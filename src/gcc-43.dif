
IMPORTANT NOTE: **** Please format patches as follows in order to comply with
all flavors of patch. ****

   *** <name>.old       Ddd Mmm DD HH:MM:SS YYYY
   --- <name>   Ddd Mmm DD HH:MM:SS YYYY

Where Ddd  = {Mon, Tue, Wed, Thu, Fri, Sat, Sun}
      Mmm  = {Jan - Dec}
      DD   = 00 - 31
      HH   = 00 - 23
      MM   = 00 - 59
      SS   = 00 - 59
      YYYY = a four digit year.

Note the ".old" extension on the old filename - any extension will do, but the
old filename must be different from the new filename.

When the old file doesn't exist, i.e. a brand new file is added, "<name>.old"
must be "/dev/null".

Patches must be generated with option -c3p and the "diff" command line not
appear in the patches themselves.

Patches must be relative to the toplevel directory.

New patches must be added at the bottom of the file.

ChangeLog entries must comply with the GNU Coding Standards and use TABs for
indentation.

ChangeLog entries must contain paths to files that are relative to the gcc/
subdirectory, except for changes at the toplevel or in other first-level
directories which must mention the full path.

ChangeLog entries must end with a line indicating the status of the patch with
regard to its integration in the official GCC tree at the FSF.

New ChangeLog entries must be added at the top of the file.

----------------------------------------------------------------
2009-05-19  Nicolas Roche <roche@adacore.com>
	* config.sub: Support mindstorms-nxt as GCC target
	* configure: Idem
	* gcc/config.gcc: Idem
	* libgcc/config.host: Idem

(Not to be submitted - local settings)

2009-04-28  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.5 - revision 146829,146915
	* resource.c (find_basic_block): Use BLOCK_FOR_INSN to look up
	a label's basic block.
	(mark_target_live_regs): Tidy and rework obsolete comments.
	Change back DF problem to LIVE.  If a label starts a basic block,
	assume that all registers that used to be live then still are.
	(init_resource_info): If a label starts a basic block, set its
	BLOCK_FOR_INSN accordingly.  Add call to df_analyze.
	(fini_resource_info): Undo the setting of BLOCK_FOR_INSN.

(Already in GCC 4.5)

2009-04-27  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.4 - revision 146834
	* rtl.h (canon_true_dependence): Adjust prototype.
	* alias.c (canon_true_dependence): Add x_addr argument.
	* cse.c (check_dependence): Adjust canon_true_dependence callers.
	* cselib.c (cselib_invalidate_mem): Likewise.
	* gcse.c (compute_transp): Likewise.
	* dse.c (scan_reads_nospill): Likewise.
	(record_store, check_mem_read_rtx): Likewise.  For non-const-or-frame
	addresses pass base->val_rtx as mem_addr, for const-or-frame addresses
	canon_base_addr of the group, plus optional offset.
	(struct group_info): Rename canon_base_mem to canon_base_addr.
	(get_group_info): Set canon_base_addr to canon_rtx of base, not
	canon_rtx of base_mem.

(Already in GCC 4.4)

2009-04-18  Eric Botcazou  <ebotcazou@adacore.com>

	* dce.c (insn_is_nop): New function.
	(delete_unmarked_insns): Do not delete NOPs at -O0.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2009-04/msg01441.html)

2009-04-16  Thomas Quinot  <quinot@adacore.com>

	Backport from GCC 4.4 - revision 134832
	* gcc.c (wrapper_string): New variable.
	(insert_wrapper): New function.
	(execute): New option -wrapper.
	* doc/invoke.texi (Overall Options): New driver option -wrapper.

(Already in GCC 4.4)

2009-04-14  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (field_byte_offset): Use the type size as the field size
	if the latter is not constant.

(Installed in GCC 4.5 on 2009-04-17 - revision 146291)

2009-04-13  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c ((pp_ada_tree_identifier): Fix regression on small c
	test suite.

(Merge with other changes in same file)

2009-04-13  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_declaration): Undo partial detection of
	abstract types which broke handling of interfaces.

(Merge with other changes in same file)

2009-04-13  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_generic_ada_node): Add 'limited' keyword when
	needed.

(Merge with other changes in same file)

2009-04-13  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (is_tagged_type): Remove dead code.
	(pp_ada_tree_identifier): Improve support for C++ operators.
	Only prefix names with package for types. Add support for standard
	bool type.
	(dump_ada_function_declaration): Fix handling of class-wide parameters.
	(dump_nested_types): Avoid handling same type multiple times.
	(print_ada_declaration): Add support for C++ constructors on non tagged
	types. Add detection of abstract types.

(Merge with other changes in same file)

2009-04-06  Eric Botcazou  <ebotcazou@adacore.com>

	* stor-layout.c (set_sizetype): Use the full precision of their
	machine mode for bitsize types.

(Installed in GCC 4.5 on 2009-04-06 - revision 145631)

2009-04-01  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from debuglocus branch
	* tree.h (struct phi_arg_d): Add locus field.
	* tree-flow-inline.h (phi_arg_location): New.
	(phi_arg_set_location): Likewise.
	(phi_arg_has_location): Likewise.
	* tree-cfgcleanup.c (remove_forwarder_block): Propagate phi argument
	location.
	* tree-inline.c (copy_phis_for_bb): Likewise.
	(setup_one_parameter): Add locus parameter, set it on the initializer.
	(initialize_inlined_parameters): Adjust calls to above function.
	* tree-into-ssa.c (rewrite_add_phi_arguments): Set argument location.
	* tree-outof-ssa.c: Define heap vector of location_t.
	(struct _elim_graph): Add location to the copy and edge lists.
	(insert_copy_on_edge): Add location to copy statement.
	(new_elim_graph): Initialize location lists.
	(clear_elim_graph): Clear edge location list.
	(delete_elim_graph): Free location lists.
	(elim_graph_add_edge): Add location support in elimination graph.
	(elim_graph_remove_succ_edge): Likewise.
	(FOR_EACH_ELIM_GRAPH_SUCC): Likewise.
	(FOR_EACH_ELIM_GRAPH_PRED): Likewise.
	(eliminate_build): Likewise.
	(elim_forward): Likewise.
	(elim_unvisited_predecessor): Likewise.
	(elim_backward): Likewise.
	(elim_create): Likewise.
	(eliminate_phi): Add location to generated copies.
	(insert_backedge_copies): Likewise.
	* tree-phinodes.c (make_phi_node): Initialize argument location.
	(resize_phi_node): Likewise.
	* tree-pretty-print.c (dump_generic_node) <PHI_NODE>: Dump lineno's.
	* tree-ssa-phiopt.c (conditional_replacement): Preserve argument
	location when merging phi nodes.
	* tree-ssa-ter.c (dump_replaceable_exprs): Dump lineno's.

(Not to be submitted)

2009-03-30  Eric Botcazou  <ebotcazou@adacore.com>

	* c-parser.c (c_parser_paren_condition): Do not set source location
	information on the condition.
	(c_parser_binary_expression): Set source location information.
	* fold-const.c (fold_truth_not_expr): Copy source location information
	from the incoming expression to the outgoing one.

(Installed in GCC 4.5 on 2009-04-21 - revision 146532)

2009-03-30  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_generic_ada_node, dump_nested_types,
	print_ada_struct_decl): Add handling of TYPE_DECLs with no TYPE_NAME
	instead of crashing.

(Merge with other changes in same file)

2009-03-24  Tristan Gingold  <gingold@adacore.com>

	* gcov.c (find_source): Use case insensitive comparaison on Windows.

(To be submitted)

2009-03-23  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa.c (useless_type_conversion_p_1): Return false for
	conversions between non-base types if the bounds are all constant
	and the target range is not a subset of the source range.

(To be submitted)

2009-03-18  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_init_constructor): Do a block move for very
	small objects as well.

(To be submitted)

2009-03-18  Eric Botcazou  <ebotcazou@adacore.com>

        * gimplify.c (gimplify_modify_expr_rhs) <VAR_DECL>: Do not do a direct
        assignment from the constructor either if the target is volatile.

(Installed in GCC 4.5 on 2009-04-23 - revision 146652)

2009-03-16  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/vxworks-unwind.h (sigcontext_for): Match code
	patterns for VxWorks 6.4 to 6.7.
	Simplify idiom to include the required regs.h file.

(To be submitted)

2009-02-27  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c: Improve indentation output.
	(is_tagged_type): New function.
	Add support for manual inheritance between classes with no vtable.
	Code cleanup.

(Merge with other changes in same file)

2009-02-18  Nicolas Roche <roche@adacore.com>

	* config/arm/t-arm-elf: Activate combinations for hard/soft float,
	arm7 and thumb-interwork.

(To be submitted [arm-elf])

2009-02-17  Jose Ruiz  <ruiz@adacore.com>

	* config.gcc (leon-*-elf*): Add sparc/t-leon.
	* config/sparc/t-leon: New file.  Generate multilibs for V7 and V8.

(Not to be submitted - local setting)

2009-02-13  Matthew Gingell  <gingell@adacore.com>

	* config.sub: Add lynxos5 to the set of canonical target
	operating systems.

(To be submitted [ppc-lynx])

2009-02-13  Olivier Hainque  <hainque@adacore.com>

	* config.gcc (powerpc-xcoff-lynxos): New target configuration.
	* config/rs6000/rs6000.h (TARGET_LYNXOS): New macro, default to 0.
	* config/lynx.h (TARGET_LYNXOS): Define to 1.
	* config/rs6000/lynx-xcoff.h: New file.
	* config/rs6000/lynx-xcoff.opt: New file.
	* config/rs6000/rs6000.c (TARGET_UNALIGNED_OPs): Don't use the
	generic xcoff definitions for Lynx, fallback to the Darwin ones.
	(print_operand_address): Handle legitimate_constant_pool addresses
	on xcoff lynx the same way as on xcoff aix.

(To be submitted [ppc-lynx])

2009-02-12  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/rs6000.c (rs6000_emit_prologue) <TARGET_SPE_ABI>:
	Invert call_used_regs test in using_static_chain_p computation.

(To be submitted)

2009-02-11  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-sink.c (statement_sink_location): Do not sink the statement
	if the RHS could trap.

(To be submitted)

2009-02-11  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-profile.c (tree_profiling): Don't profile functions produced
	for builtin stuff.

(To be submitted)

2009-02-09  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (build_range_check): Properly deal with enumeral and
	boolean base types.

(Installed in GCC 4.5 on 2009-04-12 - revision 145988)

2009-02-02  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_declaration): Use new form of pragma
	CPP_Constructor, cleaner.

(Merge with other changes in same file)

2009-01-30  Eric Botcazou  <ebotcazou@adacore.com>

	* rtl.h (insn_location): Declare.
	* cfglayout.c (insn_location): New function.
	* debug.h (struct gcc_debug_hooks): Replace source_line hook with
	source_loc hook.
	(debug_nothing_int_int_charstar): Declare.
	* debug.c (do_nothing_debug_hooks): Replace debug_nothing_int_charstar
	with debug_nothing_int_int_charstar for source_loc.
	(debug_nothing_int_int_charstar): New function.
	* dbxout.c (dbxout_source_line): Rename into...
	(dbxout_source_loc): ...this.  Add 'col' parameter.
	(dbx_debug_hooks): Replace dbxout_source_line with dbxout_source_loc.
	(xcoff_debug_hooks): Replace xcoffout_source_line with
	xcoffout_source_loc.
	(dbxout_begin_prologue): Adjust for above renaming.
	* dwarf2out.c (dwarf2out_source_line): Rename into...
	(dwarf2out_source_loc): ...this.  Add 'col' parameter and handle it.
	(dwarf2out_begin_prologue): Adjust for above renaming.
	(dwarf2_debug_hooks): Replace dwarf2out_source_line with
	dwarf2out_source_loc.
	(struct dw_line_info_struct): Add dw_col_num field.
	(struct dw_separate_line_info_struct): Likewise.
	(print_dwarf_line_table): Print the column number.
	(output_line_info): Output the column number.
	* sdbout.c (sdbout_source_line): Rename into...
	(sdbout_source_loc): ...this.  Add 'col' parameter.
	(sdb_debug_hooks): Replace sdbout_source_line with sdbout_source_loc.
	* vmsdbgout.c (vmsdbgout_source_line): Rename into...
	(vmsdbgout_source_loc): ...this.  Add 'col' parameter and handle it.
	(vmsdbg_debug_hooks): Replace vmsdbgout_source_line with
	vmsdbgout_source_loc.
	(vmsdbgout_end_prologue): Adjust for above renaming.
	(vmsdbgout_end_epilogue): Likewise.
	* xcoffout.h (xcoffout_source_line): Delete.
	(xcoffout_source_loc): Declare.
	* xcoffout.c (xcoffout_source_line): Rename into...
	(xcoffout_source_loc): ...this.  Add 'col' parameter.
	* final.c (last_colnum): New static variable.
	(request_source_line): Likewise.
	(final_start_function): Set last_colnum to 0, request_source_line
	and force_source_line to false.
	(final_scan_insn): Call source_line hook instead of source_loc.
	If flag_preserve_control_flow, request a source line after each
	control flow change.
	(notice_source_line): Use insn_location to retrieve the insn location.
	If a source line is requested, use the column.  Set the column number
	if in the middle of a line.

(To be refined before submission)

2009-01-28  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (shortcut_cond_r): Add locus parameter.  Pass it to
	recursive calls on the LHS of the operator but pass that of the
	operator to recursive calls on the RHS of the operator.  Set int
	on the COND_EXPR.
	(shortcut_cond_expr): Set the locus of the operator on the second
	COND_EXPR and that of the expression on the first in degenerate cases.
	Pass the locus of the expression to calls to shortcut_cond_r.
	Set the locus of the 'then' block on the associated jump, if any.
	(gimplify_boolean_expr): Add locus parameter.  Set it on the COND_EXPR.
	(gimplify_expr) <TRUTH_ANDIF_EXPR>: Pass the locus of the outer
	expression to call to gimplify_boolean_expr.

(Installed in GCC 4.5 on 2009-04-21 - revision 146532)

2009-01-26  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_generic_ada_node): Take const qualifier into
	account for access parameters.

(Merge with other changes in same file)

2009-01-23  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_ada_function_declaration): Add is_destructor
	parameter, and ignore extra parameters in this case. Code clean up.
	(dump_template_types, dump_ada_template): New functions.
	(dump_generic_ada_node): Remove handling of TREE_LIST, TREE_VEC,
	not needed.
	(print_destructor): Use better name for default destructor.
	(print_ada_declaration): Add handling of templates.
	Improve support of destructors.
cp/
	* decl2.c (cpp_check): Add handling of IS_TEMPLATE.

(Merge with other changes in same file)

2009-01-22  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (decide_block_copy): Do not use element copy for small
	types if no elements have been instantiated.

(To be submitted)

2009-01-17  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (TYPE_DECL_IS_STUB): Extend C++ mechanism to all types
	if the language is Ada.

(To be submitted)

2009-01-14  Arnaud Charlet  <charlet@adacore.com>

	* c-macros.c (print_ada_macros): Add handling of unsigned decimal
	macros.

(Merge with other changes in same file)

2009-01-12  Olivier Hainque  <hainque@adacore.com>

	* config/sparc/sparc.c (sparc_asm_function_epilogue): Don't output
	an extra nop past a sibling call at the very end.

(To be submitted)

2009-01-09  Jose Ruiz  <ruiz@adacore.com>

	* config/sparc/leon.h (LINK_SPEC, STARTFILE_SPEC): Rename the
	Syderal board to ICM, so the linker flag, the crt0, and linker
	script need to be renamed accordingly.

(Not to be submitted - local setting)

2009-01-06  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_generic_ada_node): Add support for subtypes of
	builtins.

(Merge with other changes in same file)

2009-01-06  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_declaration): Fix handling of subtypes of
	unions.

(Merge with other changes in same file)

2009-01-06  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_ada_import): Add support for stdcall convention

(Merge with other changes in same file)

2009-01-05  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (pp_ada_tree_identifier, print_ada_declaration): Add
	support for $ instead of . as special character as occurs under Windows

(Merge with other changes in same file)

2009-01-05  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_struct_decl): Fix handling of vptr field
	under Windows, where gcc uses _vptr$ instead of _vptr.

(Merge with other changes in same file)

2009-01-05  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_declaration, print_ada_struct_decl): Fix
	handling of static fields.
	(has_static_fields): New.

(Merge with other changes in same file)

2009-01-05  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_declaration): Fix handling of array
	subtypes.

(Merge with other changes in same file)

2008-12-28  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (dump_ada_array_type): Move up.
	(dump_generic_ada_node): Add handling of ARRAY_TYPE.
	Generate subtypes when appropriate instead of new types.

(Merge with other changes in same file)

2008-12-19  Nicolas Setton  <setton@adacore.com>

	* gcov.c (main): Add support for displaying progress info on
	standard output.
	* doc/gcov.texi: Document.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-12/msg01059.html,
 and has been approved for GCC 4.5, after the 4.4 branch)

2008-12-18  Tristan Gingold  <gingold@adacore.com>

	* libgcov.c (gcov_version): Add strict_p argument and be more
	tolerant if strict_p is false.
	(gcov_exit): Call gcov_version with strict_p set to true.
	(__gcov_init): Call gcov_version with strict_p set to false.

(To be ported, not to be submitted - local fix)

2008-12-18  Tristan Gingold  <gingold@adacore.com>

	* collect2.c (main): Handle -f option if OBJECT_FORMAT_COFF, argument
	is a filename containing additionnal input files added to the object
	vector.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2007-04/msg00636.html)

2008-12-12  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (extract_muldiv): Remove obsolete comment.
	(fold_plusminus_mult_expr): Use only positive power-of-two factors.
	* expr.c (get_inner_reference): Canonicalize offset.
	* tree-pass.h (pass_forwprop_final): Declare.
	* tree-ssa-forwprop.c (forward_propagate_into_inner_array_ref): New.
	(tree_ssa_forward_propagate_vars): New function, mostly copied from
	the following.  Call forward_propagate_into_inner_array_ref on
	inner array references during the final pass.
	(tree_ssa_forward_propagate_single_use_vars): Call above function.
	(tree_ssa_forward_propagate_final_vars): New function.
	(pass_forwprop_final): New pass.
	* passes.c (init_optimization_passes): Replace fourth pass_forwprop
	by pass_forwprop_final.

(To be revisited)

2008-12-11  Olivier Hainque  <hainque@adacore.com>

	* tree.h (tree_block): New end_locus field.
	(BLOCK_SOURCE_END_LOCATION): New accessor.
	* gimplify.c (gimplify_bind_expr): When we have it, propagate the
	BIND_EXPR_BLOCK	end location to the stack_restore code.

(To be submitted)

2008-12-09  Thomas Quinot  <quinot@adacore.com>

	* config/i386/freebsd.h (TARGET_96_ROUND_53_LONG_DOUBLE): Define to 0.

(To be ported)

2008-12-08  Olivier Hainque  <hainque@adacore.com>

	* opts.c (decode_options): Inform that -fpreserve-control-flow
	is not supported at -O > 1.

(To be refined before submission)

2008-12-06  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (check_name, dump_generic_ada_node): Improve
	handling of named access types.
	(dump_generic_ada_node): Generate "access all" for all pointer types.
	(print_ada_declaration): Do not make field aliased if it's a bit-field.

(Merge with other changes in same file)

2008-12-05  Tristan Gingold  <gingold@adacore.com>

	* config/avr/avr.c (avr_reorg): Recompute REG_DEAD notes.

(To be submitted)

2008-12-05  Nicolas Roche <roche@adacore.com>

	* config/arm/nucleus.h: New file.
	* config/arm/t-nucleus: New file.
	* config.gcc: Add arm*-*-nucleus*.
	* libcpp/configure.ac: Add arm*-*-nucleus* to list of targets
	  requiring 64-bit host wide int.
	* libcpp/configure: Regenerate.
	* libgcc/config.host: Add arm*-*-nucleus*.

(To be submitted)

2008-12-05  Arnaud Charlet  <charlet@adacore.com>

	* tree-ada-spec.c (print_ada_declaration): Handle typedef of empty
	structs.

(Merge with other changes in same file)

2008-12-02  Nicolas Roche <roche@adacore.com>

	* configure: On Windows systems symbol versionning in shared libraries
	is not supported even if GNU ld is used.

(To be submitted)

2008-11-28  Olivier Hainque  <hainque@adacore.com>

	* varasm.c (get_variable_section): Extract reloc computation into ...
	(compute_reloc_for_decl): New function.
	* output.h (compute_reloc_for_decl): Declare.
	* xcoffout.h (DBX_STATIC_BLOCK_START): Expect an extra DECL argument.
	Use it for N_STSYM to determine the csect storage class qualifier.
	* dbxout.c (dbxout_symbol_location): Adjust DBX_STATIC_BLOCK_START
	invocation to pass the decl argument.

(To be submitted)

2008-11-28  Arnaud Charlet  <charlet@adacore.com>

	* c-macros.c (print_ada_macros): Fix handling of NULL macro and
	unsigned ints.
	* tree-ada-spec.c (pp_ada_tree_identifier): Compare keywords
	ignoring casing.

(Merge with other changes in same file)

2008-11-27  Arnaud Charlet  <charlet@adacore.com>
	    Matthew Gingell  <gingell@adacore.com>

	* c-decl.c (for_each_global_decl, collect_source_ref,
	collect_source_ref_cb, dump_ads): New functions.
	(c_write_global_declarations): Add handling of -fdump-ada-spec.
	* c-lex.c (c_lex_with_flags): Add handling of CPP_COMMENT.
	* diagnostic.h (print_generic_ada_decl, get_ada_package, decl_sloc,
	collect_ada_nodes, dump_ada_nodes, reset_ada_withs, dump_ada_withs,
	dump_ada_macros): Declare.
	* gcc.c: Add support for -C without -E and for -fdump-ada-spec.
	* Makefile.in (C_AND_OBJC_OBJS): Add c-macros.o
	(OBJS-common): Add tree-ada-spec.o.
	* tree-dump.c (dump_files): Add ada-spec.
	(FIRST_AUTO_NUMBERED_DUMP): Bump to 8.
	* tree-pass.h (tree_dump_index): Add TDI_ada.
	* c-macros.c, tree-ada-spec.c: New files.
cp/
	* decl2.c: Include langhooks.h and diagnostic.h.
	(cpp_check, collect_source_ref, collect_source_refs,
	collect_ada_namespace): New functions.
	(cp_write_global_declarations): Add handling of -fdump-ada-spec.
	* lang-specs.h: Add handling of -fdump-ada-spec.
	* Make-lang.in (CXX_C_OBJS): Add c-macros.o.

(Work in progress. To be refined, and then submitted)

2008-11-25  Tristan Gingold  <gingold@adacore.com>

	* config/avr/avr.c (expand_prologue): Set
	current_function_static_stack_size.

(To be submitted)

2008-11-21  Jose Ruiz  <ruiz@adacore.com>

	* config/sparc/sol2-unwind.h (sparc_fallback_frame_state):
	Add support for Solaris 8 running inside Solaris Containers.

(To be submitted)

2008-11-20  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.4 - revision 134729
	* targhooks.h (default_emutls_var_fields,
	default_emutls_var_init): Declare.
	* tree.h (DECL_THREAD_LOCAL): Compare against TLS_MODEL_REAL.
	* target.h (struct gcc_target): Add struct emutls member.
	* target-def.h (TARGET_EMUTLS_GET_ADDRESS,
	TARGET_EMUTLS_REGISTER_COMMON, TARGET_EMUTLS_VAR_SECTION,
	TARGET_EMUTLS_TMPL_SECTION, TARGET_EMUTLS_VAR_PREFIX,
	TARGET_EMUTLS_TMPL_PREFIX, TARGET_EMUTLS_VAR_FIELDS,
	TARGET_EMUTLS_VAR_INIT, TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS,
	TARGET_EMUTLS_VAR_ALIGN_FIXED, TARGET_EMUTLS): New.
	(TARGET_INITIALIZER): Add TARGET_EMUTLS.
	* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS,
	BUILT_IN_EMUTLS_REGISTER_COMMON): Get name from targetm structure.
	* dwarf2out.c (loc_descriptor_from_tree_1): Check if emutls can
	emit debug information.
	* coretypes.h (tls_model): Add TLS_MODEL_EMULATED, TLS_MODEL_REAL.
	* varasm.c: Include targhooks.h.
	(emutls_object_section, emutls_tmpl_section): New.
	(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): Remove.
	(EMUTLS_SEPARATOR): New.
	(prefix_name): New.
	(get_emutls_object_name): New.
	(default_emutls_var_fields): New, broken out of ...
	(get_emutls_object_type): ... here.  Adjust to use target hooks.
	(get_emutls_init_templ_addr): Adjust to use target hooks.
	(emutls_decl): Adjust to use target hooks.
	(emutls_finish): Likewise.
	(default_emutls_var_init): New, broken out of ...
	(assemble_variable): ... here.  Adjust to use target hooks.
	* output.h (enum section_category): Add SECCAT_EMUTLS_VAR,
	SECCAT_EMUTLS_TMPL.
	* c-common.c (handle_section_attribute): Prevent overriding
	sections for emulated tls with special sections.
	* config/i386/i386.c (x86_64_elf_select_section): Add
	SECCAT_EMUTLS_VAR and SECCAT_EMUTLS_TMPL.
	(x86_64_elf_unique_section): Likewise.
	* config/vxworks.c: Include tree.h.
	(vxworks_emutls_var_fields, vxworks_emutls_var_init): New.
	(vxworks_override_options): Set TLS scheme.
	* gcc/doc/tm.texi (Emulated TLS): New node.

(Already in GCC 4.4)

2008-11-18  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_type): Be prepared to deal with subtypes.
	* dwarf2out.c (base_type_die): Likewise.
	(is_subrange_type): Delete.
	(modified_type_die): Call subrange_type_for_debug_p.
	* tree.c (subrange_type_for_debug_p): New predicate based on the
	former is_subrange_type.
	* tree.h (subrange_type_for_debug_p): Declare.

(To be submitted)

2008-11-07  Jose Ruiz  <ruiz@adacore.com>

	* config/sparc/leon.h (LINK_SPEC, STARTFILE_SPEC): Add support
	to select the startup routine and linker script for the Syderal
	ICSDM board.

(Not to be submitted - local setting)

2008-11-06  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.4 - revision 139800
	* ipa-inline.c (cgraph_estimate_growth): Discover self recursive
	functions.

(Already in GCC 4.4)

2008-11-05  Olivier Hainque  <hainque@adacore.com>

	Partial backport from GCC 4.4 - revision 133825
	* config/i386/cygming.h (ASM_OUTPUT_DWARF_OFFSET): Add 8
	byte offsets for 64-bit mingw.
	* config/i386/i386.c (ix86_pass_by_reference): Correct
	calling abi for 64-bit mingw.
	(return_in_memory_ms_64): Likewise.
	(function_value_ms_64): Likewise.
	(function_arg_ms_64): Handle BLKmode.

(Already in GCC 4.4)

2008-11-05  Olivier Hainque  <hainque@adacore.com>

	* tree.h (CONSTRUCTOR_BITFIELD_P): True if NODE, a FIELD_DECL, is
	to be processed as a bitfield for constructor output purposes.
	* varasm.c (output_constructor): Use it.

(To be submitted)

2008-11-04  Tristan Gingold  <gingold@adacore.com>

	* config/i386/darwin.h: Define STACK_CHECK_STATIC_BUILTIN and
	STACK_CHECK_PROTECT.

(To be submitted)

2008-10-29  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/i386.c (classify_argument) <ARRAY_TYPE>: Promote partial
	integer class to full integer class if the offset is not word-aligned.

(Installed in GCC 4.4 on 2008-11-03 - revision 141559)

2008-10-28  Olivier Hainque  <hainque@adacore.com>

	Revert changes introduced in fsf revision 124006:
	* config/rs6000/sysv4.h (STARTFILE_DEFAULT_SPEC): Include
	ecrti.o and crtbegin.o.
	(LIB_DEFAULT_SPEC): Include -lc.
	(ENDFILE_DEFAULT_SPEC): Include crtend.o and ecrtn.o.

(Not to be submitted - local setting)

2008-10-26  Eric Botcazou  <ebotcazou@adacore.com>

	* calls.c (store_unaligned_arguments_into_pseudos): Also look into the
	actual alignment of the argument if it lives in memory.

(Installed in GCC 4.4 on 2008-11-10 - revision 141742)

2008-10-20  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/vxworks.h (SUBSUBTARGET_OVERRIDE_OPTIONS): When
	forcing SPE from E500, be careful not to downgrade float_gprs.

(To be submitted)

2008-10-19  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.4
	* basic-block.h (struct edge_def): Add goto_block field.
	* rtl.h (locator_eq): Declare.
	* cfgcleanup.c (try_forward_edges): Avoid the optimization if
	there is more than one edge or insn locator along the forwarding
	edges and !optimize.  If there is just one, set e->goto_locus.
	* cfgexpand.c (expand_gimple_cond_expr): Convert goto_block and
	goto_locus into RTL locator.  For unconditional jump use that
	locator for the jump insn.
	(expand_gimple_basic_block): Likewise.
	* cfglayout.c (locator_scope): New function.
	(insn_scope): Use it.
	(locator_eq): New function.
	(fixup_reorder_chain): Ensure that there is at least one insn with
	locus corresponding to edge's goto_locus if !optimize.
	* cfgrtl.c (force_nonfallthru_and_redirect): Use goto_locus for
	emitted jumps.
	(cfg_layout_merge_blocks): Emit a nop with edge's goto_locus
	locator in between the merged basic blocks if !optimize and needed.
	* gimple-low.c (lower_function_body, lower_return_expr,
	lower_builtin_setjmp): Set block on the newly created stmts.
	* profile.c (branch_prob): Copy edge's goto_block.
	* tree-cfg.c (make_cond_expr_edges, make_goto_expr_edges): Set also
	edge's goto_block.
	(move_block_to_fn): Adjust edge's goto_block.
	* tree-ssa-live.c (remove_unused_locals): Mark all edge's goto_block
	as used.

(Already in GCC 4.4)

2008-10-17  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_parms): Deal minimally with CONCATN of registers.
	Fetch the inner REG inside a PARALLEL.

(To be submitted)

2008-10-16  Olivier Hainque  <hainque@adacore.com>

	* config/i386/i386.md (allocate_stack_worker_32/64): Revert to
	an explicit (clobber (match_scratch)) scheme to expose clobbering
	of eax.
	(allocate_stack_worker_32/64_postreload): New expanders, with
	match_dup instead of match_scratch for postreload expansions.
	* config/i386/i386.c (ix86_expand_prologue): Use postreload variant
	of the stack_worker expanders.

(To be submitted)

2008-10-15  Geert Bosch  <bosch@adacore.com>

	* config/ia64/hpux.h (WIDEST_HARDWARE_FP_SIZE): Define to 64, the
	widest type supported by both the OS and the hardware.

(Not to be submitted - no Ada support at the FSF)

2008-10-15  Bernard Banner  <banner@adacore.com>

	* config/ia64/hpux.h (CC1_SPEC): Define to use LP64 mode by default.
	(ASM_SPEC): Likewise.
	(ASM_EXTRA_SPEC): Tweak to use LP64 mode by default.
	(STARTFILE_SPEC): Likewise

(To be submitted after rework as a new configuration option)

2008-10-15  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-pass.h (pass_fast_rtl_dce_no_opt): Declare.
	* dce.c (gate_fast_dce_no_opt): New gate function.
	(pass_fast_rtl_dce_no_opt): New pass.
	* passes.c (init_optimization_passes): Register it.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2009-04/msg01441.html)

2008-10-14  Eric Botcazou  <ebotcazou@adacore.com>

	* doc/invoke.texi (Overall Options): Document IDL input language.
	* c.opt (lang-idl): New option.
	* c-opts.c (c_common_init_options): Enable C++ options for -lang-idl.
	(c_common_handle_option) <OPT_lang_idl>: New case.
	* gcc.c (default_compilers): Add IDL input language.

(Not to be submitted - local kludge)

2008-10-14  Olivier Hainque  <hainque@adacore.com>

	* gcse.c (try_replace_reg): On single-set replacement failure,
	only attach a REG_EQUAL note to the insn if the destination is
	a register.
	* fwprop.c (forward_propagate_and_simplify): Likewise.

(To be submitted)

2008-10-13  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.4 - revision 133403
	* tree-ssa-loop-ivopts.c (force_expr_to_var_cost): Use
	is_gimple_min_invariant instead of TREE_INVARIANT.

(Already in GCC 4.4)

2008-10-13  Olivier Hainque  <hainque@adacore.com>

	* doc/tm.texi (GO_IF_MAY_NARROW_ACCESS_TO): New macro.  Go to
	LABEL if ADDR, a legitimate address expression for MODE, may
	be accessed using a narrower mode for the purpose of an "offsettable"
	reference.
	* recog.c (GO_IF_MAY_NARROW_ACCESS_TO): Default definition.  Win if
	ADDR is mode independent.
	(may_narrow_access_to): New predicate. Wrapper around the new GO_IF
	macro for an address and a mode.
	(offsettable_address_p): Use it instead of mode_dependent_address_p.
	* config/rs6000/rs6000.h (GO_IF_MAY_NARROW_ACCESS_TO): Map to ...
	* config/rs6000/rs6000.c (rs6000_may_narrow_access_to): New function.
	Negation of the current rs6000_mode_dependent_address without the
	CONST_INT offsets tweaks.
	(rs6000_mode_dependent_address): Always return true for PLUS CONST_INT
	and adjust head comment accordingly.
	* config/rs6000/rs6000-protos.h (rs6000_may_narrow_access_to): Declare.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2007-06/msg00767.html,
 To be revised post IRA merge)

2008-10-13  Jerome Lambourg  <lambourg@adacore.com>

	* config/i386/linux.h (LIB_SPEC): Redefine - use libgnatmon for
	profiling.
	* config/i386/linux64.h (LIB_SPEC): Likewise.
	* config/i386/mingw32.h (LIB_SPEC): Use libgnatmon for profiling
	instead of libgmon.
	* config/sol2.h (LIB_SPEC): Use libgnatmon when profiling.

(Not to be submitted - local setting)

2008-10-12  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.h (contains_packed_reference): Mention ARRAY_RANGE_REF in
	head comment.
	(array_ref_element_size): Likewise.
	(array_ref_low_bound): Likewise.
	(array_ref_up_bound): Likewise.
	* expr.c (contains_packed_reference): Likewise.
	(array_ref_element_size): Likewise.
	(array_ref_low_bound): Likewise.
	(array_ref_up_bound): Likewise.
	* tree-ssa-loop-ivopts.c (idx_contains_abnormal_ssa_name_p): Deal
	with ARRAY_RANGE_REF.
	(idx_find_step): Likewise.
	(idx_record_use): Likewise.
	(strip_offset_1): Likewise.
	(idx_remove_ssa_names): Likewise.

(Installed in GCC 4.4 on 2008-10-11 - revision 141065)

2008-10-10  Romain Berrendonner  <berrendo@adacore.com>

	* gcc.c: Adapt message to our bug_report_url.
	* gcov.c: Likewise.

(Not to be submitted - local setting)

2008-10-09  Tristan Gingold  <gingold@adacore.com>
            Anatoly Sokolov  <aesok@post.ru>

	* config/avr/avr.md ("call_prologue_saves"): Use hi8(gs())/lo8(gs())
	instead of pm_lo8/pm_hi8 to makes this call working on avr6.
	* config/avr/avr.c (expand_prologue): Tune "call_prologue"
	optimization for 'avr6' architecture.

(Installed in GCC 4.4 on 2008-05-26 - revision 135953)

2008-10-07  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (force_location_on_expr_r): New walk_tree callback.
	(force_location_on_expr): New function.
	(gimplify_call_expr): Use it to force the source location on
	the argument preparation statements.

(To be submitted)

2008-10-07  Nicolas Roche  <roche@adacore.com>

	* fixincludes/fixinc.in: Use explicit path when calling config.guess.

(To be submitted)

2008-10-06  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_symbol) <PARM_DECL>: Deal with parameters pointing
	to variables for debugging purposes.

(To be submitted)

2008-10-06  Olivier Hainque  <hainque@adacore.com>

	* collect2.c (may_unlink_output_file): New global.
	(maybe_unlink): Honor it.
	* collect2.h: Add extern for it.
	* tlink.c (do_tlink): Set it to true if the link succeeded.

(To be submitted)

2008-10-05  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-live.c (remove_unused_scope_block_p): Update TREE_USED bit.

(Installed in GCC 4.5 on 2009-04-17 - revision 146289)

2008-10-05  Matthew Gingell  <gingell@adacore.com>
	    Arnaud Charlet  <charlet@adacore.com>

	* include/cpplib.h (cpp_comments, cpp_comment_table): New structs.
	(cpp_get_comments): New function.
	* internal.h (struct cpp_reader): Add comments field.
	* init.c (cpp_destroy): Free comments.
	* lex.c (store_comment, cpp_get_comments): New functions.
	(comments): New struct.
	(save_comment): Store comments in comments struct.

(Installed in GCC 4.4 on 2008-10-05 - revision 140883)

2008-10-03  Nicolas Roche  <roche@adacore.com>

	* config/mh-ppc-aix (LDFLAGS): Quote $(CC).

(To be submitted [ppc-aix])

2008-10-03  Olivier Hainque  <hainque@adacore.com>

	Stack realignment compatibility with mcount profiling calls on x86:
	* config/i386/i386.h (MCOUNT_PRESERVES_ALL_REGS): New target specific
	configuration macro.  Defaults to 1.
	(PROFILE_COUNT_REGISTER): Replaced register name string by ...
	(PROFILE_COUNT_REGNUM): GCC regno for the mcount register argument
	expected to hold the address of the function specific counter unless
	NO_PROFILE_COUNTERS is defined.
	* config/i386/i386.c (x86_function_profiler): Split into ...
	(x86_64_function_profiler): 64bit ABI implementation, and ...
	(x86_32_function_profiler): 32bit ABI implementation, enhanced to
	save/restore the internal arg pointer used to support local stack
	realignment, if any, when either !MCOUNT_PRESERVES_ALL_REGS or
	PROFILE_COUNT_REGNUM is the same and needed as an mcount argument.
	(X86_SET_PROFILE_COUNTERS): New local macro, always defined.  Conveys
	whether NO_PROFILE_COUNTERS is defined or not.
	* config/i386/sol2.h (MCOUNT_PRESERVES_ALL_REGS): Override to 0.
	* config/i386/freebsd.h (MCOUNT_PRESERVES_ALL_REGS): Likewise.

(To be reevaluated vs the new stack realignment code in 4.4 [x86])

2008-10-03  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris.h (DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET):
	Define to 1.

(Not to be submitted - local setting [mips-irix])

2008-10-03  Olivier Hainque  <hainque@adacore.com>

	dwarf2out support for debuggers missing location lists capabilities:
	* doc/tm.texi (DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET): New
	macro. Document, then ...
	* defaults.h: Default to 0, and ...
	* dwarf2out.c (add_location_or_const_value_attribute): Comment on the
	expected result of lookup_decl_loc if LOCATION_LISTS_SUPPORT_MISSING.
	(gen_subprogram_die): If LOCATION_LISTS_SUPPORT_MISSING, don't define
	frame_base as the CFA.  Fallback to the	previous stack/frame pointer
	use instead.
	* toplev.c (process_options): If generating DWARF2 debug info and
	LOCATION_LISTS_SUPPORT_MISSING, disable var_tracking.

(Not to be submitted - local twist to accommodate old GDBs)

2008-10-02  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/rs6000.c (TARGET_INTERRUPTS_CLOBBER_STACK): New
	port specific macro, document and define default value.
	(rs6000_emit_stack_tie): Accept a STRONG_P argument to control
	the stack_tie reference alias set.
	(rs6000_emit_prologue, rs6000_emit_prologue): Emit strong stack
	tie if TARGET_INTERRUPTS_CLOBBER_STACK.
	* config/rs6000/vxworks.h (TARGET_INTERRUPTS_CLOBBER_STACK): Define
	to 1.

(To be submitted - PR 16900 [ppc-vxworks])

2008-10-02  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.h (DECL_IGNORED_P): Document further effect for FUNCTION_DECL.
	* dbxout.c (dbxout_function_end): Do not test DECL_IGNORED_P.
	(dbxout_begin_function): Likewise.
	* final.c (dwarf2_debug_info_emitted_p): New predicate.
	(final_start_function): Do not emit debug info if DECL_IGNORED_P is
	set on the function.
	(final_end_function): Likewise.
	(final_scan_insn): Likewise.
	(rest_of_handle_final): Likewise.
	* varasm.c (assemble_start_function): Likewise.
	* config/rs6000/xcoff.h (ASM_DECLARE_FUNCTION_NAME): Likewise.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2009-04/msg01796.html)

2008-10-02  Olivier Hainque  <hainque@adacore.com>

	* expr.c (convert_move): Latch mem integer inputs into a
	register before expanding a multi-instructions sequence.

(To be submitted)

2008-10-01  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (NO_DBX_FUNCTION_END): Delete.
	(NO_DBX_BNSYM_ENSYM): Likewise.
	(DBX_BNSYM_ENSYM): Define if not defined.
	(dbxout_function_end): Delete uses of NO_DBX_FUNCTION_END and replace
	uses of NO_DBX_BNSYM_ENSYM with DBX_BNSYM_ENSYM.  Add DBX_OUTPUT_NFUN.
	(dbxout_begin_prologue): Likewise.
	* mips-tfile.c (section_headers): New static variable.
	(rdata_vaddr): Likewise.
	(rdata_ptr): Likewise.
	(parse_stabs_common): Deal with special N_FUN with empty string.
	(copy_object): Read section headers and contents of .rdata section.
	* doc/tm.texi (DBX Options): Delete NO_DBX_FUNCTION_END and replace
	NO_DBX_BNSYM_ENSYM with DBX_BNSYM_ENSYM.  Adjust DBX_OUTPUT_NFUN.
	* config/darwin.h (DBX_BNSYM_ENSYM): Define to 1.
	* config/alpha/alpha.h (DBX_CONTIN_LENGTH): Move to...
	(NO_DBX_FUNCTION_END): Delete.
	 * config/alpha/osf.h (DBX_CONTIN_LENGTH): ...here.
	(DBX_OUTPUT_NFUN): Define.

(To be submitted)

2008-10-01  Olivier Hainque  <hainque@adacore.com>

	* dbxout.c (SCOPE_LABEL_BASENAME): New local macro.  Use it instead
	of a hardcoded "Lscope" in several places, all below.
	(dbxout_end_epilogue): New hook.  Emit the function scope label
	here instead of ...
	(dbxout_function_end): here. Process targets without named sections
	as the others.
	(dbxout_block): Adjust comment mentioning where the label is emitted.

(To be submitted)

2008-10-01  Olivier Hainque  <hainque@adacore.com>

	Part of support for pragma Persistent_BSS
	* varasm.c (default_section_type_flags): Flag .persistent.bss
	sections as SECTION_BSS too.

(To be submitted)

2008-10-01  Olivier Hainque  <hainque@adacore.com>

	* dbxout.c (PREVENT_STATIC_DEBUG_ONLY_BLOCKS): New internal macro.
	(dbxout_symbol_location): Make a static block for static debug-only
	symbols if !PREVENT_STATIC_DEBUG_ONLY_BLOCKS.

(To be submitted)

2008-10-01  Tristan Gingold  <gingold@adacore.com>

	* dwarf2out.c (rtl_for_decl_location): Handle CONST_DECL.
	(gen_decl_die): Generate a DIE for a CONST_DECL unless ENUMERAL_TYPE.
	(dwarf2out_decl): Likewise.
	(add_location_or_const_value_attribute): Accept CONST_DECL.
	(loc_descriptor_from_tree_1): Handle CONST_DECL and COMPLEX_CST.

(To be submitted)

2008-10-01  Tristan Gingold  <gingold@adacore.com>

	* common.opt (fpreserve-control-flow): New option.
	* doc/invoke.texi: Document it.
	* tree-ssa-phiopt.c (gate_phiopt): Disable if we are to
	preserve control flow.
	* opts.c (decode_options): Disable if-conversion if we are to
	preserve control flow.
	* fold-const.c (combine_comparisons): Disable optimizations
	over short-circuit operators if we are to preserve control flow.
	(fold_range_test, fold_truthop, fold_binary): Likewise.
	* doc/gcov.texi (Precise Decision Coverage): New section.

(To be refined before submission)

2008-09-29  Geert Bosch  <bosch@adacore.com>

	* tree.c (contains_placeholder_p): Return 0 for a SAVE_EXPR.

(Installed in GCC 4.4 on 2008-10-01 - revision 140819)

2008-09-29  Olivier Hainque  <hainque@adacore.com>

	* config/gthr-vxworks.h (pthread_once_t): Force alignment
	of the 'busy' field to 4.

(To be submitted)

2008-09-28  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (constant_size): Use HOST_WIDE_INT in parameter type.

(Installed in GCC 4.4 on 2008-09-29 - revision 140769)

2008-09-27  Olivier Hainque  <hainque@adacore.com>

	* config/i386/vx-common.h (DBX_REGISTER_NUMBER): Define.

(To be submitted)

2008-09-25  Eric Botcazou  <ebotcazou@adacore.com>

	* expmed.c (store_fixed_bit_field): Always use convert_to_mode in
	order to convert between modes.
	(extract_bit_field_1): Test TRULY_NOOP_TRUNCATION on the right mode.

(Installed in GCC 4.4 on 2008-09-28 - revision 140730)

2008-09-24  Nicolas Roche  <roche@adacore.com>

	* gcc/config/rs6000/vxworks-unwind.h: _Unwind_FrameState structure has
	changed. CR_* are now defined in rs6000.md and no more in rs6000.h. 
	So include insn-constants.h in order to have access to this constants.
	* gcc/config/rs6000/vxworks.h: Condition definition of 
	MD_UNWIND_SUPPORT on _WRS_KERNEL_ macro.

(To be submitted)

2008-09-24  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (expand_expr_real_1) <normal_inner_ref>: Force op0 to
	non-constant memory if it cannot be forced to constant memory.
	Overhaul surrounding code and factor out common condition.

(Installed in GCC 4.4 on 2008-09-29 - revision 140760)

2008-09-24  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/vxworks.h (CC1_SPEC): Default to -mlongcall.

(Not to be submitted - local setting [ppc-vxworks])

2008-09-24  Olivier Hainque  <hainque@adacore.com>

	Turn -mstrict-align on by default on relevant ppc cross ports:
	* config/rs6000/strict-align.h: New file.  Define SUBTARGET_DEFAULT
	to MASK_STRICT_ALIGN.
	* config.gcc <powerpc-*-(elf|eabi)*>: Add strict-align.h to the list
	of target configuration files.

(Not to be submitted - local setting [ppc-cross])

2008-09-24  Olivier Hainque  <hainque@adacore.com>

	Support for subtarget default flags on ppc:
	* config/rs6000/rs6000.h (SUBTARGET_DEFAULT): New macro.  Extra
	default flags to be set on a per subtarget basis.  Default to 0.
	* config/rs6000/rs6000.c (TARGET_DEFAULT_TARGET_FLAGS): Honor it.

(To be submitted)

2008-09-24  Nicolas Roche  <roche@adacore.com>

	* configure: Disable libiberty, libffi,... on powerpc-eabispe.

(To be submitted)

2008-09-23  Nicolas Roche  <roche@adacore.com>

	* config/rs6000/tramp.asm: Use long call when setting trampoline.
	* config/rs6000/t-vxworks: Compile libgcc with -mlongcall.

(To be submitted)

2008-09-23  Nicolas Roche  <roche@adacore.com>

	Add support for erc32-elf and leon-elf:
	* configure: Add match for erc32-elf and leon-elf.
	* config.sub: Idem.
	* libgcc/config.host: Idem.
	* config.gcc: Idem.
	* config/sparc/erc32.h: New file.
	* config/sparc/leon.h: New file.

(Not to be submitted - Part of H703-003)

2008-09-19  Pascal Obry  <obry@adacore.com>

	Fix gcov dirsep handling on DOS based file systems:
	* gcov.c (create_file_names): Use IS_DIR_SEPARATOR instead
	of hardcoded '/'.
	(l_strchr, l_strrchr): New functions, searching for DIR_SEPARATOR.
	(make_gcov_file_name): Use them instead of the base C library
	instances to search for hardcoded '/'.

(Variant installed in GCC 4.4 on 2008-10-03 - revision 140854)
	
2008-09-18  Tristan Gingold  <gingold@adacore.com>

	* profile.c (branch_prob): Also call output_location on expression
	of a MODIFY_EXPR or GIMPLE_MODIFY_STMT.

(To be submitted)

2008-09-18  Nicolas Roche  <roche@adacore.com>

	* config/vxworks.h: Make sure __RTP__ is defined when -mrtp is used
	and _WRS_KERNEL otherwise.

(To be exercised)

2008-09-17  Olivier Hainque  <hainque@adacore.com>

	* expr.c (target_align): Return 1 for BIT_FIELD_REF.

(To be refined)

2008-09-17  Olivier Hainque  <hainque@adacore.com>

	* expr.c (target_align): New function.  Alignment the target of an
	assignment may be assume to have.
	(highest_pow2_factor_for_target): Use it instead of relying on
	immediate tree attributes of TARGET, which may not be honored if
	there are outer bitfields involved.

(To be submitted)

2008-09-17  Eric Botcazou  <ebotcazou@adacore.com>

	* varasm.c (initializer_constant_valid_p): Forbid view-conversions
	from aggregate to non-aggregate type if the bit pattern is not fully
	preserved afterwards.

(Installed in GCC 4.4 on 2008-09-17 - revision 140432)

2008-09-17  Thomas Quinot  <quinot@adacore.com>

	* config/i386/freebsd.h (MD_UNWIND_SUPPORT): Define.
	* config/i386/freebsd-unwind.h: New file.

(To be submitted)

2008-09-16  Nicolas Setton  <setton@adacore.com>

	* dwarf2out.c (add_type_attribute): Do not use the inner type when the
	type is a subrange type of an integral type, since subrange type DIEs
	are now properly generated in this case.

(To be submitted)

2008-09-15  Olivier Hainque  <hainque@adacore.com>

	* config/mips/mips.h (WIDEST_HARDWARE_FP_SIZE): Define.

(To be submitted [mips])

2008-09-15  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris6.h (IRIX_SUBTARGET_LINK_SPEC): Disable all
	linker warnings.

(Not to be submitted - local setting [mips-irix])

2008-09-15  Eric Botcazou  <ebotcazou@adacore.com>

	* rtl.h (non_final_source_line): Declare.
	* cfglayout.c (non_final_source_line): New function.
	* final.c (final_scan_insn): Do not force a source line after the
	prologue if that of the next instruction is not the final one.

(To be submitted)

2008-09-13  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_global_decl): Skip local static variables.

(To be submitted)

2008-09-13  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_parms): Restore adjustment lost in translation.

(To be submitted)

2008-09-13  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_symbol_location): Be prepared for file scope in
	the special (MEM (CONST (...))) case too.
	Deal with null address specially if DBX_STATIC_BLOCK_START.

(To be submitted)

2008-09-13  Nicolas Setton  <setton@adacore.com>

	* dbxout.c (dbxout_reg_parms): Output informations for parameters
	that live in memory, when DECL_RTL indicates a pseudo-register.

(To be submitted)

2008-09-13  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_expand_expr): Add TYPE parameter and adjust.
	<INDIRECT_REF>: New case.
	(dbxout_symbol): Adjust for above change.

(To be submitted)

2008-09-12  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.h (dbxout_static_link): Declare.
	* dbxout.c (static_link_var): New static variable.
	(dbxout_init): Initialize it with "__link" name.
	(dbxout_begin_function): Call dbxout_static_link if needed.
	(dbxout_static_link): New function.
	* xcoffout.c: Include function.h.
	(xcoffout_begin_prologue): Call dbxout_static_link if needed.
	* Makefile.in (xcoffout.o): Depend on function.h.
	* function.c (instantiate_decls): Process the static chain.
	(expand_function_start): If not optimizing, save the static chain
	onto the stack.
	* tree-nested.c (struct nesting_info): Add address_taken field.
	(mark_reachable_function_1): Add address_taken parameter.
	Set the field of the same name for the function if it is set.
	(mark_reachable_functions_1): Adjust calls to above functions.
	(convert_nonlocal_reference): Do not create a debug decl by default.
	(convert_local_reference): Likewise.  Declare the transformation
	of variables and parameters for debugging purposes.
	(convert_all_function_calls): Always create the static chain for
	nested functions if not optimizing, unless causing trampolines.

(To be submitted)

2008-09-11  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris6.h (MD_UNWIND_SUPPORT): Define.
	* config/mips/iris6-unwind.h: New file.

(To be submitted)

2008-09-09  Nicolas Setton  <setton@adacore.com>

	* config/i386/darwin.h (PREFERRED_DEBUGGING_TYPE): Set to
	DWARF2_DEBUG regardless of the target.

(Not to be submitted: this is only relevant as long as we are building
 on Tiger, and will be removed when all our build machines are running
 Leopard or later)

2008-09-07  Eric Botcazou  <ebotcazou@adacore.com>

	* config/alpha/alpha.c (alpha_in_small_data_p): Compile only for ELF.
	(TARGET_IN_SMALL_DATA_P): Define only for ELF.

(To be submitted)

2008-09-07  Eric Botcazou  <ebotcazou@adacore.com>

	* config/alpha/osf5.h (ASM_OUTPUT_ALIGNED_LOCAL): New macro
	(ASM_OUTPUT_ALIGNED_BSS): Likewise.

(To be submitted)

2008-09-07  Eric Botcazou  <ebotcazou@adacore.com>

	* config/rs6000/rs6000.c (rs6000_output_function_entry): Use
	RS6000_OUTPUT_BASENAME unconditionally.
	(rs6000_output_function_epilogue): Likewise.

(To be submitted)

2008-09-07  Nicolas Roche  <roche@adacore.com>

	* Makefile.in (gcc-no-fixedincludes): Avoid recompilation during
	installation when using install-no-fixedincludes target.

(To be submitted)

2008-09-02  Olivier Hainque  <hainque@adacore.com>
            Jose Ruiz  <ruiz@adacore.com>

	* config/alpha/alpha.h (DWARF_FRAME_REGNUM): Define.
	* config/alpha/osf5.h (MD_UNWIND_SUPPORT): Likewise.
	* config/alpha/osf5-unwind.h: New file.

(To be submitted)

2008-09-02  Olivier Hainque  <hainque@adacore.com>

	* config/alpha/t-osf4 (SHLIB_LINK): Do not hide the dummy weak
	pthread symbols.

(To be submitted)

2008-09-01  Olivier Hainque  <hainque@adacore.com>

	* config/pa/pa.c (output_call): Don't attempt the return address
	adjustment optimization if we're generating call frame information.

(To be ported/submitted [pa-hpux])

2008-09-01  Olivier Hainque  <hainque@adacore.com>

	Tweaks to accommodate the need for backtraces via system library:
	* config/pa/pa.c (pa_output_function_prologue): Adjust the CALLINFO
	generation to help the support of backtraces using the hpux
	unwinding library.
	* config/pa/pa.h (FRAME_POINTER_REQUIRED): Force to 1 to ease
	backtrace computations using the hpux unwinding library, only
	device able to backtrace through non GCC code properly.

(Not to be submitted - local tweaks for backtraces [pa-hpux])

2008-09-01  Olivier Hainque  <hainque@adacore.com>

	Unwinding fallback for ppc-vxworks5:
	* config/rs6000/vxworks.h (MD_UNWIND_SUPPORT): Define.
	* config/rs6000/vxworks-unwind.h: New file.

(To be submitted)

2008-09-01  Olivier Hainque  <hainque@adacore.com>

	Base support for table driven eh on ppc-vxworks5:
	* config.gcc <powerpc-*-vxworks*> (extra_parts): Define to include
	the crtstuff objects we will be relying on.
	* config/rs6000/vxworks.h (STARTFILE_SPEC, ENDFILE_SPEC,
	HAS_INIT_SECTION, USE_EH_FRAME_REGISTRY, INIT_SECTION_ASM_OP,
	INIT_SECTION_FUNCTION):	Adjust definitions to use tailored crtstuff
	objects when -static or -dynamic is on the command line.
	(DWARF2_UNWIND_INFO): Redefine to 1.
	* crtstuff.c: Undef JCR_SECTION_NAME for VxWorks.
	<CRTBEGIN> (_ctors, _dtors): Define for VxWorks, unless -static.
	(__module_has_ctors): Always define for VxWorks.

(To be ported/submitted [ppc-vxworks])

2008-08-20  Tristan Gingold  <gingold@adacore.com>

	* gcov.c (create_file_names): If no object directory is specified,
	keep directories of file_name.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-08/msg01389.html)

2008-08-19  Tristan Gingold  <gingold@adacore.com>

	* gcov.c (main): Call expandargv.

(Installed in GCC 4.4 on 2008-08-29, svn revision 139759)

2008-08-17  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/aix52.h (MD_UNWIND_SUPPORT): Define.
	* config/rs6000/aix53.h (MD_UNWIND_SUPPORT): Likewise.
	* config/rs6000/aix-unwind.h: New file.

(To be submitted)

2008-08-01  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/rs6000.c (rs6000_reg_live_or_pic_offset_p):
	If current_function_calls_eh_return, claim live all registers
	that we need to check for liveness otherwise.

(To be submitted)

2008-07-30  Olivier Hainque  <hainque@adacore.com>

	* scan.c (make_sstring_space): Add explicit conversions of
	allocator's return value.
	* fix-header.c (recognized_function): Likewise.

(Installed in GCC 4.4 on 2008-07-30, svn revision 138295)
 
2008-07-26  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/i386-protos.h (i386_pe_rwreloc_reloc_rw_mask): New.
	(i386_pe_rwreloc_select_section): Likewise.
	(i386_pe_rwreloc_select_rtx_section): Likewise.
	* config/i386/mingw32.h (TARGET_ASM_RELOC_RW_MASK): Redefine.
	(TARGET_ASM_SELECT_SECTION): Likewise.
	(TARGET_ASM_SELECT_RTX_SECTION): Likewise.
	(TARGET_RWRELOC): Define to 1.
	* config/i386/winnt.c (TARGET_RWRELOC): Define if not defined.
	(i386_pe_rwreloc_reloc_rw_mask): New target hook.
	(i386_pe_rwreloc_select_section): Likewise.
	(i386_pe_rwreloc_select_rtx_section): Likewise.

(Not to be submitted - obsolete with GNU Binutils 2.19)

2008-07-25  Olivier Hainque  <hainque@adacore.com>

	* collect2.c (DO_COLLECT_EXPORT_LIST): New internal macro,
	always defined.  Reflect definition or absence of such for
	COLLECT_EXPORT_LIST.  Readability helper.
	(scanfilter enum): Add SCAN_NOTHING.
	(main): Reorganize the first pass link control to let AIX
	drag only the needed frame tables in executables.  Prevent
	frame tables collection during the scan aimed at static ctors.
 	Pre-link and scan for frame tables later to compensate.
	* doc/tm.texi (ASM_OUTPUT_DWARF_TABLE_REF): New macro.
	A C statement to issue assembly directives that create a reference
	to + the given DWARF table identifier @var{label} from the current
	function section.
	* dwarf2out.c (switch_to_eh_frame_section): Add a BACK argument
	to differentiate first time section entry.  Only emit a .data
	tables start identifier label the first time around.
	(switch_to_frame_table_section): New function.  Helper for
	output_call_frame_info to switch possibly BACK into the eh_frame
	or the debug_frame section depending on FOR_EH.
	(output_call_frame_info): Use helper to first enter the proper
	frame section. Use ASM_OUTPUT_DWARF_TABLE_REF when defined to
	emit a link to the frame table start label from each function
	section.
	* config/rs6000/rs6000.c (rs6000_aix_asm_output_dwarf_table_ref):
	New function.  Implementation of ASM_OUTPUT_DWARF_TABLE_REF.
	* config/rs6000/rs6000-protos.h: Declare it.
	* config/rs6000/aix.h (ASM_OUTPUT_DWARF_TABLE_REF): Define.

(To be submitted)

2008-07-25  Olivier Hainque  <hainque@adacore.com>

	* collect2 (scanfilter): New enum, to help control what symbols
	are to be considered or ignored by scan_prog_file.
	(enum pass): Rename as "scanpass", moved together with scanfilter
	prior to scan_prog_file's prototype.
	(scan_prog_file): Accept and honor a scanpass argument.  Group
	prototype with the scanpass/scanfilter definitions, factorize
	head comments for the several implementations at the prototype.
	(main): Adjust scan_prog_file calls to pass the scanfilter argument,
	SCAN_ALL the special symbols as before.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-07/msg01957.html)

2008-07-25  Olivier Hainque  <hainque@adacore.com>

	* collect2.c (symkind): New enum.
	(is_ctor_dtor): Return symkind instead of int.  Adjust
	prototype, code and head comment accordingly.
	(scan_prog_file): Use symkind names instead of bare integers.

(Installed in GCC 4.4 on 2008-07-26, svn revision 138179)

2008-07-25  Olivier Hainque  <hainque@adacore.com>

	 * collect2.c (scan_prog_file, COFF version): Use CONST_CAST
	instead of bare conversion to cast const-ness away.

(Installed in GCC 4.4 on 2008-07-16, svn revision 137889)

2008-07-19  Olivier Hainque  <hainque@adacore.com>

	* doc/tm.texi (MALLOC_ABI_ALIGNMENT): New macro. Alignment, in
	bits, a C conformant malloc implementation has to provide.
	* defaults.h (MALLOC_ABI_ALIGNMENT): Default to BITS_PER_WORD.

(Installed in GCC 4.4 on 2008-17-19 - revision 137984)

2008-07-14  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (view_convert_barrier_p): New predicate.
	(sra_walk_gimple_modify_stmt): Use it to disable scalarization of
	aggregates also manipulated as scalar objects of the same size.

(To be submitted)

2008-07-14  Eric Botcazou  <ebotcazou@adacore.com>

	Callgraph info support
	* common.opt (-fcallgraph-info[=]): New option.
	* doc/invoke.texi (Debugging options): Document it.
	* flags.h (flag_stack_usage_info): New flag.
	(flag_callgraph_info): Likewise.
	* opts.c (common_handle_option): Handle -fcallgraph-info[=].
	Set flag_stack_usage_info to 1 if -fstack-usage.
	* calls.c (expand_call): If -fcallgraph-info, record calls.  Turn
	flag_stack_usage into flag_stack_usage_info.
	(emit_library_call_value_1): Likewise.
	* cgraph.h (struct cgraph_final_info): New structure.
	(struct cgraph_dynamic_alloc): Likewise.
	(cgraph_final_edge): Likewise.
	(cgraph_node): Add 'final' field.
	(dump_cgraph_final_vcg): Declare.
	(cgraph_final_record_call): Likewise.
	(cgraph_final_record_dynamic_alloc): Likewise.
	(cgraph_final_info): Likewise.
	* cgraph.c (cgraph_node): Initialize 'final' field.
	(final_create_edge): New static function.
	(cgraph_final_record_call): New global function.
	(cgraph_final_record_dynamic_alloc): Likewise.
	(cgraph_final_info): Likewise.
	(dump_cgraph_final_indirect_call_node_vcg): New static function.
	(dump_cgraph_final_edge_vcg): Likewise.
	(dump_cgraph_final_node_vcg): Likewise.
	(external_node_needed_p): Likewise.
	(dump_cgraph_final_vcg): New global function.
	* explow.c (allocate_dynamic_stack_space): Turn flag_stack_usage into
	flag_stack_usage_info.
	* expr.c (block_move_fn): Make global.
	(block_clear_fn): Likewise.
	Do not include gt-expr.h.
	* function.c (instantiate_virtual_regs): Turn flag_stack_usage into
	flag_stack_usage_info.
	(prepare_function_start): Likewise.
	(rest_of_handle_thread_prologue_and_epilogue): Likewise.
	* gimplify.c (gimplify_decl_expr): Record dynamically-allocated object
	by calling cgraph_final_record_dynamic_alloc if -fcallgraph-info=da.
	* print-tree.c (print_decl_identifier): New function.
	* toplev.h (stack_usage_qual): Declare.
	* toplev.c (flag_callgraph_info): New flag.
	(flag_stack_usage_info): Likewise.
	(stack_usage_qual): New global variable.
	(output_stack_usage): If -fcallgraph-info=su, set stack_usage_kind
	and stack_usage of associated callgraph node.  If -fstack-usage, use
	print_decl_identifier for pretty-printing.
	(finalize): If -fcallgraph-info, invoke dump_cgraph_vcg.
	* tree.h (print_decl_identifier): Declare it.
	(PRINT_DECL_ORIGIN, PRINT_DECL_NAME, PRINT_DECL_UNIQUE_NAME): New.
	(block_move_fn): Declare.
	(block_clear_fn): Likewise.
	* Makefile.in (expr.o): Remove gt-expr.h.
	* config/alpha/alpha.c (alpha_expand_prologue): Turn flag_stack_usage
	into flag_stack_usage_info.
	* config/i386/i386.c (ix86_expand_prologue): Likewise.
	* config/ia64/ia64.c (ia64_expand_prologue): Likewise.
	* config/mips/mips.c (mips_expand_prologue): Likewise.
	* config/pa/pa.c (hppa_expand_prologue): Likewise.
	* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.
	* config/sparc/sparc.c (sparc_expand_prologue): Likewise.

(To be submitted)

2008-07-13  Eric Botcazou  <ebotcazou@adacore.com>

	Stack usage support
	* common.opt (-fstack-usage): New option.
	* doc/invoke.texi (Debugging options): Document it.
	* builtins.c (expand_builtin_apply): Pass TRUE as 4th argument to
	allocate_dynamic_stack_space.
	(expand_builtin_alloca): Add 4th bool parameter CANNOT_ACCUMULATE
	and propagate it to allocate_dynamic_stack_space.
	(expand_builtin) <BUILT_IN_ALLOCA>: Adjust for above change.
	* calls.c (initialize_argument_information): Pass TRUE as 4th
	argument to allocate_dynamic_stack_space.
	(expand_call): Set current_function_has_unbounded_dynamic_stack_size
	to 1 when pushing a variable-sized argument onto the stack.  Pass
	TRUE as 4th argument to allocate_dynamic_stack_space.
	Update current_function_pushed_stack_size.
	(emit_library_call_value_1): Likewise.
	* explow.c (allocate_dynamic_stack_space): Add 4th bool parameter
	CANNOT_ACCUMULATE.  If flag_stack_usage, look into the size and
	attempt to find an upper bound.  Remove redundant code for the
	SETJMP_VIA_SAVE_AREA case.
	* expr.h (allocate_dynamic_stack_space): Add 4th bool parameter.
	* function.h (struct stack_usage): New structure.
	(current_function_static_stack_size): New macro.
	(current_function_dynamic_stack_size): Likewise.
	(current_function_pushed_stack_size): Likewise.
	(current_function_dynamic_alloc_count): Likewise.
	(current_function_has_unbounded_dynamic_stack_size): Likewise.
	(current_function_allocates_dynamic_stack_space): Likewise.
	(struct function): Add new field 'su'.
	* function.c (instantiate_virtual_regs): If SETJMP_VIA_SAVE_AREA,
	add the value of the dynamic offset to the dynamic stack usage.
	(prepare_function_start): Allocate cfun->su if flag_stack_usage.
	(rest_of_handle_thread_prologue_and_epilogue): Call output_stack_usage.
	* gimplify.c (gimplify_decl_expr): Set ALLOCA_FOR_VAR_P on the call
	to BUILT_IN_ALLOCA for variable-sized objects.
	* toplev.h (output_stack_usage): Declare.
	* toplev.c (stack_usage_file): New file pointer.
	(output_stack_usage): New function.
	(open_auxiliary_file): Likewise.
	(lang_dependent_init): Open file if flag_stack_usage is set.
	(finalize): Close file if stack_usage_file is not null.
	* tree.h (ALLOCA_FOR_VAR_P): New macro.
	* config/alpha/alpha.c (compute_frame_size): New function.
	(alpha_expand_prologue): Use it.
	(alpha_start_function): Likewise.
	(alpha_expand_epilogue): Likewise.
	Set current_function_static_stack_size.
	* config/i386/i386.c (ix86_expand_prologue): Likewise.
	* config/ia64/ia64.c (ia64_expand_prologue): Likewise.
	* config/mips/mips.c (mips_expand_prologue): Likewise.
	* config/pa/pa.c (hppa_expand_prologue): Likewise.
	* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.
	* config/sparc/sparc.c (sparc_expand_prologue): Likewise.

(To be submitted)

2008-07-10  Nicolas Roche  <roche@adacore.com>

	* config/i386/t-mingw32: Add support for libgcc_s.dll.

(To be experimented)

2008-07-09  Eric Botcazou  <ebotcazou@adacore.com>

	* config/ia64/unwind-ia64.c (struct _Unwind_Context): Add new
	field 'signal_pfs_loc'.
	(uw_frame_state_for): Remove duplicate code dealing with leaf
	procedures without unwind info.
	If in the frame after unwinding through a signal handler, restore
	the AR.PFS register instead of the CFM if AR.PFS has not been saved.
	* config/ia64/linux-unwind.h (ia64_fallback_frame_state): Do not
	set 'pfs_loc' to the AR.PFS location in the signal context; instead
	set 'signal_pfs_loc'.
	Manually generate the unwind info for the AR.PFS register.
	(ABI_MARKER_OLD_LINUX_SIGTRAMP, ABI_MARKER_OLD_LINUX_INTERRUPT,
	ABI_MARKER_LINUX_SIGTRAMP, ABI_MARKER_LINUX_INTERRUPT): Define.
	(ia64_handle_unwabi): Test 'fs->unwabi' against them.
	Do not set 'pfs_loc' to the AR.PFS location in the signal context;
	instead set 'signal_pfs_loc'.
	Remove code preventing the AR.PFS register from being restored
	from the signal context.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2005-11/msg00597.html)

2008-07-09  Eric Botcazou  <ebotcazou@adacore.com>

	* unwind-dw2.c (uw_identify_context): Take into account whether the
	context is that of a signal frame or not.

(To be submitted)

2008-07-08  Jose Ruiz  <ruiz@adacore.com>
            Eric Botcazou  <ebotcazou@adacore.com>

	* config/sparc/sol2.h (MD_UNWIND_SUPPORT): Define.
	* config/sparc/sol2-unwind.h: New file.

(To be submitted)

2008-07-08  Olivier Hainque  <hainque@adacore.com>

	* config/i386/sol2.h (MD_UNWIND_SUPPORT): Define.
	* config/i386/sol2-unwind.h: New file.

(To be submitted)

2008-07-08  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/linux-unwind.h (x86_frob_update_context): New function.
	(MD_FROB_UPDATE_CONTEXT): Define.
	* config/i386/w32-unwind.h (i386_w32_fallback_frame_state): Do not
	restore reg #9.  Remove +1 adjustment to EIP.  Set fs->signal_frame.
	* config/pa/hpux-unwind.h (pa_fallback_frame_state): Likewise.

(To be submitted)

2008-07-08  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-nested.c (walk_stmts) <COND_EXPR>: Request a GIMPLE value.

(Not to be submitted - irrelevant for GCC 4.4)

2008-07-07  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (is_subrange_type): Deal with BOOLEAN_TYPE.

(Installed in GCC 4.4 on 2008-06-30 - revision 138348)

2008-07-06  Pascal Obry  <obry@adacore.com>

	* config/i386/mingw32.h (LINK_SPEC): --enable-auto-import 
	--enable-runtime-pseudo-reloc by default.

(To be refined)

2008-06-30  Eric Botcazou  <ebotcazou@adacore.com>

	* config/sparc/sparc.h (CANNOT_CHANGE_MODE_CLASS): Disable change from
	SFmode to a mode with different size in floating-point registers.

(Not to be submitted - obsolete for GCC 4.4)

2008-06-27  Olivier Hainque  <hainque@adacore.com>

	* gimplify.c (gimplify_modify_expr_to_memset): Assert our
	documented assumptions.

(Installed in GCC 4.4 on 2008-06-27 - revision 132941)

2008-06-26  Olivier Hainque  <hainque@adacore.com>

	* dwarf2out.c (add_subscript_info): New explicit COLLAPSE_P
	argument, saying whether nested array types should be collapsed
	as multiple outer level subscripts.
	(gen_array_type_die): Factorize comments about the MIPS_DEBUG_INFO
	issues and centralize the nested array types collapsing control.

(Installed in GCC 4.4 on 2008-08-18 - revision 137975)

2008-06-25  Olivier Hainque  <hainque@adacore.com>
            Eric Botcazou  <ebotcazou@adacore.com>

	Support for output of static nested constructors within bitfields
	* varasm.c (initializer_constant_valid_for_bitfield_p): New
	predicate. Whether VALUE is a valid constant-valued expression
	for use in initializing a static bit-field.
	(oc_outer_state): New type. output_constructor outer state of
	relevance in recursive calls.
	(oc_local_state): byte_buffer_in_use is bool, not int.  Add a
	"last_relative_index" field to memorize the index of the last
	array element output within a bitfield.
	(output_constructor_array_range): Minor prototype and head
	comment adjustments.
	(output_constructor_regular_field): Likewise.  Adjust assignments
	to byte_buffer_in_use, now bool.
	(output_constructor_bitfield): Likewise.  Accept an OUTER state
	argument for recursive processing.  Recurse on record or array
	CONSTRUCTOR values, possibly past noop conversions.
	(output_constructor): Accept and honor an OUTER state argument for
	recursive calls + return total size.  Be prepared for nested
	constructors initializing bitfields and consider BLKmode toplevel
	fields as regular even if DECL_BIT_FIELD is set.
	(output_constant): Feed OUTER in calls to output_constructor.
	* output.h (initializer_constant_valid_for_bitfield_p): Declare.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-07/msg01862.html)

2008-06-12  Eric Botcazou  <ebotcazou@adacore.com>

	* config/ia64/ia64.h (HARD_REGNO_NREGS): Return 1 for CCImode
	in general purpose registers.
	(HARD_REGNO_MODE_OK): Accept CCImode in general purpose registers.
	* config/ia64/ia64.md (*movcci): Change to named pattern.  Deal
	with general purpose registers and memory operands.  Add associated
	CCImode post-reload splitter.
	* config/ia64/div.md: Change BImode to CCImode throughout.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-06/msg00904.html)

2008-06-11  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-inline.c (copy_body_r): Copy TREE_SIDE_EFFECTS along with
	TREE_THIS_VOLATILE on INDIRECT_REF nodes.

(Installed in GCC 4.4 on 2008-06-12 - revision 136702)

2008-06-10  Olivier Hainque  <hainque@adacore.com>

	* varasm.c (oc_local_state): New structure, output_constructor
	local state to support communication with helpers.
	(output_constructor_array_range): New output_constructor helper,
	extracted code for an array range element.
	(output_constructor_regular_field): New output_constructor helper,
	extracted code for an element that is not a bitfield.
	(output_constructor_bitfield): New output_constructor helper,
	extracted code for a bitfield element.
	(output_constructor): Rework to use helpers.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-07/msg01802.html)

2008-06-10  Olivier Hainque  <hainque@adacore.com>

	* config/i386/w32-unwind.h (i386_w32_fallback_frame_state):
	DWARF_FRAME_REGNUM(ebp) is 5, not 4.

(To be submitted)

2008-06-10  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (expand_expr_real_1) <VIEW_CONVERT_EXPR>: When converting
	to BLKmode, try to fetch an inner memory reference.  Use 'mode' in
	lieu of TYPE_MODE (type) throughout.

(Installed in GCC 4.4 on 2008-08-15 - revision 139139)

2008-06-06  Eric Botcazou  <ebotcazou@adacore.com>
            Olivier Hainque  <hainque@adacore.com>

	* builtins.c (get_memory_rtx): Accept byte-addressable bitfields.
	Use DECL_SIZE_UNIT to retrieve the size of the field.

(Installed in GCC 4.4 on 2008-06-11 - revision 136673)

2008-06-06  Nicolas Roche  <roche@adacore.com>

	* configure: Avoid using shell scripts wrappers on Windows hosted
	platforms for as, nm and ld.

(To be submitted)

2008-06-04  Eric Botcazou  <ebotcazou@adacore.com>

	* common.opt (-fdead-non-call-exceptions): New option.
	* doc/invoke.texi (Code Generation Options): Document it.
	* cse.c (insn_live_p): Test flag_dead_non_call_exceptions in lieu of
	flag_non_call_exceptions.
	* dce.c (can_alter_cfg): New flag.
	(deletable_insn_p_1): Test flag_dead_non_call_exceptions in lieu of
	flag_non_call_exceptions if the CFG can be altered.
	(init_dce): Set can_alter_cfg to false for fast DCE, true otherwise.
	* dse.c (scan_insn): Test flag_dead_non_call_exceptions in lieu of
	flag_non_call_exceptions.
	* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.

(To be submitted)

2008-05-27  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (sra_type_can_be_decomposed_p) <RECORD_TYPE>: Make sure
	that the bitfield is of integral type before testing its precision.

(Installed in GCC 4.4 on 2008-05-27 - revision 136009)

2008-05-26  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold_binary): Associate again expressions with more
	than one variable for sizetypes.

(Not to be submitted - see http://gcc.gnu.org/ml/gcc/2008-05/msg00354.html)

2008-05-25  Eric Botcazou  <ebotcazou@adacore.com>

	Elimination of stack trampolines
	* common.opt (-Wtrampolines): New warning.
	(-ftrampolines): New option.
	* opts.c (decode_options): Force -ftrampolines if the target doesn't
	use runtime descriptors.
	* doc/invoke.texi (Code Gen Options): Document them.
	* doc/tm.texi (Trampolines): Document USE_RUNTIME_DESCRIPTORS.
	* builtins.def: Add *_init_descriptor and *_adjust_descriptor.
	* builtins.c (expand_builtin_init_trampoline): Do not set
	trampolines_created here.
	(expand_builtin_init_descriptor): New function.
	(expand_builtin_adjust_descriptor): Likewise.
	(expand_builtin) <BUILT_IN_INIT_DESCRIPTOR>: New case.
	<BUILT_IN_ADJUST_DESCRIPTOR>: Likewise.
	* calls.c (prepare_call_address): Change purpose of last parameter.
	Deal with indirect calls by descriptor.
	(call_expr_flags): Set ECF_BY_DESCRIPTOR for calls by descriptor.
	(expand_call): Likewise.  Adjust call to prepare_call_address.
	* rtlanal.c (find_first_parameter_load): Treat the static chain
	register specially if USE_RUNTIME_DESCRIPTORS is 1.
	* tree.h (FUNC_ADDR_BY_DESCRIPTOR): New flag on ADDR_EXPR.
	(CALL_EXPR_BY_DESCRIPTOR): New flag on CALL_EXPR.
	(ECF_BY_DESCRIPTOR): New mask.
	* tree.c (make_node_stat): Force alignment of functions to 16
	at least if -ftrampolines.
	(build_common_builtin_nodes): Initialize *_init_descriptor and
	*_adjust_descriptor.
	* tree-nested.c: Include toplev.h.
	(struct nesting_info): Add 'any_descr_created' field.
	(get_descriptor_type): New function.
	(lookup_element_for_decl): Likewise.
	(create_field_for_decl): Likewise.
	(lookup_tramp_for_decl): Factor out code into above functions.
	(lookup_descr_for_decl): New function.
	(convert_tramp_reference): Set trampolines_created here.  Issue
	a warning on trampoline generation.  Deal with descriptors.
	(build_init_call_expr): New function.
	(finalize_nesting_tree_1): Factor out code into above function.
	Deal with descriptors.
	* defaults.h (TRAMPOLINE_ALIGNMENT): Force to 16 at least if
	USE_RUNTIME_DESCRIPTORS is 1.
	* config/alpha/alpha.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/alpha/vms.h (USE_RUNTIME_DESCRIPTORS): Redefine to 0.
	* config/i386/i386.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/i386/i386.md (sibcall_1): Disparage 'c' alternative.
	(sibcall_value_1): Likewise.
	* config/ia64/ia64.h (USE_RUNTIME_DESCRIPTORS): Define to 0.
	* config/mips/mips.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/pa/pa.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/rs6000/rs6000.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/rs6000/aix.h (USE_RUNTIME_DESCRIPTORS): Redefine to 0.
	* config/sparc/sparc.h (USE_RUNTIME_DESCRIPTORS): Define to 1.

(To be submitted)

2008-05-24  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.h (TREE_STATIC): Fully document usage on ADDR_EXPR.
	* tree-nested.c (convert_tramp_reference) <ADDR_EXPR>: Do not
	build a trampoline if we don't want one.
	* varasm.c (initializer_constant_valid_p) <ADDR_EXPR>: Do not
	return zero for nested functions if we don't want a trampoline.

(Installed in GCC 4.4 on 2008-05-25 - revision 135884)

2008-05-22  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (highest_pow2_factor) <BIT_AND_EXPR>: New case.

(Installed in GCC 4.4 on 2008-05-23 - revision 135820)

2008-05-21  Eric Botcazou  <ebotcazou@adacore.com>

	* cfgexpand.c (tree_expand_cfg): Zap the EH throw statement table
	once finished.

(Installed in GCC 4.4 on 2008-05-21 - revision 135712)

2008-05-20  Eric Botcazou  <ebotcazou@adacore.com>

	Uniquization of constants at the Tree level
	* function.h (struct function): Add new deferred_constants field.
	(n_deferred_constants): New macro moved from varasm.c.
	* tree-inline.c (expand_call_inline): Update n_deferred_constants.
	* tree.h (tree_output_constant_def): Declare.
	* varasm.c (struct varasm_status): Remove deferred_constants field.
	(n_deferred_constants): Move to function.h.
	(struct constant_descriptor_tree): Add decl field.
	(build_constant_desc): Set it to zero.
	(tree_output_constant_def): New function.
	(init_varasm_status): Do not initialize deferred_constants field.

(To be submitted)

2008-05-19  Eric Botcazou  <ebotcazou@adacore.com>

	Factorization of self-referential size trees into functions
	* cgraphunit.c (cgraph_finalize_compilation_unit): Call
	finalize_size_functions before further processing.
	* stor-layout.c: Include cgraph.h, tree-inline.h and tree-dump.h.
	(variable_size): Call self_referential_size on size expressions
	that contain a PLACEHOLDER_EXPR.
	(size_functions): New static variable.
	(copy_self_referential_tree_r): New static function.
	(self_referential_size): Likewise.
	(finalize_size_functions): New global function.
	* tree.c: Include tree-inline.h.
	(push_without_duplicate): New static function.
	(find_substitute_in_expr): New global function.
	(substitute_in_expr) <COMPONENT_REF>: Minor tweaks.
	<tcc_declaration>: Return the replacement object on equality.
	<tcc_expression>: Likewise.
	<tcc_vl_exp>: If the replacement object is a constant, try to inline
	the call in the expression.
	Propagate the TREE_READONLY flag without overwriting.
	(substitute_placeholder_in_expr): Likewise.
	(PROCESS_ARG): Do not clear TREE_READONLY if CONSTANT_CLASS_P.
	(build3_stat): Propagate TREE_READONLY for COND_EXPR.
	(process_call_operands): Propagate TREE_READONLY from the operands.
	* tree.h (finalize_size_functions): Declare.
	(find_substitute_in_expr): Likewise.
	(FIND_SUBSTITUTE_IN_EXPR): New macro.
	(substitute_placeholder_in_expr): Update comment.
	* tree-inline.c (remap_decl): Do not unshare trees if do_not_unshare
	is true.
	(copy_body_r): Be prepared for MODIFY_EXPR as well.
	(maybe_inline_call_in_expr): New global function.
	* tree-inline.h (struct copy_body_data): Add do_not_unshare field.
	(maybe_inline_call_in_expr): Declare.

(To be submitted)

2008-05-18  Eric Botcazou  <ebotcazou@adacore.com>

	Elimination of unreachable nested functions
	* common.opt (-fkeep-nested-functions): New option.
	* doc/invoke.texi (Optimize Options): Document it.
	* tree-nested.c (nesting_info): New fields 'next_reachable'
	and 'reachable'.
	(local_dump_file): New static variable.
	(local_dump_flags): Likewise.
	(discard_unreachable): Likewise.
	(ni_map): Likewise.
	(get_frame_type): Update comment about addressability.
	(walk_all_functions): Check reachability of functions.
	(create_nesting_tree): Populate ni_map.
	(reachable_queue): New global variable.
	(mark_reachable_function_1): New function.
	(mark_reachable_functions_1): Likewise.
	(mark_reachable_functions): Likewise.
	(convert_all_function_calls): Check reachability of functions.
	(finalize_nesting_tree_1): Dump the function directly.
	(finalize_nesting_tree): Check reachability of functions.
	(unnest_nesting_tree_1): Likewise.  Write the name of the function
	in the dump file if it is discarded.
	(unnest_nesting_tree):  Use 'for' instead of 'do' loop.
	(free_nesting_tree): Likewise.
	(lower_nested_functions): Open and close the dump file.
	Discard unreachable functions unless -fkeep-nested-functions.
	Initialize and destroy ni_map.  Invoke mark_reachable_functions
	if discard_unreachable is true.

(To be submitted)

2008-05-17  Eric Botcazou  <ebotcazou@adacore.com>

	* alias.h (record_alias_subset): Declare.
	* alias.c (record_alias_subset): Make public.
	* tree-inline.h (struct copy_body_data): Add ref_all_alias_set field.
	* tree-inline.c (remap_type_1): Build ref-all pointers and references
	if their designated type can be pointed to by ref-all pointers.
	(remap_type): Do not punt on pointers if there are ref-all pointers.
	(setup_one_parameter): Propagate the TYPE_REF_CAN_ALIAS_ALL flag to
	the new variable if necessary.  Remove dead code.

(To be submitted)

2008-05-15  Nicolas Setton  <setton@adacore.com>
	    Olivier Hainque  <hainque@adacore.com>

	GNAT extensions to DWARF-2 format to support type encodings
	and descriptive types.
	* common.opt: Add -gdwarf+.
	* opts.c (common_handle_option): Accept -gdwarf+. Set
	use_gnu_debug_info_extensions
	* doc/invoke.texi: Document -gdwarf+.
	* defaults.h (DWARF2_GNU_TYPE_EXTENSIONS): Define to 1.
	* dwarf2.h (dwarf_attribute): Add DW_AT_GNU_type_encoding and
	DW_AT_GNU_descriptive_type.
	* dwarf2out.c (dwarf2out_set_descriptive_type_func): New function.
	Let front-end register a hook to retrieve the "descriptive type"
	associated with a type.
	(dwarf2out_set_type_encoding_func): Likewise for the support of a
	"type encoding"	string.
	(dwarf_attr_name): Add cases for DW_AT_GNU_type_encoding and
	DW_AT_GNU_descriptive_type.
	(add_artificial_attribute_for_type): New function. Add a
	DW_AT_artificial attribute to the DIE for a TYPE if it is needed.
	(add_descriptive_attribute_for_type): Likewise.
	(add_name_attribute): Output type encoding if any.
	(modified_type_die): Add calls to add_artificial_attribute_for_type
	and add_descriptive_attribute_for_type.
	(gen_array_type_die): Likewise.
	(gen_enumeration_type_die): Likewise.
	(gen_struct_or_union_type_die): Likewise.
	(gen_compile_unit_die): Add "-gdwarf+" to the DW_AT_producer string
	string when compiling with GNU type extensions and "-gdwarf+-"
	otherwise.
	* dwarf2out.h (dwarf2out_set_descriptive_type_func): Declare.
	(dwarf2out_set_type_encoding_func): Likewise.

(Not to be submitted - better replaced by proper DWARF type descriptions)

2008-05-14  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c: Include pointer-set.h.
	(mostly_copy_tree_r): Copy trees under SAVE_EXPR and TARGET_EXPR
	nodes, but only once.  Stop at BIND_EXPR nodes.  Do not propagate
	the 'data' argument to copy_tree_r.
	(copy_if_shared_r): Unshare trees under SAVE_EXPR and TARGET_EXPR
	nodes, but only once.  Remove redundant code dealing with types,
	decls and constants.  Remove bogus ATTRIBUTE_UNUSED marker.
	Propagate 'data' argument to walk_tree.
	(copy_if_shared): New function.
	(unmark_visited_r): Unmark trees under SAVE_EXPR and TARGET_EXPR
	nodes, but only once.  Remove bogus ATTRIBUTE_UNUSED marker.
	(unmark_visited): New function.
	(unshare_body): Call copy_if_shared instead of doing it manually.
	(unvisit_body): Call unmark_visited instead of doing it manually.
	(unshare_all_trees): Likewise.
	* Makefile.in (gimplify.o): Add pointer-set.h dependency.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-05/msg00939.html)

2008-05-06  Olivier Hainque  <hainque@adacore.com>

	* tree-sra.c (try_instantiate_multiple_fields): Early return
	if field has POINTER_TYPE.

(Installed in GCC 4.4 on 2006-05-06 - revision 134982)

2008-04-29  Olivier Hainque  <hainque@adacore.com>

	* expr.c (expand_expr_real_1) <normal_inner_ref>: Force op0 to
	memory if the component is to be referenced in BLKmode according
	to get_inner_reference.

(Installed in GCC 4.4 on 2008-05-14 - revision 135296)

2008-04-22  Nicolas Roche  <roche@adacore.com>

	* configure.ac: Update to support new gcc-interface subdirectory.
	* configure: Regenerate.
	* gengtype.c: Update to support new gcc-interface subdirectory.
	* Makefile.in: Likewise.

(Not to be submitted - obsolete for GCC 4.4)

2008-04-20  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (sra_walk_expr) <VIEW_CONVERT_EXPR>: Disable
	scalarization if on the LHS and not a full access.

(Installed in GCC 4.4 on 2008-04-20 - revision 134487)

2008-04-18  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.4 - revision 134069
	* config/avr/avr.h (TARGET_CPU_CPP_BUILTINS): Define 
	__AVR_HAVE_EIJMP_EICALL__ macro if device have EIJMP and EICALL 
	instructions.
	* config/avr/avr.c (avr_mcu_types): Set AVR31 architecture for 
	atmega103 device.

(Already in GCC 4.4)

2008-04-18  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.4 - revision 133966
	* config/avr/avr.h (avr_mega_p): Remove declaration.
	(AVR_MEGA): Remove macro.
	* config/avr/avr.c (avr_mega_p): Remove variable.
	(avr_override_options): Remove inicializion of avr_mega_p.
	Use AVR_HAVE_JMP_CALL instead of AVR_MEGA.
	(print_operand): Use AVR_HAVE_JMP_CALL instead of AVR_MEGA.
	(avr_jump_mode): (Ditto.).
	(avr_output_progmem_section_asm_op): (Ditto.).
	(avr_asm_init_sections): (Ditto.).
	(avr_asm_init_sections): (Ditto.).
	(avr_rtx_costs): (Ditto.).
	* config/avr/avr.md: (Ditto.).
	* config/avr/avr.h: Use '__AVR_HAVE_JMP_CALL__' instead of 
	'__AVR_MEGA__'.

(Already in GCC 4.4)

2008-04-18  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.4 - revision 133846
	* config/avr/predicates.md (io_address_operand): New predicate. 
	* config/avr/avr-protos.h (avr_io_address_p): Remove declaration.
	* config/avr/avr.c (avr_io_address_p): Remove function.
	(out_movqi_r_mr): Use 'io_address_operand' predicate instead of 
	'avr_io_address_p' function.
	(out_movhi_r_mr): (Ditto.).
	(out_movqi_mr_r): (Ditto.).
	(out_movhi_mr_r): (Ditto.).
	(avr_address_cost): (Ditto.).

(Already in GCC 4.4)

2008-04-18  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.4 - revision 133248
	* config/avr/avr.c (avr_arch_types): Add avr6 entry.
	(avr_arch): Add ARCH_AVR6.
	(avr_mcu_types): Add 'atmega2560' and 'atmega2561' entry.
 	(initial_elimination_offset): Initialize and use 'avr_pc_size' 
	instead of fixed value 2.
	(print_operand_address): Use gs() asm specifier instead of pm().
	(avr_assemble_integer): (Ditto.).
	(avr_output_addr_vec_elt): (Ditto.).
	(print_operand): Handle "!" code.
	* config/avr/avr.h (TARGET_CPU_CPP_BUILTINS): Add 
	__AVR_3_BYTE_PC__, __AVR_2_BYTE_PC__ and __AVR_HAVE_JMP_CALL__.
	(AVR_HAVE_EIJMP_EICALL): Define.
	(AVR_3_BYTE_PC): Redefine.
	(AVR_2_BYTE_PC): (Ditto.).
	(PRINT_OPERAND_PUNCT_VALID_P): Add '!' code.
	(LINK_SPEC): Add atmega2560 and atmega2561.
	(CRT_BINUTILS_SPEC): Add atmega2560 (crtm2560.o) and atmega2561 
	(crtm2561.o).
	* config/avr/avr.md (call_insn): Use eicall instead of icall 
	for 3 byte PC devices.
	(call_value_insn): (Ditto.).
	(*tablejump_enh): Use eijmp instead of ijmp for 3 byte PC devices.
	(indirect_jump): Use only for for 2 byte PC devices.
	(*tablejump): (Ditto.).
	(*indirect_jump_avr6): Add insn.
	(*tablejump_rjmp): Don't use for 3 byte PC devices.
	* config/avr/libgcc.S (__prologue_saves__): Use eijmp 
	instead of ijmp for 3 byte PC devices.
	(__tablejump2__): (Ditto.).
	* config/avr/t-avr (MULITLIB_OPTIONS): Add avr6 architecture.
	(MULITLIB_DIRNAMES): (Ditto.). 
	(MULTILIB_MATCHES): Add atmega2560 and atmega2561 to list.

(Already in GCC 4.4)

2008-04-18  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.4 - revision 132555
	* config/avr/libgcc.S (__RAMPZ__): Define.
	(__do_copy_data): Add for devices with 128KB code memory.

(Already in GCC 4.4)

2008-04-17  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_modify_expr_rhs) <COND_EXPR>: Gimplify the LHS
	using the is_gimple_lvalue predicate instead of is_gimple_min_lval.

(Installed in GCC 4.4 on 2008-04-18 - revision 134442)

2008-04-09  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-structalias.c (get_constraint_for_component_ref): Do not
	punt for STRING_CST.
	(get_constraint_for): Deal with STRING_CST here instead.

(Installed in GCC 4.4 on 2008-04-15 - revision 134325)

2008-04-01  Olivier Hainque  <hainque@adacore.com>

	* Makefile.in (CRTSTUFF_CFLAGS): Add explicit -funit-at-a-time
	together with -fno-toplevel-reorder.

(Not to be submitted - proper approach is not to rely on the latter)

2008-03-29  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold) <ARRAY_REF>: New case.  Try to fold constant
	reference in constructor with non self-referential type.

(Installed in GCC 4.4 on 2008-04-07 - revision 133977)

2008-03-27  Romain Berrendonner  <berrendo@adacore.com>

	* gcc.c (process_command): Update warranty notice for AdaCore use.

(Not to be submitted - local setting)

2008-03-25  Eric Botcazou  <ebotcazou@adacore.com>
            Tristan Gingold  <gingold@adacore.com>
            Jose Ruiz  <ruiz@adacore.com>

	New stack checking implementation
	* common.opt (-fstack-check): Do not declare the variable here.
	(-fold-stack-check): New option.
	* doc/invoke.texi (Code Gen Options): Document it.
	* expr.h (STACK_CHECK_PROBE_INTERVAL): Delete.
	(STACK_CHECK_PROBE_INTERVAL_EXP): New macro.
	(STACK_CHECK_MAX_FRAME_SIZE): Adjust for above change.
	(STACK_OLD_CHECK_PROTECT): Likewise.
	(STACK_CHECK_PROTECT): Bump to 3 pages if DWARF-2 EH is used.
	(STACK_CHECK_STATIC_BUILTIN): New macro.
	(STACK_CHECK_PROBE_IOR): Likewise.
	(STACK_CHECK_MOVING_SP): Likewise.
	* system.h (STACK_CHECK_PROBE_INTERVAL): Poison it.
	* doc/tm.texi (Stack Checking): Delete STACK_CHECK_PROBE_INTERVAL.
	Document STACK_CHECK_PROBE_INTERVAL_EXP, STACK_CHECK_STATIC_BUILTIN,
	STACK_CHECK_PROBE_IOR and STACK_CHECK_MOVING_SP.
	* opts.c: Include expr.h.
	(common_handle_option) <OPT_fold_stack_check>: New case.
	<OPT_fstack_check>: Likewise.
	* calls.c (emit_library_call_value_1): Clear the ECF_NOTHROW flag if
	the libcall is LCT_MAY_THROW.
	(initialize_argument_information): Use TYPE_SIZE_UNIT consistently
	in the test for variable-sized types.  Adjust for new behaviour of
	flag_stack_check.
	* explow.c: Include except.h.
	(anti_adjust_stack_and_probe): New function.
	(allocate_dynamic_stack_space): Do not take into account
	STACK_CHECK_MAX_FRAME_SIZE for static builtin stack checking.
	Do not directly allocate space if STACK_CHECK_MOVING_SP, instead
	invoke above function.
	(set_stack_check_libfunc): Delete.
	(stack_check_libfunc): Make public.
	(stack_check_symbol): New public variable.
	(emit_stack_probe): Deal with STACK_CHECK_PROBE_IOR.
	(PROBE_INTERVAL): New macro.
	(STACK_GROW_OPTAB): Likewise.
	(STACK_HIGH, STACK_LOW): Likewise.
	(probe_stack_range): Cope with SPARC_STACK_BIAS.  Pass LCT_MAY_THROW
	to emit_library_call for the checking routine.  Remove support code
	for dedicated pattern.  Add support for stack limits provided by the
	stack_check_symbol variable.  Fix loop condition in the small constant
	case.  Rewrite in the general case to be immune to wrap-around.
	Make sure the address of probes is valid.  Try to use [base + disp]
	addressing mode as much as possible.
	Do not include gt-explow.h.
	* function.c (gimplify_parameters): Use DECL_SIZE_UNIT in the test
	for variable-sized parameters.  Treat all parameters whose size is
	greater than STACK_CHECK_MAX_VAR_SIZE as variable-sized if generic
	stack checking is enabled.
	* gimplify.c (gimplify_decl_expr): Treat non-static objects whose
	size is greater than STACK_CHECK_MAX_VAR_SIZE as variable-sized
	if generic stack checking is enabled.
	(expand_function_end): Adjust for new behaviour of flag_stack_check.
	* reload1.c (reload): Likewise.
	(init_elim_table): Set frame_pointer_needed if stack checking is
	enabled and STACK_CHECK_MOVING_SP.
	* rtlanal.c: Include expr.h.
	(may_trap_p_1) <MEM>: If STACK_CHECK_MOVING_SP, return 1 for
	volatile references to the stack pointer.
	* stmt.c (expand_decl): Assert that all automatic variables have
	fixed size at this point and remove dead code.
	* rtl.h (set_stack_check_libfunc): Delete.
	(stack_check_libfunc): Declare.
	(stack_check_symbol): Likewise.
	(libcall_type enum): Add LCT_MAY_THROW.
	* flags.h (stack_check_type): New enumeration type.
	(flag_stack_check): Change type to above.
	* toplev.c (flag_stack_check): Likewise.
	* tree.c (build_common_builtin_nodes): Do not set ECF_NOTHROW on
	__builtin_alloca if stack checking is enabled.
	* Makefile.in (rtlanal.o): Add dependency on EXPR_H.
	(explow.o): Remove gt-explow.h.
	* config/alpha/alpha.c (alpha_expand_prologue): If stack checking
	is enabled, probe up to frame_size + STACK_CHECK_PROTECT bytes.
	* config/i386/cygming.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/i386/freebsd.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	(STACK_CHECK_MOVING_SP): Likewise.
	* config/i386/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	(STACK_CHECK_MOVING_SP): Likewise.
	* config/i386/lynx.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/sol2.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/vxworks.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	(STACK_CHECK_PROTECT): 8K is reserved in the stack to propagate
	exceptions reliably in case of stack overflow.
	* config/i386/vxworksae.h (STACK_CHECK_PROTECT): Redefine to 4K
	which is enough for executing a possible last chance handler.
	* config/i386/i386.h (STACK_CHECK_PROBE_IOR): Define to 1.
	* config/i386/i386.c (ix86_target_stack_probe): New function.
	(ix86_compute_frame_layout): Force use of push instructions to
	save registers if stack checking with probes is enabled.
	(get_scratch_register_on_entry): New function.
	(release_scratch_register_on_entry): Likewise.
	(output_probe_op): Likewise.
	(output_adjust_stack_and_probe_op): Likewise.
	(output_adjust_stack_and_probe): Likewise.
	(ix86_gen_adjust_stack_and_probe): Likewise.
	(ix86_adjust_stack_and_probe): Likewise.
	(output_cond_trap): Likewise.
	(output_probe_stack_range_op): Likewise.
	(ix86_gen_probe_stack_range): Likewise.
	(ix86_emit_probe_stack_range): Likewise.
	(ix86_expand_prologue): Emit stack checking code if static builtin
	stack checking is enabled.
	Test ix86_target_stack_probe instead of TARGET_STACK_PROBE.
	* config/i386/i386-protos.h (ix86_target_stack_probe): Declare.
	(output_adjust_stack_and_probe): Likewise.
	(output_cond_trap): Likewise.
	(output_probe_stack_range): Likewise.
	* config/i386/i386.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(allocate_stack_worker_32): Test ix86_target_stack_probe instead of
	TARGET_STACK_PROBE.
	(allocate_stack_worker_64): Likewise.
	(allocate_stack): Likewise.
	(adjust_stack_and_probe): New insn.
	(probe_stack_range): Likewise.
	(logical operation peepholes): Do not split stack checking probes.
	(cond_trap): New insn.
	* config/ia64/hpux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	(STACK_CHECK_PROTECT): Define.
	* config/ia64/linux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/ia64/ia64.c (ia64_emit_probe_stack_range): New function.
	(output_probe_stack_range): Likewise.
	(ia64_expand_prologue): Invoke ia64_emit_probe_stack_range if static
	builtin stack checking is enabled.
	(rtx_needs_barrier): Return 1 for inline stack probes.
	(asm_insn_p): New predicate.
	(ia64_dfa_sched_reorder): Use it.
	(ia64_dfa_new_cycle): Likewise.
	(issue_nops_and_insn): Likewise.
	(bundling): Likewise.
	(final_emit_insn_group_barriers): Likewise.
	* config/ia64/ia64-protos.h (output_probe_stack_range): Declare.
	* config/ia64/ia64.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/mips/iris6.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/mips/mips.c: Include except.h.
	(mips_emit_probe_stack_range): New function.
	(mips_output_probe_stack_range): Likewise.
	(mips_expand_prologue): Invoke mips_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/mips/mips-protos.h (mips_output_probe_stack_range): Declare.
	* config/mips/mips.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/pa/pa-hpux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/pa/pa.c (pa_emit_probe_stack_range): New function.
	(output_probe_stack_range): Likewise.
	(hppa_expand_prologue): Invoke pa_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/pa/pa-protos.h (output_probe_stack_range): Declare.
	* config/pa/pa.md (probe_stack_range): New insn.
	* config/rs6000/aix.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/rs6000/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/rs6000/lynx.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/rs6000/vxworks.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	(STACK_CHECK_PROTECT): 8K is reserved in the stack to propagate
	exceptions reliably in case of stack overflow.
	* config/rs6000/vxworksae.h  (STACK_CHECK_PROTECT): Redefine to 4K
	which is enough for executing a possible last chance handler.
	* config/rs6000/rs6000.c (rs6000_emit_probe_stack_range): New function.
	(output_probe_stack_range): Likewise.
	(rs6000_emit_prologue): Invoke rs6000_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/rs6000/rs6000-protos.h (output_probe_stack_range): Declare.
	* config/rs6000/rs6000.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/sparc/sol2.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/sparc/sparc.c: Include except.h.
	(sparc_emit_probe_stack_range): New function.
	(build_big_number): Likewise.
	(output_probe_stack_range): Likewise.
	(sparc_expand_prologue): Invoke sparc_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/sparc/sparc-protos.h (output_probe_stack_range): Declare.
	* config/sparc/sparc.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-03/msg01853.html)

2008-03-25  Nicolas Roche  <roche@adacore.com>

	* config/vx-common.h (TARGET_EXECUTABLE_SUFFIX): Define.

(Not to be submitted - local setting)

2008-03-20  Olivier Hainque  <hainque@adacore.com>

	Enhance back-end support for stack realignment on request.
	* config/i386/i386.c (ix86_stack_realignment_for): New helper.
	States what kind of need a function has with respect to stack
	realignment.
	(needs_static_chain_p): Simple helper.
	(ix86_function_regparm): Punt on trying to use an internal regparm
	convention if there is a need for stack realignment.  Don't look at
	DECL_STRUCT_FUNCTION components for this purpose.  Use the new helpers.
	(ix86_eax_maybe_live_in_or_out): New helper.		
	(ix86_edx_maybe_live_in_or_out): Likewise.
	(ix86_ecx_maybe_live_in_or_out): Likewise.
	(ix86_stack_realign_arg_pointer_regno_for): Likewise.
	(ix86_internal_arg_pointer): Don't hardcode ecx as the internal arg
	pointer for stack realignment purposes, hence don't reject nested
	functions upfront any more.
	(ix86_expand_prologue): At the point we're setting up the stack
	worker, eax is live if it has been used as the arg pointer for stack
	realignment purposes.

(Not to be submitted - obsolete for GCC 4.4)

2008-03-14  Nicolas Roche  <roche@adacore.com>

	* configure.ac: Replace some tabulation in options by spaces.
	* configure: Regenerate.

(To be submitted)

2008-03-12  Nicolas Roche  <roche@adacore.com>

	* Makefile.in: Add variable CROSS that contains the value of @CROSS@.

(To be submitted)

2008-03-05  Eric Botcazou  <ebotcazou@adacore.com>

	* builtins.c (expand_builtin_update_setjmp_buf): Make global.
	* expr.h (expand_builtin_update_setjmp_buf): Declare.
	* insn-notes.def (UPDATE_SJLJ_CONTEXT): New note.
	* final.c (final_scan_insn): Deal with NOTE_INSN_UPDATE_SJLJ_CONTEXT.
	* cfglayout.c (duplicate_insn_chain): Likewise.
	* except.c (sjlj_mark_call_sites): Expand builtin_update_setjmp_buf
	wherever a NOTE_INSN_UPDATE_SJLJ_CONTEXT note is present.
	(update_sjlj_context): New global function.
	* except.h (update_sjlj_context): Declare.
	* calls.c (expand_call): If the callee may be alloca and if using SJLJ
	exceptions, invoke update_sjlj_context.
	* explow.c (allocate_dynamic_stack_space): If using SJLJ exceptions,
	invoke update_sjlj_context at the end.
	* stmt.c (expand_stack_save): Do not call do_pending_stack_adjust.
	(expand_stack_restore): If there are non-local gotos, invoke
	update_nonlocal_goto_save_area.
	If using SJLJ exceptions, invoke update_sjlj_context.

(To be submitted - see http://gcc.gnu.org/ml/gcc-patches/2007-03/msg00946.html)

2008-03-05  Nicolas Roche  <roche@adacore.com>

	* Makefile.in: skip ada/doctools/* and ada/bldtools/* when comparing
	stage2 and stage3 objects.

(To be submitted)

2008-03-04  Eric Botcazou  <ebotcazou@adacore.com>

	* config-ml.in: Enable logic if --enable-dual-exceptions.
	* configure.ac (--enable-sjlj-exceptions): Move around.
	(--enable-dual-exceptions): New option.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.in (s-mlib): Test enable_multilib against "no".
	* genmultilib: Deal with new values of 8th argument specifying
	whether SJLJ multilibs are enabled.
	* common.opt (-fsjlj): New option.
	* doc/invoke.texi: Document it.
	* except.h: Implement it.
	* gcc.c (option_map): Add --sjlj-exceptions alias for it.
	(for_each_path): Consider names modulo trailing sjlj suffix
	for the multilib OS directory.

(To be submitted)

2008-02-25  Eric Botcazou  <ebotcazou@adacore.com>

	* stor-layout.c (layout_decl): Do not bump the alignment of a
	bit-field to more than byte alignment if it is packed.

(Installed in GCC 4.4 on 2008-02-25 - revision 132614)

=============================================================================
*** gcc/stor-layout.c.0	2008-02-25 10:53:49.336693264 +0100
--- gcc/stor-layout.c	2008-02-25 10:53:54.165959104 +0100
*************** layout_decl (tree decl, unsigned int kno
*** 388,400 ****
  	    {
  	      enum machine_mode xmode
  		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
  
  	      if (xmode != BLKmode
! 		  && (known_align == 0
! 		      || known_align >= GET_MODE_ALIGNMENT (xmode)))
  		{
! 		  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),
! 					   DECL_ALIGN (decl));
  		  DECL_MODE (decl) = xmode;
  		  DECL_BIT_FIELD (decl) = 0;
  		}
--- 388,400 ----
  	    {
  	      enum machine_mode xmode
  		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
+ 	      unsigned int xalign = GET_MODE_ALIGNMENT (xmode);
  
  	      if (xmode != BLKmode
! 		  && !(xalign > BITS_PER_UNIT && DECL_PACKED (decl))
! 		  && (known_align == 0 || known_align >= xalign))
  		{
! 		  DECL_ALIGN (decl) = MAX (xalign, DECL_ALIGN (decl));
  		  DECL_MODE (decl) = xmode;
  		  DECL_BIT_FIELD (decl) = 0;
  		}
*** config-ml.in.0	2008-03-06 12:20:46.000000000 +0100
--- config-ml.in	2008-03-06 13:37:23.582711376 +0100
*************** do
*** 166,173 ****
    esac
  done
  
! # Only do this if --enable-multilib.
! if [ "${enable_multilib}" = yes ]; then
  
  # Compute whether this is the library's top level directory
  # (ie: not a multilib subdirectory, and not a subdirectory like newlib/src).
--- 166,173 ----
    esac
  done
  
! # Only do this if --enable-multilib or --enable-dual-exceptions.
! if test "${enable_multilib}" = yes || test "${enable_dual_exceptions}" = yes; then
  
  # Compute whether this is the library's top level directory
  # (ie: not a multilib subdirectory, and not a subdirectory like newlib/src).
*** gcc/configure.ac.0	2008-03-05 11:54:21.315851416 +0100
--- gcc/configure.ac	2008-03-05 11:54:31.496303752 +0100
*************** stabs=no)
*** 580,585 ****
--- 580,629 ----
  AC_ARG_ENABLE(multilib,
  [  --enable-multilib       enable library support for multiple ABIs],
  [], [enable_multilib=yes])
+ 
+ # With setjmp/longjmp based exception handling only.
+ AC_ARG_ENABLE(sjlj-exceptions,
+ [  --enable-sjlj-exceptions
+                           arrange to use setjmp/longjmp exception handling],
+ [case $target in
+   *-*-hpux10*)
+     if test $enableval != yes; then
+       AC_MSG_WARN([dwarf2 exceptions not supported, sjlj exceptions forced])
+       enableval=yes
+     fi
+     ;;
+ esac
+ force_sjlj_exceptions=yes],
+ [case $target in
+   *-*-hpux10*)
+     force_sjlj_exceptions=yes
+     enableval=yes
+     ;;
+   *)
+     force_sjlj_exceptions=no
+     ;;
+ esac])
+ if test $force_sjlj_exceptions = yes; then
+   sjlj=`if test $enableval = yes; then echo 1; else echo 0; fi`
+   AC_DEFINE_UNQUOTED(CONFIG_SJLJ_EXCEPTIONS, $sjlj,
+     [Define 0/1 to force the choice for exception handling model.])
+ fi
+ 
+ # With both native and setjmp/longjmp based exception handling.
+ AC_ARG_ENABLE(dual-exceptions,
+ [  --enable-dual-exceptions
+                           use native and setjmp/longjmp exception handling],
+ [dual=`if test $enableval = yes; then echo 1; else echo 0; fi`
+ AC_DEFINE_UNQUOTED(CONFIG_DUAL_EXCEPTIONS, $dual,
+   [Define to 1 to enable dual exception handling model.])])
+ 
+ if test x$dual = x1; then
+   if test x$sjlj = x1; then
+     echo "sjlj-exceptions and dual-exceptions are mutually exclusive" 1>&2
+     exit 1
+   fi
+   enable_multilib="${enable_multilib}-sjlj"
+ fi
  AC_SUBST(enable_multilib)
  
  # Enable __cxa_atexit for C++.
*************** objext='.o'
*** 1168,1201 ****
  AC_SUBST(manext)
  AC_SUBST(objext)
  
- # With Setjmp/Longjmp based exception handling.
- AC_ARG_ENABLE(sjlj-exceptions,
- [  --enable-sjlj-exceptions
-                           arrange to use setjmp/longjmp exception handling],
- [case $target in
-   *-*-hpux10*)
-     if test $enableval != yes; then
-       AC_MSG_WARN([dwarf2 exceptions not supported, sjlj exceptions forced])
-       enableval=yes
-     fi
-     ;;
- esac
- force_sjlj_exceptions=yes],
- [case $target in
-   *-*-hpux10*)
-     force_sjlj_exceptions=yes
-     enableval=yes
-     ;;
-   *)
-     force_sjlj_exceptions=no
-     ;;
- esac])
- if test $force_sjlj_exceptions = yes; then
-   sjlj=`if test $enableval = yes; then echo 1; else echo 0; fi`
-   AC_DEFINE_UNQUOTED(CONFIG_SJLJ_EXCEPTIONS, $sjlj,
-     [Define 0/1 to force the choice for exception handling model.])
- fi
- 
  # For platforms with the unwind ABI which includes an unwind library,
  # libunwind, we can choose to use the system libunwind.
  AC_ARG_WITH(system-libunwind,
--- 1212,1217 ----
*** gcc/configure.0	2008-03-05 11:54:17.621413056 +0100
--- gcc/configure	2008-03-05 11:54:46.882964624 +0100
*************** Optional Features:
*** 1027,1032 ****
--- 1028,1037 ----
  			  default is noopt
    --enable-gather-detailed-mem-stats         enable detailed memory allocation stats gathering
    --enable-multilib       enable library support for multiple ABIs
+   --enable-sjlj-exceptions
+                           arrange to use setjmp/longjmp exception handling
+   --enable-dual-exceptions
+                           use native and setjmp/longjmp exception handling
    --enable-__cxa_atexit   enable __cxa_atexit for C++
    --enable-decimal-float={no,yes,bid,dpd}
  			enable decimal float extension to C.  Selecting 'bid'
*************** Optional Features:
*** 1044,1051 ****
    --enable-languages=LIST specify which front-ends to build
    --disable-rpath         do not hardcode runtime library paths
    --enable-initfini-array	use .init_array/.fini_array sections
-   --enable-sjlj-exceptions
-                           arrange to use setjmp/longjmp exception handling
    --enable-secureplt      enable -msecure-plt by default for PowerPC
    --enable-cld            enable -mcld by default for 32bit x86
    --disable-win32-registry
--- 1048,1053 ----
*************** else
*** 7135,7140 ****
--- 7137,7196 ----
    enable_multilib=yes
  fi;
  
+ # With setjmp/longjmp based exception handling only.
+ # Check whether --enable-sjlj-exceptions or --disable-sjlj-exceptions was given.
+ if test "${enable_sjlj_exceptions+set}" = set; then
+   enableval="$enable_sjlj_exceptions"
+   case $target in
+   *-*-hpux10*)
+     if test $enableval != yes; then
+       { echo "$as_me:$LINENO: WARNING: dwarf2 exceptions not supported, sjlj exceptions forced" >&5
+ echo "$as_me: WARNING: dwarf2 exceptions not supported, sjlj exceptions forced" >&2;}
+       enableval=yes
+     fi
+     ;;
+ esac
+ force_sjlj_exceptions=yes
+ else
+   case $target in
+   *-*-hpux10*)
+     force_sjlj_exceptions=yes
+     enableval=yes
+     ;;
+   *)
+     force_sjlj_exceptions=no
+     ;;
+ esac
+ fi;
+ if test $force_sjlj_exceptions = yes; then
+   sjlj=`if test $enableval = yes; then echo 1; else echo 0; fi`
+ 
+ cat >>confdefs.h <<_ACEOF
+ #define CONFIG_SJLJ_EXCEPTIONS $sjlj
+ _ACEOF
+ 
+ fi
+ 
+ # With both native and setjmp/longjmp based exception handling.
+ # Check whether --enable-dual-exceptions or --disable-dual-exceptions was given.
+ if test "${enable_dual_exceptions+set}" = set; then
+   enableval="$enable_dual_exceptions"
+   dual=`if test $enableval = yes; then echo 1; else echo 0; fi`
+ 
+ cat >>confdefs.h <<_ACEOF
+ #define CONFIG_DUAL_EXCEPTIONS $dual
+ _ACEOF
+ 
+ fi;
+ 
+ if test x$dual = x1; then
+   if test x$sjlj = x1; then
+     echo "sjlj-exceptions and dual-exceptions are mutually exclusive" 1>&2
+     exit 1
+   fi
+   enable_multilib="${enable_multilib}-sjlj"
+ fi
+ 
  
  # Enable __cxa_atexit for C++.
  # Check whether --enable-__cxa_atexit or --disable-__cxa_atexit was given.
*************** objext='.o'
*** 12373,12412 ****
  
  
  
- # With Setjmp/Longjmp based exception handling.
- # Check whether --enable-sjlj-exceptions or --disable-sjlj-exceptions was given.
- if test "${enable_sjlj_exceptions+set}" = set; then
-   enableval="$enable_sjlj_exceptions"
-   case $target in
-   *-*-hpux10*)
-     if test $enableval != yes; then
-       { echo "$as_me:$LINENO: WARNING: dwarf2 exceptions not supported, sjlj exceptions forced" >&5
- echo "$as_me: WARNING: dwarf2 exceptions not supported, sjlj exceptions forced" >&2;}
-       enableval=yes
-     fi
-     ;;
- esac
- force_sjlj_exceptions=yes
- else
-   case $target in
-   *-*-hpux10*)
-     force_sjlj_exceptions=yes
-     enableval=yes
-     ;;
-   *)
-     force_sjlj_exceptions=no
-     ;;
- esac
- fi;
- if test $force_sjlj_exceptions = yes; then
-   sjlj=`if test $enableval = yes; then echo 1; else echo 0; fi`
- 
- cat >>confdefs.h <<_ACEOF
- #define CONFIG_SJLJ_EXCEPTIONS $sjlj
- _ACEOF
- 
- fi
- 
  # For platforms with the unwind ABI which includes an unwind library,
  # libunwind, we can choose to use the system libunwind.
  
--- 12429,12434 ----
*** gcc/config.in.0	2008-03-05 11:54:25.214258768 +0100
--- gcc/config.in	2008-03-05 11:54:59.955977224 +0100
***************
*** 6,11 ****
--- 6,17 ----
  #endif
  
  
+ /* Define to 1 to enable dual exception handling model. */
+ #ifndef USED_FOR_TARGET
+ #undef CONFIG_DUAL_EXCEPTIONS
+ #endif
+ 
+ 
  /* Define 0/1 to force the choice for exception handling model. */
  #ifndef USED_FOR_TARGET
  #undef CONFIG_SJLJ_EXCEPTIONS
*** gcc/Makefile.in.0	2008-03-04 20:40:22.000000000 +0100
--- gcc/Makefile.in	2008-03-04 21:07:14.000000000 +0100
*************** libgcc.mvars: config.status Makefile $(L
*** 1657,1663 ****
  # switches.
  multilib.h: s-mlib; @true
  s-mlib: $(srcdir)/genmultilib Makefile
! 	if test @enable_multilib@ = yes \
  	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
  	  $(SHELL) $(srcdir)/genmultilib \
  	    "$(MULTILIB_OPTIONS)" \
--- 1657,1663 ----
  # switches.
  multilib.h: s-mlib; @true
  s-mlib: $(srcdir)/genmultilib Makefile
! 	if test @enable_multilib@ != no \
  	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
  	  $(SHELL) $(srcdir)/genmultilib \
  	    "$(MULTILIB_OPTIONS)" \
*** gcc/genmultilib.0	2008-03-05 23:30:00.000000000 +0100
--- gcc/genmultilib	2008-03-05 23:46:05.000000000 +0100
***************
*** 73,80 ****
  # the os directory names are used exclusively.  Use the mapping when
  # there is no one-to-one equivalence between GCC levels and the OS.
  
! # The last option should be "yes" if multilibs are enabled.  If it is not
! # "yes", all GCC multilib dir names will be ".".
  
  # The output looks like
  #   #define MULTILIB_MATCHES "\
--- 73,82 ----
  # the os directory names are used exclusively.  Use the mapping when
  # there is no one-to-one equivalence between GCC levels and the OS.
  
! # The eighth argument is "yes" if multilibs are enabled and "yes-sjlj"
! # if SJLJ multilibs are additionally enabled.  It is "no" if multilibs
! # are not enabled and "no-sjlj" if only SJLJ multilibs are enabled; in
! # either case, all non-SJLJ multilibs dir names will be ".".
  
  # The output looks like
  #   #define MULTILIB_MATCHES "\
*************** exclusions=$6
*** 123,128 ****
--- 125,137 ----
  osdirnames=$7
  enable_multilib=$8
  
+ if expr "${enable_multilib}" : ".*-sjlj" > /dev/null; then
+   options="${options} fsjlj"
+   dirnames="${dirnames} sjlj"
+   osdirnames="${osdirnames} sjlj"
+   enable_multilib=`echo ${enable_multilib} | sed -e 's|-sjlj||'`
+ fi
+ 
  echo "static const char *const multilib_raw[] = {"
  
  mkdir tmpmultilib.$$ || exit 1
*************** for combo in ${combinations}; do
*** 322,328 ****
      # Remove the leading and trailing slashes.
      osdirout=`echo ${osdirout} | sed -e 's|^/||' -e 's|/$||g'`
      if [ "x${enable_multilib}" != xyes ]; then
!       dirout=".:${osdirout}"
        disable_multilib=yes
      else
        case "${osdirout}" in
--- 331,340 ----
      # Remove the leading and trailing slashes.
      osdirout=`echo ${osdirout} | sed -e 's|^/||' -e 's|/$||g'`
      if [ "x${enable_multilib}" != xyes ]; then
!       if [ x"${dirout}" != xsjlj ] ; then
!         dirout="."
!       fi
!       dirout="${dirout}:${osdirout}"
        disable_multilib=yes
      else
        case "${osdirout}" in
*************** for combo in ${combinations}; do
*** 336,345 ****
      fi
    else
      if [ "x${enable_multilib}" != xyes ]; then
!       # genmultilib with --disable-multilib should be
!       # called with '' '' '' '' '' '' '' no
!       # if MULTILIB_OSDIRNAMES is empty.
!       exit 1
      fi
    fi
  
--- 348,356 ----
      fi
    else
      if [ "x${enable_multilib}" != xyes ]; then
!       if [ x"${dirout}" != xsjlj ] ; then
!         dirout="."
!       fi
      fi
    fi
  
*** gcc/common.opt.0	2008-03-04 20:40:22.000000000 +0100
--- gcc/common.opt	2008-03-04 21:07:26.000000000 +0100
*************** fsingle-precision-constant
*** 944,949 ****
--- 944,953 ----
  Common Report Var(flag_single_precision_constant) Optimization
  Convert floating point constants to single precision constants
  
+ fsjlj
+ Common Report Var(flag_sjlj)
+ Use setjmp/longjmp exception handling if configured with dual exceptions support
+ 
  fsplit-ivs-in-unroller
  Common Report Var(flag_split_ivs_in_unroller) Init(1) Optimization
  Split lifetimes of induction variables when loops are unrolled
*** gcc/doc/invoke.texi.0	2008-03-04 20:40:22.000000000 +0100
--- gcc/doc/invoke.texi	2008-03-04 21:11:31.000000000 +0100
*************** See S/390 and zSeries Options.
*** 810,816 ****
  @gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
  -ffixed-@var{reg}  -fexceptions @gol
  -fnon-call-exceptions  -funwind-tables @gol
! -fasynchronous-unwind-tables @gol
  -finhibit-size-directive  -finstrument-functions @gol
  -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol
  -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{} @gol
--- 810,816 ----
  @gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
  -ffixed-@var{reg}  -fexceptions @gol
  -fnon-call-exceptions  -funwind-tables @gol
! -fasynchronous-unwind-tables  -fsjlj @gol
  -finhibit-size-directive  -finstrument-functions @gol
  -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol
  -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{} @gol
*************** Generate unwind table in dwarf2 format, 
*** 14850,14855 ****
--- 14850,14861 ----
  table is exact at each instruction boundary, so it can be used for stack
  unwinding from asynchronous events (such as debugger or garbage collector).
  
+ @item -fsjlj
+ @opindex fsjlj
+ Use setjmp/longjmp exception instead of native exception handling.  The
+ compiler must have been configured with dual exceptions support for this
+ option to be available (@option{--enable-dual-exceptions}).
+ 
  @item -fpcc-struct-return
  @opindex fpcc-struct-return
  Return ``short'' @code{struct} and @code{union} values in memory like
*** gcc/except.h.0	2008-03-04 20:40:22.000000000 +0100
--- gcc/except.h	2008-03-04 21:07:27.000000000 +0100
*************** extern int (*lang_eh_type_covers) (tree 
*** 131,137 ****
  extern tree (*lang_eh_runtime_type) (tree);
  
  
! /* Just because the user configured --with-sjlj-exceptions=no doesn't
     mean that we can use call frame exceptions.  Detect that the target
     has appropriate support.  */
  
--- 131,137 ----
  extern tree (*lang_eh_runtime_type) (tree);
  
  
! /* Just because the user configured --disable-sjlj-exceptions doesn't
     mean that we can use call frame exceptions.  Detect that the target
     has appropriate support.  */
  
*************** extern tree (*lang_eh_runtime_type) (tre
*** 147,166 ****
  # endif
  #endif
  
! #ifdef CONFIG_SJLJ_EXCEPTIONS
  # if CONFIG_SJLJ_EXCEPTIONS == 1
  #  define USING_SJLJ_EXCEPTIONS		1
! # endif
! # if CONFIG_SJLJ_EXCEPTIONS == 0
! #  define USING_SJLJ_EXCEPTIONS		0
  #  ifndef EH_RETURN_DATA_REGNO
!     #error "EH_RETURN_DATA_REGNO required"
  #  endif
  #  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)
!     #error "EH_RETURN_HANDLER_RTX or eh_return required"
  #  endif
  #  if !defined(DWARF2_UNWIND_INFO) && !defined(TARGET_UNWIND_INFO)
!     #error "{DWARF2,TARGET}_UNWIND_INFO required"
  #  endif
  # endif
  #else
--- 147,169 ----
  # endif
  #endif
  
! #if defined (CONFIG_SJLJ_EXCEPTIONS) || CONFIG_DUAL_EXCEPTIONS == 1
  # if CONFIG_SJLJ_EXCEPTIONS == 1
  #  define USING_SJLJ_EXCEPTIONS		1
! # else
! #  if CONFIG_DUAL_EXCEPTIONS == 1
! #    define USING_SJLJ_EXCEPTIONS	flag_sjlj
! #  else
! #    define USING_SJLJ_EXCEPTIONS	0
! #  endif
  #  ifndef EH_RETURN_DATA_REGNO
! #    error "EH_RETURN_DATA_REGNO required"
  #  endif
  #  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)
! #    error "EH_RETURN_HANDLER_RTX or eh_return required"
  #  endif
  #  if !defined(DWARF2_UNWIND_INFO) && !defined(TARGET_UNWIND_INFO)
! #    error "{DWARF2,TARGET}_UNWIND_INFO required"
  #  endif
  # endif
  #else
*** gcc/gcc.c.0	2008-03-06 16:03:38.216764240 +0100
--- gcc/gcc.c	2008-03-06 16:10:11.784932784 +0100
*************** static const struct option_map option_ma
*** 1158,1163 ****
--- 1158,1164 ----
     {"--save-temps", "-save-temps", 0},
     {"--shared", "-shared", 0},
     {"--silent", "-q", 0},
+    {"--sjlj-exceptions", "-fsjlj", 0},
     {"--specs", "-specs=", "aj"},
     {"--static", "-static", 0},
     {"--std", "-std=", "aj"},
*************** for_each_path (const struct path_prefix 
*** 2434,2439 ****
--- 2435,2441 ----
    struct prefix_list *pl;
    const char *multi_dir = NULL;
    const char *multi_os_dir = NULL;
+   const char *multi_os_dir_sjlj = NULL;
    const char *multi_suffix;
    const char *just_multi_suffix;
    char *path = NULL;
*************** for_each_path (const struct path_prefix 
*** 2450,2456 ****
        just_multi_suffix = concat (just_multi_suffix, multi_dir, NULL);
      }
    if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0)
!     multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL);
  
    while (1)
      {
--- 2452,2468 ----
        just_multi_suffix = concat (just_multi_suffix, multi_dir, NULL);
      }
    if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0)
!     {
!       size_t len = strlen (multilib_os_dir);
!       multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL);
!       if (len > 4 && strncmp (multi_os_dir + len - 4, "sjlj", 4) == 0)
! 	{
! 	   char *tmp = XNEWVEC (char, len);
! 	   memcpy (tmp, multi_os_dir, len);
! 	   tmp [len - 4] = '\0';
! 	   multi_os_dir_sjlj = tmp;
! 	}
!     }
  
    while (1)
      {
*************** for_each_path (const struct path_prefix 
*** 2552,2558 ****
        if (multi_os_dir)
  	{
  	  free (CONST_CAST (char *, multi_os_dir));
! 	  multi_os_dir = NULL;
  	}
        else
  	skip_multi_os_dir = true;
--- 2564,2576 ----
        if (multi_os_dir)
  	{
  	  free (CONST_CAST (char *, multi_os_dir));
! 	  if (multi_os_dir_sjlj)
! 	    {
! 	      multi_os_dir = multi_os_dir_sjlj;
! 	      multi_os_dir_sjlj = NULL;
! 	    }
! 	  else
! 	    multi_os_dir = NULL;
  	}
        else
  	skip_multi_os_dir = true;
*************** for_each_path (const struct path_prefix 
*** 2566,2571 ****
--- 2584,2591 ----
      }
    if (multi_os_dir)
      free (CONST_CAST (char *, multi_os_dir));
+   if (multi_os_dir_sjlj)
+     free (CONST_CAST (char *, multi_os_dir_sjlj));
    if (ret != path)
      free (path);
    return ret;
*** Makefile.in.orig	2008-03-05 11:01:07.000000000 +0100
--- Makefile.in	2008-03-05 11:02:57.000000000 +0100
***************
*** 50076,50082 ****
  	  $(do-compare) > /dev/null 2>&1; \
  	  if test $$? -eq 1; then \
  	    case $$file in \
! 	      ./cc*-checksum$(objext) | ./libgcc/* ) \
  	        echo warning: $$file differs ;; \
  	      *) \
  	        echo $$file differs >> .bad_compare ;; \
--- 50076,50082 ----
  	  $(do-compare) > /dev/null 2>&1; \
  	  if test $$? -eq 1; then \
  	    case $$file in \
! 	      ./cc*-checksum$(objext) | ./libgcc/* | ./ada/bldtools/* | ./ada/doctools/*) \
  	        echo warning: $$file differs ;; \
  	      *) \
  	        echo $$file differs >> .bad_compare ;; \
*** gcc/builtins.c.0	2008-03-05 09:15:24.924603248 +0100
--- gcc/builtins.c	2008-03-05 09:15:38.113598216 +0100
*************** static int apply_result_size (void);
*** 83,89 ****
  #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)
  static rtx result_vector (int, rtx);
  #endif
- static void expand_builtin_update_setjmp_buf (rtx);
  static void expand_builtin_prefetch (tree);
  static rtx expand_builtin_apply_args (void);
  static rtx expand_builtin_apply_args_1 (void);
--- 83,88 ----
*************** expand_builtin_nonlocal_goto (tree exp)
*** 946,960 ****
  /* __builtin_update_setjmp_buf is passed a pointer to an array of five words
     (not all will be used on all machines) that was passed to __builtin_setjmp.
     It updates the stack pointer in that block to correspond to the current
!    stack pointer.  */
  
! static void
  expand_builtin_update_setjmp_buf (rtx buf_addr)
  {
    enum machine_mode sa_mode = Pmode;
    rtx stack_save;
  
- 
  #ifdef HAVE_save_stack_nonlocal
    if (HAVE_save_stack_nonlocal)
      sa_mode = insn_data[(int) CODE_FOR_save_stack_nonlocal].operand[0].mode;
--- 945,958 ----
  /* __builtin_update_setjmp_buf is passed a pointer to an array of five words
     (not all will be used on all machines) that was passed to __builtin_setjmp.
     It updates the stack pointer in that block to correspond to the current
!    stack pointer.  This is used directly by sjlj exception handling code.  */
  
! void
  expand_builtin_update_setjmp_buf (rtx buf_addr)
  {
    enum machine_mode sa_mode = Pmode;
    rtx stack_save;
  
  #ifdef HAVE_save_stack_nonlocal
    if (HAVE_save_stack_nonlocal)
      sa_mode = insn_data[(int) CODE_FOR_save_stack_nonlocal].operand[0].mode;
*** gcc/calls.c.0	2008-03-05 09:15:24.939600968 +0100
--- gcc/calls.c	2008-03-05 09:15:38.118597456 +0100
*************** expand_call (tree exp, rtx target, int i
*** 3109,3120 ****
  	  stack_usage_map = initial_stack_usage_map;
  	}
  
!       /* If this was alloca, record the new stack level for nonlocal gotos.
! 	 Check for the handler slots since we might not have a save area
! 	 for non-local gotos.  */
! 
!       if ((flags & ECF_MAY_BE_ALLOCA) && cfun->nonlocal_goto_save_area != 0)
! 	update_nonlocal_goto_save_area ();
  
        /* Free up storage we no longer need.  */
        for (i = 0; i < num_actuals; ++i)
--- 3109,3125 ----
  	  stack_usage_map = initial_stack_usage_map;
  	}
  
!       /* If this was alloca, record the new stack level.  */
!       if (flags & ECF_MAY_BE_ALLOCA)
! 	{
! 	  /* Record the new stack level for nonlocal gotos.  */
! 	  if (cfun->nonlocal_goto_save_area)
! 	    update_nonlocal_goto_save_area ();
! 
! 	  /* Record the new stack level for sjlj exceptions.  */
! 	  if (USING_SJLJ_EXCEPTIONS)
! 	    update_sjlj_context ();
! 	}
  
        /* Free up storage we no longer need.  */
        for (i = 0; i < num_actuals; ++i)
*** gcc/cfglayout.c.0	2008-03-05 10:37:04.003830000 +0100
--- gcc/cfglayout.c	2008-03-05 10:38:35.168970792 +0100
*************** duplicate_insn_chain (rtx from, rtx to)
*** 1102,1107 ****
--- 1102,1108 ----
  	      break;
  
  	    case NOTE_INSN_SWITCH_TEXT_SECTIONS:
+ 	    case NOTE_INSN_UPDATE_SJLJ_CONTEXT:
  	      emit_note_copy (insn);
  	      break;
  
*** gcc/except.c.0	2008-03-05 09:15:24.961597624 +0100
--- gcc/except.c	2008-03-05 10:39:57.887395680 +0100
*************** sjlj_mark_call_sites (struct sjlj_lp_inf
*** 1797,1802 ****
--- 1797,1815 ----
        if (LABEL_P (insn))
  	last_call_site = -2;
  
+       /* If the function allocates dynamic stack space, the context must
+ 	 be updated after every allocation/deallocation accordingly.  */
+       if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_UPDATE_SJLJ_CONTEXT)
+ 	{
+ 	  rtx buf_addr
+ 	    = plus_constant (XEXP (cfun->eh->sjlj_fc, 0), sjlj_fc_jbuf_ofs);
+ 	  start_sequence ();
+ 	  expand_builtin_update_setjmp_buf (buf_addr);
+ 	  p = get_insns ();
+ 	  end_sequence ();
+ 	  emit_insn_before (p, insn);
+ 	}
+ 
        if (! INSN_P (insn))
  	continue;
  
*************** sjlj_build_landing_pads (void)
*** 2078,2083 ****
--- 2091,2108 ----
    free (lp_info);
  }
  
+ /* Update the sjlj function context.  This function should be called
+    whenever we allocate or deallocate dynamic stack space.  */
+ 
+ void
+ update_sjlj_context (void)
+ {
+   if (!flag_exceptions)
+     return;
+ 
+   emit_note (NOTE_INSN_UPDATE_SJLJ_CONTEXT);
+ }
+ 
  void
  finish_eh_generation (void)
  {
*** gcc/except.h.0	2008-03-05 09:15:24.969596408 +0100
--- gcc/except.h	2008-03-05 09:15:38.126596240 +0100
*************** extern int duplicate_eh_regions (struct 
*** 85,90 ****
--- 85,91 ----
  				 void *, int, int);
  
  extern void sjlj_emit_function_exit_after (rtx);
+ extern void update_sjlj_context (void);
  extern void default_init_unwind_resume_libfunc (void);
  
  extern struct eh_region *gen_eh_region_cleanup (struct eh_region *,
*** gcc/explow.c.0	2008-03-05 09:15:24.977595192 +0100
--- gcc/explow.c	2008-03-05 09:37:56.051200784 +0100
*************** allocate_dynamic_stack_space (rtx size, 
*** 1282,1290 ****
      }
  
    /* Record the new stack level for nonlocal gotos.  */
!   if (cfun->nonlocal_goto_save_area != 0)
      update_nonlocal_goto_save_area ();
  
    return target;
  }
  
--- 1283,1295 ----
      }
  
    /* Record the new stack level for nonlocal gotos.  */
!   if (cfun->nonlocal_goto_save_area)
      update_nonlocal_goto_save_area ();
  
+   /* Record the new stack level for sjlj exceptions.  */
+   if (USING_SJLJ_EXCEPTIONS)
+     update_sjlj_context ();
+ 
    return target;
  }
  
*** gcc/expr.h.0	2008-03-05 09:15:24.986593824 +0100
--- gcc/expr.h	2008-03-05 09:15:38.129595784 +0100
*************** extern void std_expand_builtin_va_start 
*** 346,351 ****
--- 346,352 ----
  extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);
  extern void expand_builtin_setjmp_setup (rtx, rtx);
  extern void expand_builtin_setjmp_receiver (rtx);
+ extern void expand_builtin_update_setjmp_buf (rtx);
  extern rtx expand_builtin_saveregs (void);
  extern void expand_builtin_trap (void);
  extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);
*** gcc/final.c.0	2008-03-05 10:36:56.359992040 +0100
--- gcc/final.c	2008-03-05 10:37:54.126210240 +0100
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1773,1778 ****
--- 1773,1779 ----
        switch (NOTE_KIND (insn))
  	{
  	case NOTE_INSN_DELETED:
+ 	case NOTE_INSN_UPDATE_SJLJ_CONTEXT:
  	  break;
  
  	case NOTE_INSN_SWITCH_TEXT_SECTIONS:
*** gcc/insn-notes.def.0	2008-03-05 09:15:25.001591544 +0100
--- gcc/insn-notes.def	2008-03-05 09:15:38.135594872 +0100
*************** INSN_NOTE (BASIC_BLOCK)
*** 70,73 ****
--- 70,77 ----
     between hot and cold text sections.  */
  INSN_NOTE (SWITCH_TEXT_SECTIONS)
  
+ /* This note indicates that the function context must be updated if
+    the Setjmp/Longjmp exception mechanism is used.  */
+ INSN_NOTE (UPDATE_SJLJ_CONTEXT)
+ 
  #undef INSN_NOTE
*** gcc/stmt.c.0	2008-05-12 14:54:53.183177000 +0200
--- gcc/stmt.c	2008-05-12 15:08:44.180846736 +0200
*************** expand_decl (tree decl)
*** 1981,1997 ****
  }
  
  /* Emit code to save the current value of stack.  */
  rtx
  expand_stack_save (void)
  {
    rtx ret = NULL_RTX;
  
-   do_pending_stack_adjust ();
    emit_stack_save (SAVE_BLOCK, &ret, NULL_RTX);
    return ret;
  }
  
  /* Emit code to restore the current value of stack.  */
  void
  expand_stack_restore (tree var)
  {
--- 1981,1998 ----
  }
  
  /* Emit code to save the current value of stack.  */
+ 
  rtx
  expand_stack_save (void)
  {
    rtx ret = NULL_RTX;
  
    emit_stack_save (SAVE_BLOCK, &ret, NULL_RTX);
    return ret;
  }
  
  /* Emit code to restore the current value of stack.  */
+ 
  void
  expand_stack_restore (tree var)
  {
*************** expand_stack_restore (tree var)
*** 1999,2004 ****
--- 2000,2013 ----
  
    sa = convert_memory_address (Pmode, sa);
    emit_stack_restore (SAVE_BLOCK, sa, NULL_RTX);
+ 
+   /* Record the new stack level for nonlocal gotos.  */
+   if (cfun->nonlocal_goto_save_area)
+     update_nonlocal_goto_save_area ();
+ 
+   /* Record the new stack level for sjlj exceptions.  */
+   if (USING_SJLJ_EXCEPTIONS)
+     update_sjlj_context ();
  }
  
  /* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.
*** gcc/Makefile.in.orig	Wed Mar 12 17:40:19 2008
--- gcc/Makefile.in	Wed Mar 12 17:40:35 2008
***************
*** 267,272 ****
--- 267,274 ----
  # UNSORTED
  # --------
  
+ CROSS=@CROSS@
+ 
  # Some compilers can't handle cc -c blah.c -o foo/blah.o.
  # In stage2 and beyond, we force this to "-o $@" since we know we're using gcc.
  OUTPUT_OPTION = @OUTPUT_OPTION@
*** gcc/configure.ac.orig	2008-03-14 09:05:34.000000000 +0100
--- gcc/configure.ac	2008-03-14 09:10:45.000000000 +0100
***************
*** 325,331 ****
  ACX_PROG_CC_WARNING_OPTS([-Wold-style-definition \
                            -Wmissing-format-attribute], [strict_warn])
  ACX_PROG_CC_WARNING_ALMOST_PEDANTIC([-Wno-long-long -Wno-variadic-macros \
! 				     -Wno-overlength-strings], [strict_warn])
  ACX_PROG_CC_WARNINGS_ARE_ERRORS([manual], [strict_warn])
  
  # The above macros do nothing if the compiler is not GCC.  However, the
--- 325,331 ----
  ACX_PROG_CC_WARNING_OPTS([-Wold-style-definition \
                            -Wmissing-format-attribute], [strict_warn])
  ACX_PROG_CC_WARNING_ALMOST_PEDANTIC([-Wno-long-long -Wno-variadic-macros \
!          -Wno-overlength-strings], [strict_warn])
  ACX_PROG_CC_WARNINGS_ARE_ERRORS([manual], [strict_warn])
  
  # The above macros do nothing if the compiler is not GCC.  However, the
*** gcc/configure.orig	2008-03-14 09:05:29.000000000 +0100
--- gcc/configure	2008-03-14 09:12:14.000000000 +0100
***************
*** 6491,6497 ****
  else
    save_CFLAGS="$CFLAGS"
  CFLAGS="-pedantic -Wno-long-long -Wno-variadic-macros \
! 				     -Wno-overlength-strings"
  cat >conftest.$ac_ext <<_ACEOF
  /* confdefs.h.  */
  _ACEOF
--- 6491,6497 ----
  else
    save_CFLAGS="$CFLAGS"
  CFLAGS="-pedantic -Wno-long-long -Wno-variadic-macros \
!          -Wno-overlength-strings"
  cat >conftest.$ac_ext <<_ACEOF
  /* confdefs.h.  */
  _ACEOF
***************
*** 6543,6549 ****
  echo "${ECHO_T}$acx_cv_prog_cc_pedantic__Wno_long_long__Wno_variadic_macros_____________Wno_overlength_strings" >&6
  if test $acx_cv_prog_cc_pedantic__Wno_long_long__Wno_variadic_macros_____________Wno_overlength_strings = yes; then
    strict_warn="$strict_warn${strict_warn:+ }-pedantic -Wno-long-long -Wno-variadic-macros \
! 				     -Wno-overlength-strings"
  fi
  
  
--- 6543,6549 ----
  echo "${ECHO_T}$acx_cv_prog_cc_pedantic__Wno_long_long__Wno_variadic_macros_____________Wno_overlength_strings" >&6
  if test $acx_cv_prog_cc_pedantic__Wno_long_long__Wno_variadic_macros_____________Wno_overlength_strings = yes; then
    strict_warn="$strict_warn${strict_warn:+ }-pedantic -Wno-long-long -Wno-variadic-macros \
!          -Wno-overlength-strings"
  fi
  
  
*** gcc/config/i386/i386.c.ori	Thu Mar 20 12:54:16 2008
--- gcc/config/i386/i386.c	Thu Mar 20 16:33:03 2008
*************** ix86_comp_type_attributes (const_tree ty
*** 3217,3222 ****
--- 3217,3268 ----
    return 1;
  }
  
+ 
+ /* The possible stack realignment needs for a function.  */
+ 
+ enum
+   { STK_REALIGN_NONEED = 0,     /* None.  */
+     STK_REALIGN_REQUESTED = 1,  /* Requested, warning on failure.  */
+     STK_REALIGN_REQUIRED  = 2   /* Required, error on failure.  */
+   };
+ 
+ /* The actual stack realignment needs for a function DECL.
+ 
+    REQUIRED for 'main' and FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN,
+             or explicit request from function specific attribute.
+ 
+    otherwise, REQUESTED if command line option for the whole unit,
+ 
+    otherwise NONEED. */
+ 
+ static int
+ ix86_stack_realignment_for (tree decl)
+ {
+   bool has_force_align_arg_pointer
+     = (0 != lookup_attribute (ix86_force_align_arg_pointer_string,
+ 			      TYPE_ATTRIBUTES (TREE_TYPE (decl))));
+   
+   if (has_force_align_arg_pointer
+       || (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
+ 	  && DECL_NAME (decl) && MAIN_NAME_P (DECL_NAME (decl))
+ 	  && DECL_FILE_SCOPE_P (decl)))
+     return STK_REALIGN_REQUIRED;
+ 
+   else if (ix86_force_align_arg_pointer)
+     return STK_REALIGN_REQUESTED;
+ 
+   else
+     return STK_REALIGN_NONEED;
+ }
+ 
+ /* Whether a function denoted by DECL needs a static chain.  */
+ 
+ static bool
+ needs_static_chain_p (tree decl)
+ {
+   return decl_function_context (decl) && !DECL_NO_STATIC_CHAIN (decl);
+ }
+ 
  /* Return the regparm value for a function with the indicated TYPE and DECL.
     DECL may be NULL when calling function indirectly
     or considering a libcall.  */
*************** ix86_function_regparm (const_tree type, 
*** 3246,3252 ****
        if (i && i->local)
  	{
  	  int local_regparm, globals = 0, regno;
- 	  struct function *f;
  
  	  /* Make sure no regparm register is taken by a
  	     fixed register variable.  */
--- 3307,3312 ----
*************** ix86_function_regparm (const_tree type, 
*** 3259,3277 ****
  	  if (local_regparm == 3
  	      && (decl_function_context (decl)
                    || ix86_force_align_arg_pointer)
! 	      && !DECL_NO_STATIC_CHAIN (decl))
  	    local_regparm = 2;
  
! 	  /* If the function realigns its stackpointer, the prologue will
! 	     clobber %ecx.  If we've already generated code for the callee,
! 	     the callee DECL_STRUCT_FUNCTION is gone, so we fall back to
! 	     scanning the attributes for the self-realigning property.  */
! 	  f = DECL_STRUCT_FUNCTION (decl);
! 	  if (local_regparm == 3
! 	      && (f ? !!f->machine->force_align_arg_pointer
! 		  : !!lookup_attribute (ix86_force_align_arg_pointer_string,
! 					TYPE_ATTRIBUTES (TREE_TYPE (decl)))))
! 	    local_regparm = 2;
  
  	  /* Each fixed register usage increases register pressure,
  	     so less registers should be used for argument passing.
--- 3305,3319 ----
  	  if (local_regparm == 3
  	      && (decl_function_context (decl)
                    || ix86_force_align_arg_pointer)
! 	      && needs_static_chain_p (decl))
  	    local_regparm = 2;
  
! 	  /* Don't risk interfering with stack pointer realignment needs.
! 	     We could probably do better, but it appears unlikely to be
! 	     worth the effort.  */
! 	  if (local_regparm > 0
! 	      && ix86_stack_realignment_for (decl) != STK_REALIGN_NONEED)
! 	    local_regparm = 0;
  
  	  /* Each fixed register usage increases register pressure,
  	     so less registers should be used for argument passing.
*************** pro_epilogue_adjust_stack (rtx dest, rtx
*** 6240,6277 ****
      RTX_FRAME_RELATED_P (insn) = 1;
  }
  
  /* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */
  
  static rtx
  ix86_internal_arg_pointer (void)
  {
!   bool has_force_align_arg_pointer =
!     (0 != lookup_attribute (ix86_force_align_arg_pointer_string,
! 			    TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))));
!   if ((FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
!        && DECL_NAME (current_function_decl)
!        && MAIN_NAME_P (DECL_NAME (current_function_decl))
!        && DECL_FILE_SCOPE_P (current_function_decl))
!       || ix86_force_align_arg_pointer
!       || has_force_align_arg_pointer)
!     {
!       /* Nested functions can't realign the stack due to a register
! 	 conflict.  */
!       if (DECL_CONTEXT (current_function_decl)
! 	  && TREE_CODE (DECL_CONTEXT (current_function_decl)) == FUNCTION_DECL)
! 	{
! 	  if (ix86_force_align_arg_pointer)
! 	    warning (0, "-mstackrealign ignored for nested functions");
! 	  if (has_force_align_arg_pointer)
! 	    error ("%s not supported for nested functions",
! 		   ix86_force_align_arg_pointer_string);
! 	  return virtual_incoming_args_rtx;
! 	}
!       cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, CX_REG);
!       return copy_to_reg (cfun->machine->force_align_arg_pointer);
      }
!   else
!     return virtual_incoming_args_rtx;
  }
  
  /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.
--- 6282,6439 ----
      RTX_FRAME_RELATED_P (insn) = 1;
  }
  
+ /* The stack realignment handling uses a scratch register to act as
+    the internal argument pointer.  This register is
+ 
+    o loaded with the argument pointer value (sp+4), as the very first
+      operation emitted by the prologue expander just before the actual
+      stack pointer realignment (see ix86_expand_prologue).
+ 
+    o included in the set of registers to be saved/restored, then used by
+      the epilogue expander past its restoration to recompute the entry stack
+      pointer value (see ix86_save_reg and ix86_expand_epilogue).
+ 
+    o used to load the arguments to their local home within the function
+      at the very start of it (via expansions from assign_parms).
+ 
+   Bottom line, a given function may use any register dead both on entry and on
+   exit for this purpose.
+ 
+   As call-clobbered registers in the base ABI, EAX, ECX and EDX are natural
+   candidates.  None of them can be used blindly, however, considering possible
+   static chains or other calling conventions constraints.
+ 
+   We have a dedicated predicate for each candidate below, intended to be
+   conservative.  For instance, they might decide to answer 'no, this reg may
+   not be used' based on the 'regparm' value but not looking at the actual
+   number of arguments the function expects.
+ 
+   This is all 32bit ABI centric as of now.  We expect not to have the need
+   in the 64bit case anyway.  */
+ 
+ /* Whether EAX (regno 0) is live on function DECL entry or exit.  */
+ 
+ static bool
+ ix86_eax_maybe_live_in_or_out (tree decl ATTRIBUTE_UNUSED, bool fastcall_p,
+                                int regparm, int regret)
+ {
+   return
+     (/* Maybe needed for argument passing ...
+         ('fastcall' sets regparm to 2 and might use ecx+edx  */
+      (regparm >= 1 && !fastcall_p)
+ 
+      /* or for value returning.  */
+      || regret >= 1);
+ }
+ 
+ 
+ /* Whether EDX (regno 1) is live on function DECL entry or exit.  */
+ 
+ static bool
+ ix86_edx_maybe_live_in_or_out (tree decl ATTRIBUTE_UNUSED, bool fastcall_p,
+                                int regparm, int regret)
+ {
+   return
+     (/* Maybe needed for argument passing ... */
+      fastcall_p || regparm >= 2
+ 
+      /* or for value returning.  */
+      || regret >= 2);
+ }
+ 
+ /* Whether ECX (regno 2) is live on function DECL entry or exit.  */
+ 
+ static bool
+ ix86_ecx_maybe_live_in_or_out (tree decl, bool fastcall_p,
+                                int regparm, int regret ATTRIBUTE_UNUSED)
+ {
+   return
+     (/* Maybe needed for argument passing ...  */
+      fastcall_p || regparm >= 3
+ 
+      /* or as the static chain register.  */
+      || needs_static_chain_p (decl));
+ }
+ 
+ /* A REGNO available for use as the internal arg pointer for stack realignment
+    purposes in function DECL, if any, -1 otherwise.  */
+ 
+ static int
+ ix86_stack_realign_arg_pointer_regno_for (tree decl)
+ {
+   tree fntype = TREE_TYPE (decl);
+ 
+   /* Precompute the info needed by the predicates ...  */
+ 
+   /* Whether the 'fastcall' convention applies.  */
+   bool fast_p
+     = lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fntype)) != 0;
+ 
+   /* How many integer registers used for argument passing.  */
+   int regparm = ix86_function_regparm (fntype, decl);
+ 
+   /* How many integer registers used for value returning.  */
+   tree restype
+     = DECL_RESULT (decl) ? TREE_TYPE (DECL_RESULT (decl)) : 0;
+ 
+   rtx resrtx
+     = (restype) ? ix86_function_value (restype, decl, true) : 0;
+ 
+   int regret
+     = ((resrtx && REGNO (resrtx) == 0)
+        ? hard_regno_nregs[REGNO (resrtx)][GET_MODE (resrtx)] : 0);
+ 
+   /* And check them all in turn. Ordering chosen from success likeliness
+      and expected cost considerations.  */
+ 
+   gcc_assert (!TARGET_64BIT);
+ 
+   if (!ix86_ecx_maybe_live_in_or_out (decl, fast_p, regparm, regret))
+     return 2;
+   else if (!ix86_edx_maybe_live_in_or_out (decl, fast_p, regparm, regret))
+     return 1;
+   else if (!ix86_eax_maybe_live_in_or_out (decl, fast_p, regparm, regret))
+     return 0;
+   else
+     return -1;
+ }
  /* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */
  
  static rtx
  ix86_internal_arg_pointer (void)
  {
!   /* If the current function needs to have its stack realigned, see if we can
!      find a scratch register to use as an alternate arg pointer.  */
!   int stack_realign = ix86_stack_realignment_for (current_function_decl);
! 
!   if (stack_realign != STK_REALIGN_NONEED)
!     {
!       int regno
!         = ix86_stack_realign_arg_pointer_regno_for (current_function_decl);
! 
!       /* If we have one, assign it.  */
!       if (regno >= 0)
!         {
!           cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, regno);
!           return copy_to_reg (cfun->machine->force_align_arg_pointer);
!         }
! 
!       /* Otherwise, emit warning or error, depending on how hard the
!          realignment request is.  */
!       else
!         {
!           if (stack_realign == STK_REALIGN_REQUESTED)
!             warning (0, "couldn't realign stack of %q+D",
!                      current_function_decl);
!           else if (stack_realign == STK_REALIGN_REQUIRED)
!             error ("couldn't force stack realignment of %q+D",
!                    current_function_decl);
!         }
      }
! 
!   /* If no stack realignment was required, or if we couldn't get a suitable
!      scratch register to honor it, return the regular virtual.  */
!   return virtual_incoming_args_rtx;
  }
  
  /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.
*************** ix86_expand_prologue (void)
*** 6400,6406 ****
  
        gcc_assert (!TARGET_64BIT || TARGET_64BIT_MS_ABI);
  
!       if (TARGET_64BIT_MS_ABI)
  	eax_live = false;
        else
  	eax_live = ix86_eax_live_at_start_p ();
--- 6552,6561 ----
  
        gcc_assert (!TARGET_64BIT || TARGET_64BIT_MS_ABI);
  
!       if (cfun->machine->force_align_arg_pointer
! 	  && REGNO (cfun->machine->force_align_arg_pointer) == 0)
! 	eax_live = true;
!       else if (TARGET_64BIT_MS_ABI)
  	eax_live = false;
        else
  	eax_live = ix86_eax_live_at_start_p ();
*** gcc/config/vx-common.h.orig	Tue Mar 25 07:32:12 2008
--- gcc/config/vx-common.h	Tue Mar 25 07:33:51 2008
***************
*** 92,94 ****
--- 92,102 ----
  /* We occasionally need to distinguish between the VxWorks variants.  */
  #define VXWORKS_KIND_NORMAL  1
  #define VXWORKS_KIND_AE      2
+ 
+ /* Default executable suffix is .out for VxWorks, ??? Should be .vxe for RTPs,
+    but this would depend on runtime values, hence would not be a valid static
+    initializer.  */
+ #undef TARGET_EXECUTABLE_SUFFIX
+ #define TARGET_EXECUTABLE_SUFFIX ".out"
+ 
+ 
*** gcc/common.opt.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/common.opt	2008-03-25 15:50:34.000000000 +0100
*************** fvariable-expansion-in-unroller
*** 960,969 ****
  Common Report Var(flag_variable_expansion_in_unroller) Optimization
  Apply variable expansion when loops are unrolled
  
! ; Emit code to probe the stack, to help detect stack overflow; also
! ; may cause large objects to be allocated dynamically.
  fstack-check
! Common Report Var(flag_stack_check)
  Insert stack checking code into the program
  
  fstack-limit
--- 960,971 ----
  Common Report Var(flag_variable_expansion_in_unroller) Optimization
  Apply variable expansion when loops are unrolled
  
! fold-stack-check
! Common Report
! Insert old-style stack checking code into the program
! 
  fstack-check
! Common Report
  Insert stack checking code into the program
  
  fstack-limit
*** gcc/doc/invoke.texi.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/doc/invoke.texi	2008-03-25 15:50:34.000000000 +0100
*************** See S/390 and zSeries Options.
*** 820,826 ****
  -frecord-gcc-switches @gol
  -freg-struct-return  -fshort-enums @gol
  -fshort-double  -fshort-wchar @gol
! -fverbose-asm  -fpack-struct[=@var{n}]  -fstack-check @gol
  -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fargument-noalias-anything @gol
--- 820,827 ----
  -frecord-gcc-switches @gol
  -freg-struct-return  -fshort-enums @gol
  -fshort-double  -fshort-wchar @gol
! -fverbose-asm  -fpack-struct[=@var{n}] @gol
! -fstack-check  -fold-stack-check @gol
  -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fargument-noalias-anything @gol
*************** a single-threaded environment since stac
*** 15157,15164 ****
  detected on nearly all systems if there is only one stack.
  
  Note that this switch does not actually cause checking to be done; the
! operating system must do that.  The switch causes generation of code
! to ensure that the operating system sees the stack being extended.
  
  @item -fstack-limit-register=@var{reg}
  @itemx -fstack-limit-symbol=@var{sym}
--- 15158,15190 ----
  detected on nearly all systems if there is only one stack.
  
  Note that this switch does not actually cause checking to be done; the
! operating system or the language runtime must do that.  The switch causes
! generation of code to ensure that they see the stack being extended.
! 
! @item -fold-stack-check
! @opindex fold-stack-check
! Same as above, but forces the use of old-style, pre-GCC4 stack checking.
! Old-style stack checking is a generic mechanism that requires no specific
! target support in the compiler but comes with the following drawbacks:
! 
! @enumerate
! @item
! Modified allocation strategy for large objects: they will always be
! allocated dynamically if their size exceeds a fixed threshold.
! 
! @item
! Fixed limit on the size of the static frame of functions: when it is
! topped by a particular function, stack checking is not reliable and
! a warning is issued by the compiler.
! 
! @item
! Inefficiency: because of both the modified allocation strategy and the
! generic implementation, the performances of the code are hampered.
! @end enumerate
! 
! Note that old-style stack checking is also the fallback method for
! @option{-fstack-check} if no specific target support has been added
! in the compiler.
  
  @item -fstack-limit-register=@var{reg}
  @itemx -fstack-limit-symbol=@var{sym}
*** gcc/expr.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/expr.h	2008-03-25 16:58:52.000000000 +0100
*************** do {								\
*** 208,220 ****
  
  /* Provide default values for the macros controlling stack checking.  */
  
  #ifndef STACK_CHECK_BUILTIN
  #define STACK_CHECK_BUILTIN 0
  #endif
  
! /* The default interval is one page.  */
! #ifndef STACK_CHECK_PROBE_INTERVAL
! #define STACK_CHECK_PROBE_INTERVAL 4096
  #endif
  
  /* The default is to do a store into the stack.  */
--- 208,231 ----
  
  /* Provide default values for the macros controlling stack checking.  */
  
+ /* The default is neither full builtin stack checking...  */
  #ifndef STACK_CHECK_BUILTIN
  #define STACK_CHECK_BUILTIN 0
  #endif
  
! /* ...nor static builtin stack checking.  */
! #ifndef STACK_CHECK_STATIC_BUILTIN
! #define STACK_CHECK_STATIC_BUILTIN 0
! #endif
! 
! /* The default interval is one page (4096 bytes).  */
! #ifndef STACK_CHECK_PROBE_INTERVAL_EXP
! #define STACK_CHECK_PROBE_INTERVAL_EXP 12
! #endif
! 
! /* The default is not to use an inclusive OR.  */
! #ifndef STACK_CHECK_PROBE_IOR
! #define STACK_CHECK_PROBE_IOR 0
  #endif
  
  /* The default is to do a store into the stack.  */
*************** do {								\
*** 222,237 ****
  #define STACK_CHECK_PROBE_LOAD 0
  #endif
  
! /* This value is arbitrary, but should be sufficient for most machines.  */
  #ifndef STACK_CHECK_PROTECT
! #define STACK_CHECK_PROTECT (75 * UNITS_PER_WORD)
  #endif
  
  /* Make the maximum frame size be the largest we can and still only need
     one probe per function.  */
  #ifndef STACK_CHECK_MAX_FRAME_SIZE
  #define STACK_CHECK_MAX_FRAME_SIZE \
!   (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)
  #endif
  
  /* This is arbitrary, but should be large enough everywhere.  */
--- 233,268 ----
  #define STACK_CHECK_PROBE_LOAD 0
  #endif
  
! /* The default is not to move the stack pointer.  */
! #ifndef STACK_CHECK_MOVING_SP
! #define STACK_CHECK_MOVING_SP 0
! #endif
! 
! /* This is a kludge to try to capture the discrepancy between the old
!    mechanism (generic stack checking) and the new mechanism (static
!    builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped
!    for the latter because part of the protection area is effectively
!    included in STACK_CHECK_MAX_FRAME_SIZE for the former.  */
! #ifdef STACK_CHECK_PROTECT
! #define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT
! #else
! #define STACK_OLD_CHECK_PROTECT \
!  (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 8 * 1024)
! #endif
! 
! /* Minimum amount of stack required to recover from an anticipated stack
!    overflow detection.  The default value conveys an estimate of the amount
!    of stack required to propagate an exception.  */
  #ifndef STACK_CHECK_PROTECT
! #define STACK_CHECK_PROTECT \
!  (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 12 * 1024)
  #endif
  
  /* Make the maximum frame size be the largest we can and still only need
     one probe per function.  */
  #ifndef STACK_CHECK_MAX_FRAME_SIZE
  #define STACK_CHECK_MAX_FRAME_SIZE \
!   ((1 << STACK_CHECK_PROBE_INTERVAL_EXP) - UNITS_PER_WORD)
  #endif
  
  /* This is arbitrary, but should be large enough everywhere.  */
*** gcc/system.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/system.h	2008-03-25 15:57:36.000000000 +0100
*************** extern void fancy_abort (const char *, i
*** 734,740 ****
  	TARGET_ASM_EXCEPTION_SECTION TARGET_ASM_EH_FRAME_SECTION	   \
  	SMALL_ARG_MAX ASM_OUTPUT_SHARED_BSS ASM_OUTPUT_SHARED_COMMON	   \
  	ASM_OUTPUT_SHARED_LOCAL UNALIGNED_WORD_ASM_OP			   \
! 	ASM_MAKE_LABEL_LINKONCE
  
  /* Hooks that are no longer used.  */
   #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE	\
--- 734,740 ----
  	TARGET_ASM_EXCEPTION_SECTION TARGET_ASM_EH_FRAME_SECTION	   \
  	SMALL_ARG_MAX ASM_OUTPUT_SHARED_BSS ASM_OUTPUT_SHARED_COMMON	   \
  	ASM_OUTPUT_SHARED_LOCAL UNALIGNED_WORD_ASM_OP			   \
! 	ASM_MAKE_LABEL_LINKONCE STACK_CHECK_PROBE_INTERVAL
  
  /* Hooks that are no longer used.  */
   #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE	\
*** gcc/doc/tm.texi.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/doc/tm.texi	2008-03-25 16:58:52.000000000 +0100
*************** linkage is necessary.  The default is @c
*** 3418,3476 ****
  @node Stack Checking
  @subsection Specifying How Stack Checking is Done
  
! GCC will check that stack references are within the boundaries of
! the stack, if the @option{-fstack-check} is specified, in one of three ways:
  
  @enumerate
  @item
  If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC
! will assume that you have arranged for stack checking to be done at
! appropriate places in the configuration files, e.g., in
! @code{TARGET_ASM_FUNCTION_PROLOGUE}.  GCC will do not other special
! processing.
  
  @item
! If @code{STACK_CHECK_BUILTIN} is zero and you defined a named pattern
! called @code{check_stack} in your @file{md} file, GCC will call that
! pattern with one argument which is the address to compare the stack
! value against.  You must arrange for this pattern to report an error if
! the stack pointer is out of range.
  
  @item
  If neither of the above are true, GCC will generate code to periodically
  ``probe'' the stack pointer using the values of the macros defined below.
  @end enumerate
  
! Normally, you will use the default values of these macros, so GCC
! will use the third approach.
  
  @defmac STACK_CHECK_BUILTIN
  A nonzero value if stack checking is done by the configuration files in a
  machine-dependent manner.  You should define this macro if stack checking
! is require by the ABI of your machine or if you would like to have to stack
! checking in some more efficient way than GCC's portable approach.
! The default value of this macro is zero.
  @end defmac
  
! @defmac STACK_CHECK_PROBE_INTERVAL
! An integer representing the interval at which GCC must generate stack
! probe instructions.  You will normally define this macro to be no larger
! than the size of the ``guard pages'' at the end of a stack area.  The
! default value of 4096 is suitable for most systems.
  @end defmac
  
  @defmac STACK_CHECK_PROBE_LOAD
! A integer which is nonzero if GCC should perform the stack probe
  as a load instruction and zero if GCC should use a store instruction.
  The default is zero, which is the most efficient choice on most systems.
  @end defmac
  
  @defmac STACK_CHECK_PROTECT
  The number of bytes of stack needed to recover from a stack overflow,
  for languages where such a recovery is supported.  The default value of
  75 words should be adequate for most machines.
  @end defmac
  
  @defmac STACK_CHECK_MAX_FRAME_SIZE
  The maximum size of a stack frame, in bytes.  GCC will generate probe
  instructions in non-leaf functions to ensure at least this many bytes of
--- 3418,3506 ----
  @node Stack Checking
  @subsection Specifying How Stack Checking is Done
  
! GCC will check that stack references are within the boundaries of the
! stack, if the option @option{-fstack-check} is specified, in one of
! three ways:
  
  @enumerate
  @item
  If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC
! will assume that you have arranged for full stack checking to be done
! at appropriate places in the configuration files.  GCC will not do
! other special processing.
  
  @item
! If @code{STACK_CHECK_BUILTIN} is zero and the value of the
! @code{STACK_CHECK_STATIC_BUILTIN} macro is nonzero, GCC will assume
! that you have arranged for static stack checking (checking of the
! static stack frame of functions) to be done at appropriate places
! in the configuration files.  GCC will only emit code to do dynamic
! stack checking (checking on dynamic stack allocations) using the third
! approach below.
  
  @item
  If neither of the above are true, GCC will generate code to periodically
  ``probe'' the stack pointer using the values of the macros defined below.
  @end enumerate
  
! If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,
! GCC will change its allocation strategy for large objects if the option
! @option{-fstack-check} is specified: they will always be allocated
! dynamically if their size exceeds @code{STACK_CHECK_MAX_VAR_SIZE} bytes.
  
  @defmac STACK_CHECK_BUILTIN
  A nonzero value if stack checking is done by the configuration files in a
  machine-dependent manner.  You should define this macro if stack checking
! is require by the ABI of your machine or if you would like to do stack
! checking in some more efficient way than the generic approach.  The default
! value of this macro is zero.
! @end defmac
! 
! @defmac STACK_CHECK_STATIC_BUILTIN
! A nonzero value if static stack checking is done by the configuration files
! in a machine-dependent manner.  You should define this macro if you would
! like to do static stack checking in some more efficient way than the generic
! approach.  The default value of this macro is zero.
! @end defmac
! 
! @defmac STACK_CHECK_PROBE_INTERVAL_EXP
! An integer specifying the interval at which GCC must generate stack probe
! instructions, defined as 2 raised to this integer.  You will normally
! define this macro so that the interval be no larger than the size of
! the ``guard pages'' at the end of a stack area.  The default value
! of 12 (4096-byte interval) is suitable for most systems.
  @end defmac
  
! @defmac STACK_CHECK_PROBE_IOR
! An integer which is nonzero if GCC should perform the stack probe
! as an inclusive OR instruction.  The default is zero.
  @end defmac
  
  @defmac STACK_CHECK_PROBE_LOAD
! An integer which is nonzero if GCC should perform the stack probe
  as a load instruction and zero if GCC should use a store instruction.
  The default is zero, which is the most efficient choice on most systems.
  @end defmac
  
+ @defmac STACK_CHECK_MOVING_SP
+ An integer which is nonzero if GCC should move the stack pointer during
+ stack checking.  This can be necessary on systems where the stack pointer
+ contains the bottom address of the memory area accessible to the executing
+ thread at any point in time.  In this situation an alternate signal stack
+ is required in order to be able to recover from a stack overflow.
+ The default value of this macro is zero.
+ @end defmac
+ 
  @defmac STACK_CHECK_PROTECT
  The number of bytes of stack needed to recover from a stack overflow,
  for languages where such a recovery is supported.  The default value of
  75 words should be adequate for most machines.
  @end defmac
  
+ The following macros are relevant only if neither STACK_CHECK_BUILTIN
+ nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
+ in the opposite case.
+ 
  @defmac STACK_CHECK_MAX_FRAME_SIZE
  The maximum size of a stack frame, in bytes.  GCC will generate probe
  instructions in non-leaf functions to ensure at least this many bytes of
*** gcc/opts.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/opts.c	2008-03-25 15:50:34.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 26,31 ****
--- 26,32 ----
  #include "tm.h"
  #include "tree.h"
  #include "rtl.h"
+ #include "expr.h"
  #include "ggc.h"
  #include "output.h"
  #include "langhooks.h"
*************** common_handle_option (size_t scode, cons
*** 1695,1700 ****
--- 1696,1721 ----
        flag_sched_stalled_insns_dep = value;
        break;
  
+     case OPT_fstack_check:
+       if (value)
+ 	flag_stack_check = STACK_CHECK_BUILTIN
+ 			   ? FULL_BUILTIN_STACK_CHECK
+ 			   : STACK_CHECK_STATIC_BUILTIN
+ 			     ? STATIC_BUILTIN_STACK_CHECK
+ 			     : GENERIC_STACK_CHECK;
+       else
+ 	flag_stack_check = NO_STACK_CHECK;
+       break;
+ 
+     case OPT_fold_stack_check:
+       if (value)
+ 	flag_stack_check = STACK_CHECK_BUILTIN
+ 			   ? FULL_BUILTIN_STACK_CHECK
+ 			   : GENERIC_STACK_CHECK;
+       else
+ 	flag_stack_check = NO_STACK_CHECK;
+       break;
+ 
      case OPT_fstack_limit:
        /* The real switch is -fno-stack-limit.  */
        if (value)
*** gcc/calls.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/calls.c	2008-03-25 15:50:34.000000000 +0100
*************** initialize_argument_information (int num
*** 1055,1064 ****
  	      rtx copy;
  
  	      if (!COMPLETE_TYPE_P (type)
! 		  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST
! 		  || (flag_stack_check && ! STACK_CHECK_BUILTIN
! 		      && (0 < compare_tree_int (TYPE_SIZE_UNIT (type),
! 						STACK_CHECK_MAX_VAR_SIZE))))
  		{
  		  /* This is a variable-sized object.  Make space on the stack
  		     for it.  */
--- 1055,1064 ----
  	      rtx copy;
  
  	      if (!COMPLETE_TYPE_P (type)
! 		  || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST
! 		  || (flag_stack_check == GENERIC_STACK_CHECK
! 		      && compare_tree_int (TYPE_SIZE_UNIT (type),
! 					   STACK_CHECK_MAX_VAR_SIZE) > 0))
  		{
  		  /* This is a variable-sized object.  Make space on the stack
  		     for it.  */
*************** emit_library_call_value_1 (int retval, r
*** 3360,3365 ****
--- 3360,3368 ----
      case LCT_THROW:
        flags = ECF_NORETURN;
        break;
+     case LCT_MAY_THROW:
+       flags &= ~ECF_NOTHROW;
+       break;
      case LCT_RETURNS_TWICE:
        flags = ECF_RETURNS_TWICE;
        break;
*** gcc/explow.c.0	2008-12-14 17:18:12.000000000 +0100
--- gcc/explow.c	2008-12-14 17:18:19.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 29,34 ****
--- 29,35 ----
  #include "tree.h"
  #include "tm_p.h"
  #include "flags.h"
+ #include "except.h"
  #include "function.h"
  #include "expr.h"
  #include "optabs.h"
*************** along with GCC; see the file COPYING3.  
*** 42,47 ****
--- 43,49 ----
  
  static rtx break_out_memory_refs (rtx);
  static void emit_stack_probe (rtx);
+ static void anti_adjust_stack_and_probe (rtx);
  
  
  /* Truncate and perhaps sign-extend C as appropriate for MODE.  */
*************** allocate_dynamic_stack_space (rtx size, 
*** 1190,1199 ****
    gcc_assert (!(stack_pointer_delta
  		% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));
  
!   /* If needed, check that we have the required amount of stack.  Take into
!      account what has already been checked.  */
!   if (flag_stack_check && ! STACK_CHECK_BUILTIN)
!     probe_stack_range (STACK_CHECK_MAX_FRAME_SIZE + STACK_CHECK_PROTECT, size);
  
    /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */
    if (target == 0 || !REG_P (target)
--- 1192,1206 ----
    gcc_assert (!(stack_pointer_delta
  		% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));
  
!   /* If needed, check that we have the required amount of stack.
!      Take into account what has already been checked.  */
!   if (STACK_CHECK_MOVING_SP)
!     ;
!   else if (flag_stack_check == GENERIC_STACK_CHECK)
!     probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,
! 		       size);
!   else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
!     probe_stack_range (STACK_CHECK_PROTECT, size);
  
    /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */
    if (target == 0 || !REG_P (target)
*************** allocate_dynamic_stack_space (rtx size, 
*** 1258,1264 ****
  	  emit_label (space_available);
  	}
  
!       anti_adjust_stack (size);
  
  #ifdef STACK_GROWS_DOWNWARD
        emit_move_insn (target, virtual_stack_dynamic_rtx);
--- 1265,1274 ----
  	  emit_label (space_available);
  	}
  
!       if (flag_stack_check && STACK_CHECK_MOVING_SP)
! 	anti_adjust_stack_and_probe (size);
!       else
! 	anti_adjust_stack (size);
  
  #ifdef STACK_GROWS_DOWNWARD
        emit_move_insn (target, virtual_stack_dynamic_rtx);
*************** allocate_dynamic_stack_space (rtx size, 
*** 1292,1309 ****
    return target;
  }
  
! /* A front end may want to override GCC's stack checking by providing a
!    run-time routine to call to check the stack, so provide a mechanism for
!    calling that routine.  */
! 
! static GTY(()) rtx stack_check_libfunc;
  
- void
- set_stack_check_libfunc (rtx libfunc)
- {
-   stack_check_libfunc = libfunc;
- }
- 
  /* Emit one stack probe at ADDRESS, an address within the stack.  */
  
  static void
--- 1302,1319 ----
    return target;
  }
  
! /* A front end may want to override GCC's stack checking by providing
!    either a symbol (data) or a function (code).  In either case, the
!    runtime also needs to provide the associated support.  */
! 
! /* Variable whose value is checked against the future value of the stack
!    pointer.  Upon stack overflow, the generated code will raise a trap.  */
! rtx stack_check_symbol;
! 
! /* Function that is passed the future value of the stack pointer.  Upon
!    stack overflow, it is responsible for raising the appropriate event.  */
! rtx stack_check_libfunc;
  
  /* Emit one stack probe at ADDRESS, an address within the stack.  */
  
  static void
*************** emit_stack_probe (rtx address)
*** 1313,1319 ****
  
    MEM_VOLATILE_P (memref) = 1;
  
!   if (STACK_CHECK_PROBE_LOAD)
      emit_move_insn (gen_reg_rtx (word_mode), memref);
    else
      emit_move_insn (memref, const0_rtx);
--- 1323,1338 ----
  
    MEM_VOLATILE_P (memref) = 1;
  
!   if (STACK_CHECK_PROBE_IOR)
!     {
!       if (word_mode == SImode)
! 	emit_insn (gen_iorsi3 (memref, const0_rtx, memref));
!       else if (word_mode == DImode)
! 	emit_insn (gen_iordi3 (memref, const0_rtx, memref));
!       else
! 	gcc_unreachable ();
!     }
!   else if (STACK_CHECK_PROBE_LOAD)
      emit_move_insn (gen_reg_rtx (word_mode), memref);
    else
      emit_move_insn (memref, const0_rtx);
*************** emit_stack_probe (rtx address)
*** 1325,1346 ****
     subtract from the stack.  If SIZE is constant, this is done
     with a fixed number of probes.  Otherwise, we must make a loop.  */
  
  #ifdef STACK_GROWS_DOWNWARD
! #define STACK_GROW_OP MINUS
  #else
! #define STACK_GROW_OP PLUS
  #endif
  
  void
  probe_stack_range (HOST_WIDE_INT first, rtx size)
  {
    /* First ensure SIZE is Pmode.  */
    if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
      size = convert_to_mode (Pmode, size, 1);
  
!   /* Next see if the front end has set up a function for us to call to
!      check the stack.  */
!   if (stack_check_libfunc != 0)
      {
        rtx addr = memory_address (QImode,
  				 gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
--- 1344,1378 ----
     subtract from the stack.  If SIZE is constant, this is done
     with a fixed number of probes.  Otherwise, we must make a loop.  */
  
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
  #ifdef STACK_GROWS_DOWNWARD
! #define STACK_GROW_OP     MINUS
! #define STACK_GROW_OPTAB  sub_optab
! #define STACK_HIGH(high,low)  low
! #define STACK_LOW(high,low)   high
  #else
! #define STACK_GROW_OP     PLUS
! #define STACK_GROW_OPTAB  add_optab
! #define STACK_HIGH(high,low)  high
! #define STACK_LOW(high,low)   low
  #endif
  
  void
  probe_stack_range (HOST_WIDE_INT first, rtx size)
  {
+ #ifdef SPARC_STACK_BIAS
+   /* The probe offsets are counted negatively whereas the stack bias is
+      counted positively.  */
+   first -= SPARC_STACK_BIAS;
+ #endif
+ 
    /* First ensure SIZE is Pmode.  */
    if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
      size = convert_to_mode (Pmode, size, 1);
  
!   /* Next see if the runtime has got a function for us to call.  */
!   if (stack_check_libfunc)
      {
        rtx addr = memory_address (QImode,
  				 gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1348,1450 ****
  					         plus_constant (size, first)));
  
        addr = convert_memory_address (ptr_mode, addr);
!       emit_library_call (stack_check_libfunc, LCT_NORMAL, VOIDmode, 1, addr,
  			 ptr_mode);
      }
  
!   /* Next see if we have an insn to check the stack.  Use it if so.  */
! #ifdef HAVE_check_stack
!   else if (HAVE_check_stack)
      {
!       insn_operand_predicate_fn pred;
!       rtx last_addr
! 	= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 stack_pointer_rtx,
! 					 plus_constant (size, first)),
! 			 NULL_RTX);
! 
!       pred = insn_data[(int) CODE_FOR_check_stack].operand[0].predicate;
!       if (pred && ! ((*pred) (last_addr, Pmode)))
! 	last_addr = copy_to_mode_reg (Pmode, last_addr);
! 
!       emit_insn (gen_check_stack (last_addr));
!     }
  #endif
  
!   /* If we have to generate explicit probes, see if we have a constant
!      small number of them to generate.  If so, that's the easy case.  */
!   else if (GET_CODE (size) == CONST_INT
! 	   && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)
      {
!       HOST_WIDE_INT offset;
  
!       /* Start probing at FIRST + N * STACK_CHECK_PROBE_INTERVAL
! 	 for values of N from 1 until it exceeds LAST.  If only one
! 	 probe is needed, this will not generate any code.  Then probe
! 	 at LAST.  */
!       for (offset = first + STACK_CHECK_PROBE_INTERVAL;
! 	   offset < INTVAL (size);
! 	   offset = offset + STACK_CHECK_PROBE_INTERVAL)
! 	emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					  stack_pointer_rtx,
! 					  GEN_INT (offset)));
  
!       emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					stack_pointer_rtx,
! 					plus_constant (size, first)));
      }
  
!   /* In the variable case, do the same as above, but in a loop.  We emit loop
!      notes so that loop optimization can be done.  */
    else
      {
!       rtx test_addr
! 	= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 stack_pointer_rtx,
! 					 GEN_INT (first + STACK_CHECK_PROBE_INTERVAL)),
! 			 NULL_RTX);
!       rtx last_addr
! 	= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 stack_pointer_rtx,
! 					 plus_constant (size, first)),
! 			 NULL_RTX);
!       rtx incr = GEN_INT (STACK_CHECK_PROBE_INTERVAL);
        rtx loop_lab = gen_label_rtx ();
-       rtx test_lab = gen_label_rtx ();
        rtx end_lab = gen_label_rtx ();
-       rtx temp;
  
!       if (!REG_P (test_addr)
! 	  || REGNO (test_addr) < FIRST_PSEUDO_REGISTER)
! 	test_addr = force_reg (Pmode, test_addr);
  
!       emit_jump (test_lab);
  
        emit_label (loop_lab);
        emit_stack_probe (test_addr);
  
  #ifdef STACK_GROWS_DOWNWARD
! #define CMP_OPCODE GTU
!       temp = expand_binop (Pmode, sub_optab, test_addr, incr, test_addr,
! 			   1, OPTAB_WIDEN);
! #else
! #define CMP_OPCODE LTU
!       temp = expand_binop (Pmode, add_optab, test_addr, incr, test_addr,
! 			   1, OPTAB_WIDEN);
  #endif
  
!       gcc_assert (temp == test_addr);
  
-       emit_label (test_lab);
-       emit_cmp_and_jump_insns (test_addr, last_addr, CMP_OPCODE,
- 			       NULL_RTX, Pmode, 1, loop_lab);
-       emit_jump (end_lab);
        emit_label (end_lab);
  
!       emit_stack_probe (last_addr);
      }
  }
! 
  /* Return an rtx representing the register or memory location
     in which a scalar value of data type VALTYPE
     was returned by a function call to function FUNC.
--- 1380,1659 ----
  					         plus_constant (size, first)));
  
        addr = convert_memory_address (ptr_mode, addr);
!       emit_library_call (stack_check_libfunc, LCT_MAY_THROW, VOIDmode, 1, addr,
  			 ptr_mode);
      }
  
!   /* Next see if the runtime has got a symbol for us to compare against.  */
!   else if (stack_check_symbol)
      {
!       rtx stack_check_limit = gen_rtx_MEM (Pmode, stack_check_symbol);
!       rtx avail
! 	= expand_binop (Pmode, sub_optab,
! 			STACK_HIGH (stack_check_limit, stack_pointer_rtx),
! 			STACK_LOW (stack_check_limit, stack_pointer_rtx),
! 			NULL_RTX, 1, OPTAB_WIDEN);
!       rtx req = plus_constant (size, first);
! 
! #if defined(HAVE_conditional_trap)
!       emit_insn (gen_cond_trap (LTU, avail, req, const0_rtx));
! #elif defined(HAVE_trap)
!       rtx ok_lab = gen_label_rtx ();
!       emit_cmp_and_jump_insns (avail, req, GEU, NULL_RTX, Pmode, 1, ok_lab);
!       emit_insn (gen_trap ());
!       emit_barrier ();
!       emit_label (ok_lab);
! #else
!       error ("stack checking not supported on this target");
  #endif
+     }
  
!   /* Otherwise we have to generate explicit probes.  If we have a constant
!      small number of them to generate, that's the easy case.  */
!   else if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
      {
!       HOST_WIDE_INT i, offset, size_int = INTVAL (size);
!       rtx addr;
  
!       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
! 	 it exceeds SIZE.  If only one probe is needed, this will not
! 	 generate any code.  Then probe at FIRST + SIZE.  */
!       for (i = PROBE_INTERVAL; i < size_int; i += PROBE_INTERVAL)
! 	{
! 	  offset = first + i;
! #ifdef STACK_GROWS_DOWNWARD
! 	  offset = -offset;
! #endif
! 	  addr = memory_address (Pmode,
! 				 plus_constant (stack_pointer_rtx, offset));
! 	  emit_stack_probe (addr);
! 	}
  
!       offset = first + size_int;
! #ifdef STACK_GROWS_DOWNWARD
!       offset = -offset;
! #endif
!       addr = memory_address (Pmode, plus_constant (stack_pointer_rtx, offset));
!       emit_stack_probe (addr);
      }
  
!   /* In the variable case, do the same as above, but in a loop.  Note that we
!      must be extra careful with variables wrapping around because we might be
!      at the very top (or the very bottom) of the address space and we have to
!      be able to handle this case properly; in particular, we use an equality
!      test for the loop condition.  */
    else
      {
!       rtx rounded_size, rounded_size_op, test_addr, last_addr, temp;
        rtx loop_lab = gen_label_rtx ();
        rtx end_lab = gen_label_rtx ();
  
!       /* Step 1: round SIZE to the previous multiple of the interval.  */
! 
!       /* ROUNDED_SIZE = SIZE & -PROBE_INTERVAL  */
!       rounded_size = simplify_gen_binary (AND, Pmode,
! 					  size,
! 					  GEN_INT (-PROBE_INTERVAL));
!       rounded_size_op = force_operand (rounded_size, NULL_RTX);
! 
! 
!       /* Step 2: compute initial and final value of the loop counter.  */
! 
!       /* TEST_ADDR = SP + FIRST.  */
!       test_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 	 stack_pointer_rtx,
! 					 	 GEN_INT (first)),
! 				 NULL_RTX);
! 
!       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
!       last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 						 test_addr,
! 						 rounded_size_op),
! 				 NULL_RTX);
! 
  
!       /* Step 3: the loop
! 
! 	 while (TEST_ADDR != LAST_ADDR)
! 	   {
! 	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
! 	     probe at TEST_ADDR
! 	   }
! 
! 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
! 	 until it is equal to ROUNDED_SIZE.  */
  
        emit_label (loop_lab);
+ 
+       /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       emit_cmp_and_jump_insns (test_addr, last_addr, EQ,
+ 			       NULL_RTX, Pmode, 1, end_lab);
+ 
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       temp = expand_binop (Pmode, STACK_GROW_OPTAB, test_addr,
+ 			   GEN_INT (PROBE_INTERVAL), test_addr,
+ 			   1, OPTAB_WIDEN);
+ 
+       gcc_assert (temp == test_addr);
+ 
+       /* Probe at TEST_ADDR.  */
        emit_stack_probe (test_addr);
  
+       emit_jump (loop_lab);
+ 
+       emit_label (end_lab);
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);
+       if (temp != const0_rtx)
+ 	{
+ 	  rtx addr;
+ 
+ 	  if (GET_CODE (temp) == CONST_INT)
+ 	    {
+ 	      /* Use [base + disp} addressing mode if supported.  */
+ 	      HOST_WIDE_INT offset = INTVAL (temp);
  #ifdef STACK_GROWS_DOWNWARD
! 	      offset = -offset;
  #endif
+ 	      addr = memory_address (Pmode, plus_constant (last_addr, offset));
+ 	    }
+ 	  else
+ 	    {
+ 	      /* Manual CSE if the difference is not known at compile-time.  */
+ 	      temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);
+ 	      addr = memory_address (Pmode,
+ 				     gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
+ 						     last_addr, temp));
+ 	    }
  
! 	  emit_stack_probe (addr);
! 	}
!     }
! }
! 
! /* Adjust the stack by SIZE bytes while probing it.  Note that we skip the
!    probe for the first interval + a small dope of 4 words and instead probe
!    that many bytes past the specified size to maintain a protection area.  */
! 
! static void
! anti_adjust_stack_and_probe (rtx size)
! {
!   const int dope = 4 * UNITS_PER_WORD;
! 
!   /* First ensure SIZE is Pmode.  */
!   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
!     size = convert_to_mode (Pmode, size, 1);
! 
!   /* If we have a constant small number of probes to generate, that's the
!      easy case.  */
!   if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
!     {
!       HOST_WIDE_INT i, int_size = INTVAL (size);
!       bool first_probe = true;
! 
!       /* Adjust SP and probe to PROBE_INTERVAL + N * PROBE_INTERVAL for
! 	 values of N from 1 until it exceeds SIZE.  If only one probe is
! 	 needed, this will not generate any code.  Then adjust and probe
! 	 to PROBE_INTERVAL + SIZE.  */
!       for (i = PROBE_INTERVAL; i < int_size; i += PROBE_INTERVAL)
! 	{
! 	  if (first_probe)
! 	    {
! 	      anti_adjust_stack (GEN_INT (2 * PROBE_INTERVAL + dope));
! 	      first_probe = false;
! 	    }
! 	  else
! 	    anti_adjust_stack (GEN_INT (PROBE_INTERVAL));
! 	  emit_stack_probe (stack_pointer_rtx);
! 	}
! 
!       if (first_probe)
! 	anti_adjust_stack (plus_constant (size, PROBE_INTERVAL + dope));
!       else
! 	anti_adjust_stack (plus_constant (size, PROBE_INTERVAL - i));
!       emit_stack_probe (stack_pointer_rtx);
!     }
! 
!   /* In the variable case, do the same as above, but in a loop.  Note that we
!      must be extra careful with variables wrapping around because we might be
!      at the very top (or the very bottom) of the address space and we have to
!      be able to handle this case properly; in particular, we use an equality
!      test for the loop condition.  */
!   else
!     {
!       rtx rounded_size, rounded_size_op, last_addr, temp;
!       rtx loop_lab = gen_label_rtx ();
!       rtx end_lab = gen_label_rtx ();
! 
!       /* Step 1: round SIZE to the previous multiple of the interval.  */
! 
!       /* ROUNDED_SIZE = SIZE & -PROBE_INTERVAL  */
!       rounded_size = simplify_gen_binary (AND, Pmode,
! 					  size,
! 					  GEN_INT (-PROBE_INTERVAL));
!       rounded_size_op = force_operand (rounded_size, NULL_RTX);
! 
! 
!       /* Step 2: compute initial and final value of the loop counter.  */
! 
!       /* SP = SP_0 + PROBE_INTERVAL.  */
!       anti_adjust_stack (GEN_INT (PROBE_INTERVAL + dope));
! 
!       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */
!       last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 						 stack_pointer_rtx,
! 						 rounded_size_op),
! 				 NULL_RTX);
! 
! 
!       /* Step 3: the loop
! 
! 	  while (SP != LAST_ADDR)
! 	    {
! 	      SP = SP + PROBE_INTERVAL
! 	      probe at SP
! 	    }
! 
! 	 adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for
! 	 values of N from 1 until it is equal to ROUNDED_SIZE.  */
! 
!       emit_label (loop_lab);
! 
!       /* Jump to END_LAB if SP == LAST_ADDR.  */
!       emit_cmp_and_jump_insns (stack_pointer_rtx, last_addr, EQ,
! 			       NULL_RTX, Pmode, 1, end_lab);
! 
!       /* SP = SP + PROBE_INTERVAL and probe at SP.  */
!       anti_adjust_stack (GEN_INT (PROBE_INTERVAL));
!       emit_stack_probe (stack_pointer_rtx);
! 
!       emit_jump (loop_lab);
  
        emit_label (end_lab);
  
!       /* Step 4: adjust SP and probe to PROBE_INTERVAL + SIZE if we cannot
! 	 assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */
! 
!       /* TEMP = SIZE - ROUNDED_SIZE.  */
!       temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);
!       if (temp != const0_rtx)
! 	{
! 	  /* Manual CSE if the difference is not known at compile-time.  */
! 	  if (GET_CODE (temp) != CONST_INT)
! 	    temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);
! 	  anti_adjust_stack (temp);
! 	  emit_stack_probe (stack_pointer_rtx);
! 	}
      }
+ 
+   /* Adjust back to account for the additional first interval.  */
+   adjust_stack (GEN_INT (PROBE_INTERVAL + dope));
  }
! 
  /* Return an rtx representing the register or memory location
     in which a scalar value of data type VALTYPE
     was returned by a function call to function FUNC.
*************** rtx_to_tree_code (enum rtx_code code)
*** 1534,1538 ****
      }
    return ((int) tcode);
  }
- 
- #include "gt-explow.h"
--- 1743,1745 ----
*** gcc/function.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/function.c	2008-03-25 15:50:34.000000000 +0100
*************** gimplify_parameters (void)
*** 3232,3238 ****
        walk_tree_without_duplicates (&data.passed_type,
  				    gimplify_parm_type, &stmts);
  
!       if (!TREE_CONSTANT (DECL_SIZE (parm)))
  	{
  	  gimplify_one_sizepos (&DECL_SIZE (parm), &stmts);
  	  gimplify_one_sizepos (&DECL_SIZE_UNIT (parm), &stmts);
--- 3232,3238 ----
        walk_tree_without_duplicates (&data.passed_type,
  				    gimplify_parm_type, &stmts);
  
!       if (TREE_CODE (DECL_SIZE_UNIT (parm)) != INTEGER_CST)
  	{
  	  gimplify_one_sizepos (&DECL_SIZE (parm), &stmts);
  	  gimplify_one_sizepos (&DECL_SIZE_UNIT (parm), &stmts);
*************** gimplify_parameters (void)
*** 3246,3254 ****
  	    {
  	      tree local, t;
  
! 	      /* For constant sized objects, this is trivial; for
  		 variable-sized objects, we have to play games.  */
! 	      if (TREE_CONSTANT (DECL_SIZE (parm)))
  		{
  		  local = create_tmp_var (type, get_name (parm));
  		  DECL_IGNORED_P (local) = 0;
--- 3246,3257 ----
  	    {
  	      tree local, t;
  
! 	      /* For constant-sized objects, this is trivial; for
  		 variable-sized objects, we have to play games.  */
! 	      if (TREE_CODE (DECL_SIZE_UNIT (parm)) == INTEGER_CST
! 		  && !(flag_stack_check == GENERIC_STACK_CHECK
! 		       && compare_tree_int (DECL_SIZE_UNIT (parm),
! 					    STACK_CHECK_MAX_VAR_SIZE) > 0))
  		{
  		  local = create_tmp_var (type, get_name (parm));
  		  DECL_IGNORED_P (local) = 0;
*************** expand_function_end (void)
*** 4443,4452 ****
    if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)
      get_arg_pointer_save_area (cfun);
  
!   /* If we are doing stack checking and this function makes calls,
       do a stack probe at the start of the function to ensure we have enough
       space for another stack frame.  */
!   if (flag_stack_check && ! STACK_CHECK_BUILTIN)
      {
        rtx insn, seq;
  
--- 4443,4452 ----
    if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)
      get_arg_pointer_save_area (cfun);
  
!   /* If we are doing generic stack checking and this function makes calls,
       do a stack probe at the start of the function to ensure we have enough
       space for another stack frame.  */
!   if (flag_stack_check == GENERIC_STACK_CHECK)
      {
        rtx insn, seq;
  
*************** expand_function_end (void)
*** 4454,4460 ****
  	if (CALL_P (insn))
  	  {
  	    start_sequence ();
! 	    probe_stack_range (STACK_CHECK_PROTECT,
  			       GEN_INT (STACK_CHECK_MAX_FRAME_SIZE));
  	    seq = get_insns ();
  	    end_sequence ();
--- 4457,4463 ----
  	if (CALL_P (insn))
  	  {
  	    start_sequence ();
! 	    probe_stack_range (STACK_OLD_CHECK_PROTECT,
  			       GEN_INT (STACK_CHECK_MAX_FRAME_SIZE));
  	    seq = get_insns ();
  	    end_sequence ();
*** gcc/gimplify.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/gimplify.c	2008-03-25 16:04:16.000000000 +0100
*************** gimplify_decl_expr (tree *stmt_p)
*** 1279,1285 ****
      {
        tree init = DECL_INITIAL (decl);
  
!       if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)
  	gimplify_vla_decl (decl, stmt_p);
  
        if (init && init != error_mark_node)
--- 1279,1289 ----
      {
        tree init = DECL_INITIAL (decl);
  
!       if (TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST
! 	  || (!TREE_STATIC (decl)
! 	      && flag_stack_check == GENERIC_STACK_CHECK
! 	      && compare_tree_int (DECL_SIZE_UNIT (decl),
! 				   STACK_CHECK_MAX_VAR_SIZE) > 0))
  	gimplify_vla_decl (decl, stmt_p);
  
        if (init && init != error_mark_node)
*** gcc/reload1.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/reload1.c	2008-03-25 16:58:52.000000000 +0100
*************** reload (rtx first, int global)
*** 1305,1313 ****
  	  }
        }
  
!   /* If we are doing stack checking, give a warning if this function's
!      frame size is larger than we expect.  */
!   if (flag_stack_check && ! STACK_CHECK_BUILTIN)
      {
        HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;
        static int verbose_warned = 0;
--- 1305,1313 ----
  	  }
        }
  
!   /* If we are doing generic stack checking, give a warning if this
!      function's frame size is larger than we expect.  */
!   if (flag_stack_check == GENERIC_STACK_CHECK)
      {
        HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;
        static int verbose_warned = 0;
*************** init_elim_table (void)
*** 3724,3729 ****
--- 3724,3732 ----
  			     sp-adjusting insns for this case.  */
  			  || (current_function_calls_alloca
  			      && EXIT_IGNORE_STACK)
+ 			  /* We need the frame pointer to catch stack overflow
+ 			     exceptions if sp is moved by stack cheking.  */
+ 			  || (flag_stack_check && STACK_CHECK_MOVING_SP)
  			  || current_function_accesses_prior_frames
  			  || FRAME_POINTER_REQUIRED);
  
*** gcc/rtlanal.c.0	2008-03-25 16:58:40.000000000 +0100
--- gcc/rtlanal.c	2008-03-25 17:00:48.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 36,41 ****
--- 36,42 ----
  #include "real.h"
  #include "regs.h"
  #include "function.h"
+ #include "expr.h"
  #include "df.h"
  #include "tree.h"
  
*************** may_trap_p_1 (const_rtx x, unsigned flag
*** 2222,2227 ****
--- 2223,2233 ----
  
        /* Memory ref can trap unless it's a static var or a stack slot.  */
      case MEM:
+       /* Recognize specific pattern of stack checking probes.  */
+       if (STACK_CHECK_MOVING_SP
+ 	  && MEM_VOLATILE_P (x)
+ 	  && XEXP (x, 0) == stack_pointer_rtx)
+ 	return 1;
        if (/* MEM_NOTRAP_P only relates to the actual position of the memory
  	     reference; moving it out of condition might cause its address
  	     become invalid.  */
*** gcc/stmt.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/stmt.c	2008-03-25 15:59:38.000000000 +0100
*************** expand_decl (tree decl)
*** 1874,1881 ****
      SET_DECL_RTL (decl, gen_rtx_MEM (BLKmode, const0_rtx));
  
    else if (DECL_SIZE (decl) == 0)
-     /* Variable with incomplete type.  */
      {
        rtx x;
        if (DECL_INITIAL (decl) == 0)
  	/* Error message was already done; now avoid a crash.  */
--- 1874,1881 ----
      SET_DECL_RTL (decl, gen_rtx_MEM (BLKmode, const0_rtx));
  
    else if (DECL_SIZE (decl) == 0)
      {
+       /* Variable with incomplete type.  */
        rtx x;
        if (DECL_INITIAL (decl) == 0)
  	/* Error message was already done; now avoid a crash.  */
*************** expand_decl (tree decl)
*** 1906,1921 ****
  			  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));
      }
  
!   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST
! 	   && ! (flag_stack_check && ! STACK_CHECK_BUILTIN
! 		 && 0 < compare_tree_int (DECL_SIZE_UNIT (decl),
! 					  STACK_CHECK_MAX_VAR_SIZE)))
      {
-       /* Variable of fixed size that goes on the stack.  */
        rtx oldaddr = 0;
        rtx addr;
        rtx x;
  
        /* If we previously made RTL for this decl, it must be an array
  	 whose size was determined by the initializer.
  	 The old address was a register; set that register now
--- 1906,1920 ----
  			  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));
      }
  
!   else
      {
        rtx oldaddr = 0;
        rtx addr;
        rtx x;
  
+       /* Variable-sized decls should have been handled in the gimplifier.  */
+       gcc_assert (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST);
+ 
        /* If we previously made RTL for this decl, it must be an array
  	 whose size was determined by the initializer.
  	 The old address was a register; set that register now
*************** expand_decl (tree decl)
*** 1943,1983 ****
  	    emit_move_insn (oldaddr, addr);
  	}
      }
-   else
-     /* Dynamic-size object: must push space on the stack.  */
-     {
-       rtx address, size, x;
- 
-       /* Record the stack pointer on entry to block, if have
- 	 not already done so.  */
-       do_pending_stack_adjust ();
- 
-       /* Compute the variable's size, in bytes.  This will expand any
- 	 needed SAVE_EXPRs for the first time.  */
-       size = expand_normal (DECL_SIZE_UNIT (decl));
-       free_temp_slots ();
- 
-       /* Allocate space on the stack for the variable.  Note that
- 	 DECL_ALIGN says how the variable is to be aligned and we
- 	 cannot use it to conclude anything about the alignment of
- 	 the size.  */
-       address = allocate_dynamic_stack_space (size, NULL_RTX,
- 					      TYPE_ALIGN (TREE_TYPE (decl)));
- 
-       /* Reference the variable indirect through that rtx.  */
-       x = gen_rtx_MEM (DECL_MODE (decl), address);
-       set_mem_attributes (x, decl, 1);
-       SET_DECL_RTL (decl, x);
- 
- 
-       /* Indicate the alignment we actually gave this variable.  */
- #ifdef STACK_BOUNDARY
-       DECL_ALIGN (decl) = STACK_BOUNDARY;
- #else
-       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;
- #endif
-       DECL_USER_ALIGN (decl) = 0;
-     }
  }
  
  /* Emit code to save the current value of stack.  */
--- 1942,1947 ----
*** gcc/rtl.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/rtl.h	2008-03-25 16:52:21.000000000 +0100
*************** extern int currently_expanding_to_rtl;
*** 1469,1475 ****
  extern int ceil_log2 (unsigned HOST_WIDE_INT);
  
  /* In explow.c */
! extern void set_stack_check_libfunc (rtx);
  extern HOST_WIDE_INT trunc_int_for_mode	(HOST_WIDE_INT, enum machine_mode);
  extern rtx plus_constant (rtx, HOST_WIDE_INT);
  
--- 1469,1476 ----
  extern int ceil_log2 (unsigned HOST_WIDE_INT);
  
  /* In explow.c */
! extern GTY(()) rtx stack_check_symbol;
! extern GTY(()) rtx stack_check_libfunc;
  extern HOST_WIDE_INT trunc_int_for_mode	(HOST_WIDE_INT, enum machine_mode);
  extern rtx plus_constant (rtx, HOST_WIDE_INT);
  
*************** enum libcall_type
*** 2222,2228 ****
    LCT_PURE_MAKE_BLOCK = 4,
    LCT_NORETURN = 5,
    LCT_THROW = 6,
!   LCT_RETURNS_TWICE = 7
  };
  
  extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,
--- 2223,2230 ----
    LCT_PURE_MAKE_BLOCK = 4,
    LCT_NORETURN = 5,
    LCT_THROW = 6,
!   LCT_MAY_THROW = 7,
!   LCT_RETURNS_TWICE = 8
  };
  
  extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,
*** gcc/flags.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/flags.h	2008-03-25 16:15:40.000000000 +0100
*************** extern int flag_var_tracking;
*** 265,270 ****
--- 265,291 ----
     warning message in case flag was set by -fprofile-{generate,use}.  */
  extern bool flag_speculative_prefetching_set;
  
+ /* Type of stack check.  */
+ enum stack_check_type
+ {
+   /* Do not check the stack.  */
+   NO_STACK_CHECK = 0,
+ 
+   /* Check the stack generically, i.e. assume no specific support
+      from the target configuration files.  */
+   GENERIC_STACK_CHECK,
+ 
+   /* Check the stack and rely on the target configuration files to
+      check the static frame of functions, i.e. use the generic
+      mechanism only for dynamic stack allocations.  */
+   STATIC_BUILTIN_STACK_CHECK,
+ 
+   /* Check the stack and entirely rely on the target configuration
+      files, i.e. do not use the generic mechanism at all.  */
+   FULL_BUILTIN_STACK_CHECK
+ };
+ extern enum stack_check_type flag_stack_check;
+ 
  /* Returns TRUE if generated code should match ABI version N or
     greater is in use.  */
  
*** gcc/toplev.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/toplev.c	2008-03-25 15:53:27.000000000 +0100
*************** rtx stack_limit_rtx;
*** 329,334 ****
--- 329,337 ----
     to optimize, debug_info_level and debug_hooks in process_options ().  */
  int flag_var_tracking = AUTODETECT_VALUE;
  
+ /* Type of stack check.  */
+ enum stack_check_type flag_stack_check = NO_STACK_CHECK;
+ 
  /* True if the user has tagged the function with the 'section'
     attribute.  */
  
*** gcc/tree.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/tree.c	2008-03-25 15:53:27.000000000 +0100
*************** build_common_builtin_nodes (void)
*** 7527,7533 ****
        tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);
        ftype = build_function_type (ptr_type_node, tmp);
        local_define_builtin ("__builtin_alloca", ftype, BUILT_IN_ALLOCA,
! 			    "alloca", ECF_NOTHROW | ECF_MALLOC);
      }
  
    tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
--- 7527,7534 ----
        tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);
        ftype = build_function_type (ptr_type_node, tmp);
        local_define_builtin ("__builtin_alloca", ftype, BUILT_IN_ALLOCA,
! 			    "alloca",
! 			    ECF_MALLOC | (flag_stack_check ? 0 : ECF_NOTHROW));
      }
  
    tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
*** gcc/Makefile.in.0	2008-03-25 16:13:18.000000000 +0100
--- gcc/Makefile.in	2008-03-25 17:01:51.000000000 +0100
*************** print-rtl.o : print-rtl.c $(CONFIG_H) $(
*** 2385,2392 ****
      $(BCONFIG_H) $(REAL_H)
  rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
     $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \
!    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H) \
!    $(DF_H)
  
  varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \
--- 2385,2392 ----
      $(BCONFIG_H) $(REAL_H)
  rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
     $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \
!    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(EXPR_H) \
!    $(TREE_H) $(DF_H)
  
  varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \
*************** expmed.o : expmed.c $(CONFIG_H) $(SYSTEM
*** 2435,2441 ****
     toplev.h $(TM_P_H) langhooks.h $(DF_H) $(TARGET_H)
  explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
!    toplev.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h \
     $(TARGET_H) output.h
  optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \
--- 2435,2441 ----
     toplev.h $(TM_P_H) langhooks.h $(DF_H) $(TARGET_H)
  explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
!    toplev.h except.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h \
     $(TARGET_H) output.h
  optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \
*** gcc/config/alpha/alpha.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/alpha/alpha.c	2008-03-25 15:53:27.000000000 +0100
*************** alpha_expand_prologue (void)
*** 7467,7472 ****
--- 7467,7475 ----
    HOST_WIDE_INT sa_size;
    /* Complete stack size needed.  */
    HOST_WIDE_INT frame_size;
+   /* Probed stack size; it additionally includes the size of
+      the "reserve region" if any.  */
+   HOST_WIDE_INT probed_size;
    /* Offset from base reg to register save area.  */
    HOST_WIDE_INT reg_offset;
    rtx sa_reg;
*************** alpha_expand_prologue (void)
*** 7526,7545 ****
  
       Note that we are only allowed to adjust sp once in the prologue.  */
  
!   if (frame_size <= 32768)
      {
!       if (frame_size > 4096)
  	{
  	  int probed;
  
! 	  for (probed = 4096; probed < frame_size; probed += 8192)
  	    emit_insn (gen_probe_stack (GEN_INT (TARGET_ABI_UNICOSMK
  						 ? -probed + 64
  						 : -probed)));
  
! 	  /* We only have to do this probe if we aren't saving registers.  */
! 	  if (sa_size == 0 && frame_size > probed - 4096)
! 	    emit_insn (gen_probe_stack (GEN_INT (-frame_size)));
  	}
  
        if (frame_size != 0)
--- 7529,7553 ----
  
       Note that we are only allowed to adjust sp once in the prologue.  */
  
!   probed_size = frame_size;
!   if (flag_stack_check)
!     probed_size += STACK_CHECK_PROTECT;
! 
!   if (probed_size <= 32768)
      {
!       if (probed_size > 4096)
  	{
  	  int probed;
  
! 	  for (probed = 4096; probed < probed_size; probed += 8192)
  	    emit_insn (gen_probe_stack (GEN_INT (TARGET_ABI_UNICOSMK
  						 ? -probed + 64
  						 : -probed)));
  
! 	  /* We only have to do this probe if we aren't saving registers or
! 	     if we are probing beyond the frame because of -fstack-check.  */
! 	  if ((probed_size > probed - 4096 && !sa_size) || flag_stack_check)
! 	    emit_insn (gen_probe_stack (GEN_INT (-probed_size)));
  	}
  
        if (frame_size != 0)
*************** alpha_expand_prologue (void)
*** 7554,7563 ****
  	 number of 8192 byte blocks to probe.  We then probe each block
  	 in the loop and then set SP to the proper location.  If the
  	 amount remaining is > 4096, we have to do one more probe if we
! 	 are not saving any registers.  */
  
!       HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;
!       HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;
        rtx ptr = gen_rtx_REG (DImode, 22);
        rtx count = gen_rtx_REG (DImode, 23);
        rtx seq;
--- 7562,7572 ----
  	 number of 8192 byte blocks to probe.  We then probe each block
  	 in the loop and then set SP to the proper location.  If the
  	 amount remaining is > 4096, we have to do one more probe if we
! 	 are not saving any registers or if we are probing beyond the
! 	 frame because of -fstack-check.  */
  
!       HOST_WIDE_INT blocks = (probed_size + 4096) / 8192;
!       HOST_WIDE_INT leftover = probed_size + 4096 - blocks * 8192;
        rtx ptr = gen_rtx_REG (DImode, 22);
        rtx count = gen_rtx_REG (DImode, 23);
        rtx seq;
*************** alpha_expand_prologue (void)
*** 7570,7589 ****
  	 late in the compilation, generate the loop as a single insn.  */
        emit_insn (gen_prologue_stack_probe_loop (count, ptr));
  
!       if (leftover > 4096 && sa_size == 0)
  	{
  	  rtx last = gen_rtx_MEM (DImode, plus_constant (ptr, -leftover));
  	  MEM_VOLATILE_P (last) = 1;
  	  emit_move_insn (last, const0_rtx);
  	}
  
!       if (TARGET_ABI_WINDOWS_NT)
  	{
  	  /* For NT stack unwind (done by 'reverse execution'), it's
  	     not OK to take the result of a loop, even though the value
  	     is already in ptr, so we reload it via a single operation
  	     and subtract it to sp.
  
  	     Yes, that's correct -- we have to reload the whole constant
  	     into a temporary via ldah+lda then subtract from sp.  */
  
--- 7579,7601 ----
  	 late in the compilation, generate the loop as a single insn.  */
        emit_insn (gen_prologue_stack_probe_loop (count, ptr));
  
!       if ((leftover > 4096 && !sa_size) || flag_stack_check)
  	{
  	  rtx last = gen_rtx_MEM (DImode, plus_constant (ptr, -leftover));
  	  MEM_VOLATILE_P (last) = 1;
  	  emit_move_insn (last, const0_rtx);
  	}
  
!       if (TARGET_ABI_WINDOWS_NT || flag_stack_check)
  	{
  	  /* For NT stack unwind (done by 'reverse execution'), it's
  	     not OK to take the result of a loop, even though the value
  	     is already in ptr, so we reload it via a single operation
  	     and subtract it to sp.
  
+ 	     Same if -fstack-check is specified, because the probed stack
+ 	     size is not equal to the frame size.
+ 
  	     Yes, that's correct -- we have to reload the whole constant
  	     into a temporary via ldah+lda then subtract from sp.  */
  
*** gcc/config/i386/cygming.h.0	2008-03-25 16:56:40.000000000 +0100
--- gcc/config/i386/cygming.h	2008-03-25 16:58:52.000000000 +0100
*************** do {						\
*** 407,412 ****
--- 407,415 ----
  #define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION i386_pe_adjust_class_at_definition
  #define TARGET_MANGLE_DECL_ASSEMBLER_NAME i386_pe_mangle_decl_assembler_name
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #undef TREE
  
  #ifndef BUFSIZ
*** gcc/config/i386/freebsd.h.0	2008-03-25 16:56:53.000000000 +0100
--- gcc/config/i386/freebsd.h	2008-03-25 17:02:27.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 138,140 ****
--- 138,143 ----
     compiler get the contents of <float.h> and std::numeric_limits correct.  */
  #undef TARGET_96_ROUND_53_LONG_DOUBLE
  #define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/i386/linux.h.0	2008-03-25 16:57:31.000000000 +0100
--- gcc/config/i386/linux.h	2008-03-25 16:58:52.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 194,199 ****
--- 194,205 ----
  
  #define MD_UNWIND_SUPPORT "config/i386/linux-unwind.h"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Define this to be nonzero if the stack pointer needs to be moved.  */
+ #define STACK_CHECK_MOVING_SP 1
+ 
  /* This macro may be overridden in i386/k*bsd-gnu.h.  */
  #define REG_NAME(reg) reg
  
*** gcc/config/i386/linux64.h.0	2008-03-25 16:57:41.000000000 +0100
--- gcc/config/i386/linux64.h	2008-03-25 16:58:52.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 100,105 ****
--- 100,111 ----
  
  #define MD_UNWIND_SUPPORT "config/i386/linux-unwind.h"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Define this to be nonzero if the stack pointer needs to be moved.  */
+ #define STACK_CHECK_MOVING_SP 1
+ 
  /* This macro may be overridden in i386/k*bsd-gnu.h.  */
  #define REG_NAME(reg) reg
  
*** gcc/config/i386/lynx.h.0	2008-03-25 16:57:52.000000000 +0100
--- gcc/config/i386/lynx.h	2008-03-25 16:58:52.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 88,90 ****
--- 88,93 ----
     TLS is detected by configure.  We undefine it here.  */
  
  #undef HAVE_AS_TLS
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/i386/sol2.h.0	2008-03-25 16:58:01.000000000 +0100
--- gcc/config/i386/sol2.h	2008-03-25 17:03:04.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 109,111 ****
--- 109,114 ----
  /* We do not need NT_VERSION notes.  */
  #undef X86_FILE_START_VERSION_DIRECTIVE
  #define X86_FILE_START_VERSION_DIRECTIVE false
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/i386/vxworks.h.0	2008-03-25 16:47:06.000000000 +0100
--- gcc/config/i386/vxworks.h	2008-03-25 23:05:34.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 76,78 ****
--- 76,86 ----
  /* We cannot use PC-relative accesses for VxWorks PIC because there is no
     fixed gap between segments.  */
  #undef ASM_PREFERRED_EH_DATA_FORMAT
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* This platform supports the probing method of stack checking (RTP mode)
+    and the ZCX mechanism. 8K is reserved in the stack to propagate
+    exceptions reliably in case of stack overflow. */
+ #define STACK_CHECK_PROTECT 8192
*** gcc/config/i386/vxworksae.h.0	2008-03-25 16:47:06.000000000 +0100
--- gcc/config/i386/vxworksae.h	2008-03-25 16:52:21.000000000 +0100
*************** along with GCC; see the file COPYING3.
*** 24,26 ****
--- 24,31 ----
    do						\
      builtin_define ("CPU=SIMNT");		\
    while (0)
+ 
+ /* This platform supports the probing method of stack checking and
+    requires 4K of space for executing a possible last chance handler.  */
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 4096
*** gcc/config/i386/i386.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/i386/i386.h	2008-03-25 16:58:52.000000000 +0100
*************** struct machine_function GTY(())
*** 2495,2500 ****
--- 2495,2503 ----
  #define SYMBOL_REF_DLLEXPORT_P(X) \
  	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLEXPORT) != 0)
  
+ /* Define this to be nonzero to use an inclusive OR.  */
+ #define STACK_CHECK_PROBE_IOR 1
+ 
  /* Model costs for vectorizer.  */
  
  /* Cost of conditional branch.  */
*** gcc/config/i386/i386.c.0	2008-12-14 17:17:44.000000000 +0100
--- gcc/config/i386/i386.c	2008-12-14 17:18:19.000000000 +0100
*************** static int ix86_function_regparm (const_
*** 1753,1758 ****
--- 1753,1759 ----
  static void ix86_compute_frame_layout (struct ix86_frame *);
  static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,
  						 rtx, rtx, int);
+ static rtx ix86_expand_int_compare (enum rtx_code, rtx, rtx);
  
  
  /* The svr4 ABI for the i386 says that records and unions are returned
*************** optimization_options (int level, int siz
*** 2984,2989 ****
--- 2985,3004 ----
  #endif
  }
  
+ /* Decide whether we must probe the stack before any space allocation
+    on this target.  It's essentially TARGET_STACK_PROBE except when
+    -fstack-check causes the stack to be already probed differently.  */
+ 
+ bool
+ ix86_target_stack_probe (void)
+ {
+   /* Do not probe the stack twice if static stack checking is enabled.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
+     return false;
+ 
+   return TARGET_STACK_PROBE;
+ }
+ 
  /* Decide whether we can make a sibling call to a function.  DECL is the
     declaration of the function being targeted by the call and EXP is the
     CALL_EXPR representing the call.  */
*************** ix86_compute_frame_layout (struct ix86_f
*** 6098,6103 ****
--- 6113,6122 ----
    else
      frame->save_regs_using_mov = false;
  
+   /* If static stack checking is enabled and done with probes, the registers
+      need to be saved before allocating the frame.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && !stack_check_symbol)
+     frame->save_regs_using_mov = false;
  
    /* Skip return address and saved base pointer.  */
    offset = frame_pointer_needed ? UNITS_PER_WORD * 2 : UNITS_PER_WORD;
*************** ix86_internal_arg_pointer (void)
*** 6435,6440 ****
--- 6454,6904 ----
    return virtual_incoming_args_rtx;
  }
  
+ struct scratch_reg {
+   rtx reg;
+   bool saved;
+ };
+ 
+ /* Return a short-lived scratch register for use on function entry. 
+    In 32-bit mode, it is valid only after the registers are saved
+    in the prologue.  This register must be released by means of
+    release_scratch_register_on_entry once it is dead.  */
+ 
+ static void
+ get_scratch_register_on_entry (struct scratch_reg *sr)
+ {
+   int regno;
+ 
+   sr->saved = false;
+ 
+   if (TARGET_64BIT)
+     regno = FIRST_REX_INT_REG + 3; /* R11 */
+   else
+     {
+       /* See ix86_stack_realign_arg_pointer_regno_for for the logic.  */
+       tree decl = current_function_decl, fntype = TREE_TYPE (decl);
+       bool fast_p
+ 	= lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fntype)) != 0;
+       int regparm = ix86_function_regparm (fntype, decl);
+       int faap_regno = cfun->machine->force_align_arg_pointer
+ 		       ? REGNO (cfun->machine->force_align_arg_pointer)
+ 		       : INVALID_REGNUM;
+ 
+       if (!ix86_eax_maybe_live_in_or_out (decl, fast_p, regparm, 0)
+ 	  && faap_regno != 0)
+ 	regno = 0;
+       else if (!ix86_edx_maybe_live_in_or_out (decl, fast_p, regparm, 0)
+ 	       && faap_regno != 1)
+ 	regno = 1;
+       else if (!ix86_ecx_maybe_live_in_or_out (decl, fast_p, regparm, 0)
+ 	       && faap_regno != 2)
+ 	regno = 2;
+       else if (ix86_save_reg (3, true))
+ 	regno = 3;
+       else if (ix86_save_reg (4, true))
+ 	regno = 4;
+       else if (ix86_save_reg (5, true))
+ 	regno = 5;
+       else
+ 	{
+ 	  if (faap_regno == 0)
+ 	    regno = 1;
+ 	  else
+ 	    regno = 0;
+ 	  sr->saved = true;
+ 	}
+     }
+ 
+   sr->reg = gen_rtx_REG (Pmode, regno);
+   if (sr->saved)
+     {
+       rtx insn = emit_insn (gen_push (sr->reg));
+       RTX_FRAME_RELATED_P (insn) = 1;
+     }
+ }
+ 
+ /* Release a scratch register obtained from the preceding function.  */
+ 
+ static void
+ release_scratch_register_on_entry (struct scratch_reg *sr)
+ {
+   if (sr->saved)
+     {
+       rtx insn, x;
+ 
+       if (TARGET_64BIT)
+ 	insn = emit_insn (gen_popdi1 (sr->reg));
+       else
+ 	insn = emit_insn (gen_popsi1 (sr->reg));
+ 
+       /* The RTX_FRAME_RELATED_P mechanism doesn't know about pop.  */
+       RTX_FRAME_RELATED_P (insn) = 1;
+       x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (UNITS_PER_WORD));
+       x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);
+       REG_NOTES (insn)
+ 	= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);
+   }
+ }
+ 
+ /* The run-time loop is made up of 8 insns in the generic case while this
+    compile-time loop is made up of n insns for n # of intervals.  */
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ #define SMALL_INTERVAL(size) ((size) <= 8 * PROBE_INTERVAL)
+ 
+ /* Output one probe.  */
+ 
+ static inline void
+ output_probe_op (void)
+ {
+   fputs (TARGET_64BIT ? "\torq\t$0, " : "\torl\t$0, ", asm_out_file);
+ }
+ 
+ /* Adjust the stack by SIZE bytes and output one probe.  */
+ 
+ static void
+ output_adjust_stack_and_probe_op (HOST_WIDE_INT size)
+ {
+   fprintf (asm_out_file, "\tsub\t$"HOST_WIDE_INT_PRINT_DEC",", size);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   fputc ('\n', asm_out_file);
+   output_probe_op ();
+   fputc ('(', asm_out_file);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   fputs (")\n", asm_out_file);
+ }
+ 
+ /* Adjust the stack by SIZE bytes while probing it.  Note that we skip the
+    probe for the first interval + a small dope of 4 words and instead probe
+    that many bytes past the specified size to maintain a protection area.  */
+ 
+ const char *
+ output_adjust_stack_and_probe (rtx size_rtx, rtx reg)
+ {
+   const int dope = 4 * UNITS_PER_WORD;
+   static int labelno = 0;
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (SMALL_INTERVAL (size))
+     {
+       HOST_WIDE_INT i;
+       bool first_probe = true;
+ 
+       /* Adjust SP and probe to PROBE_INTERVAL + N * PROBE_INTERVAL for
+ 	 values of N from 1 until it exceeds SIZE.  If only one probe is
+ 	 needed, this will not generate any code.  Then adjust and probe
+ 	 to PROBE_INTERVAL + SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  if (first_probe)
+ 	    {
+ 	      output_adjust_stack_and_probe_op (2 * PROBE_INTERVAL + dope);
+ 	      first_probe = false;
+ 	    }
+ 	  else
+ 	    output_adjust_stack_and_probe_op (PROBE_INTERVAL);
+ 	}
+ 
+       if (first_probe)
+ 	output_adjust_stack_and_probe_op (size + PROBE_INTERVAL + dope);
+       else
+ 	output_adjust_stack_and_probe_op (size + PROBE_INTERVAL - i);
+     }
+ 
+   /* In the variable case, do the same as above, but in a loop.  Note that we
+      must be extra careful with variables wrapping around because we might be
+      at the very top (or the very bottom) of the address space and we have to
+      be able to handle this case properly; in particular, we use an equality
+      test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* SP = SP_0 + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\tsub\t$%d, ", PROBE_INTERVAL + dope);
+       print_reg (stack_pointer_rtx, 0, asm_out_file);
+ 
+       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */
+       fprintf (asm_out_file, "\n\tmov\t$-"HOST_WIDE_INT_PRINT_DEC", ",
+ 	       rounded_size);
+       print_reg (reg, 0, asm_out_file);
+       fputs ("\n\tadd\t", asm_out_file);
+       print_reg (stack_pointer_rtx, 0, asm_out_file);
+       fputs (", ", asm_out_file);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	  while (SP != LAST_ADDR)
+ 	    {
+ 	      SP = SP + PROBE_INTERVAL
+ 	      probe at SP
+ 	    }
+ 
+ 	 adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for
+ 	 values of N from 1 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+       /* Jump to END_LAB if SP == LAST_ADDR.  */
+       fputs ("\tcmp\t", asm_out_file);
+       print_reg (stack_pointer_rtx, 0, asm_out_file);
+       fputs (", ", asm_out_file);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tje\t", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+ 
+       /* SP = SP + PROBE_INTERVAL and probe at SP.  */
+       output_adjust_stack_and_probe_op (PROBE_INTERVAL);
+ 
+       fprintf (asm_out_file, "\tjmp\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: adjust SP and probe to PROBE_INTERVAL + SIZE if we cannot
+ 	 assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	output_adjust_stack_and_probe_op (size - rounded_size);
+     }
+ 
+   /* Adjust back to account for the additional first interval.  */
+   fprintf (asm_out_file, "\tadd\t$%d, ", PROBE_INTERVAL + dope);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   fputc ('\n', asm_out_file);
+ 
+   return "";
+ }
+ 
+ /* Wrapper around gen_adjust_stack_and_probe.  */
+ 
+ static rtx
+ ix86_gen_adjust_stack_and_probe (rtx op0, rtx op1)
+ {
+   if (TARGET_64BIT)
+     return gen_adjust_stack_and_probedi (op0, op1);
+   else
+     return gen_adjust_stack_and_probesi (op0, op1);
+ }
+ 
+ /* Emit code to adjust the stack by SIZE bytes while probing it.  */
+ 
+ static void
+ ix86_adjust_stack_and_probe (HOST_WIDE_INT size)
+ {
+   rtx size_rtx = GEN_INT (size), insn, x;
+ 
+   if (SMALL_INTERVAL (size))
+     insn = emit_insn (ix86_gen_adjust_stack_and_probe (size_rtx, const0_rtx));
+   else
+     {
+       struct scratch_reg sr;
+       get_scratch_register_on_entry (&sr);
+       insn = emit_insn (ix86_gen_adjust_stack_and_probe (size_rtx, sr.reg));
+       release_scratch_register_on_entry (&sr);
+     }
+ 
+   RTX_FRAME_RELATED_P (insn) = 1;
+   x = gen_rtx_MINUS (Pmode, stack_pointer_rtx, size_rtx);
+   x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);
+   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);
+ 
+   /* Make sure nothing is scheduled before we are done.  */
+   emit_insn (gen_blockage ());
+ }
+ 
+ /* Output a conditional trap.  COND is the condition code.  */
+ 
+ const char *
+ output_cond_trap (rtx cond)
+ {
+   static int labelno = 0;
+   char ok_lab[32];
+ 
+   ASM_GENERATE_INTERNAL_LABEL (ok_lab, "LOCT", labelno++);
+ 
+   fputs ("\tj", asm_out_file); print_operand (asm_out_file, cond, 'c');
+   fputs ("\t", asm_out_file); assemble_name (asm_out_file, ok_lab);
+   fputs ("\n" ASM_SHORT "0x0b0f\n", asm_out_file);
+   ASM_OUTPUT_LABEL (asm_out_file, ok_lab);
+ 
+   return "";
+ }
+ 
+ /* Output one probe at OFFSET + INDEX from the current stack pointer.  */
+ 
+ static void
+ output_probe_stack_range_op (HOST_WIDE_INT offset, rtx index)
+ {
+   output_probe_op ();
+   if (offset)
+     fprintf (asm_out_file, "-"HOST_WIDE_INT_PRINT_DEC, offset);
+   fputc ('(', asm_out_file);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   if (index)
+     {
+       fputc (',', asm_out_file);
+       print_reg (index, 0, asm_out_file);
+       fputs (",1", asm_out_file);
+     }
+   fputs (")\n", asm_out_file);
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx, rtx reg)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (SMALL_INTERVAL (size))
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	output_probe_stack_range_op (first + i, NULL_RTX);
+ 
+       output_probe_stack_range_op (first + size, NULL_RTX);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_OFFSET = FIRST.  */
+       fprintf (asm_out_file, "\tmov\t$-"HOST_WIDE_INT_PRINT_DEC", ", first);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+ 
+       /* LAST_OFFSET = FIRST + ROUNDED_SIZE.  */
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	 while (TEST_ADDR != LAST_ADDR)
+ 	   {
+ 	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	     probe at TEST_ADDR
+ 	   }
+ 
+ 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+ 	 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fprintf (asm_out_file, "\tcmp\t$-"HOST_WIDE_INT_PRINT_DEC", ",
+ 	       first + rounded_size);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tje\t", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+ 
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\tsub\t$%d, ", PROBE_INTERVAL);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+ 
+       /* Probe at TEST_ADDR.  */
+       output_probe_stack_range_op (0, reg);
+ 
+       fprintf (asm_out_file, "\tjmp\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	output_probe_stack_range_op (size - rounded_size, reg);
+     }
+ 
+   return "";
+ }
+ 
+ /* Wrapper around gen_probe_stack_range.  */
+ 
+ static rtx
+ ix86_gen_probe_stack_range (rtx op0, rtx op1, rtx op2)
+ {
+   if (TARGET_64BIT)
+     return gen_probe_stack_rangedi (op0, op1, op2);
+   else
+     return gen_probe_stack_rangesi (op0, op1, op2);
+ }
+ 
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+ 
+   if (stack_check_symbol)
+     {
+       struct scratch_reg sr;
+       rtx res;
+ 
+       get_scratch_register_on_entry (&sr);
+       emit_move_insn (sr.reg,
+ 		      plus_constant (stack_pointer_rtx, -(first + size)));
+       res = ix86_expand_int_compare (LTU, sr.reg,
+ 				     gen_rtx_MEM (Pmode, stack_check_symbol));
+       emit_insn (gen_rtx_TRAP_IF (VOIDmode, res, GEN_INT (6)));
+       release_scratch_register_on_entry (&sr);
+     }
+   else if (SMALL_INTERVAL (size))
+      emit_insn (ix86_gen_probe_stack_range (GEN_INT (first), GEN_INT (size),
+ 					    const0_rtx));
+   else
+     {
+       struct scratch_reg sr;
+       get_scratch_register_on_entry (&sr);
+       emit_insn (ix86_gen_probe_stack_range (GEN_INT (first), GEN_INT (size),
+ 					     sr.reg));
+       release_scratch_register_on_entry (&sr);
+     }
+ 
+   /* Make sure nothing is scheduled before we are done.  */
+   emit_insn (gen_blockage ());
+ }
+ 
  /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.
     This is called from dwarf2out.c to emit call frame instructions
     for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */
*************** ix86_expand_prologue (void)
*** 6536,6541 ****
--- 7000,7031 ----
    else
      allocate += frame.nregs * UNITS_PER_WORD;
  
+   /* The stack has already been decremented by the instruction calling us
+      so we need to probe unconditionally to preserve the protection area.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
+     {
+       /* We expect the registers to be saved when probes are used.  */
+       gcc_assert (!frame.save_regs_using_mov || stack_check_symbol);
+ 
+       if (STACK_CHECK_MOVING_SP)
+ 	{
+ 	  ix86_adjust_stack_and_probe (allocate);
+ 	  allocate = 0;
+ 	}
+       else
+ 	{
+ 	  HOST_WIDE_INT size = allocate;
+ 
+ 	  if (TARGET_64BIT && size >= (HOST_WIDE_INT) 0x80000000)
+ 	    size = 0x80000000 - STACK_CHECK_PROTECT - 1;
+ 
+ 	  if (TARGET_STACK_PROBE)
+ 	    ix86_emit_probe_stack_range (0, size + STACK_CHECK_PROTECT);
+ 	  else
+ 	    ix86_emit_probe_stack_range (STACK_CHECK_PROTECT, size);
+ 	}
+     }
+ 
    /* When using red zone we may start register saving before allocating
       the stack frame saving one cycle of the prologue. However I will
       avoid doing this if I am going to have to probe the stack since
*************** ix86_expand_prologue (void)
*** 6549,6555 ****
  
    if (allocate == 0)
      ;
!   else if (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)
      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
  			       GEN_INT (-allocate), -1);
    else
--- 7039,7045 ----
  
    if (allocate == 0)
      ;
!   else if (!ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)
      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
  			       GEN_INT (-allocate), -1);
    else
*** gcc/config/i386/i386-protos.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/i386/i386-protos.h	2008-03-25 16:58:52.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 23,28 ****
--- 23,29 ----
  extern void override_options (void);
  extern void optimization_options (int, int);
  
+ extern bool ix86_target_stack_probe (void);
  extern int ix86_can_use_return_insn_p (void);
  extern int ix86_frame_pointer_required (void);
  extern void ix86_setup_frame_addresses (void);
*************** extern const char *output_387_binary_op 
*** 73,78 ****
--- 74,82 ----
  extern const char *output_387_reg_move (rtx, rtx*);
  extern const char *output_fix_trunc (rtx, rtx*, int);
  extern const char *output_fp_compare (rtx, rtx*, int, int);
+ extern const char *output_adjust_stack_and_probe (rtx, rtx);
+ extern const char *output_cond_trap (rtx);
+ extern const char *output_probe_stack_range (rtx, rtx, rtx);
  
  extern void ix86_expand_clear (rtx);
  extern void ix86_expand_move (enum machine_mode, rtx[]);
*** gcc/config/i386/i386.md.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/i386/i386.md	2008-03-28 17:26:29.000000000 +0100
***************
*** 208,213 ****
--- 208,214 ----
     (UNSPECV_LOCK		13)
     (UNSPECV_PROLOGUE_USE	14)
     (UNSPECV_CLD			15)
+    (UNSPECV_STACK_PROBE_INLINE	16)
    ])
  
  ;; Constants to represent pcomtrue/pcomfalse variants
***************
*** 19946,19952 ****
  	(unspec_volatile:SI [(match_dup 0)] UNSPECV_STACK_PROBE))
     (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
     (clobber (reg:CC FLAGS_REG))]
!   "!TARGET_64BIT && TARGET_STACK_PROBE"
    "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
--- 19947,19953 ----
  	(unspec_volatile:SI [(match_dup 0)] UNSPECV_STACK_PROBE))
     (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
     (clobber (reg:CC FLAGS_REG))]
!   "!TARGET_64BIT && ix86_target_stack_probe ()"
    "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
***************
*** 19958,19964 ****
     (clobber (reg:DI R10_REG))
     (clobber (reg:DI R11_REG))
     (clobber (reg:CC FLAGS_REG))]
!   "TARGET_64BIT && TARGET_STACK_PROBE"
    "call\t___chkstk"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
--- 19959,19965 ----
     (clobber (reg:DI R10_REG))
     (clobber (reg:DI R11_REG))
     (clobber (reg:CC FLAGS_REG))]
!   "TARGET_64BIT && ix86_target_stack_probe ()"
    "call\t___chkstk"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
***************
*** 19966,19972 ****
  (define_expand "allocate_stack"
    [(match_operand 0 "register_operand" "")
     (match_operand 1 "general_operand" "")]
!   "TARGET_STACK_PROBE"
  {
    rtx x;
  
--- 19967,19973 ----
  (define_expand "allocate_stack"
    [(match_operand 0 "register_operand" "")
     (match_operand 1 "general_operand" "")]
!   "ix86_target_stack_probe ()"
  {
    rtx x;
  
***************
*** 19996,20001 ****
--- 19997,20025 ----
    DONE;
  })
  
+ (define_mode_iterator P [(SI "!TARGET_64BIT") (DI "TARGET_64BIT")])
+ 
+ (define_insn "adjust_stack_and_probe<P:mode>"
+   [(unspec_volatile:P [(match_operand:P 0 "const_int_operand" "n")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (set (reg:P SP_REG) (minus:P (reg:P SP_REG) (match_dup 0)))
+    (clobber (match_operand:P 1 "general_operand" "=rn"))
+    (clobber (reg:CC FLAGS_REG))
+    (clobber (mem:BLK (scratch)))]
+   ""
+   "* return output_adjust_stack_and_probe (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
+ (define_insn "probe_stack_range<P:mode>"
+   [(unspec_volatile:P [(match_operand:P 0 "const_int_operand" "n")
+ 		       (match_operand:P 1 "const_int_operand" "n")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (match_operand:P 2 "general_operand" "=rn"))
+    (clobber (reg:CC FLAGS_REG))]
+   ""
+   "* return output_probe_stack_range (operands[0], operands[1], operands[2]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "builtin_setjmp_receiver"
    [(label_ref (match_operand 0 "" ""))]
    "!TARGET_64BIT && flag_pic"
***************
*** 20462,20468 ****
                       [(match_dup 0)
                        (match_operand:SI 1 "nonmemory_operand" "")]))
                (clobber (reg:CC FLAGS_REG))])]
!   "! optimize_size && ! TARGET_READ_MODIFY_WRITE"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 2) (match_dup 1)]))
--- 20486,20494 ----
                       [(match_dup 0)
                        (match_operand:SI 1 "nonmemory_operand" "")]))
                (clobber (reg:CC FLAGS_REG))])]
!   "!optimize_size && !TARGET_READ_MODIFY_WRITE
!    /* Do not split stack checking probes.  */
!    && GET_CODE (operands[3]) != IOR && operands[1] != const0_rtx"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 2) (match_dup 1)]))
***************
*** 20477,20483 ****
                       [(match_operand:SI 1 "nonmemory_operand" "")
                        (match_dup 0)]))
                (clobber (reg:CC FLAGS_REG))])]
!   "! optimize_size && ! TARGET_READ_MODIFY_WRITE"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
--- 20503,20511 ----
                       [(match_operand:SI 1 "nonmemory_operand" "")
                        (match_dup 0)]))
                (clobber (reg:CC FLAGS_REG))])]
!   "!optimize_size && !TARGET_READ_MODIFY_WRITE
!    /* Do not split stack checking probes.  */
!    && GET_CODE (operands[3]) != IOR && operands[1] != const0_rtx"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
***************
*** 21201,21206 ****
--- 21229,21242 ----
    { return ASM_SHORT "0x0b0f"; }
    [(set_attr "length" "2")])
  
+ (define_insn "*cond_trap"
+   [(trap_if (match_operator 0 "comparison_operator"
+              [(reg:CC FLAGS_REG) (const_int 0)])
+ 	    (const_int 6))]
+   ""
+   "* return output_cond_trap (operands[0]);"
+   [(set_attr "length" "4")])
+ 
  (define_expand "sse_prologue_save"
    [(parallel [(set (match_operand:BLK 0 "" "")
  		   (unspec:BLK [(reg:DI 21)
*** gcc/config/ia64/hpux.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/ia64/hpux.h	2008-03-25 16:25:26.000000000 +0100
*************** do {								\
*** 215,217 ****
--- 215,224 ----
  
  #undef HANDLE_PRAGMA_PACK_PUSH_POP
  #define HANDLE_PRAGMA_PACK_PUSH_POP
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Minimum amount of stack required to recover from an anticipated stack
+    overflow detection.  */
+ #define STACK_CHECK_PROTECT (24 * 1024)
*** gcc/config/ia64/linux.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/ia64/linux.h	2008-03-25 15:53:27.000000000 +0100
*************** do {						\
*** 58,61 ****
--- 58,64 ----
  #undef LINK_EH_SPEC
  #define LINK_EH_SPEC ""
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #define MD_UNWIND_SUPPORT "config/ia64/linux-unwind.h"
*** gcc/config/ia64/ia64.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/ia64/ia64.c	2008-03-25 22:14:01.000000000 +0100
*************** gen_fr_restore_x (rtx dest, rtx src, rtx
*** 2895,2900 ****
--- 2895,3090 ----
    return gen_fr_restore (dest, src);
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ ia64_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ /* See Table 6.2 of the IA-64 Software Developer Manual, Volume 2.  */
+ #define BACKING_STORE_SIZE(N) ((N) > 0 ? ((N) + (N)/63 + 1) * 8 : 0)
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT end = first + size;
+   HOST_WIDE_INT rounded_size;
+   int sol, bs_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* On the IA-64 there is a second stack in memory, namely the Backing Store
+      of the Register Stack Engine.  We also need to probe it after checking
+      that the 2 stacks don't overlap.  */
+   sol = current_frame_info.n_input_regs + current_frame_info.n_local_regs;
+   bs_size = BACKING_STORE_SIZE (sol);
+ 
+   /* Detect collision of the 2 stacks if necessary.  */
+   if (bs_size > 0 || size > 0)
+     {
+       /* FIXME: clobber r2 and r3.  Should check for fixed registers.  */
+ 
+       fputs ("\tmov r3 = ar.bsp\n", asm_out_file);
+       /* Micro-optimization based on number of bits for END.  */
+       if (end >= (1 << 21))
+ 	fprintf (asm_out_file,
+ 		 "\tmovl r2 = -"HOST_WIDE_INT_PRINT_DEC"\n", end);
+       else
+ 	fprintf (asm_out_file,
+ 		 "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC",r0\n", end);
+       
+       /* Compare current value of BSP and SP registers.  */
+       fputs ("\t;;\n"
+ 	     "\tcmp.ltu p6, p0 = r3, r12\n", asm_out_file);
+ 
+       /* Compute the address of the probe for the Backing Store (which grows
+ 	 towards higher addresses).  We probe only at the first offset of
+ 	 the next page because some OS (eg Linux/ia64) only extend the
+ 	 backing store when this specific address is hit (but generate a SEGV
+ 	 on other address).  Page size is the worst case (4KB).  The reserve
+ 	 size is at least 4096 - (96 + 2) * 8 = 3312 bytes - which is
+ 	 enough.
+ 	 Also compute the address of the last probe for the memory
+ 	 stack (which grows towards lower addresses).  */
+       fputs ("\tadd r3 = 4095, r3\n", asm_out_file);
+       fputs ("\tadd r2 = r2, r12\n\t;;\n", asm_out_file);
+ 
+       /* Compare them and raise SEGV if the former has topped the latter.  */
+       fputs ("\t(p6) cmp.ltu p0, p6 = r3, r2\n\t;;\n", asm_out_file);
+       fputs ("\tdep r3 = r0, r3, 0, 12\n", asm_out_file);
+       fputs ("\t(p6) break 11\n\t;;\n", asm_out_file);
+     }
+ 
+   /* Probe the Backing Store if necessary.  */
+   if (bs_size > 0)
+     fputs ("\tst8 [r3] = r0\n", asm_out_file);
+ 
+   /* Probe the memory stack if necessary.  */
+   if (size == 0)
+     ;
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   else if (size <= PROBE_INTERVAL)
+     fputs ("\tst8 [r2] = r0\n", asm_out_file);
+ 
+   /* The run-time loop is made up of 8 insns in the generic case while this
+      compile-time loop is made up of 5+2*(n-2) insns for n # of intervals.  */
+   else if (size <= 4 * PROBE_INTERVAL)
+     {
+       HOST_WIDE_INT i;
+ 
+       fputs ("\tmov r2 = r12\n\t;;\n", asm_out_file);
+       fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 	       first + PROBE_INTERVAL);
+       fputs ("\tst8 [r2] = r0\n", asm_out_file);
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
+ 	 it exceeds SIZE.  If only two probes are needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
+ 	  fputs ("\tst8 [r2] = r0\n\t;;\n", asm_out_file);
+ 	}
+ 
+       fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 	       size - (i - PROBE_INTERVAL));
+       fputs ("\tst8 [r2] = r0\n", asm_out_file);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fputs ("\tmov r2 = r12\n\t;;\n", asm_out_file);
+       fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       if (rounded_size > (1 << 21))
+ 	{
+ 	  fprintf (asm_out_file, "\tmovl r3 = -"HOST_WIDE_INT_PRINT_DEC"\n\t;;\n",
+ 		   rounded_size);
+ 	  fputs ("\tadd r3 = r2, r3\n\t;;\n", asm_out_file);
+ 	}
+       else
+ 	{
+ 	  fputs ("\t;;\n", asm_out_file);
+ 	  fprintf (asm_out_file, "\taddl r3 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 		   rounded_size);
+ 	}
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	 while (TEST_ADDR != LAST_ADDR)
+ 	   {
+ 	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	     probe at TEST_ADDR
+ 	   }
+ 
+ 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+ 	 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tcmp.eq p6, p0 = r2, r3\n", asm_out_file);
+       fputs ("\t(p6) br.cond.dpnt ", asm_out_file);
+       assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fputs ("\tst8 [r2] = r0\n", asm_out_file);
+       fprintf (asm_out_file, "\tbr "); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+         {
+ 	  fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 		   size - rounded_size);
+ 	  fputs ("\tst8 [r2] = r0\n", asm_out_file);
+ 	}
+     }
+ 
+   return "";
+ }
+ 
  /* Called after register allocation to add any instructions needed for the
     prologue.  Using a prologue insn is favored compared to putting all of the
     instructions in output_function_prologue(), since it allows the scheduler
*************** ia64_expand_prologue (void)
*** 2943,2948 ****
--- 3133,3142 ----
  #undef PRINTREG
      }
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
+     ia64_emit_probe_stack_range (STACK_CHECK_PROTECT,
+ 				 current_frame_info.total_size);
+ 
    /* If there is no epilogue, then we don't need some prologue insns.
       We need to avoid emitting the dead prologue insns, because flow
       will complain about them.  */
*************** ia64_init_machine_status (void)
*** 5256,5261 ****
--- 5450,5456 ----
  
  static enum attr_itanium_class ia64_safe_itanium_class (rtx);
  static enum attr_type ia64_safe_type (rtx);
+ static bool asm_insn_p (rtx);
  
  static enum attr_itanium_class
  ia64_safe_itanium_class (rtx insn)
*************** ia64_safe_type (rtx insn)
*** 5274,5279 ****
--- 5469,5485 ----
    else
      return TYPE_UNKNOWN;
  }
+ 
+ static bool
+ asm_insn_p (rtx insn)
+ {
+   rtx pat = PATTERN (insn);
+   return (GET_CODE (pat) == ASM_INPUT
+           || (GET_CODE (pat) == PARALLEL
+ 	      && GET_CODE (XVECEXP (pat, 0, 0)) == UNSPEC_VOLATILE
+ 	      && XINT (XVECEXP (pat, 0, 0), 1) == UNSPECV_STACK_PROBE_INLINE)
+ 	  || asm_noperands (pat) >= 0);
+ }
  
  /* The following collection of routines emit instruction group stop bits as
     necessary to avoid dependencies.  */
*************** rtx_needs_barrier (rtx x, struct reg_fla
*** 5764,5769 ****
--- 5970,5980 ----
  	    case RETURN:
  	      break;
  
+ 	    case UNSPEC_VOLATILE:
+ 	      if (XINT (pat, 1) == UNSPECV_STACK_PROBE_INLINE)
+ 	        return 1;
+ 	    /* fall through */
+ 
  	    default:
  	      gcc_unreachable ();
  	    }
*************** ia64_dfa_sched_reorder (FILE *dump, int 
*** 6534,6541 ****
  	    enum attr_type t = ia64_safe_type (insn);
  	    if (t == TYPE_UNKNOWN)
  	      {
! 		if (GET_CODE (PATTERN (insn)) == ASM_INPUT
! 		    || asm_noperands (PATTERN (insn)) >= 0)
  		  {
  		    rtx lowest = ready[n_asms];
  		    ready[n_asms] = insn;
--- 6745,6751 ----
  	    enum attr_type t = ia64_safe_type (insn);
  	    if (t == TYPE_UNKNOWN)
  	      {
! 		if (asm_insn_p (insn))
  		  {
  		    rtx lowest = ready[n_asms];
  		    ready[n_asms] = insn;
*************** ia64_dfa_new_cycle (FILE *dump, int verb
*** 6699,6706 ****
    if ((reload_completed && safe_group_barrier_needed (insn))
        || (last_scheduled_insn
  	  && (GET_CODE (last_scheduled_insn) == CALL_INSN
! 	      || GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT
! 	      || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)))
      {
        init_insn_group_barriers ();
        if (verbose && dump)
--- 6909,6915 ----
    if ((reload_completed && safe_group_barrier_needed (insn))
        || (last_scheduled_insn
  	  && (GET_CODE (last_scheduled_insn) == CALL_INSN
! 	      || asm_insn_p (last_scheduled_insn))))
      {
        init_insn_group_barriers ();
        if (verbose && dump)
*************** ia64_dfa_new_cycle (FILE *dump, int verb
*** 6719,6726 ****
  	}
        else if (reload_completed)
  	setup_clocks_p = TRUE;
!       if (GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT
! 	  || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)
  	state_reset (curr_state);
        else
  	{
--- 6928,6934 ----
  	}
        else if (reload_completed)
  	setup_clocks_p = TRUE;
!       if (asm_insn_p (last_scheduled_insn))
  	state_reset (curr_state);
        else
  	{
*************** ia64_dfa_new_cycle (FILE *dump, int verb
*** 6733,6740 ****
    else if (reload_completed)
      setup_clocks_p = TRUE;
    if (setup_clocks_p && ia64_tune == PROCESSOR_ITANIUM
!       && GET_CODE (PATTERN (insn)) != ASM_INPUT
!       && asm_noperands (PATTERN (insn)) < 0)
      {
        enum attr_itanium_class c = ia64_safe_itanium_class (insn);
  
--- 6941,6947 ----
    else if (reload_completed)
      setup_clocks_p = TRUE;
    if (setup_clocks_p && ia64_tune == PROCESSOR_ITANIUM
!       && ! asm_insn_p (insn))
      {
        enum attr_itanium_class c = ia64_safe_itanium_class (insn);
  
*************** issue_nops_and_insn (struct bundle_state
*** 7636,7643 ****
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       gcc_assert (GET_CODE (PATTERN (insn)) != ASM_INPUT
! 		  && asm_noperands (PATTERN (insn)) < 0);
  
        if (ia64_safe_type (insn) == TYPE_L)
  	curr_state->accumulated_insns_num++;
--- 7843,7849 ----
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       gcc_assert (!asm_insn_p (insn));
  
        if (ia64_safe_type (insn) == TYPE_L)
  	curr_state->accumulated_insns_num++;
*************** issue_nops_and_insn (struct bundle_state
*** 7663,7670 ****
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       if (GET_CODE (PATTERN (insn)) == ASM_INPUT
! 	  || asm_noperands (PATTERN (insn)) >= 0)
  	{
  	  /* Finish bundle containing asm insn.  */
  	  curr_state->after_nops_num
--- 7869,7875 ----
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       if (asm_insn_p (insn))
  	{
  	  /* Finish bundle containing asm insn.  */
  	  curr_state->after_nops_num
*************** bundling (FILE *dump, int verbose, rtx p
*** 8073,8080 ****
         curr_state = curr_state->originator)
      {
        insn = curr_state->insn;
!       asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT
! 	       || asm_noperands (PATTERN (insn)) >= 0);
        insn_num++;
        if (verbose >= 2 && dump)
  	{
--- 8278,8284 ----
         curr_state = curr_state->originator)
      {
        insn = curr_state->insn;
!       asm_p = asm_insn_p (insn);
        insn_num++;
        if (verbose >= 2 && dump)
  	{
*************** bundling (FILE *dump, int verbose, rtx p
*** 8151,8158 ****
        /* Move the position backward in the window.  Group barrier has
  	 no slot.  Asm insn takes all bundle.  */
        if (INSN_CODE (insn) != CODE_FOR_insn_group_barrier
! 	  && GET_CODE (PATTERN (insn)) != ASM_INPUT
! 	  && asm_noperands (PATTERN (insn)) < 0)
  	pos--;
        /* Long insn takes 2 slots.  */
        if (ia64_safe_type (insn) == TYPE_L)
--- 8355,8361 ----
        /* Move the position backward in the window.  Group barrier has
  	 no slot.  Asm insn takes all bundle.  */
        if (INSN_CODE (insn) != CODE_FOR_insn_group_barrier
!           && ! asm_insn_p (insn))
  	pos--;
        /* Long insn takes 2 slots.  */
        if (ia64_safe_type (insn) == TYPE_L)
*************** bundling (FILE *dump, int verbose, rtx p
*** 8160,8167 ****
        gcc_assert (pos >= 0);
        if (pos % 3 == 0
  	  && INSN_CODE (insn) != CODE_FOR_insn_group_barrier
! 	  && GET_CODE (PATTERN (insn)) != ASM_INPUT
! 	  && asm_noperands (PATTERN (insn)) < 0)
  	{
  	  /* The current insn is at the bundle start: emit the
  	     template.  */
--- 8363,8369 ----
        gcc_assert (pos >= 0);
        if (pos % 3 == 0
  	  && INSN_CODE (insn) != CODE_FOR_insn_group_barrier
! 	  && ! asm_insn_p (insn))
  	{
  	  /* The current insn is at the bundle start: emit the
  	     template.  */
*************** final_emit_insn_group_barriers (FILE *du
*** 8400,8407 ****
  	  else if (recog_memoized (insn) >= 0)
  	    prev_insn = insn;
  	  need_barrier_p = (GET_CODE (insn) == CALL_INSN
! 			    || GET_CODE (PATTERN (insn)) == ASM_INPUT
! 			    || asm_noperands (PATTERN (insn)) >= 0);
  	}
      }
  }
--- 8602,8608 ----
  	  else if (recog_memoized (insn) >= 0)
  	    prev_insn = insn;
  	  need_barrier_p = (GET_CODE (insn) == CALL_INSN
! 			    || asm_insn_p (insn));
  	}
      }
  }
*** gcc/config/ia64/ia64-protos.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/ia64/ia64-protos.h	2008-03-25 15:53:27.000000000 +0100
*************** extern enum reg_class ia64_secondary_rel
*** 69,74 ****
--- 69,75 ----
  						   enum machine_mode, rtx);
  extern void process_for_unwind_directive (FILE *, rtx);
  extern const char *get_bundle_name (int);
+ extern const char *output_probe_stack_range (rtx, rtx);
  #endif /* RTX_CODE */
  
  #ifdef TREE_CODE
*** gcc/config/ia64/ia64.md.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/ia64/ia64.md	2008-03-25 15:53:27.000000000 +0100
***************
*** 98,103 ****
--- 98,104 ----
     (UNSPECV_PSAC_ALL		5)	; pred.safe_across_calls
     (UNSPECV_PSAC_NORMAL		6)
     (UNSPECV_SETJMP_RECEIVER	7)
+    (UNSPECV_STACK_PROBE_INLINE  8)
    ])
  
  (include "predicates.md")
***************
*** 5927,5932 ****
--- 5928,5943 ----
  ;; ::
  ;; ::::::::::::::::::::
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:DI 0 "const_int_operand" "")
+ 			(match_operand:DI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:DI 2))
+    (clobber (reg:DI 3))]
+   ""
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "predicable" "no")])
+ 
  (define_expand "prologue"
    [(const_int 1)]
    ""
*** gcc/config/mips/iris6.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/mips/iris6.h	2008-03-25 16:27:34.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 140,142 ****
--- 140,144 ----
  #undef SUBTARGET_CPP_SPEC
  #define SUBTARGET_CPP_SPEC "%{pthread:-D_REENTRANT}"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/mips/mips.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/mips/mips.c	2008-03-25 22:05:03.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 40,45 ****
--- 40,46 ----
  #include "output.h"
  #include "tree.h"
  #include "function.h"
+ #include "except.h"
  #include "expr.h"
  #include "optabs.h"
  #include "flags.h"
*************** mips_emit_loadgp (void)
*** 8363,8368 ****
--- 8364,8494 ----
      emit_insn (gen_loadgp_blockage ());
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ mips_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL > 32768
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ const char *
+ mips_output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (first + size <= 32768)
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	fprintf (asm_out_file, "\tsd\t$0,-"HOST_WIDE_INT_PRINT_DEC"($sp)\n",
+ 		 first + i);
+ 
+       fprintf (asm_out_file, "\tsd\t$0,-"HOST_WIDE_INT_PRINT_DEC"($sp)\n",
+ 	       first + size);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Sanity check for the addressing mode we're going to use.  */
+       gcc_assert (first <= 32768);
+ 
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fprintf (asm_out_file, "\taddiu\t$3,$sp,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       if (rounded_size > 32768)
+ 	{
+ 	  int high = (-rounded_size) & ~0xffff;
+ 	  int low = (-rounded_size) & 0xffff;
+ 
+ 	  if (high)
+ 	    fprintf (asm_out_file, "\tli\t$12,%d\n", high);
+ 	  if (low)
+ 	    fprintf (asm_out_file, "\tori\t$12,$12,0x%x\n", low);
+ 	  fputs ("\taddu\t$12,$3,$12\n", asm_out_file);
+ 	}
+       else
+ 	fprintf (asm_out_file, "\taddiu\t$12,$3,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 		 rounded_size);
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+ 	probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+ 	until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tbeq\t$3,$12,", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\t addiu\t$3,$3,-%d\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fprintf (asm_out_file, "\tb\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+       fputs ("\t sd\t$0,0($3)\n", asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tsd\t$0,-"HOST_WIDE_INT_PRINT_DEC"($12)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Expand the "prologue" pattern.  */
  
  void
*************** mips_expand_prologue (void)
*** 8379,8384 ****
--- 8505,8513 ----
    frame = &cfun->machine->frame;
    size = frame->total_size;
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)
+     mips_emit_probe_stack_range (STACK_CHECK_PROTECT, size);
+ 
    /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP
       bytes beforehand; this is enough to cover the register save area
       without going out of range.  */
*** gcc/config/mips/mips-protos.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/mips/mips-protos.h	2008-03-25 15:53:27.000000000 +0100
*************** extern const char *mips_output_condition
*** 279,284 ****
--- 279,285 ----
  						   const char *);
  extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);
  extern const char *mips_output_division (const char *, rtx *);
+ extern const char *mips_output_probe_stack_range (rtx, rtx);
  extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);
  extern bool mips_linked_madd_p (rtx, rtx);
  extern bool mips_store_data_bypass_p (rtx, rtx);
*** gcc/config/mips/mips.md.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/mips/mips.md	2008-03-25 15:53:27.000000000 +0100
***************
*** 213,218 ****
--- 213,221 ----
    ]
  )
  
+ (define_constants
+   [(UNSPECV_STACK_PROBE_INLINE  0)])
+ 
  (include "predicates.md")
  (include "constraints.md")
  
***************
*** 5501,5506 ****
--- 5504,5519 ----
  ;;  ....................
  ;;
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:SI 3))
+    (clobber (reg:SI 12))]
+   ""
+   "* return mips_output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "prologue"
    [(const_int 1)]
    ""
*** gcc/config/pa/pa-hpux.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/pa/pa-hpux.h	2008-03-25 15:53:27.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 124,127 ****
--- 124,130 ----
  #undef HANDLE_PRAGMA_PACK_PUSH_POP
  #define HANDLE_PRAGMA_PACK_PUSH_POP
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #define MD_UNWIND_SUPPORT "config/pa/hpux-unwind.h"
*** gcc/config/pa/pa.c.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/pa/pa.c	2008-03-25 22:06:44.000000000 +0100
*************** pa_output_function_prologue (FILE *file,
*** 3651,3656 ****
--- 3651,3791 ----
    remove_useless_addtr_insns (0);
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ pa_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc && !TARGET_64BIT); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL >= 8192
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ #if PROBE_INTERVAL & 0x7ff
+ #error Cannot use addil instruction for stack probing
+ #endif
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* Sanity check for addil instruction.  */
+   gcc_assert ((first & 0x7ff) == 0);
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (size <= PROBE_INTERVAL)
+     {
+       fprintf (asm_out_file, "\taddil L'"HOST_WIDE_INT_PRINT_DEC",%%r30\n",
+ 	       first);
+       fprintf (asm_out_file, "\tstw %%r0,"HOST_WIDE_INT_PRINT_DEC"(%%r1)\n",
+ 	       size);
+     }
+ 
+   /* The run-time loop is made up of 8 insns in the generic case while this
+      compile-time loop is made up of 3+2*(n-2) insns for n # of intervals.  */
+   else if (size <= 4 * PROBE_INTERVAL)
+     {
+       HOST_WIDE_INT i;
+ 
+       fprintf (asm_out_file, "\taddil L'"HOST_WIDE_INT_PRINT_DEC",%%r30\n",
+ 	       first + PROBE_INTERVAL);
+       fputs ("\tstw %r0,0(%r1)\n", asm_out_file);
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
+ 	 it exceeds SIZE.  If only two probes are needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  fprintf (asm_out_file, "\taddil L'%d,%%r1\n", PROBE_INTERVAL);
+ 	  fputs ("\tstw %r0,0(%r1)\n", asm_out_file);
+ 	}
+ 
+       fprintf (asm_out_file, "\tstw %%r0,"HOST_WIDE_INT_PRINT_DEC"(%%r1)\n",
+ 	       size - (i - PROBE_INTERVAL));
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fprintf (asm_out_file, "\taddil L'"HOST_WIDE_INT_PRINT_DEC",%%r30\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       fprintf (asm_out_file, "\tldil L'"HOST_WIDE_INT_PRINT_DEC",%%r20\n",
+ 	       rounded_size);
+       fputs ("\taddl %r1,%r20,%r20\n", asm_out_file);
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	 while (TEST_ADDR != LAST_ADDR)
+ 	   {
+ 	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	     probe at TEST_ADDR
+ 	   }
+ 
+ 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+ 	 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tcomb,= %r1,%r20,", asm_out_file);
+       assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\t addil L'%d,%%r1\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fprintf (asm_out_file, "\tb "); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+       fputs ("\t stw %r0,0(%r1)\n", asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tstw %%r0,"HOST_WIDE_INT_PRINT_DEC"(%%r20)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  void
  hppa_expand_prologue (void)
  {
*************** hppa_expand_prologue (void)
*** 3673,3678 ****
--- 3808,3816 ----
  
    actual_fsize = compute_frame_size (size, &save_fregs);
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
+     pa_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);
+ 
    /* Compute a few things we will use often.  */
    tmpreg = gen_rtx_REG (word_mode, 1);
  
*** gcc/config/pa/pa-protos.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/pa/pa-protos.h	2008-03-25 15:53:27.000000000 +0100
*************** extern const char *output_mul_insn (int,
*** 54,59 ****
--- 54,60 ----
  extern const char *output_div_insn (rtx *, int, rtx);
  extern const char *output_mod_insn (int, rtx);
  extern const char *singlemove_string (rtx *);
+ extern const char *output_probe_stack_range (rtx, rtx);
  extern void output_arg_descriptor (rtx);
  extern void output_global_address (FILE *, rtx, int);
  extern void print_operand (FILE *, rtx, int);
*** gcc/config/pa/pa.md.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/pa/pa.md	2008-03-25 15:53:27.000000000 +0100
***************
*** 7270,7275 ****
--- 7270,7285 ----
    [(set_attr "type" "branch")
     (set_attr "length" "12")])
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     10)
+    (clobber (reg:SI 1))
+    (clobber (reg:SI 20))]
+   "!TARGET_64BIT"
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "prologue"
    [(const_int 0)]
    ""
*** gcc/config/rs6000/aix.h.0	2008-03-25 15:47:49.000000000 +0100
--- gcc/config/rs6000/aix.h	2008-03-25 15:53:27.000000000 +0100
***************
*** 256,258 ****
--- 256,261 ----
  
  /* WINT_TYPE */
  #define WINT_TYPE "int"
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/rs6000/linux.h.0	2008-07-02 16:20:20.590532504 +0200
--- gcc/config/rs6000/linux.h	2008-07-02 16:20:56.236113552 +0200
***************
*** 128,130 ****
--- 128,133 ----
  #ifdef TARGET_DEFAULT_LONG_DOUBLE_128
  #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 128
  #endif
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/rs6000/lynx.h.0	2008-03-25 16:45:20.000000000 +0100
--- gcc/config/rs6000/lynx.h	2008-03-25 16:45:25.000000000 +0100
***************
*** 105,110 ****
--- 105,113 ----
  #undef HAVE_AS_TLS
  #define HAVE_AS_TLS 0
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #ifdef CRT_BEGIN
  /* This function is part of crtbegin*.o which is at the beginning of
     the link and is called from .fini which is usually toward the end
*** gcc/config/rs6000/vxworks.h.0	2008-03-25 16:47:06.000000000 +0100
--- gcc/config/rs6000/vxworks.h	2008-03-25 16:52:21.000000000 +0100
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 137,139 ****
--- 137,147 ----
  /* No _mcount profiling on VxWorks.  */
  #undef FUNCTION_PROFILER
  #define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)
+ 
+ /* This platform supports the probing method of stack checking (RTP mode)
+    and the ZCX mechanism. 8K is reserved in the stack to propagate
+    exceptions reliably in case of stack overflow. */
+ #define STACK_CHECK_PROTECT 8192
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/rs6000/vxworksae.h.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/rs6000/vxworksae.h	2008-03-25 16:52:21.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 21,23 ****
--- 21,29 ----
  #undef TARGET_VERSION
  #define TARGET_VERSION fprintf (stderr, " (PowerPC VxWorks AE)");
  
+ /* Target overrides for VxWorks AE653 platform.  */
+ 
+ /* This platform supports the probing method of stack checking and
+    requires 4K of space for executing a possible last chance handler.  */
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 4096
*** gcc/config/rs6000/rs6000.c.0	2008-12-13 11:55:20.000000000 +0100
--- gcc/config/rs6000/rs6000.c	2008-12-13 11:56:12.000000000 +0100
*************** rs6000_emit_allocate_stack (HOST_WIDE_IN
*** 15282,15287 ****
--- 15282,15428 ----
  		       REG_NOTES (insn));
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc && !TARGET_64BIT); /* Not implemented.  */
+ 
+   if (stack_check_symbol)
+     {
+       rtx reg1 = gen_rtx_REG (Pmode, 0), reg2 = gen_rtx_REG (Pmode, 12);
+       emit_insn (gen_addsi3 (reg1, stack_pointer_rtx,
+ 			     GEN_INT (-(first + size))));
+       emit_insn (gen_rtx_SET (VOIDmode, reg2,
+ 			      gen_rtx_HIGH (Pmode, stack_check_symbol)));
+       emit_insn (gen_rtx_SET (VOIDmode, reg2,
+ 			      gen_rtx_MEM (Pmode,
+ 					   gen_rtx_LO_SUM (Pmode, reg2,
+ 							   stack_check_symbol))));
+       emit_insn (gen_cond_trap (LTU, reg1, reg2, const0_rtx));
+     }
+   else
+     emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL > 32768
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (first + size <= 32768)
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	fprintf (asm_out_file, "\tstw 0,-"HOST_WIDE_INT_PRINT_DEC"(1)\n",
+ 		 first + i);
+ 
+       fprintf (asm_out_file, "\tstw 0,-"HOST_WIDE_INT_PRINT_DEC"(1)\n",
+ 	       first + size);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Sanity check for the addressing mode we're going to use.  */
+       gcc_assert (first <= 32768);
+ 
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fprintf (asm_out_file, "\taddi 12,1,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       if (rounded_size > 32768)
+ 	{
+ 	  int high = (-rounded_size) >> 16;
+ 	  int low = (-rounded_size) & 0xffff;
+ 
+ 	  if (high)
+ 	    fprintf (asm_out_file, "\tlis 0,%d\n", high);
+ 	  if (low)
+ 	    fprintf (asm_out_file, "\tori 0,0,%d\n", low);
+ 	  fputs ("\tadd 0,12,0\n", asm_out_file);
+ 	}
+       else
+ 	fprintf (asm_out_file, "\taddi 0,12,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 		 rounded_size);
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	 while (TEST_ADDR != LAST_ADDR)
+ 	   {
+ 	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	     probe at TEST_ADDR
+ 	   }
+ 
+ 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+ 	 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fputs ("\tcmpw 0,12,0\n", asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tbeq 0,", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\taddi 12,12,-%d\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fputs ("\tstw 0,0(12)\n", asm_out_file);
+       fprintf (asm_out_file, "\tb "); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tstw 0,-"HOST_WIDE_INT_PRINT_DEC"(12)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced
     with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2
     is not NULL.  It would be nice if dwarf2out_frame_debug_expr could
*************** rs6000_emit_prologue (void)
*** 15602,15607 ****
--- 15743,15751 ----
    int using_store_multiple;
    HOST_WIDE_INT sp_offset = 0;
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)
+     rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, info->total_size);
+ 
    if (TARGET_FIX_AND_CONTINUE)
      {
        /* gdb on darwin arranges to forward a function from the old
*** gcc/config/rs6000/rs6000-protos.h.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/rs6000/rs6000-protos.h	2008-03-25 15:53:27.000000000 +0100
*************** extern void rs6000_emit_swdivsf (rtx, rt
*** 98,103 ****
--- 98,104 ----
  extern void rs6000_emit_swdivdf (rtx, rtx, rtx);
  extern void rs6000_emit_swrsqrtsf (rtx, rtx);
  extern void output_toc (FILE *, rtx, int, enum machine_mode);
+ extern const char *output_probe_stack_range (rtx, rtx);
  extern void rs6000_initialize_trampoline (rtx, rtx, rtx);
  extern rtx rs6000_longcall_ref (rtx);
  extern void rs6000_fatal_bad_address (rtx);
*** gcc/config/rs6000/rs6000.md.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/rs6000/rs6000.md	2008-03-25 15:53:27.000000000 +0100
***************
*** 110,115 ****
--- 110,116 ----
     (UNSPECV_LL			1)	; load-locked
     (UNSPECV_SC			2)	; store-conditional
     (UNSPECV_EH_RR		9)	; eh_reg_restore
+    (UNSPECV_STACK_PROBE_INLINE  10)
    ])
  
  ;; Define an insn type attribute.  This is used in function unit delay
***************
*** 14420,14425 ****
--- 14421,14437 ----
  
  ;; Insns related to generating the function prologue and epilogue.
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:SI 0))
+    (clobber (reg:SI 12))
+    (clobber (reg:CC 68))]
+   "TARGET_32BIT"
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "three")])
+ 
  (define_expand "prologue"
    [(use (const_int 0))]
    "TARGET_SCHED_PROLOG"
*** gcc/config/sparc/sol2.h.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/sparc/sol2.h	2008-03-25 15:53:27.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 176,178 ****
--- 176,181 ----
        fprintf (FILE, "\n\tnop\n");				\
      }								\
    while (0)
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/sparc/sparc.c.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/sparc/sparc.c	2008-03-25 22:09:19.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 38,43 ****
--- 38,44 ----
  #include "insn-attr.h"
  #include "flags.h"
  #include "function.h"
+ #include "except.h"
  #include "expr.h"
  #include "optabs.h"
  #include "recog.h"
*************** sparc_output_scratch_registers (FILE *fi
*** 3847,3852 ****
--- 3848,4088 ----
  #endif
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ sparc_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+ 
+   if (TARGET_ARCH64)
+     emit_insn (gen_probe_stack_rangedi (GEN_INT (first), GEN_INT (size)));
+   else
+     emit_insn (gen_probe_stack_rangesi (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Build big number NUM in register REG and output the result to FILE.
+    REG is guaranteed to be the only clobbered register.  The function
+    will very likely emit several instructions, so it must not be called
+    from within a delay slot.  */
+ 
+ static void
+ build_big_number (FILE *file, HOST_WIDE_INT num, const char *reg)
+ {
+ #if HOST_BITS_PER_WIDE_INT == 64
+   HOST_WIDE_INT high_bits = (num >> 32) & 0xffffffff;
+ 
+   if (high_bits == 0
+ #else
+   if (num >= 0
+ #endif
+       || TARGET_ARCH32)
+     {
+       /* We don't use the 'set' macro because it appears to be broken
+ 	 in the Solaris 7 assembler.  */
+       fprintf (file, "\tsethi\t%%hi("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 	       num, reg);
+       if ((num & 0x3ff) != 0)
+ 	fprintf (file, "\tor\t%s, %%lo("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 		 reg, num, reg);
+     }
+ #if HOST_BITS_PER_WIDE_INT == 64
+   else if (high_bits == 0xffffffff) /* && TARGET_ARCH64 */
+ #else
+   else /* num < 0 && TARGET_ARCH64 */
+ #endif
+     {
+       /* Sethi does not sign extend, so we must use a little trickery
+ 	 to use it for negative numbers.  Invert the constant before
+ 	 loading it in, then use xor immediate to invert the loaded bits
+ 	 (along with the upper 32 bits) to the desired constant.  This
+ 	 works because the sethi and immediate fields overlap.  */
+       HOST_WIDE_INT inv = ~num;
+       HOST_WIDE_INT low = -0x400 + (num & 0x3ff);
+ 	  
+       fprintf (file, "\tsethi\t%%hi("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 	       inv, reg);
+       fprintf (file, "\txor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 	       reg, low, reg);
+     }
+ #if HOST_BITS_PER_WIDE_INT == 64
+   else /* TARGET_ARCH64 */
+     {
+       /* We don't use the 'setx' macro because if requires a scratch register.
+          This is the translation of sparc_emit_set_const64_longway.  */
+       HOST_WIDE_INT low1 = (num >> (32 - 12))          & 0xfff;
+       HOST_WIDE_INT low2 = (num >> (32 - 12 - 12))     & 0xfff;
+       HOST_WIDE_INT low3 = (num >> (32 - 12 - 12 - 8)) & 0x0ff;
+       int to_shift = 12;
+ 
+       /* We don't use the 'set' macro because it appears to be broken
+ 	 in the Solaris 7 assembler.  */
+       fprintf (file, "\tsethi\t%%hi("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 	       high_bits, reg);
+       if ((high_bits & 0x3ff) != 0)
+ 	fprintf (file, "\tor\t%s, %%lo("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 		 reg, high_bits, reg);
+ 
+       if (low1 != 0)
+ 	{
+ 	  fprintf (file, "\tsllx\t%s, %d, %s\n", reg, to_shift, reg);
+ 	  fprintf (file, "\tor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 		   reg, low1, reg);
+ 	  to_shift = 12;
+ 	}
+       else
+ 	{
+ 	  to_shift += 12;
+ 	}
+       if (low2 != 0)
+ 	{
+ 	  fprintf (file, "\tsllx\t%s, %d, %s\n", reg, to_shift, reg);
+ 	  fprintf (file, "\tor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 		   reg, low2, reg);
+ 	  to_shift = 8;
+ 	}
+       else
+ 	{
+ 	  to_shift += 8;
+ 	}
+       fprintf (file, "\tsllx\t%s, %d, %s\n", reg, to_shift, reg);
+       if (low3 != 0)
+ 	fprintf (file, "\tor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 		 reg, low3, reg);
+     }
+ #endif
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL > 4096
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* The probe offsets are counted negatively whereas the stack bias is
+      counted positively.  */
+   first -= SPARC_STACK_BIAS;
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (size <= PROBE_INTERVAL)
+     {
+       build_big_number (asm_out_file, first, "%g1");
+       fputs ("\tsub\t%sp, %g1, %g1\n", asm_out_file);
+       fprintf (asm_out_file, "\tst\t%%g0, [%%g1-"HOST_WIDE_INT_PRINT_DEC"]\n",
+ 	       size);
+     }
+ 
+   /* The run-time loop is made up of 10 insns in the generic case while this
+      compile-time loop is made up of 4+2*(n-2) insns for n # of intervals.  */
+   else if (size <= 5 * PROBE_INTERVAL)
+     {
+       HOST_WIDE_INT i;
+ 
+       build_big_number (asm_out_file, first + PROBE_INTERVAL, "%g1");
+       fputs ("\tsub\t%sp, %g1, %g1\n", asm_out_file);
+       fputs ("\tst\t%g0, [%g1]\n", asm_out_file);
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
+ 	 it exceeds SIZE.  If only two probes are needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  fprintf (asm_out_file, "\tadd\t%%g1, -%d, %%g1\n", PROBE_INTERVAL);
+ 	  fputs ("\tst\t%g0, [%g1]\n", asm_out_file);
+ 	}
+ 
+       fprintf (asm_out_file, "\tst\t%%g0, [%%g1-"HOST_WIDE_INT_PRINT_DEC"]\n",
+ 	       size - (i - PROBE_INTERVAL));
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       build_big_number (asm_out_file, first, "%g1");
+       fputs ("\tsub\t%sp, %g1, %g1\n", asm_out_file);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       build_big_number (asm_out_file, rounded_size, "%g4");
+       fputs ("\tsub\t%g1, %g4, %g4\n", asm_out_file);
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	 while (TEST_ADDR != LAST_ADDR)
+ 	   {
+ 	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	     probe at TEST_ADDR
+ 	   }
+ 
+ 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+ 	 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fputs ("\tcmp\t%g1, %g4\n", asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       if (TARGET_ARCH64)
+ 	fputs ("\tbe,pn\t%xcc,", asm_out_file);
+       else
+ 	fputs ("\tbe\t", asm_out_file);
+       assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+ 
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\t add\t%%g1, -%d, %%g1\n", PROBE_INTERVAL);
+ 
+       /* Probe at TEST_ADDR and branch.  */
+       if (TARGET_ARCH64)
+ 	fputs ("\tba,pt\t%xcc,", asm_out_file);
+       else
+ 	fputs ("\tba\t", asm_out_file);
+       assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+       fputs ("\t st\t%g0, [%g1]\n", asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tst\t%%g0, [%%g4-"HOST_WIDE_INT_PRINT_DEC"]\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Save/restore call-saved registers from LOW to HIGH at BASE+OFFSET
     as needed.  LOW should be double-word aligned for 32-bit registers.
     Return the new OFFSET.  */
*************** sparc_expand_prologue (void)
*** 4035,4040 ****
--- 4271,4279 ----
    /* Advertise that the data calculated just above are now valid.  */
    sparc_prologue_data_valid_p = true;
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
+     sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);
+ 
    if (sparc_leaf_function_p)
      {
        frame_base_reg = stack_pointer_rtx;
*** gcc/config/sparc/sparc-protos.h.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/sparc/sparc-protos.h	2008-03-25 15:53:27.000000000 +0100
*************** extern const char *output_return (rtx);
*** 85,90 ****
--- 85,91 ----
  extern const char *output_sibcall (rtx, rtx);
  extern const char *output_v8plus_shift (rtx *, rtx, const char *);
  extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);
+ extern const char *output_probe_stack_range (rtx, rtx);
  extern void emit_v9_brxx_insn (enum rtx_code, rtx, rtx);
  extern void print_operand (FILE *, rtx, int);
  extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);
*** gcc/config/sparc/sparc.md.0	2008-03-25 15:47:50.000000000 +0100
--- gcc/config/sparc/sparc.md	2008-03-25 16:35:57.000000000 +0100
***************
*** 72,77 ****
--- 72,78 ----
     (UNSPECV_CAS			8)
     (UNSPECV_SWAP		9)
     (UNSPECV_LDSTUB		10)
+    (UNSPECV_STACK_PROBE_INLINE	11)
    ])
  
  ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this
***************
*** 7028,7033 ****
--- 7029,7044 ----
  
  ;; Special instructions.
  
+ (define_insn "probe_stack_range<P:mode>"
+   [(unspec_volatile:SI [(match_operand:P 0 "const_int_operand" "")
+ 			(match_operand:P 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:P 1))
+    (clobber (reg:P 4))]
+   ""
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "prologue"
    [(const_int 0)]
    ""
*** gcc/gcc.c.0	2008-03-27 09:02:48.572959528 +0100
--- gcc/gcc.c	2008-03-27 09:02:56.167804936 +0100
*************** process_command (int argc, const char **
*** 3627,3634 ****
  		  version_string);
  	  printf ("Copyright %s 2008 Free Software Foundation, Inc.\n",
  		  _("(C)"));
! 	  fputs (_("This is free software; see the source for copying conditions.  There is NO\n\
! warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"),
  		 stdout);
  	  exit (0);
  	}
--- 3627,3637 ----
  		  version_string);
  	  printf ("Copyright %s 2008 Free Software Foundation, Inc.\n",
  		  _("(C)"));
! 	  fputs (_("This is free software; see the source for copying conditions.\n\
! See your AdaCore support agreement for details of warranty and support.\n\
! If you do not have a current support agreement, then there is absolutely\n\
! no warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR\n\
! PURPOSE.\n\n"),
  		 stdout);
  	  exit (0);
  	}
*** gcc/fold-const.c.0	2008-03-29 13:40:38.000000000 +0100
--- gcc/fold-const.c	2008-03-29 16:19:01.180819584 +0100
*************** fold (tree expr)
*** 13494,13499 ****
--- 13494,13538 ----
  
    switch (code)
      {
+     case ARRAY_REF:
+       {
+ 	tree op0 = TREE_OPERAND (t, 0);
+ 	tree op1 = TREE_OPERAND (t, 1);
+ 
+ 	if (TREE_CODE (op1) == INTEGER_CST
+ 	    && TREE_CODE (op0) == CONSTRUCTOR
+ 	    && ! type_contains_placeholder_p (TREE_TYPE (op0)))
+ 	  {
+ 	    VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (op0);
+ 	    unsigned HOST_WIDE_INT end = VEC_length (constructor_elt, elts);
+ 	    unsigned HOST_WIDE_INT begin = 0;
+ 
+ 	    /* Find a matching index by means of a binary search.  */
+ 	    while (begin != end)
+ 	      {
+ 		unsigned HOST_WIDE_INT middle = (begin + end) / 2;
+ 		tree index = VEC_index (constructor_elt, elts, middle)->index;
+ 
+ 		if (TREE_CODE (index) == INTEGER_CST
+ 		    && tree_int_cst_lt (index, op1))
+ 		  begin = middle + 1;
+ 		else if (TREE_CODE (index) == INTEGER_CST
+ 			 && tree_int_cst_lt (op1, index))
+ 		  end = middle;
+ 		else if (TREE_CODE (index) == RANGE_EXPR
+ 			 && tree_int_cst_lt (TREE_OPERAND (index, 1), op1))
+ 		  begin = middle + 1;
+ 		else if (TREE_CODE (index) == RANGE_EXPR
+ 			 && tree_int_cst_lt (op1, TREE_OPERAND (index, 0)))
+ 		  end = middle;
+ 		else
+ 		  return VEC_index (constructor_elt, elts, middle)->value;
+ 	      }
+ 	  }
+ 
+ 	return t;
+       }
+ 
      case CONST_DECL:
        return fold (DECL_INITIAL (t));
  
*** gcc/Makefile.in.ori	Tue Apr  1 16:23:17 2008
--- gcc/Makefile.in	Tue Apr  1 16:36:03 2008
*************** LIBGCC2_INCLUDES =
*** 592,600 ****
  TARGET_LIBGCC2_CFLAGS =
  
  # Options to use when compiling crtbegin/end.
  CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
    -finhibit-size-directive -fno-inline-functions -fno-exceptions \
!   -fno-zero-initialized-in-bss -fno-toplevel-reorder -fno-tree-vectorize \
    $(INHIBIT_LIBC_CFLAGS)
  
  # Additional sources to handle exceptions; overridden by targets as needed.
--- 592,608 ----
  TARGET_LIBGCC2_CFLAGS =
  
  # Options to use when compiling crtbegin/end.
+ 
+ # -fno-toplevel-reorder is currently required for targets manually
+ # emitting switch to .ctors with an "asm (CTORS_SECTION_ASM_OP)" call.
+ # It only operates with -funit-at-a-time, added explicitly despite the
+ # head -O2 because the latter might be turned off from one of the options
+ # variable sets.
+ 
  CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
    -finhibit-size-directive -fno-inline-functions -fno-exceptions \
!   -fno-zero-initialized-in-bss -fno-tree-vectorize \
!   -funit-at-a-time -fno-toplevel-reorder \
    $(INHIBIT_LIBC_CFLAGS)
  
  # Additional sources to handle exceptions; overridden by targets as needed.
*** gcc/tree-ssa-structalias.c.0	2008-04-09 18:48:39.307445584 +0200
--- gcc/tree-ssa-structalias.c	2008-04-09 18:48:48.211092024 +0200
*************** get_constraint_for_component_ref (tree t
*** 2795,2805 ****
  
    t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);
  
-   /* String constants are readonly, so there is nothing to really do
-      here.  */
-   if (TREE_CODE (t) == STRING_CST)
-     return;
- 
    get_constraint_for (t, results);
    result = VEC_last (ce_s, *results);
    result->offset = bitpos;
--- 2795,2800 ----
*************** get_constraint_for (tree t, VEC (ce_s, h
*** 2921,2926 ****
--- 2916,2931 ----
        return;
      }
  
+   /* String constants are read-only.  */
+   if (TREE_CODE (t) == STRING_CST)
+     {
+       temp.var = readonly_id;
+       temp.type = SCALAR;
+       temp.offset = 0;
+       VEC_safe_push (ce_s, heap, *results, &temp);
+       return;
+     }
+ 
    switch (TREE_CODE_CLASS (TREE_CODE (t)))
      {
      case tcc_expression:
*** gcc/gimplify.c.0	2008-04-18 00:00:09.934578672 +0200
--- gcc/gimplify.c	2008-04-18 00:00:39.781041320 +0200
*************** gimplify_modify_expr_rhs (tree *expr_p, 
*** 3655,3661 ****
  	    tree result = *to_p;
  
  	    ret = gimplify_expr (&result, pre_p, post_p,
! 				 is_gimple_min_lval, fb_lvalue);
  	    if (ret != GS_ERROR)
  	      ret = GS_OK;
  
--- 3655,3661 ----
  	    tree result = *to_p;
  
  	    ret = gimplify_expr (&result, pre_p, post_p,
! 				 is_gimple_lvalue, fb_lvalue);
  	    if (ret != GS_ERROR)
  	      ret = GS_OK;
  
*** gcc/config/avr/libgcc.S.old	(revision 132554)
--- gcc/config/avr/libgcc.S	(revision 132555)
***************
*** 32,37 ****
--- 32,38 ----
  #define __SREG__ 0x3f
  #define __SP_H__ 0x3e
  #define __SP_L__ 0x3d
+ #define __RAMPZ__ 0x3B
  
  /* Most of the functions here are called directly from avr.md
     patterns, instead of using the standard libcall mechanisms.
***************
*** 686,705 ****
  	.endfunc
  #endif /* defined (L_tablejump) */
  
- /* __do_copy_data is only necessary if there is anything in .data section.
-    Does not use RAMPZ - crt*.o provides a replacement for >64K devices.  */
- 
  #ifdef L_copy_data
  	.section .init4,"ax",@progbits
  	.global __do_copy_data
  __do_copy_data:
  	ldi	r17, hi8(__data_end)
  	ldi	r26, lo8(__data_start)
  	ldi	r27, hi8(__data_start)
  	ldi	r30, lo8(__data_load_start)
  	ldi	r31, hi8(__data_load_start)
! 	rjmp	.do_copy_data_start
! .do_copy_data_loop:
  #if defined (__AVR_HAVE_LPMX__)
  	lpm	r0, Z+
  #else
--- 687,740 ----
  	.endfunc
  #endif /* defined (L_tablejump) */
  
  #ifdef L_copy_data
  	.section .init4,"ax",@progbits
  	.global __do_copy_data
  __do_copy_data:
+ #if defined(__AVR_HAVE_ELPMX__)
+ 	ldi	r17, hi8(__data_end)
+ 	ldi	r26, lo8(__data_start)
+ 	ldi	r27, hi8(__data_start)
+ 	ldi	r30, lo8(__data_load_start)
+ 	ldi	r31, hi8(__data_load_start)
+ 	ldi	r16, hh8(__data_load_start)
+ 	out	__RAMPZ__, r16
+ 	rjmp	.L__do_copy_data_start
+ .L__do_copy_data_loop:
+ 	elpm	r0, Z+
+ 	st	X+, r0
+ .L__do_copy_data_start:
+ 	cpi	r26, lo8(__data_end)
+ 	cpc	r27, r17
+ 	brne	.L__do_copy_data_loop
+ #elif  !defined(__AVR_HAVE_ELPMX__) && defined(__AVR_HAVE_ELPM__)
+ 	ldi	r17, hi8(__data_end)
+ 	ldi	r26, lo8(__data_start)
+ 	ldi	r27, hi8(__data_start)
+ 	ldi	r30, lo8(__data_load_start)
+ 	ldi	r31, hi8(__data_load_start)
+ 	ldi	r16, hh8(__data_load_start - 0x10000)
+ .L__do_copy_data_carry:
+ 	inc	r16
+ 	out	__RAMPZ__, r16
+ 	rjmp	.L__do_copy_data_start
+ .L__do_copy_data_loop:
+ 	elpm
+ 	st	X+, r0
+ 	adiw	r30, 1
+ 	brcs	.L__do_copy_data_carry
+ .L__do_copy_data_start:
+ 	cpi	r26, lo8(__data_end)
+ 	cpc	r27, r17
+ 	brne	.L__do_copy_data_loop
+ #elif !defined(__AVR_HAVE_ELPMX__) && !defined(__AVR_HAVE_ELPM__)
  	ldi	r17, hi8(__data_end)
  	ldi	r26, lo8(__data_start)
  	ldi	r27, hi8(__data_start)
  	ldi	r30, lo8(__data_load_start)
  	ldi	r31, hi8(__data_load_start)
! 	rjmp	.L__do_copy_data_start
! .L__do_copy_data_loop:
  #if defined (__AVR_HAVE_LPMX__)
  	lpm	r0, Z+
  #else
***************
*** 707,716 ****
  	adiw	r30, 1
  #endif
  	st	X+, r0
! .do_copy_data_start:
  	cpi	r26, lo8(__data_end)
  	cpc	r27, r17
! 	brne	.do_copy_data_loop
  #endif /* L_copy_data */
  
  /* __do_clear_bss is only necessary if there is anything in .bss section.  */
--- 742,752 ----
  	adiw	r30, 1
  #endif
  	st	X+, r0
! .L__do_copy_data_start:
  	cpi	r26, lo8(__data_end)
  	cpc	r27, r17
! 	brne	.L__do_copy_data_loop
! #endif /* !defined(__AVR_HAVE_ELPMX__) && !defined(__AVR_HAVE_ELPM__) */
  #endif /* L_copy_data */
  
  /* __do_clear_bss is only necessary if there is anything in .bss section.  */
*** gcc/config/avr/libgcc.S.old	(revision 133247)
--- gcc/config/avr/libgcc.S	(revision 133248)
***************
*** 595,601 ****
--- 595,606 ----
  	out	__SP_H__,r29
  	out	__SREG__,__tmp_reg__
  	out	__SP_L__,r28
+ #if defined (__AVR_HAVE_EIJMP_EICALL__)
+ 	eijmp
+ #else
  	ijmp
+ #endif
+ 
  .endfunc
  #endif /* defined (L_prologue) */
  
***************
*** 675,687 ****
--- 680,701 ----
  	lpm	__tmp_reg__, Z+
  	lpm	r31, Z
  	mov	r30, __tmp_reg__
+ 
+ #if defined (__AVR_HAVE_EIJMP_EICALL__)
+ 	eijmp
+ #else
  	ijmp
+ #endif
+ 
  #else
  	lpm
  	adiw	r30, 1
  	push	r0
  	lpm
  	push	r0
+ #if defined (__AVR_HAVE_EIJMP_EICALL__)
+         push    __zero_reg__
+ #endif
  	ret
  #endif
  	.endfunc
*** gcc/config/avr/avr.md.old	(revision 133247)
--- gcc/config/avr/avr.md	(revision 133248)
***************
*** 32,37 ****
--- 32,38 ----
  ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)
  ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)
  ;;  ~  Output 'r' if not AVR_MEGA.
+ ;;  !  Output 'e' if AVR_HAVE_EIJMP_EICALL.
  
  ;; UNSPEC usage:
  ;;  0  Length of a string, see "strlenhi".
***************
*** 2290,2311 ****
    "(register_operand (operands[0], HImode) || CONSTANT_P (operands[0]))"
    "*{
    if (which_alternative==0)
!      return \"icall\";
    else if (which_alternative==1)
      {
        if (AVR_HAVE_MOVW)
  	return (AS2 (movw, r30, %0) CR_TAB
! 		\"icall\");
        else
  	return (AS2 (mov, r30, %A0) CR_TAB
  		AS2 (mov, r31, %B0) CR_TAB
! 		\"icall\");
      }
    else if (which_alternative==2)
      return AS1(%~call,%c0);
    return (AS2 (ldi,r30,lo8(%0)) CR_TAB
            AS2 (ldi,r31,hi8(%0)) CR_TAB
!           \"icall\");
  }"
    [(set_attr "cc" "clobber,clobber,clobber,clobber")
     (set_attr_alternative "length"
--- 2291,2312 ----
    "(register_operand (operands[0], HImode) || CONSTANT_P (operands[0]))"
    "*{
    if (which_alternative==0)
!      return \"%!icall\";
    else if (which_alternative==1)
      {
        if (AVR_HAVE_MOVW)
  	return (AS2 (movw, r30, %0) CR_TAB
!                \"%!icall\");
        else
  	return (AS2 (mov, r30, %A0) CR_TAB
  		AS2 (mov, r31, %B0) CR_TAB
! 		\"%!icall\");
      }
    else if (which_alternative==2)
      return AS1(%~call,%c0);
    return (AS2 (ldi,r30,lo8(%0)) CR_TAB
            AS2 (ldi,r31,hi8(%0)) CR_TAB
!           \"%!icall\");
  }"
    [(set_attr "cc" "clobber,clobber,clobber,clobber")
     (set_attr_alternative "length"
***************
*** 2327,2348 ****
    "(register_operand (operands[0], VOIDmode) || CONSTANT_P (operands[0]))"
    "*{
    if (which_alternative==0)
!      return \"icall\";
    else if (which_alternative==1)
      {
        if (AVR_HAVE_MOVW)
  	return (AS2 (movw, r30, %1) CR_TAB
! 		\"icall\");
        else
  	return (AS2 (mov, r30, %A1) CR_TAB
  		AS2 (mov, r31, %B1) CR_TAB
! 		\"icall\");
      }
    else if (which_alternative==2)
      return AS1(%~call,%c1);
    return (AS2 (ldi, r30, lo8(%1)) CR_TAB
            AS2 (ldi, r31, hi8(%1)) CR_TAB
!           \"icall\");
  }"
    [(set_attr "cc" "clobber,clobber,clobber,clobber")
     (set_attr_alternative "length"
--- 2328,2349 ----
    "(register_operand (operands[0], VOIDmode) || CONSTANT_P (operands[0]))"
    "*{
    if (which_alternative==0)
!      return \"%!icall\";
    else if (which_alternative==1)
      {
        if (AVR_HAVE_MOVW)
  	return (AS2 (movw, r30, %1) CR_TAB
! 		\"%!icall\");
        else
  	return (AS2 (mov, r30, %A1) CR_TAB
  		AS2 (mov, r31, %B1) CR_TAB
! 		\"%!icall\");
      }
    else if (which_alternative==2)
      return AS1(%~call,%c1);
    return (AS2 (ldi, r30, lo8(%1)) CR_TAB
            AS2 (ldi, r31, hi8(%1)) CR_TAB
!           \"%!icall\");
  }"
    [(set_attr "cc" "clobber,clobber,clobber,clobber")
     (set_attr_alternative "length"
***************
*** 2365,2377 ****
  ; indirect jump
  (define_insn "indirect_jump"
    [(set (pc) (match_operand:HI 0 "register_operand" "!z,*r"))]
!   ""
    "@
  	ijmp
  	push %A0\;push %B0\;ret"
    [(set_attr "length" "1,3")
     (set_attr "cc" "none,none")])
  
  ;; table jump
  
  ;; Table made from "rjmp" instructions for <=8K devices.
--- 2366,2385 ----
  ; indirect jump
  (define_insn "indirect_jump"
    [(set (pc) (match_operand:HI 0 "register_operand" "!z,*r"))]
!   "!AVR_HAVE_EIJMP_EICALL"
    "@
  	ijmp
  	push %A0\;push %B0\;ret"
    [(set_attr "length" "1,3")
     (set_attr "cc" "none,none")])
  
+ (define_insn "*indirect_jump_avr6"
+   [(set (pc) (match_operand:HI 0 "register_operand" "z"))]
+   "AVR_HAVE_EIJMP_EICALL"
+   "eijmp"
+   [(set_attr "length" "1")
+    (set_attr "cc" "none")])
+ 
  ;; table jump
  
  ;; Table made from "rjmp" instructions for <=8K devices.
***************
*** 2380,2386 ****
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "!AVR_MEGA"
    "@
  	ijmp
  	push %A0\;push %B0\;ret"
--- 2400,2406 ----
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "(!AVR_HAVE_JMP_CALL) && (!AVR_HAVE_EIJMP_EICALL)"
    "@
  	ijmp
  	push %A0\;push %B0\;ret"
***************
*** 2409,2415 ****
  	lpm __tmp_reg__,Z+
  	lpm r31,Z
  	mov r30,__tmp_reg__
! 	ijmp"
    [(set_attr "length" "6")
     (set_attr "cc" "clobber")])
  
--- 2417,2423 ----
  	lpm __tmp_reg__,Z+
  	lpm r31,Z
  	mov r30,__tmp_reg__
! 	%!ijmp"
    [(set_attr "length" "6")
     (set_attr "cc" "clobber")])
  
***************
*** 2418,2424 ****
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "AVR_MEGA"
    "lsl r30
  	rol r31
  	lpm
--- 2426,2432 ----
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "AVR_HAVE_JMP_CALL && !AVR_HAVE_EIJMP_EICALL"
    "lsl r30
  	rol r31
  	lpm
*** gcc/config/avr/avr.c.old	(revision 133247)
--- gcc/config/avr/avr.c	(revision 133248)
***************
*** 127,133 ****
    { 0, 0, 1, 1, 0, 0, 0, 0, "__AVR_ARCH__=35"  },
    { 0, 1, 0, 1, 0, 0, 0, 0, "__AVR_ARCH__=4"   },
    { 0, 1, 1, 1, 0, 0, 0, 0, "__AVR_ARCH__=5"   },
!   { 0, 1, 1, 1, 1, 1, 0, 0, "__AVR_ARCH__=51"  }
  };
  
  /* These names are used as the index into the avr_arch_types[] table 
--- 127,134 ----
    { 0, 0, 1, 1, 0, 0, 0, 0, "__AVR_ARCH__=35"  },
    { 0, 1, 0, 1, 0, 0, 0, 0, "__AVR_ARCH__=4"   },
    { 0, 1, 1, 1, 0, 0, 0, 0, "__AVR_ARCH__=5"   },
!   { 0, 1, 1, 1, 1, 1, 0, 0, "__AVR_ARCH__=51"  },
!   { 0, 1, 1, 1, 1, 1, 1, 0, "__AVR_ARCH__=6"   }
  };
  
  /* These names are used as the index into the avr_arch_types[] table 
***************
*** 144,150 ****
    ARCH_AVR35,
    ARCH_AVR4,
    ARCH_AVR5,
!   ARCH_AVR51
  };
  
  struct mcu_type_s {
--- 145,152 ----
    ARCH_AVR35,
    ARCH_AVR4,
    ARCH_AVR5,
!   ARCH_AVR51,
!   ARCH_AVR6
  };
  
  struct mcu_type_s {
***************
*** 273,278 ****
--- 275,284 ----
    { "at90can128",   ARCH_AVR51, "__AVR_AT90CAN128__" },
    { "at90usb1286",  ARCH_AVR51, "__AVR_AT90USB1286__" },
    { "at90usb1287",  ARCH_AVR51, "__AVR_AT90USB1287__" },
+     /* 3-Byte PC.  */
+   { "avr6",         ARCH_AVR6, NULL },
+   { "atmega2560",   ARCH_AVR6, "__AVR_ATmega2560__" },
+   { "atmega2561",   ARCH_AVR6, "__AVR_ATmega2561__" },
      /* Assembler only.  */
    { "avr1",         ARCH_AVR1, NULL },
    { "at90s1200",    ARCH_AVR1, "__AVR_AT90S1200__" },
***************
*** 513,521 ****
    else
      {
        int offset = frame_pointer_needed ? 2 : 0;
  
        offset += avr_regs_to_save (NULL);
!       return get_frame_size () + 2 + 1 + offset;
      }
  }
  
--- 519,528 ----
    else
      {
        int offset = frame_pointer_needed ? 2 : 0;
+       int avr_pc_size = AVR_HAVE_EIJMP_EICALL ? 3 : 2;
  
        offset += avr_regs_to_save (NULL);
!       return get_frame_size () + (avr_pc_size) + 1 + offset;
      }
  }
  
***************
*** 1121,1127 ****
  	  && ((GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (addr))
  	      || GET_CODE (addr) == LABEL_REF))
  	{
! 	  fprintf (file, "pm(");
  	  output_addr_const (file,addr);
  	  fprintf (file ,")");
  	}
--- 1128,1134 ----
  	  && ((GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (addr))
  	      || GET_CODE (addr) == LABEL_REF))
  	{
! 	  fprintf (file, "gs(");
  	  output_addr_const (file,addr);
  	  fprintf (file ,")");
  	}
***************
*** 1146,1151 ****
--- 1153,1163 ----
        if (!AVR_MEGA)
  	fputc ('r', file);
      }
+   else if (code == '!')
+     {
+       if (AVR_HAVE_EIJMP_EICALL)
+ 	fputc ('e', file);
+     }
    else if (REG_P (x))
      {
        if (x == zero_reg_rtx)
***************
*** 4470,4476 ****
        && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))
  	  || GET_CODE (x) == LABEL_REF))
      {
!       fputs ("\t.word\tpm(", asm_out_file);
        output_addr_const (asm_out_file, x);
        fputs (")\n", asm_out_file);
        return true;
--- 4482,4488 ----
        && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))
  	  || GET_CODE (x) == LABEL_REF))
      {
!       fputs ("\t.word\tgs(", asm_out_file);
        output_addr_const (asm_out_file, x);
        fputs (")\n", asm_out_file);
        return true;
***************
*** 5816,5823 ****
  avr_output_addr_vec_elt (FILE *stream, int value)
  {
    switch_to_section (progmem_section);
!   if (AVR_MEGA)
!     fprintf (stream, "\t.word pm(.L%d)\n", value);
    else
      fprintf (stream, "\trjmp .L%d\n", value);
  }
--- 5828,5835 ----
  avr_output_addr_vec_elt (FILE *stream, int value)
  {
    switch_to_section (progmem_section);
!   if (AVR_HAVE_JMP_CALL)
!     fprintf (stream, "\t.word gs(.L%d)\n", value);
    else
      fprintf (stream, "\trjmp .L%d\n", value);
  }
*** gcc/config/avr/t-avr.old	(revision 133247)
--- gcc/config/avr/t-avr	(revision 133248)
***************
*** 37,44 ****
  
  FPBIT = fp-bit.c
  
! MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51
! MULTILIB_DIRNAMES = avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51
  
  # The many avr2 matches are not listed here - this is the default.
  MULTILIB_MATCHES = \
--- 37,44 ----
  
  FPBIT = fp-bit.c
  
! MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6
! MULTILIB_DIRNAMES = avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6
  
  # The many avr2 matches are not listed here - this is the default.
  MULTILIB_MATCHES = \
***************
*** 123,129 ****
  	mmcu?avr51=mmcu?atmega1284p \
  	mmcu?avr51=mmcu?at90can128 \
  	mmcu?avr51=mmcu?at90usb1286 \
! 	mmcu?avr51=mmcu?at90usb1287
  
  MULTILIB_EXCEPTIONS =
  
--- 123,131 ----
  	mmcu?avr51=mmcu?atmega1284p \
  	mmcu?avr51=mmcu?at90can128 \
  	mmcu?avr51=mmcu?at90usb1286 \
! 	mmcu?avr51=mmcu?at90usb1287 \
!  	mmcu?avr6=mmcu?atmega2560 \
!  	mmcu?avr6=mmcu?atmega2561
  
  MULTILIB_EXCEPTIONS =
  
*** gcc/config/avr/avr.h.old	(revision 133247)
--- gcc/config/avr/avr.h	(revision 133248)
***************
*** 80,85 ****
--- 80,94 ----
  	builtin_define ("__AVR_MEGA__");	\
        if (avr_current_arch->have_jmp_call)	\
  	builtin_define ("__AVR_HAVE_JMP_CALL__"); \
+       if (avr_current_arch->have_eijmp_eicall)	\
+         {					\
+ 	  builtin_define ("__AVR_HAVE_JMP_CALL__");	\
+ 	  builtin_define ("__AVR_3_BYTE_PC__");	\
+ 	}					\
+       else					\
+         {					\
+ 	  builtin_define ("__AVR_2_BYTE_PC__");	\
+ 	}					\
        if (TARGET_NO_INTERRUPTS)			\
  	builtin_define ("__NO_INTERRUPTS__");	\
      }						\
***************
*** 96,108 ****
  #endif
  
  #define AVR_MEGA (avr_mega_p && !TARGET_SHORT_CALLS)
  #define AVR_HAVE_MUL (avr_have_mul_p)
  #define AVR_HAVE_MOVW (avr_have_movw_lpmx_p)
  #define AVR_HAVE_LPMX (avr_have_movw_lpmx_p)
  #define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm)
  
! #define AVR_2_BYTE_PC 1
! #define AVR_3_BYTE_PC 0
  
  #define TARGET_VERSION fprintf (stderr, " (GNU assembler syntax)");
  
--- 105,119 ----
  #endif
  
  #define AVR_MEGA (avr_mega_p && !TARGET_SHORT_CALLS)
+ #define AVR_HAVE_JMP_CALL (avr_current_arch->have_jmp_call && !TARGET_SHORT_CALLS)
  #define AVR_HAVE_MUL (avr_have_mul_p)
  #define AVR_HAVE_MOVW (avr_have_movw_lpmx_p)
  #define AVR_HAVE_LPMX (avr_have_movw_lpmx_p)
  #define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm)
+ #define AVR_HAVE_EIJMP_EICALL (avr_current_arch->have_eijmp_eicall)
  
! #define AVR_2_BYTE_PC (!AVR_HAVE_EIJMP_EICALL)
! #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)
  
  #define TARGET_VERSION fprintf (stderr, " (GNU assembler syntax)");
  
***************
*** 681,687 ****
  
  #define PRINT_OPERAND(STREAM, X, CODE) print_operand (STREAM, X, CODE)
  
! #define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '~')
  
  #define PRINT_OPERAND_ADDRESS(STREAM, X) print_operand_address(STREAM, X)
  
--- 692,698 ----
  
  #define PRINT_OPERAND(STREAM, X, CODE) print_operand (STREAM, X, CODE)
  
! #define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '~' || (CODE) == '!')
  
  #define PRINT_OPERAND_ADDRESS(STREAM, X) print_operand_address(STREAM, X)
  
***************
*** 838,843 ****
--- 849,855 ----
    mmcu=at90usb64*|\
    mmcu=at90usb128*|\
    mmcu=at94k: -m avr5}\
+ %{mmcu=atmega256*:-m avr6}\
  %{mmcu=atmega324*|\
    mmcu=atmega325*|\
    mmcu=atmega328p|\
***************
*** 866,872 ****
    mmcu=at90usb*: -Tdata 0x800100}\
  %{mmcu=atmega640|\
    mmcu=atmega1280|\
!   mmcu=atmega1281: -Tdata 0x800200} "
  
  #define LIB_SPEC \
    "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
--- 878,885 ----
    mmcu=at90usb*: -Tdata 0x800100}\
  %{mmcu=atmega640|\
    mmcu=atmega1280|\
!   mmcu=atmega1281|\
!   mmcu=atmega256*: -Tdata 0x800200} "
  
  #define LIB_SPEC \
    "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
***************
*** 978,983 ****
--- 991,998 ----
  %{mmcu=atmega1280:crtm1280.o%s} \
  %{mmcu=atmega1281:crtm1281.o%s} \
  %{mmcu=atmega1284p:crtm1284p.o%s} \
+ %{mmcu=atmega2560:crtm2560.o%s} \
+ %{mmcu=atmega2561:crtm2561.o%s} \
  %{mmcu=at90can128:crtcan128.o%s} \
  %{mmcu=at90usb1286:crtusb1286.o%s} \
  %{mmcu=at90usb1287:crtusb1287.o%s}"
*** gcc/config/avr/avr-protos.h.old	(revision 133845)
--- gcc/config/avr/avr-protos.h	(revision 133846)
***************
*** 1,6 ****
  /* Prototypes for exported functions defined in avr.c
     
!    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2006, 2007
     Free Software Foundation, Inc.
     Contributed by Denis Chertykov (denisc@overta.ru)
  
--- 1,6 ----
  /* Prototypes for exported functions defined in avr.c
     
!    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008
     Free Software Foundation, Inc.
     Contributed by Denis Chertykov (denisc@overta.ru)
  
***************
*** 123,129 ****
  extern int compare_eq_p (rtx insn);
  extern void out_shift_with_cnt (const char *template, rtx insn,
  				rtx operands[], int *len, int t_len);
- extern int avr_io_address_p (rtx x, int size);
  extern int avr_peep2_scratch_safe (rtx reg_rtx);
  #endif /* RTX_CODE */
  
--- 123,128 ----
*** gcc/config/avr/predicates.md.old	(revision 133845)
--- gcc/config/avr/predicates.md	(revision 133846)
***************
*** 1,5 ****
  ;; Predicate definitions for ATMEL AVR micro controllers.
! ;; Copyright (C) 2006, 2007 Free Software Foundation, Inc.
  ;;
  ;; This file is part of GCC.
  ;;
--- 1,5 ----
  ;; Predicate definitions for ATMEL AVR micro controllers.
! ;; Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
  ;;
  ;; This file is part of GCC.
  ;;
***************
*** 52,57 ****
--- 52,62 ----
    (and (match_code "const_int")
         (match_test "IN_RANGE((INTVAL (op)), 0x40, 0x5F)")))
  
+ ;; Return true if OP is a valid address of I/O space.
+ (define_predicate "io_address_operand"
+   (and (match_code "const_int")
+        (match_test "IN_RANGE((INTVAL (op)), 0x20, (0x60 - GET_MODE_SIZE(mode)))")))
+ 
  ;; Return 1 if OP is the zero constant for MODE.
  (define_predicate "const0_operand"
    (and (match_code "const_int,const_double")
*** gcc/config/avr/avr.c.old	(revision 133845)
--- gcc/config/avr/avr.c	(revision 133846)
***************
*** 1848,1854 ****
  	  *l = 1;
  	  return AS2 (in,%0,__SREG__);
  	}
!       if (avr_io_address_p (x, 1))
  	{
  	  *l = 1;
  	  return AS2 (in,%0,%1-0x20);
--- 1848,1854 ----
  	  *l = 1;
  	  return AS2 (in,%0,__SREG__);
  	}
!       if (optimize > 0 && io_address_operand (x, QImode))
  	{
  	  *l = 1;
  	  return AS2 (in,%0,%1-0x20);
***************
*** 2036,2042 ****
      }
    else if (CONSTANT_ADDRESS_P (base))
      {
!       if (avr_io_address_p (base, 2))
  	{
  	  *l = 2;
  	  return (AS2 (in,%A0,%A1-0x20) CR_TAB
--- 2036,2042 ----
      }
    else if (CONSTANT_ADDRESS_P (base))
      {
!       if (optimize > 0 && io_address_operand (base, HImode))
  	{
  	  *l = 2;
  	  return (AS2 (in,%A0,%A1-0x20) CR_TAB
***************
*** 2536,2542 ****
  	  *l = 1;
  	  return AS2 (out,__SREG__,%1);
  	}
!       if (avr_io_address_p (x, 1))
  	{
  	  *l = 1;
  	  return AS2 (out,%0-0x20,%1);
--- 2536,2542 ----
  	  *l = 1;
  	  return AS2 (out,__SREG__,%1);
  	}
!       if (optimize > 0 && io_address_operand (x, QImode))
  	{
  	  *l = 1;
  	  return AS2 (out,%0-0x20,%1);
***************
*** 2615,2621 ****
      l = &tmp;
    if (CONSTANT_ADDRESS_P (base))
      {
!       if (avr_io_address_p (base, 2))
  	{
  	  *l = 2;
  	  return (AS2 (out,%B0-0x20,%B1) CR_TAB
--- 2615,2621 ----
      l = &tmp;
    if (CONSTANT_ADDRESS_P (base))
      {
!       if (optimize > 0 && io_address_operand (base, HImode))
  	{
  	  *l = 2;
  	  return (AS2 (out,%B0-0x20,%B1) CR_TAB
***************
*** 5467,5473 ****
      return 18;
    if (CONSTANT_ADDRESS_P (x))
      {
!       if (avr_io_address_p (x, 1))
  	return 2;
        return 4;
      }
--- 5467,5473 ----
      return 18;
    if (CONSTANT_ADDRESS_P (x))
      {
!       if (optimize > 0 && io_address_operand (x, QImode))
  	return 2;
        return 4;
      }
***************
*** 5713,5729 ****
    return !(regno & 1);
  }
  
- /* Returns 1 if X is a valid address for an I/O register of size SIZE
-    (1 or 2).  Used for lds/sts -> in/out optimization.  Add 0x20 to SIZE
-    to check for the lower half of I/O space (for cbi/sbi/sbic/sbis).  */
- 
- int
- avr_io_address_p (rtx x, int size)
- {
-   return (optimize > 0 && GET_CODE (x) == CONST_INT
- 	  && INTVAL (x) >= 0x20 && INTVAL (x) <= 0x60 - size);
- }
- 
  const char *
  output_reload_inhi (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)
  {
--- 5713,5718 ----
*** gcc/config/avr/libgcc.S.old	(revision 133965)
--- gcc/config/avr/libgcc.S	(revision 133966)
***************
*** 784,790 ****
  /* __do_global_ctors and __do_global_dtors are only necessary
     if there are any constructors/destructors.  */
  
! #if defined (__AVR_MEGA__)
  #define XCALL call
  #else
  #define XCALL rcall
--- 784,790 ----
  /* __do_global_ctors and __do_global_dtors are only necessary
     if there are any constructors/destructors.  */
  
! #if defined (__AVR_HAVE_JMP_CALL__)
  #define XCALL call
  #else
  #define XCALL rcall
*** gcc/config/avr/avr.md.old	(revision 133965)
--- gcc/config/avr/avr.md	(revision 133966)
***************
*** 31,37 ****
  ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.
  ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)
  ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)
! ;;  ~  Output 'r' if not AVR_MEGA.
  ;;  !  Output 'e' if AVR_HAVE_EIJMP_EICALL.
  
  ;; UNSPEC usage:
--- 31,37 ----
  ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.
  ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)
  ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)
! ;;  ~  Output 'r' if not AVR_HAVE_JMP_CALL.
  ;;  !  Output 'e' if AVR_HAVE_EIJMP_EICALL.
  
  ;; UNSPEC usage:
***************
*** 74,80 ****
  		       (const_string "no"))))
  
  (define_attr "mcu_mega" "yes,no"
!   (const (if_then_else (symbol_ref "AVR_MEGA")
  		       (const_string "yes")
  		       (const_string "no"))))
    
--- 74,80 ----
  		       (const_string "no"))))
  
  (define_attr "mcu_mega" "yes,no"
!   (const (if_then_else (symbol_ref "AVR_HAVE_JMP_CALL")
  		       (const_string "yes")
  		       (const_string "no"))))
    
***************
*** 2249,2255 ****
          (label_ref (match_operand 0 "" "")))]
    ""
    "*{
!   if (AVR_MEGA && get_attr_length (insn) != 1)
      return AS1 (jmp,%0);
    return AS1 (rjmp,%0);
  }"
--- 2249,2255 ----
          (label_ref (match_operand 0 "" "")))]
    ""
    "*{
!   if (AVR_HAVE_JMP_CALL && get_attr_length (insn) != 1)
      return AS1 (jmp,%0);
    return AS1 (rjmp,%0);
  }"
***************
*** 2401,2407 ****
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "AVR_MEGA && TARGET_CALL_PROLOGUES"
    "jmp __tablejump2__"
    [(set_attr "length" "2")
     (set_attr "cc" "clobber")])
--- 2401,2407 ----
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "AVR_HAVE_JMP_CALL && TARGET_CALL_PROLOGUES"
    "jmp __tablejump2__"
    [(set_attr "length" "2")
     (set_attr "cc" "clobber")])
***************
*** 2411,2417 ****
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "AVR_MEGA && AVR_HAVE_LPMX"
    "lsl r30
  	rol r31
  	lpm __tmp_reg__,Z+
--- 2411,2417 ----
  			UNSPEC_INDEX_JMP))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_dup 0))]
!   "AVR_HAVE_JMP_CALL && AVR_HAVE_LPMX"
    "lsl r30
  	rol r31
  	lpm __tmp_reg__,Z+
*** gcc/config/avr/avr.c.old	(revision 133965)
--- gcc/config/avr/avr.c	(revision 133966)
***************
*** 105,113 ****
  
  section *progmem_section;
  
- /* More than 8K of program memory: use "call" and "jmp".  */
- int avr_mega_p = 0;
- 
  /* Core have 'MUL*' instructions.  */
  int avr_have_mul_p = 0;
  
--- 105,110 ----
***************
*** 360,372 ****
    base = &avr_arch_types[t->arch];
    avr_asm_only_p = base->asm_only;
    avr_have_mul_p = base->have_mul;
-   avr_mega_p = base->have_jmp_call;
    avr_have_movw_lpmx_p = base->have_movw_lpmx;
    avr_base_arch_macro = base->macro;
    avr_extra_arch_macro = t->macro;
  
    if (optimize && !TARGET_NO_TABLEJUMP)
!     avr_case_values_threshold = (!AVR_MEGA || TARGET_CALL_PROLOGUES) ? 8 : 17;
  
    tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);
    zero_reg_rtx = gen_rtx_REG (QImode, ZERO_REGNO);
--- 357,369 ----
    base = &avr_arch_types[t->arch];
    avr_asm_only_p = base->asm_only;
    avr_have_mul_p = base->have_mul;
    avr_have_movw_lpmx_p = base->have_movw_lpmx;
    avr_base_arch_macro = base->macro;
    avr_extra_arch_macro = t->macro;
  
    if (optimize && !TARGET_NO_TABLEJUMP)
!     avr_case_values_threshold = 
!       (!AVR_HAVE_JMP_CALL || TARGET_CALL_PROLOGUES) ? 8 : 17;
  
    tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);
    zero_reg_rtx = gen_rtx_REG (QImode, ZERO_REGNO);
***************
*** 1150,1156 ****
  
    if (code == '~')
      {
!       if (!AVR_MEGA)
  	fputc ('r', file);
      }
    else if (code == '!')
--- 1147,1153 ----
  
    if (code == '~')
      {
!       if (!AVR_HAVE_JMP_CALL)
  	fputc ('r', file);
      }
    else if (code == '!')
***************
*** 1325,1331 ****
      return 1;
    else if (-2046 <= jump_distance && jump_distance <= 2045)
      return 2;
!   else if (AVR_MEGA)
      return 3;
    
    return 2;
--- 1322,1328 ----
      return 1;
    else if (-2046 <= jump_distance && jump_distance <= 2045)
      return 2;
!   else if (AVR_HAVE_JMP_CALL)
      return 3;
    
    return 2;
***************
*** 4775,4781 ****
  {
    fprintf (asm_out_file,
  	   "\t.section .progmem.gcc_sw_table, \"%s\", @progbits\n",
! 	   AVR_MEGA ? "a" : "ax");
    /* Should already be aligned, this is just to be safe if it isn't.  */
    fprintf (asm_out_file, "\t.p2align 1\n");
  }
--- 4772,4778 ----
  {
    fprintf (asm_out_file,
  	   "\t.section .progmem.gcc_sw_table, \"%s\", @progbits\n",
! 	   AVR_HAVE_JMP_CALL ? "a" : "ax");
    /* Should already be aligned, this is just to be safe if it isn't.  */
    fprintf (asm_out_file, "\t.p2align 1\n");
  }
***************
*** 4785,4791 ****
  static void
  avr_asm_init_sections (void)
  {
!   progmem_section = get_unnamed_section (AVR_MEGA ? 0 : SECTION_CODE,
  					 avr_output_progmem_section_asm_op,
  					 NULL);
    readonly_data_section = data_section;
--- 4782,4788 ----
  static void
  avr_asm_init_sections (void)
  {
!   progmem_section = get_unnamed_section (AVR_HAVE_JMP_CALL ? 0 : SECTION_CODE,
  					 avr_output_progmem_section_asm_op,
  					 NULL);
    readonly_data_section = data_section;
***************
*** 5070,5076 ****
  	  if (AVR_HAVE_MUL)
  	    *total = COSTS_N_INSNS (optimize_size ? 3 : 4);
  	  else if (optimize_size)
! 	    *total = COSTS_N_INSNS (AVR_MEGA ? 2 : 1);
  	  else
  	    return false;
  	  break;
--- 5067,5073 ----
  	  if (AVR_HAVE_MUL)
  	    *total = COSTS_N_INSNS (optimize_size ? 3 : 4);
  	  else if (optimize_size)
! 	    *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);
  	  else
  	    return false;
  	  break;
***************
*** 5079,5085 ****
  	  if (AVR_HAVE_MUL)
  	    *total = COSTS_N_INSNS (optimize_size ? 7 : 10);
  	  else if (optimize_size)
! 	    *total = COSTS_N_INSNS (AVR_MEGA ? 2 : 1);
  	  else
  	    return false;
  	  break;
--- 5076,5082 ----
  	  if (AVR_HAVE_MUL)
  	    *total = COSTS_N_INSNS (optimize_size ? 7 : 10);
  	  else if (optimize_size)
! 	    *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);
  	  else
  	    return false;
  	  break;
***************
*** 5096,5102 ****
      case UDIV:
      case UMOD:
        if (optimize_size)
! 	*total = COSTS_N_INSNS (AVR_MEGA ? 2 : 1);
        else
  	return false;
        *total += avr_operand_rtx_cost (XEXP (x, 0), mode, code);
--- 5093,5099 ----
      case UDIV:
      case UMOD:
        if (optimize_size)
! 	*total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);
        else
  	return false;
        *total += avr_operand_rtx_cost (XEXP (x, 0), mode, code);
*** gcc/config/avr/avr.h.old	(revision 133965)
--- gcc/config/avr/avr.h	(revision 133966)
***************
*** 96,102 ****
  
  extern const char *avr_base_arch_macro;
  extern const char *avr_extra_arch_macro;
- extern int avr_mega_p;
  extern int avr_have_mul_p;
  extern int avr_asm_only_p;
  extern int avr_have_movw_lpmx_p;
--- 96,101 ----
***************
*** 104,110 ****
  extern GTY(()) section *progmem_section;
  #endif
  
- #define AVR_MEGA (avr_mega_p && !TARGET_SHORT_CALLS)
  #define AVR_HAVE_JMP_CALL (avr_current_arch->have_jmp_call && !TARGET_SHORT_CALLS)
  #define AVR_HAVE_MUL (avr_have_mul_p)
  #define AVR_HAVE_MOVW (avr_have_movw_lpmx_p)
--- 103,108 ----
*** gcc/config/avr/avr.c.old	(revision 134068)
--- gcc/config/avr/avr.c	(revision 134069)
***************
*** 200,206 ****
    { "at76c711",     ARCH_AVR3, "__AVR_AT76C711__" },
      /* Classic, == 128K.  */
    { "avr31",        ARCH_AVR31, NULL },
!   { "atmega103",    ARCH_AVR3, "__AVR_ATmega103__" },
      /* Classic + MOVW + JMP/CALL.  */
    { "avr35",        ARCH_AVR35, NULL },
    { "at90usb82",    ARCH_AVR35, "__AVR_AT90USB82__" },
--- 200,206 ----
    { "at76c711",     ARCH_AVR3, "__AVR_AT76C711__" },
      /* Classic, == 128K.  */
    { "avr31",        ARCH_AVR31, NULL },
!   { "atmega103",    ARCH_AVR31, "__AVR_ATmega103__" },
      /* Classic + MOVW + JMP/CALL.  */
    { "avr35",        ARCH_AVR35, NULL },
    { "at90usb82",    ARCH_AVR35, "__AVR_AT90USB82__" },
*** gcc/config/avr/avr.h.old	(revision 134068)
--- gcc/config/avr/avr.h	(revision 134069)
***************
*** 82,88 ****
  	builtin_define ("__AVR_HAVE_JMP_CALL__"); \
        if (avr_current_arch->have_eijmp_eicall)	\
          {					\
! 	  builtin_define ("__AVR_HAVE_JMP_CALL__");	\
  	  builtin_define ("__AVR_3_BYTE_PC__");	\
  	}					\
        else					\
--- 82,88 ----
  	builtin_define ("__AVR_HAVE_JMP_CALL__"); \
        if (avr_current_arch->have_eijmp_eicall)	\
          {					\
! 	  builtin_define ("__AVR_HAVE_EIJMP_EICALL__");	\
  	  builtin_define ("__AVR_3_BYTE_PC__");	\
  	}					\
        else					\
*** gcc/tree-sra.c.0	2008-04-20 11:31:55.846492952 +0200
--- gcc/tree-sra.c	2008-04-20 11:40:46.586808160 +0200
*************** sra_walk_expr (tree *expr_p, block_stmt_
*** 855,872 ****
  	    if (elt)
  	      elt->is_vector_lhs = true;
  	  }
  	/* A bit field reference (access to *multiple* fields simultaneously)
! 	   is not currently scalarized.  Consider this an access to the
! 	   complete outer element, to which walk_tree will bring us next.  */
! 	  
  	goto use_all;
  
-       case VIEW_CONVERT_EXPR:
        case NOP_EXPR:
! 	/* Similarly, a view/nop explicitly wants to look at an object in a
  	   type other than the one we've scalarized.  */
  	goto use_all;
  
        case WITH_SIZE_EXPR:
  	/* This is a transparent wrapper.  The entire inner expression really
  	   is being used.  */
--- 855,882 ----
  	    if (elt)
  	      elt->is_vector_lhs = true;
  	  }
+ 
  	/* A bit field reference (access to *multiple* fields simultaneously)
! 	   is not currently scalarized.  Consider this an access to the full
! 	   outer element, to which walk_tree will bring us next.  */
  	goto use_all;
  
        case NOP_EXPR:
! 	/* Similarly, a nop explicitly wants to look at an object in a
  	   type other than the one we've scalarized.  */
  	goto use_all;
  
+       case VIEW_CONVERT_EXPR:
+ 	/* Likewise for a view conversion, but with an additional twist:
+ 	   it can be on the LHS and, in this case, an access to the full
+ 	   outer element would mean a killing def.  So we need to punt
+ 	   if we haven't already a full access to the current element,
+ 	   because we cannot pretend to have a killing def if we only
+ 	   have a partial access at some level.  */
+ 	if (is_output && !use_all_p && inner != expr)
+ 	  disable_scalarization = true;
+ 	goto use_all;
+ 
        case WITH_SIZE_EXPR:
  	/* This is a transparent wrapper.  The entire inner expression really
  	   is being used.  */
*** gcc/Makefile.in.orig	Tue Apr 22 16:47:37 2008
--- gcc/Makefile.in	Tue Apr 22 16:49:33 2008
***************
*** 3148,3155 ****
    $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \
    @all_gtfiles@
  
! GTFILES_H = $(subst /,-, $(patsubst $(srcdir)/%,gt-%, $(patsubst %.c,%.h, \
! 		  $(filter %.c, $(GTFILES)))))
  
  GTFILES_LANG_H = $(patsubst [%], gtype-%.h, $(filter [%], $(GTFILES)))
  ALL_GTFILES_H := $(sort $(GTFILES_H) $(GTFILES_LANG_H))
--- 3148,3156 ----
    $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \
    @all_gtfiles@
  
! GTFILES_H = $(subst /,-, $(shell echo $(patsubst $(srcdir)/%,gt-%, \
!               $(patsubst %.c,%.h, \
!               $(filter %.c, $(GTFILES)))) | sed -e "s;/[^ ]*/;/;g"))
  
  GTFILES_LANG_H = $(patsubst [%], gtype-%.h, $(filter [%], $(GTFILES)))
  ALL_GTFILES_H := $(sort $(GTFILES_H) $(GTFILES_LANG_H))
*** gcc/configure.orig	Tue Apr 22 16:47:37 2008
--- gcc/configure	Tue Apr 22 16:49:43 2008
***************
*** 6483,6491 ****
  
  if test "$GCC" = yes; then
    echo "$as_me:$LINENO: checking whether $CC supports -pedantic -Wno-long-long -Wno-variadic-macros \
! 				     -Wno-overlength-strings" >&5
  echo $ECHO_N "checking whether $CC supports -pedantic -Wno-long-long -Wno-variadic-macros \
! 				     -Wno-overlength-strings... $ECHO_C" >&6
  if test "${acx_cv_prog_cc_pedantic__Wno_long_long__Wno_variadic_macros_____________Wno_overlength_strings+set}" = set; then
    echo $ECHO_N "(cached) $ECHO_C" >&6
  else
--- 6483,6491 ----
  
  if test "$GCC" = yes; then
    echo "$as_me:$LINENO: checking whether $CC supports -pedantic -Wno-long-long -Wno-variadic-macros \
!          -Wno-overlength-strings" >&5
  echo $ECHO_N "checking whether $CC supports -pedantic -Wno-long-long -Wno-variadic-macros \
!          -Wno-overlength-strings... $ECHO_C" >&6
  if test "${acx_cv_prog_cc_pedantic__Wno_long_long__Wno_variadic_macros_____________Wno_overlength_strings+set}" = set; then
    echo $ECHO_N "(cached) $ECHO_C" >&6
  else
***************
*** 22940,22945 ****
--- 22940,22946 ----
  # Then add #include lines to for a compiler that has specs and/or options.
  
  subdirs=
+ gcc_subdirs=
  lang_opt_files=
  lang_specs_files=
  lang_tree_files=
***************
*** 22980,22990 ****
          fi
          subdir="`echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
          subdirs="$subdirs $subdir"
          case ",$enable_languages," in
          *,$lang_alias,*)
              all_selected_languages="$all_selected_languages $lang_alias"
! 	    if test -f $srcdir/$subdir/lang-specs.h; then
! 	        lang_specs_files="$lang_specs_files $srcdir/$subdir/lang-specs.h"
  	    fi
  	    ;;
          esac
--- 22981,22997 ----
          fi
          subdir="`echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
          subdirs="$subdirs $subdir"
+ 
+         gcc_subdir=`sed -n -e 's,^gcc_subdir=['"'"'"'"]\(.*\)["'"'"'"'].*$,\1,p' -e 's,^gcc_subdir=\([^   ]*\).*$,\1,p' $lang`
+         if [ "$gcc_subdir" = "" ]; then
+            gcc_subdir="$subdir"
+         fi
+ 
          case ",$enable_languages," in
          *,$lang_alias,*)
              all_selected_languages="$all_selected_languages $lang_alias"
!             if test -f $srcdir/$gcc_subdir/lang-specs.h; then
!                 lang_specs_files="$lang_specs_files $srcdir/$gcc_subdir/lang-specs.h"
  	    fi
  	    ;;
          esac
***************
*** 22995,23004 ****
  	outputs=
  	gtfiles=
  	subdir_requires=
! 	. ${srcdir}/$subdir/config-lang.in
  	if test "x$language" = x
  	then
! 		echo "${srcdir}/$subdir/config-lang.in doesn't set \$language." 1>&2
  		exit 1
  	fi
  
--- 23002,23011 ----
  	outputs=
  	gtfiles=
  	subdir_requires=
! 	. ${srcdir}/$gcc_subdir/config-lang.in
  	if test "x$language" = x
  	then
! 		echo "${srcdir}/$gcc_subdir/config-lang.in doesn't set \$language." 1>&2
  		exit 1
  	fi
  
***************
*** 23015,23034 ****
  	esac
  	$ok || continue
  
! 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$subdir/Make-lang.in"
! 	if test -f $srcdir/$subdir/lang.opt; then
! 	    lang_opt_files="$lang_opt_files $srcdir/$subdir/lang.opt"
! 	fi
! 	if test -f $srcdir/$subdir/$subdir-tree.def; then
! 	    lang_tree_files="$lang_tree_files $srcdir/$subdir/$subdir-tree.def"
! 	fi
! 	if test -f ${srcdir}/$subdir/Makefile.in
! 		then all_lang_makefiles="$subdir/Makefile"
! 	fi
! 	all_languages="$all_languages $language"
! 	all_compilers="$all_compilers $compilers"
! 	all_outputs="$all_outputs $outputs"
! 	all_gtfiles="$all_gtfiles [$subdir] $gtfiles"
  done
  
  # Pick up gtfiles for c
--- 23022,23041 ----
  	esac
  	$ok || continue
  
!         all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
!         if test -f $srcdir/$gcc_subdir/lang.opt; then
!             lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
!         fi
!         if test -f $srcdir/$gcc_subdir/$subdir-tree.def; then
!             lang_tree_files="$lang_tree_files $srcdir/$gcc_subdir/$subdir-tree.def"
!         fi
!         if test -f ${srcdir}/$gcc_subdir/Makefile.in
!                 then all_lang_makefiles="$gcc_subdir/Makefile"
!         fi
!         all_languages="$all_languages $language"
!         all_compilers="$all_compilers $compilers"
!         all_outputs="$all_outputs $outputs"
!         all_gtfiles="$all_gtfiles [$subdir] $gtfiles"
  done
  
  # Pick up gtfiles for c
*** gcc/configure.ac.orig	Tue Apr 22 16:47:37 2008
--- gcc/configure.ac	Tue Apr 22 16:49:33 2008
***************
*** 3580,3585 ****
--- 3580,3586 ----
  # Then add #include lines to for a compiler that has specs and/or options.
  
  subdirs=
+ gcc_subdirs=
  lang_opt_files=
  lang_specs_files=
  lang_tree_files=
***************
*** 3621,3631 ****
          fi
          subdir="`echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
          subdirs="$subdirs $subdir"
          case ",$enable_languages," in
          *,$lang_alias,*)
              all_selected_languages="$all_selected_languages $lang_alias"
! 	    if test -f $srcdir/$subdir/lang-specs.h; then
! 	        lang_specs_files="$lang_specs_files $srcdir/$subdir/lang-specs.h"
  	    fi
  	    ;;
          esac
--- 3621,3637 ----
          fi
          subdir="`echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
          subdirs="$subdirs $subdir"
+ 
+         gcc_subdir=`sed -n -e 's,^gcc_subdir=['"'"'"'"]\(.*\)["'"'"'"'].*$,\1,p' -e 's,^gcc_subdir=\([^   ]*\).*$,\1,p' $lang`
+         if [ "$gcc_subdir" = "" ]; then
+            gcc_subdir="$subdir"
+         fi
+ 
          case ",$enable_languages," in
          *,$lang_alias,*)
              all_selected_languages="$all_selected_languages $lang_alias"
!             if test -f $srcdir/$gcc_subdir/lang-specs.h; then
!                 lang_specs_files="$lang_specs_files $srcdir/$gcc_subdir/lang-specs.h"
  	    fi
  	    ;;
          esac
***************
*** 3637,3646 ****
  	outputs=
  	gtfiles=
  	subdir_requires=
! 	. ${srcdir}/$subdir/config-lang.in
  	if test "x$language" = x
  	then
! 		echo "${srcdir}/$subdir/config-lang.in doesn't set \$language." 1>&2
  		exit 1
  	fi
  
--- 3644,3653 ----
  	outputs=
  	gtfiles=
  	subdir_requires=
! 	. ${srcdir}/$gcc_subdir/config-lang.in
  	if test "x$language" = x
  	then
! 		echo "${srcdir}/$gcc_subdir/config-lang.in doesn't set \$language." 1>&2
  		exit 1
  	fi
  
***************
*** 3657,3676 ****
  	esac
  	$ok || continue
  
! 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$subdir/Make-lang.in"
! 	if test -f $srcdir/$subdir/lang.opt; then
! 	    lang_opt_files="$lang_opt_files $srcdir/$subdir/lang.opt"
! 	fi
! 	if test -f $srcdir/$subdir/$subdir-tree.def; then
! 	    lang_tree_files="$lang_tree_files $srcdir/$subdir/$subdir-tree.def"
! 	fi
! 	if test -f ${srcdir}/$subdir/Makefile.in
! 		then all_lang_makefiles="$subdir/Makefile"
! 	fi
! 	all_languages="$all_languages $language"
! 	all_compilers="$all_compilers $compilers"
! 	all_outputs="$all_outputs $outputs"
! 	all_gtfiles="$all_gtfiles [[$subdir]] $gtfiles"
  done
  
  # Pick up gtfiles for c
--- 3664,3683 ----
  	esac
  	$ok || continue
  
!         all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
!         if test -f $srcdir/$gcc_subdir/lang.opt; then
!             lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
!         fi
!         if test -f $srcdir/$gcc_subdir/$subdir-tree.def; then
!             lang_tree_files="$lang_tree_files $srcdir/$gcc_subdir/$subdir-tree.def"
!         fi
!         if test -f ${srcdir}/$gcc_subdir/Makefile.in
!                 then all_lang_makefiles="$gcc_subdir/Makefile"
!         fi
!         all_languages="$all_languages $language"
!         all_compilers="$all_compilers $compilers"
!         all_outputs="$all_outputs $outputs"
!         all_gtfiles="$all_gtfiles [[$subdir]] $gtfiles"
  done
  
  # Pick up gtfiles for c
*** gcc/gengtype.c.orig	Fri Nov 16 01:11:47 2007
--- gcc/gengtype.c	Tue Apr 22 16:49:33 2008
***************
*** 152,157 ****
--- 152,158 ----
  
  static outf_p create_file (const char *, const char *);
  static const char * get_file_basename (const char *);
+ static const char * get_file_gtfilename (const char *);
  
  
  /* Nonzero iff an error has occurred.  */
***************
*** 1556,1569 ****
  get_file_basename (const char *f)
  {
    const char *basename;
    unsigned i;
  
    basename = strrchr (f, '/');
  
    if (!basename)
!     return f;
  
!   basename++;
  
    for (i = 0; i < num_lang_dirs; i++)
      {
--- 1557,1589 ----
  get_file_basename (const char *f)
  {
    const char *basename;
+   int f_length;
+ 
+   basename = f;
+ 
+   f_length = strlen (f);
+   if (f_length > srcdir_len && IS_DIR_SEPARATOR (f[srcdir_len]) && memcmp (basename, srcdir, srcdir_len) == 0)
+      { basename += srcdir_len + 1;
+      }
+   return basename;
+ }
+ 
+ static const char *
+ get_file_gtfilename (const char *f)
+ {
+   const char *basename;
+   const char *srcdir_relative_path;
+   char *s, *result;
    unsigned i;
  
    basename = strrchr (f, '/');
  
    if (!basename)
!     basename = f;
!   else
!     basename++;
  
!   srcdir_relative_path = get_file_basename (f);
  
    for (i = 0; i < num_lang_dirs; i++)
      {
***************
*** 1571,1590 ****
        const char * s2;
        int l1;
        int l2;
!       s1 = basename - strlen (lang_dir_names [i]) - 1;
        s2 = lang_dir_names [i];
        l1 = strlen (s1);
        l2 = strlen (s2);
!       if (l1 >= l2 && IS_DIR_SEPARATOR (s1[-1]) && !memcmp (s1, s2, l2))
          {
-           basename -= l2 + 1;
-           if ((basename - f - 1) != srcdir_len)
- 	    fatal ("filename `%s' should be preceded by $srcdir", f);
            break;
          }
      }
  
!   return basename;
  }
  
  /* An output file, suitable for definitions, that can see declarations
--- 1591,1616 ----
        const char * s2;
        int l1;
        int l2;
!       s1 = srcdir_relative_path;
        s2 = lang_dir_names [i];
        l1 = strlen (s1);
        l2 = strlen (s2);
!       if (l1 > l2 && IS_DIR_SEPARATOR (s1[l2]) && memcmp (s1, s2, l2) == 0)
          {
            break;
          }
      }
  
!   if (i >= num_lang_dirs)
!      result = s = xasprintf ("gt-%s", basename);
!   else  
!      result = s = xasprintf ("gt-%s-%s", lang_dir_names [i], basename);
! 
!   for (; *s != '.'; s++)
!         if (! ISALNUM (*s) && *s != '-')
!           *s = '-';
!       memcpy (s, ".h", sizeof (".h"));
!   return result;
  }
  
  /* An output file, suitable for definitions, that can see declarations
***************
*** 1614,1626 ****
        || (len > 2 && memcmp (basename+len-2, ".y", 2) == 0)
        || (len > 3 && memcmp (basename+len-3, ".in", 3) == 0))
      {
!       char *s;
! 
!       output_name = s = xasprintf ("gt-%s", basename);
!       for (; *s != '.'; s++)
! 	if (! ISALNUM (*s) && *s != '-')
! 	  *s = '-';
!       memcpy (s, ".h", sizeof (".h"));
        for_name = basename;
      }
    /* Some headers get used by more than one front-end; hence, it
--- 1640,1646 ----
        || (len > 2 && memcmp (basename+len-2, ".y", 2) == 0)
        || (len > 3 && memcmp (basename+len-3, ".in", 3) == 0))
      {
!       output_name = get_file_gtfilename (input_file); 
        for_name = basename;
      }
    /* Some headers get used by more than one front-end; hence, it
*** gcc/expr.c	(revision 129234)
--- gcc/expr.c	(working copy)
*************** expand_expr_real_1 (tree exp, rtx target
*** 7794,7806 ****
  	/* If this is a constant, put it into a register if it is a legitimate
  	   constant, OFFSET is 0, and we won't try to extract outside the
  	   register (in case we were passed a partially uninitialized object
! 	   or a view_conversion to a larger size).  Force the constant to
! 	   memory otherwise.  */
  	if (CONSTANT_P (op0))
  	  {
  	    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));
  	    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)
  		&& offset == 0
  		&& bitpos + bitsize <= GET_MODE_BITSIZE (mode))
  	      op0 = force_reg (mode, op0);
  	    else
--- 7794,7808 ----
  	/* If this is a constant, put it into a register if it is a legitimate
  	   constant, OFFSET is 0, and we won't try to extract outside the
  	   register (in case we were passed a partially uninitialized object
! 	   or a view_conversion to a larger size) or a BLKmode piece of it
! 	   (e.g. if it is unchecked-converted to a record type in Ada).  Force
! 	   the constant to memory otherwise.  */
  	if (CONSTANT_P (op0))
  	  {
  	    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));
  	    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)
  		&& offset == 0
+ 		&& mode1 != BLKmode
  		&& bitpos + bitsize <= GET_MODE_BITSIZE (mode))
  	      op0 = force_reg (mode, op0);
  	    else
*************** expand_expr_real_1 (tree exp, rtx target
*** 7814,7821 ****
  	   for an ARRAY_RANGE_REF whose type is BLKmode.  */
  	else if (!MEM_P (op0)
  		 && (offset != 0
! 		     || (bitpos + bitsize > GET_MODE_BITSIZE (GET_MODE (op0)))
! 		     || (code == ARRAY_RANGE_REF && mode == BLKmode)))
  	  {
  	    tree nt = build_qualified_type (TREE_TYPE (tem),
  					    (TYPE_QUALS (TREE_TYPE (tem))
--- 7816,7824 ----
  	   for an ARRAY_RANGE_REF whose type is BLKmode.  */
  	else if (!MEM_P (op0)
  		 && (offset != 0
! 		     || mode1 == BLKmode
! 		     || (bitpos + bitsize
! 			 > GET_MODE_BITSIZE (GET_MODE (op0)))))
  	  {
  	    tree nt = build_qualified_type (TREE_TYPE (tem),
  					    (TYPE_QUALS (TREE_TYPE (tem))
*** gcc/tree-sra.c.ori	Tue May  6 14:27:49 2008
--- gcc/tree-sra.c	Tue May  6 14:28:52 2008
*************** try_instantiate_multiple_fields (struct 
*** 1475,1480 ****
--- 1475,1484 ----
    tree type, var;
    struct sra_elt *block;
  
+   /* Point fields are typically best handled as standalone entities.  */
+   if (POINTER_TYPE_P (TREE_TYPE (f)))
+     return f;
+     
    if (!is_sra_scalar_type (TREE_TYPE (f))
        || !host_integerp (DECL_FIELD_OFFSET (f), 1)
        || !host_integerp (DECL_FIELD_BIT_OFFSET (f), 1)
*** gcc/gimplify.c.0	2008-05-13 15:35:13.000000000 +0200
--- gcc/gimplify.c	2008-05-14 12:27:20.579903080 +0200
*************** along with GCC; see the file COPYING3.  
*** 28,33 ****
--- 28,34 ----
  #include "tree.h"
  #include "rtl.h"
  #include "varray.h"
+ #include "pointer-set.h"
  #include "tree-gimple.h"
  #include "tree-inline.h"
  #include "diagnostic.h"
*************** annotate_all_with_locus (tree *stmt_p, l
*** 815,821 ****
      }
  }
  
! /* Similar to copy_tree_r() but do not copy SAVE_EXPR or TARGET_EXPR nodes.
     These nodes model computations that should only be done once.  If we
     were to unshare something like SAVE_EXPR(i++), the gimplification
     process would create wrong code.  */
--- 816,822 ----
      }
  }
  
! /* Similar to copy_tree_r but do not copy SAVE_EXPR or TARGET_EXPR nodes.
     These nodes model computations that should only be done once.  If we
     were to unshare something like SAVE_EXPR(i++), the gimplification
     process would create wrong code.  */
*************** static tree
*** 824,905 ****
  mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)
  {
    enum tree_code code = TREE_CODE (*tp);
!   /* Don't unshare types, decls, constants and SAVE_EXPR nodes.  */
!   if (TREE_CODE_CLASS (code) == tcc_type
!       || TREE_CODE_CLASS (code) == tcc_declaration
!       || TREE_CODE_CLASS (code) == tcc_constant
!       || code == SAVE_EXPR || code == TARGET_EXPR
!       /* We can't do anything sensible with a BLOCK used as an expression,
! 	 but we also can't just die when we see it because of non-expression
! 	 uses.  So just avert our eyes and cross our fingers.  Silly Java.  */
!       || code == BLOCK)
!     *walk_subtrees = 0;
!   else
      {
!       gcc_assert (code != BIND_EXPR);
!       copy_tree_r (tp, walk_subtrees, data);
      }
  
    return NULL_TREE;
  }
  
  /* Callback for walk_tree to unshare most of the shared trees rooted at
     *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),
!    then *TP is deep copied by calling copy_tree_r.
! 
!    This unshares the same trees as copy_tree_r with the exception of
!    SAVE_EXPR nodes.  These nodes model computations that should only be
!    done once.  If we were to unshare something like SAVE_EXPR(i++), the
!    gimplification process would create wrong code.  */
  
  static tree
! copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,
! 		  void *data ATTRIBUTE_UNUSED)
  {
!   tree t = *tp;
!   enum tree_code code = TREE_CODE (t);
  
!   /* Skip types, decls, and constants.  But we do want to look at their
!      types and the bounds of types.  Mark them as visited so we properly
!      unmark their subtrees on the unmark pass.  If we've already seen them,
!      don't look down further.  */
!   if (TREE_CODE_CLASS (code) == tcc_type
!       || TREE_CODE_CLASS (code) == tcc_declaration
!       || TREE_CODE_CLASS (code) == tcc_constant)
      {
!       if (TREE_VISITED (t))
! 	*walk_subtrees = 0;
        else
! 	TREE_VISITED (t) = 1;
      }
  
    /* If this node has been visited already, unshare it and don't look
       any deeper.  */
!   else if (TREE_VISITED (t))
      {
!       walk_tree (tp, mostly_copy_tree_r, NULL, NULL);
        *walk_subtrees = 0;
      }
  
!   /* Otherwise, mark the tree as visited and keep looking.  */
    else
!     TREE_VISITED (t) = 1;
  
    return NULL_TREE;
  }
  
  static tree
! unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,
! 		  void *data ATTRIBUTE_UNUSED)
  {
!   if (TREE_VISITED (*tp))
      TREE_VISITED (*tp) = 0;
    else
      *walk_subtrees = 0;
  
    return NULL_TREE;
  }
  
  /* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the
     bodies of any nested functions if we are unsharing the entire body of
     FNDECL.  */
--- 825,944 ----
  mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)
  {
    enum tree_code code = TREE_CODE (*tp);
! 
!   /* Do not copy SAVE_EXPR or TARGET_EXPR nodes themselves, but copy
!      their subtrees if we can make sure to do it only once.  */
!   if (code == SAVE_EXPR || code == TARGET_EXPR)
      {
!       if (data && !pointer_set_insert (data, *tp))
! 	;
!       else
! 	*walk_subtrees = 0;
      }
  
+   /* Stop at types, decls, constants like copy_tree_r.  */
+   else if (TREE_CODE_CLASS (code) == tcc_type
+ 	   || TREE_CODE_CLASS (code) == tcc_declaration
+ 	   || TREE_CODE_CLASS (code) == tcc_constant
+ 	   /* Cope with the statement expression extension.  */
+ 	   || code == BIND_EXPR
+ 	   /* We can't do anything sensible with a BLOCK used as an
+ 	      expression, but we also can't just die when we see it
+ 	      because of non-expression uses.  So we avert our eyes
+ 	      and cross our fingers.  Silly Java.  */
+ 	   || code == BLOCK)
+     *walk_subtrees = 0;
+ 
+   /* Leave the bulk of the work to copy_tree_r itself.  */
+   else
+     copy_tree_r (tp, walk_subtrees, NULL);
+ 
    return NULL_TREE;
  }
  
  /* Callback for walk_tree to unshare most of the shared trees rooted at
     *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),
!    then *TP is deep copied by calling mostly_copy_tree_r.  */
  
  static tree
! copy_if_shared_r (tree *tp, int *walk_subtrees, void *data)
  {
!   enum tree_code code = TREE_CODE (*tp);
  
!   /* Do not unshare SAVE_EXPR or TARGET_EXPR nodes themselves, but unshare
!      their subtrees if we can make sure to do it only once.  */
!   if (code == SAVE_EXPR || code == TARGET_EXPR)
      {
!       if (data && !pointer_set_insert (data, *tp))
! 	;
        else
! 	*walk_subtrees = 0;
      }
  
    /* If this node has been visited already, unshare it and don't look
       any deeper.  */
!   else if (TREE_VISITED (*tp))
      {
!       walk_tree (tp, mostly_copy_tree_r, data, NULL);
        *walk_subtrees = 0;
      }
  
!   /* Otherwise, mark the node as visited and keep looking.  */
    else
!     TREE_VISITED (*tp) = 1;
  
    return NULL_TREE;
  }
  
+ /* Unshare most of the shared trees rooted at *TP. */
+ 
+ static inline void
+ copy_if_shared (tree *tp)
+ {
+   struct pointer_set_t *visited = pointer_set_create ();
+   walk_tree (tp, copy_if_shared_r, visited, NULL);
+   pointer_set_destroy (visited);
+ }
+ 
+ /* Callback for walk_tree to unmark the visited trees rooted at *TP.
+    Subtrees are walked until the first unvisited node is encountered.  */
+ 
  static tree
! unmark_visited_r (tree *tp, int *walk_subtrees, void *data)
  {
!   enum tree_code code = TREE_CODE (*tp);
! 
!   /* Do not unmark SAVE_EXPR or TARGET_EXPR nodes themselves, but unmark
!      their subtrees if we can make sure to do it only once.  */
!   if (code == SAVE_EXPR || code == TARGET_EXPR)
!     {
!       if (data && !pointer_set_insert (data, *tp))
! 	;
!       else
! 	*walk_subtrees = 0;
!     }
! 
!   /* If this node has been visited, unmark it and keep looking.  */
!   else if (TREE_VISITED (*tp))
      TREE_VISITED (*tp) = 0;
+ 
+   /* Otherwise, don't look any deeper.  */
    else
      *walk_subtrees = 0;
  
    return NULL_TREE;
  }
  
+ /* Unmark the visited trees rooted at *TP.  */
+ 
+ static inline void
+ unmark_visited (tree *tp)
+ {
+   struct pointer_set_t *visited = pointer_set_create ();
+   walk_tree (tp, unmark_visited_r, visited, NULL);
+   pointer_set_destroy (visited);
+ }
+ 
  /* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the
     bodies of any nested functions if we are unsharing the entire body of
     FNDECL.  */
*************** unshare_body (tree *body_p, tree fndecl)
*** 909,915 ****
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   walk_tree (body_p, copy_if_shared_r, NULL, NULL);
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
--- 948,955 ----
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   copy_if_shared (body_p);
! 
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
*************** unvisit_body (tree *body_p, tree fndecl)
*** 922,928 ****
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   walk_tree (body_p, unmark_visited_r, NULL, NULL);
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
--- 962,969 ----
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   unmark_visited (body_p);
! 
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
*************** unvisit_body (tree *body_p, tree fndecl)
*** 933,940 ****
  static void
  unshare_all_trees (tree t)
  {
!   walk_tree (&t, copy_if_shared_r, NULL, NULL);
!   walk_tree (&t, unmark_visited_r, NULL, NULL);
  }
  
  /* Unconditionally make an unshared copy of EXPR.  This is used when using
--- 974,981 ----
  static void
  unshare_all_trees (tree t)
  {
!   copy_if_shared (&t);
!   unmark_visited (&t);
  }
  
  /* Unconditionally make an unshared copy of EXPR.  This is used when using
*** gcc/Makefile.in.0	2008-05-13 15:35:17.000000000 +0200
--- gcc/Makefile.in	2008-05-14 12:28:09.686437752 +0200
*************** c-gimplify.o : c-gimplify.c $(CONFIG_H) 
*** 2253,2259 ****
     $(FLAGS_H) langhooks.h toplev.h $(RTL_H) $(TREE_FLOW_H) $(LANGHOOKS_DEF_H) \
     $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H) $(BASIC_BLOCK_H) \
     hard-reg-set.h $(TREE_DUMP_H) $(TREE_INLINE_H)
! gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
     $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \
     $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \
     coretypes.h except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) output.h \
--- 2253,2259 ----
     $(FLAGS_H) langhooks.h toplev.h $(RTL_H) $(TREE_FLOW_H) $(LANGHOOKS_DEF_H) \
     $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H) $(BASIC_BLOCK_H) \
     hard-reg-set.h $(TREE_DUMP_H) $(TREE_INLINE_H)
! gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) pointer-set.h \
     $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \
     $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \
     coretypes.h except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) output.h \
*** gcc/common.opt.ori	Tue May 13 15:05:01 2008
--- gcc/common.opt	Tue May 13 15:05:33 2008
*************** gdwarf-2
*** 1257,1262 ****
--- 1257,1266 ----
  Common JoinedOrMissing Negative(gstabs)
  Generate debug information in DWARF v2 format
  
+ gdwarf+
+ Common JoinedOrMissing
+ Generate debug information in DWARF v2 format with GNU extensions
+ 
  ggdb
  Common JoinedOrMissing
  Generate debug information in default extended format
*** gcc/opts.c.ori	Tue May 13 15:05:01 2008
--- gcc/opts.c	Tue May 13 15:05:33 2008
*************** common_handle_option (size_t scode, cons
*** 1770,1775 ****
--- 1770,1779 ----
        set_debug_level (SDB_DEBUG, false, arg);
        break;
  
+     case OPT_gdwarf_:
+       set_debug_level (DWARF2_DEBUG, true, arg);
+       break;
+ 
      case OPT_gdwarf_2:
        set_debug_level (DWARF2_DEBUG, false, arg);
        break;
*** gcc/doc/invoke.texi.ori	Tue May 13 15:05:01 2008
--- gcc/doc/invoke.texi	Tue May 13 15:05:33 2008
*************** option, GCC uses features of DWARF versi
*** 4155,4160 ****
--- 4155,4165 ----
  version 3 is upward compatible with version 2, but may still cause
  problems for older debuggers.
  
+ @item -gdwarf+
+ @opindex gdwarf+
+ Produce debugging information in DWARF version 2 format, including the
+ GNAT vendors extensions (if that is supported).
+ 
  @item -gvms
  @opindex gvms
  Produce debugging information in VMS debug format (if that is
*************** debug level for DWARF2.
*** 4193,4199 ****
  @opindex feliminate-dwarf2-dups
  Compress DWARF2 debugging information by eliminating duplicated
  information about each symbol.  This option only makes sense when
! generating DWARF2 debugging information with @option{-gdwarf-2}.
  
  @item -femit-struct-debug-baseonly
  Emit debug information for struct-like types
--- 4198,4205 ----
  @opindex feliminate-dwarf2-dups
  Compress DWARF2 debugging information by eliminating duplicated
  information about each symbol.  This option only makes sense when
! generating DWARF2 debugging information with @option{-gdwarf-2} or
! @option{-gdwarf+}.
  
  @item -femit-struct-debug-baseonly
  Emit debug information for struct-like types
*** gcc/defaults.h.0	2009-03-30 08:53:56.000000000 +0200
--- gcc/defaults.h	2009-03-28 15:42:00.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 619,624 ****
--- 619,630 ----
  #define DEFAULT_GDB_EXTENSIONS 1
  #endif
  
+ #ifdef DWARF2_DEBUGGING_INFO
+ #ifndef DWARF2_GNU_TYPE_EXTENSIONS
+ #define DWARF2_GNU_TYPE_EXTENSIONS 1
+ #endif
+ #endif
+ 
  /* If more than one debugging type is supported, you must define
     PREFERRED_DEBUGGING_TYPE to choose the default.  */
  
*** gcc/dwarf2out.c.ori	Tue May 13 15:05:01 2008
--- gcc/dwarf2out.c	Thu May 15 12:36:29 2008
*************** static void add_location_or_const_value_
*** 4481,4486 ****
--- 4481,4488 ----
  						   enum dwarf_attribute);
  static void tree_add_const_value_attribute (dw_die_ref, tree);
  static void add_name_attribute (dw_die_ref, const char *);
+ static void add_artificial_attribute_for_type (dw_die_ref, tree);
+ static void add_descriptive_attribute_for_type (dw_die_ref, tree, dw_die_ref);
  static void add_comp_dir_attribute (dw_die_ref);
  static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);
  static void add_subscript_info (dw_die_ref, tree);
*************** dwarf2out_set_demangle_name_func (const 
*** 4678,4683 ****
--- 4680,4700 ----
    demangle_name_func = func;
  }
  
+ static const char *(*type_encoding_func) (const char *);
+ static tree (*descriptive_type_func) (tree);
+ 
+ void
+ dwarf2out_set_type_encoding_func (const char *(*func) (const char *))
+ {
+   type_encoding_func = func;
+ }
+ 
+ void
+ dwarf2out_set_descriptive_type_func (tree (*func) (tree))
+ {
+   descriptive_type_func = func;
+ }
+ 
  /* Test if rtl node points to a pseudo register.  */
  
  static inline int
*************** dwarf_attr_name (unsigned int attr)
*** 5057,5062 ****
--- 5074,5084 ----
      case DW_AT_VMS_rtnbeg_pd_address:
        return "DW_AT_VMS_rtnbeg_pd_address";
  
+     case DW_AT_GNU_type_encoding:
+       return "DW_AT_GNAT_encoding"; 
+     case DW_AT_GNU_descriptive_type:
+       return "DW_AT_GNAT_descriptive_type";
+ 
      default:
        return "DW_AT_<unknown>";
      }
*************** modified_type_die (tree type, int is_con
*** 8960,8965 ****
--- 8982,8989 ----
  	   useful source coordinates anyway.  */
  	name = DECL_NAME (name);
        add_name_attribute (mod_type_die, IDENTIFIER_POINTER (name));
+       add_artificial_attribute_for_type (mod_type_die, type);
+       add_descriptive_attribute_for_type (mod_type_die, type, context_die);
      }
  
    if (qualified_type)
*************** add_name_attribute (dw_die_ref die, cons
*** 11197,11207 ****
--- 11221,11281 ----
  {
    if (name_string != NULL && *name_string != 0)
      {
+       const char *orig_string = name_string;
+ 
        if (demangle_name_func)
  	name_string = (*demangle_name_func) (name_string);
  
        add_AT_string (die, DW_AT_name, name_string);
+ 
+       if (type_encoding_func)
+ 	{
+ 	  const char *encoding = (*type_encoding_func) (orig_string);
+ 
+ 	  if (*encoding != 0)
+ 	    add_AT_string (die, DW_AT_GNU_type_encoding, encoding);
+ 	}
+     }
+ }
+ 
+ /* Add a DW_AT_artificial attribute to the DIE for TYPE if needed.  */
+ 
+ static void 
+ add_artificial_attribute_for_type (dw_die_ref die, tree type)
+ {
+   if (TYPE_NAME (type)
+       && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+       && DECL_ARTIFICIAL (TYPE_NAME (type))
+       && !get_AT_flag (die, DW_AT_artificial))
+     add_AT_flag (die, DW_AT_artificial, 1);
+ }
+ 
+ /* Retrieve the descriptive type for TYPE, if any, and attach a
+    DW_AT_GNU_descriptive_type attribute to the DIE of TYPE if needed.  */
+ 
+ static void 
+ add_descriptive_attribute_for_type (dw_die_ref die, tree type,
+ 				    dw_die_ref context_die)
+ {
+   tree descriptive_type;
+   dw_die_ref type_die;
+ 
+   if (!descriptive_type_func)
+     return;
+ 
+   descriptive_type = descriptive_type_func (type);
+   if (!descriptive_type)
+     return;
+ 
+   type_die = lookup_type_die (descriptive_type);
+   if (!type_die)
+     {
+       gen_type_die (descriptive_type, context_die);
+       type_die = lookup_type_die (descriptive_type);
+       gcc_assert (type_die);
      }
+ 
+   add_AT_die_ref (die, DW_AT_GNU_descriptive_type, type_die);
  }
  
  /* Generate a DW_AT_comp_dir attribute for DIE.  */
*************** gen_array_type_die (tree type, dw_die_re
*** 11891,11896 ****
--- 11965,11972 ----
  
    array_die = new_die (DW_TAG_array_type, scope_die, type);
    add_name_attribute (array_die, type_tag (type));
+   add_artificial_attribute_for_type (array_die, type);
+   add_descriptive_attribute_for_type (array_die, type, context_die);
    equate_type_number_to_die (type, array_die);
  
    if (TREE_CODE (type) == VECTOR_TYPE)
*************** gen_enumeration_type_die (tree type, dw_
*** 12221,12226 ****
--- 12324,12331 ----
  			  scope_die_for (type, context_die), type);
        equate_type_number_to_die (type, type_die);
        add_name_attribute (type_die, type_tag (type));
+       add_artificial_attribute_for_type (type_die, type);
+       add_descriptive_attribute_for_type (type_die, type, context_die);
      }
    else if (! TYPE_SIZE (type))
      return type_die;
*************** gen_compile_unit_die (const char *filena
*** 13246,13251 ****
--- 13325,13336 ----
      strcat (producer, " -g");
  #endif
  
+   /* ??? We need to find a better way.  */
+   if (use_gnu_debug_info_extensions)
+     strcat (producer, " -gdwarf+");
+   else
+     strcat (producer, " -gdwarf+-");
+ 
    add_AT_string (die, DW_AT_producer, producer);
  
    if (strcmp (language_string, "GNU C++") == 0)
*************** gen_struct_or_union_type_die (tree type,
*** 13393,13399 ****
        if (old_die)
  	add_AT_specification (type_die, old_die);
        else
! 	add_name_attribute (type_die, type_tag (type));
      }
    else
      remove_AT (type_die, DW_AT_declaration);
--- 13477,13487 ----
        if (old_die)
  	add_AT_specification (type_die, old_die);
        else
! 	{
! 	  add_name_attribute (type_die, type_tag (type));
! 	  add_artificial_attribute_for_type (type_die, type);
! 	  add_descriptive_attribute_for_type (type_die, type, context_die);
! 	}
      }
    else
      remove_AT (type_die, DW_AT_declaration);
*** gcc/dwarf2out.h.ori	Tue May 13 15:05:01 2008
--- gcc/dwarf2out.h	Thu May 15 12:12:45 2008
*************** extern void debug_dwarf (void);
*** 25,30 ****
--- 25,32 ----
  struct die_struct;
  extern void debug_dwarf_die (struct die_struct *);
  extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));
+ extern void dwarf2out_set_type_encoding_func (const char *(*) (const char *));
+ extern void dwarf2out_set_descriptive_type_func (tree (*) (tree));
  
  struct array_descr_info
  {
*************** struct array_descr_info
*** 41,43 ****
--- 43,46 ----
        tree stride;
      } dimen[10];
  };
+ 
*** gcc/dwarf2.h.ori	Tue May 13 15:05:01 2008
--- gcc/dwarf2.h	Thu May 15 11:57:20 2008
*************** enum dwarf_attribute
*** 372,377 ****
--- 372,380 ----
      DW_AT_GNU_vector = 0x2107,
      /* VMS extensions.  */
      DW_AT_VMS_rtnbeg_pd_address = 0x2201,
+     /* GNU extensions for descriptive types and type encoding.  */
+     DW_AT_GNU_type_encoding = 0x2301,
+     DW_AT_GNU_descriptive_type = 0x2302,
      /* UPC extension.  */
      DW_AT_upc_threads_scaled = 0x3210,
      /* PGI (STMicroelectronics) extensions.  */
*** gcc/alias.h.0	2008-05-17 10:45:03.000000000 +0200
--- gcc/alias.h	2008-02-21 12:22:00.000000000 +0100
*************** typedef HOST_WIDE_INT alias_set_type;
*** 26,31 ****
--- 26,32 ----
  extern alias_set_type new_alias_set (void);
  extern alias_set_type get_varargs_alias_set (void);
  extern alias_set_type get_frame_alias_set (void);
+ extern void record_alias_subset (alias_set_type, alias_set_type);
  extern bool component_uses_parent_alias_set (const_tree);
  extern bool alias_set_subset_of (alias_set_type, alias_set_type);
  extern int nonoverlapping_memrefs_p (const_rtx, const_rtx);
*** gcc/alias.c.0	2008-05-17 10:45:03.000000000 +0200
--- gcc/alias.c	2008-05-17 10:47:15.000000000 +0200
*************** static rtx adjust_offset_for_component_r
*** 167,173 ****
  static int write_dependence_p (const_rtx, const_rtx, int);
  
  static void memory_modified_1 (rtx, const_rtx, void *);
- static void record_alias_subset (alias_set_type, alias_set_type);
  
  /* Set up all info needed to perform alias analysis on memory references.  */
  
--- 167,172 ----
*************** new_alias_set (void)
*** 689,695 ****
     It is illegal for SUPERSET to be zero; everything is implicitly a
     subset of alias set zero.  */
  
! static void
  record_alias_subset (alias_set_type superset, alias_set_type subset)
  {
    alias_set_entry superset_entry;
--- 688,694 ----
     It is illegal for SUPERSET to be zero; everything is implicitly a
     subset of alias set zero.  */
  
! void
  record_alias_subset (alias_set_type superset, alias_set_type subset)
  {
    alias_set_entry superset_entry;
*** gcc/tree-inline.h.0	2008-05-17 10:49:18.000000000 +0200
--- gcc/tree-inline.h	2008-02-21 12:22:00.000000000 +0100
*************** typedef struct copy_body_data
*** 66,71 ****
--- 66,74 ----
       get eh region number of the duplicate in the function we inline into.  */
    int eh_region_offset;
  
+   /* Special alias set whose children are pointed to by ref-all pointers.  */
+   alias_set_type ref_all_alias_set;
+ 
    /* We use the same mechanism do all sorts of different things.  Rather
       than enumerating the different cases, we categorize the behavior
       in the various situations.  */
*** gcc/tree-inline.c.0	2008-05-17 10:45:03.000000000 +0200
--- gcc/tree-inline.c	2008-05-17 15:44:46.068236088 +0200
*************** remap_type_1 (tree type, copy_body_data 
*** 303,324 ****
  {
    tree new, t;
  
!   /* We do need a copy.  build and register it now.  If this is a pointer or
!      reference type, remap the designated type and make a new pointer or
!      reference type.  */
    if (TREE_CODE (type) == POINTER_TYPE)
      {
        new = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					 TYPE_MODE (type),
! 					 TYPE_REF_CAN_ALIAS_ALL (type));
        insert_decl_map (id, type, new);
        return new;
      }
    else if (TREE_CODE (type) == REFERENCE_TYPE)
      {
        new = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					    TYPE_MODE (type),
! 					    TYPE_REF_CAN_ALIAS_ALL (type));
        insert_decl_map (id, type, new);
        return new;
      }
--- 303,340 ----
  {
    tree new, t;
  
!   /* We do need a copy.  Build and register it now.  If this is a pointer
!      or reference type, remap the designated type and make a new pointer
!      or reference type.  Moreover, if the designated type can be pointed
!      to by ref-all pointers, we might be remapping a chain starting from
!      one of them so we need to propagate the property to it.  */
    if (TREE_CODE (type) == POINTER_TYPE)
      {
+       bool can_alias_all = TYPE_REF_CAN_ALIAS_ALL (type);
+       if (!can_alias_all && id->ref_all_alias_set)
+ 	{
+ 	  HOST_WIDE_INT alias_set = get_alias_set (TREE_TYPE (type));
+ 	  if (alias_set
+ 	      && alias_sets_conflict_p (id->ref_all_alias_set, alias_set))
+ 	    can_alias_all = TRUE;
+ 	}
        new = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					 TYPE_MODE (type), can_alias_all);
        insert_decl_map (id, type, new);
        return new;
      }
    else if (TREE_CODE (type) == REFERENCE_TYPE)
      {
+       bool can_alias_all = TYPE_REF_CAN_ALIAS_ALL (type);
+       if (!can_alias_all && id->ref_all_alias_set)
+ 	{
+ 	  HOST_WIDE_INT alias_set = get_alias_set (TREE_TYPE (type));
+ 	  if (alias_set
+ 	      && alias_sets_conflict_p (id->ref_all_alias_set, alias_set))
+ 	    can_alias_all = TRUE;
+ 	}
        new = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					   TYPE_MODE (type), can_alias_all);
        insert_decl_map (id, type, new);
        return new;
      }
*************** remap_type (tree type, copy_body_data *i
*** 419,426 ****
    if (node)
      return *node;
  
!   /* The type only needs remapping if it's variably modified.  */
!   if (! variably_modified_type_p (type, id->src_fn))
      {
        insert_decl_map (id, type, type);
        return type;
--- 435,444 ----
    if (node)
      return *node;
  
!   /* The type only needs remapping if we have ref-all pointers and
!      it is a pointer or is variably modified.  */
!   if (!(id->ref_all_alias_set && POINTER_TYPE_P (type))
!       && !variably_modified_type_p (type, id->src_fn))
      {
        insert_decl_map (id, type, type);
        return type;
*************** setup_one_parameter (copy_body_data *id,
*** 1442,1470 ****
  {
    tree init_stmt;
    tree var;
!   tree var_sub;
    tree rhs = value;
    tree def = (gimple_in_ssa_p (cfun)
  	      ? gimple_default_def (id->src_cfun, p) : NULL);
  
!   if (value
!       && value != error_mark_node
!       && !useless_type_conversion_p (TREE_TYPE (p), TREE_TYPE (value)))
      {
!       if (fold_convertible_p (TREE_TYPE (p), value))
! 	rhs = fold_build1 (NOP_EXPR, TREE_TYPE (p), value);
!       else
! 	/* ???  For valid (GIMPLE) programs we should not end up here.
! 	   Still if something has gone wrong and we end up with truly
! 	   mismatched types here, fall back to using a VIEW_CONVERT_EXPR
! 	   to not leak invalid GIMPLE to the following passes.  */
! 	rhs = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (p), value);
      }
  
    /* If the parameter is never assigned to, has no SSA_NAMEs created,
       we may not need to create a new variable here at all.  Instead, we may
       be able to just use the argument value.  */
!   if (TREE_READONLY (p)
        && !TREE_ADDRESSABLE (p)
        && value && !TREE_SIDE_EFFECTS (value)
        && !def)
--- 1460,1517 ----
  {
    tree init_stmt;
    tree var;
!   tree type = TREE_TYPE (p);
    tree rhs = value;
    tree def = (gimple_in_ssa_p (cfun)
  	      ? gimple_default_def (id->src_cfun, p) : NULL);
  
!   if (value && value != error_mark_node)
      {
!       /* If the argument is a pointer that can alias everything, we need
! 	 to propagate the property to the VAR_DECL.  But, at this point,
! 	 it is too late to have a better granularity than types and we
! 	 need to propagate the property to all the types that can point
! 	 to (or within) the object pointed to by the VAR_DECL.  */
!       if (POINTER_TYPE_P (TREE_TYPE (value))
! 	  && TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (value))
! 	  && POINTER_TYPE_P (type)
! 	  && !TYPE_REF_CAN_ALIAS_ALL (type))
! 	{
! 	  alias_set_type alias_set = get_alias_set (TREE_TYPE (type));
! 	  if (alias_set)
! 	    {
! 	      if (!id->ref_all_alias_set)
! 		id->ref_all_alias_set = new_alias_set ();
! 	      record_alias_subset (id->ref_all_alias_set, alias_set);
! 	      if (TREE_CODE (type) == POINTER_TYPE)
! 		type = build_pointer_type_for_mode (TREE_TYPE (type),
! 						    TYPE_MODE (type),
! 						    true);
! 	      else
! 	        type = build_reference_type_for_mode (TREE_TYPE (type),
! 						      TYPE_MODE (type),
! 						      true);
! 	    }
! 	}
! 
!       if (!useless_type_conversion_p (type, TREE_TYPE (value)))
! 	{
! 	  if (fold_convertible_p (type, value))
! 	    rhs = fold_build1 (NOP_EXPR, type, value);
! 	  else
! 	    /* ??? For valid (GIMPLE) programs we should not end up here.
! 	       Still if something has gone wrong and we end up with truly
! 	       mismatched types here, fall back to using a VIEW_CONVERT_EXPR
! 	      to not leak invalid GIMPLE to the following passes.  */
! 	    rhs = fold_build1 (VIEW_CONVERT_EXPR, type, value);
! 	}
      }
  
    /* If the parameter is never assigned to, has no SSA_NAMEs created,
       we may not need to create a new variable here at all.  Instead, we may
       be able to just use the argument value.  */
!   if (TREE_TYPE (p) == type
!       && TREE_READONLY (p)
        && !TREE_ADDRESSABLE (p)
        && value && !TREE_SIDE_EFFECTS (value)
        && !def)
*************** setup_one_parameter (copy_body_data *id,
*** 1474,1481 ****
  	 It is not big deal to prohibit constant propagation here as
  	 we will constant propagate in DOM1 pass anyway.  */
        if (is_gimple_min_invariant (value)
! 	  && useless_type_conversion_p (TREE_TYPE (p),
! 						 TREE_TYPE (value))
  	  /* We have to be very careful about ADDR_EXPR.  Make sure
  	     the base variable isn't a local variable of the inlined
  	     function, e.g., when doing recursive inlining, direct or
--- 1521,1527 ----
  	 It is not big deal to prohibit constant propagation here as
  	 we will constant propagate in DOM1 pass anyway.  */
        if (is_gimple_min_invariant (value)
! 	  && useless_type_conversion_p (type, TREE_TYPE (value))
  	  /* We have to be very careful about ADDR_EXPR.  Make sure
  	     the base variable isn't a local variable of the inlined
  	     function, e.g., when doing recursive inlining, direct or
*************** setup_one_parameter (copy_body_data *id,
*** 1492,1520 ****
       here since the type of this decl must be visible to the calling
       function.  */
    var = copy_decl_to_var (p, id);
    if (gimple_in_ssa_p (cfun) && TREE_CODE (var) == VAR_DECL)
      {
        get_var_ann (var);
        add_referenced_var (var);
      }
  
-   /* See if the frontend wants to pass this by invisible reference.  If
-      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to
-      replace uses of the PARM_DECL with dereferences.  */
-   if (TREE_TYPE (var) != TREE_TYPE (p)
-       && POINTER_TYPE_P (TREE_TYPE (var))
-       && TREE_TYPE (TREE_TYPE (var)) == TREE_TYPE (p))
-     {
-       insert_decl_map (id, var, var);
-       var_sub = build_fold_indirect_ref (var);
-     }
-   else
-     var_sub = var;
- 
    /* Register the VAR_DECL as the equivalent for the PARM_DECL;
       that way, when the PARM_DECL is encountered, it will be
       automatically replaced by the VAR_DECL.  */
!   insert_decl_map (id, p, var_sub);
  
    /* Declare this new variable.  */
    TREE_CHAIN (var) = *vars;
--- 1538,1556 ----
       here since the type of this decl must be visible to the calling
       function.  */
    var = copy_decl_to_var (p, id);
+   if (TREE_TYPE (var) != type)
+     TREE_TYPE (var) = type;
+ 
    if (gimple_in_ssa_p (cfun) && TREE_CODE (var) == VAR_DECL)
      {
        get_var_ann (var);
        add_referenced_var (var);
      }
  
    /* Register the VAR_DECL as the equivalent for the PARM_DECL;
       that way, when the PARM_DECL is encountered, it will be
       automatically replaced by the VAR_DECL.  */
!   insert_decl_map (id, p, var);
  
    /* Declare this new variable.  */
    TREE_CHAIN (var) = *vars;
*************** setup_one_parameter (copy_body_data *id,
*** 1574,1580 ****
  
        if (rhs == error_mark_node)
  	{
!   	  insert_decl_map (id, p, var_sub);
  	  return;
  	}
  
--- 1610,1616 ----
  
        if (rhs == error_mark_node)
  	{
! 	  insert_decl_map (id, p, var);
  	  return;
  	}
  
*** gcc/common.opt.0	2008-05-20 12:23:07.692860752 +0200
--- gcc/common.opt	2008-05-20 09:37:00.000000000 +0200
*************** fkeep-inline-functions
*** 634,639 ****
--- 634,643 ----
  Common Report Var(flag_keep_inline_functions)
  Generate code for functions even if they are fully inlined
  
+ fkeep-nested-functions
+ Common Report Var(flag_keep_nested_functions)
+ Generate code for nested functions even if they are not used
+ 
  fkeep-static-consts
  Common Report Var(flag_keep_static_consts) Init(1)
  Emit static const variables even if they are not used
*** gcc/doc/invoke.texi.0	2008-05-20 12:23:07.699859688 +0200
--- gcc/doc/invoke.texi	2008-05-20 09:37:00.000000000 +0200
*************** Objective-C and Objective-C++ Dialects}.
*** 329,335 ****
  -finline-functions-called-once -finline-limit=@var{n} @gol
  -finline-small-functions -fipa-cp -fipa-matrix-reorg -fipa-pta @gol 
  -fipa-pure-const -fipa-reference -fipa-struct-reorg @gol
! -fipa-type-escape -fivopts -fkeep-inline-functions -fkeep-static-consts @gol
  -fmerge-all-constants -fmerge-constants -fmodulo-sched @gol
  -fmodulo-sched-allow-regmoves -fmove-loop-invariants -fmudflap @gol
  -fmudflapir -fmudflapth -fno-branch-count-reg -fno-default-inline @gol
--- 329,336 ----
  -finline-functions-called-once -finline-limit=@var{n} @gol
  -finline-small-functions -fipa-cp -fipa-matrix-reorg -fipa-pta @gol 
  -fipa-pure-const -fipa-reference -fipa-struct-reorg @gol
! -fipa-type-escape -fivopts -fkeep-inline-functions @gol
! -fkeep-nested-functions -fkeep-static-consts @gol
  -fmerge-all-constants -fmerge-constants -fmodulo-sched @gol
  -fmodulo-sched-allow-regmoves -fmove-loop-invariants -fmudflap @gol
  -fmudflapir -fmudflapth -fno-branch-count-reg -fno-default-inline @gol
*************** of its callers.  This switch does not af
*** 5386,5391 ****
--- 5387,5398 ----
  @code{extern inline} extension in GNU C89@.  In C++, emit any and all
  inline functions into the object file.
  
+ @item -fkeep-nested-functions
+ @opindex fkeep-nested-functions
+ Emit functions that are nested in other functions into the object file,
+ even if the function is not called or referenced in its parent function.
+ GCC discards these functions by default.
+ 
  @item -fkeep-static-consts
  @opindex fkeep-static-consts
  Emit variables declared @code{static const} when optimization isn't turned
*** gcc/tree-nested.c.0	2008-05-20 12:23:07.703859080 +0200
--- gcc/tree-nested.c	2008-05-20 12:28:18.502610488 +0200
*************** struct nesting_info
*** 82,88 ****
    struct nesting_info *outer;
    struct nesting_info *inner;
    struct nesting_info *next;
!   
    struct pointer_map_t *field_map;
    struct pointer_map_t *var_map;
    bitmap suppress_expansion;
--- 82,89 ----
    struct nesting_info *outer;
    struct nesting_info *inner;
    struct nesting_info *next;
!   struct nesting_info *next_reachable;
! 
    struct pointer_map_t *field_map;
    struct pointer_map_t *var_map;
    bitmap suppress_expansion;
*************** struct nesting_info
*** 98,107 ****
--- 99,129 ----
  
    bool any_parm_remapped;
    bool any_tramp_created;
+   bool reachable;
    char static_chain_added;
  };
  
  
+ static FILE *local_dump_file;
+ static int local_dump_flags;
+ 
+ /* Whether to discard unreachable nested functions during this pass.
+    If this is set to false, the pass will not differentiate objects
+    referenced by a reachable inner function from objects referenced
+    by an unreachable inner function: both will end up being members
+    of the "nonlocal frame struct" after the pass and not standalone
+    objects anymore.  That means they will be allocated in memory
+    since the "nonlocal frame struct" is always addressable.  */
+ 
+ static bool discard_unreachable;
+ 
+ #define IS_UNREACHABLE(ni) (discard_unreachable && !(ni)->reachable)
+ 
+ /* Pointer map used to look up nesting_info from nesting_info->context.  */
+ 
+ static struct pointer_map_t *ni_map;
+ 
+ 
  /* Obstack used for the bitmaps in the struct above.  */
  static struct bitmap_obstack nesting_info_bitmap_obstack;
  
*************** get_frame_type (struct nesting_info *inf
*** 211,222 ****
        info->frame_type = type;
        info->frame_decl = create_tmp_var_for (info, type, "FRAME");
  
!       /* ??? Always make it addressable for now, since it is meant to
! 	 be pointed to by the static chain pointer.  This pessimizes
! 	 when it turns out that no static chains are needed because
! 	 the nested functions referencing non-local variables are not
! 	 reachable, but the true pessimization is to create the non-
! 	 local frame structure in the first place.  */
        TREE_ADDRESSABLE (info->frame_decl) = 1;
      }
    return type;
--- 233,240 ----
        info->frame_type = type;
        info->frame_decl = create_tmp_var_for (info, type, "FRAME");
  
!       /* It is always addressable since it will be pointed to
! 	 by the static chain pointer.  */
        TREE_ADDRESSABLE (info->frame_decl) = 1;
      }
    return type;
*************** walk_omp_for (walk_tree_fn callback, str
*** 723,736 ****
  static void
  walk_all_functions (walk_tree_fn callback, struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
  	walk_all_functions (callback, root->inner);
        walk_function (callback, root);
-       root = root->next;
      }
-   while (root);
  }
  
  /* We have to check for a fairly pathological case.  The operands of function
--- 741,755 ----
  static void
  walk_all_functions (walk_tree_fn callback, struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
+       if (IS_UNREACHABLE (root))
+ 	continue;
+ 
        if (root->inner)
  	walk_all_functions (callback, root->inner);
        walk_function (callback, root);
      }
  }
  
  /* We have to check for a fairly pathological case.  The operands of function
*************** check_for_nested_with_variably_modified 
*** 781,792 ****
--- 800,816 ----
  static struct nesting_info *
  create_nesting_tree (struct cgraph_node *cgn)
  {
+   void **slot;
    struct nesting_info *info = XCNEW (struct nesting_info);
    info->field_map = pointer_map_create ();
    info->var_map = pointer_map_create ();
    info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);
    info->context = cgn->decl;
  
+   slot = pointer_map_insert (ni_map, info->context);
+   gcc_assert (*slot == NULL);
+   *slot = info;
+ 
    for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)
      {
        struct nesting_info *sub = create_nesting_tree (cgn);
*************** create_nesting_tree (struct cgraph_node 
*** 803,808 ****
--- 827,910 ----
    return info;
  }
  
+ /* Queue of reachable nested functions to be analyzed.  */
+ 
+ static struct nesting_info *reachable_queue;
+ 
+ /* Mark FNDECL as reachable if it is not already and add it to the queue.  */
+ 
+ static void
+ mark_reachable_function_1 (tree fndecl)
+ {
+   struct nesting_info *info;
+   void **slot;
+ 
+   slot = pointer_map_contains (ni_map, fndecl);
+   gcc_assert (slot != NULL);
+   info = *slot;
+ 
+   if (!info->reachable)
+     {
+       info->reachable = true;
+       info->next_reachable = reachable_queue;
+       reachable_queue = info;
+     }
+ }
+ 
+ /* Called via walk_function+walk_tree, mark the nested functions
+    that are reachable from TP.  */
+ 
+ static tree
+ mark_reachable_functions_1 (tree *tp, int *walk_subtrees, void *data)
+ {
+   struct walk_stmt_info *wi = data;
+   tree t = *tp, decl;
+   int i;
+ 
+   *walk_subtrees = 0;
+   switch (TREE_CODE (t))
+     {
+     case FDESC_EXPR:
+     case ADDR_EXPR:
+       decl = TREE_OPERAND (t, 0);
+       if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))
+ 	mark_reachable_function_1 (decl);
+       break;
+ 
+     case CALL_EXPR:
+       decl = get_callee_fndecl (t);
+       if (decl && decl_function_context (decl))
+ 	mark_reachable_function_1 (decl);
+ 
+       for (i = 3; i < VL_EXP_OPERAND_LENGTH (t); i++)
+ 	walk_tree (&TREE_OPERAND (t, i), mark_reachable_functions_1, wi, NULL);
+       break;
+ 
+     default:
+       if (!IS_TYPE_OR_DECL_P (t))
+ 	*walk_subtrees = 1;
+       break;
+     }
+ 
+   return NULL_TREE;
+ }
+ 
+ /* Find out which nested functions are reachable from ROOT.  */
+ 
+ static void
+ mark_reachable_functions (struct nesting_info *root)
+ {
+   root->reachable = true;
+   reachable_queue = root;
+ 
+   while (reachable_queue)
+     {
+       struct nesting_info *i = reachable_queue;
+       reachable_queue = reachable_queue->next_reachable;
+       walk_function (mark_reachable_functions_1, i);
+     }
+ }
+   
  /* Return an expression computing the static chain for TARGET_CONTEXT
     from INFO->CONTEXT.  Insert any necessary computations before TSI.  */
  
*************** convert_call_expr (tree *tp, int *walk_s
*** 1775,1782 ****
  static void
  convert_all_function_calls (struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
  	convert_all_function_calls (root->inner);
  
--- 1877,1887 ----
  static void
  convert_all_function_calls (struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
+       if (IS_UNREACHABLE (root))
+ 	continue;
+ 
        if (root->inner)
  	convert_all_function_calls (root->inner);
  
*************** convert_all_function_calls (struct nesti
*** 1788,1797 ****
  	DECL_NO_STATIC_CHAIN (root->context) = 1;
        else
  	gcc_assert (!DECL_NO_STATIC_CHAIN (root->context));
- 
-       root = root->next;
      }
-   while (root);
  }
  
  /* Do "everything else" to clean up or complete state collected by the
--- 1893,1899 ----
*************** finalize_nesting_tree_1 (struct nesting_
*** 1918,1937 ****
  		  true);
  
    /* Dump the translated tree function.  */
!   dump_function (TDI_nested, root->context);
  }
  
  static void
  finalize_nesting_tree (struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
  	finalize_nesting_tree (root->inner);
        finalize_nesting_tree_1 (root);
-       root = root->next;
      }
-   while (root);
  }
  
  /* Unnest the nodes and pass them to cgraph.  */
--- 2020,2041 ----
  		  true);
  
    /* Dump the translated tree function.  */
!   if (local_dump_file)
!     dump_function_to_file (root->context, local_dump_file, local_dump_flags);
  }
  
  static void
  finalize_nesting_tree (struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
+       if (IS_UNREACHABLE (root))
+ 	continue;
+ 
        if (root->inner)
  	finalize_nesting_tree (root->inner);
        finalize_nesting_tree_1 (root);
      }
  }
  
  /* Unnest the nodes and pass them to cgraph.  */
*************** unnest_nesting_tree_1 (struct nesting_in
*** 1945,1966 ****
       We also delay finalizing of these functions up to this point.  */
    if (node->origin)
      {
!        cgraph_unnest_node (cgraph_node (root->context));
!        cgraph_finalize_function (root->context, true);
      }
  }
  
  static void
  unnest_nesting_tree (struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
  	unnest_nesting_tree (root->inner);
        unnest_nesting_tree_1 (root);
-       root = root->next;
      }
-   while (root);
  }
  
  /* Free the data structures allocated during this pass.  */
--- 2049,2078 ----
       We also delay finalizing of these functions up to this point.  */
    if (node->origin)
      {
!       if (IS_UNREACHABLE (root))
! 	{
! 	  cgraph_remove_node (node);
! 	  if (local_dump_file)
! 	    fprintf (local_dump_file, "Discarded %s\n",
! 		     lang_hooks.decl_printable_name (root->context, 2));
! 	}
!       else
! 	{
! 	  cgraph_unnest_node (node);
! 	  cgraph_finalize_function (root->context, true);
! 	}
      }
  }
  
  static void
  unnest_nesting_tree (struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
        if (root->inner)
  	unnest_nesting_tree (root->inner);
        unnest_nesting_tree_1 (root);
      }
  }
  
  /* Free the data structures allocated during this pass.  */
*************** static void
*** 1969,1975 ****
  free_nesting_tree (struct nesting_info *root)
  {
    struct nesting_info *next;
!   do
      {
        if (root->inner)
  	free_nesting_tree (root->inner);
--- 2081,2088 ----
  free_nesting_tree (struct nesting_info *root)
  {
    struct nesting_info *next;
! 
!   for (; root; root = next)
      {
        if (root->inner)
  	free_nesting_tree (root->inner);
*************** free_nesting_tree (struct nesting_info *
*** 1977,1985 ****
        pointer_map_destroy (root->field_map);
        next = root->next;
        free (root);
-       root = next;
      }
-   while (root);
  }
  
  /* Main entry point for this pass.  Process FNDECL and all of its nested
--- 2090,2096 ----
*************** lower_nested_functions (tree fndecl)
*** 1996,2003 ****
--- 2107,2122 ----
    if (!cgn->nested)
      return;
  
+   local_dump_file = dump_begin (TDI_nested, &local_dump_flags);
+ 
+   /* Discard unreachable nested functions unless instructed not to.  */
+   discard_unreachable = (flag_keep_nested_functions == 0);
+ 
    bitmap_obstack_initialize (&nesting_info_bitmap_obstack);
+   ni_map = pointer_map_create ();
    root = create_nesting_tree (cgn);
+   if (discard_unreachable)
+     mark_reachable_functions (root);
    walk_all_functions (convert_nonlocal_reference, root);
    walk_all_functions (convert_local_reference, root);
    walk_all_functions (convert_nl_goto_reference, root);
*************** lower_nested_functions (tree fndecl)
*** 2006,2012 ****
--- 2125,2135 ----
    finalize_nesting_tree (root);
    unnest_nesting_tree (root);
    free_nesting_tree (root);
+   pointer_map_destroy (ni_map);
    bitmap_obstack_release (&nesting_info_bitmap_obstack);
+ 
+   if (local_dump_file)
+     dump_end (TDI_nested, local_dump_file);
  }
  
  #include "gt-tree-nested.h"
*** gcc/cgraphunit.c.0	2009-03-10 09:38:00.000000000 +0100
--- gcc/cgraphunit.c	2009-03-10 09:38:05.000000000 +0100
*************** cgraph_finalize_compilation_unit (void)
*** 1078,1083 ****
--- 1078,1084 ----
    if (errorcount || sorrycount)
      return;
  
+   finalize_size_functions ();
    finish_aliases_1 ();
  
    if (!flag_unit_at_a_time)
*** gcc/stor-layout.c.0	2009-03-10 09:38:00.000000000 +0100
--- gcc/stor-layout.c	2009-03-10 09:38:15.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 37,42 ****
--- 37,45 ----
  #include "langhooks.h"
  #include "regs.h"
  #include "params.h"
+ #include "cgraph.h"
+ #include "tree-inline.h"
+ #include "tree-dump.h"
  
  /* Data type for the expressions representing sizes of data types.
     It is the first integer type laid out.  */
*************** unsigned int initial_max_fld_align = TAR
*** 53,58 ****
--- 56,62 ----
     called only by a front end.  */
  static int reference_types_internal = 0;
  
+ static tree self_referential_size (tree);
  static void finalize_record_size (record_layout_info);
  static void finalize_type_size (tree);
  static void place_union_field (record_layout_info, tree);
*************** variable_size (tree size)
*** 117,129 ****
  {
    tree save;
  
    /* If the language-processor is to take responsibility for variable-sized
       items (e.g., languages which have elaboration procedures like Ada),
!      just return SIZE unchanged.  Likewise for self-referential sizes and
!      constant sizes.  */
!   if (TREE_CONSTANT (size)
!       || lang_hooks.decls.global_bindings_p () < 0
!       || CONTAINS_PLACEHOLDER_P (size))
      return size;
  
    size = save_expr (size);
--- 121,139 ----
  {
    tree save;
  
+   /* Obviously.  */
+   if (TREE_CONSTANT (size))
+     return size;
+ 
+   /* If the size is self-referential, we can't make a SAVE_EXPR (see
+      save_expr for the rationale).  But we can do something else.  */
+   if (CONTAINS_PLACEHOLDER_P (size))
+     return self_referential_size (size);
+ 
    /* If the language-processor is to take responsibility for variable-sized
       items (e.g., languages which have elaboration procedures like Ada),
!      just return SIZE unchanged.  */
!   if (lang_hooks.decls.global_bindings_p () < 0)
      return size;
  
    size = save_expr (size);
*************** variable_size (tree size)
*** 157,162 ****
--- 167,371 ----
  
    return size;
  }
+ 
+ /* An array of functions used for self-referential size computation.  */
+ static GTY(()) VEC (tree, gc) *size_functions;
+ 
+ /* Similar to copy_tree_r but do not copy component references involving
+    PLACEHOLDER_EXPRs.  These nodes are spotted in find_substitute_in_expr
+    and substituted in substitute_in_expr.  */
+ 
+ static tree
+ copy_self_referential_tree_r (tree *tp, int *walk_subtrees, void *data)
+ {
+   enum tree_code code = TREE_CODE (*tp);
+ 
+   /* Stop at types, decls, constants like copy_tree_r.  */
+   if (TREE_CODE_CLASS (code) == tcc_type
+       || TREE_CODE_CLASS (code) == tcc_declaration
+       || TREE_CODE_CLASS (code) == tcc_constant)
+     {
+       *walk_subtrees = 0;
+       return NULL_TREE;
+     }
+ 
+   /* This is the pattern built in ada/make_aligning_type.  */
+   else if (code == ADDR_EXPR
+ 	   && TREE_CODE (TREE_OPERAND (*tp, 0)) == PLACEHOLDER_EXPR)
+     {
+       *walk_subtrees = 0;
+       return NULL_TREE;
+     }
+ 
+   /* Default case: the component reference.  */
+   else if (code == COMPONENT_REF)
+     {
+       tree inner;
+       for (inner = TREE_OPERAND (*tp, 0);
+ 	   REFERENCE_CLASS_P (inner);
+ 	   inner = TREE_OPERAND (inner, 0))
+ 	;
+ 
+       if (TREE_CODE (inner) == PLACEHOLDER_EXPR)
+ 	{
+ 	  *walk_subtrees = 0;
+ 	  return NULL_TREE;
+ 	}
+     }
+ 
+   /* We're not supposed to have them in self-referential size trees
+      because we wouldn't properly control when they are evaluated.
+      However, not creating superfluous SAVE_EXPRs requires accurate
+      tracking of readonly-ness all the way down to here, which we
+      cannot always guarantee in practice.  So punt in this case.  */
+   else if (code == SAVE_EXPR)
+     return error_mark_node;
+ 
+   return copy_tree_r (tp, walk_subtrees, data);
+ }
+ 
+ /* Given a SIZE expression that is self-referential, return an equivalent
+    expression to serve as the actual size expression for a type.  */
+ 
+ static tree
+ self_referential_size (tree size)
+ {
+   static unsigned HOST_WIDE_INT fnno = 0;
+   VEC (tree, heap) *self_refs = NULL;
+   tree param_type_list = NULL, param_decl_list = NULL, arg_list = NULL;
+   tree t, ref, return_type, fntype, fnname, fndecl;
+   unsigned int i;
+   char buf[128];
+ 
+   /* Do not factor out simple operations.  */
+   t = skip_simple_arithmetic (size);
+   if (TREE_CODE (t) == CALL_EXPR)
+     return size;
+ 
+   /* Collect the list of self-references in the expression.  */
+   find_substitute_in_expr (size, &self_refs);
+   gcc_assert (VEC_length (tree, self_refs) > 0);
+ 
+   /* Obtain a private copy of the expression.  */
+   t = size;
+   if (walk_tree (&t, copy_self_referential_tree_r, NULL, NULL))
+     return size;
+   size = t;
+ 
+   /* Build the parameter and argument lists in parallel; also
+      substitute the former for the latter in the expression.  */
+   for (i = 0; VEC_iterate (tree, self_refs, i, ref); i++)
+     {
+       tree subst, param_name, param_type, param_decl;
+ 
+       if (DECL_P (ref))
+ 	{
+ 	  /* We shouldn't have true variables here.  */
+ 	  gcc_assert (TREE_READONLY (ref));
+ 	  subst = ref;
+ 	}
+       /* This is the pattern built in ada/make_aligning_type.  */
+       else if (TREE_CODE (ref) == ADDR_EXPR)
+         subst = ref;
+       /* Default case: the component reference.  */
+       else
+ 	subst = TREE_OPERAND (ref, 1);
+ 
+       sprintf (buf, "p%d", i);
+       param_name = get_identifier (buf);
+       param_type = TREE_TYPE (ref);
+       param_decl = build_decl (PARM_DECL, param_name, param_type);
+       if (targetm.calls.promote_prototypes (NULL_TREE)
+ 	  && INTEGRAL_TYPE_P (param_type)
+ 	  && TYPE_PRECISION (param_type) < TYPE_PRECISION (integer_type_node))
+ 	DECL_ARG_TYPE (param_decl) = integer_type_node;
+       else
+ 	DECL_ARG_TYPE (param_decl) = param_type;
+       DECL_ARTIFICIAL (param_decl) = 1;
+       TREE_READONLY (param_decl) = 1;
+ 
+       size = substitute_in_expr (size, subst, param_decl);
+ 
+       param_type_list = tree_cons (NULL_TREE, param_type, param_type_list);
+       param_decl_list = chainon (param_decl, param_decl_list);
+       arg_list = tree_cons (NULL_TREE, ref, arg_list);
+     }
+ 
+   VEC_free (tree, heap, self_refs);
+ 
+   /* Append 'void' to indicate that the number of parameters is fixed.  */
+   param_type_list = tree_cons (NULL_TREE, void_type_node, param_type_list);
+ 
+   /* The 3 lists have been created in reverse order.  */
+   param_type_list = nreverse (param_type_list);
+   param_decl_list = nreverse (param_decl_list);
+   arg_list = nreverse (arg_list);
+ 
+   /* Build the function type.  */
+   return_type = TREE_TYPE (size);
+   fntype = build_function_type (return_type, param_type_list);
+ 
+   /* Build the function declaration.  */
+   sprintf (buf, "SZ"HOST_WIDE_INT_PRINT_UNSIGNED, fnno++);
+   fnname = get_file_function_name (buf);
+   fndecl = build_decl (FUNCTION_DECL, fnname, fntype);
+   for (t = param_decl_list; t; t = TREE_CHAIN (t))
+     DECL_CONTEXT (t) = fndecl;
+   DECL_ARGUMENTS (fndecl) = param_decl_list;
+   DECL_RESULT (fndecl) = build_decl (RESULT_DECL, 0, return_type);
+   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;
+ 
+   /* The function has been created by the compiler and we don't
+      want to emit debug info for it.  */
+   DECL_ARTIFICIAL (fndecl) = 1;
+   DECL_IGNORED_P (fndecl) = 1;
+ 
+   /* It is supposed to be "const" and never throw.  */
+   TREE_READONLY (fndecl) = 1;
+   TREE_NOTHROW (fndecl) = 1;
+ 
+   /* We want it to be inlined when this is deemed profitable, as
+      well as discarded if every call has been integrated.  */
+   DECL_INLINE (fndecl) = 1;
+   DECL_DECLARED_INLINE_P (fndecl) = 1;
+ 
+   /* It is made up of a unique return statement.  */
+   DECL_INITIAL (fndecl) = make_node (BLOCK);
+   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;
+   t = build2 (MODIFY_EXPR, return_type, DECL_RESULT (fndecl), size);
+   DECL_SAVED_TREE (fndecl) = build1 (RETURN_EXPR, void_type_node, t);
+   TREE_STATIC (fndecl) = 1;
+ 
+   /* Put it onto the list of size functions.  */
+   VEC_safe_push (tree, gc, size_functions, fndecl);
+ 
+   /* Replace the original expression with a call to the size function.  */
+   return build_function_call_expr (fndecl, arg_list);
+ }
+ 
+ /* Take, queue and compile all the size functions.  It is essential that
+    the size functions be gimplified at the very end of the compilation
+    in order to guarantee transparent handling of self-referential sizes.
+    Otherwise the GENERIC inliner would not be able to inline them back
+    at each of their call sites, thus creating artificial non-constant
+    size expressions which would trigger nasty problems later on.  */
+ 
+ void
+ finalize_size_functions (void)
+ {
+   unsigned int i;
+   tree fndecl;
+ 
+   for (i = 0; VEC_iterate(tree, size_functions, i, fndecl); i++)
+     {
+       dump_function (TDI_original, fndecl);
+       gimplify_function_tree (fndecl);
+       dump_function (TDI_generic, fndecl);
+       cgraph_finalize_function (fndecl, false);
+     }
+ 
+   VEC_free (tree, gc, size_functions);
+ }
  
  #ifndef MAX_FIXED_MODE_SIZE
  #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)
*** gcc/tree.c.0	2009-03-10 09:38:00.000000000 +0100
--- gcc/tree.c	2009-03-10 09:38:05.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 45,50 ****
--- 45,51 ----
  #include "output.h"
  #include "target.h"
  #include "langhooks.h"
+ #include "tree-inline.h"
  #include "tree-iterator.h"
  #include "basic-block.h"
  #include "tree-flow.h"
*************** type_contains_placeholder_p (tree type)
*** 2412,2422 ****
    return result;
  }
  
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP
!    contains only arithmetic expressions or a CALL_EXPR with a
!    PLACEHOLDER_EXPR occurring only in its arglist.  */
  
  tree
  substitute_in_expr (tree exp, tree f, tree r)
--- 2413,2514 ----
    return result;
  }
  
+ /* Push tree EXP onto vector QUEUE if it is not already present.  */
+ 
+ static void
+ push_without_duplicate (tree exp, VEC (tree, heap) **queue)
+ {
+   unsigned int i;
+   tree iter;
+ 
+   for (i = 0; VEC_iterate (tree, *queue, i, iter); i++)
+     if (simple_cst_equal (iter, exp) == 1)
+       break;
+ 
+   if (!iter)
+     VEC_safe_push (tree, heap, *queue, exp);
+ }
+ 
+ /* Given a tree EXP, find all occurences of references to fields
+    in a PLACEHOLDER_EXPR and place them in vector SUBSTS without
+    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that
+    we assume here that EXP contains only arithmetic expressions
+    or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their
+    argument list.  */
+ 
+ void
+ find_substitute_in_expr (tree exp, VEC (tree, heap) **substs)
+ {
+   enum tree_code code = TREE_CODE (exp);
+   tree inner;
+   int i;
+ 
+   /* We handle TREE_LIST and COMPONENT_REF separately.  */
+   if (code == TREE_LIST)
+     {
+       FIND_SUBSTITUTE_IN_EXPR (TREE_CHAIN (exp), substs);
+       FIND_SUBSTITUTE_IN_EXPR (TREE_VALUE (exp), substs);
+     }
+   else if (code == COMPONENT_REF)
+     {
+       for (inner = TREE_OPERAND (exp, 0);
+ 	   REFERENCE_CLASS_P (inner);
+ 	   inner = TREE_OPERAND (inner, 0))
+ 	;
+ 
+       if (TREE_CODE (inner) == PLACEHOLDER_EXPR)
+ 	push_without_duplicate (exp, substs);
+       else
+ 	FIND_SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), substs);
+    }
+   else
+     switch (TREE_CODE_CLASS (code))
+       {
+       case tcc_constant:
+ 	break;
+ 
+       case tcc_declaration:
+ 	/* Variables allocated to static storage can stay.  */
+         if (!TREE_STATIC (exp))
+ 	  push_without_duplicate (exp, substs);
+ 	break;
+ 
+       case tcc_expression:
+ 	/* This is the pattern built in ada/make_aligning_type.  */
+ 	if (code == ADDR_EXPR
+ 	    && TREE_CODE (TREE_OPERAND (exp, 0)) == PLACEHOLDER_EXPR)
+ 	  {
+ 	    push_without_duplicate (exp, substs);
+ 	    break;
+ 	  }
+ 
+         /* Fall through...  */
+ 
+       case tcc_exceptional:
+       case tcc_unary:
+       case tcc_binary:
+       case tcc_comparison:
+       case tcc_reference:
+ 	for (i = 0; i < TREE_CODE_LENGTH (code); i++)
+ 	  FIND_SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, i), substs);
+ 	break;
+ 
+       case tcc_vl_exp:
+ 	for (i = 1; i < VL_EXP_OPERAND_LENGTH (exp); i++)
+ 	  FIND_SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, i), substs);
+ 	break;
+ 
+       default:
+ 	gcc_unreachable ();
+       }
+ }
+ 
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and
!    CONST_DECLs.  Note that we assume here that EXP contains only
!    arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs
!    occurring only in their argument list.  */
  
  tree
  substitute_in_expr (tree exp, tree f, tree r)
*************** substitute_in_expr (tree exp, tree f, tr
*** 2436,2475 ****
        return tree_cons (TREE_PURPOSE (exp), op1, op0);
      }
    else if (code == COMPONENT_REF)
!    {
!      /* If this expression is getting a value from a PLACEHOLDER_EXPR
! 	and it is the right field, replace it with R.  */
!      for (inner = TREE_OPERAND (exp, 0);
! 	  REFERENCE_CLASS_P (inner);
! 	  inner = TREE_OPERAND (inner, 0))
!        ;
!      if (TREE_CODE (inner) == PLACEHOLDER_EXPR
! 	 && TREE_OPERAND (exp, 1) == f)
!        return r;
! 
!      /* If this expression hasn't been completed let, leave it alone.  */
!      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && TREE_TYPE (inner) == 0)
!        return exp;
! 
!      op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);
!      if (op0 == TREE_OPERAND (exp, 0))
!        return exp;
  
!      new = fold_build3 (COMPONENT_REF, TREE_TYPE (exp),
! 			op0, TREE_OPERAND (exp, 1), NULL_TREE);
     }
    else
      switch (TREE_CODE_CLASS (code))
        {
        case tcc_constant:
-       case tcc_declaration:
  	return exp;
  
        case tcc_exceptional:
        case tcc_unary:
        case tcc_binary:
        case tcc_comparison:
-       case tcc_expression:
        case tcc_reference:
  	switch (TREE_CODE_LENGTH (code))
  	  {
--- 2528,2579 ----
        return tree_cons (TREE_PURPOSE (exp), op1, op0);
      }
    else if (code == COMPONENT_REF)
!     {
!       /* If this expression is getting a value from a PLACEHOLDER_EXPR
! 	 and it is the right field, replace it with R.  */
!       for (inner = TREE_OPERAND (exp, 0);
! 	   REFERENCE_CLASS_P (inner);
! 	   inner = TREE_OPERAND (inner, 0))
! 	;
! 
!       /* The field.  */
!       op1 = TREE_OPERAND (exp, 1);
! 
!       if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)
! 	return r;
! 
!       /* If this expression hasn't been completed yet, leave it alone.  */
!       if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))
! 	return exp;
! 
!       op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);
!       if (op0 == TREE_OPERAND (exp, 0))
! 	return exp;
  
!       new = fold_build3 (code, TREE_TYPE (exp), op0, op1, NULL_TREE);
     }
    else
      switch (TREE_CODE_CLASS (code))
        {
        case tcc_constant:
  	return exp;
  
+       case tcc_declaration:
+ 	if (exp == f)
+ 	  return r;
+ 	else
+ 	  return exp;
+ 
+       case tcc_expression:
+ 	if (exp == f)
+ 	  return r;
+ 
+         /* Fall through...  */
+ 
        case tcc_exceptional:
        case tcc_unary:
        case tcc_binary:
        case tcc_comparison:
        case tcc_reference:
  	switch (TREE_CODE_LENGTH (code))
  	  {
*************** substitute_in_expr (tree exp, tree f, tr
*** 2530,2536 ****
  	  tree copy = NULL_TREE;
  	  int i;
  
! 	  for (i = 1; i < TREE_OPERAND_LENGTH (exp); i++)
  	    {
  	      tree op = TREE_OPERAND (exp, i);
  	      tree new_op = SUBSTITUTE_IN_EXPR (op, f, r);
--- 2634,2651 ----
  	  tree copy = NULL_TREE;
  	  int i;
  
! 	  /* If we are trying to replace F with a constant, inline back
! 	     functions which do nothing else than computing a value from
! 	     the arguments they are passed.  This makes it possible to
! 	     fold partially or entirely the replacement expression.  */
! 	  if (CONSTANT_CLASS_P (r) && code == CALL_EXPR)
! 	    {
! 	      tree t = maybe_inline_call_in_expr (exp);
! 	      if (t)
! 		return SUBSTITUTE_IN_EXPR (t, f, r);
! 	    }
! 
! 	  for (i = 1; i < VL_EXP_OPERAND_LENGTH (exp); i++)
  	    {
  	      tree op = TREE_OPERAND (exp, i);
  	      tree new_op = SUBSTITUTE_IN_EXPR (op, f, r);
*************** substitute_in_expr (tree exp, tree f, tr
*** 2553,2559 ****
  	gcc_unreachable ();
        }
  
!   TREE_READONLY (new) = TREE_READONLY (exp);
    return new;
  }
  
--- 2668,2674 ----
  	gcc_unreachable ();
        }
  
!   TREE_READONLY (new) |= TREE_READONLY (exp);
    return new;
  }
  
*************** substitute_placeholder_in_expr (tree exp
*** 2565,2570 ****
--- 2680,2686 ----
  {
    enum tree_code code = TREE_CODE (exp);
    tree op0, op1, op2, op3;
+   tree new;
  
    /* If this is a PLACEHOLDER_EXPR, see if we find a corresponding type
       in the chain of OBJ.  */
*************** substitute_placeholder_in_expr (tree exp
*** 2640,2647 ****
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
  	    if (op0 == TREE_OPERAND (exp, 0))
  	      return exp;
! 	    else
! 	      return fold_build1 (code, TREE_TYPE (exp), op0);
  
  	  case 2:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
--- 2756,2764 ----
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
  	    if (op0 == TREE_OPERAND (exp, 0))
  	      return exp;
! 
! 	    new = fold_build1 (code, TREE_TYPE (exp), op0);
! 	    break;
  
  	  case 2:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
*************** substitute_placeholder_in_expr (tree exp
*** 2649,2656 ****
  
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))
  	      return exp;
! 	    else
! 	      return fold_build2 (code, TREE_TYPE (exp), op0, op1);
  
  	  case 3:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
--- 2766,2774 ----
  
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))
  	      return exp;
! 
! 	    new = fold_build2 (code, TREE_TYPE (exp), op0, op1);
! 	    break;
  
  	  case 3:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
*************** substitute_placeholder_in_expr (tree exp
*** 2660,2667 ****
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)
  		&& op2 == TREE_OPERAND (exp, 2))
  	      return exp;
! 	    else
! 	      return fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);
  
  	  case 4:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
--- 2778,2786 ----
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)
  		&& op2 == TREE_OPERAND (exp, 2))
  	      return exp;
! 
! 	    new = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);
! 	    break;
  
  	  case 4:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
*************** substitute_placeholder_in_expr (tree exp
*** 2673,2680 ****
  		&& op2 == TREE_OPERAND (exp, 2)
  		&& op3 == TREE_OPERAND (exp, 3))
  	      return exp;
! 	    else
! 	      return fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));
  
  	  default:
  	    gcc_unreachable ();
--- 2792,2800 ----
  		&& op2 == TREE_OPERAND (exp, 2)
  		&& op3 == TREE_OPERAND (exp, 3))
  	      return exp;
! 
! 	    new = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));
! 	    break;
  
  	  default:
  	    gcc_unreachable ();
*************** substitute_placeholder_in_expr (tree exp
*** 2685,2711 ****
  	{
  	  tree copy = NULL_TREE;
  	  int i;
! 	  int n = TREE_OPERAND_LENGTH (exp);
! 	  for (i = 1; i < n; i++)
  	    {
  	      tree op = TREE_OPERAND (exp, i);
! 	      tree newop = SUBSTITUTE_PLACEHOLDER_IN_EXPR (op, obj);
! 	      if (newop != op)
  		{
  		  if (!copy)
  		    copy = copy_node (exp);
! 		  TREE_OPERAND (copy, i) = newop;
  		}
  	    }
  	  if (copy)
! 	    return fold (copy);
  	  else
  	    return exp;
  	}
  
        default:
  	gcc_unreachable ();
        }
  }
  
  /* Stabilize a reference so that we can use it any number of times
--- 2805,2836 ----
  	{
  	  tree copy = NULL_TREE;
  	  int i;
! 
! 	  for (i = 1; i < VL_EXP_OPERAND_LENGTH (exp); i++)
  	    {
  	      tree op = TREE_OPERAND (exp, i);
! 	      tree new_op = SUBSTITUTE_PLACEHOLDER_IN_EXPR (op, obj);
! 	      if (new_op != op)
  		{
  		  if (!copy)
  		    copy = copy_node (exp);
! 		  TREE_OPERAND (copy, i) = new_op;
  		}
  	    }
+ 
  	  if (copy)
! 	    new = fold (copy);
  	  else
  	    return exp;
  	}
+ 	break;
  
        default:
  	gcc_unreachable ();
        }
+ 
+   TREE_READONLY (new) |= TREE_READONLY (exp);
+   return new;
  }
  
  /* Stabilize a reference so that we can use it any number of times
*************** build1_stat (enum tree_code code, tree t
*** 3074,3093 ****
    return t;
  }
  
! #define PROCESS_ARG(N)			\
!   do {					\
!     TREE_OPERAND (t, N) = arg##N;	\
!     if (arg##N &&!TYPE_P (arg##N))	\
!       {					\
!         if (TREE_SIDE_EFFECTS (arg##N))	\
! 	  side_effects = 1;		\
!         if (!TREE_READONLY (arg##N))	\
! 	  read_only = 0;		\
!         if (!TREE_CONSTANT (arg##N))	\
! 	  constant = 0;			\
! 	if (!TREE_INVARIANT (arg##N))	\
! 	  invariant = 0;		\
!       }					\
    } while (0)
  
  tree
--- 3199,3219 ----
    return t;
  }
  
! #define PROCESS_ARG(N)				\
!   do {						\
!     TREE_OPERAND (t, N) = arg##N;		\
!     if (arg##N &&!TYPE_P (arg##N))		\
!       {						\
!         if (TREE_SIDE_EFFECTS (arg##N))		\
! 	  side_effects = 1;			\
!         if (!TREE_READONLY (arg##N)		\
! 	    && !CONSTANT_CLASS_P (arg##N))	\
! 	  read_only = 0;			\
!         if (!TREE_CONSTANT (arg##N))		\
! 	  constant = 0;				\
! 	if (!TREE_INVARIANT (arg##N))		\
! 	  invariant = 0;			\
!       }						\
    } while (0)
  
  tree
*************** build3_stat (enum tree_code code, tree t
*** 3175,3180 ****
--- 3301,3308 ----
    t = make_node_stat (code PASS_MEM_STAT);
    TREE_TYPE (t) = tt;
  
+   read_only = 1;
+ 
    /* As a special exception, if COND_EXPR has NULL branches, we
       assume that it is a gimple statement and always consider
       it to have side effects.  */
*************** build3_stat (enum tree_code code, tree t
*** 3190,3195 ****
--- 3318,3326 ----
    PROCESS_ARG(1);
    PROCESS_ARG(2);
  
+   if (code == COND_EXPR)
+     TREE_READONLY (t) = read_only;
+ 
    TREE_SIDE_EFFECTS (t) = side_effects;
    TREE_THIS_VOLATILE (t)
      = (TREE_CODE_CLASS (code) == tcc_reference
*************** build_omp_clause (enum omp_clause_code c
*** 7835,7844 ****
  static void
  process_call_operands (tree t)
  {
!   bool side_effects;
  
!   side_effects = TREE_SIDE_EFFECTS (t);
!   if (!side_effects)
      {
        int i, n;
        n = TREE_OPERAND_LENGTH (t);
--- 7966,7985 ----
  static void
  process_call_operands (tree t)
  {
!   bool side_effects = TREE_SIDE_EFFECTS (t);
!   bool read_only = false;
!   int i;
  
!   /* Calls have side-effects, except maybe those to const or
!      pure functions.  */
!   i = call_expr_flags (t);
!   if (!(i & (ECF_CONST | ECF_PURE)))
!     side_effects = true;
!   /* Propagate TREE_READONLY of arguments for const functions.  */
!   if (i & ECF_CONST)
!     read_only = true;
! 
!   if (!side_effects || read_only)
      {
        int i, n;
        n = TREE_OPERAND_LENGTH (t);
*************** process_call_operands (tree t)
*** 7846,7868 ****
  	{
  	  tree op = TREE_OPERAND (t, i);
  	  if (op && TREE_SIDE_EFFECTS (op))
! 	    {
! 	      side_effects = 1;
! 	      break;
! 	    }
  	}
      }
-   if (!side_effects)
-     {
-       int i;
  
-       /* Calls have side-effects, except those to const or
- 	 pure functions.  */
-       i = call_expr_flags (t);
-       if (!(i & (ECF_CONST | ECF_PURE)))
- 	side_effects = 1;
-     }
    TREE_SIDE_EFFECTS (t) = side_effects;
  }
  
  /* Build a tcc_vl_exp object with code CODE and room for LEN operands.  LEN
--- 7987,8000 ----
  	{
  	  tree op = TREE_OPERAND (t, i);
  	  if (op && TREE_SIDE_EFFECTS (op))
! 	    side_effects = true;
! 	  if (op && !TREE_READONLY (op) && !CONSTANT_CLASS_P (op))
! 	    read_only = false;
  	}
      }
  
    TREE_SIDE_EFFECTS (t) = side_effects;
+   TREE_READONLY (t) = read_only;
  }
  
  /* Build a tcc_vl_exp object with code CODE and room for LEN operands.  LEN
*** gcc/tree.h.0	2009-03-10 09:38:00.000000000 +0100
--- gcc/tree.h	2009-03-06 11:07:00.000000000 +0100
*************** extern tree round_down (tree, int);
*** 4380,4385 ****
--- 4380,4386 ----
  extern tree get_pending_sizes (void);
  extern void put_pending_size (tree);
  extern void put_pending_sizes (tree);
+ extern void finalize_size_functions (void);
  
  /* Type for sizes of data-type.  */
  
*************** extern bool contains_placeholder_p (cons
*** 4513,4522 ****
  
  extern bool type_contains_placeholder_p (tree);
  
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP
!    contains only arithmetic expressions.  */
  
  extern tree substitute_in_expr (tree, tree, tree);
  
--- 4514,4543 ----
  
  extern bool type_contains_placeholder_p (tree);
  
+ /* Given a tree EXP, find all occurences of references to fields
+    in a PLACEHOLDER_EXPR and place them in vector SUBSTS without
+    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that
+    we assume here that EXP contains only arithmetic expressions
+    or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their
+    argument list.  */
+ 
+ extern void find_substitute_in_expr (tree, VEC (tree, heap) **);
+ 
+ /* This macro calls the above function but short-circuits the common
+    case of a constant to save time and also checks for NULL.  */
+ 
+ #define FIND_SUBSTITUTE_IN_EXPR(EXP, V)	\
+ do {					\
+   if((EXP) && !TREE_CONSTANT (EXP))	\
+     find_substitute_in_expr (EXP, V);	\
+ } while (0)
+ 
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and
!    CONST_DECLs.  Note that we assume here that EXP contains only
!    arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs
!    occurring only in their argument list.  */
  
  extern tree substitute_in_expr (tree, tree, tree);
  
*** gcc/tree-inline.c.0	2009-03-10 09:38:00.000000000 +0100
--- gcc/tree-inline.c	2009-03-10 09:38:05.000000000 +0100
*************** remap_decl (tree decl, copy_body_data *i
*** 295,301 ****
        return t;
      }
  
!   return unshare_expr (*n);
  }
  
  static tree
--- 295,304 ----
        return t;
      }
  
!   if (id->do_not_unshare)
!     return *n;
!   else
!     return unshare_expr (*n);
  }
  
  static tree
*************** copy_body_r (tree *tp, int *walk_subtree
*** 600,609 ****
  	 If the "assignment" is just the result decl, the result
  	 decl has already been set (e.g. a recent "foo (&result_decl,
  	 ...)"); just toss the entire RETURN_EXPR.  */
!       if (assignment && TREE_CODE (assignment) == GIMPLE_MODIFY_STMT)
  	{
! 	  /* Replace the RETURN_EXPR with (a copy of) the
! 	     GIMPLE_MODIFY_STMT hanging underneath.  */
  	  *tp = copy_node (assignment);
  	}
        else /* Else the RETURN_EXPR returns no value.  */
--- 603,614 ----
  	 If the "assignment" is just the result decl, the result
  	 decl has already been set (e.g. a recent "foo (&result_decl,
  	 ...)"); just toss the entire RETURN_EXPR.  */
!       if (assignment
! 	  && (TREE_CODE (assignment) == MODIFY_EXPR
! 	      || TREE_CODE (assignment) == GIMPLE_MODIFY_STMT))
  	{
! 	  /* Replace the RETURN_EXPR with (a copy of) the MODIFY_EXPR
! 	     or the GIMPLE_MODIFY_STMT hanging underneath.  */
  	  *tp = copy_node (assignment);
  	}
        else /* Else the RETURN_EXPR returns no value.  */
*************** copy_body_r (tree *tp, int *walk_subtree
*** 717,723 ****
  		 but we absolutely rely on that.  As fold_indirect_ref
  	         does other useful transformations, try that first, though.  */
  	      tree type = TREE_TYPE (TREE_TYPE (*n));
! 	      new = unshare_expr (*n);
  	      old = *tp;
  	      *tp = gimple_fold_indirect_ref (new);
  	      if (! *tp)
--- 722,731 ----
  		 but we absolutely rely on that.  As fold_indirect_ref
  	         does other useful transformations, try that first, though.  */
  	      tree type = TREE_TYPE (TREE_TYPE (*n));
! 	      if (id->do_not_unshare)
! 		new = *n;
! 	      else
! 		new = unshare_expr (*n);
  	      old = *tp;
  	      *tp = gimple_fold_indirect_ref (new);
  	      if (! *tp)
*************** optimize_inline_calls (tree fn)
*** 3096,3101 ****
--- 3104,3163 ----
  	  | (profile_status != PROFILE_ABSENT ? TODO_rebuild_frequencies : 0));
  }
  
+ /* EXP is CALL_EXPR present in a GENERIC expression tree.  Try
+    to integrate it and return the inlined body on success.  */
+ 
+ tree
+ maybe_inline_call_in_expr (tree exp)
+ {
+   tree fn = get_callee_fndecl (exp);
+ 
+   /* We can only try to inline "const" functions.  */
+   if (fn && TREE_READONLY (fn) && DECL_SAVED_TREE (fn))
+     {
+       struct pointer_map_t *decl_map = pointer_map_create ();
+       call_expr_arg_iterator iter;
+       copy_body_data id;
+       tree param, arg, t;
+ 
+       /* Remap the parameters.  */
+       for (param = DECL_ARGUMENTS (fn), arg = first_call_expr_arg (exp, &iter);
+ 	   param;
+ 	   param = TREE_CHAIN (param), arg = next_call_expr_arg (&iter))
+ 	*pointer_map_insert (decl_map, param) = arg;
+ 
+       memset (&id, 0, sizeof (id));
+       id.src_fn = fn;
+       id.dst_fn = current_function_decl;
+       id.src_cfun = DECL_STRUCT_FUNCTION (fn);
+       id.decl_map = decl_map;
+ 
+       id.copy_decl = copy_decl_no_change;
+       id.transform_call_graph_edges = CB_CGE_DUPLICATE;
+       id.transform_new_cfg = false;
+       id.transform_return_to_modify = true;
+       id.transform_lang_insert_block = false;
+ 
+       /* Make sure not to unshare trees behind the front-end's back
+ 	 since front-end specific mechanisms may rely on sharing.  */
+       id.regimplify = false;
+       id.do_not_unshare = true;
+ 
+       /* We're not inside any EH region.  */
+       id.eh_region = -1;
+ 
+       t = copy_generic_body (&id);
+       pointer_map_destroy (decl_map);
+ 
+       /* We can only return something suitable for use
+ 	 in a GENERIC expression tree.  */
+       if (TREE_CODE (t) == MODIFY_EXPR)
+ 	return TREE_OPERAND (t, 1);
+     }
+ 
+   return NULL_TREE;
+ }
+ 
  /* FN is a function that has a complete body, and CLONE is a function whose
     body is to be set to a copy of FN, mapping argument declarations according
     to the ARG_MAP splay_tree.  */
*** gcc/tree-inline.h.0	2009-03-10 09:38:00.000000000 +0100
--- gcc/tree-inline.h	2009-03-06 11:07:00.000000000 +0100
*************** typedef struct copy_body_data
*** 98,103 ****
--- 98,106 ----
    /* True if this statement will need to be regimplified.  */
    bool regimplify;
  
+   /* True if trees should not be unshared.  */
+   bool do_not_unshare;
+ 
    /* > 0 if we are remapping a type currently.  */
    int remapping_type_depth;
  
*************** extern tree copy_body_r (tree *, int *, 
*** 145,150 ****
--- 148,154 ----
  extern void insert_decl_map (copy_body_data *, tree, tree);
  
  unsigned int optimize_inline_calls (tree);
+ tree maybe_inline_call_in_expr (tree);
  bool tree_inlinable_function_p (tree);
  tree copy_tree_r (tree *, int *, void *);
  void clone_body (tree, tree, void *);
*** gcc/function.h.0	2008-05-20 15:56:08.524878952 +0200
--- gcc/function.h	2008-05-20 15:57:41.666719240 +0200
*************** struct function GTY(())
*** 317,322 ****
--- 317,325 ----
    /* UIDs for LABEL_DECLs.  */
    int last_label_uid;
  
+   /* Number of tree constants deferred for this function.  */
+   unsigned int deferred_constants;
+ 
    /* Line number of the end of the function.  */
    location_t function_end_locus;
  
*************** extern void instantiate_decl_rtl (rtx x)
*** 537,542 ****
--- 540,546 ----
  #define dom_computed (cfun->cfg->x_dom_computed)
  #define n_bbs_in_dom_tree (cfun->cfg->x_n_bbs_in_dom_tree)
  #define VALUE_HISTOGRAMS(fun) (fun)->value_histograms
+ #define n_deferred_constants (cfun->deferred_constants)
  
  /* Given a function decl for a containing function,
     return the `struct function' for it.  */
*** gcc/tree.h.0	2008-05-20 15:56:08.528878344 +0200
--- gcc/tree.h	2008-05-20 15:56:14.422982304 +0200
*************** extern void internal_reference_types (vo
*** 5076,5081 ****
--- 5076,5082 ----
  extern unsigned int update_alignment_for_field (record_layout_info, tree,
                                                  unsigned int);
  /* varasm.c */
+ extern tree tree_output_constant_def (tree);
  extern void make_decl_rtl (tree);
  extern void make_decl_one_only (tree);
  extern int supports_one_only (void);
*** gcc/tree-inline.c.0	2008-05-20 15:56:08.548875304 +0200
--- gcc/tree-inline.c	2008-05-20 16:25:51.287857784 +0200
*************** expand_call_inline (basic_block bb, tree
*** 2870,2875 ****
--- 2870,2878 ----
  					       cfun->unexpanded_var_list);
      }
  
+   /* As well as deferred constants.  */
+   cfun->deferred_constants += id->src_cfun->deferred_constants;
+ 
    /* Clean up.  */
    pointer_map_destroy (id->decl_map);
    id->decl_map = st;
*** gcc/varasm.c.0	2008-05-27 14:53:50.338263776 +0200
--- gcc/varasm.c	2008-05-27 15:13:04.232845136 +0200
*************** struct varasm_status GTY(())
*** 74,87 ****
  {
    /* If we're using a per-function constant pool, this is it.  */
    struct rtx_constant_pool *pool;
- 
-   /* Number of tree-constants deferred during the expansion of this
-      function.  */
-   unsigned int deferred_constants;
  };
  
- #define n_deferred_constants (cfun->varasm->deferred_constants)
- 
  /* Number for making the label on the next
     constant that is stored in memory.  */
  
--- 74,81 ----
*************** struct constant_descriptor_tree GTY(())
*** 2720,2725 ****
--- 2714,2722 ----
    /* A MEM for the constant.  */
    rtx rtl;
  
+   /* A VAR_DECL for the constant.  */
+   tree decl;
+ 
    /* The value of the constant.  */
    tree value;
  
*************** build_constant_desc (tree exp)
*** 3115,3120 ****
--- 3112,3118 ----
  
    desc = ggc_alloc (sizeof (*desc));
    desc->value = copy_constant (exp);
+   desc->decl = NULL_TREE;
  
    /* Propagate marked-ness to copied constant.  */
    if (flag_mudflap && mf_marked_p (exp))
*************** lookup_constant_def (tree exp)
*** 3296,3301 ****
--- 3294,3352 ----
  
    return (desc ? desc->rtl : NULL_RTX);
  }
+ 
+ /* Return a tree representing a reference to constant data in memory
+    for the constant expression EXP.  This is the counterpart of
+    output_constant_def at the tree level.  */
+ 
+ tree
+ tree_output_constant_def (tree exp)
+ {
+   struct constant_descriptor_tree *desc;
+   struct constant_descriptor_tree key;
+   void **loc;
+ 
+   /* Look up EXP in the table of constant descriptors.  If we didn't find
+      it, create a new one.  */
+   key.value = exp;
+   key.hash = const_hash_1 (exp);
+   loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);
+ 
+   desc = *loc;
+   if (desc == 0)
+     {
+       desc = build_constant_desc (exp);
+       desc->hash = key.hash;
+       *loc = desc;
+     }
+ 
+   if (desc->decl == NULL_TREE)
+     {
+       tree var
+	= build_decl (VAR_DECL, get_identifier (XSTR (XEXP (desc->rtl, 0), 0)),
+		      TREE_TYPE (exp));
+       DECL_ARTIFICIAL (var) = 1;
+       DECL_IGNORED_P (var) = 1;
+       TREE_READONLY (var) = 1;
+       TREE_STATIC (var) = 1;
+       TREE_ADDRESSABLE (var) = 1;
+       /* Make sure objects referenced in the expression are not discarded,
+ 	 and pretend that the variable has already been expanded to RTL and
+ 	 assembled in order not to interfere with the varasm machinery.  */
+       DECL_INITIAL (var) = desc->value;
+       record_references_in_initializer (var);
+       SET_DECL_RTL (var, desc->rtl);
+       TREE_ASM_WRITTEN (var) = 1;
+       desc->decl = var;
+     }
+ 
+   /* See maybe_output_constant_def_contents.  We always defer
+      constants at the tree level.  */
+   if (cfun)
+     n_deferred_constants++;
+ 
+   return desc->decl;
+ }
  
  /* Used in the hash tables to avoid outputting the same constant
     twice.  Unlike 'struct constant_descriptor_tree', RTX constants
*************** init_varasm_status (struct function *f)
*** 3472,3478 ****
    f->varasm = p;
  
    p->pool = create_constant_pool ();
-   p->deferred_constants = 0;
  }
  
  /* Given a MINUS expression, simplify it if both sides
--- 3521,3526 ----
*** gcc/cfgexpand.c.0	2008-05-21 11:10:56.825180056 +0200
--- gcc/cfgexpand.c	2008-05-21 11:12:51.722712976 +0200
*************** tree_expand_cfg (void)
*** 1928,1936 ****
    /* We're done expanding trees to RTL.  */
    currently_expanding_to_rtl = 0;
  
!   /* Convert tree EH labels to RTL EH labels, and clean out any unreachable
!      EH regions.  */
    convert_from_eh_region_ranges ();
  
    rebuild_jump_labels (get_insns ());
    find_exception_handler_labels ();
--- 1928,1936 ----
    /* We're done expanding trees to RTL.  */
    currently_expanding_to_rtl = 0;
  
!   /* Convert tree EH labels to RTL EH labels and zap the tree EH table.  */
    convert_from_eh_region_ranges ();
+   set_eh_throw_stmt_table (cfun, NULL);
  
    rebuild_jump_labels (get_insns ());
    find_exception_handler_labels ();
*** gcc/expr.c.0	2008-05-22 12:12:53.000000000 +0200
--- gcc/expr.c	2008-05-22 12:22:20.000000000 +0200
*************** highest_pow2_factor (const_tree exp)
*** 6620,6625 ****
--- 6620,6632 ----
  	}
        break;
  
+     case BIT_AND_EXPR:
+       /* The highest power of two of a bit-and expression is the maximum of
+ 	 that of its operands.  We typically get here for a complex LHS and
+ 	 a constant negative power of two on the RHS to force an explicit
+ 	 alignment, so don't bother looking at the LHS.  */
+       return highest_pow2_factor (TREE_OPERAND (exp, 1));
+ 
      case NON_LVALUE_EXPR:  case NOP_EXPR:  case CONVERT_EXPR:
      case SAVE_EXPR:
        return highest_pow2_factor (TREE_OPERAND (exp, 0));
*** gcc/tree.h.0	2008-05-24 12:31:09.549720600 +0200
--- gcc/tree.h	2008-05-22 21:23:00.000000000 +0200
*************** extern void omp_clause_range_check_faile
*** 1163,1168 ****
--- 1163,1169 ----
  /* In a VAR_DECL, nonzero means allocate static storage.
     In a FUNCTION_DECL, nonzero if function has been defined.
     In a CONSTRUCTOR, nonzero means allocate static storage.
+    In a ADDR_EXPR, nonzero means do not use a trampoline.
  
     ??? This is also used in lots of other nodes in unclear ways which
     should be cleaned up some day.  */
*** gcc/tree-nested.c.0	2008-05-24 12:31:09.571717256 +0200
--- gcc/tree-nested.c	2008-05-24 12:31:25.120353504 +0200
*************** convert_tramp_reference (tree *tp, int *
*** 1742,1747 ****
--- 1742,1751 ----
        if (DECL_NO_STATIC_CHAIN (decl))
  	break;
  
+       /* If we don't want a trampoline, then don't build one.  */
+       if (TREE_STATIC (t))
+ 	break;
+ 
        /* Lookup the immediate parent of the callee, as that's where
  	 we need to insert the trampoline.  */
        for (i = info; i->context != target_context; i = i->outer)
*** gcc/varasm.c.0	2008-05-24 12:31:09.589714520 +0200
--- gcc/varasm.c	2008-05-24 12:43:15.746321936 +0200
*************** initializer_constant_valid_p (tree value
*** 4194,4218 ****
  
      case ADDR_EXPR:
      case FDESC_EXPR:
!       value = staticp (TREE_OPERAND (value, 0));
!       if (value)
! 	{
! 	  /* "&(*a).f" is like unto pointer arithmetic.  If "a" turns out to
! 	     be a constant, this is old-skool offsetof-like nonsense.  */
! 	  if (TREE_CODE (value) == INDIRECT_REF
! 	      && TREE_CONSTANT (TREE_OPERAND (value, 0)))
! 	    return null_pointer_node;
! 	  /* Taking the address of a nested function involves a trampoline.  */
! 	  if (TREE_CODE (value) == FUNCTION_DECL
! 	      && decl_function_context (value)
! 	      && !DECL_NO_STATIC_CHAIN (value))
! 	    return NULL_TREE;
! 	  /* "&{...}" requires a temporary to hold the constructed
! 	     object.  */
! 	  if (TREE_CODE (value) == CONSTRUCTOR)
! 	    return NULL_TREE;
! 	}
!       return value;
  
      case VIEW_CONVERT_EXPR:
      case NON_LVALUE_EXPR:
--- 4194,4222 ----
  
      case ADDR_EXPR:
      case FDESC_EXPR:
!       {
! 	tree op0 = staticp (TREE_OPERAND (value, 0));
! 	if (op0)
! 	  {
! 	    /* "&(*a).f" is like unto pointer arithmetic.  If "a" turns out
! 	       to be a constant, this is old-skool offsetof-like nonsense.  */
! 	    if (TREE_CODE (op0) == INDIRECT_REF
! 		&& TREE_CONSTANT (TREE_OPERAND (op0, 0)))
! 	      return null_pointer_node;
! 	    /* Taking the address of a nested function involves a trampoline,
! 	       unless we don't need or want one.  */
! 	    if (TREE_CODE (op0) == FUNCTION_DECL
! 		&& decl_function_context (op0)
! 		&& !DECL_NO_STATIC_CHAIN (op0)
! 		&& !TREE_STATIC (value))
! 	      return NULL_TREE;
! 	    /* "&{...}" requires a temporary to hold the constructed
! 	       object.  */
! 	    if (TREE_CODE (op0) == CONSTRUCTOR)
! 	      return NULL_TREE;
! 	  }
! 	return op0;
!       }
  
      case VIEW_CONVERT_EXPR:
      case NON_LVALUE_EXPR:
*** gcc/common.opt.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/common.opt	2008-05-24 20:34:56.000000000 +0200
*************** Wsystem-headers
*** 182,187 ****
--- 182,191 ----
  Common Var(warn_system_headers) Warning
  Do not suppress warnings from system headers
  
+ Wtrampolines
+ Common Var(warn_trampolines) Warning
+ Warn about trampolines generated for pointers to nested functions
+ 
  Wuninitialized
  Common Var(warn_uninitialized) Warning
  Warn about uninitialized automatic variables
*************** ftracer
*** 1035,1040 ****
--- 1039,1048 ----
  Common Report Var(flag_tracer)
  Perform superblock formation via tail duplication
  
+ ftrampolines
+ Common Report Var(flag_trampolines) Init(0)
+ Always generate trampolines for pointers to nested functions
+ 
  ; Zero means that floating-point math operations cannot generate a
  ; (user-visible) trap.  This is the case, for example, in nonstop
  ; IEEE 754 arithmetic.
*** gcc/opts.c.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/opts.c	2008-05-24 19:09:07.000000000 +0200
*************** decode_options (unsigned int argc, const
*** 994,999 ****
--- 994,1004 ----
        flag_reorder_blocks_and_partition = 0;
        flag_reorder_blocks = 1;
      }
+ 
+ #if !USE_RUNTIME_DESCRIPTORS
+   /* Do not generate runtime descriptors if they are not requested.  */
+   flag_trampolines = 1;
+ #endif
  }
  
  #define LEFT_COLUMN	27
*** gcc/doc/invoke.texi.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/doc/invoke.texi	2008-05-24 19:10:52.000000000 +0200
*************** Objective-C and Objective-C++ Dialects}.
*** 254,260 ****
  -Wstrict-aliasing -Wstrict-aliasing=n @gol
  -Wstrict-overflow -Wstrict-overflow=@var{n} @gol
  -Wswitch  -Wswitch-default  -Wswitch-enum @gol
! -Wsystem-headers  -Wtrigraphs  -Wtype-limits  -Wundef  -Wuninitialized @gol
  -Wunknown-pragmas  -Wno-pragmas -Wunreachable-code @gol
  -Wunused  -Wunused-function  -Wunused-label  -Wunused-parameter @gol
  -Wunused-value  -Wunused-variable @gol
--- 254,261 ----
  -Wstrict-aliasing -Wstrict-aliasing=n @gol
  -Wstrict-overflow -Wstrict-overflow=@var{n} @gol
  -Wswitch  -Wswitch-default  -Wswitch-enum @gol
! -Wsystem-headers  -Wtrampolines  -Wtrigraphs  @gol
! -Wtype-limits  -Wundef  -Wuninitialized @gol
  -Wunknown-pragmas  -Wno-pragmas -Wunreachable-code @gol
  -Wunused  -Wunused-function  -Wunused-label  -Wunused-parameter @gol
  -Wunused-value  -Wunused-variable @gol
*************** See S/390 and zSeries Options.
*** 827,833 ****
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fargument-noalias-anything @gol
  -fleading-underscore  -ftls-model=@var{model} @gol
! -ftrapv  -fwrapv  -fbounds-check @gol
  -fvisibility}
  @end table
  
--- 828,834 ----
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fargument-noalias-anything @gol
  -fleading-underscore  -ftls-model=@var{model} @gol
! -ftrampolines  -ftrapv  -fwrapv  -fbounds-check @gol
  -fvisibility}
  @end table
  
*************** This option causes the compiler to abort
*** 2588,2593 ****
--- 2589,2603 ----
  occurred rather than trying to keep going and printing further error
  messages.
  
+ @item -Wtrampolines
+ Warn about trampolines generated for pointers to nested functions.
+ 
+ A trampoline is a small piece of data or code that is created at run
+ time on the stack when the address of a nested function is taken, and
+ is used to call the nested function indirectly.  For some targets, it
+ is made up of data only and thus requires no special treatment.  But,
+ for most targets, it is made up of code and thus requires the stack
+ to be made executable in order for the program to work properly.
  @end table
  
  You can request many specific warnings with options beginning
*************** The @var{model} argument should be one o
*** 15262,15267 ****
--- 15272,15301 ----
  The default without @option{-fpic} is @code{initial-exec}; with
  @option{-fpic} the default is @code{global-dynamic}.
  
+ @item -ftrampolines
+ Always generate trampolines for pointers to nested functions.
+ 
+ A trampoline is a small piece of data or code that is created at run
+ time on the stack when the address of a nested function is taken, and
+ is used to call the nested function indirectly.  For some targets, it
+ is made up of data only and thus requires no special treatment.  But,
+ for most targets, it is made up of code and thus requires the stack
+ to be made executable in order for the program to work properly.
+ 
+ @option{-fno-trampolines} is enabled by default to let the compiler avoid
+ generating them if it computes that this is safe, on a case by case basis,
+ and replace them with descriptors.  Descriptors are always made up of data
+ only, but the generated code must be prepared to deal with them.
+ 
+ This option has no effects for any other languages than Ada as of this
+ writing.  Moreover, code compiled with @option{-ftrampolines} and code
+ compiled with @option{-fno-trampolines} are not binary compatible if
+ nested functions are present.  This option must therefore be used on
+ a program-wide basis and be manipulated with extreme care.
+ 
+ This option has no effects for targets whose trampolines are made up of
+ data only, for example IA-64 targets, AIX or VMS platforms.
+ 
  @item -fvisibility=@var{default|internal|hidden|protected}
  @opindex fvisibility
  Set the default ELF image symbol visibility to the specified option---all
*** gcc/doc/tm.texi.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/doc/tm.texi	2008-05-24 19:09:07.000000000 +0200
*************** global.  Then trampolines can use that l
*** 5100,5105 ****
--- 5100,5117 ----
  special assembler code.
  @end defmac
  
+ @defmac USE_RUNTIME_DESCRIPTORS
+ Define this macro to 1 if the target will benefit from the use of runtime
+ descriptors instead of trampolines.  Such descriptors are created at run
+ time on the stack and made up of data only, but the generated code must be
+ prepared to deal with them.  Define this macro to 0 if the target already
+ uses descriptors for its standard calling sequence, which very likely means
+ that trampolines need not reside on the stack.
+ 
+ The macro should be defined to 1 for targets whose trampolines reside on
+ the stack, thus requiring it to be made executable.
+ @end defmac
+ 
  @node Library Calls
  @section Implicit Calls to Library Routines
  @cindex library subroutine names
*** gcc/builtins.def.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/builtins.def	2008-05-24 19:09:07.000000000 +0200
*************** DEF_C99_BUILTIN        (BUILT_IN__EXIT2,
*** 710,715 ****
--- 710,717 ----
  /* Implementing nested functions.  */
  DEF_BUILTIN_STUB (BUILT_IN_INIT_TRAMPOLINE, "__builtin_init_trampoline")
  DEF_BUILTIN_STUB (BUILT_IN_ADJUST_TRAMPOLINE, "__builtin_adjust_trampoline")
+ DEF_BUILTIN_STUB (BUILT_IN_INIT_DESCRIPTOR, "__builtin_init_descriptor")
+ DEF_BUILTIN_STUB (BUILT_IN_ADJUST_DESCRIPTOR, "__builtin_adjust_descriptor")
  DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, "__builtin_nonlocal_goto")
  
  /* Implementing __builtin_setjmp.  */
*** gcc/builtins.c.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/builtins.c	2008-05-24 20:42:10.000000000 +0200
*************** expand_builtin_init_trampoline (tree exp
*** 5657,5663 ****
    emit_block_move (blktramp, assemble_trampoline_template (),
  		   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
  #endif
-   trampolines_created = 1;
    INITIALIZE_TRAMPOLINE (r_tramp, r_func, r_chain);
  
    return const0_rtx;
--- 5657,5662 ----
*************** expand_builtin_adjust_trampoline (tree e
*** 5680,5685 ****
--- 5679,5734 ----
    return tramp;
  }
  
+ #if USE_RUNTIME_DESCRIPTORS
+ 
+ /* Expand a call to the builtin descriptor initialization routine.
+    A descriptor is made up of a couple of pointers to the static
+    chain and the code entry in this order.  */
+ 
+ static rtx
+ expand_builtin_init_descriptor (tree exp)
+ {
+   tree t_tramp, t_func, t_chain;
+   rtx r_tramp, r_func, r_chain;
+ 
+   if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, POINTER_TYPE,
+ 			 VOID_TYPE))
+     return NULL_RTX;
+ 
+   t_tramp = CALL_EXPR_ARG (exp, 0);
+   t_func = CALL_EXPR_ARG (exp, 1);
+   t_chain = CALL_EXPR_ARG (exp, 2);
+ 
+   r_tramp = expand_normal (t_tramp);
+   r_func = expand_normal (t_func);
+   r_chain = expand_normal (t_chain);
+ 
+   /* Generate insns to initialize the descriptor.  */
+   emit_move_insn (gen_rtx_MEM (Pmode, r_tramp), r_chain);
+   emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (r_tramp, UNITS_PER_WORD)),
+ 		  r_func);
+ 
+   return const0_rtx;
+ }
+ 
+ /* Expand a call to the builtin descriptor adjustment routine.  */
+ 
+ static rtx
+ expand_builtin_adjust_descriptor (tree exp)
+ {
+   rtx tramp;
+ 
+   if (!validate_arglist (exp, POINTER_TYPE, VOID_TYPE))
+     return NULL_RTX;
+ 
+   tramp = expand_normal (CALL_EXPR_ARG (exp, 0));
+ 
+   /* Unalign the descriptor to allow runtime identification.  */
+   return force_operand (plus_constant (tramp, 1), NULL_RTX);
+ }
+ 
+ #endif /* USE_RUNTIME_DESCRIPTORS */
+ 
  /* Expand the call EXP to the built-in signbit, signbitf or signbitl
     function.  The function first checks whether the back end provides
     an insn to implement signbit for the respective mode.  If not, it
*************** expand_builtin (tree exp, rtx target, rt
*** 6724,6729 ****
--- 6773,6791 ----
      case BUILT_IN_ADJUST_TRAMPOLINE:
        return expand_builtin_adjust_trampoline (exp);
  
+     case BUILT_IN_INIT_DESCRIPTOR:
+ #if USE_RUNTIME_DESCRIPTORS
+       return expand_builtin_init_descriptor (exp);
+ #else
+       gcc_unreachable ();
+ #endif
+     case BUILT_IN_ADJUST_DESCRIPTOR:
+ #if USE_RUNTIME_DESCRIPTORS
+       return expand_builtin_adjust_descriptor (exp);
+ #else
+       gcc_unreachable ();
+ #endif
+ 
      case BUILT_IN_FORK:
      case BUILT_IN_EXECL:
      case BUILT_IN_EXECV:
*** gcc/calls.c.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/calls.c	2008-05-24 19:15:26.000000000 +0200
*************** static void restore_fixed_argument_area 
*** 165,181 ****
  
  rtx
  prepare_call_address (rtx funexp, rtx static_chain_value,
! 		      rtx *call_fusage, int reg_parm_seen, int sibcallp)
  {
    /* Make a valid memory address and copy constants through pseudo-regs,
       but not for a constant address if -fno-function-cse.  */
    if (GET_CODE (funexp) != SYMBOL_REF)
!     /* If we are using registers for parameters, force the
!        function address into a register now.  */
!     funexp = ((SMALL_REGISTER_CLASSES && reg_parm_seen)
! 	      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))
! 	      : memory_address (FUNCTION_MODE, funexp));
!   else if (! sibcallp)
      {
  #ifndef NO_FUNCTION_CSE
        if (optimize && ! flag_no_function_cse)
--- 165,227 ----
  
  rtx
  prepare_call_address (rtx funexp, rtx static_chain_value,
! 		      rtx *call_fusage, int reg_parm_seen, int flags)
  {
    /* Make a valid memory address and copy constants through pseudo-regs,
       but not for a constant address if -fno-function-cse.  */
    if (GET_CODE (funexp) != SYMBOL_REF)
!     {
! #if USE_RUNTIME_DESCRIPTORS
!       /* If it's an indirect call by descriptor, generate code to perform
! 	 runtime identification of the pointer and load the descriptor.  */
!       if (!flag_trampolines && (flags & ECF_BY_DESCRIPTOR))
! 	{
! 	  rtx mask, insn, mem, call_lab = gen_label_rtx ();
! 
! 	  /* Avoid long live ranges around function calls.  */
! 	  funexp = copy_to_mode_reg (Pmode, funexp);
! 
! 	  if (REG_P (static_chain_rtx))
! 	    emit_insn (gen_rtx_CLOBBER (VOIDmode, static_chain_rtx));
! 
! 	  /* Emit the runtime identification pattern.  */
! 	  mask = gen_rtx_AND (Pmode, funexp, const1_rtx);
! 	  emit_cmp_and_jump_insns (mask, const0_rtx, EQ, NULL_RTX, Pmode, 1,
! 				   call_lab);
! 
! 	  /* Statically predict the branch to very likely taken.  */
! 	  insn = get_last_insn ();
! 	  if (JUMP_P (insn))
! 	    predict_insn_def (insn, PRED_BUILTIN_EXPECT, TAKEN);
! 
! 	  /* Load the descriptor.  */
! 	  mem = gen_rtx_MEM (Pmode, plus_constant (funexp, -1));
! 	  MEM_NOTRAP_P (mem) = 1;
! 	  emit_move_insn (static_chain_rtx, mem);
! 	  mem = gen_rtx_MEM (Pmode,
! 			     plus_constant (funexp, UNITS_PER_WORD - 1));
! 	  MEM_NOTRAP_P (mem) = 1;
! 	  emit_move_insn (funexp, mem);
! 
! 	  emit_label (call_lab);
! 
! 	  if (REG_P (static_chain_rtx))
! 	    use_reg (call_fusage, static_chain_rtx);
! 
! 	  /* Make sure we're not going to be overwritten below.  */
! 	  gcc_assert (!static_chain_value);
! 	}
! #endif /* USE_RUNTIME_DESCRIPTORS */
! 
!       /* If we are using registers for parameters, force the
! 	 function address into a register now.  */
!       funexp = ((SMALL_REGISTER_CLASSES && reg_parm_seen)
! 		? force_not_mem (memory_address (FUNCTION_MODE, funexp))
! 		: memory_address (FUNCTION_MODE, funexp));
! 
!     }
! 
!   else if (!(flags & ECF_SIBCALL))
      {
  #ifndef NO_FUNCTION_CSE
        if (optimize && ! flag_no_function_cse)
*************** call_expr_flags (const_tree t)
*** 625,635 ****
      flags = flags_from_decl_or_type (decl);
    else
      {
!       t = TREE_TYPE (CALL_EXPR_FN (t));
!       if (t && TREE_CODE (t) == POINTER_TYPE)
! 	flags = flags_from_decl_or_type (TREE_TYPE (t));
        else
  	flags = 0;
      }
  
    return flags;
--- 671,683 ----
      flags = flags_from_decl_or_type (decl);
    else
      {
!       tree type = TREE_TYPE (CALL_EXPR_FN (t));
!       if (type && TREE_CODE (type) == POINTER_TYPE)
! 	flags = flags_from_decl_or_type (TREE_TYPE (type));
        else
  	flags = 0;
+       if (CALL_EXPR_BY_DESCRIPTOR (t))
+ 	flags |= ECF_BY_DESCRIPTOR;
      }
  
    return flags;
*************** expand_call (tree exp, rtx target, int i
*** 2021,2026 ****
--- 2069,2076 ----
      {
        fntype = TREE_TYPE (TREE_TYPE (p));
        flags |= flags_from_decl_or_type (fntype);
+       if (CALL_EXPR_BY_DESCRIPTOR (exp))
+ 	flags |= ECF_BY_DESCRIPTOR;
      }
  
    struct_value = targetm.calls.struct_value_rtx (fntype, 0);
*************** expand_call (tree exp, rtx target, int i
*** 2755,2761 ****
  
        after_args = get_last_insn ();
        funexp = prepare_call_address (funexp, static_chain_value,
! 				     &call_fusage, reg_parm_seen, pass == 0);
  
        load_register_parameters (args, num_actuals, &call_fusage, flags,
  				pass == 0, &sibcall_failure);
--- 2805,2811 ----
  
        after_args = get_last_insn ();
        funexp = prepare_call_address (funexp, static_chain_value,
! 				     &call_fusage, reg_parm_seen, flags);
  
        load_register_parameters (args, num_actuals, &call_fusage, flags,
  				pass == 0, &sibcall_failure);
*** gcc/rtlanal.c.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/rtlanal.c	2008-05-24 19:09:07.000000000 +0200
*************** find_first_parameter_load (rtx call_insn
*** 3359,3364 ****
--- 3359,3371 ----
           CODE_LABEL.  */
        if (LABEL_P (before))
  	{
+ #if USE_RUNTIME_DESCRIPTORS
+ 	  /* Look for the conditional load of the static chain register.  */
+ 	  if (!boundary
+ 	      && parm.nregs == 1
+ 	      && TEST_HARD_REG_BIT (parm.regs, STATIC_CHAIN_REGNUM))
+ 	    continue;
+ #endif
  	  gcc_assert (before == boundary);
  	  break;
  	}
*** gcc/tree.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/tree.h	2008-05-22 21:23:00.000000000 +0200
*************** struct gimple_stmt GTY(())
*** 589,594 ****
--- 589,600 ----
         TYPE_SATURATING in
             all types
  
+        FUNC_ADDR_BY_DESCRIPTOR in
+            ADDR_EXPR
+ 
+        CALL_EXPR_BY_DESCRIPTOR in
+            CALL_EXPR
+ 
     nowarning_flag:
  
         TREE_NO_WARNING in
*************** extern void omp_clause_range_check_faile
*** 1381,1386 ****
--- 1387,1402 ----
  /* In fixed-point types, means a saturating type.  */
  #define TYPE_SATURATING(NODE) ((NODE)->base.saturating_flag)
  
+ /* In an ADDR_EXPR, indicates that this is a pointer to nested function
+    represented by a descriptor instead of a trampoline.  */
+ #define FUNC_ADDR_BY_DESCRIPTOR(NODE) \
+   (TREE_CHECK (NODE, ADDR_EXPR)->base.saturating_flag)
+ 
+ /* In a CALL_EXPR, indicates that this is an indirect call for which
+    pointers to nested function are descriptors instead of trampolines.  */
+ #define CALL_EXPR_BY_DESCRIPTOR(NODE) \
+   (TREE_CHECK (NODE, CALL_EXPR)->base.saturating_flag)
+ 
  /* These flags are available for each language front end to use internally.  */
  #define TREE_LANG_FLAG_0(NODE) ((NODE)->base.lang_flag_0)
  #define TREE_LANG_FLAG_1(NODE) ((NODE)->base.lang_flag_1)
*************** extern tree build_duplicate_type (tree);
*** 5043,5048 ****
--- 5059,5066 ----
  /* Function does not read or write memory (but may have side effects, so
     it does not necessarily fit ECF_CONST).  */
  #define ECF_NOVOPS		1024
+ /* Nonzero if this is an indirect call by descriptor.  */
+ #define ECF_BY_DESCRIPTOR	2048
  
  extern int flags_from_decl_or_type (const_tree);
  extern int call_expr_flags (const_tree);
*** gcc/tree.c.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/tree.c	2008-05-24 20:21:39.000000000 +0200
*************** make_node_stat (enum tree_code code MEM_
*** 592,598 ****
  	{
  	  if (code == FUNCTION_DECL)
  	    {
! 	      DECL_ALIGN (t) = FUNCTION_BOUNDARY;
  	      DECL_MODE (t) = FUNCTION_MODE;
  	    }
  	  else
--- 592,603 ----
  	{
  	  if (code == FUNCTION_DECL)
  	    {
! 	      /* Force minimum alignment to use the least significant bit
! 		 to distinguish descriptor addresses from code addresses.  */
! 	      if (!flag_trampolines && FUNCTION_BOUNDARY < 2 * BITS_PER_UNIT)
! 		DECL_ALIGN (t) = 2 * BITS_PER_UNIT;
! 	      else
! 		DECL_ALIGN (t) = FUNCTION_BOUNDARY;
  	      DECL_MODE (t) = FUNCTION_MODE;
  	    }
  	  else
*************** build_common_builtin_nodes (void)
*** 7679,7684 ****
--- 7684,7704 ----
  
    tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
    tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
+   tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
+   ftype = build_function_type (void_type_node, tmp);
+   local_define_builtin ("__builtin_init_descriptor", ftype,
+ 			BUILT_IN_INIT_DESCRIPTOR,
+ 			"__builtin_init_descriptor", ECF_NOTHROW);
+ 
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   ftype = build_function_type (ptr_type_node, tmp);
+   local_define_builtin ("__builtin_adjust_descriptor", ftype,
+ 			BUILT_IN_ADJUST_DESCRIPTOR,
+ 			"__builtin_adjust_descriptor",
+ 			ECF_CONST | ECF_NOTHROW);
+ 
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
    ftype = build_function_type (void_type_node, tmp);
    local_define_builtin ("__builtin_nonlocal_goto", ftype,
  			BUILT_IN_NONLOCAL_GOTO,
*** gcc/tree-nested.c.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/tree-nested.c	2008-05-24 23:10:19.000000000 +0200
***************
*** 32,37 ****
--- 32,38 ----
  #include "tree-flow.h"
  #include "cgraph.h"
  #include "expr.h"
+ #include "toplev.h"
  #include "langhooks.h"
  #include "pointer-set.h"
  #include "ggc.h"
*************** struct nesting_info
*** 99,104 ****
--- 100,106 ----
  
    bool any_parm_remapped;
    bool any_tramp_created;
+   bool any_descr_created;
    bool reachable;
    char static_chain_added;
  };
*************** get_trampoline_type (void)
*** 451,462 ****
    return trampoline_type;
  }
  
! /* Given DECL, a nested function, find or create a field in the non-local
!    frame structure for a trampoline for this function.  */
  
  static tree
! lookup_tramp_for_decl (struct nesting_info *info, tree decl,
! 		       enum insert_option insert)
  {
    void **slot;
  
--- 453,490 ----
    return trampoline_type;
  }
  
! /* Build or return the type used to represent a nested function descriptor.  */
! 
! static GTY(()) tree descriptor_type;
  
  static tree
! get_descriptor_type (void)
! {
!   tree t;
! 
!   if (descriptor_type)
!     return descriptor_type;
! 
!   t = build_index_type (build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1));
!   t = build_array_type (char_type_node, t);
!   t = build_decl (FIELD_DECL, get_identifier ("__data"), t);
!   DECL_ALIGN (t) = BITS_PER_WORD;
!   DECL_USER_ALIGN (t) = 1;
! 
!   descriptor_type = make_node (RECORD_TYPE);
!   TYPE_NAME (descriptor_type) = get_identifier ("__builtin_descriptor");
!   TYPE_FIELDS (descriptor_type) = t;
!   layout_type (descriptor_type);
! 
!   return descriptor_type;
! }
! 
! /* Given DECL, a nested function, find or create an element in the
!    var map for this function.  */
! 
! static tree
! lookup_element_for_decl (struct nesting_info *info, tree decl,
! 			 enum insert_option insert)
  {
    void **slot;
  
*************** lookup_tramp_for_decl (struct nesting_in
*** 468,487 ****
  
    slot = pointer_map_insert (info->var_map, decl);
    if (!*slot)
!     {
!       tree field = make_node (FIELD_DECL);
!       DECL_NAME (field) = DECL_NAME (decl);
!       TREE_TYPE (field) = get_trampoline_type ();
!       TREE_ADDRESSABLE (field) = 1;
  
!       insert_field_into_struct (get_frame_type (info), field);
!       *slot = field;
  
        info->any_tramp_created = true;
      }
  
!   return *slot;
! } 
  
  /* Build or return the field within the non-local frame state that holds
     the non-local goto "jmp_buf".  The buffer itself is maintained by the
--- 496,569 ----
  
    slot = pointer_map_insert (info->var_map, decl);
    if (!*slot)
!     *slot = build_tree_list (NULL_TREE, NULL_TREE);
  
!   return *slot;
! } 
! 
! /* Given DECL, a nested function, create a field in the non-local
!    frame structure for this function.  */
! 
! static tree
! create_field_for_decl (struct nesting_info *info, tree decl, tree type)
! {
!   tree field = make_node (FIELD_DECL);
!   DECL_NAME (field) = DECL_NAME (decl);
!   TREE_TYPE (field) = type;
!   TREE_ADDRESSABLE (field) = 1;
!   insert_field_into_struct (get_frame_type (info), field);
!   return field;
! }
! 
! /* Given DECL, a nested function, find or create a field in the non-local
!    frame structure for a trampoline for this function.  */
  
+ static tree
+ lookup_tramp_for_decl (struct nesting_info *info, tree decl,
+ 		       enum insert_option insert)
+ {
+   tree elt, field;
+ 
+   elt = lookup_element_for_decl (info, decl, insert);
+   if (!elt)
+     return NULL_TREE;
+ 
+   field = TREE_PURPOSE (elt);
+ 
+   if (!field && insert == INSERT)
+     {
+       field = create_field_for_decl (info, decl, get_trampoline_type ());
+       TREE_PURPOSE (elt) = field;
        info->any_tramp_created = true;
      }
  
!   return field;
! }
! 
! /* Given DECL, a nested function, find or create a field in the non-local
!    frame structure for a descriptor for this function.  */
! 
! static tree
! lookup_descr_for_decl (struct nesting_info *info, tree decl,
! 		       enum insert_option insert)
! {
!   tree elt, field;
! 
!   elt = lookup_element_for_decl (info, decl, insert);
!   if (!elt)
!     return NULL_TREE;
! 
!   field = TREE_VALUE (elt);
! 
!   if (!field && insert == INSERT)
!     {
!       field = create_field_for_decl (info, decl, get_descriptor_type ());
!       TREE_VALUE (elt) = field;
!       info->any_descr_created = true;
!     }
! 
!   return field;
! }
  
  /* Build or return the field within the non-local frame state that holds
     the non-local goto "jmp_buf".  The buffer itself is maintained by the
*************** convert_tramp_reference (tree *tp, int *
*** 1716,1722 ****
  {
    struct walk_stmt_info *wi = (struct walk_stmt_info *) data;
    struct nesting_info *info = wi->info, *i;
!   tree t = *tp, decl, target_context, x;
  
    *walk_subtrees = 0;
    switch (TREE_CODE (t))
--- 1798,1805 ----
  {
    struct walk_stmt_info *wi = (struct walk_stmt_info *) data;
    struct nesting_info *info = wi->info, *i;
!   tree t = *tp, decl, target_context, x, f;
!   bool descr;
  
    *walk_subtrees = 0;
    switch (TREE_CODE (t))
*************** convert_tramp_reference (tree *tp, int *
*** 1750,1756 ****
  	 we need to insert the trampoline.  */
        for (i = info; i->context != target_context; i = i->outer)
  	continue;
!       x = lookup_tramp_for_decl (i, decl, INSERT);
  
        /* Compute the address of the field holding the trampoline.  */
        x = get_frame_field (info, target_context, x, &wi->tsi);
--- 1833,1874 ----
  	 we need to insert the trampoline.  */
        for (i = info; i->context != target_context; i = i->outer)
  	continue;
! 
!       /* Decide whether to generate a descriptor or a trampoline. */
!       descr = !flag_trampolines && FUNC_ADDR_BY_DESCRIPTOR (t);
!       if (descr)
! 	x = lookup_descr_for_decl (i, decl, INSERT);
!       else
! 	{
! 	  x = lookup_tramp_for_decl (i, decl, INSERT);
! 	  trampolines_created = 1;
! 	  if (warn_trampolines)
! 	    {
! #ifdef USE_MAPPED_LOCATION
! 	      source_location location = EXPR_LOCATION (t);
! #else
! 	      location_t * locus = EXPR_LOCUS (t);
! #endif
! 	      tree save_context = current_function_decl;
! 	      current_function_decl = info->context;
! 	      warning (OPT_Wtrampolines, "trampoline generated for %q+F",
! 		       decl);
! #ifdef USE_MAPPED_LOCATION
! 	      if (location == UNKNOWN_LOCATION)
! #else
! 	      if (locus == NULL)
! #endif
! 	        warning (OPT_Wtrampolines, "address taken from here");
! 	      else
! 		warning (OPT_Wtrampolines, "%Haddress taken from here",
! #ifdef USE_MAPPED_LOCATION
! 			 &location);
! #else
! 			 locus);
! #endif
! 	      current_function_decl = save_context;
! 	    }
! 	}
  
        /* Compute the address of the field holding the trampoline.  */
        x = get_frame_field (info, target_context, x, &wi->tsi);
*************** convert_tramp_reference (tree *tp, int *
*** 1759,1766 ****
  
        /* Do machine-specific ugliness.  Normally this will involve
  	 computing extra alignment, but it can really be anything.  */
!       x = build_call_expr (implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE],
! 			   1, x);
        x = init_tmp_var (info, x, &wi->tsi);
  
        /* Cast back to the proper function type.  */
--- 1877,1887 ----
  
        /* Do machine-specific ugliness.  Normally this will involve
  	 computing extra alignment, but it can really be anything.  */
!       if (descr)
! 	f = implicit_built_in_decls[BUILT_IN_ADJUST_DESCRIPTOR];
!       else
! 	f = implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE];
!       x = build_call_expr (f, 1, x);
        x = init_tmp_var (info, x, &wi->tsi);
  
        /* Cast back to the proper function type.  */
*************** convert_all_function_calls (struct nesti
*** 1900,1905 ****
--- 2021,2049 ----
      }
  }
  
+ /* Given DECL, a nested function, build an initialization call for FIELD,
+    the trampoline or descriptor for DECL, using FUNC as the function.  */
+ 
+ static tree
+ build_init_call_expr (struct nesting_info *info, tree decl, tree field,
+ 		      tree func)
+ {
+   tree arg1, arg2, arg3, x;
+ 
+   if (DECL_NO_STATIC_CHAIN (decl))
+     arg3 = null_pointer_node;
+   else
+     arg3 = build_addr (info->frame_decl, info->context);
+ 
+   arg2 = build_addr (decl, info->context);
+ 
+   x = build3 (COMPONENT_REF, TREE_TYPE (field),
+ 	      info->frame_decl, field, NULL_TREE);
+   arg1 = build_addr (x, info->context);
+ 
+   return build_call_expr (func, 3, arg1, arg2, arg3);
+ }
+ 
  /* Do "everything else" to clean up or complete state collected by the
     various walking passes -- lay out the types and decls, generate code
     to initialize the frame decl, store critical expressions in the
*************** finalize_nesting_tree_1 (struct nesting_
*** 1967,1991 ****
        struct nesting_info *i;
        for (i = root->inner; i ; i = i->next)
  	{
! 	  tree arg1, arg2, arg3, x, field;
  
  	  field = lookup_tramp_for_decl (root, i->context, NO_INSERT);
  	  if (!field)
  	    continue;
  
! 	  if (DECL_NO_STATIC_CHAIN (i->context))
! 	    arg3 = null_pointer_node;
! 	  else
! 	    arg3 = build_addr (root->frame_decl, context);
  
! 	  arg2 = build_addr (i->context, context);
  
! 	  x = build3 (COMPONENT_REF, TREE_TYPE (field),
! 		      root->frame_decl, field, NULL_TREE);
! 	  arg1 = build_addr (x, context);
  
! 	  x = implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE];
! 	  x = build_call_expr (x, 3, arg1, arg2, arg3);
  	  append_to_statement_list (x, &stmt_list);
  	}
      }
--- 2111,2142 ----
        struct nesting_info *i;
        for (i = root->inner; i ; i = i->next)
  	{
! 	  tree field, x;
  
  	  field = lookup_tramp_for_decl (root, i->context, NO_INSERT);
  	  if (!field)
  	    continue;
  
! 	  x = implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE];
! 	  x = build_init_call_expr (root, i->context, field, x);
! 	  append_to_statement_list (x, &stmt_list);
! 	}
!     }
  
!   /* If descriptors were created, then we need to initialize them.  */
!   if (root->any_descr_created)
!     {
!       struct nesting_info *i;
!       for (i = root->inner; i ; i = i->next)
! 	{
! 	  tree field, x;
  
! 	  field = lookup_descr_for_decl (root, i->context, NO_INSERT);
! 	  if (!field)
! 	    continue;
  
! 	  x = implicit_built_in_decls[BUILT_IN_INIT_DESCRIPTOR];
! 	  x = build_init_call_expr (root, i->context, field, x);
  	  append_to_statement_list (x, &stmt_list);
  	}
      }
*** gcc/defaults.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/defaults.h	2008-05-24 19:09:07.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 882,891 ****
  #define CASE_VECTOR_PC_RELATIVE 0
  #endif
  
! /* Assume that trampolines need function alignment.  */
  #ifndef TRAMPOLINE_ALIGNMENT
  #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY
  #endif
  
  /* Register mappings for target machines without register windows.  */
  #ifndef INCOMING_REGNO
--- 882,896 ----
  #define CASE_VECTOR_PC_RELATIVE 0
  #endif
  
! /* Assume that trampolines need function alignment but make sure that
!    they are overaligned like code if runtime descriptors are used.  */
  #ifndef TRAMPOLINE_ALIGNMENT
+ #if USE_RUNTIME_DESCRIPTORS && (FUNCTION_BOUNDARY < 16)
+ #define TRAMPOLINE_ALIGNMENT 16
+ #else
  #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY
  #endif
+ #endif
  
  /* Register mappings for target machines without register windows.  */
  #ifndef INCOMING_REGNO
*** gcc/config/alpha/alpha.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/alpha/alpha.h	2008-05-24 19:09:07.000000000 +0200
*************** do {						\
*** 897,902 ****
--- 897,906 ----
  #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
    alpha_initialize_trampoline (TRAMP, FNADDR, CXT, 16, 24, 8)
  
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
+ 
  /* A C expression whose value is RTL representing the value of the return
     address for the frame COUNT steps up from the current frame.
     FRAMEADDR is the frame pointer of the COUNT frame, or the frame pointer of
*** gcc/config/alpha/vms.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/alpha/vms.h	2008-05-24 19:09:07.000000000 +0200
*************** do {									\
*** 264,269 ****
--- 264,274 ----
  #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
    alpha_initialize_trampoline (TRAMP, FNADDR, CXT, 16, 24, -1)
  
+ /* VMS already uses descriptors for its standard calling sequence.  */
+ 
+ #undef USE_RUNTIME_DESCRIPTORS
+ #define USE_RUNTIME_DESCRIPTORS 0
+ 
  /* Control how constructors and destructors are emitted.  */
  #define TARGET_ASM_CONSTRUCTOR  vms_asm_out_constructor
  #define TARGET_ASM_DESTRUCTOR   vms_asm_out_destructor
*** gcc/config/i386/i386.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/i386/i386.h	2008-05-22 21:23:00.000000000 +0200
*************** typedef struct ix86_args {
*** 1756,1761 ****
--- 1756,1765 ----
  
  #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
    x86_initialize_trampoline ((TRAMP), (FNADDR), (CXT))
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Definitions for register eliminations.
  
*** gcc/config/i386/i386.md.0	2008-08-22 15:55:16.000000000 +0200
--- gcc/config/i386/i386.md	2008-08-22 15:55:40.000000000 +0200
***************
*** 14745,14751 ****
    [(set_attr "type" "call")])
  
  (define_insn "*sibcall_1"
!   [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,c,d,a"))
  	 (match_operand 1 "" ""))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
--- 14745,14751 ----
    [(set_attr "type" "call")])
  
  (define_insn "*sibcall_1"
!   [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,!c,d,a"))
  	 (match_operand 1 "" ""))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
***************
*** 21171,21177 ****
  
  (define_insn "*sibcall_value_1"
    [(set (match_operand 0 "" "")
! 	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,c,d,a"))
  	      (match_operand:SI 2 "" "")))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
--- 21171,21177 ----
  
  (define_insn "*sibcall_value_1"
    [(set (match_operand 0 "" "")
! 	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,!c,d,a"))
  	      (match_operand:SI 2 "" "")))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
*** gcc/config/ia64/ia64.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/ia64/ia64.h	2008-05-24 19:09:07.000000000 +0200
*************** do {									\
*** 1265,1270 ****
--- 1265,1274 ----
  
  #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \
    ia64_initialize_trampoline((ADDR), (FNADDR), (STATIC_CHAIN))
+ 
+ /* IA-64 already uses descriptors for its standard calling sequence.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 0
  
  /* Addressing Modes */
  
*** gcc/config/mips/mips.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/mips/mips.h	2008-05-24 19:09:07.000000000 +0200
*************** typedef struct mips_args {
*** 2229,2234 ****
--- 2229,2238 ----
                              GEN_INT (TRAMPOLINE_SIZE)));		    \
    emit_insn (gen_clear_cache (copy_rtx (ADDR), end_addr));		    \
  }
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Addressing modes, and classification of registers for them.  */
  
*** gcc/config/pa/pa.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/pa/pa.h	2008-05-24 20:27:11.000000000 +0200
*************** extern int may_call_alloca;
*** 965,970 ****
--- 965,974 ----
     
  #define TRAMPOLINE_ADJUST_ADDRESS(ADDR) \
    if (!TARGET_64BIT) (ADDR) = memory_address (Pmode, plus_constant ((ADDR), 46))
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Addressing modes, and classification of registers for them. 
  
*** gcc/config/rs6000/rs6000.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/rs6000/rs6000.h	2008-05-24 19:09:07.000000000 +0200
*************** typedef struct rs6000_args
*** 1548,1553 ****
--- 1548,1557 ----
  
  #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)		\
    rs6000_initialize_trampoline (ADDR, FNADDR, CXT)
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Definitions for __builtin_return_address and __builtin_frame_address.
     __builtin_return_address (0) should give link register (65), enable
*** gcc/config/rs6000/aix.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/rs6000/aix.h	2008-05-24 20:28:12.000000000 +0200
***************
*** 246,251 ****
--- 246,256 ----
  
  #define PROFILE_HOOK(LABEL)   output_profile_hook (LABEL)
  
+ /* AIX already uses descriptors for its standard calling sequence.  */
+ 
+ #undef USE_RUNTIME_DESCRIPTORS
+ #define USE_RUNTIME_DESCRIPTORS 0
+ 
  /* Print subsidiary information on the compiler version in use.  */
  #define TARGET_VERSION ;
  
*** gcc/config/sparc/sparc.h.0	2008-05-24 19:08:43.000000000 +0200
--- gcc/config/sparc/sparc.h	2008-05-24 19:09:07.000000000 +0200
*************** do {									\
*** 1699,1704 ****
--- 1699,1708 ----
        sparc64_initialize_trampoline (TRAMP, FNADDR, CXT);	\
      else							\
        sparc_initialize_trampoline (TRAMP, FNADDR, CXT)
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Generate RTL to flush the register windows so as to make arbitrary frames
     available.  */
*** gcc/fold-const.c.0	2008-05-26 11:54:21.000000000 +0200
--- gcc/fold-const.c	2008-05-27 00:05:26.386153008 +0200
*************** fold_binary (enum tree_code code, tree t
*** 10104,10110 ****
  	  /* With undefined overflow we can only associate constants
  	     with one variable.  */
  	  if (((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)
! 	       || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))
  	      && var0 && var1)
  	    {
  	      tree tmp0 = var0;
--- 10104,10113 ----
  	  /* With undefined overflow we can only associate constants
  	     with one variable.  */
  	  if (((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)
! 	       || (INTEGRAL_TYPE_P (type)
! 		   && !(TYPE_OVERFLOW_WRAPS (type)
! 			|| (TREE_CODE (type) == INTEGER_TYPE
! 			    && TYPE_IS_SIZETYPE (type)))))
  	      && var0 && var1)
  	    {
  	      tree tmp0 = var0;
*** gcc/tree-sra.c.0	2008-05-27 08:20:37.411933752 +0200
--- gcc/tree-sra.c	2008-05-27 08:21:09.463061240 +0200
*************** sra_type_can_be_decomposed_p (tree type)
*** 268,273 ****
--- 268,274 ----
  	    {
  	      /* Reject incorrectly represented bit fields.  */
  	      if (DECL_BIT_FIELD (t)
+ 		  && INTEGRAL_TYPE_P (TREE_TYPE (t))
  		  && (tree_low_cst (DECL_SIZE (t), 1)
  		      != TYPE_PRECISION (TREE_TYPE (t))))
  		goto fail;
*** gcc/common.opt.0	2008-06-04 09:08:37.000000000 +0200
--- gcc/common.opt	2008-06-04 09:10:02.000000000 +0200
*************** fdbg-cnt=
*** 406,411 ****
--- 406,415 ----
  Common RejectNegative Joined
  -fdbg-cnt=<counter>:<limit>[,<counter>:<limit>,...]    Set the debug counter limit.   
  
+ fdead-non-call-exceptions
+ Common Report Var(flag_dead_non_call_exceptions) Optimization
+ Preserve synchronous non-call exceptions raised from dead code
+ 
  fdebug-prefix-map=
  Common Joined RejectNegative
  Map one directory name to another in debug information
*** gcc/doc/invoke.texi.0	2008-06-04 09:08:37.000000000 +0200
--- gcc/doc/invoke.texi	2008-06-04 09:12:07.000000000 +0200
*************** See S/390 and zSeries Options.
*** 811,817 ****
  @xref{Code Gen Options,,Options for Code Generation Conventions}.
  @gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
  -ffixed-@var{reg}  -fexceptions @gol
! -fnon-call-exceptions  -funwind-tables @gol
  -fasynchronous-unwind-tables  -fsjlj @gol
  -finhibit-size-directive  -finstrument-functions @gol
  -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol
--- 811,817 ----
  @xref{Code Gen Options,,Options for Code Generation Conventions}.
  @gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
  -ffixed-@var{reg}  -fexceptions @gol
! -fnon-call-exceptions  -fdead-non-call-exceptions  -funwind-tables @gol
  -fasynchronous-unwind-tables  -fsjlj @gol
  -finhibit-size-directive  -finstrument-functions @gol
  -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol
*************** instructions to throw exceptions, i.e.@:
*** 14861,14866 ****
--- 14861,14873 ----
  point instructions.  It does not allow exceptions to be thrown from
  arbitrary signal handlers such as @code{SIGALRM}.
  
+ @item -fdead-non-call-exceptions
+ @opindex fdead-non-call-exceptions
+ Do not eliminate otherwise dead code containing trapping instructions
+ that can throw exceptions, in other words do not consider code containing
+ trapping instructions that may raise an exception but that would effectively
+ be dead if no exception was eventually raised as dead.
+ 
  @item -funwind-tables
  @opindex funwind-tables
  Similar to @option{-fexceptions}, except that it will just generate any needed
*** gcc/cse.c.0	2008-06-04 09:08:37.000000000 +0200
--- gcc/cse.c	2008-06-04 17:43:33.000000000 +0200
*************** static bool
*** 6479,6485 ****
  insn_live_p (rtx insn, int *counts)
  {
    int i;
!   if (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))
      return true;
    else if (GET_CODE (PATTERN (insn)) == SET)
      return set_live_p (PATTERN (insn), insn, counts);
--- 6479,6485 ----
  insn_live_p (rtx insn, int *counts)
  {
    int i;
!   if (flag_dead_non_call_exceptions && may_trap_p (PATTERN (insn)))
      return true;
    else if (GET_CODE (PATTERN (insn)) == SET)
      return set_live_p (PATTERN (insn), insn, counts);
*** gcc/dce.c.0	2008-06-04 09:16:39.000000000 +0200
--- gcc/dce.c	2008-06-04 17:52:29.000000000 +0200
*************** DEF_VEC_ALLOC_I(int,heap);
*** 46,51 ****
--- 46,54 ----
     we don't want to reenter it.  */
  static bool df_in_progress = false;
  
+ /* True if we are allowed to alter the CFG in this pass.  */
+ static bool can_alter_cfg = false;
+ 
  /* Instructions that have been marked but whose dependencies have not
     yet been processed.  */
  static VEC(rtx,heap) *worklist;
*************** deletable_insn_p_1 (rtx body)
*** 82,88 ****
        if (volatile_refs_p (body))
  	return false;
  
!       if (flag_non_call_exceptions && may_trap_p (body))
  	return false;
  
        return true;
--- 85,96 ----
        if (volatile_refs_p (body))
  	return false;
  
!       /* An instruction that may trap cannot be deleted if we need to
! 	 preserve it even if it is dead, or if it changes the flow of
! 	 control and we need to preserve the CFG.  */
!       if ((flag_dead_non_call_exceptions
! 	   || (flag_non_call_exceptions && !can_alter_cfg))
! 	  && may_trap_p (body))
  	return false;
  
        return true;
*************** init_dce (bool fast)
*** 511,517 ****
--- 527,536 ----
      {
        bitmap_obstack_initialize (&dce_blocks_bitmap_obstack);
        bitmap_obstack_initialize (&dce_tmp_bitmap_obstack);
+       can_alter_cfg = false;
      }
+   else
+     can_alter_cfg = true;
  
    marked = sbitmap_alloc (get_max_uid () + 1);
    sbitmap_zero (marked);
*** gcc/dse.c.0	2008-06-04 09:16:45.000000000 +0200
--- gcc/dse.c	2008-06-04 09:16:52.000000000 +0200
*************** scan_insn (bb_info_t bb_info, rtx insn)
*** 2039,2045 ****
       them.  */
    if ((GET_CODE (PATTERN (insn)) == CLOBBER)
        || volatile_refs_p (PATTERN (insn))
!       || (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))
        || (RTX_FRAME_RELATED_P (insn))
        || find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX))
      insn_info->cannot_delete = true;
--- 2039,2045 ----
       them.  */
    if ((GET_CODE (PATTERN (insn)) == CLOBBER)
        || volatile_refs_p (PATTERN (insn))
!       || (flag_dead_non_call_exceptions && may_trap_p (PATTERN (insn)))
        || (RTX_FRAME_RELATED_P (insn))
        || find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX))
      insn_info->cannot_delete = true;
*** gcc/tree-ssa-dce.c.0	2008-06-04 09:08:37.000000000 +0200
--- gcc/tree-ssa-dce.c	2008-06-04 09:09:08.000000000 +0200
*************** mark_stmt_if_obviously_necessary (tree s
*** 261,270 ****
    stmt_ann_t ann;
    tree op;
  
!   /* With non-call exceptions, we have to assume that all statements could
!      throw.  If a statement may throw, it is inherently necessary.  */
!   if (flag_non_call_exceptions
!       && tree_could_throw_p (stmt))
      {
        mark_stmt_necessary (stmt, true);
        return;
--- 261,268 ----
    stmt_ann_t ann;
    tree op;
  
!   /* If requested, don't eliminate statements that may throw.  */
!   if (flag_dead_non_call_exceptions && tree_could_throw_p (stmt))
      {
        mark_stmt_necessary (stmt, true);
        return;
*** gcc/configure.orig	Thu Jun  5 19:10:23 2008
--- gcc/configure	Thu Jun  5 22:16:22 2008
***************
*** 19452,19458 ****
  
  case "$ORIGINAL_AS_FOR_TARGET" in
    ./as | ./as$build_exeext) ;;
!   *)           ac_config_files="$ac_config_files as:exec-tool.in"
   ;;
  esac
  
--- 19452,19461 ----
  
  case "$ORIGINAL_AS_FOR_TARGET" in
    ./as | ./as$build_exeext) ;;
!   *)  case `uname` in
!         CYGWIN*) cp -p $ORIGINAL_AS_FOR_TARGET .;;         
!               *) ac_config_files="$ac_config_files as:exec-tool.in";;
!       esac
   ;;
  esac
  
***************
*** 19573,19580 ****
  
  case "$ORIGINAL_LD_FOR_TARGET" in
    ./collect-ld | ./collect-ld$build_exeext) ;;
!   *)           ac_config_files="$ac_config_files collect-ld:exec-tool.in"
!  ;;
  esac
  
  echo "$as_me:$LINENO: checking what linker to use" >&5
--- 19576,19585 ----
  
  case "$ORIGINAL_LD_FOR_TARGET" in
    ./collect-ld | ./collect-ld$build_exeext) ;;
!   *) case `uname` in
!         CYGWIN*) cp -p $ORIGINAL_LD_FOR_TARGET ./collect-ld$build_exeext;;
!               *) ac_config_files="$ac_config_files collect-ld:exec-tool.in";;
!      esac;;
  esac
  
  echo "$as_me:$LINENO: checking what linker to use" >&5
***************
*** 19682,19688 ****
  
  case "$ORIGINAL_NM_FOR_TARGET" in
    ./nm | ./nm$build_exeext) ;;
!   *)           ac_config_files="$ac_config_files nm:exec-tool.in"
   ;;
  esac
  
--- 19687,19696 ----
  
  case "$ORIGINAL_NM_FOR_TARGET" in
    ./nm | ./nm$build_exeext) ;;
!   *)  case `uname` in
!          CYGWIN*) cp -p $ORIGINAL_NM_FOR_TARGET .;;         
!                *) ac_config_files="$ac_config_files nm:exec-tool.in";;
!       esac
   ;;
  esac
  
*** gcc/builtins.c.0	2008-06-13 12:08:35.645608480 +0200
--- gcc/builtins.c	2008-06-13 12:09:30.703238448 +0200
*************** get_memory_rtx (tree exp, tree len)
*** 1121,1139 ****
  	  while (TREE_CODE (inner) == COMPONENT_REF)
  	    {
  	      tree field = TREE_OPERAND (inner, 1);
- 	      gcc_assert (! DECL_BIT_FIELD (field));
  	      gcc_assert (TREE_CODE (mem_expr) == COMPONENT_REF);
  	      gcc_assert (field == TREE_OPERAND (mem_expr, 1));
  
  	      if (length >= 0
! 		  && TYPE_SIZE_UNIT (TREE_TYPE (inner))
! 		  && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (inner)), 0))
  		{
  		  HOST_WIDE_INT size
! 		    = tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (inner)), 0);
! 		  /* If we can prove the memory starting at XEXP (mem, 0)
! 		     and ending at XEXP (mem, 0) + LENGTH will fit into
! 		     this field, we can keep that COMPONENT_REF in MEM_EXPR.  */
  		  if (offset <= size
  		      && length <= size
  		      && offset + length <= size)
--- 1121,1147 ----
  	  while (TREE_CODE (inner) == COMPONENT_REF)
  	    {
  	      tree field = TREE_OPERAND (inner, 1);
  	      gcc_assert (TREE_CODE (mem_expr) == COMPONENT_REF);
  	      gcc_assert (field == TREE_OPERAND (mem_expr, 1));
  
+ 	      /* Bitfields are generally not byte-addressable.  */
+ 	      gcc_assert (!DECL_BIT_FIELD (field)
+ 			  || ((tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)
+ 			       % BITS_PER_UNIT) == 0
+ 			      && host_integerp (DECL_SIZE (field), 0)
+ 			      && (TREE_INT_CST_LOW (DECL_SIZE (field))
+ 				  % BITS_PER_UNIT) == 0));
+ 
+ 	      /* If we can prove that the memory starting at XEXP (mem, 0) and
+ 		 ending at XEXP (mem, 0) + LENGTH will fit into this field, we
+ 		 can keep the COMPONENT_REF in MEM_EXPR.  But be careful with
+ 		 fields without DECL_SIZE_UNIT like flexible array members.  */
  	      if (length >= 0
! 		  && DECL_SIZE_UNIT (field)
! 		  && host_integerp (DECL_SIZE_UNIT (field), 0))
  		{
  		  HOST_WIDE_INT size
! 		    = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field));
  		  if (offset <= size
  		      && length <= size
  		      && offset + length <= size)
*************** get_memory_rtx (tree exp, tree len)
*** 1142,1148 ****
  
  	      if (offset >= 0
  		  && host_integerp (DECL_FIELD_OFFSET (field), 0))
! 		offset += tree_low_cst (DECL_FIELD_OFFSET (field), 0)
  			  + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)
  			    / BITS_PER_UNIT;
  	      else
--- 1150,1156 ----
  
  	      if (offset >= 0
  		  && host_integerp (DECL_FIELD_OFFSET (field), 0))
! 		offset += TREE_INT_CST_LOW (DECL_FIELD_OFFSET (field))
  			  + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)
  			    / BITS_PER_UNIT;
  	      else
*** gcc/expr.c.0	2008-06-10 12:23:03.505341720 +0200
--- gcc/expr.c	2008-06-10 12:30:59.486981512 +0200
*************** expand_expr_real_1 (tree exp, rtx target
*** 8188,8213 ****
        return REDUCE_BIT_FIELD (op0);
  
      case VIEW_CONVERT_EXPR:
!       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);
  
        /* If the input and output modes are both the same, we are done.  */
!       if (TYPE_MODE (type) == GET_MODE (op0))
  	;
        /* If neither mode is BLKmode, and both modes are the same size
  	 then we can use gen_lowpart.  */
!       else if (TYPE_MODE (type) != BLKmode && GET_MODE (op0) != BLKmode
! 	       && GET_MODE_SIZE (TYPE_MODE (type))
! 		   == GET_MODE_SIZE (GET_MODE (op0)))
  	{
  	  if (GET_CODE (op0) == SUBREG)
  	    op0 = force_reg (GET_MODE (op0), op0);
! 	  op0 = gen_lowpart (TYPE_MODE (type), op0);
  	}
        /* If both modes are integral, then we can convert from one to the
  	 other.  */
!       else if (SCALAR_INT_MODE_P (GET_MODE (op0))
! 	       && SCALAR_INT_MODE_P (TYPE_MODE (type)))
! 	op0 = convert_modes (TYPE_MODE (type), GET_MODE (op0), op0,
  			     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));
        /* As a last resort, spill op0 to memory, and reload it in a
  	 different mode.  */
--- 8188,8276 ----
        return REDUCE_BIT_FIELD (op0);
  
      case VIEW_CONVERT_EXPR:
!       op0 = NULL_RTX;
! 
!       /* If we are converting to BLKmode, try to avoid an intermediate
! 	 temporary by fetching an inner memory reference.  */
!       if (mode == BLKmode
! 	  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST
! 	  && TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != BLKmode
! 	  && handled_component_p (TREE_OPERAND (exp, 0)))
!       {
! 	enum machine_mode mode1;
! 	HOST_WIDE_INT bitsize, bitpos;
! 	tree offset;
! 	int unsignedp;
! 	int volatilep = 0;
! 	tree tem
! 	  = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, &bitpos,
! 				 &offset, &mode1, &unsignedp, &volatilep,
! 				 true);
! 	rtx orig_op0;
! 
! 	/* ??? We should work harder and deal with non-zero offsets.  */
! 	if (!offset
! 	    && (bitpos % BITS_PER_UNIT) == 0
! 	    && bitsize >= 0
! 	    && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) == 0)
! 	  {
! 	    /* See the normal_inner_ref case for the rationale.  */
! 	    orig_op0
! 	      = expand_expr (tem,
! 			     (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE
! 			      && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))
! 				  != INTEGER_CST)
! 			      && modifier != EXPAND_STACK_PARM
! 			      ? target : NULL_RTX),
! 			     VOIDmode,
! 			     (modifier == EXPAND_INITIALIZER
! 			      || modifier == EXPAND_CONST_ADDRESS
! 			      || modifier == EXPAND_STACK_PARM)
! 			     ? modifier : EXPAND_NORMAL);
! 
! 	    if (MEM_P (orig_op0))
! 	      {
! 		op0 = orig_op0;
! 
! 		/* Get a reference to just this component.  */
! 		if (modifier == EXPAND_CONST_ADDRESS
! 		    || modifier == EXPAND_SUM
! 		    || modifier == EXPAND_INITIALIZER)
! 		  op0 = adjust_address_nv (op0, mode, bitpos / BITS_PER_UNIT);
! 		else
! 		  op0 = adjust_address (op0, mode, bitpos / BITS_PER_UNIT);
! 
! 		if (op0 == orig_op0)
! 		  op0 = copy_rtx (op0);
! 
! 		set_mem_attributes (op0, TREE_OPERAND (exp, 0), 0);
! 		if (REG_P (XEXP (op0, 0)))
! 		  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));
! 
! 		MEM_VOLATILE_P (op0) |= volatilep;
! 	      }
! 	  }
!       }
! 
!       if (!op0)
! 	op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);
  
        /* If the input and output modes are both the same, we are done.  */
!       if (mode == GET_MODE (op0))
  	;
        /* If neither mode is BLKmode, and both modes are the same size
  	 then we can use gen_lowpart.  */
!       else if (mode != BLKmode && GET_MODE (op0) != BLKmode
! 	       && GET_MODE_SIZE (mode) == GET_MODE_SIZE (GET_MODE (op0)))
  	{
  	  if (GET_CODE (op0) == SUBREG)
  	    op0 = force_reg (GET_MODE (op0), op0);
! 	  op0 = gen_lowpart (mode, op0);
  	}
        /* If both modes are integral, then we can convert from one to the
  	 other.  */
!       else if (SCALAR_INT_MODE_P (GET_MODE (op0)) && SCALAR_INT_MODE_P (mode))
! 	op0 = convert_modes (mode, GET_MODE (op0), op0, 
  			     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));
        /* As a last resort, spill op0 to memory, and reload it in a
  	 different mode.  */
*************** expand_expr_real_1 (tree exp, rtx target
*** 8241,8262 ****
  
  	  if (TYPE_ALIGN_OK (type))
  	    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));
! 	  else if (TYPE_MODE (type) != BLKmode && STRICT_ALIGNMENT
! 		   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (TYPE_MODE (type)))
  	    {
  	      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));
  	      HOST_WIDE_INT temp_size
  		= MAX (int_size_in_bytes (inner_type),
! 		       (HOST_WIDE_INT) GET_MODE_SIZE (TYPE_MODE (type)));
! 	      rtx new = assign_stack_temp_for_type (TYPE_MODE (type),
! 						    temp_size, 0, type);
  	      rtx new_with_op0_mode = adjust_address (new, GET_MODE (op0), 0);
  
  	      gcc_assert (!TREE_ADDRESSABLE (exp));
  
  	      if (GET_MODE (op0) == BLKmode)
  		emit_block_move (new_with_op0_mode, op0,
! 				 GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))),
  				 (modifier == EXPAND_STACK_PARM
  				  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));
  	      else
--- 8304,8325 ----
  
  	  if (TYPE_ALIGN_OK (type))
  	    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));
! 	  else if (STRICT_ALIGNMENT
! 		   && mode != BLKmode
! 		   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode))
  	    {
  	      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));
  	      HOST_WIDE_INT temp_size
  		= MAX (int_size_in_bytes (inner_type),
! 		       (HOST_WIDE_INT) GET_MODE_SIZE (mode));
! 	      rtx new = assign_stack_temp_for_type (mode, temp_size, 0, type);
  	      rtx new_with_op0_mode = adjust_address (new, GET_MODE (op0), 0);
  
  	      gcc_assert (!TREE_ADDRESSABLE (exp));
  
  	      if (GET_MODE (op0) == BLKmode)
  		emit_block_move (new_with_op0_mode, op0,
! 				 GEN_INT (GET_MODE_SIZE (mode)),
  				 (modifier == EXPAND_STACK_PARM
  				  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));
  	      else
*************** expand_expr_real_1 (tree exp, rtx target
*** 8265,8271 ****
  	      op0 = new;
  	    }
  
! 	  op0 = adjust_address (op0, TYPE_MODE (type), 0);
  	}
  
        return op0;
--- 8328,8334 ----
  	      op0 = new;
  	    }
  
! 	  op0 = adjust_address (op0, mode, 0);
  	}
  
        return op0;
*** gcc/config/i386/w32-unwind.h.ori	Tue Jun 10 17:13:08 2008
--- gcc/config/i386/w32-unwind.h	Tue Jun 10 17:13:35 2008
*************** i386_w32_fallback_frame_state (struct _U
*** 172,179 ****
        fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;
        fs->regs.reg[9].how = REG_SAVED_OFFSET;
        fs->regs.reg[9].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;
!       fs->regs.reg[4].how = REG_SAVED_OFFSET;
!       fs->regs.reg[4].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;
  
        /* Set the return address to Eip + 1. As we can be called multiple
  	 times we use another register for this.  */
--- 172,179 ----
        fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;
        fs->regs.reg[9].how = REG_SAVED_OFFSET;
        fs->regs.reg[9].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;
!       fs->regs.reg[5].how = REG_SAVED_OFFSET;
!       fs->regs.reg[5].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;
  
        /* Set the return address to Eip + 1. As we can be called multiple
  	 times we use another register for this.  */
*** gcc/varasm.c.ori	Tue Jun 10 17:59:09 2008
--- gcc/varasm.c	Tue Jun 10 18:00:49 2008
*************** array_size_for_constructor (tree val)
*** 4580,4585 ****
--- 4580,4867 ----
    return tree_low_cst (i, 1);
  }
  
+ /* Datastructures and helpers for output_constructor.  */
+ 
+ /* Local output_constructor state to support interaction with helpers.  */
+ 
+ typedef struct {
+ 
+   /* Received arguments.  */
+   tree exp;                     /* constructor expression.  */
+   unsigned HOST_WIDE_INT size;  /* # bytes to output - pad if necessary.  */
+   unsigned int align;           /* known initial alignment.  */
+ 
+   /* Constructor expression data.  */
+   tree type;       /* expression type.  */
+   tree field;      /* current field decl in a record.  */
+   tree min_index;  /* lower bound if specified for an array.  */
+ 
+   /* Output processing state per se.  */
+   HOST_WIDE_INT total_bytes;  /* # bytes output so far / current position.  */
+   int byte_buffer_in_use;     /* whether byte ...  */
+   int byte;                   /* ... contains part of a bitfield byte yet to
+ 			         be output.  */
+ 
+   /* Current element.  */
+   tree val;    /* current element value.  */
+   tree index;  /* current element index.  */
+ 
+ } oc_local_state;
+ 
+ static void output_constructor_array_range (oc_local_state *local);
+ static void output_constructor_regular_field (oc_local_state *local);
+ static void output_constructor_bitfield (oc_local_state *local);
+ 
+ /* Helper for output_constructor.  Output a RANGE_EXPR element.  */
+ 
+ static void
+ output_constructor_array_range (oc_local_state *local)
+ {
+   unsigned HOST_WIDE_INT fieldsize
+     = int_size_in_bytes (TREE_TYPE (local->type));
+ 
+   HOST_WIDE_INT lo_index
+     = tree_low_cst (TREE_OPERAND (local->index, 0), 0);
+   HOST_WIDE_INT hi_index
+     = tree_low_cst (TREE_OPERAND (local->index, 1), 0);
+   HOST_WIDE_INT index;
+ 
+   unsigned int align2
+     = min_align (local->align, fieldsize * BITS_PER_UNIT);
+   
+   for (index = lo_index; index <= hi_index; index++)
+     {
+       /* Output the element's initial value.  */
+       if (local->val == 0)
+ 	assemble_zeros (fieldsize);
+       else
+ 	output_constant (local->val, fieldsize, align2);
+       
+       /* Count its size.  */
+       local->total_bytes += fieldsize;
+     }
+ }
+ 
+ /* Helper for output_constructor.  Output a field element that is not
+    bitfield.  */
+ 
+ static void
+ output_constructor_regular_field (oc_local_state *local)
+ {
+   /* Field size and position.  Since this structure is static, we know the
+      positions are constant.  */
+   unsigned HOST_WIDE_INT fieldsize;
+   HOST_WIDE_INT pos = local->field ? int_byte_position (local->field) : 0;
+ 
+   unsigned int align2;
+ 
+   if (local->index != 0)
+     pos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (local->val)), 1)
+ 	   * ((tree_low_cst (local->index, 0) 
+ 	       - tree_low_cst (local->min_index, 0))));
+   
+   /* Output any buffered-up bit-fields preceding this element.  */
+   if (local->byte_buffer_in_use)
+     {
+       assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
+       local->total_bytes++;
+       local->byte_buffer_in_use = 0;
+     }
+   
+   /* Advance to offset of this element.
+      Note no alignment needed in an array, since that is guaranteed
+      if each element has the proper size.  */
+   if ((local->field != 0 || local->index != 0) && pos != local->total_bytes)
+     {
+       gcc_assert (pos >= local->total_bytes);
+       assemble_zeros (pos - local->total_bytes);
+       local->total_bytes = pos;
+     }
+   
+   /* Find the alignment of this element.  */
+   align2 = min_align (local->align, BITS_PER_UNIT * pos);
+ 
+   /* Determine size this element should occupy.  */
+   if (local->field)
+     {
+       fieldsize = 0;
+       
+       /* If this is an array with an unspecified upper bound,
+ 	 the initializer determines the size.  */
+       /* ??? This ought to only checked if DECL_SIZE_UNIT is NULL,
+ 	 but we cannot do this until the deprecated support for
+ 	 initializing zero-length array members is removed.  */
+       if (TREE_CODE (TREE_TYPE (local->field)) == ARRAY_TYPE
+ 	  && TYPE_DOMAIN (TREE_TYPE (local->field))
+ 	  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (local->field))))
+ 	{
+ 	  fieldsize = array_size_for_constructor (local->val);
+ 	  /* Given a non-empty initialization, this field had
+ 	     better be last.  */
+ 	  gcc_assert (!fieldsize || !TREE_CHAIN (local->field));
+ 	}
+       else if (DECL_SIZE_UNIT (local->field))
+ 	{
+ 	  /* ??? This can't be right.  If the decl size overflows
+ 	     a host integer we will silently emit no data.  */
+ 	  if (host_integerp (DECL_SIZE_UNIT (local->field), 1))
+ 	    fieldsize = tree_low_cst (DECL_SIZE_UNIT (local->field), 1);
+ 	}
+     }
+   else
+     fieldsize = int_size_in_bytes (TREE_TYPE (local->type));
+   
+   /* Output the element's initial value.  */
+   if (local->val == 0)
+     assemble_zeros (fieldsize);
+   else
+     output_constant (local->val, fieldsize, align2);
+ 
+   /* Count its size.  */
+   local->total_bytes += fieldsize;
+ }
+ 
+ /* Helper for output_constructor.  Output a bitfield element.  */
+ 
+ static void
+ output_constructor_bitfield (oc_local_state *local)
+ {
+   /* Offset in bits from the beginning of the structure to the next bit of
+      this element to be processed.  */
+   HOST_WIDE_INT next_offset = int_bit_position (local->field);
+ 
+   /* Offset of the first bit past the end of this element.  */
+   HOST_WIDE_INT end_offset
+     = (next_offset + tree_low_cst (DECL_SIZE (local->field), 1));
+   
+   if (local->val != 0 && TREE_CODE (local->val) != INTEGER_CST)
+     error ("invalid initial value for member %qs",
+ 	   IDENTIFIER_POINTER (DECL_NAME (local->field)));
+ 
+   if (local->val == 0)
+     local->val = integer_zero_node;
+   
+   /* If this field does not start in this (or, next) byte,
+      skip some bytes.  */
+   if (next_offset / BITS_PER_UNIT != local->total_bytes)
+     {
+       /* Output remnant of any bit field in previous bytes.  */
+       if (local->byte_buffer_in_use)
+ 	{
+ 	  assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
+ 	  local->total_bytes++;
+ 	  local->byte_buffer_in_use = 0;
+ 	}
+       
+       /* If still not at proper byte, advance to there.  */
+       if (next_offset / BITS_PER_UNIT != local->total_bytes)
+ 	{
+ 	  gcc_assert (next_offset / BITS_PER_UNIT >= local->total_bytes);
+ 	  assemble_zeros (next_offset / BITS_PER_UNIT - local->total_bytes);
+ 	  local->total_bytes = next_offset / BITS_PER_UNIT;
+ 	}
+     }
+   
+   if (! local->byte_buffer_in_use)
+     local->byte = 0;
+   
+   /* We must split the element into pieces that fall within
+      separate bytes, and combine each byte with previous or
+      following bit-fields.  */
+   
+   while (next_offset < end_offset)
+     {
+       int this_time;
+       int shift;
+       HOST_WIDE_INT value;
+       HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
+       HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
+       
+       /* Advance from byte to byte
+ 	 within this element when necessary.  */
+       while (next_byte != local->total_bytes)
+ 	{
+ 	  assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
+ 	  local->total_bytes++;
+ 	  local->byte = 0;
+ 	}
+       
+       /* Number of bits we can process at once
+ 	 (all part of the same byte).  */
+       this_time = MIN (end_offset - next_offset,
+ 		       BITS_PER_UNIT - next_bit);
+       if (BYTES_BIG_ENDIAN)
+ 	{
+ 	  /* On big-endian machine, take the most significant bits
+ 	     first (of the bits that are significant)
+ 	     and put them into bytes from the most significant end.  */
+ 	  shift = end_offset - next_offset - this_time;
+ 	  
+ 	  /* Don't try to take a bunch of bits that cross
+ 	     the word boundary in the INTEGER_CST. We can
+ 	     only select bits from the LOW or HIGH part
+ 	     not from both.  */
+ 	  if (shift < HOST_BITS_PER_WIDE_INT
+ 	      && shift + this_time > HOST_BITS_PER_WIDE_INT)
+ 	    {
+ 	      this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;
+ 	      shift = HOST_BITS_PER_WIDE_INT;
+ 	    }
+ 	  
+ 	  /* Now get the bits from the appropriate constant word.  */
+ 	  if (shift < HOST_BITS_PER_WIDE_INT)
+ 	    value = TREE_INT_CST_LOW (local->val);
+ 	  else
+ 	    {
+ 	      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
+ 	      value = TREE_INT_CST_HIGH (local->val);
+ 	      shift -= HOST_BITS_PER_WIDE_INT;
+ 	    }
+ 	  
+ 	  /* Get the result. This works only when:
+ 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
+ 	  local->byte |= (((value >> shift)
+ 			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
+ 			  << (BITS_PER_UNIT - this_time - next_bit));
+ 	}
+       else
+ 	{
+ 	  /* On little-endian machines,
+ 	     take first the least significant bits of the value
+ 	     and pack them starting at the least significant
+ 	     bits of the bytes.  */
+ 	  shift = next_offset - int_bit_position (local->field);
+ 	  
+ 	  /* Don't try to take a bunch of bits that cross
+ 	     the word boundary in the INTEGER_CST. We can
+ 	     only select bits from the LOW or HIGH part
+ 	     not from both.  */
+ 	  if (shift < HOST_BITS_PER_WIDE_INT
+ 	      && shift + this_time > HOST_BITS_PER_WIDE_INT)
+ 	    this_time = (HOST_BITS_PER_WIDE_INT - shift);
+ 	  
+ 	  /* Now get the bits from the appropriate constant word.  */
+ 	  if (shift < HOST_BITS_PER_WIDE_INT)
+ 	    value = TREE_INT_CST_LOW (local->val);
+ 	  else
+ 	    {
+ 	      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
+ 	      value = TREE_INT_CST_HIGH (local->val);
+ 	      shift -= HOST_BITS_PER_WIDE_INT;
+ 	    }
+ 	  
+ 	  /* Get the result. This works only when:
+ 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
+ 	  local->byte |= (((value >> shift)
+ 			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
+ 			  << next_bit);
+ 	}
+       
+       next_offset += this_time;
+       local->byte_buffer_in_use = 1;
+     }
+ }
+ 
  /* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).
     Generate at least SIZE bytes, padding if necessary.  */
  
*************** static void
*** 4587,4895 ****
  output_constructor (tree exp, unsigned HOST_WIDE_INT size,
  		    unsigned int align)
  {
-   tree type = TREE_TYPE (exp);
-   tree field = 0;
-   tree min_index = 0;
-   /* Number of bytes output or skipped so far.
-      In other words, current position within the constructor.  */
-   HOST_WIDE_INT total_bytes = 0;
-   /* Nonzero means BYTE contains part of a byte, to be output.  */
-   int byte_buffer_in_use = 0;
-   int byte = 0;
    unsigned HOST_WIDE_INT cnt;
    constructor_elt *ce;
  
!   gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);
  
!   if (TREE_CODE (type) == RECORD_TYPE)
!     field = TYPE_FIELDS (type);
  
!   if (TREE_CODE (type) == ARRAY_TYPE
!       && TYPE_DOMAIN (type) != 0)
!     min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));
! 
!   /* As LINK goes through the elements of the constant,
!      FIELD goes through the structure fields, if the constant is a structure.
!      if the constant is a union, then we override this,
!      by getting the field from the TREE_LIST element.
       But the constant could also be an array.  Then FIELD is zero.
  
       There is always a maximum of one element in the chain LINK for unions
       (even if the initializer in a source program incorrectly contains
       more one).  */
    for (cnt = 0;
         VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), cnt, ce);
!        cnt++, field = field ? TREE_CHAIN (field) : 0)
      {
!       tree val = ce->value;
!       tree index = 0;
  
        /* The element in a union constructor specifies the proper field
  	 or index.  */
!       if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE
! 	   || TREE_CODE (type) == QUAL_UNION_TYPE)
  	  && ce->index != 0)
! 	field = ce->index;
  
!       else if (TREE_CODE (type) == ARRAY_TYPE)
! 	index = ce->index;
  
  #ifdef ASM_COMMENT_START
!       if (field && flag_verbose_asm)
  	fprintf (asm_out_file, "%s %s:\n",
  		 ASM_COMMENT_START,
! 		 DECL_NAME (field)
! 		 ? IDENTIFIER_POINTER (DECL_NAME (field))
  		 : "<anonymous>");
  #endif
  
        /* Eliminate the marker that makes a cast not be an lvalue.  */
!       if (val != 0)
! 	STRIP_NOPS (val);
  
!       if (index && TREE_CODE (index) == RANGE_EXPR)
! 	{
! 	  unsigned HOST_WIDE_INT fieldsize
! 	    = int_size_in_bytes (TREE_TYPE (type));
! 	  HOST_WIDE_INT lo_index = tree_low_cst (TREE_OPERAND (index, 0), 0);
! 	  HOST_WIDE_INT hi_index = tree_low_cst (TREE_OPERAND (index, 1), 0);
! 	  HOST_WIDE_INT index;
! 	  unsigned int align2 = min_align (align, fieldsize * BITS_PER_UNIT);
! 
! 	  for (index = lo_index; index <= hi_index; index++)
! 	    {
! 	      /* Output the element's initial value.  */
! 	      if (val == 0)
! 		assemble_zeros (fieldsize);
! 	      else
! 		output_constant (val, fieldsize, align2);
! 
! 	      /* Count its size.  */
! 	      total_bytes += fieldsize;
! 	    }
! 	}
!       else if (field == 0 || !DECL_BIT_FIELD (field))
! 	{
! 	  /* An element that is not a bit-field.  */
! 
! 	  unsigned HOST_WIDE_INT fieldsize;
! 	  /* Since this structure is static,
! 	     we know the positions are constant.  */
! 	  HOST_WIDE_INT pos = field ? int_byte_position (field) : 0;
! 	  unsigned int align2;
! 
! 	  if (index != 0)
! 	    pos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (val)), 1)
! 		   * (tree_low_cst (index, 0) - tree_low_cst (min_index, 0)));
! 
! 	  /* Output any buffered-up bit-fields preceding this element.  */
! 	  if (byte_buffer_in_use)
! 	    {
! 	      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
! 	      total_bytes++;
! 	      byte_buffer_in_use = 0;
! 	    }
! 
! 	  /* Advance to offset of this element.
! 	     Note no alignment needed in an array, since that is guaranteed
! 	     if each element has the proper size.  */
! 	  if ((field != 0 || index != 0) && pos != total_bytes)
! 	    {
! 	      gcc_assert (pos >= total_bytes);
! 	      assemble_zeros (pos - total_bytes);
! 	      total_bytes = pos;
! 	    }
! 
! 	  /* Find the alignment of this element.  */
! 	  align2 = min_align (align, BITS_PER_UNIT * pos);
  
! 	  /* Determine size this element should occupy.  */
! 	  if (field)
! 	    {
! 	      fieldsize = 0;
! 
! 	      /* If this is an array with an unspecified upper bound,
! 		 the initializer determines the size.  */
! 	      /* ??? This ought to only checked if DECL_SIZE_UNIT is NULL,
! 		 but we cannot do this until the deprecated support for
! 		 initializing zero-length array members is removed.  */
! 	      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE
! 		  && TYPE_DOMAIN (TREE_TYPE (field))
! 		  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))
! 		{
! 		  fieldsize = array_size_for_constructor (val);
! 		  /* Given a non-empty initialization, this field had
! 		     better be last.  */
! 		  gcc_assert (!fieldsize || !TREE_CHAIN (field));
! 		}
! 	      else if (DECL_SIZE_UNIT (field))
! 		{
! 		  /* ??? This can't be right.  If the decl size overflows
! 		     a host integer we will silently emit no data.  */
! 		  if (host_integerp (DECL_SIZE_UNIT (field), 1))
! 		    fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);
! 		}
! 	    }
! 	  else
! 	    fieldsize = int_size_in_bytes (TREE_TYPE (type));
  
! 	  /* Output the element's initial value.  */
! 	  if (val == 0)
! 	    assemble_zeros (fieldsize);
! 	  else
! 	    output_constant (val, fieldsize, align2);
  
! 	  /* Count its size.  */
! 	  total_bytes += fieldsize;
! 	}
!       else if (val != 0 && TREE_CODE (val) != INTEGER_CST)
! 	error ("invalid initial value for member %qs",
! 	       IDENTIFIER_POINTER (DECL_NAME (field)));
        else
! 	{
! 	  /* Element that is a bit-field.  */
! 
! 	  HOST_WIDE_INT next_offset = int_bit_position (field);
! 	  HOST_WIDE_INT end_offset
! 	    = (next_offset + tree_low_cst (DECL_SIZE (field), 1));
! 
! 	  if (val == 0)
! 	    val = integer_zero_node;
! 
! 	  /* If this field does not start in this (or, next) byte,
! 	     skip some bytes.  */
! 	  if (next_offset / BITS_PER_UNIT != total_bytes)
! 	    {
! 	      /* Output remnant of any bit field in previous bytes.  */
! 	      if (byte_buffer_in_use)
! 		{
! 		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
! 		  total_bytes++;
! 		  byte_buffer_in_use = 0;
! 		}
! 
! 	      /* If still not at proper byte, advance to there.  */
! 	      if (next_offset / BITS_PER_UNIT != total_bytes)
! 		{
! 		  gcc_assert (next_offset / BITS_PER_UNIT >= total_bytes);
! 		  assemble_zeros (next_offset / BITS_PER_UNIT - total_bytes);
! 		  total_bytes = next_offset / BITS_PER_UNIT;
! 		}
! 	    }
! 
! 	  if (! byte_buffer_in_use)
! 	    byte = 0;
! 
! 	  /* We must split the element into pieces that fall within
! 	     separate bytes, and combine each byte with previous or
! 	     following bit-fields.  */
! 
! 	  /* next_offset is the offset n fbits from the beginning of
! 	     the structure to the next bit of this element to be processed.
! 	     end_offset is the offset of the first bit past the end of
! 	     this element.  */
! 	  while (next_offset < end_offset)
! 	    {
! 	      int this_time;
! 	      int shift;
! 	      HOST_WIDE_INT value;
! 	      HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
! 	      HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
! 
! 	      /* Advance from byte to byte
! 		 within this element when necessary.  */
! 	      while (next_byte != total_bytes)
! 		{
! 		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
! 		  total_bytes++;
! 		  byte = 0;
! 		}
! 
! 	      /* Number of bits we can process at once
! 		 (all part of the same byte).  */
! 	      this_time = MIN (end_offset - next_offset,
! 			       BITS_PER_UNIT - next_bit);
! 	      if (BYTES_BIG_ENDIAN)
! 		{
! 		  /* On big-endian machine, take the most significant bits
! 		     first (of the bits that are significant)
! 		     and put them into bytes from the most significant end.  */
! 		  shift = end_offset - next_offset - this_time;
! 
! 		  /* Don't try to take a bunch of bits that cross
! 		     the word boundary in the INTEGER_CST. We can
! 		     only select bits from the LOW or HIGH part
! 		     not from both.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT
! 		      && shift + this_time > HOST_BITS_PER_WIDE_INT)
! 		    {
! 		      this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;
! 		      shift = HOST_BITS_PER_WIDE_INT;
! 		    }
! 
! 		  /* Now get the bits from the appropriate constant word.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT)
! 		    value = TREE_INT_CST_LOW (val);
! 		  else
! 		    {
! 		      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
! 		      value = TREE_INT_CST_HIGH (val);
! 		      shift -= HOST_BITS_PER_WIDE_INT;
! 		    }
! 
! 		  /* Get the result. This works only when:
! 		     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
! 		  byte |= (((value >> shift)
! 			    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
! 			   << (BITS_PER_UNIT - this_time - next_bit));
! 		}
! 	      else
! 		{
! 		  /* On little-endian machines,
! 		     take first the least significant bits of the value
! 		     and pack them starting at the least significant
! 		     bits of the bytes.  */
! 		  shift = next_offset - int_bit_position (field);
! 
! 		  /* Don't try to take a bunch of bits that cross
! 		     the word boundary in the INTEGER_CST. We can
! 		     only select bits from the LOW or HIGH part
! 		     not from both.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT
! 		      && shift + this_time > HOST_BITS_PER_WIDE_INT)
! 		    this_time = (HOST_BITS_PER_WIDE_INT - shift);
! 
! 		  /* Now get the bits from the appropriate constant word.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT)
! 		    value = TREE_INT_CST_LOW (val);
! 		  else
! 		    {
! 		      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
! 		      value = TREE_INT_CST_HIGH (val);
! 		      shift -= HOST_BITS_PER_WIDE_INT;
! 		    }
! 
! 		  /* Get the result. This works only when:
! 		     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
! 		  byte |= (((value >> shift)
! 			    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
! 			   << next_bit);
! 		}
! 
! 	      next_offset += this_time;
! 	      byte_buffer_in_use = 1;
! 	    }
! 	}
      }
  
!   if (byte_buffer_in_use)
      {
!       assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
!       total_bytes++;
      }
  
!   if ((unsigned HOST_WIDE_INT)total_bytes < size)
!     assemble_zeros (size - total_bytes);
  }
  
  /* This TREE_LIST contains any weak symbol declarations waiting
--- 4869,4964 ----
  output_constructor (tree exp, unsigned HOST_WIDE_INT size,
  		    unsigned int align)
  {
    unsigned HOST_WIDE_INT cnt;
    constructor_elt *ce;
  
!   oc_local_state local;
  
!   /* Setup our local state to communicate with helpers.  */
!   local.exp = exp;
!   local.size = size;
!   local.align = align;
! 
!   local.total_bytes = 0;
!   local.byte_buffer_in_use = 0;
!   local.byte = 0;
! 
!   local.type = TREE_TYPE (exp);
! 
!   local.min_index = 0;
!   if (TREE_CODE (local.type) == ARRAY_TYPE
!       && TYPE_DOMAIN (local.type) != 0)
!     local.min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (local.type));
!   
!   gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);
  
!   /* As CE goes through the elements of the constant, FIELD goes through the
!      structure fields if the constant is a structure.  If the constant is a
!      union, we override this by getting the field from the TREE_LIST element.
       But the constant could also be an array.  Then FIELD is zero.
  
       There is always a maximum of one element in the chain LINK for unions
       (even if the initializer in a source program incorrectly contains
       more one).  */
+ 
+   local.field = 0;
+   if (TREE_CODE (local.type) == RECORD_TYPE)
+     local.field = TYPE_FIELDS (local.type);
+ 
    for (cnt = 0;
         VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), cnt, ce);
!        cnt++, local.field = local.field ? TREE_CHAIN (local.field) : 0)
      {
!       local.val = ce->value;
!       local.index = 0;
  
        /* The element in a union constructor specifies the proper field
  	 or index.  */
!       if ((TREE_CODE (local.type) == RECORD_TYPE
! 	   || TREE_CODE (local.type) == UNION_TYPE
! 	   || TREE_CODE (local.type) == QUAL_UNION_TYPE)
  	  && ce->index != 0)
! 	local.field = ce->index;
  
!       else if (TREE_CODE (local.type) == ARRAY_TYPE)
! 	local.index = ce->index;
  
  #ifdef ASM_COMMENT_START
!       if (local.field && flag_verbose_asm)
  	fprintf (asm_out_file, "%s %s:\n",
  		 ASM_COMMENT_START,
! 		 DECL_NAME (local.field)
! 		 ? IDENTIFIER_POINTER (DECL_NAME (local.field))
  		 : "<anonymous>");
  #endif
  
        /* Eliminate the marker that makes a cast not be an lvalue.  */
!       if (local.val != 0)
! 	STRIP_NOPS (local.val);
  
!       /* Output the current element, using the appropriate helper ...  */
  
!       /* For an array slice.  */
!       if (local.index && TREE_CODE (local.index) == RANGE_EXPR)
! 	output_constructor_array_range (&local);
  
!       /* For a field that is not a bitfield.  */
!       else if (local.field == 0 || !DECL_BIT_FIELD (local.field))
! 	output_constructor_regular_field (&local);
  
!       /* For a bitfield.  */
        else
! 	output_constructor_bitfield (&local);
      }
  
!   if (local.byte_buffer_in_use)
      {
!       assemble_integer (GEN_INT (local.byte), 1, BITS_PER_UNIT, 1);
!       local.total_bytes++;
      }
  
!   if ((unsigned HOST_WIDE_INT)local.total_bytes < size)
!     assemble_zeros (size - local.total_bytes);
  }
  
  /* This TREE_LIST contains any weak symbol declarations waiting
*** gcc/tree-inline.c.0	2008-06-11 09:35:52.371067240 +0200
--- gcc/tree-inline.c	2008-06-11 09:36:12.901946072 +0200
*************** copy_body_r (tree *tp, int *walk_subtree
*** 743,748 ****
--- 743,749 ----
  		    {
  	              *tp = build1 (INDIRECT_REF, type, new);
  		      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);
+ 		      TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);
  		    }
  		}
  	      *walk_subtrees = 0;
*** gcc/config/ia64/ia64.h.0	2008-06-12 12:27:39.000000000 +0200
--- gcc/config/ia64/ia64.h	2008-06-12 19:48:34.538382848 +0200
*************** while (0)
*** 642,648 ****
  #define HARD_REGNO_NREGS(REGNO, MODE)					\
    ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64			\
     : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2				\
!    : PR_REGNO_P (REGNO) && (MODE) == CCImode ? 1			\
     : FR_REGNO_P (REGNO) && (MODE) == XFmode ? 1				\
     : FR_REGNO_P (REGNO) && (MODE) == RFmode ? 1				\
     : FR_REGNO_P (REGNO) && (MODE) == XCmode ? 2				\
--- 642,648 ----
  #define HARD_REGNO_NREGS(REGNO, MODE)					\
    ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64			\
     : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2				\
!    : (PR_REGNO_P (REGNO) || GR_REGNO_P (REGNO)) && (MODE) == CCImode ? 1\
     : FR_REGNO_P (REGNO) && (MODE) == XFmode ? 1				\
     : FR_REGNO_P (REGNO) && (MODE) == RFmode ? 1				\
     : FR_REGNO_P (REGNO) && (MODE) == XCmode ? 2				\
*************** while (0)
*** 660,666 ****
     : PR_REGNO_P (REGNO) ?					\
       (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC	\
     : GR_REGNO_P (REGNO) ?					\
!      (MODE) != CCImode && (MODE) != XFmode && (MODE) != XCmode && (MODE) != RFmode \
     : AR_REGNO_P (REGNO) ? (MODE) == DImode			\
     : BR_REGNO_P (REGNO) ? (MODE) == DImode			\
     : 0)
--- 660,666 ----
     : PR_REGNO_P (REGNO) ?					\
       (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC	\
     : GR_REGNO_P (REGNO) ?					\
!      (MODE) != XFmode && (MODE) != XCmode && (MODE) != RFmode	\
     : AR_REGNO_P (REGNO) ? (MODE) == DImode			\
     : BR_REGNO_P (REGNO) ? (MODE) == DImode			\
     : 0)
*** gcc/config/ia64/ia64.md.0	2008-06-12 12:27:48.000000000 +0200
--- gcc/config/ia64/ia64.md	2008-06-12 19:53:22.244644848 +0200
***************
*** 209,225 ****
  ;; Set of a single predicate register.  This is only used to implement
  ;; pr-to-pr move and complement.
  
! (define_insn "*movcci"
!   [(set (match_operand:CCI 0 "register_operand" "=c,c,c")
! 	(match_operand:CCI 1 "nonmemory_operand" "O,n,c"))]
    ""
    "@
     cmp.ne %0, p0 = r0, r0
     cmp.eq %0, p0 = r0, r0
!    (%1) cmp.eq.unc %0, p0 = r0, r0"
!   [(set_attr "itanium_class" "icmp")
     (set_attr "predicable" "no")])
  
  (define_insn "movbi"
    [(set (match_operand:BI 0 "destination_operand" "=c,c,?c,?*r, c,*r,*r,*m,*r")
  	(match_operand:BI 1 "move_operand"        " O,n, c,  c,*r, n,*m,*r,*r"))]
--- 209,242 ----
  ;; Set of a single predicate register.  This is only used to implement
  ;; pr-to-pr move and complement.
  
! (define_insn "movcci"
!   [(set (match_operand:CCI 0 "destination_operand" "=c,c,?c,?*r, c,*r,*m,*r")
! 	(match_operand:CCI 1 "move_operand"        " O,n, c,  c,*r,*m,*r,*r"))]
    ""
    "@
     cmp.ne %0, p0 = r0, r0
     cmp.eq %0, p0 = r0, r0
!    (%1) cmp.eq.unc %0, p0 = r0, r0
!    #
!    tbit.nz %0, p0 = %1, 0
!    ld1%O1 %0 = %1%P1
!    st1%Q0 %0 = %1%P0
!    mov %0 = %1"
!   [(set_attr "itanium_class" "icmp,icmp,icmp,unknown,tbit,ld,st,ialu")
     (set_attr "predicable" "no")])
  
+ (define_split
+   [(set (match_operand:CCI 0 "register_operand" "")
+ 	(match_operand:CCI 1 "register_operand" ""))]
+   "reload_completed
+    && GET_CODE (operands[0]) == REG && GR_REGNO_P (REGNO (operands[0]))
+    && GET_CODE (operands[1]) == REG && PR_REGNO_P (REGNO (operands[1]))"
+   [(set (match_dup 2) (const_int 0))
+    (cond_exec (ne (match_dup 3) (const_int 0))
+      (set (match_dup 2) (const_int 1)))]
+   "operands[2] = gen_rtx_REG (BImode, REGNO (operands[0]));
+    operands[3] = gen_rtx_REG (BImode, REGNO (operands[1]));")
+ 
  (define_insn "movbi"
    [(set (match_operand:BI 0 "destination_operand" "=c,c,?c,?*r, c,*r,*r,*m,*r")
  	(match_operand:BI 1 "move_operand"        " O,n, c,  c,*r, n,*m,*r,*r"))]
*** gcc/config/ia64/div.md.0	2008-06-12 12:27:28.000000000 +0200
--- gcc/config/ia64/div.md	2008-06-12 10:44:44.000000000 +0200
***************
*** 20,26 ****
  
  (define_insn "addrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (plus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
--- 20,26 ----
  
  (define_insn "addrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (plus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
***************
*** 35,41 ****
  
  (define_insn "subrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (minus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
--- 35,41 ----
  
  (define_insn "subrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (minus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
***************
*** 50,56 ****
  
  (define_insn "mulrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (mult:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
--- 50,56 ----
  
  (define_insn "mulrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (mult:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
***************
*** 67,73 ****
  
  (define_insn "nmulrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (neg:RF (mult:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
--- 67,73 ----
  
  (define_insn "nmulrf3_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (neg:RF (mult:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
***************
*** 84,90 ****
  
  (define_insn "m1addrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (plus:RF
              (mult:RF
--- 84,90 ----
  
  (define_insn "m1addrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (plus:RF
              (mult:RF
***************
*** 101,107 ****
  
  (define_insn "m1subrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (minus:RF
              (mult:RF
--- 101,107 ----
  
  (define_insn "m1subrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (minus:RF
              (mult:RF
***************
*** 120,126 ****
  
  (define_insn "m2addrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (plus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
--- 120,126 ----
  
  (define_insn "m2addrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (plus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
***************
*** 137,143 ****
  
  (define_insn "m2subrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:BI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (minus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
--- 137,143 ----
  
  (define_insn "m2subrf4_cond"
    [(set (match_operand:RF 0 "fr_register_operand" "=f,f")
!         (if_then_else:RF (ne:RF (match_operand:CCI 1 "register_operand"  "c,c")
                                  (const_int 0))
            (minus:RF
              (match_operand:RF 2 "fr_reg_or_fp01_operand" "fG,fG")
***************
*** 202,209 ****
          (unspec:RF [(match_operand:RF 1 "fr_register_operand" "f")
  		    (match_operand:RF 2 "fr_register_operand" "f")]
  		   UNSPEC_FR_RECIP_APPROX_RES))
!    (set (match_operand:BI 3 "register_operand" "=c")
!         (unspec:BI [(match_dup 1) (match_dup 2)] UNSPEC_FR_RECIP_APPROX))
     (use (match_operand:SI 4 "const_int_operand" ""))]
    ""
    "frcpa.s%4 %0, %3 = %1, %2"
--- 202,209 ----
          (unspec:RF [(match_operand:RF 1 "fr_register_operand" "f")
  		    (match_operand:RF 2 "fr_register_operand" "f")]
  		   UNSPEC_FR_RECIP_APPROX_RES))
!    (set (match_operand:CCI 3 "register_operand" "=c")
!         (unspec:CCI [(match_dup 1) (match_dup 2)] UNSPEC_FR_RECIP_APPROX))
     (use (match_operand:SI 4 "const_int_operand" ""))]
    ""
    "frcpa.s%4 %0, %3 = %1, %2"
***************
*** 227,233 ****
    rtx q     = gen_reg_rtx (RFmode);
    rtx r     = gen_reg_rtx (RFmode);
    rtx q_res = gen_reg_rtx (RFmode);
!   rtx cond  = gen_reg_rtx (BImode);
    rtx zero    = CONST0_RTX (RFmode);
    rtx one     = CONST1_RTX (RFmode);
    rtx status0 = CONST0_RTX (SImode);
--- 227,233 ----
    rtx q     = gen_reg_rtx (RFmode);
    rtx r     = gen_reg_rtx (RFmode);
    rtx q_res = gen_reg_rtx (RFmode);
!   rtx cond  = gen_reg_rtx (CCImode);
    rtx zero    = CONST0_RTX (RFmode);
    rtx one     = CONST1_RTX (RFmode);
    rtx status0 = CONST0_RTX (SImode);
***************
*** 278,284 ****
    rtx y3    = gen_reg_rtx (RFmode);
    rtx q     = gen_reg_rtx (RFmode);
    rtx r     = gen_reg_rtx (RFmode);
!   rtx cond  = gen_reg_rtx (BImode);
    rtx zero    = CONST0_RTX (RFmode);
    rtx one     = CONST1_RTX (RFmode);
    rtx status0 = CONST0_RTX (SImode);
--- 278,284 ----
    rtx y3    = gen_reg_rtx (RFmode);
    rtx q     = gen_reg_rtx (RFmode);
    rtx r     = gen_reg_rtx (RFmode);
!   rtx cond  = gen_reg_rtx (CCImode);
    rtx zero    = CONST0_RTX (RFmode);
    rtx one     = CONST1_RTX (RFmode);
    rtx status0 = CONST0_RTX (SImode);
*** gcc/varasm.c.ori	Thu Jun 19 20:36:28 2008
--- gcc/varasm.c	Tue Jun 24 18:24:01 2008
*************** static void output_constant_def_contents
*** 118,124 ****
  static void output_addressed_constants (tree);
  static unsigned HOST_WIDE_INT array_size_for_constructor (tree);
  static unsigned min_align (unsigned, unsigned);
- static void output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int);
  static void globalize_decl (tree);
  #ifdef BSS_SECTION_ASM_OP
  #ifdef ASM_OUTPUT_BSS
--- 118,123 ----
*************** initializer_constant_valid_p (tree value
*** 4348,4353 ****
--- 4347,4401 ----
    return 0;
  }
  
+ /* Return true if VALUE is a valid constant-valued expression
+    for use in initializing a static bit-field; one that can be
+    an element of a "constant" initializer.  */
+ 
+ bool
+ initializer_constant_valid_for_bitfield_p (tree value)
+ {
+   /* For bitfields we support integer constants or possibly nested aggregates
+      of such.  */
+   switch (TREE_CODE (value))
+     {
+     case CONSTRUCTOR:
+       {
+ 	unsigned HOST_WIDE_INT idx;
+ 	tree elt;
+ 
+ 	FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (value), idx, elt)
+ 	  if (!initializer_constant_valid_for_bitfield_p (elt))
+ 	    return false;
+ 	return true;
+       }
+ 
+     case INTEGER_CST:
+       return true;
+ 
+     case VIEW_CONVERT_EXPR:
+     case NON_LVALUE_EXPR:
+       return
+ 	initializer_constant_valid_for_bitfield_p (TREE_OPERAND (value, 0));
+ 
+     default:
+       break;
+     }
+ 
+   return false;
+ }
+ 
+ /* output_constructor outer state of relevance in recursive calls, typically
+    for nested aggregate bitfields.  */
+ 
+ typedef struct {
+   unsigned int bit_offset;  /* current position in ...  */
+   int byte;                 /* ... the outer byte buffer.  */
+ } oc_outer_state;
+ 
+ static unsigned HOST_WIDE_INT
+   output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int,
+ 		      oc_outer_state *);
+ 
  /* Output assembler code for constant EXP to FILE, with no label.
     This includes the pseudo-op such as ".int" or ".byte", and a newline.
     Assumes output_addressed_constants has been done on EXP already.
*************** output_constant (tree exp, unsigned HOST
*** 4486,4492 ****
        switch (TREE_CODE (exp))
  	{
  	case CONSTRUCTOR:
! 	  output_constructor (exp, size, align);
  	  return;
  	case STRING_CST:
  	  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),
--- 4534,4540 ----
        switch (TREE_CODE (exp))
  	{
  	case CONSTRUCTOR:
! 	    output_constructor (exp, size, align, NULL);
  	  return;
  	case STRING_CST:
  	  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),
*************** output_constant (tree exp, unsigned HOST
*** 4524,4530 ****
      case RECORD_TYPE:
      case UNION_TYPE:
        gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);
!       output_constructor (exp, size, align);
        return;
  
      case ERROR_MARK:
--- 4572,4578 ----
      case RECORD_TYPE:
      case UNION_TYPE:
        gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);
!       output_constructor (exp, size, align, NULL);
        return;
  
      case ERROR_MARK:
*************** array_size_for_constructor (tree val)
*** 4580,4588 ****
    return tree_low_cst (i, 1);
  }
  
! /* Datastructures and helpers for output_constructor.  */
  
! /* Local output_constructor state to support interaction with helpers.  */
  
  typedef struct {
  
--- 4628,4636 ----
    return tree_low_cst (i, 1);
  }
  
! /* Other datastructures + helpers for output_constructor.  */
  
! /* output_constructor local state to support interaction with helpers.  */
  
  typedef struct {
  
*************** typedef struct {
*** 4598,4618 ****
  
    /* Output processing state per se.  */
    HOST_WIDE_INT total_bytes;  /* # bytes output so far / current position.  */
!   int byte_buffer_in_use;     /* whether byte ...  */
    int byte;                   /* ... contains part of a bitfield byte yet to
  			         be output.  */
  
    /* Current element.  */
    tree val;    /* current element value.  */
    tree index;  /* current element index.  */
  
  } oc_local_state;
  
! static void output_constructor_array_range (oc_local_state *local);
! static void output_constructor_regular_field (oc_local_state *local);
! static void output_constructor_bitfield (oc_local_state *local);
  
! /* Helper for output_constructor.  Output a RANGE_EXPR element.  */
  
  static void
  output_constructor_array_range (oc_local_state *local)
--- 4646,4669 ----
  
    /* Output processing state per se.  */
    HOST_WIDE_INT total_bytes;  /* # bytes output so far / current position.  */
!   bool byte_buffer_in_use;    /* whether byte ...  */
    int byte;                   /* ... contains part of a bitfield byte yet to
  			         be output.  */
  
+   int last_relative_index;    /* Implicit or explicit index of the last
+ 				 array element output within a bitfield.  */
    /* Current element.  */
    tree val;    /* current element value.  */
    tree index;  /* current element index.  */
  
  } oc_local_state;
  
! static void output_constructor_array_range (oc_local_state *);
! static void output_constructor_regular_field (oc_local_state *);
! static void output_constructor_bitfield (oc_local_state *, oc_outer_state *);
  
! /* Helper for output_constructor.  From the current LOCAL state, output a
!    RANGE_EXPR element.  */
  
  static void
  output_constructor_array_range (oc_local_state *local)
*************** output_constructor_array_range (oc_local
*** 4642,4649 ****
      }
  }
  
! /* Helper for output_constructor.  Output a field element that is not
!    bitfield.  */
  
  static void
  output_constructor_regular_field (oc_local_state *local)
--- 4693,4700 ----
      }
  }
  
! /* Helper for output_constructor.  From the current LOCAL state, output a
!    field element that is not true bitfield or part of an outer one.  */
  
  static void
  output_constructor_regular_field (oc_local_state *local)
*************** output_constructor_regular_field (oc_loc
*** 4665,4671 ****
      {
        assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
        local->total_bytes++;
!       local->byte_buffer_in_use = 0;
      }
    
    /* Advance to offset of this element.
--- 4716,4722 ----
      {
        assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
        local->total_bytes++;
!       local->byte_buffer_in_use = false;
      }
    
    /* Advance to offset of this element.
*************** output_constructor_regular_field (oc_loc
*** 4721,4746 ****
    local->total_bytes += fieldsize;
  }
  
! /* Helper for output_constructor.  Output a bitfield element.  */
  
  static void
! output_constructor_bitfield (oc_local_state *local)
  {
!   /* Offset in bits from the beginning of the structure to the next bit of
!      this element to be processed.  */
!   HOST_WIDE_INT next_offset = int_bit_position (local->field);
! 
!   /* Offset of the first bit past the end of this element.  */
!   HOST_WIDE_INT end_offset
!     = (next_offset + tree_low_cst (DECL_SIZE (local->field), 1));
    
-   if (local->val != 0 && TREE_CODE (local->val) != INTEGER_CST)
-     error ("invalid initial value for member %qs",
- 	   IDENTIFIER_POINTER (DECL_NAME (local->field)));
- 
    if (local->val == 0)
      local->val = integer_zero_node;
    
    /* If this field does not start in this (or, next) byte,
       skip some bytes.  */
    if (next_offset / BITS_PER_UNIT != local->total_bytes)
--- 4772,4830 ----
    local->total_bytes += fieldsize;
  }
  
! /* Helper for output_constructor.  From the current LOCAL and OUTER states,
!    output an element that is a true bitfield or part of an outer one.  */
  
  static void
! output_constructor_bitfield (oc_local_state *local, oc_outer_state *outer)
  {
!   /* Bit size of this element.  */
!   HOST_WIDE_INT ebitsize
!     = (local->field
!        ? tree_low_cst (DECL_SIZE (local->field), 1)
!        : tree_low_cst (TYPE_SIZE (TREE_TYPE (local->type)), 1));
! 
!   /* Relative index of this element if this is an array component.  */
!   HOST_WIDE_INT relative_index
!     = (!local->field
!        ? (local->index
! 	  ? (tree_low_cst (local->index, 0) 
! 	     - tree_low_cst (local->min_index, 0))
! 	  : local->last_relative_index + 1)
!        : 0);
!   
!   /* Bit position of this element from the start of the containing
!      constructor.  */
!   HOST_WIDE_INT constructor_relative_ebitpos
!       = (local->field
! 	 ? int_bit_position (local->field) 
! 	 : ebitsize * relative_index);
!   
!   /* Bit position of this element from the start of a possibly ongoing
!      outer byte buffer.  */
!   HOST_WIDE_INT byte_relative_ebitpos
!       = ((outer ? outer->bit_offset : 0) + constructor_relative_ebitpos);
! 
!   /* From the start of a possibly ongoing outer byte buffer, offsets to 
!      the first bit of this element and to the first bit past the end of
!      this element.  */
!   HOST_WIDE_INT next_offset = byte_relative_ebitpos;
!   HOST_WIDE_INT end_offset = byte_relative_ebitpos + ebitsize;
!   
!   local->last_relative_index = relative_index;
    
    if (local->val == 0)
      local->val = integer_zero_node;
    
+   while (TREE_CODE (local->val) == VIEW_CONVERT_EXPR
+ 	 || TREE_CODE (local->val) == NON_LVALUE_EXPR)
+     local->val = TREE_OPERAND (local->val, 0);
+     
+   if (TREE_CODE (local->val) != INTEGER_CST
+       && TREE_CODE (local->val) != CONSTRUCTOR)
+       error ("invalid initial value for member %qs",
+ 	     IDENTIFIER_POINTER (DECL_NAME (local->field)));
+ 
    /* If this field does not start in this (or, next) byte,
       skip some bytes.  */
    if (next_offset / BITS_PER_UNIT != local->total_bytes)
*************** output_constructor_bitfield (oc_local_st
*** 4750,4756 ****
  	{
  	  assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
  	  local->total_bytes++;
! 	  local->byte_buffer_in_use = 0;
  	}
        
        /* If still not at proper byte, advance to there.  */
--- 4834,4840 ----
  	{
  	  assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);
  	  local->total_bytes++;
! 	  local->byte_buffer_in_use = false;
  	}
        
        /* If still not at proper byte, advance to there.  */
*************** output_constructor_bitfield (oc_local_st
*** 4762,4774 ****
  	}
      }
    
!   if (! local->byte_buffer_in_use)
!     local->byte = 0;
    
!   /* We must split the element into pieces that fall within
!      separate bytes, and combine each byte with previous or
!      following bit-fields.  */
    
    while (next_offset < end_offset)
      {
        int this_time;
--- 4846,4876 ----
  	}
      }
    
!   /* Set up the buffer if necessary.  */
!   if (!local->byte_buffer_in_use)
!     {
!       local->byte = 0;
!       if (ebitsize > 0)
! 	local->byte_buffer_in_use = true;
!     }
    
!   /* If this is nested constructor, recurse passing the bit offset and the
!      pending data, then retrieve the new pending data afterwards.  */
!   if (TREE_CODE (local->val) == CONSTRUCTOR)
!     {
!       oc_outer_state output_state;
! 
!       output_state.bit_offset = next_offset % BITS_PER_UNIT;
!       output_state.byte = local->byte;
!       local->total_bytes
! 	  += output_constructor (local->val, 0, 0, &output_state);
!       local->byte = output_state.byte;
!       return;
!     }
    
+   /* Otherwise, we must split the element into pieces that fall within
+      separate bytes, and combine each byte with previous or following
+      bit-fields.  */  
    while (next_offset < end_offset)
      {
        int this_time;
*************** output_constructor_bitfield (oc_local_st
*** 4830,4836 ****
  	     take first the least significant bits of the value
  	     and pack them starting at the least significant
  	     bits of the bytes.  */
! 	  shift = next_offset - int_bit_position (local->field);
  	  
  	  /* Don't try to take a bunch of bits that cross
  	     the word boundary in the INTEGER_CST. We can
--- 4932,4938 ----
  	     take first the least significant bits of the value
  	     and pack them starting at the least significant
  	     bits of the bytes.  */
! 	  shift = next_offset - byte_relative_ebitpos;
  	  
  	  /* Don't try to take a bunch of bits that cross
  	     the word boundary in the INTEGER_CST. We can
*************** output_constructor_bitfield (oc_local_st
*** 4858,4873 ****
  	}
        
        next_offset += this_time;
!       local->byte_buffer_in_use = 1;
      }
  }
  
  /* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).
!    Generate at least SIZE bytes, padding if necessary.  */
  
! static void
  output_constructor (tree exp, unsigned HOST_WIDE_INT size,
! 		    unsigned int align)
  {
    unsigned HOST_WIDE_INT cnt;
    constructor_elt *ce;
--- 4960,4976 ----
  	}
        
        next_offset += this_time;
!       local->byte_buffer_in_use = true;
      }
  }
  
  /* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).
!    Generate at least SIZE bytes, padding if necessary.  OUTER designates the
!    caller output state of relevance in recursive invocations.  */
  
! static unsigned HOST_WIDE_INT
  output_constructor (tree exp, unsigned HOST_WIDE_INT size,
! 		    unsigned int align, oc_outer_state * outer)
  {
    unsigned HOST_WIDE_INT cnt;
    constructor_elt *ce;
*************** output_constructor (tree exp, unsigned H
*** 4880,4890 ****
    local.align = align;
  
    local.total_bytes = 0;
!   local.byte_buffer_in_use = 0;
!   local.byte = 0;
  
    local.type = TREE_TYPE (exp);
  
    local.min_index = 0;
    if (TREE_CODE (local.type) == ARRAY_TYPE
        && TYPE_DOMAIN (local.type) != 0)
--- 4983,4995 ----
    local.align = align;
  
    local.total_bytes = 0;
!   local.byte_buffer_in_use = outer != NULL;
!   local.byte = outer ? outer->byte : 0;
  
    local.type = TREE_TYPE (exp);
  
+   local.last_relative_index = -1;
+ 
    local.min_index = 0;
    if (TREE_CODE (local.type) == ARRAY_TYPE
        && TYPE_DOMAIN (local.type) != 0)
*************** output_constructor (tree exp, unsigned H
*** 4938,4964 ****
  
        /* Output the current element, using the appropriate helper ...  */
  
!       /* For an array slice.  */
!       if (local.index && TREE_CODE (local.index) == RANGE_EXPR)
  	output_constructor_array_range (&local);
  
!       /* For a field that is not a bitfield.  */
!       else if (local.field == 0 || !DECL_BIT_FIELD (local.field))
  	output_constructor_regular_field (&local);
! 
!       /* For a bitfield.  */
        else
! 	output_constructor_bitfield (&local);
      }
  
!   if (local.byte_buffer_in_use)
      {
!       assemble_integer (GEN_INT (local.byte), 1, BITS_PER_UNIT, 1);
!       local.total_bytes++;
!     }
  
!   if ((unsigned HOST_WIDE_INT)local.total_bytes < size)
!     assemble_zeros (size - local.total_bytes);
  }
  
  /* This TREE_LIST contains any weak symbol declarations waiting
--- 5043,5086 ----
  
        /* Output the current element, using the appropriate helper ...  */
  
!       /* For an array slice not part of an outer bitfield.  */
!       if (!outer
! 	  && local.index && TREE_CODE (local.index) == RANGE_EXPR)
  	output_constructor_array_range (&local);
  
!       /* For a field that is neither a true bitfield nor part of an outer one,
! 	 known to be at least byte aligned and multiple-of-bytes long.  */
!       else if (!outer
! 	       && (local.field == 0
! 		   || !DECL_BIT_FIELD (local.field)
! 		   || DECL_MODE (local.field) == BLKmode))
  	output_constructor_regular_field (&local);
!       
!       /* For a true bitfield or part of an outer one.  */
        else
! 	output_constructor_bitfield (&local, outer);
      }
  
!   /* If we are not at toplevel, save the pending data for our caller.
!      Otherwise output the pending data and padding zeros as needed. */
!   if (outer)
!     outer->byte = local.byte;
!   else
      {
!       if (local.byte_buffer_in_use)
! 	{
! 	  assemble_integer (GEN_INT (local.byte), 1, BITS_PER_UNIT, 1);
! 	  local.total_bytes++;
! 	}
  
!       if ((unsigned HOST_WIDE_INT)local.total_bytes < local.size)
! 	{
! 	  assemble_zeros (local.size - local.total_bytes);
! 	  local.total_bytes = local.size;
! 	}
!     }
!       
!   return local.total_bytes;
  }
  
  /* This TREE_LIST contains any weak symbol declarations waiting
*** gcc/output.h.ori	Wed Jun 25 09:36:31 2008
--- gcc/output.h	Fri Jun 20 00:51:50 2008
*************** extern bool constructor_static_from_elts
*** 296,301 ****
--- 296,306 ----
     arithmetic-combinations of integers.  */
  extern tree initializer_constant_valid_p (tree, tree);
  
+ /* Return true if VALUE is a valid constant-valued expression
+    for use in initializing a static bit-field; one that can be
+    an element of a "constant" initializer.  */
+ extern bool initializer_constant_valid_for_bitfield_p (tree);
+ 
  /* Output assembler code for constant EXP to FILE, with no label.
     This includes the pseudo-op such as ".int" or ".byte", and a newline.
     Assumes output_addressed_constants has been done on EXP already.
*** gcc/dwarf2out.c	Thu Jun 26 12:25:59 2008
--- gcc/dwarf2out.c	Thu Jun 26 12:25:40 2008
*************** static void add_artificial_attribute_for
*** 4485,4491 ****
  static void add_descriptive_attribute_for_type (dw_die_ref, tree, dw_die_ref);
  static void add_comp_dir_attribute (dw_die_ref);
  static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);
! static void add_subscript_info (dw_die_ref, tree);
  static void add_byte_size_attribute (dw_die_ref, tree);
  static void add_bit_offset_attribute (dw_die_ref, tree);
  static void add_bit_size_attribute (dw_die_ref, tree);
--- 4485,4491 ----
  static void add_descriptive_attribute_for_type (dw_die_ref, tree, dw_die_ref);
  static void add_comp_dir_attribute (dw_die_ref);
  static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);
! static void add_subscript_info (dw_die_ref, tree, bool);
  static void add_byte_size_attribute (dw_die_ref, tree);
  static void add_bit_offset_attribute (dw_die_ref, tree);
  static void add_bit_size_attribute (dw_die_ref, tree);
*************** add_bound_info (dw_die_ref subrange_die,
*** 11365,11400 ****
      }
  }
  
! /* Note that the block of subscript information for an array type also
!    includes information about the element type of type given array type.  */
  
  static void
! add_subscript_info (dw_die_ref type_die, tree type)
  {
- #ifndef MIPS_DEBUGGING_INFO
    unsigned dimension_number;
- #endif
    tree lower, upper;
    dw_die_ref subrange_die;
  
-   /* The GNU compilers represent multidimensional array types as sequences of
-      one dimensional array types whose element types are themselves array
-      types.  Here we squish that down, so that each multidimensional array
-      type gets only one array_type DIE in the Dwarf debugging info. The draft
-      Dwarf specification say that we are allowed to do this kind of
-      compression in C (because there is no difference between an array or
-      arrays and a multidimensional array in C) but for other source languages
-      (e.g. Ada) we probably shouldn't do this.  */
- 
-   /* ??? The SGI dwarf reader fails for multidimensional arrays with a
-      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].
-      We work around this by disabling this feature.  See also
-      gen_array_type_die.  */
- #ifndef MIPS_DEBUGGING_INFO
    for (dimension_number = 0;
!        TREE_CODE (type) == ARRAY_TYPE;
         type = TREE_TYPE (type), dimension_number++)
- #endif
      {
        tree domain = TYPE_DOMAIN (type);
  
--- 11365,11385 ----
      }
  }
  
! /* Add subscript info to TYPE_DIE, describing an array TYPE, collapsing
!    possibly nested array subscripts in a flat sequence if COLLAPSE_P is true.
!    Note that the block of subscript information for an array type also
!    includes information about the element type of the given array type.  */
  
  static void
! add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)
  {
    unsigned dimension_number;
    tree lower, upper;
    dw_die_ref subrange_die;
  
    for (dimension_number = 0;
!        TREE_CODE (type) == ARRAY_TYPE && (dimension_number == 0 || collapse_p);
         type = TREE_TYPE (type), dimension_number++)
      {
        tree domain = TYPE_DOMAIN (type);
  
*************** gen_array_type_die (tree type, dw_die_re
*** 11923,11928 ****
--- 12014,12030 ----
    dw_die_ref array_die;
    tree element_type;
  
+   /* GNU compilers represent multidimensional array types as sequences of one
+      dimensional array types whose element types are themselves array types.
+      We sometimes squish that down to a single array_type DIE with multiple
+      subscripts in the Dwarf debugging info.  The draft Dwarf specification
+      say that we are allowed to do this kind of compression in C, because
+      there is no difference between an array of arrays and a multidimensional
+      array.  We don't do this for Ada to remain as close as possible to the
+      actual representation, which is especially important against the language
+      flexibilty wrt arrays of variable size.  */
+   bool collapse_nested_arrays = !is_ada ();
+ 
    /* Emit DW_TAG_string_type for Fortran character types (with kind 1 only, as
       DW_TAG_string_type doesn't have DW_AT_type attribute).  */
    if (TYPE_STRING_FLAG (type)
*************** gen_array_type_die (tree type, dw_die_re
*** 11956,11966 ****
        return;
      }
  
!   /* ??? The SGI dwarf reader fails for array of array of enum types unless
!      the inner array type comes before the outer array type.  Thus we must
!      call gen_type_die before we call new_die.  See below also.  */
  #ifdef MIPS_DEBUGGING_INFO
    gen_type_die (TREE_TYPE (type), context_die);
  #endif
  
    array_die = new_die (DW_TAG_array_type, scope_die, type);
--- 12058,12070 ----
        return;
      }
  
!   /* ??? The SGI dwarf reader fails for array of array of enum types
!      (e.g. const enum machine_mode insn_operand_mode[2][10]) unless the inner
!      array type comes before the outer array type.  We thus call gen_type_die
!      before we new_die and must prevent nested array types collapsing.  */
  #ifdef MIPS_DEBUGGING_INFO
    gen_type_die (TREE_TYPE (type), context_die);
+   collapse_nested_arrays = false;
  #endif
  
    array_die = new_die (DW_TAG_array_type, scope_die, type);
*************** gen_array_type_die (tree type, dw_die_re
*** 12002,12020 ****
      add_AT_flag (array_die, DW_AT_declaration, 1);
    else
  #endif
!     add_subscript_info (array_die, type);
  
!   /* Add representation of the type of the elements of this array type.  */
    element_type = TREE_TYPE (type);
! 
!   /* ??? The SGI dwarf reader fails for multidimensional arrays with a
!      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].
!      We work around this by disabling this feature.  See also
!      add_subscript_info.  */
  #ifndef MIPS_DEBUGGING_INFO
-   while (TREE_CODE (element_type) == ARRAY_TYPE)
-     element_type = TREE_TYPE (element_type);
- 
    gen_type_die (element_type, context_die);
  #endif
  
--- 12003,12018 ----
      add_AT_flag (array_die, DW_AT_declaration, 1);
    else
  #endif
!     add_subscript_info (array_die, type, collapse_nested_arrays);
  
!   /* Add representation of the type of the elements of this array type and
!      emit the corresponding DIE if we haven't done it already.  */  
    element_type = TREE_TYPE (type);
!   if (collapse_nested_arrays)
!     while (TREE_CODE (element_type) == ARRAY_TYPE)
!       element_type = TREE_TYPE (element_type);
!   
  #ifndef MIPS_DEBUGGING_INFO
    gen_type_die (element_type, context_die);
  #endif
  
*** gcc/gimplify.c	(revision 137170)
--- gcc/gimplify.c	(working copy)
*************** gimplify_modify_expr_to_memcpy (tree *ex
*** 2841,2848 ****
  static enum gimplify_status
  gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value)
  {
!   tree t, to, to_ptr;
  
    to = GENERIC_TREE_OPERAND (*expr_p, 0);
  
    to_ptr = build_fold_addr_expr (to);
--- 2841,2859 ----
  static enum gimplify_status
  gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value)
  {
!   tree t, from, to, to_ptr;
  
+   /* Assert our assumptions, to abort instead of producing wrong code
+      silently if they are not met.  Beware that the RHS CONSTRUCTOR might
+      not be immediately exposed.  */
+   from = GENERIC_TREE_OPERAND (*expr_p, 1);  
+   if (TREE_CODE (from) == WITH_SIZE_EXPR)
+     from = TREE_OPERAND (from, 0);
+ 
+   gcc_assert (TREE_CODE (from) == CONSTRUCTOR
+ 	      && VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (from)));
+ 
+   /* Now proceed.  */
    to = GENERIC_TREE_OPERAND (*expr_p, 0);
  
    to_ptr = build_fold_addr_expr (to);
*** gcc/config/sparc/sparc.h.0	2008-06-30 20:46:36.439981816 +0200
--- gcc/config/sparc/sparc.h	2008-06-30 20:46:51.107751976 +0200
*************** enum reg_class { NO_REGS, FPCC_REGS, I64
*** 1080,1091 ****
     SImode loads to floating-point registers are not zero-extended.
     The definition for LOAD_EXTEND_OP specifies that integer loads
     narrower than BITS_PER_WORD will be zero-extended.  As a result,
!    we inhibit changes from SImode unless they are to a mode that is
!    identical in size.  */
  
  #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)		\
    (TARGET_ARCH64						\
!    && (FROM) == SImode						\
     && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)		\
     ? reg_classes_intersect_p (CLASS, FP_REGS) : 0)
  
--- 1080,1091 ----
     SImode loads to floating-point registers are not zero-extended.
     The definition for LOAD_EXTEND_OP specifies that integer loads
     narrower than BITS_PER_WORD will be zero-extended.  As a result,
!    we inhibit changes from SImode and SFmode unless they are to a
!    mode that is identical in size.  */
  
  #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)		\
    (TARGET_ARCH64						\
!    && ((FROM) == SImode || (FROM) == SFmode)			\
     && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)		\
     ? reg_classes_intersect_p (CLASS, FP_REGS) : 0)
  
*** gcc/config/i386/mingw32.h.ori	Sat Jul  5 18:26:39 2008
--- gcc/config/i386/mingw32.h	Sat Jul  5 18:29:45 2008
*************** along with GCC; see the file COPYING3.  
*** 74,80 ****
    %{shared: %{mdll: %eshared and mdll are not compatible}} \
    %{shared: --shared} %{mdll:--dll} \
    %{static:-Bstatic} %{!static:-Bdynamic} \
!   %{shared|mdll: -e _DllMainCRTStartup@12}"
  
  /* Include in the mingw32 libraries with libgcc */
  #undef LIBGCC_SPEC
--- 74,81 ----
    %{shared: %{mdll: %eshared and mdll are not compatible}} \
    %{shared: --shared} %{mdll:--dll} \
    %{static:-Bstatic} %{!static:-Bdynamic} \
!   %{shared|mdll: -e _DllMainCRTStartup@12} \
!   --enable-auto-import --enable-runtime-pseudo-reloc"
  
  /* Include in the mingw32 libraries with libgcc */
  #undef LIBGCC_SPEC
*** gcc/dwarf2out.c.0	2008-07-07 17:46:07.887031368 +0200
--- gcc/dwarf2out.c	2008-07-07 17:46:13.136233368 +0200
*************** is_subrange_type (const_tree type)
*** 8793,8799 ****
      return false;
  
    if (TREE_CODE (subtype) != INTEGER_TYPE
!       && TREE_CODE (subtype) != ENUMERAL_TYPE)
      return false;
  
    if (TREE_CODE (type) == TREE_CODE (subtype)
--- 8793,8800 ----
      return false;
  
    if (TREE_CODE (subtype) != INTEGER_TYPE
!       && TREE_CODE (subtype) != ENUMERAL_TYPE
!       && TREE_CODE (subtype) != BOOLEAN_TYPE)
      return false;
  
    if (TREE_CODE (type) == TREE_CODE (subtype)
*** gcc/tree-nested.c.0	2008-07-08 11:52:37.493932544 +0200
--- gcc/tree-nested.c	2008-07-08 12:10:14.220285720 +0200
*************** walk_stmts (struct walk_stmt_info *wi, t
*** 678,683 ****
--- 678,684 ----
        break;
  
      case COND_EXPR:
+       wi->val_only = true;
        walk_tree (&COND_EXPR_COND (t), wi->callback, wi, NULL);
        walk_stmts (wi, &COND_EXPR_THEN (t));
        walk_stmts (wi, &COND_EXPR_ELSE (t));
*** gcc/config/i386/linux-unwind.h.0	2008-07-07 13:44:39.000000000 +0200
--- gcc/config/i386/linux-unwind.h	2008-07-07 13:47:40.000000000 +0200
*************** x86_fallback_frame_state (struct _Unwind
*** 176,181 ****
--- 176,200 ----
    fs->signal_frame = 1;
    return _URC_NO_REASON;
  }
+ 
+ #define MD_FROB_UPDATE_CONTEXT x86_frob_update_context
+ 
+ /* Fix up for kernels that have vDSO, but don't have S flag in it.  */
+ 
+ static void
+ x86_frob_update_context (struct _Unwind_Context *context,
+ 			 _Unwind_FrameState *fs)
+ {
+   unsigned char *pc = context->ra;
+ 
+   /* movl $__NR_rt_sigreturn,%eax ; {int $0x80 | syscall}  */
+   if (*(unsigned char *)(pc+0) == 0xb8
+       && *(unsigned int *)(pc+1) == 173
+       && (*(unsigned short *)(pc+5) == 0x80cd
+ 	  || *(unsigned short *)(pc+5) == 0x050f))
+     _Unwind_SetSignalFrame (context, 1);
+ }
+ 
  #endif /* not glibc 2.0 */
  #endif /* ifdef __x86_64__  */
  #endif /* ifdef inhibit_libc  */
*** gcc/config/i386/w32-unwind.h.0	2008-07-08 18:11:48.816205832 +0200
--- gcc/config/i386/w32-unwind.h	2008-07-08 18:15:19.240216520 +0200
*************** i386_w32_fallback_frame_state (struct _U
*** 132,138 ****
  
    /* In the test below we look for two specific patterns found
       experimentally to be in the Windows signal handler.  */
- 
    if (SIG_PAT1 || SIG_PAT2 || SIG_SEH1 || SIG_SEH2)
      {
        PEXCEPTION_POINTERS weinfo_;
--- 132,137 ----
*************** i386_w32_fallback_frame_state (struct _U
*** 150,163 ****
  	}
  
        /* The new context frame address is the stack pointer.  */
- 
        new_cfa_ = proc_ctx_->Esp;
        fs->regs.cfa_how = CFA_REG_OFFSET;
        fs->regs.cfa_reg = __builtin_dwarf_sp_column();
        fs->regs.cfa_offset = new_cfa_ - (long) ctx_cfa_;
  
        /* Save some registers.  */
- 
        fs->regs.reg[0].how = REG_SAVED_OFFSET;
        fs->regs.reg[0].loc.offset = (long)&proc_ctx_->Eax - new_cfa_;
        fs->regs.reg[3].how = REG_SAVED_OFFSET;
--- 149,160 ----
*************** i386_w32_fallback_frame_state (struct _U
*** 170,187 ****
        fs->regs.reg[6].loc.offset = (long)&proc_ctx_->Esi - new_cfa_;
        fs->regs.reg[7].how = REG_SAVED_OFFSET;
        fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;
-       fs->regs.reg[9].how = REG_SAVED_OFFSET;
-       fs->regs.reg[9].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;
        fs->regs.reg[5].how = REG_SAVED_OFFSET;
        fs->regs.reg[5].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;
- 
-       /* Set the return address to Eip + 1. As we can be called multiple
- 	 times we use another register for this.  */
-       
-       proc_ctx_->Dr0 = proc_ctx_->Eip + 1;
        fs->regs.reg[8].how = REG_SAVED_OFFSET;
!       fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Dr0 - new_cfa_;
        fs->retaddr_column = 8;
        return _URC_NO_REASON;
      }
  
--- 167,179 ----
        fs->regs.reg[6].loc.offset = (long)&proc_ctx_->Esi - new_cfa_;
        fs->regs.reg[7].how = REG_SAVED_OFFSET;
        fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;
        fs->regs.reg[5].how = REG_SAVED_OFFSET;
        fs->regs.reg[5].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;
        fs->regs.reg[8].how = REG_SAVED_OFFSET;
!       fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;
        fs->retaddr_column = 8;
+       fs->signal_frame = 1;
+ 
        return _URC_NO_REASON;
      }
  
*************** i386_w32_fallback_frame_state (struct _U
*** 189,195 ****
       one of it's probes prior to the real SP adjustment. The only
       operations of interest performed is "pushl %ecx", followed by
       ecx clobbering.  */
- 
    else if (SIG_ALLOCA) 
      {
        /* Only one push between entry in _alloca and the probe trap.  */ 
--- 181,186 ----
*************** i386_w32_fallback_frame_state (struct _U
*** 207,213 ****
        fs->retaddr_column = 8;
        fs->regs.reg[8].how = REG_SAVED_OFFSET;
        fs->regs.reg[8].loc.offset = 0;
!  
        return _URC_NO_REASON;
      }
    else
--- 198,205 ----
        fs->retaddr_column = 8;
        fs->regs.reg[8].how = REG_SAVED_OFFSET;
        fs->regs.reg[8].loc.offset = 0;
!       fs->signal_frame = 1;
! 
        return _URC_NO_REASON;
      }
    else
*** gcc/config/pa/hpux-unwind.h.0	2008-07-08 18:16:41.464716496 +0200
--- gcc/config/pa/hpux-unwind.h	2008-07-08 18:17:15.861487392 +0200
*************** pa_fallback_frame_state (struct _Unwind_
*** 355,360 ****
--- 355,361 ----
  
        fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
        UPDATE_FS_FOR_PC (fs, DWARF_ALT_FRAME_RETURN_COLUMN);
+       fs->signal_frame = 1;
  
        return _URC_NO_REASON;
      }
*** gcc/config/i386/sol2.h.0	2008-07-08 23:39:35.026487432 +0200
--- gcc/config/i386/sol2.h	2008-07-04 23:44:17.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 112,114 ****
--- 112,116 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ #define MD_UNWIND_SUPPORT "config/i386/sol2-unwind.h"
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/i386/sol2-unwind.h	2008-07-08 23:38:12.288065584 +0200
***************
*** 0 ****
--- 1,156 ----
+ /* DWARF2 EH unwinding support for x86.
+    Copyright (C) 2007 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR sol2_fallback_frame_state
+ 
+ #include <signal.h>
+ #include <siginfo.h>
+ #include <sys/ucontext.h>
+ #include <sys/regset.h>
+ 
+ static _Unwind_Reason_Code
+ sol2_fallback_frame_state (struct _Unwind_Context *context,
+ 			   _Unwind_FrameState *fs)
+ {
+   static int eh_debug = -1;
+ 
+   unsigned char *ra = context->ra;
+   ucontext_t *uctx;
+   mcontext_t *mctx;
+   long new_cfa;
+   
+   int context_is_sighandler;
+ 
+   if (eh_debug == -1)
+     eh_debug = getenv ("EH_DEBUG") != 0;
+ 
+   if (eh_debug)
+     printf ("FALLBACK # ra = 0x%p, cfa = 0x%p...\n",
+ 	    context->ra, context->cfa);
+ 
+   context_is_sighandler =
+     /* Solaris 2.8 - mono thread
+        -------------------------
+        <sigacthandler+17>:  mov    0x10(%ebp),%esi
+        <sigacthandler+20>:  push   %esi
+        <sigacthandler+21>:  pushl  0xc(%ebp)
+        <sigacthandler+24>:  mov    0x8(%ebp),%ecx
+        <sigacthandler+27>:  push   %ecx
+        <sigacthandler+28>:  mov    0x244(%ebx),%eax
+        <sigacthandler+34>:  call   *(%eax,%ecx,4)
+        <sigacthandler+37>:  add    $0xc,%esp        <--- context->ra
+        <sigacthandler+40>:  push   %esi ... */
+     (*(unsigned long *)(ra - 20) == 0x5610758b
+      && *(unsigned long *)(ra - 16) == 0x8b0c75ff
+      && *(unsigned long *)(ra - 12) == 0x8b51084d
+      && *(unsigned long *)(ra - 8)  == 0x00024483
+      && *(unsigned long *)(ra - 4)  == 0x8814ff00
+      && *(unsigned long *)(ra - 0)  == 0x560cc483)
+ 
+     ||  /* Solaris 2.8 - multi threads
+ 	   ---------------------------
+ 	   <__sighndlr+0>:      push   %ebp
+ 	   <__sighndlr+1>:      mov    %esp,%ebp
+ 	   <__sighndlr+3>:      pushl  0x10(%ebp)
+ 	   <__sighndlr+6>:      pushl  0xc(%ebp)
+ 	   <__sighndlr+9>:      pushl  0x8(%ebp)
+ 	   <__sighndlr+12>:     call   *0x14(%ebp)
+ 	   <__sighndlr+15>:     leave               <--- context->ra  */
+     (*(unsigned long *)(ra - 15) == 0xffec8b55
+      && *(unsigned long *)(ra - 11) == 0x75ff1075
+      && *(unsigned long *)(ra - 7)  == 0x0875ff0c
+      && *(unsigned long *)(ra - 3)  == 0xc91455ff)
+ 
+     ||  /* Solaris 2.10
+ 	   ------------
+ 	   <__sighndlr+0>:      push   %ebp
+ 	   <__sighndlr+1>:      mov    %esp,%ebp
+ 	   <__sighndlr+3>:      pushl  0x10(%ebp)
+ 	   <__sighndlr+6>:      pushl  0xc(%ebp)
+ 	   <__sighndlr+9>:      pushl  0x8(%ebp)
+ 	   <__sighndlr+12>:     call   *0x14(%ebp)
+ 	   <__sighndlr+15>:     add    $0xc,%esp     <--- context->ra
+ 	   <__sighndlr+18>:     leave
+ 	   <__sighndlr+19>:     ret  */
+     (*(unsigned long *)(ra - 15) == 0xffec8b55
+      && *(unsigned long *)(ra - 11) == 0x75ff1075
+      && *(unsigned long *)(ra - 7)  == 0x0875ff0c
+      && *(unsigned long *)(ra - 3)  == 0x831455ff
+      && *(unsigned long *)(ra + 1)  == 0xc3c90cc4);
+ 
+   if (context_is_sighandler)
+     {
+       typedef struct {
+ 	int signo;
+ 	siginfo_t  * siginfo;
+ 	ucontext_t * ucontext;
+       } handler_args_t;
+ 
+       handler_args_t * handler_args = context->cfa;
+ 
+       uctx = handler_args->ucontext;
+       mctx = &uctx->uc_mcontext;
+     }
+   else
+     return _URC_END_OF_STACK;
+ 
+   if (eh_debug)
+     printf ("FALLBACK - uctx = 0x%p, mctx = 0x%p\n", uctx, mctx);
+ 
+   new_cfa = mctx->gregs[UESP];
+ 
+   fs->regs.cfa_how = CFA_REG_OFFSET;
+   fs->regs.cfa_reg = 4;
+   fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+ 
+   /* The SVR4 register numbering macros aren't usable in libgcc.  */
+   fs->regs.reg[0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[0].loc.offset = (long)&mctx->gregs[EAX] - new_cfa;
+   fs->regs.reg[3].how = REG_SAVED_OFFSET;
+   fs->regs.reg[3].loc.offset = (long)&mctx->gregs[EBX] - new_cfa;
+   fs->regs.reg[1].how = REG_SAVED_OFFSET;
+   fs->regs.reg[1].loc.offset = (long)&mctx->gregs[ECX] - new_cfa;
+   fs->regs.reg[2].how = REG_SAVED_OFFSET;
+   fs->regs.reg[2].loc.offset = (long)&mctx->gregs[EDX] - new_cfa;
+   fs->regs.reg[6].how = REG_SAVED_OFFSET;
+   fs->regs.reg[6].loc.offset = (long)&mctx->gregs[ESI] - new_cfa;
+   fs->regs.reg[7].how = REG_SAVED_OFFSET;
+   fs->regs.reg[7].loc.offset = (long)&mctx->gregs[EDI] - new_cfa;
+   fs->regs.reg[5].how = REG_SAVED_OFFSET;
+   fs->regs.reg[5].loc.offset = (long)&mctx->gregs[EBP] - new_cfa;
+   fs->regs.reg[8].how = REG_SAVED_OFFSET;
+   fs->regs.reg[8].loc.offset = (long)&mctx->gregs[EIP] - new_cfa;
+   fs->retaddr_column = 8;
+   fs->signal_frame = 1;
+ 
+   if (eh_debug)
+     printf ("FALLBACK - ncfa = 0x%p, nip = 0x%p\n",
+ 	    (void *)new_cfa, (void *)mctx->gregs[EIP]);
+ 
+   return _URC_NO_REASON;
+ }
*** gcc/config/sparc/sol2.h.0	2008-07-08 23:35:14.242132680 +0200
--- gcc/config/sparc/sol2.h	2008-07-04 23:44:17.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 179,181 ****
--- 179,183 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ #define MD_UNWIND_SUPPORT "config/sparc/sol2-unwind.h"
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/sparc/sol2-unwind.h	2008-07-08 23:52:52.081316680 +0200
***************
*** 0 ****
--- 1,460 ----
+ /* DWARF2 EH unwinding support for SPARC Solaris.
+    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #include <ucontext.h>
+ 
+ /* Handle multilib correctly.  */
+ #if defined(__arch64__)
+ 
+ /* 64-bit SPARC version */
+ #define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ sparc64_fallback_frame_state (struct _Unwind_Context *context,
+ 			      _Unwind_FrameState *fs)
+ {
+   void *pc = context->ra;
+   void *this_cfa = context->cfa;
+   void *new_cfa, *ra_location, *shifted_ra_location;
+   int regs_off;
+   int fpu_save_off;
+   unsigned char fpu_save;
+   int i;
+ 
+   /* This is the observed pattern for the sigacthandler in Solaris 8.  */
+   unsigned int sigacthandler_sol8_pattern []
+     = {0x9401400f, 0xca5aafa0, 0x913e2000, 0x892a3003,
+        0xe0590005, 0x9fc40000, 0x9410001a, 0x80a6e008};
+ 
+   /* This is the observed pattern for the sigacthandler in Solaris 9.  */ 
+   unsigned int sigacthandler_sol9_pattern []
+     = {0xa33e2000, 0x00000000, 0x892c7003, 0x90100011,
+        0xe0590005, 0x9fc40000, 0x9410001a, 0x80a46008};
+ 
+   /* This is the observed pattern for the __sighndlr.  */
+   unsigned int sighndlr_pattern []
+     = {0x9de3bf50, 0x90100018, 0x92100019, 0x9fc6c000,
+        0x9410001a, 0x81c7e008, 0x81e80000};
+ 
+   /* Deal with frame-less function from which a signal was raised.  */
+   if (_Unwind_IsSignalFrame (context))
+     {
+       /* The CFA is by definition unmodified in this case.  */
+       fs->regs.cfa_how = CFA_REG_OFFSET;
+       fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+       fs->regs.cfa_offset = 0;
+ 
+       /* This is the canonical RA column.  */
+       fs->retaddr_column = 15;
+ 
+       return _URC_NO_REASON;
+     }
+ 
+   /* Look for the sigacthandler pattern.  The pattern changes slightly
+      in different versions of the operating system, so we skip the
+      comparison against pc-(4*6) for Solaris 9.  */
+   if ((    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol8_pattern[0]
+ 	&& *(unsigned int *)(pc-(4*6)) == sigacthandler_sol8_pattern[1]
+ 	&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol8_pattern[2]
+ 	&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol8_pattern[3]
+ 	&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol8_pattern[4]
+ 	&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol8_pattern[5]
+ 	&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol8_pattern[6]
+ 	&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol8_pattern[7] ) ||
+       (    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol9_pattern[0]
+ 	/* skip pc-(4*6) */
+ 	&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol9_pattern[2]
+ 	&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol9_pattern[3]
+ 	&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol9_pattern[4]
+ 	&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol9_pattern[5]
+ 	&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol9_pattern[6]
+ 	&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol9_pattern[7] ) )
+     /* We need to move up two frames (the kernel frame and the handler
+        frame).  Minimum stack frame size is 176 bytes (128 + 48): 128
+        bytes for spilling register window (16 extended words for in
+        and local registers), and 6 extended words to store at least
+        6 arguments to callees, The kernel frame and the sigacthandler
+        both have this minimal stack.  The ucontext_t structure is after
+        this offset.  */
+     regs_off = 176 + 176;
+ 
+   /* Look for the __sighndlr pattern.  */
+   else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
+ 	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
+ 	    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]
+ 	    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]
+ 	    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]
+ 	    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]
+ 	    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )
+     {
+       /* We have observed different calling frames among different
+ 	 versions of the operating system, so that we need to
+ 	 discriminate using the upper frame.  We look for the return
+ 	 address of the caller frame (there is an offset of 15 double
+ 	 words between the frame address and the place where this return
+ 	 address is stored) in order to do some more pattern matching.  */
+       if (*(unsigned int *)(*(unsigned long *)(this_cfa + 15*8) - 4)
+ 	    == 0x9410001a)
+ 	/* In Solaris 9 we need to move up four frames (the kernel frame,
+ 	   the sigacthandler frame, the call_user_handler, and the
+ 	   __sighndlr frame).  The kernel frame has a stack frame size of
+ 	   176, the __sighndlr frames of 304 bytes, 176 bytes for the
+ 	   call_user_handler frame, and another 176 bytes for the
+ 	   sigacthandler frame.  The ucontext_t structure is after this
+ 	   offset.  */
+ 	regs_off = 176 + 304 + 176 + 176;
+       else
+ 	/* We need to move up three frames (the kernel frame, the
+ 	   sigacthandler frame, and the __sighndlr frame).  The kernel
+ 	   frame has a stack frame size of 176, the __sighndlr frames of
+ 	   304 bytes, and there is a stack frame of 176 bytes for the
+ 	   sigacthandler frame.  The ucontext_t structure is after this
+ 	   offset.  */
+ 	regs_off = 176 + 304 + 176;
+     }
+ 
+   /* Exit if the pattern at the return address does not match the
+      previous three patterns.  */
+   else
+     return _URC_END_OF_STACK;
+ 
+   /* FPU information can be extracted from the ucontext_t structure 
+      that is the third argument for the signal handler, that is saved
+      in the stack.  There are 64 bytes between the beginning of the
+      ucontext_t argument of the signal handler and the uc_mcontext
+      field.  There are 176 bytes between the beginning of uc_mcontext
+      and the beginning of the fpregs field.  */
+   fpu_save_off = regs_off + (8*10) + 176;
+ 
+   /* The fpregs field contains 32 extended words at the beginning that
+      contain the fpu state.  Then there are 2 extended words and two
+      bytes.  */
+   fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (8*32) + (2*8) + 2);
+ 
+   /* We need to get the frame pointer for the kernel frame that
+      executes when the signal is raised.  This frame is just the
+      following to the application code that generated the signal, so
+      that the later's stack pointer is the former's frame pointer.
+      The stack pointer for the interrupted application code can be
+      calculated from the ucontext_t structure (third argument for the
+      signal handler) that is saved in the stack.  There are 10 words
+      between the beginning of the  ucontext_t argument  of the signal
+      handler and the uc_mcontext.gregs field that contains the
+      registers saved by the signal handler.  */
+   new_cfa = *(void **)(this_cfa + regs_off + (8*10) + (REG_SP*8));
+   /* The frame address is %sp + STACK_BIAS in 64-bit mode. */
+   new_cfa += 2047;
+   fs->regs.cfa_how = CFA_REG_OFFSET;
+   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+   fs->regs.cfa_offset = new_cfa - this_cfa;
+ 
+   /* Restore global and out registers (in this order) from the
+      ucontext_t structure, uc_mcontext.gregs field.  */
+   for (i = 1; i < 16; i++)
+     {
+       /* We never restore %sp as everything is purely CFA-based.  */
+       if ((unsigned int) i == __builtin_dwarf_sp_column ())
+ 	continue;
+ 
+       /* First the global registers and then the out registers.  */
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset
+ 	= this_cfa + regs_off + (8*10) + ((REG_Y+i)*8) - new_cfa;
+     }
+ 
+   /* Just above the stack pointer there are 16 extended words in which
+      the register window (in and local registers) was saved.  */
+   for (i = 0; i < 16; i++)
+     {
+       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i + 16].loc.offset = i*8;
+     }
+ 
+   /* Check whether we need to restore fpu registers.  */
+   if (fpu_save)
+     {
+       for (i = 0; i < 64; i++)
+ 	{
+ 	  if (i > 32 && (i & 1))
+ 	    continue;
+ 
+ 	  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;
+ 	  fs->regs.reg[i + 32].loc.offset
+ 	    = this_cfa + fpu_save_off + (i*4) - new_cfa;
+ 	}
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which is
+      the address of the active instruction when the signal was caught.
+      On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we
+      need to preventively subtract it from the purported return address.  */
+   ra_location = this_cfa + regs_off + (8*10) + (REG_PC*8);
+   shifted_ra_location = this_cfa + regs_off + (8*10) + (REG_Y*8);
+   *(void **)shifted_ra_location = *(void **)ra_location - 8;
+   fs->retaddr_column = 0;
+   fs->regs.reg[0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;
+   fs->signal_frame = 1;
+ 
+   return _URC_NO_REASON;
+ }
+ 
+ #define MD_FROB_UPDATE_CONTEXT sparc64_frob_update_context
+ 
+ static void
+ sparc64_frob_update_context (struct _Unwind_Context *context,
+ 			     _Unwind_FrameState *fs)
+ {
+   /* The column of %sp contains the old CFA, not the old value of %sp.
+      The CFA offset already comprises the stack bias so, when %sp is the
+      CFA register, we must avoid counting the stack bias twice.  Do not
+      do that for signal frames as the offset is artificial for them.  */
+   if (fs->regs.cfa_reg == __builtin_dwarf_sp_column ()
+       && fs->regs.cfa_how == CFA_REG_OFFSET
+       && fs->regs.cfa_offset != 0
+       && !fs->signal_frame)
+     context->cfa -= 2047;
+ }
+ 
+ #else
+ 
+ /* 32-bit SPARC version */
+ #define MD_FALLBACK_FRAME_STATE_FOR sparc_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ sparc_fallback_frame_state (struct _Unwind_Context *context,
+ 			    _Unwind_FrameState *fs)
+ {
+   void *pc = context->ra;
+   void *this_cfa = context->cfa;
+   void *new_cfa, *ra_location, *shifted_ra_location;
+   int regs_off;
+   int fpu_save_off;
+   unsigned char fpu_save;
+   int i;
+ 
+   /* This is the observed pattern for the sigacthandler.  */
+   unsigned int sigacthandler_pattern []
+     = {0x9602400f, 0x92100019, 0x00000000, 0x912e2002,
+        0xe002000a, 0x90100018, 0x9fc40000, 0x9410001a,
+        0x80a62008};
+ 
+   /* This is the observed pattern for the __libthread_segvhdlr.  */
+   unsigned int segvhdlr_pattern []
+     = {0x94102000, 0xe007bfe4, 0x9010001c, 0x92100019,
+        0x9fc40000, 0x9410001a, 0x81c7e008, 0x81e80000,
+        0x80a26000};
+ 
+   /* This is the observed pattern for the __sighndlr.  */
+   unsigned int sighndlr_pattern []
+     = {0x9de3bfa0, 0x90100018, 0x92100019, 0x9fc6c000,
+        0x9410001a, 0x81c7e008, 0x81e80000};
+ 
+   /* Deal with frame-less function from which a signal was raised.  */
+   if (_Unwind_IsSignalFrame (context))
+     {
+       /* The CFA is by definition unmodified in this case.  */
+       fs->regs.cfa_how = CFA_REG_OFFSET;
+       fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+       fs->regs.cfa_offset = 0;
+ 
+       /* This is the canonical RA column.  */
+       fs->retaddr_column = 15;
+ 
+       return _URC_NO_REASON;
+     }
+ 
+   /* Look for the sigacthandler pattern.  The pattern changes slightly
+      in different versions of the operating system, so we skip the
+      comparison against pc-(4*6).  */
+   if (    *(unsigned int *)(pc-(4*8)) == sigacthandler_pattern[0]
+        && *(unsigned int *)(pc-(4*7)) == sigacthandler_pattern[1]
+        /* skip pc-(4*6) */
+        && *(unsigned int *)(pc-(4*5)) == sigacthandler_pattern[3]
+        && *(unsigned int *)(pc-(4*4)) == sigacthandler_pattern[4]
+        && *(unsigned int *)(pc-(4*3)) == sigacthandler_pattern[5]
+        && *(unsigned int *)(pc-(4*2)) == sigacthandler_pattern[6]
+        && *(unsigned int *)(pc-(4*1)) == sigacthandler_pattern[7]
+        && *(unsigned int *)(pc-(4*0)) == sigacthandler_pattern[8] )
+     /* We need to move up two frames (the kernel frame and the handler
+        frame).  Minimum stack frame size is 96 bytes (64 + 4 + 24): 64
+        bytes for spilling register window (16 words for in and local
+        registers), 4 bytes for a pointer to space for callees
+        returning structs, and 24 bytes to store at least six argument
+        to callees.  The ucontext_t structure is after this offset.  */
+     regs_off = 96 + 96;
+ 
+   /* Look for the __libthread_segvhdlr pattern.  */
+   else if (    *(unsigned int *)(pc-(4*6)) == segvhdlr_pattern[0]
+ 	    && *(unsigned int *)(pc-(4*5)) == segvhdlr_pattern[1]
+ 	    && *(unsigned int *)(pc-(4*4)) == segvhdlr_pattern[2]
+ 	    && *(unsigned int *)(pc-(4*3)) == segvhdlr_pattern[3]
+ 	    && *(unsigned int *)(pc-(4*2)) == segvhdlr_pattern[4]
+ 	    && *(unsigned int *)(pc-(4*1)) == segvhdlr_pattern[5]
+ 	    && *(unsigned int *)(pc-(4*0)) == segvhdlr_pattern[6]
+ 	    && *(unsigned int *)(pc+(4*1)) == segvhdlr_pattern[7]
+ 	    && *(unsigned int *)(pc+(4*2)) == segvhdlr_pattern[8] )
+     /* We need to move up four frames (the kernel frame, the
+        sigacthandler frame, the __sighndlr frame, and the
+        __libthread_segvhdlr).  Two of them have the minimum
+        stack frame size (kernel and __sighndlr frames) of 96 bytes,
+        other has a stack frame of 216 bytes (the sigacthandler frame),
+        and there is another with a stack frame of 128 bytes (the
+        __libthread_segvhdlr).  The ucontext_t structure is after this
+        offset.  */
+     regs_off = 96 + 96 + 128 + 216;
+ 
+   /* Look for the __sighndlr pattern.  */
+   else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
+ 	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
+ 	    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]
+ 	    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]
+ 	    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]
+ 	    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]
+ 	    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )
+     {
+       /* We have observed different calling frames among different
+ 	 versions of the operating system, so that we need to
+ 	 discriminate using the upper frame.  We look for the return
+ 	 address of the caller frame (there is an offset of 15 words
+ 	 between the frame address and the place where this return
+ 	 address is stored) in order to do some more pattern matching.  */
+       if (*(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4)
+ 	    == 0xd407a04c)
+ 	/* This matches the call_user_handler pattern for Solaris 10.
+ 	   We need to move up three frames (the kernel frame, the
+ 	   call_user_handler frame, the __sighndlr frame).  Two of them
+ 	   have the minimum stack frame size (kernel and __sighndlr
+ 	   frames) of 96 bytes, and there is another with a stack frame
+ 	   of 160 bytes (the call_user_handler frame).  The ucontext_t
+ 	  structure is after this offset.  */
+ 	regs_off = 96 + 96 + 160;
+       else if (*(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4)
+ 		==  0x9410001a)
+ 	/* This matches the call_user_handler pattern for Solaris 9.
+ 	   We need to move up four frames (the kernel frame, the signal
+ 	   frame, the call_user_handler frame, the __sighndlr frame).
+ 	   Three of them have the minimum stack frame size (kernel,
+ 	   signal, and __sighndlr frames) of 96 bytes, and there is
+ 	   another with a stack frame of 160 bytes (the call_user_handler
+ 	   frame).  The ucontext_t structure is after this offset.  */
+ 	regs_off = 96 + 96 + 96 + 160;
+       else
+ 	/* We need to move up three frames (the kernel frame, the
+ 	   sigacthandler frame, and the __sighndlr frame).  Two of them
+ 	   have the minimum stack frame size (kernel and __sighndlr
+ 	   frames) of 96 bytes, and there is another with a stack frame
+ 	   of 216 bytes (the sigacthandler frame).  The ucontext_t 
+ 	   structure is after this offset.  */
+ 	regs_off = 96 + 96 + 216;
+     }
+ 
+   /* Exit if the pattern at the return address does not match the
+      previous three patterns.  */
+   else
+     return _URC_END_OF_STACK;
+ 
+   /* FPU information can be extracted from the ucontext_t structure
+      that is the third argument for the signal handler, that is saved
+      in the stack.  There are 10 words between the beginning of the
+      ucontext_t argument of the signal handler and the uc_mcontext
+      field.  There are 80 bytes between the beginning of uc_mcontext
+      and the beginning of the fpregs field.  */
+   fpu_save_off = regs_off + (4*10) + (4*20);
+ 
+   /* The fpregs field contains 32 words at the beginning that contain
+      the fpu state.  Then there are 2 words and two bytes.  */
+   fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (4*32) + (2*4) + 2);
+ 
+   /* We need to get the frame pointer for the kernel frame that
+      executes when the signal is raised.  This frame is just the
+      following to the application code that generated the signal, so
+      that the later's stack pointer is the former's frame pointer.
+      The stack pointer for the interrupted application code can be
+      calculated from the ucontext_t structure (third argument for the
+      signal handler) that is saved in the stack.  There are 10 words
+      between the beginning of the  ucontext_t argument  of the signal
+      handler and the uc_mcontext.gregs field that contains the
+      registers saved by the signal handler.  */
+   new_cfa = *(void **)(this_cfa + regs_off + (4*10) + (REG_SP*4));
+   fs->regs.cfa_how = CFA_REG_OFFSET;
+   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+   fs->regs.cfa_offset = new_cfa - this_cfa;
+ 
+   /* Restore global and out registers (in this order) from the
+      ucontext_t structure, uc_mcontext.gregs field.  */
+   for (i = 1; i < 16; i++)
+     {
+       /* We never restore %sp as everything is purely CFA-based.  */
+       if ((unsigned int) i == __builtin_dwarf_sp_column ())
+ 	continue;
+ 
+       /* First the global registers and then the out registers */
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset
+ 	= this_cfa + regs_off + (4*10) + ((REG_Y+i)*4) - new_cfa;
+     }
+ 
+   /* Just above the stack pointer there are 16 words in which the
+      register window (in and local registers) was saved.  */
+   for (i = 0; i < 16; i++)
+     {
+       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i + 16].loc.offset = i*4;
+     }
+ 
+   /* Check whether we need to restore fpu registers.  */
+   if (fpu_save)
+     {
+       for (i = 0; i < 32; i++)
+ 	{
+ 	  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;
+ 	  fs->regs.reg[i + 32].loc.offset
+ 	    = this_cfa + fpu_save_off + (i*4) - new_cfa;
+ 	}
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which is
+      the address of the active instruction when the signal was caught.
+      On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we
+      need to preventively subtract it from the purported return address.  */
+   ra_location = this_cfa + regs_off + (4*10) + (REG_PC*4);
+   shifted_ra_location = this_cfa + regs_off + (4*10) + (REG_Y*4);
+   *(void **)shifted_ra_location = *(void **)ra_location - 8;
+   fs->retaddr_column = 0;
+   fs->regs.reg[0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;
+   fs->signal_frame = 1;
+ 
+   return _URC_NO_REASON;
+ };
+ 
+ #endif
*** gcc/unwind-dw2.c.0	2008-07-09 17:52:13.414311200 +0200
--- gcc/unwind-dw2.c	2008-07-09 18:05:31.368003800 +0200
*************** uw_install_context_1 (struct _Unwind_Con
*** 1534,1540 ****
  static inline _Unwind_Ptr
  uw_identify_context (struct _Unwind_Context *context)
  {
!   return _Unwind_GetCFA (context);
  }
  
  
--- 1534,1546 ----
  static inline _Unwind_Ptr
  uw_identify_context (struct _Unwind_Context *context)
  {
!   /* The CFA is not sufficient to disambiguate the context of a function
!      interrupted by a signal before establishing its frame and the context
!      of the signal itself.  */
!   if (STACK_GROWS_DOWNWARD)
!     return _Unwind_GetCFA (context) - _Unwind_IsSignalFrame (context);
!   else
!     return _Unwind_GetCFA (context) + _Unwind_IsSignalFrame (context);
  }
  
  
*** gcc/config/ia64/unwind-ia64.c.0	2008-06-15 13:53:07.665043680 +0200
--- gcc/config/ia64/unwind-ia64.c	2008-06-15 13:53:15.272887112 +0200
*************** struct _Unwind_Context
*** 208,213 ****
--- 208,216 ----
    unsigned long *pfs_loc;	/* Save location for pfs in current
    				   (corr. to sp) frame.  Target
    				   contains cfm for caller.	*/
+   unsigned long *signal_pfs_loc;/* Save location for pfs in current
+ 				   signal frame.  Target contains
+ 				   pfs for caller.  */
    unsigned long *pri_unat_loc;
    unsigned long *unat_loc;
    unsigned long *lc_loc;
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1790,1795 ****
--- 1793,1799 ----
  #ifdef MD_FALLBACK_FRAME_STATE_FOR
        if (MD_FALLBACK_FRAME_STATE_FOR (context, fs) == _URC_NO_REASON)
  	return _URC_NO_REASON;
+ #endif
  
        /* [SCRA 11.4.1] A leaf function with no memory stack, no exception
  	 handlers, and which keeps the return value in B0 does not need
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1798,1812 ****
  	 This can only happen in the frame after unwinding through a signal
  	 handler.  Avoid infinite looping by requiring that B0 != RP.
  	 RP == 0 terminates the chain.  */
!       if (context->br_loc[0] && *context->br_loc[0] != context->rp
  	  && context->rp != 0)
! 	{
! 	  fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
! 	  fs->curr.reg[UNW_REG_RP].when = -1;
! 	  fs->curr.reg[UNW_REG_RP].val = 0;
! 	  return _URC_NO_REASON;
! 	}
! #endif
        return _URC_END_OF_STACK;
      }
  
--- 1802,1812 ----
  	 This can only happen in the frame after unwinding through a signal
  	 handler.  Avoid infinite looping by requiring that B0 != RP.
  	 RP == 0 terminates the chain.  */
!       if (context->br_loc[0]
! 	  && *context->br_loc[0] != context->rp
  	  && context->rp != 0)
! 	goto skip_unwind_info;
! 
        return _URC_END_OF_STACK;
      }
  
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1854,1860 ****
  	  r->where = UNW_WHERE_NONE;
      }
  
!   /* If RP did't get saved, generate entry for the return link register.  */
    if (fs->curr.reg[UNW_REG_RP].when >= fs->when_target)
      {
        fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
--- 1854,1861 ----
  	  r->where = UNW_WHERE_NONE;
      }
  
! skip_unwind_info:
!   /* If RP didn't get saved, generate entry for the return link register.  */
    if (fs->curr.reg[UNW_REG_RP].when >= fs->when_target)
      {
        fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1862,1867 ****
--- 1863,1889 ----
        fs->curr.reg[UNW_REG_RP].val = fs->return_link_reg;
      }
  
+   /* There is a subtlety for the frame after unwinding through a signal
+      handler: should we restore the cfm as usual or the pfs?  We can't
+      restore both because we use br.ret to resume execution of user code.
+      For other frames the procedure is by definition non-leaf so the pfs
+      is saved and restored and thus effectively dead in the body; only
+      the cfm need therefore be restored.
+      
+      Here we have 2 cases:
+        - either the pfs is saved and restored and thus effectively dead
+ 	 like in regular frames; then we do nothing special and restore
+ 	 the cfm.
+        - or the pfs is not saved and thus live; but in that case the
+ 	 procedure is necessarily leaf so the cfm is effectively dead
+ 	 and we restore the pfs.  */
+   if (context->signal_pfs_loc)
+     {
+       if (fs->curr.reg[UNW_REG_PFS].when >= fs->when_target)
+ 	context->pfs_loc = context->signal_pfs_loc;
+       context->signal_pfs_loc = NULL;
+     }
+ 
    return _URC_NO_REASON;
  }
  
*** gcc/config/ia64/linux-unwind.h.0	2008-06-15 13:53:07.667043376 +0200
--- gcc/config/ia64/linux-unwind.h	2008-06-15 13:53:15.274886808 +0200
***************
*** 1,4 ****
! /* DWARF2 EH unwinding support for IA64 Linux.
     Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
     This file is part of GCC.
--- 1,4 ----
! /* EH unwinding support for IA-64/Linux.
     Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
     This file is part of GCC.
***************
*** 27,33 ****
     MA 02110-1301, USA.  */
  
  /* Do code reading to identify a signal frame, and set the frame
!    state data appropriately.  See unwind-dw2.c for the structs.  */
  
  /* This works only for glibc-2.3 and later, because sigcontext is different
     in glibc-2.2.4.  */
--- 27,33 ----
     MA 02110-1301, USA.  */
  
  /* Do code reading to identify a signal frame, and set the frame
!    state data appropriately.  See unwind-ia64.c for the structs.  */
  
  /* This works only for glibc-2.3 and later, because sigcontext is different
     in glibc-2.2.4.  */
*************** ia64_fallback_frame_state (struct _Unwin
*** 70,76 ****
        }
  
        context->fpsr_loc = &(sc->sc_ar_fpsr);
!       context->pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
--- 70,76 ----
        }
  
        context->fpsr_loc = &(sc->sc_ar_fpsr);
!       context->signal_pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
*************** ia64_fallback_frame_state (struct _Unwin
*** 109,119 ****
--- 109,125 ----
  	  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);
        }
  
+       /* Account for use of br.ret to resume execution of user code. */
        fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_SPREL;
        fs->curr.reg[UNW_REG_RP].val
  	= (unsigned long)&(sc->sc_ip) - context->psp;
        fs->curr.reg[UNW_REG_RP].when = -1;
  
+       fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_SPREL;
+       fs->curr.reg[UNW_REG_PFS].val
+ 	= (unsigned long)&(sc->sc_cfm) - context->psp;
+       fs ->curr.reg[UNW_REG_PFS].when = -1;
+ 
        return _URC_NO_REASON;
      }
    return _URC_END_OF_STACK;
*************** ia64_fallback_frame_state (struct _Unwin
*** 121,131 ****
  
  #define MD_HANDLE_UNWABI ia64_handle_unwabi
  
  static void
  ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)
  {
!   if (fs->unwabi == ((3 << 8) | 's')
!       || fs->unwabi == ((0 << 8) | 's'))
      {
        struct sigframe {
  	char scratch[16];
--- 127,142 ----
  
  #define MD_HANDLE_UNWABI ia64_handle_unwabi
  
+ #define ABI_MARKER_OLD_LINUX_SIGTRAMP	((0 << 8) | 's')
+ #define ABI_MARKER_OLD_LINUX_INTERRUPT	((0 << 8) | 'i')
+ #define ABI_MARKER_LINUX_SIGTRAMP	((3 << 8) | 's')
+ #define ABI_MARKER_LINUX_INTERRUPT	((3 << 8) | 'i')
+ 
  static void
  ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)
  {
!   if (fs->unwabi == ABI_MARKER_LINUX_SIGTRAMP
!       || fs->unwabi == ABI_MARKER_OLD_LINUX_SIGTRAMP)
      {
        struct sigframe {
  	char scratch[16];
*************** ia64_handle_unwabi (struct _Unwind_Conte
*** 148,154 ****
  	  context->ireg[i - 2].loc = &sc->sc_gr[i];
        }
  
!       context->pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
--- 159,165 ----
  	  context->ireg[i - 2].loc = &sc->sc_gr[i];
        }
  
!       context->signal_pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
*************** ia64_handle_unwabi (struct _Unwind_Conte
*** 185,193 ****
  	  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);
        }
  
!       /* pfs_loc already set above.  Without this pfs_loc would point
! 	 incorrectly to sc_cfm instead of sc_ar_pfs.  */
!       fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_NONE;
      }
  }
  #endif /* glibc-2.3 or better */
--- 196,203 ----
  	  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);
        }
  
!       /* The use of br.ret to resume execution of user code is already
! 	 accounted for in the unwind ABI.  */
      }
  }
  #endif /* glibc-2.3 or better */
*** gcc/config/i386/t-mingw32.orig	2006-08-15 19:06:18.000000000 +0200
--- gcc/config/i386/t-mingw32	2008-07-10 17:52:48.000000000 +0200
***************
*** 1,2 ****
--- 1,20 ----
  # Match SYSTEM_INCLUDE_DIR
  NATIVE_SYSTEM_HEADER_DIR = /mingw/include
+ 
+ # Build a shared libgcc library with the GNU linker.
+ 
+ SHLIB_EXT = .dll
+ SHLIB_SONAME = @shlib_base_name@.dll
+ SHLIB_OBJS = @shlib_objs@
+ SHLIB_DIR = @multilib_dir@
+ SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
+ 
+ SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+         -o $(SHLIB_DIR)/$(SHLIB_SONAME) \
+         @multilib_flags@ $(SHLIB_OBJS) -lmingwthrd -lmingw32 -lshell32 -lmoldname -lmingwex -lmsvcrt -lkernel32 -luser32 -ladvapi32
+ # $(slibdir) double quoted to protect it from expansion while building
+ # libgcc.mk.  We want this delayed until actual install time.
+ SHLIB_INSTALL = \
+         $$(mkinstalldirs) $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL); \
+         $(INSTALL_PROGRAM) $(SHLIB_DIR)/$(SHLIB_SONAME) \
+          $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SONAME);
*** gcc/common.opt.0	2008-07-13 14:18:54.782013336 +0200
--- gcc/common.opt	2008-07-13 14:19:43.204651976 +0200
*************** fstack-protector-all
*** 999,1004 ****
--- 999,1008 ----
  Common Report RejectNegative Var(flag_stack_protect, 2) VarExists
  Use a stack protection method for every function
  
+ fstack-usage
+ Common RejectNegative Var(flag_stack_usage)
+ Output stack usage information on a per-function basis
+ 
  fstrength-reduce
  Common
  Does nothing.  Preserved for backward compatibility.
*** gcc/doc/invoke.texi.0	2008-07-13 14:18:54.798010904 +0200
--- gcc/doc/invoke.texi	2008-07-13 14:19:43.255644224 +0200
*************** Objective-C and Objective-C++ Dialects}.
*** 301,307 ****
  -feliminate-unused-debug-symbols -femit-class-debug-always @gol
  -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
! -ftest-coverage  -ftime-report -fvar-tracking @gol
  -g  -g@var{level}  -gcoff -gdwarf-2 @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
  -fno-merge-debug-strings -fdebug-prefix-map=@var{old}=@var{new} @gol
--- 301,307 ----
  -feliminate-unused-debug-symbols -femit-class-debug-always @gol
  -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
! -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
  -g  -g@var{level}  -gcoff -gdwarf-2 @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
  -fno-merge-debug-strings -fdebug-prefix-map=@var{old}=@var{new} @gol
*************** allocation when it finishes.
*** 4336,4341 ****
--- 4336,4374 ----
  Makes the compiler print some statistics about permanent memory
  allocation before or after interprocedural optimization.
  
+ @item -fstack-usage
+ @opindex fstack-usage
+ Makes the compiler output stack usage information for the program, on a
+ per-function basis.  The filename for the dump is made by appending
+ @file{.su} to the AUXNAME.  AUXNAME is generated from the name of
+ the output file, if explicitly specified and it is not an executable,
+ otherwise it is the basename of the source file.  An entry is made up
+ of three fields:
+ 
+ @itemize
+ @item
+ The name of the function.
+ @item
+ A number of bytes.
+ @item
+ One or more qualifiers: @code{static}, @code{dynamic}, @code{bounded}.
+ @end itemize
+ 
+ The qualifier @code{static} means that the function manipulates the stack
+ statically: a fixed number of bytes are allocated for the frame on function
+ entry and released on function exit; no stack adjustments are otherwise made
+ in the function.  The second field is this fixed number of bytes.
+ 
+ The qualifier @code{dynamic} means that the function manipulates the stack
+ dynamically: in addition to the static allocation described above, stack
+ adjustments are made in the body of the function, for example to push/pop
+ arguments around function calls.  If the qualifier @code{bounded} is also
+ present, the amount of these adjustments is bounded at compile-time and
+ the second field is an upper bound of the total amount of stack used by
+ the function.  If it is not present, the amount of these adjustments is
+ not bounded at compile-time and the second field only represents the
+ bounded part.
+ 
  @item -fprofile-arcs
  @opindex fprofile-arcs
  Add code so that program flow @dfn{arcs} are instrumented.  During
*** gcc/builtins.c.0	2008-07-13 14:18:54.868000264 +0200
--- gcc/builtins.c	2008-07-13 14:29:19.631021848 +0200
*************** static rtx expand_builtin_strstr (tree, 
*** 134,140 ****
  static rtx expand_builtin_strpbrk (tree, rtx, enum machine_mode);
  static rtx expand_builtin_strchr (tree, rtx, enum machine_mode);
  static rtx expand_builtin_strrchr (tree, rtx, enum machine_mode);
! static rtx expand_builtin_alloca (tree, rtx);
  static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);
  static rtx expand_builtin_frame_address (tree, tree);
  static rtx expand_builtin_fputs (tree, rtx, bool);
--- 134,140 ----
  static rtx expand_builtin_strpbrk (tree, rtx, enum machine_mode);
  static rtx expand_builtin_strchr (tree, rtx, enum machine_mode);
  static rtx expand_builtin_strrchr (tree, rtx, enum machine_mode);
! static rtx expand_builtin_alloca (tree, rtx, bool);
  static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);
  static rtx expand_builtin_frame_address (tree, tree);
  static rtx expand_builtin_fputs (tree, rtx, bool);
*************** expand_builtin_apply (rtx function, rtx 
*** 1457,1464 ****
      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);
  
    /* Allocate a block of memory onto the stack and copy the memory
!      arguments to the outgoing arguments address.  */
!   allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT);
    dest = virtual_outgoing_args_rtx;
  #ifndef STACK_GROWS_DOWNWARD
    if (GET_CODE (argsize) == CONST_INT)
--- 1457,1466 ----
      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);
  
    /* Allocate a block of memory onto the stack and copy the memory
!      arguments to the outgoing arguments address.  We can pass TRUE
!      as the 4th argument because we just saved the stack pointer
!      and will restore it right after the call.  */
!   allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT, TRUE);
    dest = virtual_outgoing_args_rtx;
  #ifndef STACK_GROWS_DOWNWARD
    if (GET_CODE (argsize) == CONST_INT)
*************** expand_builtin_frame_address (tree fndec
*** 5053,5064 ****
      }
  }
  
! /* Expand EXP, a call to the alloca builtin.  Return NULL_RTX if
!    we failed and the caller should emit a normal call, otherwise try to get
!    the result in TARGET, if convenient.  */
  
  static rtx
! expand_builtin_alloca (tree exp, rtx target)
  {
    rtx op0;
    rtx result;
--- 5055,5067 ----
      }
  }
  
! /* Expand EXP, a call to the alloca builtin.  Return NULL_RTX if we
!    failed and the caller should emit a normal call, otherwise try to
!    get the result in TARGET, if convenient.  CANNOT_ACCUMULATE is the
!    same as for allocate_dynamic_stack_space. */
  
  static rtx
! expand_builtin_alloca (tree exp, rtx target, bool cannot_accumulate)
  {
    rtx op0;
    rtx result;
*************** expand_builtin_alloca (tree exp, rtx tar
*** 5076,5082 ****
    op0 = expand_normal (CALL_EXPR_ARG (exp, 0));
  
    /* Allocate the desired space.  */
!   result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);
    result = convert_memory_address (ptr_mode, result);
  
    return result;
--- 5079,5086 ----
    op0 = expand_normal (CALL_EXPR_ARG (exp, 0));
  
    /* Allocate the desired space.  */
!   result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT,
! 					 cannot_accumulate);
    result = convert_memory_address (ptr_mode, result);
  
    return result;
*************** expand_builtin (tree exp, rtx target, rt
*** 6388,6394 ****
  	return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);
  
      case BUILT_IN_ALLOCA:
!       target = expand_builtin_alloca (exp, target);
        if (target)
  	return target;
        break;
--- 6392,6400 ----
  	return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);
  
      case BUILT_IN_ALLOCA:
!       /* If the allocation stems from the declaration of a variable-sized
! 	 object, it cannot accumulate.  */
!       target = expand_builtin_alloca (exp, target, ALLOCA_FOR_VAR_P (exp));
        if (target)
  	return target;
        break;
*** gcc/calls.c.0	2008-07-13 14:18:54.878998592 +0200
--- gcc/calls.c	2008-07-13 14:19:43.323633888 +0200
*************** initialize_argument_information (int num
*** 1119,1127 ****
  		      pending_stack_adjust = 0;
  		    }
  
  		  copy = gen_rtx_MEM (BLKmode,
  				      allocate_dynamic_stack_space
! 				      (size_rtx, NULL_RTX, TYPE_ALIGN (type)));
  		  set_mem_attributes (copy, type, 1);
  		}
  	      else
--- 1119,1131 ----
  		      pending_stack_adjust = 0;
  		    }
  
+ 		  /* We can pass TRUE as the 4th argument because we just
+ 		     saved the stack pointer and will restore it right after
+ 		     the call.  */
  		  copy = gen_rtx_MEM (BLKmode,
  				      allocate_dynamic_stack_space
! 				      (size_rtx, NULL_RTX,
! 				       TYPE_ALIGN (type), TRUE));
  		  set_mem_attributes (copy, type, 1);
  		}
  	      else
*************** expand_call (tree exp, rtx target, int i
*** 2476,2481 ****
--- 2480,2487 ----
  	      stack_arg_under_construction = 0;
  	    }
  	  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);
+ 	  if (flag_stack_usage)
+ 	    current_function_has_unbounded_dynamic_stack_size = 1;
  	}
        else
  	{
*************** expand_call (tree exp, rtx target, int i
*** 2636,2643 ****
  		  stack_usage_map = stack_usage_map_buf;
  		  highest_outgoing_arg_in_use = 0;
  		}
  	      allocate_dynamic_stack_space (push_size, NULL_RTX,
! 					    BITS_PER_UNIT);
  	    }
  
  	  /* If argument evaluation might modify the stack pointer,
--- 2642,2652 ----
  		  stack_usage_map = stack_usage_map_buf;
  		  highest_outgoing_arg_in_use = 0;
  		}
+ 	      /* We can pass TRUE as the 4th argument because we just
+ 		 saved the stack pointer and will restore it right after
+ 		 the call.  */
  	      allocate_dynamic_stack_space (push_size, NULL_RTX,
! 					    BITS_PER_UNIT, TRUE);
  	    }
  
  	  /* If argument evaluation might modify the stack pointer,
*************** expand_call (tree exp, rtx target, int i
*** 2678,2683 ****
--- 2687,2705 ----
  	 be deferred during the evaluation of the arguments.  */
        NO_DEFER_POP;
  
+       if (flag_stack_usage
+ 	  && !ACCUMULATE_OUTGOING_ARGS && pass && adjusted_args_size.var == 0)
+ 	{
+ 	  int pushed = adjusted_args_size.constant + pending_stack_adjust;
+ 
+ 	  /* Record the maximum pushed stack space size.  We need to
+ 	     delay it this far to take into account the optimization
+ 	     done by combine_pending_stack_adjustment_and_call.  */
+ 
+ 	  if (pushed > current_function_pushed_stack_size)
+ 	    current_function_pushed_stack_size = pushed;
+ 	}
+ 
        funexp = rtx_for_function_call (fndecl, addr);
  
        /* Figure out the register where the value, if any, will come back.  */
*************** emit_library_call_value_1 (int retval, r
*** 3628,3633 ****
--- 3650,3662 ----
    if (args_size.constant > current_function_outgoing_args_size)
      current_function_outgoing_args_size = args_size.constant;
  
+   if (flag_stack_usage && !ACCUMULATE_OUTGOING_ARGS)
+     {
+       int pushed = args_size.constant + pending_stack_adjust;
+       if (pushed > current_function_pushed_stack_size)
+ 	current_function_pushed_stack_size = pushed;
+     }
+ 
    if (ACCUMULATE_OUTGOING_ARGS)
      {
        /* Since the stack pointer will never be pushed, it is possible for
*** gcc/explow.c.0	2008-07-13 14:18:54.891996616 +0200
--- gcc/explow.c	2008-07-13 14:19:43.327633280 +0200
*************** update_nonlocal_goto_save_area (void)
*** 1068,1078 ****
     SIZE is an rtx representing the size of the area.
     TARGET is a place in which the address can be placed.
  
!    KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.  */
  
  rtx
! allocate_dynamic_stack_space (rtx size, rtx target, int known_align)
  {
    /* If we're asking for zero bytes, it doesn't matter what we point
       to since we can't dereference it.  But return a reasonable
       address anyway.  */
--- 1068,1090 ----
     SIZE is an rtx representing the size of the area.
     TARGET is a place in which the address can be placed.
  
!    KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.
! 
!    If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the
!    stack space allocated by the generated code cannot be added with itself
!    in the course of the execution of the function.  It is always safe to
!    pass FALSE here and the following criterion is sufficient in order to
!    pass TRUE: every path in the CFG that starts at the allocation point and
!    loops to it executes the associated deallocation code (that always exists
!    if the function does not use the depressed stack pointer mechanism).  */
  
  rtx
! allocate_dynamic_stack_space (rtx size, rtx target, int known_align,
! 			      bool cannot_accumulate)
  {
+   HOST_WIDE_INT stack_usage_size = -1;
+   bool known_align_valid = true;
+ 
    /* If we're asking for zero bytes, it doesn't matter what we point
       to since we can't dereference it.  But return a reasonable
       address anyway.  */
*************** allocate_dynamic_stack_space (rtx size, 
*** 1082,1087 ****
--- 1094,1131 ----
    /* Otherwise, show we're calling alloca or equivalent.  */
    current_function_calls_alloca = 1;
  
+   /* If stack usage info is requested, look into the size we are passed.
+      We need to do so this early to avoid the obfuscation that may be
+      introduced later by the various alignment operations.  */
+   if (flag_stack_usage)
+     {
+       if (GET_CODE (size) == CONST_INT)
+ 	stack_usage_size = INTVAL (size);
+       else if (GET_CODE (size) == REG)
+         {
+ 	  /* Look into the last emitted insn and see if we can deduce
+ 	     something for the register.  */
+ 	  rtx insn, set, note;
+ 	  insn = get_last_insn ();
+ 	  if ((set = single_set (insn))
+ 	      && rtx_equal_p (SET_DEST (set), size))
+ 	    {
+ 	      if (GET_CODE (SET_SRC (set)) == CONST_INT)
+ 		stack_usage_size = INTVAL (SET_SRC (set));
+ 	      else if ((note = find_reg_equal_equiv_note (insn))
+ 		       && GET_CODE (XEXP (note, 0)) == CONST_INT)
+ 		stack_usage_size = INTVAL (XEXP (note, 0));
+ 	    }
+ 	}
+ 
+       /* If the size is not constant, we can't say anything.  */
+       if (stack_usage_size == -1)
+ 	{
+ 	  current_function_has_unbounded_dynamic_stack_size = 1;
+ 	  stack_usage_size = 0;
+ 	}
+     }
+ 
    /* Ensure the size is in the proper mode.  */
    if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
      size = convert_to_mode (Pmode, size, 1);
*************** allocate_dynamic_stack_space (rtx size, 
*** 1111,1120 ****
  #endif
  
    if (MUST_ALIGN)
!     size
!       = force_operand (plus_constant (size,
! 				      BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
! 		       NULL_RTX);
  
  #ifdef SETJMP_VIA_SAVE_AREA
    /* If setjmp restores regs from a save area in the stack frame,
--- 1155,1171 ----
  #endif
  
    if (MUST_ALIGN)
!     {
!       size
!         = force_operand (plus_constant (size,
! 					BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
! 			 NULL_RTX);
! 
!       if (flag_stack_usage)
! 	stack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;
! 
!       known_align_valid = false;
!     }
  
  #ifdef SETJMP_VIA_SAVE_AREA
    /* If setjmp restores regs from a save area in the stack frame,
*************** allocate_dynamic_stack_space (rtx size, 
*** 1128,1159 ****
       would use reg notes to store the "optimized" size and fix things
       up later.  These days we know this information before we ever
       start building RTL so the reg notes are unnecessary.  */
!   if (!current_function_calls_setjmp)
!     {
!       int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
! 
!       /* ??? Code below assumes that the save area needs maximal
! 	 alignment.  This constraint may be too strong.  */
!       gcc_assert (PREFERRED_STACK_BOUNDARY == BIGGEST_ALIGNMENT);
! 
!       if (GET_CODE (size) == CONST_INT)
! 	{
! 	  HOST_WIDE_INT new = INTVAL (size) / align * align;
! 
! 	  if (INTVAL (size) != new)
! 	    size = GEN_INT (new);
! 	}
!       else
! 	{
! 	  /* Since we know overflow is not possible, we avoid using
! 	     CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */
! 	  size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size,
! 				GEN_INT (align), NULL_RTX, 1);
! 	  size = expand_mult (Pmode, size,
! 			      GEN_INT (align), NULL_RTX, 1);
! 	}
!     }
!   else
      {
        rtx dynamic_offset
  	= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,
--- 1179,1185 ----
       would use reg notes to store the "optimized" size and fix things
       up later.  These days we know this information before we ever
       start building RTL so the reg notes are unnecessary.  */
!   if (current_function_calls_setjmp)
      {
        rtx dynamic_offset
  	= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,
*************** allocate_dynamic_stack_space (rtx size, 
*** 1161,1166 ****
--- 1187,1200 ----
  
        size = expand_binop (Pmode, add_optab, size, dynamic_offset,
  			   NULL_RTX, 1, OPTAB_LIB_WIDEN);
+ 
+       /* The above dynamic offset cannot be computed statically at this
+ 	 point, but it will be possible to do so after RTL expansion is
+ 	 done.  Record how many times we will need to add it.  */
+       if (flag_stack_usage)
+ 	current_function_dynamic_alloc_count++;
+ 
+       known_align_valid = false;
      }
  #endif /* SETJMP_VIA_SAVE_AREA */
  
*************** allocate_dynamic_stack_space (rtx size, 
*** 1177,1189 ****
       insns.  Since this is an extremely rare event, we have no reliable
       way of knowing which systems have this problem.  So we avoid even
       momentarily mis-aligning the stack.  */
  
!   /* If we added a variable amount to SIZE,
!      we can no longer assume it is aligned.  */
! #if !defined (SETJMP_VIA_SAVE_AREA)
!   if (MUST_ALIGN || known_align % PREFERRED_STACK_BOUNDARY != 0)
! #endif
!     size = round_push (size);
  
    do_pending_stack_adjust ();
  
--- 1211,1238 ----
       insns.  Since this is an extremely rare event, we have no reliable
       way of knowing which systems have this problem.  So we avoid even
       momentarily mis-aligning the stack.  */
+   if (!known_align_valid || known_align % PREFERRED_STACK_BOUNDARY != 0)
+     {
+       size = round_push (size);
  
!       if (flag_stack_usage)
! 	{
! 	  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
! 	  stack_usage_size = (stack_usage_size + align - 1) / align * align;
! 	}
!     }
! 
!   /* The size is supposed to be fully adjusted at this point so record it
!      if stack usage info is requested.  */
!   if (flag_stack_usage)
!     {
!       current_function_dynamic_stack_size += stack_usage_size;
! 
!       /* ??? This is gross but the only safe stance in the absence
! 	 of stack usage oriented flow analysis.  */
!       if (!cannot_accumulate)
! 	current_function_has_unbounded_dynamic_stack_size = 1;
!     }
  
    do_pending_stack_adjust ();
  
*** gcc/expr.h.0	2008-07-13 14:18:54.898995552 +0200
--- gcc/expr.h	2008-07-13 14:19:43.329632976 +0200
*************** extern void emit_stack_restore (enum sav
*** 748,756 ****
  /* Invoke emit_stack_save for the nonlocal_goto_save_area.  */
  extern void update_nonlocal_goto_save_area (void);
  
! /* Allocate some space on the stack dynamically and return its address.  An rtx
!    says how many bytes.  */
! extern rtx allocate_dynamic_stack_space (rtx, rtx, int);
  
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
     FIRST is a constant and size is a Pmode RTX.  These are offsets from the
--- 748,755 ----
  /* Invoke emit_stack_save for the nonlocal_goto_save_area.  */
  extern void update_nonlocal_goto_save_area (void);
  
! /* Allocate some space on the stack dynamically and return its address.  */
! extern rtx allocate_dynamic_stack_space (rtx, rtx, int, bool);
  
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
     FIRST is a constant and size is a Pmode RTX.  These are offsets from the
*** gcc/function.h.0	2008-07-13 14:18:54.930990688 +0200
--- gcc/function.h	2008-07-13 14:38:55.498476688 +0200
*************** enum function_frequency {
*** 159,164 ****
--- 159,195 ----
    FUNCTION_FREQUENCY_HOT
  };
  
+ struct stack_usage GTY(())
+ {
+   /* # of bytes of static stack space allocated by the function.  */
+   HOST_WIDE_INT static_stack_size;
+ 
+   /* # of bytes of dynamic stack space allocated by the function.  This is
+      meaningful only if has_unbounded_dynamic_stack_size is zero.  */
+   HOST_WIDE_INT dynamic_stack_size;
+ 
+   /* # of bytes of space pushed onto the stack after the prologue.  If
+      !ACCUMULATE_OUTGOING_ARGS, it contains the outgoing arguments.  */
+   int pushed_stack_size;
+ 
+   /* # of dynamic allocations in the function.  */
+   unsigned int dynamic_alloc_count : 31;
+ 
+   /* Nonzero if the amount of stack space allocated dynamically cannot
+      be bounded at compile-time.  */
+   unsigned int has_unbounded_dynamic_stack_size : 1;
+ };
+ 
+ #define current_function_static_stack_size (cfun->su->static_stack_size)
+ #define current_function_dynamic_stack_size (cfun->su->dynamic_stack_size)
+ #define current_function_pushed_stack_size (cfun->su->pushed_stack_size)
+ #define current_function_dynamic_alloc_count (cfun->su->dynamic_alloc_count)
+ #define current_function_has_unbounded_dynamic_stack_size \
+   (cfun->su->has_unbounded_dynamic_stack_size)
+ #define current_function_allocates_dynamic_stack_space    \
+   (current_function_dynamic_stack_size != 0               \
+    || current_function_has_unbounded_dynamic_stack_size)
+ 
  /* This structure can save all the important global and static variables
     describing the status of the current function.  */
  
*************** struct function GTY(())
*** 168,173 ****
--- 199,205 ----
    struct expr_status *expr;
    struct emit_status *emit;
    struct varasm_status *varasm;
+   struct stack_usage *su;
  
    /* The control flow graph for this function.  */
    struct control_flow_graph *cfg;
*** gcc/function.c.0	2008-07-13 14:18:54.944988560 +0200
--- gcc/function.c	2008-07-13 15:43:07.467888328 +0200
*************** instantiate_virtual_regs (void)
*** 1734,1739 ****
--- 1734,1751 ----
    /* Indicate that, from now on, assign_stack_local should use
       frame_pointer_rtx.  */
    virtuals_instantiated = 1;
+ 
+   /* See allocate_dynamic_stack_space for the rationale.  */
+ #ifdef SETJMP_VIA_SAVE_AREA
+   if (flag_stack_usage && current_function_calls_setjmp)
+     {
+       int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
+       dynamic_offset = (dynamic_offset + align - 1) / align * align;
+       current_function_dynamic_stack_size
+ 	+= current_function_dynamic_alloc_count * dynamic_offset;
+     }
+ #endif
+ 
    return 0;
  }
  
*************** prepare_function_start (void)
*** 3983,3988 ****
--- 3995,4005 ----
    init_emit ();
    init_varasm_status (cfun);
    init_expr ();
+   if (flag_stack_usage)
+     {
+       cfun->su = ggc_alloc_cleared (sizeof (struct stack_usage));
+       cfun->su->static_stack_size = -1;
+     }
  
    cse_not_expected = ! optimize;
  
*************** rest_of_handle_thread_prologue_and_epilo
*** 5625,5636 ****
  {
    if (optimize)
      cleanup_cfg (CLEANUP_EXPENSIVE);
    /* On some machines, the prologue and epilogue code, or parts thereof,
       can be represented as RTL.  Doing so lets us schedule insns between
       it and the rest of the code and also allows delayed branch
       scheduling to operate in the epilogue.  */
- 
    thread_prologue_and_epilogue_insns ();
    return 0;
  }
  
--- 5642,5658 ----
  {
    if (optimize)
      cleanup_cfg (CLEANUP_EXPENSIVE);
+ 
    /* On some machines, the prologue and epilogue code, or parts thereof,
       can be represented as RTL.  Doing so lets us schedule insns between
       it and the rest of the code and also allows delayed branch
       scheduling to operate in the epilogue.  */
    thread_prologue_and_epilogue_insns ();
+ 
+   /* The stack usage info is finalized during prologue expansion.  */
+   if (flag_stack_usage)
+     output_stack_usage ();
+ 
    return 0;
  }
  
*** gcc/gimplify.c.0	2008-07-13 14:18:54.979983240 +0200
--- gcc/gimplify.c	2008-07-13 14:30:49.860304912 +0200
*************** gimplify_vla_decl (tree decl, tree *stmt
*** 1287,1292 ****
--- 1287,1294 ----
  
    t = built_in_decls[BUILT_IN_ALLOCA];
    t = build_call_expr (t, 1, DECL_SIZE_UNIT (decl));
+   /* The call has been built for a variable-sized object.  */
+   ALLOCA_FOR_VAR_P (t) = 1;
    t = fold_convert (ptr_type, t);
    t = build_gimple_modify_stmt (addr, t);
  
*** gcc/toplev.h.0	2008-07-13 14:18:55.006979136 +0200
--- gcc/toplev.h	2008-07-13 14:19:48.614829504 +0200
*************** extern void dump_memory_report (bool);
*** 103,108 ****
--- 103,111 ----
  
  extern void target_reinit (void);
  
+ /* Output stack usage information.  */
+ extern void output_stack_usage (void);
+ 
  /* A unique local time stamp, might be zero if none is available.  */
  extern unsigned local_tick;
  
*** gcc/toplev.c.0	2008-07-13 14:18:55.017977464 +0200
--- gcc/toplev.c	2008-07-13 16:22:43.336701368 +0200
*************** static const param_info lang_independent
*** 377,382 ****
--- 377,383 ----
  
  FILE *asm_out_file;
  FILE *aux_info_file;
+ FILE *stack_usage_file = NULL;
  FILE *dump_file = NULL;
  const char *dump_file_name;
  
*************** realloc_for_line_map (void *ptr, size_t 
*** 1615,1620 ****
--- 1616,1709 ----
    return ggc_realloc (ptr, len);
  }
  
+ /* Output stack usage information.  */
+ void
+ output_stack_usage (void)
+ {
+   static bool warning_issued = false;
+   enum stack_usage_kind_type { STATIC = 0, DYNAMIC, DYNAMIC_BOUNDED };
+   const char *stack_usage_kind_str[] = {
+     "static",
+     "dynamic",
+     "dynamic,bounded"
+   };
+   HOST_WIDE_INT stack_usage = current_function_static_stack_size;
+   enum stack_usage_kind_type stack_usage_kind;
+   expanded_location loc;
+   const char *raw_id, *id;
+ 
+   if (stack_usage < 0)
+     {
+       if (!warning_issued)
+ 	{
+ 	  warning (0, "-fstack-usage not supported for this target");
+ 	  warning_issued = true;
+ 	}
+       return;
+     }
+ 
+   stack_usage_kind = STATIC;
+ 
+   /* Add the maximum amount of space pushed onto the stack.  */
+   if (current_function_pushed_stack_size > 0)
+     {
+       stack_usage += current_function_pushed_stack_size;
+       stack_usage_kind = DYNAMIC_BOUNDED;
+     }
+ 
+   /* Now on to the tricky part: dynamic stack allocation.  */
+   if (current_function_allocates_dynamic_stack_space)
+     {
+       if (current_function_has_unbounded_dynamic_stack_size)
+ 	stack_usage_kind = DYNAMIC;
+       else
+ 	stack_usage_kind = DYNAMIC_BOUNDED;
+ 
+       /* Add the size even in the unbounded case, this can't hurt.  */
+       stack_usage += current_function_dynamic_stack_size;
+     }
+ 
+   loc = expand_location (DECL_SOURCE_LOCATION (current_function_decl));
+ 
+   /* Strip the scope prefix if any.  */
+   raw_id = lang_hooks.decl_printable_name (current_function_decl, 2);
+   id = strrchr (raw_id, '.');
+   if (id)
+     id++;
+   else
+     id = raw_id;
+ 
+   fprintf (stack_usage_file,
+ #ifdef USE_MAPPED_LOCATION
+ 	   "%s:%d:%d:%s\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
+ #else
+ 	   "%s:%d:%s\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
+ #endif
+ 	   basename (loc.file),
+ 	   loc.line,
+ #ifdef USE_MAPPED_LOCATION
+ 	   loc.column,
+ #endif
+ 	   id,
+ 	   stack_usage,
+ 	   stack_usage_kind_str[stack_usage_kind]);
+ }
+ 
+ /* Open an auxiliary output file.  */
+ static FILE *
+ open_auxiliary_file (const char *ext)
+ {
+   char *filename;
+   FILE *file;
+ 
+   filename = concat (aux_base_name, ".", ext, NULL);
+   file = fopen (filename, "w");
+   if (!file)
+     fatal_error ("can't open %s for writing: %m", filename);
+   free (filename);
+   return file;
+ }
+ 
  /* Initialization of the front end environment, before command line
     options are parsed.  Signal handlers, internationalization etc.
     ARGV0 is main's argv[0].  */
*************** lang_dependent_init (const char *name)
*** 2133,2138 ****
--- 2223,2232 ----
  
    init_asm_output (name);
  
+   /* If stack usage information is desired, open the output file.  */
+   if (flag_stack_usage)
+     stack_usage_file = open_auxiliary_file ("su");
+ 
    /* This creates various _DECL nodes, so needs to be called after the
       front end is initialized.  */
    init_eh ();
*************** finalize (void)
*** 2209,2214 ****
--- 2303,2311 ----
  	fatal_error ("error closing %s: %m", asm_file_name);
      }
  
+   if (stack_usage_file)
+     fclose (stack_usage_file);
+ 
    finish_optimization_passes ();
  
    if (mem_report)
*** gcc/tree.h.0	2008-07-13 14:18:55.045973208 +0200
--- gcc/tree.h	2008-07-13 14:19:00.000000000 +0200
*************** struct gimple_stmt GTY(())
*** 500,506 ****
         TREE_PROTECTED in
             BLOCK
  	   ..._DECL
!        CALL_FROM_THUNK_P in
             CALL_EXPR
  
     side_effects_flag:
--- 500,507 ----
         TREE_PROTECTED in
             BLOCK
  	   ..._DECL
!        CALL_FROM_THUNK_P and
!        ALLOCA_FOR_VAR_P in
             CALL_EXPR
  
     side_effects_flag:
*************** extern void omp_clause_range_check_faile
*** 1351,1356 ****
--- 1352,1361 ----
  #define CALL_FROM_THUNK_P(NODE) \
    (CALL_EXPR_CHECK (NODE)->base.protected_flag)
  
+ /* In a CALL_EXPR, if the function being called is BUILT_IN_ALLOCA, means that
+    it has been built for the declaration of a variable-sized object.  */
+ #define ALLOCA_FOR_VAR_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)
+ 
  /* In a type, nonzero means that all objects of the type are guaranteed by the
     language or front-end to be properly aligned, so we can indicate that a MEM
     of this type is aligned at least to the alignment of the type, even if it
*** gcc/config/alpha/alpha.c.0	2008-07-13 14:18:55.086966976 +0200
--- gcc/config/alpha/alpha.c	2008-07-13 16:02:52.600720752 +0200
*************** emit_frame_store (unsigned int regno, rt
*** 7440,7445 ****
--- 7440,7469 ----
    emit_frame_store_1 (reg, base_reg, frame_bias, base_ofs, reg);
  }
  
+ /* Compute the frame size.  SIZE is the size of the "naked" frame
+    and SA_SIZE is the size of the register save area.  */
+ 
+ static HOST_WIDE_INT
+ compute_frame_size (HOST_WIDE_INT size, HOST_WIDE_INT sa_size)
+ {
+   if (TARGET_ABI_OPEN_VMS)
+     return ALPHA_ROUND (sa_size 
+ 			+ (alpha_procedure_type == PT_STACK ? 8 : 0)
+ 			+ size
+ 			+ current_function_pretend_args_size);
+   else if (TARGET_ABI_UNICOSMK)
+     /* We have to allocate space for the DSIB if we generate a frame.  */
+     return ALPHA_ROUND (sa_size
+ 			+ (alpha_procedure_type == PT_STACK ? 48 : 0))
+ 	   + ALPHA_ROUND (size
+ 			  + current_function_outgoing_args_size);
+   else
+     return ALPHA_ROUND (current_function_outgoing_args_size)
+ 	   + sa_size
+ 	   + ALPHA_ROUND (size
+ 			  + current_function_pretend_args_size);
+ }
+ 
  /* Write function prologue.  */
  
  /* On vms we have two kinds of functions:
*************** alpha_expand_prologue (void)
*** 7476,7499 ****
    int i;
  
    sa_size = alpha_sa_size ();
  
!   frame_size = get_frame_size ();
!   if (TARGET_ABI_OPEN_VMS)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 8 : 0)
! 			      + frame_size
! 			      + current_function_pretend_args_size);
!   else if (TARGET_ABI_UNICOSMK)
!     /* We have to allocate space for the DSIB if we generate a frame.  */
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 48 : 0))
! 		 + ALPHA_ROUND (frame_size
! 				+ current_function_outgoing_args_size);
!   else
!     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)
! 		  + sa_size
! 		  + ALPHA_ROUND (frame_size
! 				 + current_function_pretend_args_size));
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
--- 7500,7509 ----
    int i;
  
    sa_size = alpha_sa_size ();
+   frame_size = compute_frame_size (get_frame_size (), sa_size);
  
!   if (flag_stack_usage)
!     current_function_static_stack_size = frame_size;
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
*************** alpha_start_function (FILE *file, const 
*** 7811,7833 ****
  
    alpha_fnname = fnname;
    sa_size = alpha_sa_size ();
! 
!   frame_size = get_frame_size ();
!   if (TARGET_ABI_OPEN_VMS)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 8 : 0)
! 			      + frame_size
! 			      + current_function_pretend_args_size);
!   else if (TARGET_ABI_UNICOSMK)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 48 : 0))
! 		 + ALPHA_ROUND (frame_size
! 			      + current_function_outgoing_args_size);
!   else
!     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)
! 		  + sa_size
! 		  + ALPHA_ROUND (frame_size
! 				 + current_function_pretend_args_size));
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
--- 7821,7827 ----
  
    alpha_fnname = fnname;
    sa_size = alpha_sa_size ();
!   frame_size = compute_frame_size (get_frame_size (), sa_size);
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
*************** alpha_expand_epilogue (void)
*** 8010,8032 ****
    int i;
  
    sa_size = alpha_sa_size ();
! 
!   frame_size = get_frame_size ();
!   if (TARGET_ABI_OPEN_VMS)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 8 : 0)
! 			      + frame_size
! 			      + current_function_pretend_args_size);
!   else if (TARGET_ABI_UNICOSMK)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 48 : 0))
! 		 + ALPHA_ROUND (frame_size
! 			      + current_function_outgoing_args_size);
!   else
!     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)
! 		  + sa_size
! 		  + ALPHA_ROUND (frame_size
! 				 + current_function_pretend_args_size));
  
    if (TARGET_ABI_OPEN_VMS)
      {
--- 8004,8010 ----
    int i;
  
    sa_size = alpha_sa_size ();
!   frame_size = compute_frame_size (get_frame_size (), sa_size);
  
    if (TARGET_ABI_OPEN_VMS)
      {
*** gcc/config/i386/i386.c.0	2008-07-13 15:50:55.708704904 +0200
--- gcc/config/i386/i386.c	2008-07-13 16:01:26.673783632 +0200
*************** ix86_expand_prologue (void)
*** 6935,6940 ****
--- 6935,6948 ----
  
    ix86_compute_frame_layout (&frame);
  
+   /* We start at the ARG_POINTER register's address.  */
+   if (flag_stack_usage)
+     current_function_static_stack_size
+       = (UNITS_PER_WORD /* return address */
+ 	 + (frame_pointer_needed ? UNITS_PER_WORD : 0) /* saved fp */
+ 	 + frame.nregs * UNITS_PER_WORD /* saved regs */
+ 	 + frame.to_allocate); /* static frame */
+ 
    if (cfun->machine->force_align_arg_pointer)
      {
        rtx x, y;
*** gcc/config/ia64/ia64.c.0	2008-07-13 14:18:55.168954512 +0200
--- gcc/config/ia64/ia64.c	2008-07-13 16:02:35.141374976 +0200
*************** ia64_expand_prologue (void)
*** 3117,3122 ****
--- 3117,3125 ----
    ia64_compute_frame_size (get_frame_size ());
    last_scratch_gr_reg = 15;
  
+   if (flag_stack_usage)
+     current_function_static_stack_size = current_frame_info.total_size;
+ 
    if (dump_file) 
      {
        fprintf (dump_file, "ia64 frame related registers "
*** gcc/config/mips/mips.c.0	2008-07-13 14:18:55.263940072 +0200
--- gcc/config/mips/mips.c	2008-07-13 16:02:18.242943928 +0200
*************** mips_expand_prologue (void)
*** 8505,8510 ****
--- 8505,8513 ----
    frame = &cfun->machine->frame;
    size = frame->total_size;
  
+   if (flag_stack_usage)
+     current_function_static_stack_size = size;
+ 
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)
      mips_emit_probe_stack_range (STACK_CHECK_PROTECT, size);
  
*** gcc/config/pa/pa.c.0	2008-07-13 14:18:55.336928976 +0200
--- gcc/config/pa/pa.c	2008-07-13 16:00:24.090297768 +0200
*************** hppa_expand_prologue (void)
*** 3807,3812 ****
--- 3807,3814 ----
      local_fsize += STARTING_FRAME_OFFSET;
  
    actual_fsize = compute_frame_size (size, &save_fregs);
+   if (flag_stack_usage)
+     current_function_static_stack_size = actual_fsize;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
      pa_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);
*** gcc/config/rs6000/rs6000.c.0	2008-07-13 14:18:55.478907392 +0200
--- gcc/config/rs6000/rs6000.c	2008-07-13 16:02:03.150238368 +0200
*************** rs6000_emit_prologue (void)
*** 15743,15748 ****
--- 15743,15751 ----
    int using_store_multiple;
    HOST_WIDE_INT sp_offset = 0;
  
+   if (flag_stack_usage)
+     current_function_static_stack_size = info->total_size;
+ 
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)
      rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, info->total_size);
  
*** gcc/config/sparc/sparc.c.0	2008-07-13 14:18:55.529899640 +0200
--- gcc/config/sparc/sparc.c	2008-07-13 16:00:59.364935208 +0200
*************** sparc_expand_prologue (void)
*** 4271,4276 ****
--- 4271,4279 ----
    /* Advertise that the data calculated just above are now valid.  */
    sparc_prologue_data_valid_p = true;
  
+   if (flag_stack_usage)
+     current_function_static_stack_size = actual_fsize;
+ 
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
      sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);
  
*** gcc/common.opt.0	2008-07-14 12:30:21.000000000 +0200
--- gcc/common.opt	2008-07-14 12:30:33.000000000 +0200
*************** fcheck-data-deps
*** 370,375 ****
--- 370,383 ----
  Common Report Var(flag_check_data_deps)
  Compare the results of several data dependence analyzers.
  
+ fcallgraph-info
+ Common RejectNegative
+ Output callgraph information on a per-file basis
+ 
+ fcallgraph-info=
+ Common RejectNegative Joined
+ Output callgraph information on a per-file basis with decorations
+ 
  fcommon
  Common Report Var(flag_no_common,0) Optimization
  Do not put uninitialized globals in the common section
*** gcc/doc/invoke.texi.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/doc/invoke.texi	2008-07-14 15:57:05.000000000 +0200
*************** Objective-C and Objective-C++ Dialects}.
*** 297,302 ****
--- 297,303 ----
  -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol
  -ftree-vectorizer-verbose=@var{n} @gol
  -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol
+ -fcallgraph-info@r{[}=su,da@r{]} @gol
  -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
  -feliminate-unused-debug-symbols -femit-class-debug-always @gol
  -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol
*************** the function.  If it is not present, the
*** 4369,4374 ****
--- 4370,4387 ----
  not bounded at compile-time and the second field only represents the
  bounded part.
  
+ @item -fcallgraph-info
+ @itemx -fcallgraph-info=@var{MARKERS}
+ @opindex fcallgraph-info
+ Makes the compiler output callgraph information for the program, on a
+ per-file basis.  The information is generated in the common VCG format.
+ It can be decorated with additional, per-node and/or per-edge information,
+ if a list of comma-separated markers is additionally specified.  When the
+ @code{su} marker is specified, the callgraph is decorated with stack usage
+ information; it is equivalent to @option{-fstack-usage}.  When the @code{da}
+ marker is specified, the callgraph is decorated with information about
+ dynamically allocated objects.
+ 
  @item -fprofile-arcs
  @opindex fprofile-arcs
  Add code so that program flow @dfn{arcs} are instrumented.  During
*** gcc/flags.h.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/flags.h	2008-07-14 15:57:05.000000000 +0200
*************** enum stack_check_type
*** 286,291 ****
--- 286,300 ----
  };
  extern enum stack_check_type flag_stack_check;
  
+ /* Compute stack usage information on a per-function basis.  */
+ extern int flag_stack_usage_info;
+ 
+ /* Output callgraph information on a per-file basis.  */
+ #define CALLGRAPH_INFO_NAKED         0x1
+ #define CALLGRAPH_INFO_STACK_USAGE   0x2
+ #define CALLGRAPH_INFO_DYNAMIC_ALLOC 0x4
+ extern int flag_callgraph_info;
+ 
  /* Returns TRUE if generated code should match ABI version N or
     greater is in use.  */
  
*** gcc/opts.c.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/opts.c	2008-07-14 15:57:05.000000000 +0200
*************** common_handle_option (size_t scode, cons
*** 1548,1553 ****
--- 1548,1579 ----
        add_debug_prefix_map (arg);
        break;
  
+     case OPT_fcallgraph_info:
+       flag_callgraph_info = CALLGRAPH_INFO_NAKED;
+       break;
+ 
+     case OPT_fcallgraph_info_:
+       {
+ 	char *my_arg, *p;
+ 	my_arg = xstrdup (arg);
+ 	p = strtok (my_arg, ",");
+ 	while (p)
+ 	  {
+ 	    if (strcmp (p, "su") == 0)
+ 	      {
+ 		flag_callgraph_info |= CALLGRAPH_INFO_STACK_USAGE;
+ 		flag_stack_usage_info = 1;
+ 	      }
+ 	    else if (strcmp (p, "da") == 0)
+ 	      flag_callgraph_info |= CALLGRAPH_INFO_DYNAMIC_ALLOC;
+ 	    else
+ 	      return 0;
+ 	    p = strtok (NULL, ",");
+ 	  }
+ 	free (my_arg);
+       }
+       break;
+ 
      case OPT_fdiagnostics_show_location_:
        if (!strcmp (arg, "once"))
  	diagnostic_prefixing_rule (global_dc) = DIAGNOSTICS_SHOW_PREFIX_ONCE;
*************** common_handle_option (size_t scode, cons
*** 1742,1747 ****
--- 1768,1779 ----
        stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (arg));
        break;
  
+     case OPT_fstack_usage:
+       flag_stack_usage = value;
+       if (value)
+ 	flag_stack_usage_info = 1;
+       break;
+ 
      case OPT_ftree_vectorizer_verbose_:
        vect_set_verbosity_level (arg);
        break;
*** gcc/calls.c.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/calls.c	2008-07-14 12:30:34.000000000 +0200
*************** expand_call (tree exp, rtx target, int i
*** 2159,2164 ****
--- 2159,2167 ----
  	preferred_stack_boundary = i->preferred_incoming_stack_boundary;
      }
  
+   if (flag_callgraph_info)
+     cgraph_final_record_call (current_function_decl, fndecl, exp);
+ 
    /* Operand 0 is a pointer-to-function; get the type of the function.  */
    funtype = TREE_TYPE (addr);
    gcc_assert (POINTER_TYPE_P (funtype));
*************** expand_call (tree exp, rtx target, int i
*** 2480,2486 ****
  	      stack_arg_under_construction = 0;
  	    }
  	  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);
! 	  if (flag_stack_usage)
  	    current_function_has_unbounded_dynamic_stack_size = 1;
  	}
        else
--- 2483,2489 ----
  	      stack_arg_under_construction = 0;
  	    }
  	  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);
! 	  if (flag_stack_usage_info)
  	    current_function_has_unbounded_dynamic_stack_size = 1;
  	}
        else
*************** expand_call (tree exp, rtx target, int i
*** 2687,2693 ****
  	 be deferred during the evaluation of the arguments.  */
        NO_DEFER_POP;
  
!       if (flag_stack_usage
  	  && !ACCUMULATE_OUTGOING_ARGS && pass && adjusted_args_size.var == 0)
  	{
  	  int pushed = adjusted_args_size.constant + pending_stack_adjust;
--- 2690,2696 ----
  	 be deferred during the evaluation of the arguments.  */
        NO_DEFER_POP;
  
!       if (flag_stack_usage_info
  	  && !ACCUMULATE_OUTGOING_ARGS && pass && adjusted_args_size.var == 0)
  	{
  	  int pushed = adjusted_args_size.constant + pending_stack_adjust;
*************** emit_library_call_value_1 (int retval, r
*** 3650,3656 ****
    if (args_size.constant > current_function_outgoing_args_size)
      current_function_outgoing_args_size = args_size.constant;
  
!   if (flag_stack_usage && !ACCUMULATE_OUTGOING_ARGS)
      {
        int pushed = args_size.constant + pending_stack_adjust;
        if (pushed > current_function_pushed_stack_size)
--- 3653,3659 ----
    if (args_size.constant > current_function_outgoing_args_size)
      current_function_outgoing_args_size = args_size.constant;
  
!   if (flag_stack_usage_info && !ACCUMULATE_OUTGOING_ARGS)
      {
        int pushed = args_size.constant + pending_stack_adjust;
        if (pushed > current_function_pushed_stack_size)
*** gcc/cgraph.h.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/cgraph.h	2008-07-14 15:57:05.000000000 +0200
*************** struct cgraph_rtl_info GTY(())
*** 119,124 ****
--- 119,152 ----
     int preferred_incoming_stack_boundary;
  };
  
+ /* Information about the function that is computed by various parts of
+    the compiler.  Available only for functions that have been already
+    assembled and if -fcallgraph-info was specified.  */
+ 
+ struct cgraph_final_edge GTY((chain_next ("%h.next")))
+ {
+   location_t location;
+   struct cgraph_node *caller;
+   struct cgraph_node *callee;
+   struct cgraph_final_edge *next;
+ };
+ 
+ struct cgraph_dynamic_alloc GTY((chain_next ("%h.next")))
+ {
+   location_t location;
+   const char *name;
+   struct cgraph_dynamic_alloc *next;
+ };
+ 
+ struct cgraph_final_info GTY(())
+ {
+   struct cgraph_final_edge *calls;
+   int stack_usage_kind;
+   HOST_WIDE_INT stack_usage;
+   struct cgraph_dynamic_alloc *dynamic_allocs;
+   bool called;
+ };
+ 
  /* The cgraph data structure.
     Each function decl has assigned cgraph_node listing callees and callers.  */
  
*************** struct cgraph_node GTY((chain_next ("%h.
*** 153,158 ****
--- 181,188 ----
    struct cgraph_global_info global;
    struct cgraph_rtl_info rtl;
  
+   struct cgraph_final_info *final;
+ 
    /* Expected number of executions: calculated in profile.c.  */
    gcov_type count;
    /* Unique id of the node.  */
*************** void dump_cgraph (FILE *);
*** 295,300 ****
--- 325,331 ----
  void debug_cgraph (void);
  void dump_cgraph_node (FILE *, struct cgraph_node *);
  void debug_cgraph_node (struct cgraph_node *);
+ void dump_cgraph_final_vcg (FILE *);
  void cgraph_insert_node_to_hashtable (struct cgraph_node *node);
  void cgraph_remove_edge (struct cgraph_edge *);
  void cgraph_remove_node (struct cgraph_node *);
*************** struct cgraph_node *cgraph_node_for_asm 
*** 308,316 ****
--- 339,350 ----
  struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);
  void cgraph_set_call_stmt (struct cgraph_edge *, tree);
  void cgraph_update_edges_for_call_stmt (tree, tree, tree);
+ void cgraph_final_record_call (tree, tree, tree);
+ void cgraph_final_record_dynamic_alloc (tree, tree);
  struct cgraph_local_info *cgraph_local_info (tree);
  struct cgraph_global_info *cgraph_global_info (tree);
  struct cgraph_rtl_info *cgraph_rtl_info (tree);
+ struct cgraph_final_info *cgraph_final_info (tree);
  const char * cgraph_node_name (struct cgraph_node *);
  struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,
  					struct cgraph_node *,
*** gcc/cgraph.c.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/cgraph.c	2008-07-14 16:01:11.000000000 +0200
*************** cgraph_node (tree decl)
*** 201,206 ****
--- 201,208 ----
  
    node = cgraph_create_node ();
    node->decl = decl;
+   if (flag_callgraph_info)
+     node->final = ggc_alloc_cleared (sizeof (struct cgraph_final_info));
    *slot = node;
    if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)
      {
*************** cgraph_mark_needed_node (struct cgraph_n
*** 657,662 ****
--- 659,716 ----
    cgraph_mark_reachable_node (node);
  }
  
+ /* Create edge from CALLER to CALLEE in the final cgraph.  */
+ 
+ static struct cgraph_final_edge *
+ final_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,
+ 		   tree stmt)
+ {
+   struct cgraph_final_edge *e = ggc_alloc (sizeof (struct cgraph_final_edge));
+   e->location = EXPR_LOCATION (stmt);
+   e->caller = caller;
+   e->callee = callee;
+   e->next = caller->final->calls;
+   caller->final->calls = e;
+   return e;
+ }
+ 
+ /* Record call from SOURCE to DEST in the final cgraph.  */
+ 
+ void
+ cgraph_final_record_call (tree source, tree dest, tree stmt)
+ {
+   struct cgraph_node *callee;
+ 
+   if (dest)
+     {
+       callee = cgraph_node (dest);
+       callee->final->called = true;
+     }
+   else
+     callee = NULL;
+ 
+   (void) final_create_edge (cgraph_node (source), callee, stmt);
+ }
+ 
+ /* Record a dynamically-allocated DECL in the final cgraph of FNDECL.  */
+ 
+ void
+ cgraph_final_record_dynamic_alloc (tree fndecl, tree decl)
+ {
+   const char *dot;
+   struct cgraph_final_info *cfi = cgraph_final_info (fndecl);
+   struct cgraph_dynamic_alloc *cda
+     = ggc_alloc (sizeof (struct cgraph_dynamic_alloc));
+   cda->location = DECL_SOURCE_LOCATION (decl);
+   cda->name = lang_hooks.decl_printable_name (decl, 2);
+   dot = strrchr (cda->name, '.');
+   if (dot)
+     cda->name = dot + 1;
+   cda->name = ggc_strdup (cda->name);
+   cda->next = cfi->dynamic_allocs;
+   cfi->dynamic_allocs = cda;
+ }
+ 
  /* Return local info for the compiled function.  */
  
  struct cgraph_local_info *
*************** cgraph_rtl_info (tree decl)
*** 696,701 ****
--- 750,769 ----
    return &node->rtl;
  }
  
+ /* Return final info for the compiled function.  */
+ 
+ struct cgraph_final_info *
+ cgraph_final_info (tree decl)
+ {
+   struct cgraph_node *node;
+   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);
+   node = cgraph_node (decl);
+   if (decl != current_function_decl
+       && !TREE_ASM_WRITTEN (node->decl))
+     return NULL;
+   return node->final;
+ }
+ 
  /* Return name of the node used in debug output.  */
  const char *
  cgraph_node_name (struct cgraph_node *node)
*************** debug_cgraph (void)
*** 826,831 ****
--- 894,1077 ----
  }
  
  
+ /* Dump placeholder node for indirect calls in VCG format.  */
+ 
+ #define INDIRECT_CALL_NAME  "__indirect_call"
+ 
+ static void
+ dump_cgraph_final_indirect_call_node_vcg (FILE *f)
+ {
+   static bool emitted = false;
+   if (emitted)
+     return;
+ 
+   fputs ("node: { title: \"", f);
+   fputs (INDIRECT_CALL_NAME, f);
+   fputs ("\" label: \"", f);
+   fputs ("Indirect Call Placeholder", f);
+   fputs ("\" shape : ellipse }\n", f);
+   emitted = true;
+ }
+ 
+ /* Dump final cgraph edge in VCG format.  */
+ 
+ static void
+ dump_cgraph_final_edge_vcg (FILE *f, struct cgraph_final_edge *edge)
+ {
+   expanded_location loc;
+ 
+   fputs ("edge: { sourcename: \"", f);
+   print_decl_identifier (f, edge->caller->decl, PRINT_DECL_UNIQUE_NAME);
+   fputs ("\" targetname: \"", f);
+   if (edge->callee)
+     print_decl_identifier (f, edge->callee->decl, PRINT_DECL_UNIQUE_NAME);
+   else
+     fputs (INDIRECT_CALL_NAME, f);
+   fputs ("\" label: \"", f);
+   loc = expand_location (edge->location);
+ #ifdef USE_MAPPED_LOCATION
+   fprintf (f, "%s:%d:%d", loc.file, loc.line, loc.column);
+ #else
+   fprintf (f, "%s:%d", loc.file, loc.line);
+ #endif
+   fputs ("\" }\n", f);
+ 
+   if (!edge->callee)
+     dump_cgraph_final_indirect_call_node_vcg (f);
+ }
+ 
+ /* Dump final cgraph node in VCG format.  */
+ 
+ static void
+ dump_cgraph_final_node_vcg (FILE *f, struct cgraph_node *node)
+ {
+   struct cgraph_final_edge *edge;
+ 
+   fputs ("node: { title: \"", f);
+   print_decl_identifier (f, node->decl, PRINT_DECL_UNIQUE_NAME);
+   fputs ("\" label: \"", f);
+   print_decl_identifier (f, node->decl, PRINT_DECL_NAME);
+   fputs ("\\n", f);
+   print_decl_identifier (f, node->decl, PRINT_DECL_ORIGIN);
+ 
+   if (DECL_EXTERNAL (node->decl))
+     {
+       fputs ("\" shape : ellipse }\n", f);
+       return;
+     }
+ 
+   if (flag_callgraph_info & CALLGRAPH_INFO_STACK_USAGE)
+     {
+       if (node->final->stack_usage)
+ 	fprintf (f, "\\n"HOST_WIDE_INT_PRINT_DEC" bytes (%s)",
+ 		 node->final->stack_usage,
+ 		 stack_usage_qual[node->final->stack_usage_kind]);
+       else
+ 	fputs ("\\n0 bytes", f);
+     }
+ 
+   if (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC)
+     {
+       if (node->final->dynamic_allocs)
+ 	{
+ 	  struct cgraph_dynamic_alloc *cda, *next;
+ 	  unsigned int count = 1;
+ 
+ 	  /* Reverse the linked list and count members.  */
+ 	  cda = node->final->dynamic_allocs;
+ 	  next = cda->next;
+ 	  cda->next = NULL;
+ 	  while (next)
+ 	    {
+ 	      struct cgraph_dynamic_alloc *tmp = next;
+ 	      next = next->next;
+ 	      tmp->next = cda;
+ 	      cda = tmp;
+ 	      count++;
+ 	    }
+ 	  node->final->dynamic_allocs = cda;
+ 
+ 	  fprintf (f, "\\n%d dynamic objects", count);
+ 
+ 	  for (cda = node->final->dynamic_allocs; cda; cda = cda->next)
+ 	    {
+ 	      expanded_location loc = expand_location (cda->location);
+ 	      fprintf (f, "\\n %s", cda->name);
+ #ifdef USE_MAPPED_LOCATION
+ 	      fprintf (f, " %s:%d:%d", loc.file, loc.line, loc.column);
+ #else
+ 	      fprintf (f, " %s:%d", loc.file, loc.line);
+ #endif
+ 	    }
+ 	}
+       else
+ 	fputs ("\\n0 dynamic objects", f);
+     }
+ 
+   fputs ("\" }\n", f);
+ 
+   for (edge = node->final->calls; edge; edge = edge->next)
+     dump_cgraph_final_edge_vcg (f, edge);
+ }
+ 
+ /* Return true if NODE is needed in the final callgraph.  */
+ 
+ static inline bool
+ external_node_needed_p (struct cgraph_node *node)
+ {
+   static bool memcpy_node_seen = false;
+   static bool memset_node_seen = false;
+ 
+   /* External node that are eventually not called are not needed.  */
+   if (!node->final->called)
+     return false;
+ 
+   /* Take care of not emitting the MEMCPY node twice because of the
+      late creation of a clone by the RTL expander.  */
+   if ((DECL_BUILT_IN_CLASS (node->decl) == BUILT_IN_NORMAL
+        && DECL_FUNCTION_CODE (node->decl) == BUILT_IN_MEMCPY)
+       || node->decl == block_move_fn)
+     {
+       if (memcpy_node_seen)
+ 	return false;
+       else
+ 	memcpy_node_seen = true;
+     }
+ 
+   /* Likewise for the MEMSET node.  */
+   if ((DECL_BUILT_IN_CLASS (node->decl) == BUILT_IN_NORMAL
+        && DECL_FUNCTION_CODE (node->decl) == BUILT_IN_MEMSET)
+       || node->decl == block_clear_fn)
+     {
+       if (memset_node_seen)
+ 	return false;
+       else
+ 	memset_node_seen = true;
+     }
+ 
+   return true;
+ }
+ 
+ /* Dump the final cgraph in VCG format.  */
+ 
+ void
+ dump_cgraph_final_vcg (FILE *f)
+ {
+   struct cgraph_node *node;
+ 
+   /* Write the file header.  */
+   fprintf (f, "graph: { title: \"%s\"\n", main_input_filename);
+ 
+   /* Output only nodes that have been written in the final code.  */
+   for (node = cgraph_nodes; node; node = node->next)
+     if ((DECL_EXTERNAL (node->decl) && external_node_needed_p (node))
+ 	|| TREE_ASM_WRITTEN (node->decl))
+       dump_cgraph_final_node_vcg (f, node);
+ 
+   fputs ("}\n", f);
+ }
+ 
+ 
  /* Set the DECL_ASSEMBLER_NAME and update cgraph hashtables.  */
  
  void
*** gcc/explow.c.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/explow.c	2008-07-14 12:30:34.000000000 +0200
*************** allocate_dynamic_stack_space (rtx size, 
*** 1097,1103 ****
    /* If stack usage info is requested, look into the size we are passed.
       We need to do so this early to avoid the obfuscation that may be
       introduced later by the various alignment operations.  */
!   if (flag_stack_usage)
      {
        if (GET_CODE (size) == CONST_INT)
  	stack_usage_size = INTVAL (size);
--- 1097,1103 ----
    /* If stack usage info is requested, look into the size we are passed.
       We need to do so this early to avoid the obfuscation that may be
       introduced later by the various alignment operations.  */
!   if (flag_stack_usage_info)
      {
        if (GET_CODE (size) == CONST_INT)
  	stack_usage_size = INTVAL (size);
*************** allocate_dynamic_stack_space (rtx size, 
*** 1161,1167 ****
  					BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
  			 NULL_RTX);
  
!       if (flag_stack_usage)
  	stack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;
  
        known_align_valid = false;
--- 1161,1167 ----
  					BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
  			 NULL_RTX);
  
!       if (flag_stack_usage_info)
  	stack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;
  
        known_align_valid = false;
*************** allocate_dynamic_stack_space (rtx size, 
*** 1191,1197 ****
        /* The above dynamic offset cannot be computed statically at this
  	 point, but it will be possible to do so after RTL expansion is
  	 done.  Record how many times we will need to add it.  */
!       if (flag_stack_usage)
  	current_function_dynamic_alloc_count++;
  
        known_align_valid = false;
--- 1191,1197 ----
        /* The above dynamic offset cannot be computed statically at this
  	 point, but it will be possible to do so after RTL expansion is
  	 done.  Record how many times we will need to add it.  */
!       if (flag_stack_usage_info)
  	current_function_dynamic_alloc_count++;
  
        known_align_valid = false;
*************** allocate_dynamic_stack_space (rtx size, 
*** 1215,1221 ****
      {
        size = round_push (size);
  
!       if (flag_stack_usage)
  	{
  	  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
  	  stack_usage_size = (stack_usage_size + align - 1) / align * align;
--- 1215,1221 ----
      {
        size = round_push (size);
  
!       if (flag_stack_usage_info)
  	{
  	  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
  	  stack_usage_size = (stack_usage_size + align - 1) / align * align;
*************** allocate_dynamic_stack_space (rtx size, 
*** 1224,1230 ****
  
    /* The size is supposed to be fully adjusted at this point so record it
       if stack usage info is requested.  */
!   if (flag_stack_usage)
      {
        current_function_dynamic_stack_size += stack_usage_size;
  
--- 1224,1230 ----
  
    /* The size is supposed to be fully adjusted at this point so record it
       if stack usage info is requested.  */
!   if (flag_stack_usage_info)
      {
        current_function_dynamic_stack_size += stack_usage_size;
  
*** gcc/expr.c.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/expr.c	2008-07-14 12:30:34.000000000 +0200
*************** emit_block_move_via_libcall (rtx dst, rt
*** 1417,1422 ****
--- 1417,1423 ----
    fn = emit_block_move_libcall_fn (true);
    call_expr = build_call_expr (fn, 3, dst_tree, src_tree, size_tree);
    CALL_EXPR_TAILCALL (call_expr) = tailcall;
+   SET_EXPR_LOCATION (call_expr, input_location);
  
    retval = expand_normal (call_expr);
  
*************** emit_block_move_via_libcall (rtx dst, rt
*** 1427,1433 ****
     for the function we use for block copies.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! static GTY(()) tree block_move_fn;
  
  void
  init_block_move_fn (const char *asmspec)
--- 1428,1434 ----
     for the function we use for block copies.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! tree block_move_fn;
  
  void
  init_block_move_fn (const char *asmspec)
*************** set_storage_via_libcall (rtx object, rtx
*** 2663,2668 ****
--- 2664,2670 ----
    call_expr = build_call_expr (fn, 3,
  			       object_tree, integer_zero_node, size_tree);
    CALL_EXPR_TAILCALL (call_expr) = tailcall;
+   SET_EXPR_LOCATION (call_expr, input_location);
  
    retval = expand_normal (call_expr);
  
*************** set_storage_via_libcall (rtx object, rtx
*** 2673,2679 ****
     for the function we use for block clears.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! static GTY(()) tree block_clear_fn;
  
  void
  init_block_clear_fn (const char *asmspec)
--- 2675,2681 ----
     for the function we use for block clears.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! tree block_clear_fn;
  
  void
  init_block_clear_fn (const char *asmspec)
*************** const_vector_from_tree (tree exp)
*** 10193,10196 ****
  
    return gen_rtx_CONST_VECTOR (mode, v);
  }
- #include "gt-expr.h"
--- 10195,10197 ----
*** gcc/function.c.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/function.c	2008-07-14 14:08:46.000000000 +0200
*************** instantiate_virtual_regs (void)
*** 1737,1743 ****
  
    /* See allocate_dynamic_stack_space for the rationale.  */
  #ifdef SETJMP_VIA_SAVE_AREA
!   if (flag_stack_usage && current_function_calls_setjmp)
      {
        int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
        dynamic_offset = (dynamic_offset + align - 1) / align * align;
--- 1737,1743 ----
  
    /* See allocate_dynamic_stack_space for the rationale.  */
  #ifdef SETJMP_VIA_SAVE_AREA
!   if (flag_stack_usage_info && current_function_calls_setjmp)
      {
        int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
        dynamic_offset = (dynamic_offset + align - 1) / align * align;
*************** prepare_function_start (void)
*** 3995,4001 ****
    init_emit ();
    init_varasm_status (cfun);
    init_expr ();
!   if (flag_stack_usage)
      {
        cfun->su = ggc_alloc_cleared (sizeof (struct stack_usage));
        cfun->su->static_stack_size = -1;
--- 3995,4001 ----
    init_emit ();
    init_varasm_status (cfun);
    init_expr ();
!   if (flag_stack_usage_info)
      {
        cfun->su = ggc_alloc_cleared (sizeof (struct stack_usage));
        cfun->su->static_stack_size = -1;
*************** rest_of_handle_thread_prologue_and_epilo
*** 5650,5656 ****
    thread_prologue_and_epilogue_insns ();
  
    /* The stack usage info is finalized during prologue expansion.  */
!   if (flag_stack_usage)
      output_stack_usage ();
  
    return 0;
--- 5650,5656 ----
    thread_prologue_and_epilogue_insns ();
  
    /* The stack usage info is finalized during prologue expansion.  */
!   if (flag_stack_usage_info)
      output_stack_usage ();
  
    return 0;
*** gcc/gimplify.c.0	2008-07-14 15:56:41.000000000 +0200
--- gcc/gimplify.c	2008-07-14 15:58:11.000000000 +0200
*************** gimplify_vla_decl (tree decl, tree *stmt
*** 1297,1302 ****
--- 1297,1305 ----
    /* Indicate that we need to restore the stack level when the
       enclosing BIND_EXPR is exited.  */
    gimplify_ctxp->save_stack = true;
+ 
+   if (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC)
+     cgraph_final_record_dynamic_alloc (current_function_decl, decl);
  }
  
  /* Gimplifies a DECL_EXPR node *STMT_P by making any necessary allocation
*** gcc/print-tree.c.sav	2008-09-09 07:30:09.000000000 +0200
--- gcc/print-tree.c	2008-12-13 14:51:19.000000000 +0100
*************** print_node (FILE *file, const char *pref
*** 957,959 ****
--- 957,1029 ----
  
    fprintf (file, ">");
  }
+ 
+ /* Print the identifier for DECL according to FLAGS.  */
+ 
+ void
+ print_decl_identifier (FILE *file, tree decl, int flags)
+ {
+   bool needs_colon = false;
+   const char *name;
+   char *malloced_name = NULL;
+   char c;
+ 
+   if (flags & PRINT_DECL_ORIGIN)
+     {
+       if (DECL_IS_BUILTIN (decl))
+ 	fputs ("<built-in>", file);
+       else
+ 	{
+ 	  expanded_location loc
+ 	    = expand_location (DECL_SOURCE_LOCATION (decl));
+ #ifdef USE_MAPPED_LOCATION
+ 	  fprintf (file, "%s:%d:%d", loc.file, loc.line, loc.column);
+ #else
+ 	  fprintf (file, "%s:%d", loc.file, loc.line);
+ #endif
+ 	}
+       needs_colon = true;
+     }
+ 
+   if (flags & PRINT_DECL_UNIQUE_NAME)
+     {
+       name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+       if (!TREE_PUBLIC (decl)
+ 	  || (DECL_WEAK (decl) && !DECL_EXTERNAL (decl)))
+         /* The symbol has internal or weak linkage so its assembler name
+ 	   is not necessarily unique among the compilation units of the
+ 	   program.  We therefore have to further mangle it.  But we can't
+ 	   simply use DECL_SOURCE_FILE because it contains the name of the
+ 	   file the symbol originates from so, e.g. for function templates
+ 	   in C++ where the templates are defined in a header file, we can
+ 	   have symbols with the same assembler name and DECL_SOURCE_FILE.
+ 	   That's why we use the name of the top-level source file of the
+ 	   compilation unit.  ??? Unnecessary for Ada.  */
+ 	name = malloced_name = concat (main_input_filename, ":", name, NULL);
+     }
+   else if (flags & PRINT_DECL_NAME)
+     {
+       const char *dot;
+ 
+       name = lang_hooks.decl_printable_name (decl, 2);
+       dot = strrchr (name, '.');
+       if (dot)
+ 	name = dot + 1;
+     }
+   else
+     return;
+ 
+   if (needs_colon)
+     fputc (':', file);
+ 
+   while ((c = *name++) != '\0')
+     {
+       /* Strip double-quotes because of VCG.  */
+       if (c == '"')
+ 	continue;
+       fputc (c, file);
+     }
+ 
+   if (malloced_name)
+     free (malloced_name);
+ }
*** gcc/toplev.h.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/toplev.h	2008-07-14 12:30:37.000000000 +0200
*************** extern void dump_memory_report (bool);
*** 103,109 ****
  
  extern void target_reinit (void);
  
! /* Output stack usage information.  */
  extern void output_stack_usage (void);
  
  /* A unique local time stamp, might be zero if none is available.  */
--- 103,111 ----
  
  extern void target_reinit (void);
  
! /* Stack usage.  */
! enum { SU_STATIC = 0, SU_DYNAMIC, SU_DYNAMIC_BOUNDED };
! extern const char *stack_usage_qual[];
  extern void output_stack_usage (void);
  
  /* A unique local time stamp, might be zero if none is available.  */
*** gcc/toplev.c.0	2008-07-14 18:06:06.000000000 +0200
--- gcc/toplev.c	2008-07-14 18:03:09.218259688 +0200
*************** int flag_var_tracking = AUTODETECT_VALUE
*** 332,337 ****
--- 332,343 ----
  /* Type of stack check.  */
  enum stack_check_type flag_stack_check = NO_STACK_CHECK;
  
+ /* Output callgraph information on a per-file basis.  */
+ int flag_callgraph_info;
+ 
+ /* Compute stack usage information on a per-function basis.  */
+ int flag_stack_usage_info;
+ 
  /* True if the user has tagged the function with the 'section'
     attribute.  */
  
*************** realloc_for_line_map (void *ptr, size_t 
*** 1616,1636 ****
    return ggc_realloc (ptr, len);
  }
  
  /* Output stack usage information.  */
  void
  output_stack_usage (void)
  {
    static bool warning_issued = false;
-   enum stack_usage_kind_type { STATIC = 0, DYNAMIC, DYNAMIC_BOUNDED };
-   const char *stack_usage_kind_str[] = {
-     "static",
-     "dynamic",
-     "dynamic,bounded"
-   };
    HOST_WIDE_INT stack_usage = current_function_static_stack_size;
!   enum stack_usage_kind_type stack_usage_kind;
!   expanded_location loc;
!   const char *raw_id, *id;
  
    if (stack_usage < 0)
      {
--- 1622,1636 ----
    return ggc_realloc (ptr, len);
  }
  
+ const char *stack_usage_qual[] = { "static", "dynamic", "dynamic,bounded" };
+ 
  /* Output stack usage information.  */
  void
  output_stack_usage (void)
  {
    static bool warning_issued = false;
    HOST_WIDE_INT stack_usage = current_function_static_stack_size;
!   int stack_usage_kind;
  
    if (stack_usage < 0)
      {
*************** output_stack_usage (void)
*** 1642,1692 ****
        return;
      }
  
!   stack_usage_kind = STATIC;
  
    /* Add the maximum amount of space pushed onto the stack.  */
    if (current_function_pushed_stack_size > 0)
      {
        stack_usage += current_function_pushed_stack_size;
!       stack_usage_kind = DYNAMIC_BOUNDED;
      }
  
    /* Now on to the tricky part: dynamic stack allocation.  */
    if (current_function_allocates_dynamic_stack_space)
      {
        if (current_function_has_unbounded_dynamic_stack_size)
! 	stack_usage_kind = DYNAMIC;
        else
! 	stack_usage_kind = DYNAMIC_BOUNDED;
  
        /* Add the size even in the unbounded case, this can't hurt.  */
        stack_usage += current_function_dynamic_stack_size;
      }
  
!   loc = expand_location (DECL_SOURCE_LOCATION (current_function_decl));
! 
!   /* Strip the scope prefix if any.  */
!   raw_id = lang_hooks.decl_printable_name (current_function_decl, 2);
!   id = strrchr (raw_id, '.');
!   if (id)
!     id++;
!   else
!     id = raw_id;
  
!   fprintf (stack_usage_file,
! #ifdef USE_MAPPED_LOCATION
! 	   "%s:%d:%d:%s\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
! #else
! 	   "%s:%d:%s\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
! #endif
! 	   basename (loc.file),
! 	   loc.line,
! #ifdef USE_MAPPED_LOCATION
! 	   loc.column,
! #endif
! 	   id,
! 	   stack_usage,
! 	   stack_usage_kind_str[stack_usage_kind]);
  }
  
  /* Open an auxiliary output file.  */
--- 1642,1683 ----
        return;
      }
  
!   stack_usage_kind = SU_STATIC;
  
    /* Add the maximum amount of space pushed onto the stack.  */
    if (current_function_pushed_stack_size > 0)
      {
        stack_usage += current_function_pushed_stack_size;
!       stack_usage_kind = SU_DYNAMIC_BOUNDED;
      }
  
    /* Now on to the tricky part: dynamic stack allocation.  */
    if (current_function_allocates_dynamic_stack_space)
      {
        if (current_function_has_unbounded_dynamic_stack_size)
! 	stack_usage_kind = SU_DYNAMIC;
        else
! 	stack_usage_kind = SU_DYNAMIC_BOUNDED;
  
        /* Add the size even in the unbounded case, this can't hurt.  */
        stack_usage += current_function_dynamic_stack_size;
      }
  
!   if (flag_callgraph_info & CALLGRAPH_INFO_STACK_USAGE)
!     {
!       struct cgraph_final_info *cfi
! 	= cgraph_final_info (current_function_decl);
!       cfi->stack_usage = stack_usage;
!       cfi->stack_usage_kind = stack_usage_kind;
!     }
  
!   if (flag_stack_usage)
!     {
!       print_decl_identifier (stack_usage_file, current_function_decl,
! 			     PRINT_DECL_ORIGIN | PRINT_DECL_NAME);
!       fprintf (stack_usage_file, "\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
! 	       stack_usage, stack_usage_qual[stack_usage_kind]);
!     }
  }
  
  /* Open an auxiliary output file.  */
*************** finalize (void)
*** 2305,2310 ****
--- 2296,2308 ----
    if (stack_usage_file)
      fclose (stack_usage_file);
  
+   if (flag_callgraph_info)
+     {
+       FILE *file = open_auxiliary_file ("ci");
+       dump_cgraph_final_vcg (file);
+       fclose (file);
+     }
+ 
    finish_optimization_passes ();
  
    if (mem_report)
*** gcc/tree.h.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/tree.h	2008-07-14 13:56:26.000000000 +0200
*************** extern void print_node (FILE *, const ch
*** 5027,5032 ****
--- 5027,5036 ----
  extern void print_node_brief (FILE *, const char *, const_tree, int);
  extern void indent_to (FILE *, int);
  #endif
+ #define PRINT_DECL_ORIGIN       0x1
+ #define PRINT_DECL_NAME         0x2
+ #define PRINT_DECL_UNIQUE_NAME  0x4
+ extern void print_decl_identifier (FILE *, tree, int flags);
  
  /* In tree-inline.c:  */
  extern bool debug_find_tree (tree, tree);
*************** extern void fini_object_sizes (void);
*** 5305,5310 ****
--- 5309,5316 ----
  extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);
  
  /* In expr.c.  */
+ extern GTY(()) tree block_move_fn;
+ extern GTY(()) tree block_clear_fn;
  extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);
  
  /* In tree-inline.c.  */
*** gcc/Makefile.in.0	2008-07-14 12:30:22.000000000 +0200
--- gcc/Makefile.in	2008-07-14 13:57:24.000000000 +0200
*************** expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) 
*** 2423,2429 ****
     libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \
     typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h reload.h \
     $(GGC_H) langhooks.h intl.h $(TM_P_H) $(REAL_H) $(TARGET_H) \
!    tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \
     tree-pass.h $(DF_H) $(DIAGNOSTIC_H)
  dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
--- 2423,2429 ----
     libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \
     typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h reload.h \
     $(GGC_H) langhooks.h intl.h $(TM_P_H) $(REAL_H) $(TARGET_H) \
!    tree-iterator.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \
     tree-pass.h $(DF_H) $(DIAGNOSTIC_H)
  dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
*** gcc/config/alpha/alpha.c.0	2008-07-14 17:56:56.000000000 +0200
--- gcc/config/alpha/alpha.c	2008-07-14 18:12:12.934602240 +0200
*************** alpha_expand_prologue (void)
*** 7502,7508 ****
    sa_size = alpha_sa_size ();
    frame_size = compute_frame_size (get_frame_size (), sa_size);
  
!   if (flag_stack_usage)
      current_function_static_stack_size = frame_size;
  
    if (TARGET_ABI_OPEN_VMS)
--- 7502,7508 ----
    sa_size = alpha_sa_size ();
    frame_size = compute_frame_size (get_frame_size (), sa_size);
  
!   if (flag_stack_usage_info)
      current_function_static_stack_size = frame_size;
  
    if (TARGET_ABI_OPEN_VMS)
*** gcc/config/i386/i386.c.0	2008-07-14 18:10:25.000000000 +0200
--- gcc/config/i386/i386.c	2008-07-14 18:19:16.765170200 +0200
*************** ix86_expand_prologue (void)
*** 6936,6942 ****
    ix86_compute_frame_layout (&frame);
  
    /* We start at the ARG_POINTER register's address.  */
!   if (flag_stack_usage)
      current_function_static_stack_size
        = (UNITS_PER_WORD /* return address */
  	 + (frame_pointer_needed ? UNITS_PER_WORD : 0) /* saved fp */
--- 6936,6942 ----
    ix86_compute_frame_layout (&frame);
  
    /* We start at the ARG_POINTER register's address.  */
!   if (flag_stack_usage_info)
      current_function_static_stack_size
        = (UNITS_PER_WORD /* return address */
  	 + (frame_pointer_needed ? UNITS_PER_WORD : 0) /* saved fp */
*** gcc/config/ia64/ia64.c.0	2008-07-14 18:10:32.000000000 +0200
--- gcc/config/ia64/ia64.c	2008-07-14 18:21:51.230687872 +0200
*************** ia64_expand_prologue (void)
*** 3117,3123 ****
    ia64_compute_frame_size (get_frame_size ());
    last_scratch_gr_reg = 15;
  
!   if (flag_stack_usage)
      current_function_static_stack_size = current_frame_info.total_size;
  
    if (dump_file) 
--- 3117,3123 ----
    ia64_compute_frame_size (get_frame_size ());
    last_scratch_gr_reg = 15;
  
!   if (flag_stack_usage_info)
      current_function_static_stack_size = current_frame_info.total_size;
  
    if (dump_file) 
*** gcc/config/mips/mips.c.0	2008-07-14 18:10:41.000000000 +0200
--- gcc/config/mips/mips.c	2008-07-14 18:27:37.735011208 +0200
*************** mips_expand_prologue (void)
*** 8505,8511 ****
    frame = &cfun->machine->frame;
    size = frame->total_size;
  
!   if (flag_stack_usage)
      current_function_static_stack_size = size;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)
--- 8505,8511 ----
    frame = &cfun->machine->frame;
    size = frame->total_size;
  
!   if (flag_stack_usage_info)
      current_function_static_stack_size = size;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)
*** gcc/config/pa/pa.c.0	2008-07-14 18:10:48.000000000 +0200
--- gcc/config/pa/pa.c	2008-07-14 18:28:33.132589496 +0200
*************** hppa_expand_prologue (void)
*** 3807,3813 ****
      local_fsize += STARTING_FRAME_OFFSET;
  
    actual_fsize = compute_frame_size (size, &save_fregs);
!   if (flag_stack_usage)
      current_function_static_stack_size = actual_fsize;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
--- 3807,3813 ----
      local_fsize += STARTING_FRAME_OFFSET;
  
    actual_fsize = compute_frame_size (size, &save_fregs);
!   if (flag_stack_usage_info)
      current_function_static_stack_size = actual_fsize;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
*** gcc/config/rs6000/rs6000.c.0	2008-07-14 18:11:01.000000000 +0200
--- gcc/config/rs6000/rs6000.c	2008-07-14 18:40:52.136243864 +0200
*************** rs6000_emit_prologue (void)
*** 15743,15749 ****
    int using_store_multiple;
    HOST_WIDE_INT sp_offset = 0;
  
!   if (flag_stack_usage)
      current_function_static_stack_size = info->total_size;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)
--- 15743,15749 ----
    int using_store_multiple;
    HOST_WIDE_INT sp_offset = 0;
  
!   if (flag_stack_usage_info)
      current_function_static_stack_size = info->total_size;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)
*** gcc/config/sparc/sparc.c.0	2008-07-14 18:11:08.000000000 +0200
--- gcc/config/sparc/sparc.c	2008-07-14 18:41:46.979906360 +0200
*************** sparc_expand_prologue (void)
*** 4271,4277 ****
    /* Advertise that the data calculated just above are now valid.  */
    sparc_prologue_data_valid_p = true;
  
!   if (flag_stack_usage)
      current_function_static_stack_size = actual_fsize;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
--- 4271,4277 ----
    /* Advertise that the data calculated just above are now valid.  */
    sparc_prologue_data_valid_p = true;
  
!   if (flag_stack_usage_info)
      current_function_static_stack_size = actual_fsize;
  
    if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
*** gcc/tree-sra.c.0	2008-07-14 23:19:35.559897032 +0200
--- gcc/tree-sra.c	2008-07-14 23:40:10.742120792 +0200
*************** sra_walk_asm_expr (tree expr, block_stmt
*** 934,939 ****
--- 934,968 ----
    sra_walk_tree_list (ASM_OUTPUTS (expr), bsi, true, fns);
  }
  
+ /* Return true if EXPR is a view conversion that must be treated as
+    a barrier for the purpose of scalarization.  */
+ 
+ static bool
+ view_convert_barrier_p (tree expr)
+ {
+   tree source_type, target_type;
+ 
+   if (TREE_CODE (expr) != VIEW_CONVERT_EXPR)
+     return false;
+ 
+   source_type = TREE_TYPE (TREE_OPERAND (expr, 0));
+   target_type = TREE_TYPE (expr);
+ 
+   /* Treat a view conversion from an integral type to an aggregate type
+      (and vice versa) as a barrier if they have the same constant size,
+      i.e. if they are supposed to represent the same underlying object.
+      The problem is that the former has always contiguous representation
+      whereas the latter may have holes, e.g. in Ada; the scalarization
+      will expose this discrepancy, which will break code that effectively
+      expects the undefined bits to be copied in an assignment.  */
+   if (((INTEGRAL_TYPE_P (source_type) && AGGREGATE_TYPE_P (target_type))
+        || (AGGREGATE_TYPE_P (source_type) && INTEGRAL_TYPE_P (target_type)))
+       && tree_int_cst_equal (TYPE_SIZE (source_type), TYPE_SIZE (target_type)))
+     return true;
+ 
+   return false;
+ }
+ 
  /* Walk a GIMPLE_MODIFY_STMT and categorize the assignment appropriately.  */
  
  static void
*************** sra_walk_gimple_modify_stmt (tree expr, 
*** 958,964 ****
    /* If the RHS is scalarizable, handle it.  There are only two cases.  */
    if (rhs_elt)
      {
!       if (!rhs_elt->is_scalar && !TREE_SIDE_EFFECTS (lhs))
  	fns->ldst (rhs_elt, lhs, bsi, false);
        else
  	fns->use (rhs_elt, &GIMPLE_STMT_OPERAND (expr, 1), bsi, false, false);
--- 987,995 ----
    /* If the RHS is scalarizable, handle it.  There are only two cases.  */
    if (rhs_elt)
      {
!       if (!rhs_elt->is_scalar
! 	  && !TREE_SIDE_EFFECTS (lhs)
! 	  && !view_convert_barrier_p (lhs))
  	fns->ldst (rhs_elt, lhs, bsi, false);
        else
  	fns->use (rhs_elt, &GIMPLE_STMT_OPERAND (expr, 1), bsi, false, false);
*************** sra_walk_gimple_modify_stmt (tree expr, 
*** 1002,1008 ****
  	 the result of a function call.  Which would result in trying to call
  	 the function multiple times, and other evil things.  */
        else if (!lhs_elt->is_scalar
! 	       && !TREE_SIDE_EFFECTS (rhs) && is_gimple_addressable (rhs))
  	fns->ldst (lhs_elt, rhs, bsi, true);
  
        /* Otherwise we're being used in some context that requires the
--- 1033,1041 ----
  	 the result of a function call.  Which would result in trying to call
  	 the function multiple times, and other evil things.  */
        else if (!lhs_elt->is_scalar
! 	       && !TREE_SIDE_EFFECTS (rhs)
! 	       && !view_convert_barrier_p (rhs)
! 	       && is_gimple_addressable (rhs))
  	fns->ldst (lhs_elt, rhs, bsi, true);
  
        /* Otherwise we're being used in some context that requires the
*** gcc/doc/tm.texi	(revision 137954)
--- gcc/doc/tm.texi	(working copy)
*************** bits.  Note that this is not the biggest
*** 1094,1099 ****
--- 1094,1104 ----
  just the biggest alignment that, when violated, may cause a fault.
  @end defmac
  
+ @defmac MALLOC_ABI_ALIGNMENT
+ Alignment, in bits, a C conformant malloc implementation has to
+ provide.  If not defined, the default value is @code{BITS_PER_WORD}.
+ @end defmac
+ 
  @defmac MINIMUM_ATOMIC_ALIGNMENT
  If defined, the smallest alignment, in bits, that can be given to an
  object that can be referenced in one operation, without disturbing any
*** gcc/defaults.h	(revision 137954)
--- gcc/defaults.h	(working copy)
*************** along with GCC; see the file COPYING3.  
*** 551,556 ****
--- 551,562 ----
  #define PUSH_ARGS_REVERSED 0
  #endif
  
+ /* Default value for the alignment (in bits) a C conformant malloc has to
+    provide. This default is intended to be safe and always correct.  */
+ #ifndef MALLOC_ABI_ALIGNMENT
+ #define MALLOC_ABI_ALIGNMENT BITS_PER_WORD
+ #endif
+ 
  /* If PREFERRED_STACK_BOUNDARY is not defined, set it to STACK_BOUNDARY.
     STACK_BOUNDARY is required.  */
  #ifndef PREFERRED_STACK_BOUNDARY
*** gcc/collect2.c	(revision 137876)
--- gcc/collect2.c	(working copy)
*************** scan_prog_file (const char *prog_name, e
*** 2479,2486 ****
        /* Some platforms (e.g. OSF4) declare ldopen as taking a
  	 non-const char * filename parameter, even though it will not
  	 modify that string.  So we must cast away const-ness here,
! 	 which will cause -Wcast-qual to burp.  */
!       if ((ldptr = ldopen ((char *)prog_name, ldptr)) != NULL)
  	{
  	  if (! MY_ISCOFF (HEADER (ldptr).f_magic))
  	    fatal ("%s: not a COFF file", prog_name);
--- 2479,2486 ----
        /* Some platforms (e.g. OSF4) declare ldopen as taking a
  	 non-const char * filename parameter, even though it will not
  	 modify that string.  So we must cast away const-ness here,
! 	 using CONST_CAST to prevent complaints from -Wcast-qual.  */
!       if ((ldptr = ldopen (CONST_CAST (char *, prog_name), ldptr)) != NULL)
  	{
  	  if (! MY_ISCOFF (HEADER (ldptr).f_magic))
  	    fatal ("%s: not a COFF file", prog_name);
*** gcc/collect2.c	(revision 137349)
--- gcc/collect2.c	(working copy)
*************** static struct path_prefix *libpaths[3] =
*** 236,243 ****
  					  &libpath_lib_dirs, NULL};
  #endif
  
  static void handler (int);
- static int is_ctor_dtor (const char *);
  static char *find_a_file (struct path_prefix *, const char *);
  static void add_prefix (struct path_prefix *, const char *);
  static void prefix_from_env (const char *, struct path_prefix *);
--- 236,256 ----
  					  &libpath_lib_dirs, NULL};
  #endif
  
+ /* Special kinds of symbols that a name may denote.  */
+ 
+ typedef enum {
+   SYM_REGULAR = 0,  /* nothing special  */
+ 
+   SYM_CTOR = 1,  /* constructor */
+   SYM_DTOR = 2,  /* destructor  */
+   SYM_INIT = 3,  /* shared object routine that calls all the ctors  */
+   SYM_FINI = 4,  /* shared object routine that calls all the dtors  */
+   SYM_DWEH = 5   /* DWARF exception handling table  */
+ } symkind;
+ 
+ static symkind is_ctor_dtor (const char *);
+ 
  static void handler (int);
  static char *find_a_file (struct path_prefix *, const char *);
  static void add_prefix (struct path_prefix *, const char *);
  static void prefix_from_env (const char *, struct path_prefix *);
*************** dump_file (const char *name, FILE *to)
*** 519,530 ****
    fclose (stream);
  }
  
! /* Decide whether the given symbol is: a constructor (1), a destructor
!    (2), a routine in a shared object that calls all the constructors
!    (3) or destructors (4), a DWARF exception-handling table (5), or
!    nothing special (0).  */
  
! static int
  is_ctor_dtor (const char *s)
  {
    struct names { const char *const name; const int len; const int ret;
--- 532,540 ----
    fclose (stream);
  }
  
! /* Return the kind of symbol denoted by name S.  */
  
! static symkind
  is_ctor_dtor (const char *s)
  {
    struct names { const char *const name; const int len; const int ret;
*************** is_ctor_dtor (const char *s)
*** 536,562 ****
  
    static const struct names special[] = {
  #ifndef NO_DOLLAR_IN_LABEL
!     { "GLOBAL__I$", sizeof ("GLOBAL__I$")-1, 1, 0 },
!     { "GLOBAL__D$", sizeof ("GLOBAL__D$")-1, 2, 0 },
  #else
  #ifndef NO_DOT_IN_LABEL
!     { "GLOBAL__I.", sizeof ("GLOBAL__I.")-1, 1, 0 },
!     { "GLOBAL__D.", sizeof ("GLOBAL__D.")-1, 2, 0 },
  #endif /* NO_DOT_IN_LABEL */
  #endif /* NO_DOLLAR_IN_LABEL */
!     { "GLOBAL__I_", sizeof ("GLOBAL__I_")-1, 1, 0 },
!     { "GLOBAL__D_", sizeof ("GLOBAL__D_")-1, 2, 0 },
!     { "GLOBAL__F_", sizeof ("GLOBAL__F_")-1, 5, 0 },
!     { "GLOBAL__FI_", sizeof ("GLOBAL__FI_")-1, 3, 0 },
!     { "GLOBAL__FD_", sizeof ("GLOBAL__FD_")-1, 4, 0 },
!     { NULL, 0, 0, 0 }
    };
  
    while ((ch = *s) == '_')
      ++s;
  
    if (s == orig_s)
!     return 0;
  
    for (p = &special[0]; p->len > 0; p++)
      {
--- 546,572 ----
  
    static const struct names special[] = {
  #ifndef NO_DOLLAR_IN_LABEL
!     { "GLOBAL__I$", sizeof ("GLOBAL__I$")-1, SYM_CTOR, 0 },
!     { "GLOBAL__D$", sizeof ("GLOBAL__D$")-1, SYM_DTOR, 0 },
  #else
  #ifndef NO_DOT_IN_LABEL
!     { "GLOBAL__I.", sizeof ("GLOBAL__I.")-1, SYM_CTOR, 0 },
!     { "GLOBAL__D.", sizeof ("GLOBAL__D.")-1, SYM_DTOR, 0 },
  #endif /* NO_DOT_IN_LABEL */
  #endif /* NO_DOLLAR_IN_LABEL */
!     { "GLOBAL__I_", sizeof ("GLOBAL__I_")-1, SYM_CTOR, 0 },
!     { "GLOBAL__D_", sizeof ("GLOBAL__D_")-1, SYM_DTOR, 0 },
!     { "GLOBAL__F_", sizeof ("GLOBAL__F_")-1, SYM_DWEH, 0 },
!     { "GLOBAL__FI_", sizeof ("GLOBAL__FI_")-1, SYM_INIT, 0 },
!     { "GLOBAL__FD_", sizeof ("GLOBAL__FD_")-1, SYM_FINI, 0 },
!     { NULL, 0, SYM_REGULAR, 0 }
    };
  
    while ((ch = *s) == '_')
      ++s;
  
    if (s == orig_s)
!     return SYM_REGULAR;
  
    for (p = &special[0]; p->len > 0; p++)
      {
*************** is_ctor_dtor (const char *s)
*** 567,573 ****
  	  return p->ret;
  	}
      }
!   return 0;
  }
  
  /* We maintain two prefix lists: one from COMPILER_PATH environment variable
--- 577,583 ----
  	  return p->ret;
  	}
      }
!   return SYM_REGULAR;
  }
  
  /* We maintain two prefix lists: one from COMPILER_PATH environment variable
*************** scan_prog_file (const char *prog_name, e
*** 2174,2190 ****
        *end = '\0';
        switch (is_ctor_dtor (name))
  	{
! 	case 1:
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&constructors, name);
  	  break;
  
! 	case 2:
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&destructors, name);
  	  break;
  
! 	case 3:
  	  if (which_pass != PASS_LIB)
  	    fatal ("init function found in object %s", prog_name);
  #ifndef LD_INIT_SWITCH
--- 2184,2200 ----
        *end = '\0';
        switch (is_ctor_dtor (name))
  	{
! 	case SYM_CTOR:
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&constructors, name);
  	  break;
  
! 	case SYM_DTOR:
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&destructors, name);
  	  break;
  
! 	case SYM_INIT:
  	  if (which_pass != PASS_LIB)
  	    fatal ("init function found in object %s", prog_name);
  #ifndef LD_INIT_SWITCH
*************** scan_prog_file (const char *prog_name, e
*** 2192,2198 ****
  #endif
  	  break;
  
! 	case 4:
  	  if (which_pass != PASS_LIB)
  	    fatal ("fini function found in object %s", prog_name);
  #ifndef LD_FINI_SWITCH
--- 2202,2208 ----
  #endif
  	  break;
  
! 	case SYM_FINI:
  	  if (which_pass != PASS_LIB)
  	    fatal ("fini function found in object %s", prog_name);
  #ifndef LD_FINI_SWITCH
*************** scan_prog_file (const char *prog_name, e
*** 2200,2206 ****
  #endif
  	  break;
  
! 	case 5:
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&frame_tables, name);
  	  break;
--- 2210,2216 ----
  #endif
  	  break;
  
! 	case SYM_DWEH:
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&frame_tables, name);
  	  break;
*************** scan_prog_file (const char *prog_name, e
*** 2519,2525 ****
  
  		      switch (is_ctor_dtor (name))
  			{
! 			case 1:
  			  if (! is_shared)
  			    add_to_list (&constructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
--- 2529,2535 ----
  
  		      switch (is_ctor_dtor (name))
  			{
! 			case SYM_CTOR:
  			  if (! is_shared)
  			    add_to_list (&constructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2528,2534 ****
  #endif
  			  break;
  
! 			case 2:
  			  if (! is_shared)
  			    add_to_list (&destructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
--- 2538,2544 ----
  #endif
  			  break;
  
! 			case SYM_DTOR:
  			  if (! is_shared)
  			    add_to_list (&destructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2538,2551 ****
  			  break;
  
  #ifdef COLLECT_EXPORT_LIST
! 			case 3:
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&constructors, name);
  #endif
  			  break;
  
! 			case 4:
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&destructors, name);
--- 2548,2561 ----
  			  break;
  
  #ifdef COLLECT_EXPORT_LIST
! 			case SYM_INIT:
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&constructors, name);
  #endif
  			  break;
  
! 			case SYM_FINI:
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&destructors, name);
*************** scan_prog_file (const char *prog_name, e
*** 2553,2559 ****
  			  break;
  #endif
  
! 			case 5:
  			  if (! is_shared)
  			    add_to_list (&frame_tables, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
--- 2563,2569 ----
  			  break;
  #endif
  
! 			case SYM_DWEH:
  			  if (! is_shared)
  			    add_to_list (&frame_tables, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*** gcc/collect2.c.ori	Fri Jul 25 10:48:15 2008
--- gcc/collect2.c	Fri Jul 25 11:04:32 2008
*************** struct head
*** 159,173 ****
    int number;
  };
  
- /* Enumeration giving which pass this is for scanning the program file.  */
- 
- enum pass {
-   PASS_FIRST,				/* without constructors */
-   PASS_OBJ,				/* individual objects */
-   PASS_LIB,				/* looking for shared libraries */
-   PASS_SECOND				/* with constructors linked in */
- };
- 
  int vflag;				/* true if -v */
  static int rflag;			/* true if -r */
  static int strip_flag;			/* true if -s */
--- 159,164 ----
*************** static void write_c_file_stat (FILE *, c
*** 274,280 ****
  #ifndef LD_INIT_SWITCH
  static void write_c_file_glob (FILE *, const char *);
  #endif
- static void scan_prog_file (const char *, enum pass);
  #ifdef SCAN_LIBRARIES
  static void scan_libraries (const char *);
  #endif
--- 265,270 ----
*************** static void write_aix_file (FILE *, stru
*** 289,294 ****
--- 279,322 ----
  static char *resolve_lib_name (const char *);
  #endif
  static char *extract_string (const char **);
+ 
+ /* Enumerations describing which pass this is for scanning the
+    program file ...  */
+ 
+ typedef enum {
+   PASS_FIRST,				/* without constructors */
+   PASS_OBJ,				/* individual objects */
+   PASS_LIB,				/* looking for shared libraries */
+   PASS_SECOND				/* with constructors linked in */
+ } scanpass;
+ 
+ /* ... and which kinds of symbols are to be considered.  */
+ 
+ typedef enum {
+   SCAN_CTOR = 1 << SYM_CTOR, 
+   SCAN_DTOR = 1 << SYM_DTOR,
+   SCAN_INIT = 1 << SYM_INIT,
+   SCAN_FINI = 1 << SYM_FINI,
+   SCAN_DWEH = 1 << SYM_DWEH,
+   SCAN_ALL  = ~0
+ } scanfilter;
+ 
+ /* Scan the name list of the loaded program for the symbols g++ uses for
+    static constructors and destructors.
+ 
+    The SCANPASS argument tells which collect processing pass this is for and
+    the SCANFILTER argument tells which kinds of symbols to consider in this
+    pass.  Symbols of a special kind not in the filter mask are considered as
+    regular ones.
+ 
+    The constructor table begins at __CTOR_LIST__ and contains a count of the
+    number of pointers (or -1 if the constructors are built in a separate
+    section by the linker), followed by the pointers to the constructor
+    functions, terminated with a null pointer.  The destructor table has the
+    same format, and begins at __DTOR_LIST__.  */
+ 
+ static void scan_prog_file (const char *, scanpass, scanfilter);
+ 
  
  /* Delete tempfiles and exit function.  */
  
*************** main (int argc, char **argv)
*** 1266,1278 ****
        const char **export_object_lst = (const char **)object_lst;
  
        while (export_object_lst < object)
! 	scan_prog_file (*export_object_lst++, PASS_OBJ);
    }
    {
      struct id *list = libs.first;
  
      for (; list; list = list->next)
!       scan_prog_file (list->name, PASS_FIRST);
    }
  
    if (exports.first)
--- 1294,1306 ----
        const char **export_object_lst = (const char **)object_lst;
  
        while (export_object_lst < object)
! 	scan_prog_file (*export_object_lst++, PASS_OBJ, SCAN_ALL);
    }
    {
      struct id *list = libs.first;
  
      for (; list; list = list->next)
!       scan_prog_file (list->name, PASS_FIRST, SCAN_ALL);
    }
  
    if (exports.first)
*************** main (int argc, char **argv)
*** 1377,1383 ****
  
    /* On AIX we already scanned for global constructors/destructors.  */
  #ifndef COLLECT_EXPORT_LIST
!   scan_prog_file (output_file, PASS_FIRST);
  #endif
  
  #ifdef SCAN_LIBRARIES
--- 1405,1411 ----
  
    /* On AIX we already scanned for global constructors/destructors.  */
  #ifndef COLLECT_EXPORT_LIST
!   scan_prog_file (output_file, PASS_FIRST, SCAN_ALL);
  #endif
  
  #ifdef SCAN_LIBRARIES
*************** main (int argc, char **argv)
*** 1503,1509 ****
  
    /* Let scan_prog_file do any final mods (OSF/rose needs this for
       constructors/destructors in shared libraries.  */
!   scan_prog_file (output_file, PASS_SECOND);
  #endif
  
    maybe_unlink (c_file);
--- 1531,1537 ----
  
    /* Let scan_prog_file do any final mods (OSF/rose needs this for
       constructors/destructors in shared libraries.  */
!   scan_prog_file (output_file, PASS_SECOND, SCAN_ALL);
  #endif
  
    maybe_unlink (c_file);
*************** write_aix_file (FILE *stream, struct id 
*** 2076,2091 ****
  #ifdef OBJECT_FORMAT_NONE
  
  /* Generic version to scan the name list of the loaded program for
!    the symbols g++ uses for static constructors and destructors.
! 
!    The constructor table begins at __CTOR_LIST__ and contains a count
!    of the number of pointers (or -1 if the constructors are built in a
!    separate section by the linker), followed by the pointers to the
!    constructor functions, terminated with a null pointer.  The
!    destructor table has the same format, and begins at __DTOR_LIST__.  */
  
  static void
! scan_prog_file (const char *prog_name, enum pass which_pass)
  {
    void (*int_handler) (int);
  #ifdef SIGQUIT
--- 2104,2114 ----
  #ifdef OBJECT_FORMAT_NONE
  
  /* Generic version to scan the name list of the loaded program for
!    the symbols g++ uses for static constructors and destructors.  */
  
  static void
! scan_prog_file (const char *prog_name, scanpass which_pass,
! 		scanfilter filter)
  {
    void (*int_handler) (int);
  #ifdef SIGQUIT
*************** scan_prog_file (const char *prog_name, e
*** 2164,2170 ****
        char *name, *end;
  
        /* If it contains a constructor or destructor name, add the name
! 	 to the appropriate list.  */
  
        for (p = buf; (ch = *p) != '\0' && ch != '\n' && ch != '_'; p++)
  	if (ch == ' ' && p[1] == 'U' && p[2] == ' ')
--- 2187,2194 ----
        char *name, *end;
  
        /* If it contains a constructor or destructor name, add the name
! 	 to the appropriate list unless this is a kind of symbol we're
! 	 not supposed to even consider.  */
  
        for (p = buf; (ch = *p) != '\0' && ch != '\n' && ch != '_'; p++)
  	if (ch == ' ' && p[1] == 'U' && p[2] == ' ')
*************** scan_prog_file (const char *prog_name, e
*** 2185,2200 ****
--- 2209,2230 ----
        switch (is_ctor_dtor (name))
  	{
  	case SYM_CTOR:
+ 	  if (! (filter & SCAN_CTOR))
+ 	    break;
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&constructors, name);
  	  break;
  
  	case SYM_DTOR:
+ 	  if (! (filter & SCAN_DTOR))
+ 	    break;
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&destructors, name);
  	  break;
  
  	case SYM_INIT:
+ 	  if (! (filter & SCAN_INIT))
+ 	    break;
  	  if (which_pass != PASS_LIB)
  	    fatal ("init function found in object %s", prog_name);
  #ifndef LD_INIT_SWITCH
*************** scan_prog_file (const char *prog_name, e
*** 2203,2208 ****
--- 2233,2240 ----
  	  break;
  
  	case SYM_FINI:
+ 	  if (! (filter & SCAN_FINI))
+ 	    break;
  	  if (which_pass != PASS_LIB)
  	    fatal ("fini function found in object %s", prog_name);
  #ifndef LD_FINI_SWITCH
*************** scan_prog_file (const char *prog_name, e
*** 2211,2216 ****
--- 2243,2250 ----
  	  break;
  
  	case SYM_DWEH:
+ 	  if (! (filter & SCAN_DWEH))
+ 	    break;
  	  if (which_pass != PASS_LIB)
  	    add_to_list (&frame_tables, name);
  	  break;
*************** extern char *ldgetname (LDFILE *, GCC_SY
*** 2457,2472 ****
  #endif
  
  /* COFF version to scan the name list of the loaded program for
!    the symbols g++ uses for static constructors and destructors.
! 
!    The constructor table begins at __CTOR_LIST__ and contains a count
!    of the number of pointers (or -1 if the constructors are built in a
!    separate section by the linker), followed by the pointers to the
!    constructor functions, terminated with a null pointer.  The
!    destructor table has the same format, and begins at __DTOR_LIST__.  */
  
  static void
! scan_prog_file (const char *prog_name, enum pass which_pass)
  {
    LDFILE *ldptr = NULL;
    int sym_index, sym_count;
--- 2491,2501 ----
  #endif
  
  /* COFF version to scan the name list of the loaded program for
!    the symbols g++ uses for static constructors and destructors.  */
  
  static void
! scan_prog_file (const char *prog_name, scanpass which_pass,
! 		scanfilter filter)
  {
    LDFILE *ldptr = NULL;
    int sym_index, sym_count;
*************** scan_prog_file (const char *prog_name, e
*** 2530,2535 ****
--- 2559,2566 ----
  		      switch (is_ctor_dtor (name))
  			{
  			case SYM_CTOR:
+ 			  if (! (filter & SCAN_CTOR))
+ 			    break;
  			  if (! is_shared)
  			    add_to_list (&constructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2539,2544 ****
--- 2570,2577 ----
  			  break;
  
  			case SYM_DTOR:
+ 			  if (! (filter & SCAN_DTOR))
+ 			    break;
  			  if (! is_shared)
  			    add_to_list (&destructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2549,2554 ****
--- 2582,2589 ----
  
  #ifdef COLLECT_EXPORT_LIST
  			case SYM_INIT:
+ 			  if (! (filter & SCAN_INIT))
+ 			    break;
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&constructors, name);
*************** scan_prog_file (const char *prog_name, e
*** 2556,2561 ****
--- 2591,2598 ----
  			  break;
  
  			case SYM_FINI:
+ 			  if (! (filter & SCAN_FINI))
+ 			    break;
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&destructors, name);
*************** scan_prog_file (const char *prog_name, e
*** 2564,2569 ****
--- 2601,2608 ----
  #endif
  
  			case SYM_DWEH:
+ 			  if (! (filter & SCAN_DWEH))
+ 			    break;
  			  if (! is_shared)
  			    add_to_list (&frame_tables, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*** gcc/collect2.c.ori	Fri Jul 25 12:04:06 2008
--- gcc/collect2.c	Fri Jul 25 14:40:07 2008
*************** int do_collecting = 1;
*** 139,144 ****
--- 139,155 ----
  int do_collecting = 0;
  #endif
  
+ /* Cook up an always defined indication of whether we proceed the
+    "EXPORT_LIST" way, much simpler to include in conditional expression
+    and helping readability by preventing the systematic need of #ifdef
+    conditionals.  */
+ 
+ #ifdef COLLECT_EXPORT_LIST
+ #define DO_COLLECT_EXPORT_LIST 1
+ #else
+ #define DO_COLLECT_EXPORT_LIST 0
+ #endif
+ 
  /* Nonzero if we should suppress the automatic demangling of identifiers
     in linker error messages.  Set from COLLECT_NO_DEMANGLE.  */
  int no_demangle;
*************** typedef enum {
*** 293,298 ****
--- 304,311 ----
  /* ... and which kinds of symbols are to be considered.  */
  
  typedef enum {
+   SCAN_NOTHING = 0,
+ 
    SCAN_CTOR = 1 << SYM_CTOR, 
    SCAN_DTOR = 1 << SYM_DTOR,
    SCAN_INIT = 1 << SYM_INIT,
*************** main (int argc, char **argv)
*** 849,854 ****
--- 862,876 ----
    const char **c_ptr;
    char **ld1_argv;
    const char **ld1;
+   
+   /* The kinds of symbols we will have to consider when scanning the
+      outcome of a first pass link.  This is ALL to start with, then might
+      be adjusted before getting to the first pass link per se, typically on
+      AIX where we perform an early scan of objects and libraries to fetch
+      the list of global ctors/dtors and make sure they are not garbage
+      collected.  */
+   scanfilter ld1_filter = SCAN_ALL;
+ 
    char **ld2_argv;
    const char **ld2;
    char **object_lst;
*************** main (int argc, char **argv)
*** 1289,1306 ****
      }
  
    /* The AIX linker will discard static constructors in object files if
!      nothing else in the file is referenced, so look at them first.  */
!   {
!       const char **export_object_lst = (const char **)object_lst;
! 
!       while (export_object_lst < object)
! 	scan_prog_file (*export_object_lst++, PASS_OBJ, SCAN_ALL);
!   }
    {
      struct id *list = libs.first;
  
      for (; list; list = list->next)
!       scan_prog_file (list->name, PASS_FIRST, SCAN_ALL);
    }
  
    if (exports.first)
--- 1311,1339 ----
      }
  
    /* The AIX linker will discard static constructors in object files if
!      nothing else in the file is referenced, so look at them first.  Unless
!      we are building a shared object, ignore the eh frame tables, as we
!      would otherwise reference them all, hence drag all the corresponding
!      objects even if nothing else is referenced.  */
    {
+     const char **export_object_lst = (const char **)object_lst;
      struct id *list = libs.first;
  
+     /* Compute the filter to use from the current one, do scan, then adjust
+        the "current" filter to remove what we just included here.  This will
+        control whether we need a first pass link later on or not, and what
+        will remain to be scanned there.  */
+ 
+     scanfilter this_filter
+       = shared_obj ? ld1_filter : (ld1_filter & ~SCAN_DWEH);
+ 
+     while (export_object_lst < object)
+       scan_prog_file (*export_object_lst++, PASS_OBJ, this_filter);
+ 
      for (; list; list = list->next)
!       scan_prog_file (list->name, PASS_FIRST, this_filter);
! 
!     ld1_filter =~ this_filter;
    }
  
    if (exports.first)
*************** main (int argc, char **argv)
*** 1371,1412 ****
      }
  
    /* Load the program, searching all libraries and attempting to provide
!      undefined symbols from repository information.  */
  
!   /* On AIX we do this later.  */
! #ifndef COLLECT_EXPORT_LIST
!   do_tlink (ld1_argv, object_lst);
! #endif
  
!   /* If -r or they will be run via some other method, do not build the
!      constructor or destructor list, just return now.  */
!   if (rflag
! #ifndef COLLECT_EXPORT_LIST
!       || ! do_collecting
! #endif
!       )
!     {
! #ifdef COLLECT_EXPORT_LIST
!       /* Do the link we avoided above if we are exiting.  */
        do_tlink (ld1_argv, object_lst);
  
!       /* But make sure we delete the export file we may have created.  */
!       if (export_file != 0 && export_file[0])
! 	maybe_unlink (export_file);
! #endif
!       maybe_unlink (c_file);
!       maybe_unlink (o_file);
!       return 0;
!     }
  
!   /* Examine the namelist with nm and search it for static constructors
!      and destructors to call.
!      Write the constructor and destructor tables to a .s file and reload.  */
! 
!   /* On AIX we already scanned for global constructors/destructors.  */
! #ifndef COLLECT_EXPORT_LIST
!   scan_prog_file (output_file, PASS_FIRST, SCAN_ALL);
! #endif
  
  #ifdef SCAN_LIBRARIES
    scan_libraries (output_file);
--- 1404,1448 ----
      }
  
    /* Load the program, searching all libraries and attempting to provide
!      undefined symbols from repository information.
!      
!      If -r or they will be run via some other method, do not build the
!      constructor or destructor list, just return now.  */  
!   {
!     bool early_exit
!       = rflag || (! DO_COLLECT_EXPORT_LIST && ! do_collecting);
  
!     /* Perform the first pass link now, if we're about to exit or if we need
!        to scan for things we haven't collected yet before pursuing further.
  
!        On AIX, the latter typically includes nothing for shared objects or
!        frame tables for an executable, out of what the required early scan on
!        objects and libraries has performed above.  In the !shared_obj case, we
!        expect the relevant tables to be dragged together with their associated
!        functions from precise cross reference insertions by the compiler.  */
!        
!     if (early_exit || ld1_filter != SCAN_NOTHING)
        do_tlink (ld1_argv, object_lst);
+     
+     if (early_exit)
+       {
+ #ifdef COLLECT_EXPORT_LIST
+ 	/* Make sure we delete the export file we may have created.  */
+ 	if (export_file != 0 && export_file[0])
+ 	  maybe_unlink (export_file);
+ #endif
+ 	maybe_unlink (c_file);
+ 	maybe_unlink (o_file);
+ 	return 0;
+       }
+   }
  
!   /* Unless we have done it all already, examine the namelist and search for
!      static constructors and destructors to call.  Write the constructor and
!      destructor tables to a .s file and reload.  */
  
!   if (ld1_filter != SCAN_NOTHING)
!     scan_prog_file (output_file, PASS_FIRST, ld1_filter);
  
  #ifdef SCAN_LIBRARIES
    scan_libraries (output_file);
*************** main (int argc, char **argv)
*** 1419,1424 ****
--- 1455,1463 ----
        notice ("%d frame table(s) found\n", frame_tables.number);
      }
  
+   /* If the scan exposed nothing of special interest, there's no need to
+      generate the glue code and relink so return now.  */
+ 
    if (constructors.number == 0 && destructors.number == 0
        && frame_tables.number == 0
  #if defined (SCAN_LIBRARIES) || defined (COLLECT_EXPORT_LIST)
*************** main (int argc, char **argv)
*** 1429,1438 ****
  #endif
        )
      {
! #ifdef COLLECT_EXPORT_LIST
!       /* Do tlink without additional code generation.  */
!       do_tlink (ld1_argv, object_lst);
! #endif
        /* Strip now if it was requested on the command line.  */
        if (strip_flag)
  	{
--- 1468,1478 ----
  #endif
        )
      {
!       /* Do tlink without additional code generation now if we didn't
! 	 do it earlier for scanning purposes.  */
!       if (ld1_filter == SCAN_NOTHING)
! 	do_tlink (ld1_argv, object_lst);
! 
        /* Strip now if it was requested on the command line.  */
        if (strip_flag)
  	{
*** gcc/doc/tm.texi.ori	Fri Jul 25 18:34:18 2008
--- gcc/doc/tm.texi	Fri Jul 25 15:37:40 2008
*************** A C statement to issue assembly directiv
*** 8891,8896 ****
--- 8891,8902 ----
  reference to the given @var{label}, using an integer of the given @var{size}.
  @end defmac
  
+ @defmac ASM_OUTPUT_DWARF_TABLE_REF (@var{label})
+ A C statement to issue assembly directives that create a reference to
+ the given DWARF table identifier @var{label} from the current function
+ section.
+ @end defmac
+ 
  @deftypefn {Target Hook} void TARGET_ASM_OUTPUT_DWARF_DTPREL (FILE *@var{FILE}, int @var{size}, rtx @var{x})
  If defined, this target hook is a function which outputs a DTP-relative
  reference to the given TLS symbol of the specified size.
*** gcc/dwarf2out.c.ori	Fri Jul 25 18:32:14 2008
--- gcc/dwarf2out.c	Fri Jul 25 15:37:40 2008
*************** dw_cfi_oprnd2_desc (enum dwarf_call_fram
*** 2228,2239 ****
  
  #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)
  
! /* Switch to eh_frame_section.  If we don't have an eh_frame_section,
!    switch to the data section instead, and write out a synthetic label
!    for collect2.  */
  
  static void
! switch_to_eh_frame_section (void)
  {
    tree label;
  
--- 2228,2239 ----
  
  #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)
  
! /* Switch [BACK] to eh_frame_section.  If we don't have an eh_frame_section,
!    switch to the data section instead, and write out a synthetic start label
!    for collect2 the first time around.  */
  
  static void
! switch_to_eh_frame_section (bool back)
  {
    tree label;
  
*************** switch_to_eh_frame_section (void)
*** 2276,2286 ****
        /* We have no special eh_frame section.  Put the information in
  	 the data section and emit special labels to guide collect2.  */
        switch_to_section (data_section);
!       label = get_file_function_name ("F");
!       ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));
!       targetm.asm_out.globalize_label (asm_out_file,
! 				       IDENTIFIER_POINTER (label));
!       ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));
      }
  }
  
--- 2276,2290 ----
        /* We have no special eh_frame section.  Put the information in
  	 the data section and emit special labels to guide collect2.  */
        switch_to_section (data_section);
! 
!       if (!back)
! 	{
! 	  label = get_file_function_name ("F");
! 	  ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));
! 	  targetm.asm_out.globalize_label (asm_out_file,
! 					   IDENTIFIER_POINTER (label));
! 	  ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));
! 	}
      }
  }
  
*************** output_cfi (dw_cfi_ref cfi, dw_fde_ref f
*** 2407,2412 ****
--- 2411,2432 ----
      }
  }
  
+ /* Switch [BACK] to the eh or debug frame table section, depending on
+    FOR_EH.  */
+ static void
+ switch_to_frame_table_section (int for_eh, bool back)
+ {
+   if (for_eh)
+     switch_to_eh_frame_section (back);
+   else
+     {
+       if (!debug_frame_section)
+ 	debug_frame_section = get_section (DEBUG_FRAME_SECTION,
+ 					   SECTION_DEBUG, NULL);
+       switch_to_section (debug_frame_section);
+     }
+ }
+ 
  /* Output the call frame information used to record information
     that relates to calculating the frame pointer, and records the
     location of saved registers.  */
*************** output_call_frame_info (int for_eh)
*** 2472,2486 ****
    if (flag_debug_asm)
      app_enable ();
  
!   if (for_eh)
!     switch_to_eh_frame_section ();
!   else
!     {
!       if (!debug_frame_section)
! 	debug_frame_section = get_section (DEBUG_FRAME_SECTION,
! 					   SECTION_DEBUG, NULL);
!       switch_to_section (debug_frame_section);
!     }
  
    ASM_GENERATE_INTERNAL_LABEL (section_start_label, FRAME_BEGIN_LABEL, for_eh);
    ASM_OUTPUT_LABEL (asm_out_file, section_start_label);
--- 2502,2509 ----
    if (flag_debug_asm)
      app_enable ();
  
!   /* Switch to the proper frame section, first time.  */
!   switch_to_frame_table_section (for_eh, false);
  
    ASM_GENERATE_INTERNAL_LABEL (section_start_label, FRAME_BEGIN_LABEL, for_eh);
    ASM_OUTPUT_LABEL (asm_out_file, section_start_label);
*************** output_call_frame_info (int for_eh)
*** 2749,2754 ****
--- 2762,2781 ----
        for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)
  	output_cfi (cfi, fde, for_eh);
  
+       /* If we are to emit a ref/link from function bodies to their frame
+ 	 tables, do it now.  This is typically performed to make sure that
+ 	 tables associated with functions are dragged with them and not
+ 	 discarded in garbage collecting links, which we need do on a per
+ 	 function basis to cope with -ffunction-sections.  */
+ 	 
+ #ifdef ASM_OUTPUT_DWARF_TABLE_REF
+       /* Switch to the function section, emit the ref to the tables, and
+ 	 switch *back* into the table section.  */
+       switch_to_section (function_section (fde->decl));
+       ASM_OUTPUT_DWARF_TABLE_REF (section_start_label);
+       switch_to_frame_table_section (for_eh, true);
+ #endif
+ 
        /* Pad the FDE out to an address sized boundary.  */
        ASM_OUTPUT_ALIGN (asm_out_file,
  			floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));
*** gcc/config/rs6000/rs6000-protos.h.ori	Fri Jul 25 18:32:39 2008
--- gcc/config/rs6000/rs6000-protos.h	Fri Jul 25 15:37:40 2008
*************** extern bool rs6000_tls_referenced_p (rtx
*** 171,176 ****
--- 171,178 ----
  extern int rs6000_hard_regno_nregs (int, enum machine_mode);
  extern void rs6000_conditional_register_usage (void);
  
+ extern void rs6000_aix_asm_output_dwarf_table_ref (char *);
+ 
  /* Declare functions in rs6000-c.c */
  
  extern void rs6000_pragma_longcall (struct cpp_reader *);
*** gcc/config/rs6000/rs6000.c.ori	Fri Jul 25 18:33:31 2008
--- gcc/config/rs6000/rs6000.c	Fri Jul 25 15:37:40 2008
*************** create_TOC_reference (rtx symbol)
*** 15141,15146 ****
--- 15141,15155 ----
  		 gen_rtx_SYMBOL_REF (Pmode, toc_label_name))));
  }
  
+ /* Issue assembly directives that create a reference to the given DWARF
+    FRAME_TABLE_LABEL from the current function section.  */
+ void
+ rs6000_aix_asm_output_dwarf_table_ref (char * frame_table_label)
+ {
+   fprintf (asm_out_file, "\t.ref %s\n",
+ 	   TARGET_STRIP_NAME_ENCODING (frame_table_label));
+ }
+ 
  /* If _Unwind_* has been called from within the same module,
     toc register is not guaranteed to be saved to 40(1) on function
     entry.  Save it there in that case.  */
*** gcc/config/rs6000/aix.h.ori	Fri Jul 25 18:33:45 2008
--- gcc/config/rs6000/aix.h	Fri Jul 25 15:37:40 2008
***************
*** 43,48 ****
--- 43,54 ----
     collect has a chance to see them, so scan the object files directly.  */
  #define COLLECT_EXPORT_LIST
  
+ /* Issue assembly directives that create a reference to the given DWARF table
+    identifier label from the current function section.  This is defined to
+    ensure we drag frame frame tables associated with needed function bodies in
+    a link with garbage collection activated.  */
+ #define ASM_OUTPUT_DWARF_TABLE_REF rs6000_aix_asm_output_dwarf_table_ref
+ 
  /* Handle #pragma weak and #pragma pack.  */
  #define HANDLE_SYSV_PRAGMA 1
  
*** gcc/config/i386/i386-protos.h.0	2008-07-28 23:58:25.000000000 +0200
--- gcc/config/i386/i386-protos.h	2008-07-29 00:00:38.000000000 +0200
*************** extern void i386_pe_asm_output_aligned_d
*** 230,235 ****
--- 230,241 ----
  extern void i386_pe_file_end (void);
  extern tree i386_pe_mangle_decl_assembler_name (tree, tree);
  
+ extern int i386_pe_rwreloc_reloc_rw_mask (void);
+ extern section *i386_pe_rwreloc_select_section (tree, int,
+ 						unsigned HOST_WIDE_INT);
+ extern section *i386_pe_rwreloc_select_rtx_section (enum machine_mode, rtx,
+ 						    unsigned HOST_WIDE_INT);
+ 
  /* In winnt-cxx.c and winnt-stubs.c  */
  extern void i386_pe_adjust_class_at_definition (tree);
  extern bool i386_pe_type_dllimport_p (tree);
*** gcc/config/i386/mingw32.h.0	2008-07-28 23:58:25.000000000 +0200
--- gcc/config/i386/mingw32.h	2008-07-28 23:58:29.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 77,82 ****
--- 77,92 ----
    %{shared|mdll: -e _DllMainCRTStartup@12} \
    --enable-auto-import --enable-runtime-pseudo-reloc"
  
+ /* The auto-import feature of the linker generates runtime relocations
+    in data sections for symbols imported from DLLs.  */
+ #undef  TARGET_ASM_RELOC_RW_MASK
+ #define TARGET_ASM_RELOC_RW_MASK i386_pe_rwreloc_reloc_rw_mask
+ #undef  TARGET_ASM_SELECT_SECTION
+ #define TARGET_ASM_SELECT_SECTION  i386_pe_rwreloc_select_section
+ #undef  TARGET_ASM_SELECT_RTX_SECTION
+ #define TARGET_ASM_SELECT_RTX_SECTION  i386_pe_rwreloc_select_rtx_section
+ #define TARGET_RWRELOC  1
+ 
  /* Include in the mingw32 libraries with libgcc */
  #undef LIBGCC_SPEC
  #define LIBGCC_SPEC \
*** gcc/config/i386/winnt.c.0	2008-07-28 23:58:25.000000000 +0200
--- gcc/config/i386/winnt.c	2008-07-29 00:03:26.000000000 +0200
*************** i386_pe_strip_name_encoding_full (const 
*** 350,355 ****
--- 350,389 ----
    return name;
  }
  
+ #ifndef TARGET_RWRELOC
+ #define TARGET_RWRELOC flag_pic
+ #endif
+ 
+ int
+ i386_pe_rwreloc_reloc_rw_mask (void)
+ {
+   return TARGET_RWRELOC ? 3 : 0;
+ }
+ 
+ section *
+ i386_pe_rwreloc_select_section (tree decl, int reloc,
+ 				unsigned HOST_WIDE_INT align)
+ {
+   section *ret;
+   int save_pic = flag_pic;
+   flag_pic = TARGET_RWRELOC;
+   ret = default_select_section (decl, reloc, align);
+   flag_pic = save_pic;
+   return ret;
+ }
+ 
+ section *
+ i386_pe_rwreloc_select_rtx_section (enum machine_mode mode, rtx x,
+ 				    unsigned HOST_WIDE_INT align)
+ {
+   section *ret;
+   int save_pic = flag_pic;
+   flag_pic = TARGET_RWRELOC;
+   ret = default_select_rtx_section (mode, x, align);
+   flag_pic = save_pic;
+   return ret;
+ }
+ 
  void
  i386_pe_unique_section (tree decl, int reloc)
  {
*** gcc/scan.c	(revision 137871)
--- gcc/scan.c	(working copy)
*************** make_sstring_space (sstring *str, int co
*** 35,41 ****
    if (new_size <= cur_size)
      return;
  
!   str->base = xrealloc (str->base, new_size);
    str->ptr = str->base + cur_size;
    str->limit = str->base + new_size;
  }
--- 35,41 ----
    if (new_size <= cur_size)
      return;
  
!   str->base = (char *) xrealloc (str->base, new_size);
    str->ptr = str->base + cur_size;
    str->limit = str->base + new_size;
  }
*** gcc/fix-header.c	(revision 137871)
--- gcc/fix-header.c	(working copy)
*************** recognized_function (const cpp_token *fn
*** 562,568 ****
    /* We only have a partial function declaration,
       so remember that we have to add a complete prototype.  */
    partial_count++;
!   partial = obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));
    partial->line_seen = line;
    partial->fn = fn;
    fn->partial = partial;
--- 562,571 ----
    /* We only have a partial function declaration,
       so remember that we have to add a complete prototype.  */
    partial_count++;
!   partial
!     = (struct partial_proto *)
!       obstack_alloc (&scan_file_obstack,
! 	 	     sizeof (struct partial_proto));
    partial->line_seen = line;
    partial->fn = fn;
    fn->partial = partial;
*** gcc/config/rs6000/rs6000.c.ori	Thu Jul 31 18:07:32 2008
--- gcc/config/rs6000/rs6000.c	Fri Aug  1 18:21:33 2008
*************** no_global_regs_above (int first_greg)
*** 15726,15732 ****
  static bool
  rs6000_reg_live_or_pic_offset_p (int reg)
  {
!   return ((df_regs_ever_live_p (reg)
             && (!call_used_regs[reg]
                 || (reg == RS6000_PIC_OFFSET_TABLE_REGNUM
                     && TARGET_TOC && TARGET_MINIMAL_TOC)))
--- 15726,15732 ----
  static bool
  rs6000_reg_live_or_pic_offset_p (int reg)
  {
!   return (((current_function_calls_eh_return || df_regs_ever_live_p (reg))
             && (!call_used_regs[reg]
                 || (reg == RS6000_PIC_OFFSET_TABLE_REGNUM
                     && TARGET_TOC && TARGET_MINIMAL_TOC)))
*** gcc/config/rs6000/aix52.h.0	2008-08-17 16:19:43.000000000 +0200
--- gcc/config/rs6000/aix52.h	2008-08-17 16:20:29.000000000 +0200
*************** do {									\
*** 194,198 ****
--- 194,200 ----
  extern long long int    atoll(const char *);  
  #endif
  
+ #define MD_UNWIND_SUPPORT "config/rs6000/aix-unwind.h"
+ 
  /* This target uses the aix64.opt file.  */
  #define TARGET_USES_AIX64_OPT 1
*** gcc/config/rs6000/aix53.h.0	2008-08-17 16:19:52.000000000 +0200
--- gcc/config/rs6000/aix53.h	2008-08-17 16:20:43.000000000 +0200
*************** do {									\
*** 190,194 ****
--- 190,196 ----
  extern long long int    atoll(const char *);  
  #endif
  
+ #define MD_UNWIND_SUPPORT "config/rs6000/aix-unwind.h"
+ 
  /* This target uses the aix64.opt file.  */
  #define TARGET_USES_AIX64_OPT 1
*** /dev/null	2007-09-21 21:12:45.000000000 +0200
--- gcc/config/rs6000/aix-unwind.h	2008-08-17 18:20:53.000000000 +0200
***************
*** 0 ****
--- 1,242 ----
+ /* DWARF2 EH unwinding support for PowerPC AIX.
+    Copyright (C) 2006 Free Software Foundation, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    In addition to the permissions in the GNU General Public License,
+    the Free Software Foundation gives you unlimited permission to link
+    the compiled version of this file with other programs, and to
+    distribute those programs without any restriction coming from the
+    use of this file.  (The General Public License restrictions do
+    apply in other respects; for example, they cover modification of
+    the file, and distribution when not linked into another program.)
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the
+    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #include <stdlib.h>
+ #include <stddef.h>
+ #include <signal.h>
+ #include <sys/machine.h>
+ 
+ /* These constants are defined in insn-constant.h but this file
+    is not included when compiling for the target.  */
+ #define LR_REGNO             65
+ #define CR2_REGNO            70
+ #define XER_REGNO            76
+ #define FIRST_ALTIVEC_REGNO  77
+ #define VRSAVE_REGNO        109
+ #define VSCR_REGNO          110
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR ppc_aix_fallback_frame_state
+ 
+ #ifdef __powerpc64__
+ #error "64bit fallback for AIX not yet implemented"
+ typedef struct __context64 mstate_t;
+ #else
+ typedef struct mstsave mstate_t;
+ #endif
+ 
+ /* If we are compiling on AIX < 5.3, the VMX related datastructs are not
+    defined and we take measures to obtain proper runtime behavior if the
+    compiled code happens to run on a later version with VMX enabled.  */
+ 
+ #ifndef MSR_VMX
+ #define MSR_VMX 0x2000000
+ #endif
+ 
+ typedef unsigned int uint;
+ typedef struct { uint v[4]; } vreg_t;
+ typedef struct {
+   vreg_t regs[32];
+   uint   pad1 [3];
+   uint   vscr;
+   uint   vrsave;
+   uint   pad2 [3];
+ } vstate_t;
+ 
+ #define EXT_CONTEXT_MARK 0x45435458
+ #define EXT_CONTEXT_SIZE 4096
+ #define BUMPER_SIZE (EXT_CONTEXT_SIZE - sizeof(vstate_t) - (5 * sizeof(int)))
+ 
+ typedef struct {
+   uint     pad1 [4];
+   vstate_t vstate;
+   char     bumper [BUMPER_SIZE];
+   int      mark; 
+ } extended_context_t;
+ 
+ typedef struct {
+   char bumper [offsetof (ucontext_t, uc_stack) + sizeof (stack_t)];
+   extended_context_t * ectx;
+   int mark;
+ } vmx_ucontext_t;
+ 
+ /* Determine whether CONTEXT designates a signal handler, and return the
+    associated ucontext_t address if so.  Return NULL otherwise.  */
+ 
+ static ucontext_t *
+ ucontext_for (struct _Unwind_Context *context)
+ {
+   const unsigned int * ra = context->ra;
+ 
+   /* AIX 5.2 and 5.3, threaded or not, share a common pattern.  */
+ 
+   if (*(ra - 5) == 0x4c00012c     /* isync             */
+       && *(ra - 4) == 0x80ec0000  /* lwz     r7,0(r12) */
+       && *(ra - 3) == 0x804c0004  /* lwz     r2,4(r12) */
+       && *(ra - 2) == 0x7ce903a6  /* mtctr   r7        */
+       && *(ra - 1) == 0x4e800421  /* bctrl             */
+       && *(ra - 0) == 0x7dc37378) /* mr      r3,r14   <-- context->ra */
+     {
+       /* The layout then depends on the AIX version, which we figure out by
+ 	 looking an instruction further up.  */
+ 
+       /* AIX 5.3 */
+       if (*(ra - 6) == 0x7d000164)  /* mtmsrd  r8 */
+ 	{
+ 	  typedef struct {
+ 	    siginfo_t siginfo;
+ 	    ucontext_t ucontext;
+ 	  } aix53_stack_t;
+ 
+ 	  aix53_stack_t * frame = (aix53_stack_t *) context->cfa;
+ 	  return &frame->ucontext;
+ 	}
+ 
+       /* AIX 5.2 */
+       if (*(ra - 6) == 0x7d000124)  /* mtmsr  r8 */
+ 	{
+ 	  typedef struct {
+ 	    char pad[56];
+ 	    ucontext_t ucontext;
+ 	    siginfo_t siginfo;
+ 	  } aix52_stack_t;
+ 
+ 	  aix52_stack_t * frame = (aix52_stack_t *) context->cfa;
+ 	  return &frame->ucontext;
+ 	}
+     }
+ 
+   return 0;
+ }
+ 
+ /* The fallback proper.  */
+ 
+ #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
+ #define RETURN_COLUMN DWARF_ALT_FRAME_RETURN_COLUMN
+ #else
+ #define RETURN_COLUMN ARG_POINTER_REGNUM
+ #endif
+ 
+ #define REGISTER_CFA_OFFSET_FOR(FS,REGNO,ADDR,CFA)\
+ do { \
+ (FS)->regs.reg[REGNO].how = REG_SAVED_OFFSET; \
+ (FS)->regs.reg[REGNO].loc.offset = (long) (ADDR) - (CFA); \
+ } while (0);
+ 
+ static _Unwind_Reason_Code
+ ppc_aix_fallback_frame_state (struct _Unwind_Context *context,
+ 			      _Unwind_FrameState *fs)
+ {
+   static int eh_debug = -1;
+ 
+   ucontext_t * uctx = ucontext_for (context);
+   mstate_t * mctx;
+ 
+   long new_cfa;
+   int i;
+ 
+   if (eh_debug == -1)
+     {
+       char *eh_debug_env = getenv ("EH_DEBUG");
+       eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+    }
+ 
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n",
+ 	    context->cfa, context->ra);
+ 
+   if (uctx == NULL)
+     return _URC_END_OF_STACK;
+ 
+   mctx = &uctx->uc_mcontext.jmp_context;
+ 
+   if (eh_debug)
+     printf ("FALLBACK found ucontext @ 0x%p\n", uctx);
+ 
+   /* The "kernel" frame cfa is the stack pointer at the signal occurrence
+      point.  */
+   new_cfa = mctx->gpr[STACK_POINTER_REGNUM];
+ 
+   fs->regs.cfa_how = CFA_REG_OFFSET;
+   fs->regs.cfa_reg = STACK_POINTER_REGNUM;
+   fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+ 
+   /* And we state how to find the various registers it has saved with
+      relative offset rules from there.  */
+ 
+   for (i = 0; i < 32; i++)
+     if (i != STACK_POINTER_REGNUM)
+       REGISTER_CFA_OFFSET_FOR (fs, i, &mctx->gpr[i], new_cfa);
+ 
+   REGISTER_CFA_OFFSET_FOR (fs, CR2_REGNO, &mctx->cr, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, XER_REGNO, &mctx->xer, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, LR_REGNO, &mctx->lr, new_cfa);
+ 
+   fs->retaddr_column = RETURN_COLUMN;
+   REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->iar, new_cfa);
+   fs->signal_frame = 1;
+ 
+   /* Honor FP Ever Used ...   */
+   if (mctx->fpeu)
+     {
+       if (eh_debug)
+ 	printf ("FALLBACK setting up FPU registers restore\n");
+ 
+       for (i = 0; i < 32; i++)
+ 	REGISTER_CFA_OFFSET_FOR (fs, i+32, &mctx->fpr[i], new_cfa);
+     }
+ 
+   /* Honor VMX context, if any.  We expect the msr bit never to be set in
+      environments where there is no VMX support, e.g. on AIX < 5.3.  */
+   if (mctx->msr & MSR_VMX)
+     {
+       vmx_ucontext_t * uc = (vmx_ucontext_t *) uctx;
+ 
+       if (eh_debug)
+ 	printf ("FALLBACK MSR.VMX is set ...\n");
+ 
+       if (uc->mark == EXT_CONTEXT_MARK && uc->ectx->mark == EXT_CONTEXT_MARK)
+ 	{
+ 	  vstate_t * vstate = &uc->ectx->vstate;
+ 
+ 	  if (eh_debug)
+ 	    printf ("FALLBACK setting up VMX registers restore\n");
+ 
+ 	  for (i = 0; i < 32; i++)
+ 	    REGISTER_CFA_OFFSET_FOR
+ 	    (fs, i+FIRST_ALTIVEC_REGNO, &vstate->regs[i], new_cfa);
+ 
+ 	  REGISTER_CFA_OFFSET_FOR (fs, VSCR_REGNO, &vstate->vscr, new_cfa);
+ 	  REGISTER_CFA_OFFSET_FOR (fs, VRSAVE_REGNO, &vstate->vrsave, new_cfa);
+ 	}
+     }
+ 
+   return _URC_NO_REASON;
+ }
*** gcc/gcov.c.old	2008-03-02 23:55:19.000000000 +0100
--- gcc/gcov.c	2008-08-20 14:41:19.000000000 +0200
***************
*** 361,366 ****
--- 361,369 ----
  
    gcc_init_libintl ();
  
+   /* Handle response files.  */
+   expandargv (&argc, &argv);
+ 
    argno = process_args (argc, argv);
    if (optind == argc)
      print_usage (true);
*** gcc/gcov.c.old	2008-03-02 23:55:19.000000000 +0100
--- gcc/gcov.c	2008-08-20 14:49:58.000000000 +0200
***************
*** 628,634 ****
  
  /* Generate the names of the graph and data files. If OBJECT_DIRECTORY
     is not specified, these are looked for in the current directory,
!    and named from the basename of the FILE_NAME sans extension. If
     OBJECT_DIRECTORY is specified and is a directory, the files are in
     that directory, but named from the basename of the FILE_NAME, sans
     extension. Otherwise OBJECT_DIRECTORY is taken to be the name of
--- 631,637 ----
  
  /* Generate the names of the graph and data files. If OBJECT_DIRECTORY
     is not specified, these are looked for in the current directory,
!    and named from the FILE_NAME sans extension. If
     OBJECT_DIRECTORY is specified and is a directory, the files are in
     that directory, but named from the basename of the FILE_NAME, sans
     extension. Otherwise OBJECT_DIRECTORY is taken to be the name of
***************
*** 667,674 ****
    else
      {
        name = XNEWVEC (char, length + 1);
!       name[0] = 0;
!       base = 1;
      }
  
    if (base)
--- 670,677 ----
    else
      {
        name = XNEWVEC (char, length + 1);
!       strcpy (name, file_name);
!       base = 0;
      }
  
    if (base)
*** gcc/config.gcc.ori	Sat Dec  2 17:56:59 2006
--- gcc/config.gcc	Sun Dec  3 15:53:28 2006
*************** powerpc-wrs-vxworks|powerpc-wrs-vxworksa
*** 2009,2014 ****
--- 2009,2015 ----
  	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppccomm rs6000/t-vxworks"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	extra_headers=ppc-asm.h
+ 	extra_parts="crtbegin.o crtbeginT.o crtend.o"
  	case ${target} in
  	  *-vxworksae*)
  	    tm_file="${tm_file} vx-common.h vxworksae.h rs6000/vxworks.h rs6000/e500.h rs6000/vxworksae.h"
*** gcc/config/rs6000/vxworks.h.ori	Fri Aug 29 16:46:43 2008
--- gcc/config/rs6000/vxworks.h	Mon Sep  1 17:19:41 2008
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 145,147 ****
--- 145,198 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ 
+ /* Support for table based unwinding and exception propagation:
+ 
+    o let the compiler generate the DWARF info into the .eh_frame section,
+ 
+    o rely on the VxWorks default linker script to drag the .eh_frame sections
+      of the individual objects into the .data section of each module,
+ 
+    o resort to the crtstuff machinery to...
+ 
+      - provide the __EH_FRAME_BEGIN__ symbol at the beginning of this section
+        in the "final" binary (we have EH_FRAME_SECTION_NAME defined),
+ 
+      - provide a __do_global_ctors function to trigger the static constructors
+        and register the frame info (for which we define HAS_INIT_SECTION and
+        USE_EH_FRAME_REGISTRY here, and undefine INIT/FINI_SECTION_ASM_OP to
+        avoid relying on the .init/.fini regular elf behavior which does not
+        apply to VxWorks),
+ 
+      - define the _ctors/_dtors arrays for application modules, that VxWorks
+        recognizes as constructors and destructors tables, to trigger an
+        automatic call to __do_global_ctors/__do_global_dtors at dynamic
+        load/unload time.  Doing that is not always appropriate (e.g. when
+        linking against the VxWorks kernel), so we actually use one set of crt
+        objects with those definitions and one without.  The latter is dragged
+        when "-static" is on the link command line, and the former is dragged
+        when "-dynamic" is on the link command line.  See the SPECs below.
+        When -static is used, and so is the set of crt objects without the
+        definitions, another circuitry should be used to trigger the calls.
+ */
+ 
+ #undef  DWARF2_UNWIND_INFO
+ #define DWARF2_UNWIND_INFO 1
+ 
+ /* State we're using the crtstuff objects in addition to the common bits
+    and set things up for them to include just what we want.  */
+ 
+ #undef  STARTFILE_SPEC
+ #define STARTFILE_SPEC VXWORKS_STARTFILE_SPEC \
+       "%{static:crtbeginT.o%s} %{dynamic:crtbegin.o%s}"
+ 
+ #undef  ENDFILE_SPEC
+ #define ENDFILE_SPEC VXWORKS_ENDFILE_SPEC \
+       "%{static|dynamic:crtend.o%s}"
+ 
+ #define HAS_INIT_SECTION
+ #define USE_EH_FRAME_REGISTRY
+ #undef  INIT_SECTION_ASM_OP
+ #undef  FINI_SECTION_ASM_OP
+ 
*** gcc/crtstuff.c.ori	Sat Dec  2 17:58:07 2006
--- gcc/crtstuff.c	Sun Dec  3 18:18:17 2006
*************** call_ ## FUNC (void)					\
*** 114,119 ****
--- 114,128 ----
  # define HIDDEN_DTOR_LIST_END
  #endif
  
+ /* For VxWorks, this (crtstuff) is used to help provide table based unwinding
+    capabilities.  This has not been exercised for Java at this stage and we
+    need to avoid references to Jv regitration routines from here as they would
+    remain unresolved for dynamically loaded modules.  */
+ 
+ #ifdef __vxworks
+ #undef JCR_SECTION_NAME
+ #endif
+ 
  /* We do not want to add the weak attribute to the declarations of these
     routines in unwind-dw2-fde.h because that will cause the definition of
     these symbols to be weak as well.
*************** __do_global_dtors (void)
*** 440,445 ****
--- 449,475 ----
  #endif
  }
  
+ /* We also use this case for VxWorks table based eh.  We arrange for
+    the dynamic loader to hook into __do_global_c/dtors for application
+    modules and leave an indication stating whether we have done that
+    or not.  */
+ #if defined (__vxworks)
+ 
+ #if !defined (CRTSTUFFT_O)
+ 
+ extern void __do_global_dtors (void);
+ func_ptr _dtors [] = {__do_global_dtors, 0};
+ 
+ extern void __do_global_ctors (void);
+ func_ptr _ctors [] = {__do_global_ctors, 0};
+ 
+ const int __module_has_ctors = 1;
+ #else
+ const int __module_has_ctors = 0;
+ #endif
+ 
+ #endif
+ 
  #if defined(USE_EH_FRAME_REGISTRY) || defined(JCR_SECTION_NAME)
  /* A helper function for __do_global_ctors, which is in crtend.o.  Here
     in crtbegin.o, we can reference a couple of symbols not visible there.
*** gcc/config/rs6000/vxworks.h.ori	Mon Sep  1 17:37:38 2008
--- gcc/config/rs6000/vxworks.h	Mon Sep  1 17:37:42 2008
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 180,185 ****
--- 180,187 ----
  #undef  DWARF2_UNWIND_INFO
  #define DWARF2_UNWIND_INFO 1
  
+ #define MD_UNWIND_SUPPORT "config/rs6000/vxworks-unwind.h"
+ 
  /* State we're using the crtstuff objects in addition to the common bits
     and set things up for them to include just what we want.  */
  
*** gcc/config/rs6000/vxworks-unwind.h.ori	Mon Sep  1 16:54:33 2008
--- gcc/config/rs6000/vxworks-unwind.h	Mon Sep  1 16:54:26 2008
***************
*** 0 ****
--- 1,154 ----
+ /* DWARF2 EH unwinding support for PowerPC VxWorks.
+    Copyright (C) 2006 Free Software Foundation, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    In addition to the permissions in the GNU General Public License,
+    the Free Software Foundation gives you unlimited permission to link
+    the compiled version of this file with other programs, and to
+    distribute those programs without any restriction coming from the
+    use of this file.  (The General Public License restrictions do
+    apply in other respects; for example, they cover modification of
+    the file, and distribution when not linked into another program.)
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the
+    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR ppc_vxworks_fallback_frame_state
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <stddef.h>
+ #include <signal.h>
+ 
+ /* We need the constant and structure definitions describing the machine
+    state.  Part of this is normally retrieved from the VxWorks "regs.h" but
+    #including it here gets the GCC internals instance of this file instead.
+    We need to #include the version we need directly here, and prevent the
+    possibly indirect inclusion of the GCC one, as its contents is useless to
+    us and it depends on several other headers that we don't have at hand.  */
+ #include <arch/ppc/regsPpc.h>
+ #define GCC_REGS_H
+ 
+ #include <sigLib.h>
+ 
+ typedef struct sigcontext sigcontext_t;
+ 
+ /* Determine whether CONTEXT designates a signal handler, and return the
+    associated sigontext address if so.  Return NULL otherwise.  */
+ 
+ static sigcontext_t *
+ sigcontext_for (struct _Unwind_Context *context)
+ {
+   const unsigned int * ra = context->ra;
+ 
+   /* VxWorks 5.5.  */
+   if ((*(ra - 6) == 0x7fe3fb78      /* or     r3,r31,r31 */
+        && *(ra - 5) == 0x389e000c   /* addi   r4,r30,0xc */
+        && *(ra - 4) == 0x7fa803a6   /* mtspr  LR,r29 */
+        && *(ra - 3) == 0x7fc5f378   /* or     r5,r30,r30 */
+        && *(ra - 2) == 0x4cc63182   /* crxor  crb6,crb6,crb6 */
+        && *(ra - 1) == 0x4e800021)  /* blrl */
+       ||
+       (*(ra - 6) == 0x7fe3fb78      /* or     r3,r31,r31 */
+        && *(ra - 5) == 0x809e0014   /* lwz    r4,20(r30) */
+        && *(ra - 4) == 0x7fc5f378   /* or     r5,r30,r30 */
+        && *(ra - 3) == 0x7fa803a6   /* mtspr  LR,r29 */
+        && *(ra - 2) == 0x4cc63182   /* crxor  crb6,crb6,crb6 */
+        && *(ra - 1) == 0x4e800021   /* blrl */
+        && *(ra - 0) == 0x7fc3f378)) /* or     r3,r30,r30 */
+     {
+ 	struct {
+ 	    char pad [0x40];
+ 	    sigcontext_t sigcontext;
+ 	} * frame = context->cfa;
+ 	return &frame->sigcontext;
+     }
+ 
+   return 0;
+ }
+ 
+ /* The fallback proper.  */
+ 
+ #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
+ #define RETURN_COLUMN DWARF_ALT_FRAME_RETURN_COLUMN
+ #else
+ #define RETURN_COLUMN ARG_POINTER_REGNUM
+ #endif
+ 
+ #define LR_REGNO LINK_REGISTER_REGNUM
+ 
+ #define REGISTER_CFA_OFFSET_FOR(FS,REGNO,ADDR,CFA)\
+ do { \
+ (FS)->regs.reg[REGNO].how = REG_SAVED_OFFSET; \
+ (FS)->regs.reg[REGNO].loc.offset = (long) (ADDR) - (CFA); \
+ } while (0);
+ 
+ static _Unwind_Reason_Code
+ ppc_vxworks_fallback_frame_state (struct _Unwind_Context *context,
+ 				  _Unwind_FrameState *fs)
+ {
+   static int eh_debug = -1;
+ 
+   sigcontext_t * sigctx = sigcontext_for (context);
+   REG_SET * mctx;
+ 
+   long new_cfa;
+   int i;
+ 
+   if (eh_debug == -1)
+     {
+       char *eh_debug_env = getenv ("EH_DEBUG");
+       eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+    }
+   
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = %p, RA = %p, SIGCTX = %p\n",
+ 	    context->cfa, context->ra, sigctx);
+ 
+   if (sigctx == NULL)
+     return _URC_END_OF_STACK;
+ 
+   mctx = sigctx->sc_pregs;
+ 
+   /* The "kernel" frame cfa is the stack pointer at the signal occurrence
+      point.  */
+   new_cfa = mctx->gpr[STACK_POINTER_REGNUM];
+ 
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = STACK_POINTER_REGNUM;
+   fs->cfa_offset = new_cfa - (long) context->cfa;
+ 
+   /* And we state how to find the various registers it has saved with
+      relative offset rules from there.  */
+ 
+   for (i = 0; i < 32; i++)
+     if (i != STACK_POINTER_REGNUM)
+       REGISTER_CFA_OFFSET_FOR (fs, i, &mctx->gpr[i], new_cfa);
+ 
+   REGISTER_CFA_OFFSET_FOR (fs, CR2_REGNO, &mctx->cr, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, XER_REGNO, &mctx->xer, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, LR_REGNO, &mctx->lr, new_cfa);
+ 
+   fs->retaddr_column = RETURN_COLUMN;
+   REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->pc, new_cfa);
+   fs->signal_frame = 1;
+ 
+   return _URC_NO_REASON;
+ }
+ 
*** gcc/config/pa/pa.c.ori	Mon Sep  1 18:58:42 2008
--- gcc/config/pa/pa.c	Mon Sep  1 19:05:35 2008
*************** pa_output_function_prologue (FILE *file,
*** 3612,3618 ****
--- 3612,3649 ----
    /* hppa_expand_prologue does the dirty work now.  We just need
       to output the assembler directives which denote the start
       of a function.  */
+ 
+   /* Announce the size of the static part of the frame. Note that the value
+      output here is not in accordance with the HP convention, but the delta
+      is compensated by GAS.  */  
    fprintf (file, "\t.CALLINFO FRAME=" HOST_WIDE_INT_PRINT_DEC, actual_fsize);
+   
+   /* If dynamic stack allocation occurs within the function, say so.  */
+   if (current_function_calls_alloca)
+     {
+       fprintf (file, ",ALLOCA_FRAME,LARGE_FRAME");
+       
+       /* LARGE_FRAME is actually not a valid argument since the corresponding
+ 	 unwind entry bit is supposed to be computed by the assembler based
+ 	 upon the actual size of the static part of the frame. GAS does not
+ 	 honor this, however, and due to variations between HP and GCC frame
+ 	 layout conventions, standard calls to the HP unwinding library for
+ 	 backtracing purposes badly fail upon alloca frames if nothing is
+ 	 done.
+ 	 
+ 	 We can fake the unwinder about the value of the frame pointer but its
+ 	 easier to do this when the value of r4 is used, which is the case
+ 	 when the LARGE_FRAME bit is set. To be able to always do this, a
+ 	 patch to GAS makes it support the LARGE_FRAME argument and we always
+ 	 ask for this bit to be set when dynamic stack allocation occurs.
+ 	 
+ 	 Another solution to this issue would be to announce 0 for the size of
+ 	 the static part of the frame, but this badly confuses GDB in a way
+ 	 currently not easily recoverable.  */
+   }
+   
+   /* If this functions calls other functions say so. RP is always saved at
+      the conventional place in such cases, so announce it.  */
    if (current_function_is_leaf)
      fputs (",NO_CALLS", file);
    else
*************** pa_output_function_prologue (FILE *file,
*** 3643,3650 ****
    if (gr_saved)
      fprintf (file, ",ENTRY_GR=%d", gr_saved + 2);
  
!   if (fr_saved)
!     fprintf (file, ",ENTRY_FR=%d", fr_saved + 11);
  
    fputs ("\n\t.ENTRY\n", file);
  
--- 3674,3687 ----
    if (gr_saved)
      fprintf (file, ",ENTRY_GR=%d", gr_saved + 2);
  
!   /* Don't tell about the floating point registers because this would make the
!      backtrace unwinder look for r3 at the wrong place (that is, not where GCC
!      has put it). Might confuse GDB in some cases, but this effect is much
!      less an issue than the mess we get with backtraces otherwise.
! 
!      The right solution would be to fix the frame layout to synchronize with
!      the HP convention. This is desireable but requires a very significant 
!      additional amount of work.  */
  
    fputs ("\n\t.ENTRY\n", file);
  
*** gcc/config/pa/pa.h.ori	Wed Jul 18 22:33:44 2007
--- gcc/config/pa/pa.h	Wed Jul 18 22:33:54 2007
*************** typedef struct machine_function GTY(())
*** 363,371 ****
  /* Base register for access to local variables of the function.  */
  #define FRAME_POINTER_REGNUM 3
  
! /* Value should be nonzero if functions must have frame pointers.  */
! #define FRAME_POINTER_REQUIRED \
!   (current_function_calls_alloca)
  
  /* Don't allow hard registers to be renamed into r2 unless r2
     is already live or already being saved (due to eh).  */
--- 363,374 ----
  /* Base register for access to local variables of the function.  */
  #define FRAME_POINTER_REGNUM 3
  
! /* Value should be nonzero if functions must have frame pointers.
! 
!    ??? Currently forced to 1 to ease backtrace computations using the hpux
!    unwinding library, only device able to backtrace through non GCC code
!    properly.  */
! #define FRAME_POINTER_REQUIRED 1
  
  /* Don't allow hard registers to be renamed into r2 unless r2
     is already live or already being saved (due to eh).  */
*** gcc/config/pa/pa.c.ori	Mon Sep  1 19:09:59 2008
--- gcc/config/pa/pa.c	Mon Sep  1 19:13:23 2008
*************** output_call (rtx insn, rtx call_dest, in
*** 7888,7906 ****
    if (!delay_slot_filled && INSN_ADDRESSES_SET_P ())
      {
        /* See if the return address can be adjusted.  Use the containing
!          sequence insn's address.  */
!       rtx seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));
!       int distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))
! 		      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);
! 
!       if (VAL_14_BITS_P (distance))
! 	{
! 	  xoperands[1] = gen_label_rtx ();
! 	  output_asm_insn ("ldo %0-%1(%%r2),%%r2", xoperands);
! 	  targetm.asm_out.internal_label (asm_out_file, "L",
! 					  CODE_LABEL_NUMBER (xoperands[1]));
  	}
!       else
  	output_asm_insn ("nop\n\tb,n %0", xoperands);
      }
    else
--- 7888,7918 ----
    if (!delay_slot_filled && INSN_ADDRESSES_SET_P ())
      {
        /* See if the return address can be adjusted.  Use the containing
!          sequence insn's address.  Avoid doing that if we're generating call
!          frame information, because we need the return address to remain right
!          after the call in order not to badly confuse the unwinder.  */
!       int call_with_adjusted_ra = 0;
! 
!       if (!DO_FRAME_NOTES)
! 	{	  
! 	  rtx seq_insn
! 	    = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));
! 
! 	  int distance
! 	    = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))
! 	       - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);
! 
! 	  if (VAL_14_BITS_P (distance))
! 	    {
! 	      xoperands[1] = gen_label_rtx ();
! 	      output_asm_insn ("ldo %0-%1(%%r2),%%r2", xoperands);
! 	      targetm.asm_out.internal_label
! 		(asm_out_file, "L", CODE_LABEL_NUMBER (xoperands[1]));
! 	      call_with_adjusted_ra = 1;
! 	    }
  	}
!       
!       if (!call_with_adjusted_ra)
  	output_asm_insn ("nop\n\tb,n %0", xoperands);
      }
    else
*** gcc/config/alpha/t-osf4.ori	Thu Feb 21 12:25:19 2008
--- gcc/config/alpha/t-osf4	Thu Feb 21 12:37:32 2008
*************** SHLIB_NAME = @shlib_base_name@.so
*** 10,20 ****
  SHLIB_SONAME = @shlib_base_name@.so.1
  SHLIB_OBJS = @shlib_objs@
  
! # Hide all POSIX threads related symbols provided by gthr-posix.c.  This
! # only has an effect if t-osf-pthread is in use.
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
- 	-Wl,-hidden_symbol,pthread\* -Wl,-hidden_symbol,__pthread\* \
- 	-Wl,-hidden_symbol,sched_get_\* -Wl,-hidden_symbol,sched_yield \
  	-Wl,-msym -Wl,-set_version,gcc.1 -Wl,-soname,$(SHLIB_SONAME) \
  	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
  	rm -f $(SHLIB_SONAME) && \
--- 10,21 ----
  SHLIB_SONAME = @shlib_base_name@.so.1
  SHLIB_OBJS = @shlib_objs@
  
! # We used to hide all POSIX threads related weak dummy symbols provided by
! # gthr-posix.c, only included if t-osf-pthread is in use. As documented in
! # "The Tru64 UNIX Object File/Symbol Table Format Specification", this
! # prevents their preemption with real symbols, so we don't do it any more.
! 
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
  	-Wl,-msym -Wl,-set_version,gcc.1 -Wl,-soname,$(SHLIB_SONAME) \
  	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
 	rm -f $(SHLIB_SONAME) && \
*** gcc/config/alpha/alpha.h.0	2008-09-02 14:38:59.000000000 +0200
--- gcc/config/alpha/alpha.h	2008-09-02 14:40:12.000000000 +0200
*************** do {						\
*** 908,913 ****
--- 908,919 ----
  
  #define RETURN_ADDR_RTX  alpha_return_addr
  
+ /* Provide a definition of DWARF_FRAME_REGNUM here so that fallback unwinders
+    can use DWARF_ALT_FRAME_RETURN_COLUMN defined below.  This is just the same
+    as the default definition in dwarf2out.c.  */
+ #undef DWARF_FRAME_REGNUM
+ #define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)
+ 
  /* Before the prologue, RA lives in $26.  */
  #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)
  #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (26)
*** gcc/config/alpha/osf5.h.0	2008-09-02 14:40:31.000000000 +0200
--- gcc/config/alpha/osf5.h	2008-09-02 14:41:14.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 54,56 ****
--- 54,57 ----
  #define TARGET_ASM_OPEN_PAREN ""
  #define TARGET_ASM_CLOSE_PAREN ""
  
+ #define MD_UNWIND_SUPPORT "config/alpha/osf5-unwind.h"
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/alpha/osf5-unwind.h	2008-09-10 18:07:59.188796784 +0200
***************
*** 0 ****
--- 1,350 ----
+ /* DWARF2 EH unwinding support for Alpha Tru64 5.
+    Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ /* This file implements the MD_FALLBACK_FRAME_STATE_FOR macro, triggered when
+    the GCC table based unwinding process hits a frame for which no unwind info
+    has been registered. This typically occurs when raising an exception from a
+    signal handler, because the handler is actually called from the OS kernel.
+ 
+    The basic idea is to detect that we are indeed trying to unwind past a
+    signal handler and to fill out the GCC internal unwinding structures for
+    the OS kernel frame as if it had been directly called from the interrupted
+    context.
+ 
+    This is all assuming that the code to set the handler asked the kernel to
+    pass a pointer to such context information.  */
+ 
+ /* --------------------------------------------------------------------------
+    -- Basic principles of operation:
+    --------------------------------------------------------------------------
+ 
+    1/ We first need a way to detect if we are trying to unwind past a signal
+       handler.
+ 
+    The typical method that is used on most platforms is to look at the code
+    around the return address we have and check if it matches the OS code
+    calling a handler.  To determine what this code is expected to be, get a
+    breakpoint into a real signal handler and look at the code around the
+    return address.  Depending on the library versions the pattern of the
+    signal handler is different; this is the reason why we check against more
+    than one pattern.
+ 
+    On this target, the return address is right after the call and every
+    instruction is 4 bytes long.  For the simple case of a null dereference in
+    a single-threaded app, it went like:
+ 
+    # Check that we indeed have something we expect: the instruction right
+    # before the return address is within a __sigtramp function and is a call.
+ 
+    [... run gdb and break at the signal handler entry ...]
+ 
+    (gdb) x /i $ra-4
+    <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>
+ 
+    # Look at the code around that return address, and eventually observe a
+    # significantly large chunk of *constant* code right before the call:
+ 
+    (gdb) x /10i  $ra-44
+    <__sigtramp+120>: lda     gp,-27988(gp)
+    <__sigtramp+124>: ldq     at,-18968(gp)
+    <__sigtramp+128>: lda     t0,-1
+    <__sigtramp+132>: stq     t0,0(at)
+    <__sigtramp+136>: ldq     at,-18960(gp)
+    <__sigtramp+140>: ldl     t1,8(at)
+    <__sigtramp+144>: ldq     at,-18960(gp)
+    <__sigtramp+148>: stl     t1,12(at)
+    <__sigtramp+152>: ldq     at,-18960(gp)
+    <__sigtramp+156>: stl     t0,8(at)
+    
+    # The hexadecimal equivalent that we will have to match is:
+ 
+    (gdb) x /10x  $ra-44
+    <__sigtramp+120>: 0x23bd92ac    0xa79db5e8    0x203fffff   0xb43c0000
+    <__sigtramp+136>: 0xa79db5f0    0xa05c0008    0xa79db5f0   0xb05c000c
+    <__sigtramp+152>: 0xa79db5f0    0xb03c0008
+    
+    The problem observed on this target with this approach is that although
+    we found a constant set of instruction patterns there were some
+    gp-related offsets that made the machine code to differ from one
+    installation to another.  This problem could have been overcome by masking
+    these offsets, but we found that it would be simpler and more efficient to
+    check whether the return address was part of a signal handler, by comparing
+    it against some expected code offset from __sigtramp.
+ 
+    # Check that we indeed have something we expect: the instruction
+    # right before the return address is within a __sigtramp
+    # function and is a call. We also need to obtain the offset
+    # between the return address and the start address of __sigtramp.
+ 
+    [... run gdb and break at the signal handler entry ...]
+ 
+    (gdb) x /2i $ra-4
+    <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>
+    <__sigtramp+164>: ldah    gp,16381(ra)
+ 
+    (gdb) p (long)$ra - (long)&__sigtramp
+    $2 = 164
+ 
+    --------------------------------------------------------------------------
+ 
+    2/ Once we know we are going through a signal handler, we need a way to
+       retrieve information about the interrupted run-time context.
+ 
+    On this platform, the third handler's argument is a pointer to a structure
+    describing this context (struct sigcontext *). We unfortunately have no
+    direct way to transfer this value here, so a couple of tricks are required
+    to compute it.
+ 
+    As documented at least in some header files (e.g. sys/machine/context.h),
+    the structure the handler gets a pointer to is located on the stack.  As of
+    today, while writing this macro, we have unfortunately not been able to
+    find a detailed description of the full stack layout at handler entry time,
+    so we'll have to resort to empirism :)
+ 
+    When unwinding here, we have the handler's CFA at hand, as part of the
+    current unwinding context which is one of our arguments.  We presume that
+    for each call to a signal handler by the same kernel routine, the context's
+    structure location on the stack is always at the same offset from the
+    handler's CFA, and we compute that offset from bare observation:
+    
+    For the simple case of a bare null dereference in a single-threaded app,
+    computing the offset was done using GNAT like this:
+ 
+    # Break on the first handler's instruction, before the prologue to have the
+    # CFA in $sp, and get there:
+ 
+    (gdb) b *&__gnat_error_handler
+    Breakpoint 1 at 0x120016090: file init.c, line 378.
+ 
+    (gdb) r
+    Program received signal SIGSEGV, Segmentation fault.
+ 
+    (gdb) c
+    Breakpoint 1, __gnat_error_handler (sig=..., sip=..., context=...)
+ 
+    # The displayed argument value are meaningless because we stopped before
+    # their final "homing". We know they are passed through $a0, $a1 and $a2
+    # from the ABI, though, so ...
+ 
+    # Observe that $sp and the context pointer are in the same (stack) area,
+    # and compute the offset:
+ 
+    (gdb) p /x $sp
+    $2 = 0x11fffbc80
+ 
+    (gdb) p /x $a2
+    $3 = 0x11fffbcf8
+ 
+    (gdb) p /x (long)$a2 - (long)$sp
+    $4 = 0x78
+    
+    --------------------------------------------------------------------------
+ 
+    3/ Once we know we are unwinding through a signal handler and have the
+       address of the structure describing the interrupted context at hand, we
+       have to fill the internal frame-state/unwind-context structures properly
+       to allow the unwinding process to proceed.
+ 
+    Roughly, we are provided with an *unwinding* CONTEXT, describing the state
+    of some point P in the call chain we are unwinding through.  The macro we
+    implement has to fill a "frame state" structure FS that describe the P's
+    caller state, by way of *rules* to compute its CFA, return address, and
+    **saved** registers *locations*. 
+ 
+    For the case we are going to deal with, the caller is some kernel code
+    calling a signal handler, and:
+ 
+    o The saved registers are all in the interrupted run-time context,
+ 
+    o The CFA is the stack pointer value when the kernel code is entered, that
+      is, the stack pointer value at the interruption point, also part of the
+      interrupted run-time context.
+ 
+    o We want the return address to appear as the address of the active
+      instruction at the interruption point, so that the unwinder proceeds as
+      if the interruption had been a regular call.  This address is also part
+      of the interrupted run-time context.
+ 
+    --
+ 
+    Also, note that there is an important difference between the return address
+    we need to claim for the kernel frame and the value of the return address
+    register at the interruption point.
+ 
+    The latter might be required to be able to unwind past the interrupted
+    routine, for instance if it is interrupted before saving the incoming
+    register value in its own frame, which may typically happen during stack
+    probes for stack-checking purposes.
+ 
+    It is then essential that the rules stated to locate the kernel frame
+    return address don't clobber the rules describing where is saved the return
+    address register at the interruption point, so some scratch register state
+    entry should be used for the former. We have DWARF_ALT_FRAME_RETURN_COLUMN
+    at hand exactly for that purpose.
+ 
+    --------------------------------------------------------------------------
+ 
+    4/ Depending on the context (single-threaded or multi-threaded app, ...),
+    the code calling the handler and the handler-cfa to interrupted-context
+    offset might change, so we use a simple generic data structure to track
+    the possible variants.  */
+ 
+ /* This is the structure to wrap information about each possible sighandler
+    caller we may have to identify.  */
+ 
+ typedef struct {
+   /* Expected return address when being called from a sighandler.  */
+   void *ra_value;
+ 
+   /* Offset to get to the sigcontext structure from the handler's CFA
+      when the pattern matches.  */
+   int cfa_to_context_offset;
+ 
+ } sighandler_call_t;
+ 
+ /* Helper macro for MD_FALLBACK_FRAME_STATE_FOR below.
+ 
+    Look at RA to see if it matches within a sighandler caller.
+    Set SIGCTX to the corresponding sigcontext structure (computed from
+    CFA) if it does, or to 0 otherwise.  */
+ 
+ #define COMPUTE_SIGCONTEXT_FOR(RA,CFA,SIGCTX)				    \
+ do {									    \
+   /* Define and register the applicable patterns.  */			    \
+   extern void __sigtramp (void);					    \
+ 									    \
+   sighandler_call_t sighandler_calls [] = {				    \
+     {__sigtramp + 164, 0x78}						    \
+   };									    \
+ 									    \
+   int n_patterns_to_match						    \
+     = sizeof (sighandler_calls) / sizeof (sighandler_call_t);		    \
+ 									    \
+   int pn;  /* pattern number  */					    \
+ 									    \
+   int match = 0;  /* Did last pattern match ?  */			    \
+ 									    \
+   /* Try to match each pattern in turn.  */				    \
+   for (pn = 0; !match && pn < n_patterns_to_match; pn ++)		    \
+     match = ((RA) == sighandler_calls[pn].ra_value);			    \
+ 									    \
+   (SIGCTX) = (struct sigcontext *)					    \
+     (match ? ((CFA) + sighandler_calls[pn - 1].cfa_to_context_offset) : 0); \
+ } while (0);
+ 
+ #include <sys/context_t.h>
+ 
+ #define REG_SP  30  /* hard reg for stack pointer */
+ #define REG_RA  26  /* hard reg for return address */
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ alpha_fallback_frame_state (struct _Unwind_Context *context,
+ 			    _Unwind_FrameState *fs)
+ {
+   char *eh_debug_env = getenv ("EH_DEBUG");
+   int eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+ 
+   /* Return address and CFA of the frame we're attempting to unwind through,
+      possibly a signal handler.  */
+   void *ctx_ra  = (void *)context->ra;
+   void *ctx_cfa = (void *)context->cfa;
+ 
+   /* CFA of the intermediate abstract kernel frame between the interrupted
+      code and the signal handler, if we're indeed unwinding through a signal
+      handler.  */
+   void *k_cfa;
+ 
+   /* Pointer to the sigcontext structure pushed by the kernel when we're
+      unwinding through a signal handler.  */
+   struct sigcontext *sigctx;
+   int i;
+ 
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n", ctx_cfa, ctx_ra);
+ 
+   COMPUTE_SIGCONTEXT_FOR (ctx_ra, ctx_cfa, sigctx);
+ 
+   if (sigctx == 0)
+     return _URC_END_OF_STACK;
+ 
+   /* The kernel frame's CFA is exactly the stack pointer value at the
+      interruption point.  */
+   k_cfa = (void *) sigctx->sc_regs [REG_SP];
+ 
+   if (eh_debug)
+     printf ("Match for K_CFA = 0x%p, SIGCTX @ 0x%p\n", k_cfa, sigctx);
+ 
+   /* State the rules to compute the CFA we have the value of: use the
+      previous CFA and offset by the difference between the two.  See
+      uw_update_context_1 for the supporting details.  */
+   fs->regs.cfa_how = CFA_REG_OFFSET;
+   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+   fs->regs.cfa_offset = k_cfa - ctx_cfa;
+ 
+   /* Fill the internal frame_state structure with information stating
+      where each register of interest in the saved context can be found
+      from the CFA.  */
+ 
+   /* The general registers are in sigctx->sc_regs.  Leave out r31, which
+      is read-as-zero. It makes no sense restoring it, and we are going to
+      use the state entry for the kernel return address rule below.
+ 
+      This loop must cover at least all the callee-saved registers, and
+      we just don't bother specializing the set here.  */
+   for (i = 0; i <= 30; i ++)
+     {
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset
+ 	= (void *) &sigctx->sc_regs[i] - (void *) k_cfa;
+     }
+ 
+   /* Ditto for the floating point registers in sigctx->sc_fpregs.  */
+   for (i = 0; i <= 31; i ++)
+     {
+       fs->regs.reg[32+i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[32+i].loc.offset
+ 	= (void *) &sigctx->sc_fpregs[i] - (void *) k_cfa;
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which
+      is the address of the active instruction when the signal was caught,
+      in sigctx->sc_pc. Use DWARF_ALT_FRAME_RETURN_COLUMN since the return
+      address register is a general register and should be left alone.  */
+   fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
+   fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;
+   fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset
+     = (void *) &sigctx->sc_pc - (void *) k_cfa;
+   fs->signal_frame = 1;
+ 
+   return _URC_NO_REASON;
+ }
*** Makefile.in.orig	2008-09-05 12:06:21.000000000 +0200
--- Makefile.in	2008-09-05 12:06:25.000000000 +0200
***************
*** 49147,49158 ****
  	  mv gcc/include gcc/tmp-include 2>/dev/null; \
  	  mkdir gcc/include; \
  	  cp $(srcdir)/gcc/gsyslimits.h gcc/include/syslimits.h; \
  	  touch gcc/stmp-fixinc gcc/include/fixed; \
! 	  rm -f gcc/stmp-headers gcc/stmp-int-hdrs; \
  	  r=`${PWD_COMMAND}`; export r; \
  	  s=`cd $(srcdir); ${PWD_COMMAND}` ; export s; \
  	  $(HOST_EXPORTS) \
  	  (cd ./gcc && \
  	   $(MAKE) $(GCC_FLAGS_TO_PASS) install); \
  	  rm -rf gcc/include; \
  	  mv gcc/tmp-include gcc/include 2>/dev/null; \
--- 49147,49171 ----
  	  mv gcc/include gcc/tmp-include 2>/dev/null; \
  	  mkdir gcc/include; \
  	  cp $(srcdir)/gcc/gsyslimits.h gcc/include/syslimits.h; \
+ 	  mv gcc/stmp-fixinc gcc/stmp-fixinc-orig; \
  	  touch gcc/stmp-fixinc gcc/include/fixed; \
! 	  mv gcc/stmp-int-hdrs gcc/stmp-int-hdrs-orig; \
! 	  mv gcc/stmp-headers gcc/stmp-headers-orig; \
  	  r=`${PWD_COMMAND}`; export r; \
  	  s=`cd $(srcdir); ${PWD_COMMAND}` ; export s; \
  	  $(HOST_EXPORTS) \
  	  (cd ./gcc && \
+ 	   $(MAKE) $(GCC_FLAGS_TO_PASS) stmp-int-hdrs); \
+ 	  mv gcc/stmp-fixinc-orig gcc/stmp-fixinc; \
+ 	  mv gcc/stmp-int-hdrs-orig gcc/stmp-int-hdrs; \
+ 	  mv gcc/stmp-headers-orig gcc/stmp-headers; \
+ 	  true; \
+ 	else true; fi
+ 	@if [ -f ./gcc/Makefile ]; then \
+           r=`${PWD_COMMAND}`; export r; \
+           s=`cd $(srcdir); ${PWD_COMMAND}` ; export s; \
+           $(HOST_EXPORTS) \
+ 	  (cd ./gcc && \
  	   $(MAKE) $(GCC_FLAGS_TO_PASS) install); \
  	  rm -rf gcc/include; \
  	  mv gcc/tmp-include gcc/include 2>/dev/null; \
*** gcc/config/rs6000/rs6000.c.0	2008-09-06 21:02:04.000000000 +0200
--- gcc/config/rs6000/rs6000.c	2008-09-06 21:02:12.000000000 +0200
*************** rs6000_output_function_entry (FILE *file
*** 11558,11567 ****
  	  break;
  	}
      }
!   if (TARGET_AIX)
!     RS6000_OUTPUT_BASENAME (file, fname);
!   else
!     assemble_name (file, fname);
  }
  
  /* Print an operand.  Recognize special options, documented below.  */
--- 11558,11565 ----
  	  break;
  	}
      }
! 
!   RS6000_OUTPUT_BASENAME (file, fname);
  }
  
  /* Print an operand.  Recognize special options, documented below.  */
*************** rs6000_output_function_epilogue (FILE *f
*** 17231,17240 ****
        /* Offset from start of code to tb table.  */
        fputs ("\t.long ", file);
        ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, "LT");
!       if (TARGET_AIX)
! 	RS6000_OUTPUT_BASENAME (file, fname);
!       else
! 	assemble_name (file, fname);
        putc ('-', file);
        rs6000_output_function_entry (file, fname);
        putc ('\n', file);
--- 17229,17235 ----
        /* Offset from start of code to tb table.  */
        fputs ("\t.long ", file);
        ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, "LT");
!       RS6000_OUTPUT_BASENAME (file, fname);
        putc ('-', file);
        rs6000_output_function_entry (file, fname);
        putc ('\n', file);
*** gcc/config/alpha/osf5.h.0	2008-09-07 22:14:48.000000000 +0200
--- gcc/config/alpha/osf5.h	2008-09-07 22:15:00.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 21,26 ****
--- 21,46 ----
  #undef TARGET_DEFAULT
  #define TARGET_DEFAULT	(MASK_FPREGS | MASK_LONG_DOUBLE_128)
  
+ /* This says how to output assembler code to declare an uninitialized
+    internal linkage data object.  */
+ #undef ASM_OUTPUT_ALIGNED_LOCAL
+ #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
+ do { 									\
+   fputs ("\t.lcomm ", (FILE));						\
+   assemble_name ((FILE), (NAME));					\
+   fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED, (SIZE));		\
+   fprintf ((FILE), ",%d\n", exact_log2 ((ALIGN) / BITS_PER_UNIT));	\
+ } while (0)
+ 
+ /* This says how to output assembler code to declare an uninitialized
+    external linkage data object.  According to the Tru64 5.1 assembler
+    manual, .lcomm works for global objects too.  */
+ #undef ASM_OUTPUT_ALIGNED_BSS
+ #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)		\
+ do {									\
+   ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);			\
+ } while (0)
+ 
  /* In Tru64 UNIX V5.1, Compaq introduced a new assembler
     (/usr/lib/cmplrs/cc/adu) which currently (versions between 3.04.29 and
     3.04.32) breaks mips-tfile.  Passing the undocumented -oldas flag reverts
*** gcc/config/alpha/alpha.c.0	2008-09-07 22:25:36.000000000 +0200
--- gcc/config/alpha/alpha.c	2008-09-07 22:42:00.000000000 +0200
*************** decl_has_samegp (const_tree decl)
*** 743,781 ****
    return !TREE_PUBLIC (decl) || !DECL_EXTERNAL (decl);
  }
  
- /* Return true if EXP should be placed in the small data section.  */
- 
- static bool
- alpha_in_small_data_p (const_tree exp)
- {
-   /* We want to merge strings, so we never consider them small data.  */
-   if (TREE_CODE (exp) == STRING_CST)
-     return false;
- 
-   /* Functions are never in the small data area.  Duh.  */
-   if (TREE_CODE (exp) == FUNCTION_DECL)
-     return false;
- 
-   if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
-     {
-       const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
-       if (strcmp (section, ".sdata") == 0
- 	  || strcmp (section, ".sbss") == 0)
- 	return true;
-     }
-   else
-     {
-       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
- 
-       /* If this is an incomplete type with size 0, then we can't put it
- 	 in sdata because it might be too big when completed.  */
-       if (size > 0 && (unsigned HOST_WIDE_INT) size <= g_switch_value)
- 	return true;
-     }
- 
-   return false;
- }
- 
  #if TARGET_ABI_OPEN_VMS
  static bool
  alpha_linkage_symbol_p (const char *symname)
--- 743,748 ----
*************** alpha_file_start (void)
*** 9400,9406 ****
  }
  #endif
  
! #ifdef OBJECT_FORMAT_ELF
  /* Since we don't have a .dynbss section, we should not allow global
     relocations in the .rodata section.  */
  
--- 9367,9374 ----
  }
  #endif
  
! #if defined (OBJECT_FORMAT_ELF) && !TARGET_ABI_OPEN_VMS
! 
  /* Since we don't have a .dynbss section, we should not allow global
     relocations in the .rodata section.  */
  
*************** alpha_elf_section_type_flags (tree decl,
*** 9440,9445 ****
--- 9409,9447 ----
    flags |= default_section_type_flags (decl, name, reloc);
    return flags;
  }
+ 
+ /* Return true if EXP should be placed in the small data section.  */
+ 
+ static bool
+ alpha_in_small_data_p (const_tree exp)
+ {
+   /* We want to merge strings, so we never consider them small data.  */
+   if (TREE_CODE (exp) == STRING_CST)
+     return false;
+ 
+   /* Functions are never in the small data area.  Duh.  */
+   if (TREE_CODE (exp) == FUNCTION_DECL)
+     return false;
+ 
+   if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
+     {
+       const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
+       if (strcmp (section, ".sdata") == 0
+ 	  || strcmp (section, ".sbss") == 0)
+ 	return true;
+     }
+   else
+     {
+       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
+ 
+       /* If this is an incomplete type with size 0, then we can't put it
+ 	 in sdata because it might be too big when completed.  */
+       if (size > 0 && (unsigned HOST_WIDE_INT) size <= g_switch_value)
+ 	return true;
+     }
+ 
+   return false;
+ }
  #endif /* OBJECT_FORMAT_ELF */
  
  /* Structure to collect function names for final output in link section.  */
*************** alpha_init_libfuncs (void)
*** 10638,10646 ****
  # define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags
  #endif
  
- #undef TARGET_IN_SMALL_DATA_P
- #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p
- 
  #if TARGET_ABI_UNICOSMK
  # undef TARGET_INSERT_ATTRIBUTES
  # define TARGET_INSERT_ATTRIBUTES unicosmk_insert_attributes
--- 10638,10643 ----
*************** alpha_init_libfuncs (void)
*** 10672,10684 ****
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.align 0\n\t.quad\t"
  #endif
  
! #ifdef OBJECT_FORMAT_ELF
  #undef  TARGET_ASM_RELOC_RW_MASK
  #define TARGET_ASM_RELOC_RW_MASK  alpha_elf_reloc_rw_mask
  #undef	TARGET_ASM_SELECT_RTX_SECTION
  #define	TARGET_ASM_SELECT_RTX_SECTION  alpha_elf_select_rtx_section
  #undef  TARGET_SECTION_TYPE_FLAGS
  #define TARGET_SECTION_TYPE_FLAGS  alpha_elf_section_type_flags
  #endif
  
  #undef TARGET_ASM_FUNCTION_END_PROLOGUE
--- 10670,10684 ----
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.align 0\n\t.quad\t"
  #endif
  
! #if defined (OBJECT_FORMAT_ELF) && !TARGET_ABI_OPEN_VMS
  #undef  TARGET_ASM_RELOC_RW_MASK
  #define TARGET_ASM_RELOC_RW_MASK  alpha_elf_reloc_rw_mask
  #undef	TARGET_ASM_SELECT_RTX_SECTION
  #define	TARGET_ASM_SELECT_RTX_SECTION  alpha_elf_select_rtx_section
  #undef  TARGET_SECTION_TYPE_FLAGS
  #define TARGET_SECTION_TYPE_FLAGS  alpha_elf_section_type_flags
+ #undef TARGET_IN_SMALL_DATA_P
+ #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p
  #endif
  
  #undef TARGET_ASM_FUNCTION_END_PROLOGUE
*** gcc/config/i386/darwin.h.orig	Tue Sep  9 12:16:44 2008
--- gcc/config/i386/darwin.h	Tue Sep  9 12:17:07 2008
***************
*** 242,248 ****
     compiles default to stabs+.  darwin9+ defaults to dwarf-2.  */
  #ifndef DARWIN_PREFER_DWARF
  #undef PREFERRED_DEBUGGING_TYPE
! #define PREFERRED_DEBUGGING_TYPE (TARGET_64BIT ? DWARF2_DEBUG : DBX_DEBUG)
  #endif
  
  /* Darwin uses the standard DWARF register numbers but the default
--- 242,248 ----
     compiles default to stabs+.  darwin9+ defaults to dwarf-2.  */
  #ifndef DARWIN_PREFER_DWARF
  #undef PREFERRED_DEBUGGING_TYPE
! #define PREFERRED_DEBUGGING_TYPE  DWARF2_DEBUG 
  #endif
  
  /* Darwin uses the standard DWARF register numbers but the default
*** gcc/config/mips/iris6.h.0	2008-09-11 15:27:00.448285992 +0200
--- gcc/config/mips/iris6.h	2008-09-11 15:29:26.191129712 +0200
*************** along with GCC; see the file COPYING3.  
*** 142,144 ****
--- 142,146 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ #define MD_UNWIND_SUPPORT "config/mips/iris6-unwind.h"
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/mips/iris6-unwind.h	2008-09-11 15:31:38.998939856 +0200
***************
*** 0 ****
--- 1,141 ----
+ /* DWARF2 EH unwinding support for MIPS Irix 6.
+    Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #include <signal.h>
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR mips_fallback_frame_state
+ 
+ #define UINT_AT(ADDR) (*(unsigned int *)(ADDR))
+ 
+ /* Look at the code around RA to see if it matches a sighandler caller with a
+    sigcontext_t * argument (SA_SIGINFO cleared).  Return that pointer argument
+    if it does match, or 0 otherwise.  */
+ 
+ static sigcontext_t *
+ sigcontext_for (void * ra, void * cfa)
+ {
+   /* IRIX 6.5, mono-threaded application.  We're lucky enough to be able
+      to expect a short very sighandler specific sequence around.  */
+   if (UINT_AT (ra + 24) == 0x24020440      /* li v0,1088 (SYS_sigreturn) */
+       && UINT_AT (ra + 28) == 0x0000000c)  /* syscall */
+     return (sigcontext_t *)(cfa + 0x30);
+ 
+   /* IRIX 6.5 variants, multi-threaded application, pthreads.  Nothing really
+      sighandler specific handy, so match a fairly long constant sequence.  */
+   if (UINT_AT (ra - 40) == 0xffb00000          /* sd      s0,0(sp)     */
+       && UINT_AT (ra - 36) == 0x0004f880       /* sll     ra,a0,0x2    */
+       && (UINT_AT (ra - 32) == 0x27399058      /* addiu   t9,t9,-28584 */
+ 	  || UINT_AT (ra - 32) == 0x273990d8)  /* addiu   t9,t9,-28456 */
+       && UINT_AT (ra - 28) == 0x8c300edc       /* lw      s0,3804(at)  */
+       && UINT_AT (ra - 24) == 0x033fc821       /* addu    t9,t9,ra     */
+       && UINT_AT (ra - 20) == 0x8f390000       /* lw      t9,0(t9)     */
+       && UINT_AT (ra - 16) == 0xdc210e70       /* ld      at,3696(at)  */
+       && UINT_AT (ra - 12) == 0xde120058       /* ld      s2,88(s0)    */
+       && UINT_AT (ra - 8)  == 0x0320f809       /* jalr    t9           */
+       && UINT_AT (ra - 4)  == 0xfe010058)      /* sd      at,88(s0)    */
+     return (sigcontext_t *)(cfa + 0x60);
+ 
+   return 0;
+ }
+ 
+ #define SIGCTX_GREG_ADDR(REGNO,SIGCTX) \
+   ((void *) &(SIGCTX)->sc_regs[REGNO])
+ 
+ #define SIGCTX_FPREG_ADDR(REGNO,SIGCTX) \
+   ((void *) &(SIGCTX)->sc_fpregs[REGNO])
+ 
+ static _Unwind_Reason_Code
+ mips_fallback_frame_state (struct _Unwind_Context *context,
+ 			   _Unwind_FrameState *fs)
+ {
+   char *eh_debug_env = getenv ("EH_DEBUG");
+   int eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+ 
+   /* Return address and CFA of the frame we're attempting to unwind through,
+      possibly a signal handler.  */
+   void *ctx_ra  = (void *)context->ra;
+   void *ctx_cfa = (void *)context->cfa;
+ 
+   /* CFA of the intermediate abstract kernel frame between the interrupted
+      code and the signal handler, if we're indeed unwinding through a signal
+      handler.  */
+   void *k_cfa;
+ 
+   /* Pointer to the sigcontext_t structure pushed by the kernel when we're
+      unwinding through a signal handler setup with SA_SIGINFO cleared.  */
+   sigcontext_t *sigctx;
+   int i;
+ 
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n", ctx_cfa, ctx_ra);
+ 
+   sigctx = sigcontext_for (ctx_ra, ctx_cfa);
+ 
+   if (sigctx == 0)
+     return _URC_END_OF_STACK;
+ 
+   /* The abstract kernel frame's CFA is extactly the stack pointer
+      value at the interruption point.  */
+   k_cfa = *(void **)SIGCTX_GREG_ADDR (CTX_SP, sigctx);
+ 
+   if (eh_debug)
+     printf ("Match for K_CFA = 0x%p, SIGCTX @ 0x%p\n", k_cfa, sigctx);
+ 
+   /* State the rules to compute the CFA we have the value of: use the
+      previous CFA and offset by the difference between the two.  See
+      uw_update_context_1 for the supporting details.  */
+   fs->regs.cfa_how = CFA_REG_OFFSET;
+   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+   fs->regs.cfa_offset = k_cfa - ctx_cfa;
+ 
+   /* Fill the internal frame_state structure with information stating where
+      each register of interest can be found from the CFA.  */
+   for (i = 0; i <= 31; i ++)
+     {
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset = SIGCTX_GREG_ADDR (i, sigctx) - k_cfa;
+     }
+ 
+   for (i = 0; i <= 31; i ++)
+     {
+       fs->regs.reg[32+i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[32+i].loc.offset = SIGCTX_FPREG_ADDR (i, sigctx) - k_cfa;
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which is the
+      address of the active instruction when the signal was caught.  */
+   fs->retaddr_column = CTX_T0;
+   fs->regs.reg[CTX_T0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[CTX_T0].loc.offset = (void *)&sigctx->sc_pc - k_cfa;
+   fs->signal_frame = 1;
+ 
+   return _URC_NO_REASON;
+ }
*** gcc/dbxout.h.0	2008-09-12 21:27:13.123335336 +0200
--- gcc/dbxout.h	2008-09-12 21:28:23.592622376 +0200
*************** extern int dbxout_symbol (tree, int);
*** 25,30 ****
--- 25,31 ----
  extern void dbxout_parms (tree);
  extern void dbxout_reg_parms (tree);
  extern int dbxout_syms (tree);
+ extern void dbxout_static_link (tree);
  
  /* Language description for N_SO stabs.  */
  #define N_SO_AS          1
*** gcc/dbxout.c.0	2008-09-12 21:27:07.206234872 +0200
--- gcc/dbxout.c	2008-09-12 21:30:14.721728184 +0200
*************** static GTY(()) int next_type_number;
*** 201,206 ****
--- 201,210 ----
  
  static GTY(()) tree preinit_symbols;
  
+ /* The fake variable pointing to the static link in the frame.  */
+ 
+ static GTY(()) tree static_link_var;
+ 
  enum binclstatus {BINCL_NOT_REQUIRED, BINCL_PENDING, BINCL_PROCESSED};
  
  /* When using N_BINCL in dbx output, each type number is actually a
*************** dbxout_init (const char *input_file_name
*** 1070,1075 ****
--- 1074,1082 ----
  	dbxout_symbol (TREE_VALUE (t), 0);
        preinit_symbols = 0;
      }
+ 
+   static_link_var = build_decl (VAR_DECL, get_identifier ("__link"),
+ 				build_pointer_type (void_type_node));
  }
  
  /* Output any typedef names for types described by TYPE_DECLs in SYMS.  */
*************** dbxout_begin_function (tree decl)
*** 3514,3522 ****
--- 3521,3541 ----
    dbxout_parms (DECL_ARGUMENTS (decl));
    if (DECL_NAME (DECL_RESULT (decl)) != 0)
      dbxout_symbol (DECL_RESULT (decl), 1);
+ 
+   if (cfun->static_chain_decl)
+     dbxout_static_link (cfun->static_chain_decl);
  }
  #endif /* DBX_DEBUGGING_INFO */
  
+ /* Output the information about the static link.  */
+ 
+ void
+ dbxout_static_link (tree decl)
+ {
+   dbxout_symbol_location (static_link_var, TREE_TYPE (static_link_var), NULL,
+ 			  eliminate_regs (DECL_RTL (decl), 0, NULL_RTX));
+ }
+ 
  #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
  
  #include "gt-dbxout.h"
*** gcc/xcoffout.c.0	2008-09-12 21:27:31.554533368 +0200
--- gcc/xcoffout.c	2008-09-12 21:30:50.209333248 +0200
*************** along with GCC; see the file COPYING3.  
*** 33,38 ****
--- 33,39 ----
  #include "toplev.h"
  #include "output.h"
  #include "ggc.h"
+ #include "function.h"
  #include "target.h"
  #include "debug.h"
  
*************** xcoffout_begin_prologue (unsigned int li
*** 451,456 ****
--- 452,460 ----
    xcoffout_block (DECL_INITIAL (current_function_decl), 0,
  		  DECL_ARGUMENTS (current_function_decl));
  
+   if (cfun->static_chain_decl)
+     dbxout_static_link (cfun->static_chain_decl);
+ 
    ASM_OUTPUT_LINE (asm_out_file, line);
  }
  
*** gcc/Makefile.in.0	2008-09-12 21:27:25.794409040 +0200
--- gcc/Makefile.in	2008-09-12 21:31:24.654096848 +0200
*************** vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(
*** 2471,2477 ****
     $(RTL_H) $(FLAGS_H) output.h vmsdbg.h debug.h langhooks.h $(FUNCTION_H) $(TARGET_H)
  xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) toplev.h output.h dbxout.h \
!    $(GGC_H) $(TARGET_H) debug.h gstab.h xcoff.h
  emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \
     $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \
--- 2471,2477 ----
     $(RTL_H) $(FLAGS_H) output.h vmsdbg.h debug.h langhooks.h $(FUNCTION_H) $(TARGET_H)
  xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) toplev.h output.h dbxout.h \
!    $(GGC_H) function.h $(TARGET_H) debug.h gstab.h xcoff.h
  emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \
     $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \
*** gcc/function.c.0	2008-09-12 21:14:13.397871624 +0200
--- gcc/function.c	2008-09-12 21:24:13.660617816 +0200
*************** instantiate_decls (tree fndecl)
*** 1673,1678 ****
--- 1673,1683 ----
  	}
      }
  
+   /* Process the static chain if it exists.  */
+   decl = DECL_STRUCT_FUNCTION (fndecl)->static_chain_decl;
+   if (decl)
+     instantiate_decl_rtl (DECL_RTL (decl));
+ 
    /* Now process all variables defined in the function or its subblocks.  */
    instantiate_decls_1 (DECL_INITIAL (fndecl));
  }
*************** expand_function_start (tree subr)
*** 4298,4308 ****
    if (cfun->static_chain_decl)
      {
        tree parm = cfun->static_chain_decl;
!       rtx local = gen_reg_rtx (Pmode);
  
        set_decl_incoming_rtl (parm, static_chain_incoming_rtx, false);
        SET_DECL_RTL (parm, local);
-       mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));
  
        emit_move_insn (local, static_chain_incoming_rtx);
      }
--- 4303,4320 ----
    if (cfun->static_chain_decl)
      {
        tree parm = cfun->static_chain_decl;
!       rtx local;
! 
!       if (optimize)
! 	{
! 	  local = gen_reg_rtx (Pmode);
! 	  mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));
! 	}
!       else
! 	local = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);
  
        set_decl_incoming_rtl (parm, static_chain_incoming_rtx, false);
        SET_DECL_RTL (parm, local);
  
        emit_move_insn (local, static_chain_incoming_rtx);
      }
*** gcc/tree-nested.c.0	2008-09-12 17:54:08.001969216 +0200
--- gcc/tree-nested.c	2008-09-12 21:13:54.704713416 +0200
*************** struct nesting_info
*** 102,107 ****
--- 102,108 ----
    bool any_tramp_created;
    bool any_descr_created;
    bool reachable;
+   bool address_taken;
    char static_chain_added;
  };
  
*************** static struct nesting_info *reachable_qu
*** 917,923 ****
  /* Mark FNDECL as reachable if it is not already and add it to the queue.  */
  
  static void
! mark_reachable_function_1 (tree fndecl)
  {
    struct nesting_info *info;
    void **slot;
--- 918,924 ----
  /* Mark FNDECL as reachable if it is not already and add it to the queue.  */
  
  static void
! mark_reachable_function_1 (tree fndecl, bool address_taken)
  {
    struct nesting_info *info;
    void **slot;
*************** mark_reachable_function_1 (tree fndecl)
*** 932,937 ****
--- 933,941 ----
        info->next_reachable = reachable_queue;
        reachable_queue = info;
      }
+ 
+   if (address_taken)
+     info->address_taken = true;
  }
  
  /* Called via walk_function+walk_tree, mark the nested functions
*************** mark_reachable_functions_1 (tree *tp, in
*** 951,963 ****
      case ADDR_EXPR:
        decl = TREE_OPERAND (t, 0);
        if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))
! 	mark_reachable_function_1 (decl);
        break;
  
      case CALL_EXPR:
        decl = get_callee_fndecl (t);
        if (decl && decl_function_context (decl))
! 	mark_reachable_function_1 (decl);
  
        for (i = 3; i < VL_EXP_OPERAND_LENGTH (t); i++)
  	walk_tree (&TREE_OPERAND (t, i), mark_reachable_functions_1, wi, NULL);
--- 955,967 ----
      case ADDR_EXPR:
        decl = TREE_OPERAND (t, 0);
        if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))
! 	mark_reachable_function_1 (decl, true);
        break;
  
      case CALL_EXPR:
        decl = get_callee_fndecl (t);
        if (decl && decl_function_context (decl))
! 	mark_reachable_function_1 (decl, false);
  
        for (i = 3; i < VL_EXP_OPERAND_LENGTH (t); i++)
  	walk_tree (&TREE_OPERAND (t, i), mark_reachable_functions_1, wi, NULL);
*************** convert_nonlocal_reference (tree *tp, in
*** 1157,1164 ****
  	  tree x;
  	  wi->changed = true;
  
! 	  x = get_nonlocal_debug_decl (info, t);
! 	  if (!bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))
  	    {
  	      tree target_context = decl_function_context (t);
  	      struct nesting_info *i;
--- 1161,1169 ----
  	  tree x;
  	  wi->changed = true;
  
! 	  if (bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))
! 	    x = get_nonlocal_debug_decl (info, t);
! 	  else
  	    {
  	      tree target_context = decl_function_context (t);
  	      struct nesting_info *i;
*************** convert_local_reference (tree *tp, int *
*** 1480,1488 ****
  	    break;
  	  wi->changed = true;
  
! 	  x = get_local_debug_decl (info, t, field);
! 	  if (!bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))
! 	    x = get_frame_field (info, info->context, field, &wi->tsi);
  
  	  if (wi->val_only)
  	    {
--- 1485,1503 ----
  	    break;
  	  wi->changed = true;
  
! 	  if (bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))
! 	    x = get_local_debug_decl (info, t, field);
! 	  else
! 	    {
! 	      x = get_frame_field (info, info->context, field, &wi->tsi);
! 
! 	      /* Declare the transformation for debugging purposes.  */
! 	      if (!optimize && !DECL_HAS_VALUE_EXPR_P (t))
! 		{
! 		  SET_DECL_VALUE_EXPR (t, unshare_expr (x));
! 		  DECL_HAS_VALUE_EXPR_P (t) = 1;
! 	        }
! 	    }
  
  	  if (wi->val_only)
  	    {
*************** convert_all_function_calls (struct nesti
*** 2014,2019 ****
--- 2029,2045 ----
        walk_function (convert_tramp_reference, root);
        walk_function (convert_call_expr, root);
  
+       /* Always create a static chain if not optimizing, unless this could
+ 	 artificially cause a trampoline to be created or if the function
+ 	 really doesn't want one.  This makes it possible to reconstruct
+ 	 the static nesting tree at runtime and thus to resolve up-level
+ 	 references from within the debugger.  */
+       if (root->outer
+ 	  && !optimize
+ 	  && !root->address_taken
+ 	  && !DECL_NO_STATIC_CHAIN (root->context))
+ 	(void) get_chain_decl (root);
+ 
        /* If the function does not use a static chain, then remember that.  */
        if (root->outer && !root->chain_decl && !root->chain_field)
  	DECL_NO_STATIC_CHAIN (root->context) = 1;
*** gcc/dbxout.c.0	2008-09-13 13:29:42.229178016 +0200
--- gcc/dbxout.c	2008-09-13 13:32:13.225223128 +0200
*************** dbxout_class_name_qualifiers (tree decl)
*** 2330,2340 ****
  
  /* This is a specialized subset of expand_expr for use by dbxout_symbol in
     evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that
!    havn't been expanded, or if the expression is getting so complex we won't
!    be able to represent it in stabs anyway.  Returns NULL on failure.  */
  
  static rtx
! dbxout_expand_expr (tree expr)
  {
    switch (TREE_CODE (expr))
      {
--- 2330,2343 ----
  
  /* This is a specialized subset of expand_expr for use by dbxout_symbol in
     evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that
!    haven't been expanded, or if the expression is getting so complex we won't
!    be able to represent it in stabs anyway.
! 
!    Return the RTX for EXPR and set TYPE to the new type associated with it
!    if it is not that of EXPR.  Return NULL on failure.  */
  
  static rtx
! dbxout_expand_expr (tree expr, tree *type)
  {
    switch (TREE_CODE (expr))
      {
*************** dbxout_expand_expr (tree expr)
*** 2350,2356 ****
  
      case PARM_DECL:
        if (DECL_HAS_VALUE_EXPR_P (expr))
! 	return dbxout_expand_expr (DECL_VALUE_EXPR (expr));
        /* FALLTHRU */
  
      case CONST_DECL:
--- 2353,2359 ----
  
      case PARM_DECL:
        if (DECL_HAS_VALUE_EXPR_P (expr))
! 	return dbxout_expand_expr (DECL_VALUE_EXPR (expr), type);
        /* FALLTHRU */
  
      case CONST_DECL:
*************** dbxout_expand_expr (tree expr)
*** 2374,2380 ****
  	tem = get_inner_reference (expr, &bitsize, &bitpos, &offset,
  				   &mode, &unsignedp, &volatilep, true);
  
! 	x = dbxout_expand_expr (tem);
  	if (x == NULL || !MEM_P (x))
  	  return NULL;
  	if (offset != NULL)
--- 2377,2383 ----
  	tem = get_inner_reference (expr, &bitsize, &bitpos, &offset,
  				   &mode, &unsignedp, &volatilep, true);
  
! 	x = dbxout_expand_expr (tem, type);
  	if (x == NULL || !MEM_P (x))
  	  return NULL;
  	if (offset != NULL)
*************** dbxout_expand_expr (tree expr)
*** 2389,2394 ****
--- 2392,2403 ----
  	return x;
        }
  
+     case INDIRECT_REF:
+       /* The real object is the underlying pointer.  */
+       *type = make_node (REFERENCE_TYPE);
+       TREE_TYPE (*type) = TREE_TYPE (expr);
+       return dbxout_expand_expr (TREE_OPERAND (expr, 0), type);
+       
      default:
        return NULL;
      }
*************** dbxout_symbol (tree decl, int local ATTR
*** 2797,2803 ****
  	}
        /* else it is something we handle like a normal variable.  */
  
!       decl_rtl = dbxout_expand_expr (decl);
        if (!decl_rtl)
  	DBXOUT_DECR_NESTING_AND_RETURN (0);
  
--- 2806,2812 ----
  	}
        /* else it is something we handle like a normal variable.  */
  
!       decl_rtl = dbxout_expand_expr (decl, &type);
        if (!decl_rtl)
  	DBXOUT_DECR_NESTING_AND_RETURN (0);
  
*** gcc/dbxout.c.0	2008-09-13 13:35:11.733085808 +0200
--- gcc/dbxout.c	2008-09-13 14:26:44.224955584 +0200
*************** dbxout_reg_parms (tree parms)
*** 3344,3353 ****
        {
  	/* Report parms that live in registers during the function
  	   but were passed in memory.  */
! 	if (REG_P (DECL_RTL (parms))
! 	    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
! 	  dbxout_symbol_location (parms, TREE_TYPE (parms),
! 				  0, DECL_RTL (parms));
  	else if (GET_CODE (DECL_RTL (parms)) == CONCAT)
  	  dbxout_symbol_location (parms, TREE_TYPE (parms),
  				  0, DECL_RTL (parms));
--- 3344,3381 ----
        {
  	/* Report parms that live in registers during the function
  	   but were passed in memory.  */
! 	if (REG_P (DECL_RTL (parms)))
! 	  {
! 	    if (REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
! 	      dbxout_symbol_location (parms, TREE_TYPE (parms),
! 				    0, DECL_RTL (parms));
! 	    else
! 	      {
! 		/* Here, we are looking at where the parameter lives. This is
! 	           normally indicated by DECL_RTL. However, when optimization
! 		   is enabled, this might contain a pseudo-reg (this is the
! 	           case here, see test above.
! 	           In this case, we can use DECL_INCOMING_RTL as the source
! 	           for this information, in certain limited cases. For a full
! 	           explanations of the heuristics used, see file dwarf2out.c,
! 	           function rtl_for_decl_location.  */
! 
! 	        tree declared_type = TYPE_MAIN_VARIANT (TREE_TYPE (parms));
! 	        tree passed_type = TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parms));
! 
! 	        if (declared_type == passed_type)
! 	          dbxout_symbol_location (parms, TREE_TYPE (parms),
! 	                                  0, DECL_INCOMING_RTL (parms));
! 	        else if (!BYTES_BIG_ENDIAN
! 	                 && (TREE_CODE (declared_type) == INTEGER_TYPE
! 	                     || TREE_CODE (declared_type) == ENUMERAL_TYPE
! 	                     || TREE_CODE (declared_type) == BOOLEAN_TYPE)
! 	                 && GET_MODE_SIZE (TYPE_MODE (declared_type))
! 	                      <= GET_MODE_SIZE (TYPE_MODE (passed_type)))
! 	          dbxout_symbol_location (parms, TREE_TYPE (parms),
!                                           0, DECL_INCOMING_RTL (parms));
! 	      }
! 	  }
  	else if (GET_CODE (DECL_RTL (parms)) == CONCAT)
  	  dbxout_symbol_location (parms, TREE_TYPE (parms),
  				  0, DECL_RTL (parms));
*** gcc/dbxout.c.0	2008-09-13 14:37:27.931097376 +0200
--- gcc/dbxout.c	2008-09-13 14:37:32.526398784 +0200
*************** dbxout_symbol_location (tree decl, tree 
*** 3021,3027 ****
  	 cases we're forced to lie to debuggers and tell them that
  	 this variable was itself `static'.  */
        code = N_LCSYM;
!       letter = 'V';
        addr = XEXP (XEXP (home, 0), 0);
      }
    else if (GET_CODE (home) == CONCAT)
--- 3021,3027 ----
  	 cases we're forced to lie to debuggers and tell them that
  	 this variable was itself `static'.  */
        code = N_LCSYM;
!       letter = decl_function_context (decl) ? 'V' : 'S';
        addr = XEXP (XEXP (home, 0), 0);
      }
    else if (GET_CODE (home) == CONCAT)
*************** dbxout_symbol_location (tree decl, tree 
*** 3060,3066 ****
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
    dbxout_begin_complex_stabs_noforcetext ();
--- 3060,3069 ----
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   /* A null address denotes a pure debug entity associated
!      with no real symbol so keep using the current block.  */
!   if (addr != const0_rtx)
!     DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
    dbxout_begin_complex_stabs_noforcetext ();
*************** dbxout_symbol_location (tree decl, tree 
*** 3069,3075 ****
    dbxout_finish_complex_stabs (decl, code, addr, 0, number);
  
  #ifdef DBX_STATIC_BLOCK_END
!   DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
  }
--- 3072,3080 ----
    dbxout_finish_complex_stabs (decl, code, addr, 0, number);
  
  #ifdef DBX_STATIC_BLOCK_END
!   /* See comment just above.  */
!   if (addr != const0_rtx)
!     DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
  }
*** gcc/dbxout.c.0	2008-09-13 14:50:19.719767664 +0200
--- gcc/dbxout.c	2008-09-13 14:50:24.722007208 +0200
*************** dbxout_parms (tree parms)
*** 3307,3312 ****
--- 3307,3314 ----
  		&& GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))) < UNITS_PER_WORD)
  	      number += (GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))
  			 - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))));
+ 
+ 	    number = DEBUGGER_ARG_OFFSET (number,  XEXP (DECL_RTL (parms), 0));
  	  }
  	else
  	  /* ??? We don't know how to represent this argument.  */
*** gcc/dbxout.c.0	2008-09-13 15:17:48.552107048 +0200
--- gcc/dbxout.c	2008-09-13 15:28:04.233509248 +0200
*************** dbxout_function_decl (tree decl)
*** 1336,1342 ****
  static void
  dbxout_global_decl (tree decl)
  {
!   if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))
      {
        int saved_tree_used = TREE_USED (decl);
        TREE_USED (decl) = 1;
--- 1336,1348 ----
  static void
  dbxout_global_decl (tree decl)
  {
!   if (TREE_CODE (decl) == VAR_DECL
!       && !DECL_EXTERNAL (decl)
!       /* Do not produce debug information for local static variables
! 	 twice.  Note that it's done the other way around for DWARF-2
! 	 (they are not emitted within their scope) but we need proper
! 	 scoping for STABS.  */
!       && !decl_function_context (decl))
      {
        int saved_tree_used = TREE_USED (decl);
        TREE_USED (decl) = 1;
*** gcc/rtl.h.0	2008-09-15 13:54:41.000000000 +0200
--- gcc/rtl.h	2008-09-15 07:05:00.000000000 +0200
*************** extern int insn_line (const_rtx);
*** 1623,1628 ****
--- 1623,1629 ----
  extern const char * insn_file (const_rtx);
  extern int locator_line (int);
  extern const char * locator_file (int);
+ extern bool non_final_source_line (const_rtx);
  extern int prologue_locator, epilogue_locator;
  
  /* In jump.c */
*** gcc/cfglayout.c.0	2008-10-17 09:32:05.000000000 +0200
--- gcc/cfglayout.c	2008-10-17 09:32:20.000000000 +0200
*************** insn_file (const_rtx insn)
*** 551,556 ****
--- 551,582 ----
    return locator_file (INSN_LOCATOR (insn));
  }
  
+ /* Return true if the source line of INSN is not the final one.  */
+ 
+ bool
+ non_final_source_line (const_rtx insn)
+ {
+   /* Skip lexical blocks and EH region markers, if any.  */
+   while (NOTE_P (insn)
+ 	 && (NOTE_KIND (insn) == NOTE_INSN_BLOCK_BEG
+ 	     || NOTE_KIND (insn) == NOTE_INSN_EH_REGION_BEG))
+     insn = NEXT_INSN (insn);
+ 
+   if (!INSN_P (insn))
+    return false;
+ 
+ #ifdef USE_MAPPED_LOCATION
+   if (locator_location (INSN_LOCATOR (insn)) == cfun->function_end_locus)
+     return false;
+ #else
+   if (insn_line (insn) == cfun->function_end_locus.line
+       && !strcmp (insn_file (insn), cfun->function_end_locus.file))
+     return false;
+ #endif
+ 
+   return true;
+ }
+ 
  /* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based
     on the scope tree and the newly reordered instructions.  */
  
*** gcc/final.c.0	2008-09-15 13:54:41.000000000 +0200
--- gcc/final.c	2008-09-15 13:54:45.000000000 +0200
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1800,1806 ****
  	  if ((*seen & (SEEN_EMITTED | SEEN_BB)) == SEEN_BB)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_BB;
--- 1800,1808 ----
  	  if ((*seen & (SEEN_EMITTED | SEEN_BB)) == SEEN_BB)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      /* Do not force a source line if there is already one.  */
! 	      if (!non_final_source_line (NEXT_INSN (insn)))
! 		force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_BB;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1824,1830 ****
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
--- 1826,1834 ----
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      /* Do not force a source line if there is already one.  */
! 	      if (!non_final_source_line (NEXT_INSN (insn)))
! 		force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1842,1848 ****
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
--- 1846,1854 ----
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      /* Do not force a source line if there is already one.  */
! 	      if (!non_final_source_line (NEXT_INSN (insn)))
! 		force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
*** gcc/config/mips/iris6.h.ori	Mon Sep 15 15:38:17 2008
--- gcc/config/mips/iris6.h	Mon Sep 15 15:39:11 2008
*************** along with GCC; see the file COPYING3.  
*** 73,79 ****
       anyway.  However, no-one has volunteered to do this yet.  */
  
  #define IRIX_SUBTARGET_LINK_SPEC \
!   "%{w} -_SYSTYPE_SVR4 -woff 131 \
     %{shared:-hidden_symbol __dso_handle} \
     %{mabi=32: -32}%{mabi=n32: -n32}%{mabi=64: -64}%{!mabi*: -n32}"
  #endif
--- 73,79 ----
       anyway.  However, no-one has volunteered to do this yet.  */
  
  #define IRIX_SUBTARGET_LINK_SPEC \
!   "%{w} -_SYSTYPE_SVR4 -w \
     %{shared:-hidden_symbol __dso_handle} \
     %{mabi=32: -32}%{mabi=n32: -n32}%{mabi=64: -64}%{!mabi*: -n32}"
  #endif
*** gcc/config/mips/mips.h.0	2008-07-13 18:57:06.000000000 +0200
--- gcc/config/mips/mips.h	2008-09-15 21:56:21.000000000 +0200
*************** enum mips_code_readable_setting {
*** 1169,1174 ****
--- 1169,1175 ----
  
  /* For MIPS, width of a floating point register.  */
  #define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)
+ #define WIDEST_HARDWARE_FP_SIZE 64
  
  /* The number of consecutive floating-point registers needed to store the
     largest format supported by the FPU.  */
*** gcc/dwarf2out.c.0	2008-09-16 11:06:39.000000000 +0200
--- gcc/dwarf2out.c	2008-09-16 11:08:04.000000000 +0200
*************** add_type_attribute (dw_die_ref object_di
*** 11807,11817 ****
    enum tree_code code  = TREE_CODE (type);
    dw_die_ref type_die  = NULL;
  
!   /* ??? If this type is an unnamed subrange type of an integral, floating-point
       or fixed-point type, use the inner type.  This is because we have no
       support for unnamed types in base_type_die.  This can happen if this is
       an Ada subrange type.  Correct solution is emit a subrange type die.  */
!   if ((code == INTEGER_TYPE || code == REAL_TYPE || code == FIXED_POINT_TYPE)
        && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)
      type = TREE_TYPE (type), code = TREE_CODE (type);
  
--- 11807,11817 ----
    enum tree_code code  = TREE_CODE (type);
    dw_die_ref type_die  = NULL;
  
!   /* ??? If this type is an unnamed subrange type of a floating-point
       or fixed-point type, use the inner type.  This is because we have no
       support for unnamed types in base_type_die.  This can happen if this is
       an Ada subrange type.  Correct solution is emit a subrange type die.  */
!   if ((code == REAL_TYPE || code == FIXED_POINT_TYPE)
        && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)
      type = TREE_TYPE (type), code = TREE_CODE (type);
  
*** gcc/config/i386/freebsd.h.0	2008-09-20 09:56:10.000000000 +0200
--- gcc/config/i386/freebsd.h	2008-09-20 09:56:31.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 141,143 ****
--- 141,145 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ #define MD_UNWIND_SUPPORT "config/i386/freebsd-unwind.h"
*** /dev/null	2008-06-03 13:57:23.000000000 +0200
--- gcc/config/i386/freebsd-unwind.h	2008-12-10 13:20:24.907465894 +0100
***************
*** 0 ****
--- 1,103 ----
+ /* DWARF2 EH unwinding support for x86-freebsd
+    Copyright (C) 2004, 2005, 2006, 2007, 2008
+    Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs. */
+ 
+ #include <signal.h>
+ #include <sys/ucontext.h>
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR x86_freebsd_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ x86_freebsd_fallback_frame_state
+ (struct _Unwind_Context *context, _Unwind_FrameState *fs)
+ {
+     unsigned char *pc_ = context->ra;
+     struct sigcontext *sc_;
+     long new_cfa_;
+ 
+     /* Standard sigcode */
+     /*  movl $SYS_sigreturn, %eax; pushl %eax; int $0x80 */
+     if (*(unsigned int *)(pc_+17) == 0x0001a1b8
+ 	&& *(unsigned char *)(pc_+22) == 0x50
+ 	&& *(unsigned short *)(pc_+23) == 0x80cd) {
+       sc_ = context->cfa + 32;
+ 
+     /* libpthread _thr_sig_handler */
+     /* if ((sa_flags & SA_SIGINFO) != 0 || ... )
+                         (*(sigfunc))(sig, info, ucp); */
+ 
+     } else if (*(unsigned int *)(pc_-27) == 0xff6885f6
+       && *(unsigned int *)(pc_-23) == 0x7540ffff
+       && *(unsigned short *)(pc_) == 0xc483
+       && *(unsigned char *)(pc_+2) == 0x10) {
+       sc_ = context->cfa + 224;
+ 
+     /* libpthread handle_signal */
+     /* if ((shi->sa_flags & SA_SIGINFO) != 0 || ... )
+                         (*(shi->sigfunc))(shi->sig, shi->info, shi->ucp); */
+ 
+     } else if (*(unsigned int *)(pc_-26) == 0x400446f6
+       && *(unsigned short *)(pc_-2) == 0x16ff
+       && *(unsigned short *)(pc_) == 0xc483
+       && *(unsigned char *)(pc_+2) == 0x10) {
+       sc_ = context->cfa + 544;
+ 
+     /* No match */
+     } else {
+       return _URC_END_OF_STACK;
+     }
+ 
+     new_cfa_ = sc_->sc_esp;
+     fs->regs.cfa_how = CFA_REG_OFFSET;
+     fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+     fs->regs.cfa_offset = new_cfa_ - (long) context->cfa;
+ 
+     /* The SVR4 register numbering macros aren't usable in libgcc.  */
+     fs->regs.reg[0].how = REG_SAVED_OFFSET;
+     fs->regs.reg[0].loc.offset = (long)&sc_->sc_eax - new_cfa_;
+     fs->regs.reg[3].how = REG_SAVED_OFFSET;
+     fs->regs.reg[3].loc.offset = (long)&sc_->sc_ebx - new_cfa_;
+     fs->regs.reg[1].how = REG_SAVED_OFFSET;
+     fs->regs.reg[1].loc.offset = (long)&sc_->sc_ecx - new_cfa_;
+     fs->regs.reg[2].how = REG_SAVED_OFFSET;
+     fs->regs.reg[2].loc.offset = (long)&sc_->sc_edx - new_cfa_;
+     fs->regs.reg[6].how = REG_SAVED_OFFSET;
+     fs->regs.reg[6].loc.offset = (long)&sc_->sc_esi - new_cfa_;
+     fs->regs.reg[7].how = REG_SAVED_OFFSET;
+     fs->regs.reg[7].loc.offset = (long)&sc_->sc_edi - new_cfa_;
+     fs->regs.reg[5].how = REG_SAVED_OFFSET;
+     fs->regs.reg[5].loc.offset = (long)&sc_->sc_ebp - new_cfa_;
+     fs->regs.reg[8].how = REG_SAVED_OFFSET;
+     fs->regs.reg[8].loc.offset = (long)&sc_->sc_eip - new_cfa_;
+     fs->retaddr_column = 8;
+     fs->signal_frame = 1;
+     return _URC_NO_REASON;
+ }
*** gcc/varasm.c.0	2008-09-17 10:20:57.000000000 +0200
--- gcc/varasm.c	2008-09-17 22:33:39.000000000 +0200
*************** initializer_constant_valid_p (tree value
*** 4217,4236 ****
  	return op0;
        }
  
-     case VIEW_CONVERT_EXPR:
      case NON_LVALUE_EXPR:
        return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
  
      case CONVERT_EXPR:
      case NOP_EXPR:
        {
! 	tree src;
! 	tree src_type;
! 	tree dest_type;
! 
! 	src = TREE_OPERAND (value, 0);
! 	src_type = TREE_TYPE (src);
! 	dest_type = TREE_TYPE (value);
  
  	/* Allow conversions between pointer types, floating-point
  	   types, and offset types.  */
--- 4217,4253 ----
  	return op0;
        }
  
      case NON_LVALUE_EXPR:
        return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
  
+     case VIEW_CONVERT_EXPR:
+       {
+ 	tree src = TREE_OPERAND (value, 0);
+ 	tree src_type = TREE_TYPE (src);
+ 	tree dest_type = TREE_TYPE (value);
+ 
+ 	/* Allow view-conversions from aggregate to non-aggregate type only
+ 	   if the bit pattern is fully preserved afterwards; otherwise, the
+ 	   RTL expander won't be able to apply a subsequent transformation
+ 	   to the underlying constructor.  */
+ 	if (AGGREGATE_TYPE_P (src_type) && !AGGREGATE_TYPE_P (dest_type))
+ 	  {
+ 	    if (TYPE_MODE (endtype) == TYPE_MODE (dest_type))
+ 	      return initializer_constant_valid_p (src, endtype);
+ 	    else
+ 	      return NULL_TREE;
+ 	  }
+ 
+ 	/* Allow all other kinds of view-conversion.  */
+ 	return initializer_constant_valid_p (src, endtype);
+       }
+ 
      case CONVERT_EXPR:
      case NOP_EXPR:
        {
! 	tree src = TREE_OPERAND (value, 0);
! 	tree src_type = TREE_TYPE (src);
! 	tree dest_type = TREE_TYPE (value);
  
  	/* Allow conversions between pointer types, floating-point
  	   types, and offset types.  */
*** gcc/expr.c.ori	Wed Sep 17 15:14:09 2008
--- gcc/expr.c	Wed Sep 17 15:21:01 2008
*************** handled_component_p (const_tree t)
*** 6207,6212 ****
--- 6207,6250 ----
        return 0;
      }
  }
+ 
+ /* Alignment in bits the TARGET of an assignment may be assumed to have.  */
+ 
+ static unsigned HOST_WIDE_INT
+ target_align (const_tree target)
+ {
+   /* We might have a chain of nested references with intermediate misaligning
+      bitfields components, so need to recurse to find out.  */
+ 
+   unsigned HOST_WIDE_INT this_align, outer_align;
+ 
+   switch (TREE_CODE (target))
+     {
+     case BIT_FIELD_REF:
+     case COMPONENT_REF:
+       this_align = DECL_ALIGN (TREE_OPERAND (target, 1));
+       outer_align = target_align (TREE_OPERAND (target, 0));
+       return MIN (this_align, outer_align);
+ 
+     case ARRAY_REF:
+     case ARRAY_RANGE_REF:
+       this_align = TYPE_ALIGN (TREE_TYPE (target));
+       outer_align = target_align (TREE_OPERAND (target, 0));
+       return MIN (this_align, outer_align);
+ 
+     case NON_LVALUE_EXPR:
+     case VIEW_CONVERT_EXPR:
+     case NOP_EXPR:
+     case CONVERT_EXPR:
+       this_align = TYPE_ALIGN (TREE_TYPE (target));
+       outer_align = target_align (TREE_OPERAND (target, 0));
+       return MAX (this_align, outer_align);
+ 
+     default:
+       return TYPE_ALIGN (TREE_TYPE (target));
+     }
+ }
+ 
  
  /* Given an rtx VALUE that may contain additions and multiplications, return
     an equivalent value that just refers to a register, memory, or constant.
*************** highest_pow2_factor (const_tree exp)
*** 6656,6669 ****
  static unsigned HOST_WIDE_INT
  highest_pow2_factor_for_target (const_tree target, const_tree exp)
  {
!   unsigned HOST_WIDE_INT target_align, factor;
! 
!   factor = highest_pow2_factor (exp);
!   if (TREE_CODE (target) == COMPONENT_REF)
!     target_align = DECL_ALIGN_UNIT (TREE_OPERAND (target, 1));
!   else
!     target_align = TYPE_ALIGN_UNIT (TREE_TYPE (target));
!   return MAX (factor, target_align);
  }
  
  /* Return &VAR expression for emulated thread local VAR.  */
--- 6694,6703 ----
  static unsigned HOST_WIDE_INT
  highest_pow2_factor_for_target (const_tree target, const_tree exp)
  {
!   unsigned HOST_WIDE_INT talign = target_align (target) / BITS_PER_UNIT;
!   unsigned HOST_WIDE_INT factor = highest_pow2_factor (exp);
!   
!   return MAX (factor, talign);
  }
  
  /* Return &VAR expression for emulated thread local VAR.  */
*** gcc/expr.c.ori	Wed Sep 17 23:40:39 2008
--- gcc/expr.c	Wed Sep 17 23:40:44 2008
*************** target_align (const_tree target)
*** 6221,6226 ****
--- 6221,6229 ----
    switch (TREE_CODE (target))
      {
      case BIT_FIELD_REF:
+       /* ??? We could probably do better from the bit position here.  */
+       return 1;
+ 
      case COMPONENT_REF:
        this_align = DECL_ALIGN (TREE_OPERAND (target, 1));
        outer_align = target_align (TREE_OPERAND (target, 0));
*** gcc/config/vxworks.h.orig	Tue Sep 16 20:25:34 2008
--- gcc/config/vxworks.h	Tue Sep 16 20:24:34 2008
***************
*** 42,48 ****
   "%{!nostdinc:					\
      %{isystem*} -idirafter			\
      %{mrtp: %:getenv(WIND_USR /h)		\
!       ;:    %:getenv(WIND_BASE /target/h)}}"
  
  /* The references to __init and __fini will be satisfied by
     libc_internal.a.  */
--- 42,50 ----
   "%{!nostdinc:					\
      %{isystem*} -idirafter			\
      %{mrtp: %:getenv(WIND_USR /h)		\
!       ;:    %:getenv(WIND_BASE /target/h)}}	\
!   %{mrtp: -D__RTP__=1}				\
!   %{!mrtp: -D_WRS_KERNEL=1}"
  
  /* The references to __init and __fini will be satisfied by
     libc_internal.a.  */
*** gcc/profile.c.ori	Thu Sep 18 11:57:14 2008
--- gcc/profile.c	Thu Sep 18 13:02:20 2008
*************** branch_prob (void)
*** 1005,1019 ****
  	      if (EXPR_HAS_LOCATION (stmt))
  		output_location (EXPR_FILENAME (stmt), EXPR_LINENO (stmt),
  				 &offset, bb);
  	      /* Take into account modify statements nested in return
! 		 produced by C++ NRV transformation.  */
! 	      if (TREE_CODE (stmt) == RETURN_EXPR
! 		  && TREE_OPERAND (stmt, 0)
! 		  && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR
! 		  && EXPR_HAS_LOCATION (TREE_OPERAND (stmt, 0)))
! 		output_location (EXPR_FILENAME (TREE_OPERAND (stmt, 0)),
! 				 EXPR_LINENO (TREE_OPERAND (stmt, 0)),
! 				 &offset, bb);
  	    }
  
  	  /* Notice GOTO expressions we eliminated while constructing the
--- 1005,1045 ----
  	      if (EXPR_HAS_LOCATION (stmt))
  		output_location (EXPR_FILENAME (stmt), EXPR_LINENO (stmt),
  				 &offset, bb);
+ 	      
  	      /* Take into account modify statements nested in return
! 		 produced by C++ NRV transformation, as well as possible
! 		 location information attached to the source of any modify
! 		 statement.  */
! 	      {
! 		/* Candidate modify statement and rhs.  */
! 		tree modstmt, rhs;
! 
! 		if (TREE_CODE (stmt) == RETURN_EXPR && TREE_OPERAND (stmt, 0))
! 		  modstmt = TREE_OPERAND (stmt, 0);
! 		else
! 		  modstmt = stmt;
! 		
! 		if (TREE_CODE (modstmt) == MODIFY_EXPR)
! 		  rhs = TREE_OPERAND (modstmt, 1);
! 		else if (TREE_CODE (modstmt) == GIMPLE_MODIFY_STMT)
! 		  rhs = GIMPLE_STMT_OPERAND (modstmt, 1);
! 		else
! 		  modstmt = 0;
! 
! 		if (modstmt != 0)
! 		  {
! 		    if (modstmt != stmt && EXPR_HAS_LOCATION (modstmt))
! 		      output_location (EXPR_FILENAME (modstmt),
! 				       EXPR_LINENO (modstmt),
! 				       &offset, bb);
! 
! 		    if (EXPR_HAS_LOCATION (rhs))
! 		      output_location (EXPR_FILENAME (rhs), 
! 				       EXPR_LINENO (rhs),
! 				       &offset, bb);
! 		  }
! 	      }
! 
  	    }
  
  	  /* Notice GOTO expressions we eliminated while constructing the
*** gcc/gcov.c.ori	Fri Sep 19 19:02:30 2008
--- gcc/gcov.c	Fri Sep 19 19:04:29 2008
*************** static int output_branch_count (FILE *, 
*** 349,354 ****
--- 349,356 ----
  static void output_lines (FILE *, const source_t *);
  static char *make_gcov_file_name (const char *, const char *);
  static void release_structures (void);
+ static char *l_strchr (const char *);
+ static char *l_strrchr (const char *);
  extern int main (int, char **);
  
  int
*************** main (int argc, char **argv)
*** 381,386 ****
--- 383,417 ----
    return 0;
  }
  
+ static char *
+ l_strchr (const char *file_name)
+ {
+   char *p = (char *)file_name;
+ 
+   while (!IS_DIR_SEPARATOR (*p))
+     {
+       if (*p == '\0')
+ 	return NULL;
+       p++;
+     }
+   return p;
+ }
+ 
+ static char *
+ l_strrchr (const char *file_name)
+ {
+   char *p = (char *)&file_name [strlen (file_name) - 1];
+ 
+   while (!IS_DIR_SEPARATOR (*p))
+     {
+       p--;
+ 
+       if (p < file_name)
+ 	return NULL;
+     }
+   return p;
+ }
+ 
  static void
  fnotice (FILE *file, const char *cmsgid, ...)
  {
*************** create_file_names (const char *file_name
*** 661,667 ****
  
        base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);
        strcat (name, object_directory);
!       if (base && name[strlen (name) - 1] != '/')
  	strcat (name, "/");
      }
    else
--- 692,698 ----
  
        base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);
        strcat (name, object_directory);
!       if (base && (! IS_DIR_SEPARATOR (name[strlen (name) - 1])))
  	strcat (name, "/");
      }
    else
*************** create_file_names (const char *file_name
*** 674,680 ****
    if (base)
      {
        /* Append source file name.  */
!       cptr = strrchr (file_name, '/');
        strcat (name, cptr ? cptr + 1 : file_name);
      }
  
--- 705,711 ----
    if (base)
      {
        /* Append source file name.  */
!       cptr = l_strrchr (file_name);
        strcat (name, cptr ? cptr + 1 : file_name);
      }
  
*************** make_gcov_file_name (const char *input_n
*** 1490,1496 ****
        name = XNEWVEC (char, strlen (src_name) + strlen (input_name) + 10);
        name[0] = 0;
        /* Generate the input filename part.  */
!       cptr = flag_preserve_paths ? NULL : strrchr (input_name, '/');
        strcat (name, cptr ? cptr + 1 : input_name);
        strcat (name, "##");
      }
--- 1521,1527 ----
        name = XNEWVEC (char, strlen (src_name) + strlen (input_name) + 10);
        name[0] = 0;
        /* Generate the input filename part.  */
!       cptr = flag_preserve_paths ? NULL : l_strrchr (input_name);
        strcat (name, cptr ? cptr + 1 : input_name);
        strcat (name, "##");
      }
*************** make_gcov_file_name (const char *input_n
*** 1501,1507 ****
      }
  
    /* Generate the source filename part.  */
!   cptr = flag_preserve_paths ? NULL : strrchr (src_name, '/');
    strcat (name, cptr ? cptr + 1 : src_name);
  
    if (flag_preserve_paths)
--- 1532,1538 ----
      }
  
    /* Generate the source filename part.  */
!   cptr = flag_preserve_paths ? NULL : l_strrchr (src_name);
    strcat (name, cptr ? cptr + 1 : src_name);
  
    if (flag_preserve_paths)
*************** make_gcov_file_name (const char *input_n
*** 1509,1515 ****
        /* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */
        char *prev;
  
!       for (cptr = name; (cptr = strchr ((prev = cptr), '/'));)
  	{
  	  unsigned shift = 0;
  
--- 1540,1546 ----
        /* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */
        char *prev;
  
!       for (cptr = name; (cptr = l_strchr ((prev = cptr)));)
  	{
  	  unsigned shift = 0;
  
*** configure.orig	Mon Sep 22 21:47:44 2008
--- configure	Mon Sep 22 21:48:46 2008
***************
*** 2576,2581 ****
--- 2576,2584 ----
      ;;
    sparc-*-solaris* | sparc64-*-solaris* | sparcv9-*-solaris*)
      ;;
+   erc32-elf-* | leon-elf-*)
+     noconfigdirs="$noconfigdirs ${libgcj}"
+     ;;
    spu-*-*)
      skipdirs="target-libssp"
      ;;
*** config.sub.orig	Mon Sep 22 21:48:59 2008
--- config.sub	Mon Sep 22 21:49:33 2008
***************
*** 245,250 ****
--- 245,251 ----
  	| bfin \
  	| c4x | clipper \
  	| d10v | d30v | dlx | dsp16xx \
+ 	| erc32 | leon \
  	| fido | fr30 | frv \
  	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
  	| i370 | i860 | i960 | ia64 \
*** gcc/config.gcc.orig	Mon Sep 22 21:49:59 2008
--- gcc/config.gcc	Mon Sep 22 22:05:24 2008
***************
*** 361,366 ****
--- 361,369 ----
  sparc*-*-*)
  	cpu_type=sparc
  	;;
+ erc32-*-* | leon-*-*)
+         cpu_type=sparc
+         ;;
  spu*-*-*)
  	cpu_type=spu
  	need_64bit_hwint=yes
***************
*** 2495,2500 ****
--- 2498,2515 ----
  	c_target_objs="${c_target_objs} spu-c.o"
  	cxx_target_objs="${cxx_target_objs} spu-c.o"
  	;;
+ erc32-*-elf*)
+         tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/erc32.h"
+         tmake_file="sparc/t-elf sparc/t-crtfm"
+         extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+         use_fixproto=yes
+         ;;
+ leon-*-elf*)
+         tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/leon.h"
+         tmake_file="sparc/t-elf sparc/t-crtfm"
+         extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+         use_fixproto=yes
+         ;;
  strongarm-*-elf*)
  	tm_file="arm/strongarm-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
  	tmake_file="arm/t-arm arm/t-strongarm-elf"
***************
*** 2682,2687 ****
--- 2697,2705 ----
      i386-*-*)
        with_cpu=i386
        ;;
+     erc32-*-*)
+       with_cpu=v7
+       ;;
      i486-*-*)
        with_cpu=i486
        ;;
***************
*** 2806,2811 ****
--- 2824,2832 ----
      mips*-*-vxworks)
        with_arch=mips2
        ;;
+     leon-*-*)
+       with_cpu=v8
+       ;;
      sparc*-*-*)
        with_cpu="`echo ${target} | sed 's/-.*$//'`"
        ;;
***************
*** 2941,2946 ****
--- 2962,2993 ----
  			echo "Warning: --with-arch overrides --with-cpu=$with_cpu" 1>&2
  		fi
  		;;
+         erc32-*-*)
+                 supported_defaults="cpu float tune"
+ 
+                 for which in cpu tune; do
+                         eval "val=\$with_$which"
+                         case ${val} in
+                         "" | sparc | v7 | cypress)
+                                 # OK
+                                 ;;
+                         *)
+                                 echo "Unknown cpu used in --with-$which=$val" 1>&2
+                                 exit 1
+                                 ;;
+                         esac
+                 done
+ 
+                 case ${with_float} in
+                 "" | soft | hard)
+                         # OK
+                         ;;
+                 *)
+                         echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+                         exit 1
+                         ;;
+                 esac
+                 ;;
  
  	fr*-*-*linux*)
  		supported_defaults=cpu
***************
*** 2953,2959 ****
  			;;
  		esac
  		;;
! 
  	fido-*-* | m680[012]0-*-* | m68k*-*-*)
  		supported_defaults="arch cpu"
  		case "$with_arch" in
--- 3000,3032 ----
  			;;
  		esac
  		;;
!         leon-*-*)
!                 supported_defaults="cpu float tune"
!  
!                 for which in cpu tune; do
!                         eval "val=\$with_$which"
!                         case ${val} in
!                         "" | sparc | v7 | cypress | v8)
!                                 # OK
!                                 ;;
!                         *)
!                                 echo "Unknown cpu used in --with-$which=$val" 1>&2
!                                 exit 1
!                                 ;;
!                         esac
!                 done
!  
!                 case ${with_float} in
!                 "" | soft | hard)
!                         # OK
!                         ;;
!                 *)
!                         echo "Unknown floating point type used in --with-float=$with_float" 1>&2
!                         exit 1
!                         ;;
!                 esac
!                 ;;
!  
  	fido-*-* | m680[012]0-*-* | m68k*-*-*)
  		supported_defaults="arch cpu"
  		case "$with_arch" in
***************
*** 3273,3278 ****
--- 3346,3364 ----
  			target_cpu_default2=TARGET_CPU_$target_cpu_cname
  		fi
  		;;
+         erc32-*-*)
+                 with_cpu=cypress
+ 
+                 # The SPARC port checks this value at compile-time.
+                 target_cpu_default2="TARGET_CPU_sparc"
+                 ;;
+ 
+         leon-*-*)
+                 with_cpu=v8
+ 
+                 # The SPARC port checks this value at compile-time.
+                 target_cpu_default2="TARGET_CPU_$with_cpu"
+                 ;;
  
  	hppa*-*-* | parisc*-*-*)
  		target_cpu_default2="MASK_BIG_SWITCH"
*** gcc/config/sparc/erc32.h.orig	Mon Sep 22 22:06:41 2008
--- gcc/config/sparc/erc32.h	Mon Sep 22 22:06:21 2008
***************
*** 0 ****
--- 1,57 ----
+ /* Definitions for an ERC32 machine running in a bare board
+    configuration using the ELF object format.
+    Copyright (C) 2004-2006 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Use the required linker script file (if none has been specified) */
+ 
+ #undef LINK_SPEC
+ #define LINK_SPEC "%{!T:-T erc32.ld%s}"
+ 
+ /* Make the BSP and the C library available */
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC "-lerc32 %{!g:-lc} %{g:-lg}"
+ 
+ /* This target does not need support for either table based unwinding or
+    C++ constructors/destructors, so that there is no need for the
+    crtbegin/crtend and crti/crtn machinery. */
+ 
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC "crt0.o%s"
+ 
+ #undef ENDFILE_SPEC
+ #define ENDFILE_SPEC ""
+ 
+ /* This platform supports software stack checking, and we will reserve
+    75 words of space for either propagating the exception (sjlj) or
+    executing a possible last chance handler. */
+ 
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 300
+ 
+ /* This target does not have MMU so that nothing needs to be done in
+    order to enable the execution of code on the stack. */
+ 
+ #undef ENABLE_EXECUTE_STACK
+ 
+ /* Force the use of dwarf-2 by default */
+ 
+ #undef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
*** gcc/config/sparc/leon.h.orig	Mon Sep 22 22:06:34 2008
--- gcc/config/sparc/leon.h	Mon Sep 22 22:06:26 2008
***************
*** 0 ****
--- 1,57 ----
+ /* Definitions for a LEON machine running in a bare board
+    configuration using the ELF object format.
+    Copyright (C) 2004-2006 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Use the required linker script file (if none has been specified) */
+ 
+ #undef LINK_SPEC
+ #define LINK_SPEC "%{!T:-T leon.ld%s}"
+ 
+ /* Make the BSP and the C library available */
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC "-lleon %{!g:-lc} %{g:-lg}"
+ 
+ /* This target does not need support for either table based unwinding or
+    C++ constructors/destructors, so that there is no need for the
+    crtbegin/crtend and crti/crtn machinery. */
+ 
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC "crt0.o%s"
+ 
+ #undef ENDFILE_SPEC
+ #define ENDFILE_SPEC ""
+ 
+ /* This platform supports software stack checking, and we will reserve
+    75 words of space for either propagating the exception (sjlj) or
+    executing a possible last chance handler. */
+ 
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 300
+ 
+ /* This target does not have MMU so that nothing needs to be done in
+    order to enable the execution of code on the stack. */
+ 
+ #undef ENABLE_EXECUTE_STACK
+ 
+ /* Force the use of dwarf-2 by default */
+ 
+ #undef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
*** libgcc/config.host.orig	Mon Sep 22 22:35:02 2008
--- libgcc/config.host	Mon Sep 22 22:37:50 2008
***************
*** 83,88 ****
--- 83,91 ----
  ep9312*-*-*)
  	cpu_type=arm
  	;;
+ erc32-*-* | leon-*-*)
+         cpu_type=sparc
+         ;;
  fido-*-*)
  	cpu_type=m68k
  	;;
***************
*** 264,269 ****
--- 267,274 ----
  	;;
  crx-*-elf)
  	;;
+ erc32-*-elf)
+         ;;
  fido-*-elf)
  	;;
  fr30-*-elf)
***************
*** 399,404 ****
--- 404,411 ----
  	;;
  iq2000*-*-elf*)
          ;;
+ leon-*-elf)
+         ;;
  m32r-*-elf*)
   	;;
  m32rle-*-elf*)
*** gcc/config/rs6000/tramp.asm.orig	2008-09-23 13:02:37.000000000 +0200
--- gcc/config/rs6000/tramp.asm	2008-09-23 13:03:06.000000000 +0200
***************
*** 112,118 ****
  	addis	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@ha
  	addi	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@l
  #endif
! 	bl	JUMP_TARGET(abort)
  FUNC_END(__trampoline_setup)
  
  #endif
--- 112,130 ----
  	addis	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@ha
  	addi	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@l
  #endif
! /* Use a longcall sequence in the simple non PIC case.  This allows the
!    non-pic code to be mlongcall compliant, which is useful on e.g. VxWorks
!    targets because this can be part of a module loaded very far away from
!    the 'abort' entry point.  The PIC+longcall case would be much harder to
!    handle, and there is no real need as of today.  */
! #if defined __PIC__ || defined __pic__
!       bl JUMP_TARGET(abort)
! #else
!       addis 11, 0,JUMP_TARGET(abort)@ha
!       addi  12,11,JUMP_TARGET(abort)@l
!       mtlr  12
!       blrl
! #endif
  FUNC_END(__trampoline_setup)
  
  #endif
*** gcc/config/rs6000/t-vxworks.orig	2008-09-23 13:04:00.000000000 +0200
--- gcc/config/rs6000/t-vxworks	2008-09-23 13:04:07.000000000 +0200
***************
*** 14,16 ****
--- 14,22 ----
  # t-ppccomm *adds* to it, but the common contents are useful to us.
  # In particular the base trampoline_setup bits are expected to be
  # provided there.
+ 
+ # Parts of libgcc reference VxWorks kernel entry points and might be included
+ # in modules loaded very far away from the kernel text.  Force longcalls to
+ # ensure we don't hit problems with relocation requests too large to fit in
+ # short calls.
+ TARGET_LIBGCC2_CFLAGS += -mlongcall
*** configure.orig	2008-09-24 11:14:09.000000000 +0200
--- configure	2008-09-24 11:15:43.000000000 +0200
***************
*** 2494,2499 ****
--- 2494,2502 ----
      noconfigdirs="$noconfigdirs ${libgcj}"
      libgloss_dir=rs6000
      ;;
+   powerpc-*-eabispe)
+     noconfigdirs="$noconfigdirs ${libgcj}"
+     ;;
    powerpc-*-eabi* | powerpcle-*-eabi* | powerpc-*-rtems* )
      libgloss_dir=rs6000
      ;;
*** gcc/config/rs6000/rs6000.h.ori	Wed Sep 24 16:35:28 2008
--- gcc/config/rs6000/rs6000.h	Wed Sep 24 16:50:25 2008
*************** extern const char *host_detect_local_cpu
*** 242,247 ****
--- 242,250 ----
  
  #define TARGET_DEFAULT (MASK_POWER | MASK_MULTIPLE | MASK_STRING)
  
+ /* Extra default flags to be overriden on a per subtarget basis.  */
+ #define SUBTARGET_DEFAULT 0
+ 
  /* Processor type.  Order must match cpu attribute in MD file.  */
  enum processor_type
   {
*** gcc/config/rs6000/rs6000.c.ori	Wed Sep 24 16:35:00 2008
--- gcc/config/rs6000/rs6000.c	Wed Sep 24 16:51:42 2008
*************** static const char alt_reg_names[][8] =
*** 1192,1198 ****
  
  #undef TARGET_DEFAULT_TARGET_FLAGS
  #define TARGET_DEFAULT_TARGET_FLAGS \
!   (TARGET_DEFAULT)
  
  #undef TARGET_STACK_PROTECT_FAIL
  #define TARGET_STACK_PROTECT_FAIL rs6000_stack_protect_fail
--- 1192,1198 ----
  
  #undef TARGET_DEFAULT_TARGET_FLAGS
  #define TARGET_DEFAULT_TARGET_FLAGS \
!   (TARGET_DEFAULT | SUBTARGET_DEFAULT)
  
  #undef TARGET_STACK_PROTECT_FAIL
  #define TARGET_STACK_PROTECT_FAIL rs6000_stack_protect_fail
*** gcc/config/rs6000/strict-align.h.ori	Wed Sep 24 17:16:43 2008
--- gcc/config/rs6000/strict-align.h	Wed Sep 24 17:16:34 2008
***************
*** 0 ****
--- 1,26 ----
+ /* Definitions of target machine for GNU compiler, for IBM RS/6000.
+    Copyright (C) 2008
+    Free Software Foundation, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the
+    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301, USA.  */
+ 
+ /* Default to -mstrict-align.  */
+ 
+ #undef  SUBTARGET_DEFAULT
+ #define SUBTARGET_DEFAULT (MASK_STRICT_ALIGN)
+ 
*** gcc/config.gcc.ori	Wed Sep 24 16:35:43 2008
--- gcc/config.gcc	Wed Sep 24 17:15:20 2008
*************** powerpc-*-eabisim*)
*** 1935,1940 ****
--- 1937,1944 ----
  	;;
  powerpc-*-elf*)
  	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+ 	# Default to -mstrict-align
+ 	tm_file="${tm_file} rs6000/strict-align.h"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
  	use_fixproto=yes
*************** powerpc-*-eabialtivec*)
*** 1946,1951 ****
--- 1950,1957 ----
  	;;
  powerpc-*-eabi*)
  	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h"
+ 	# Default to -mstrict-align
+ 	tm_file="${tm_file} rs6000/strict-align.h"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
  	;;
*** gcc/config/rs6000/vxworks.h.ori	Wed Sep 24 18:03:35 2008
--- gcc/config/rs6000/vxworks.h	Wed Sep 24 18:03:35 2008
*************** along with GCC; see the file COPYING3.  
*** 75,83 ****
--- 75,87 ----
                : -DCPU=PPC604  }}" \
  VXWORKS_ADDITIONAL_CPP_SPEC
  
+  /* Force -mlongcall to prevent possible reloc errors for implicit refs to
+     support routines like memcpy in dynamically loaded modules.  */
+ 
  #define CC1_SPEC						\
  "%{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}	\
   %{mlittle|mlittle-endian:-mstrict-align}			\
+  %{!mlongcall: %{!mno-longcall: -mlongcall}}			\
   %{profile: -p}		\
   %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}"
  
*** gcc/expr.c.0	2008-09-25 10:18:43.000000000 +0200
--- gcc/expr.c	2008-09-25 10:26:00.000000000 +0200
*************** expand_expr_real_1 (tree exp, rtx target
*** 7807,7819 ****
      case ARRAY_RANGE_REF:
      normal_inner_ref:
        {
! 	enum machine_mode mode1;
  	HOST_WIDE_INT bitsize, bitpos;
  	tree offset;
! 	int volatilep = 0;
  	tree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,
  					&mode1, &unsignedp, &volatilep, true);
! 	rtx orig_op0;
  
  	/* If we got back the original object, something is wrong.  Perhaps
  	   we are evaluating an expression too early.  In any event, don't
--- 7807,7819 ----
      case ARRAY_RANGE_REF:
      normal_inner_ref:
        {
! 	enum machine_mode mode1, mode2;
  	HOST_WIDE_INT bitsize, bitpos;
  	tree offset;
! 	int volatilep = 0, must_force_mem;
  	tree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,
  					&mode1, &unsignedp, &volatilep, true);
! 	rtx orig_op0, memloc;
  
  	/* If we got back the original object, something is wrong.  Perhaps
  	   we are evaluating an expression too early.  In any event, don't
*************** expand_expr_real_1 (tree exp, rtx target
*** 7823,7829 ****
  	/* If TEM's type is a union of variable size, pass TARGET to the inner
  	   computation, since it will need a temporary and TARGET is known
  	   to have to do.  This occurs in unchecked conversion in Ada.  */
- 
  	orig_op0 = op0
  	  = expand_expr (tem,
  			 (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE
--- 7823,7828 ----
*************** expand_expr_real_1 (tree exp, rtx target
*** 7837,7881 ****
  			  || modifier == EXPAND_STACK_PARM)
  			 ? modifier : EXPAND_NORMAL);
  
! 	/* If this is a constant, put it into a register if it is a legitimate
! 	   constant, OFFSET is 0, and we won't try to extract outside the
! 	   register (in case we were passed a partially uninitialized object
! 	   or a view_conversion to a larger size) or a BLKmode piece of it
! 	   (e.g. if it is unchecked-converted to a record type in Ada).  Force
! 	   the constant to memory otherwise.  */
! 	if (CONSTANT_P (op0))
! 	  {
! 	    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));
! 	    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)
! 		&& offset == 0
! 		&& mode1 != BLKmode
! 		&& bitpos + bitsize <= GET_MODE_BITSIZE (mode))
! 	      op0 = force_reg (mode, op0);
! 	    else
! 	      op0 = validize_mem (force_const_mem (mode, op0));
! 	  }
  
! 	/* Otherwise, if this object not in memory and we either have an
! 	   offset, a BLKmode result, or a reference outside the object, put it
! 	   there.  Such cases can occur in Ada if we have unchecked conversion
! 	   of an expression from a scalar type to an array or record type or
! 	   for an ARRAY_RANGE_REF whose type is BLKmode.  */
! 	else if (!MEM_P (op0)
! 		 && (offset != 0
! 		     || mode1 == BLKmode
! 		     || (bitpos + bitsize
! 			 > GET_MODE_BITSIZE (GET_MODE (op0)))))
  	  {
  	    tree nt = build_qualified_type (TREE_TYPE (tem),
  					    (TYPE_QUALS (TREE_TYPE (tem))
  					     | TYPE_QUAL_CONST));
! 	    rtx memloc = assign_temp (nt, 1, 1, 1);
! 
  	    emit_move_insn (memloc, op0);
  	    op0 = memloc;
  	  }
  
! 	if (offset != 0)
  	  {
  	    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,
  					  EXPAND_SUM);
--- 7836,7882 ----
  			  || modifier == EXPAND_STACK_PARM)
  			 ? modifier : EXPAND_NORMAL);
  
! 	mode2
! 	  = CONSTANT_P (op0) ? TYPE_MODE (TREE_TYPE (tem)) : GET_MODE (op0);
  
! 	/* If we have either an offset, a BLKmode result, or a reference
! 	   outside the underlying object, we must force it to memory.
! 	   Such a case can occur in Ada if we have unchecked conversion
! 	   of an expression from a scalar type to an aggregate type or
! 	   for an ARRAY_RANGE_REF whose type is BLKmode, or if we were
! 	   passed a partially uninitialized object or a view-conversion
! 	   to a larger size.  */
! 	must_force_mem = (offset
! 			  || mode1 == BLKmode
! 			  || bitpos + bitsize > GET_MODE_BITSIZE (mode2));
! 
! 	/* If this is a constant, put it in a register if it is a legitimate
! 	   constant and we don't need a memory reference.  */
! 	if (CONSTANT_P (op0)
! 	    && mode2 != BLKmode
! 	    && LEGITIMATE_CONSTANT_P (op0)
! 	    && !must_force_mem)
! 	  op0 = force_reg (mode2, op0);
! 
! 	/* Otherwise, if this is a constant, try to force it to the constant
! 	   pool.  Note that back-ends, e.g. MIPS, may refuse to do so if it
! 	   is a legitimate constant.  */
! 	else if (CONSTANT_P (op0) && (memloc = force_const_mem (mode2, op0)))
! 	  op0 = validize_mem (memloc);
! 
! 	/* Otherwise, if this is a constant or the object is not in memory
! 	   and need be, put it there.  */
! 	else if (CONSTANT_P (op0) || (!MEM_P (op0) && must_force_mem))
  	  {
  	    tree nt = build_qualified_type (TREE_TYPE (tem),
  					    (TYPE_QUALS (TREE_TYPE (tem))
  					     | TYPE_QUAL_CONST));
! 	    memloc = assign_temp (nt, 1, 1, 1);
  	    emit_move_insn (memloc, op0);
  	    op0 = memloc;
  	  }
  
! 	if (offset)
  	  {
  	    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,
  					  EXPAND_SUM);
*** gcc/config/rs6000/vxworks.h.orig	Wed Sep 24 14:46:06 2008
--- gcc/config/rs6000/vxworks.h	Wed Sep 24 14:47:56 2008
***************
*** 184,190 ****
--- 182,193 ----
  #undef  DWARF2_UNWIND_INFO
  #define DWARF2_UNWIND_INFO 1
  
+ #ifdef _WRS_KERNEL
+ /* _WRS_KERNEL_ is only defined in the context of the libgcc compilation. So
+    do not put in this section configuration elements that are needed by the 
+    compiler.  */
  #define MD_UNWIND_SUPPORT "config/rs6000/vxworks-unwind.h"
+ #endif
  
  /* State we're using the crtstuff objects in addition to the common bits
     and set things up for them to include just what we want.  */
*** gcc/config/rs6000/vxworks-unwind.h.orig	2008-09-24 15:42:57.000000000 +0200
--- gcc/config/rs6000/vxworks-unwind.h	2008-09-24 16:10:37.000000000 +0200
***************
*** 46,51 ****
--- 46,52 ----
  #define GCC_REGS_H
  
  #include <sigLib.h>
+ #include "insn-constants.h"
  
  typedef struct sigcontext sigcontext_t;
  
***************
*** 91,98 ****
  #define RETURN_COLUMN ARG_POINTER_REGNUM
  #endif
  
- #define LR_REGNO LINK_REGISTER_REGNUM
- 
  #define REGISTER_CFA_OFFSET_FOR(FS,REGNO,ADDR,CFA)\
  do { \
  (FS)->regs.reg[REGNO].how = REG_SAVED_OFFSET; \
--- 92,97 ----
***************
*** 130,138 ****
       point.  */
    new_cfa = mctx->gpr[STACK_POINTER_REGNUM];
  
!   fs->cfa_how = CFA_REG_OFFSET;
!   fs->cfa_reg = STACK_POINTER_REGNUM;
!   fs->cfa_offset = new_cfa - (long) context->cfa;
  
    /* And we state how to find the various registers it has saved with
       relative offset rules from there.  */
--- 129,137 ----
       point.  */
    new_cfa = mctx->gpr[STACK_POINTER_REGNUM];
  
!   fs->regs.cfa_how = CFA_REG_OFFSET;
!   fs->regs.cfa_reg = STACK_POINTER_REGNUM;
!   fs->regs.cfa_offset = new_cfa - (long) context->cfa;
  
    /* And we state how to find the various registers it has saved with
       relative offset rules from there.  */
*** gcc/expmed.c.0	2008-09-25 21:13:05.000000000 +0200
--- gcc/expmed.c	2008-09-25 21:17:15.000000000 +0200
*************** store_fixed_bit_field (rtx op0, unsigned
*** 934,946 ****
  		      && bitpos + bitsize != GET_MODE_BITSIZE (mode));
  
        if (GET_MODE (value) != mode)
! 	{
! 	  if ((REG_P (value) || GET_CODE (value) == SUBREG)
! 	      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (value)))
! 	    value = gen_lowpart (mode, value);
! 	  else
! 	    value = convert_to_mode (mode, value, 1);
! 	}
  
        if (must_and)
  	value = expand_binop (mode, and_optab, value,
--- 934,940 ----
  		      && bitpos + bitsize != GET_MODE_BITSIZE (mode));
  
        if (GET_MODE (value) != mode)
! 	value = convert_to_mode (mode, value, 1);
  
        if (must_and)
  	value = expand_binop (mode, and_optab, value,
*************** extract_bit_field_1 (rtx str_rtx, unsign
*** 1347,1353 ****
  	       ? bitpos + bitsize == BITS_PER_WORD
  	       : bitpos == 0)))
        && ((!MEM_P (op0)
! 	   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),
  				     GET_MODE_BITSIZE (GET_MODE (op0)))
  	   && GET_MODE_SIZE (mode1) != 0
  	   && byte_offset % GET_MODE_SIZE (mode1) == 0)
--- 1341,1347 ----
  	       ? bitpos + bitsize == BITS_PER_WORD
  	       : bitpos == 0)))
        && ((!MEM_P (op0)
! 	   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode1),
  				     GET_MODE_BITSIZE (GET_MODE (op0)))
  	   && GET_MODE_SIZE (mode1) != 0
  	   && byte_offset % GET_MODE_SIZE (mode1) == 0)
*** gcc/config/i386/vx-common.h.ori	Sat Sep 27 16:04:48 2008
--- gcc/config/i386/vx-common.h	Sat Sep 27 16:07:03 2008
*************** along with GCC; see the file COPYING3.  
*** 24,26 ****
--- 24,31 ----
  
  #undef RETURN_IN_MEMORY
  #define RETURN_IN_MEMORY ix86_sol10_return_in_memory
+ 
+ #undef DBX_REGISTER_NUMBER
+ #define DBX_REGISTER_NUMBER(n) \
+   (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])
+ 
*** gcc/dwarf2out.c.0	2008-09-28 20:08:12.000000000 +0200
--- gcc/dwarf2out.c	2008-09-28 20:08:29.000000000 +0200
*************** static void record_comdat_symbol_number 
*** 4439,4445 ****
  static void add_sibling_attributes (dw_die_ref);
  static void build_abbrev_table (dw_die_ref);
  static void output_location_lists (dw_die_ref);
! static int constant_size (long unsigned);
  static unsigned long size_of_die (dw_die_ref);
  static void calc_die_sizes (dw_die_ref);
  static void mark_dies (dw_die_ref);
--- 4439,4445 ----
  static void add_sibling_attributes (dw_die_ref);
  static void build_abbrev_table (dw_die_ref);
  static void output_location_lists (dw_die_ref);
! static int constant_size (unsigned HOST_WIDE_INT);
  static unsigned long size_of_die (dw_die_ref);
  static void calc_die_sizes (dw_die_ref);
  static void mark_dies (dw_die_ref);
*************** build_abbrev_table (dw_die_ref die)
*** 6972,6978 ****
  /* Return the power-of-two number of bytes necessary to represent VALUE.  */
  
  static int
! constant_size (long unsigned int value)
  {
    int log;
  
--- 6972,6978 ----
  /* Return the power-of-two number of bytes necessary to represent VALUE.  */
  
  static int
! constant_size (unsigned HOST_WIDE_INT value)
  {
    int log;
  
*** gcc/gthr-vxworks.h.ori	Mon Sep 29 18:29:33 2008
--- gcc/gthr-vxworks.h	Mon Sep 29 18:40:38 2008
*************** __gthread_recursive_mutex_unlock (__gthr
*** 108,114 ****
  typedef struct
  {
  #ifndef __RTP__
!   volatile unsigned char busy;
  #endif
    volatile unsigned char done;
  }
--- 108,117 ----
  typedef struct
  {
  #ifndef __RTP__
!   /* The address of field is likely to be used as an argument of an atomic
!      instruction eventually, e.g. via vxTas, and this requires some minimal
!      alignment to work on some targets.  */
!   volatile unsigned char busy __attribute__((aligned(4)));
  #endif
    volatile unsigned char done;
  }
*** gcc/tree.c~	Thu Aug 28 10:49:25 2008
--- gcc/tree.c	Mon Sep 29 15:48:34 2008
*************** contains_placeholder_p (const_tree exp)
*** 2293,2298 ****
--- 2293,2302 ----
  		  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1))
  		  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 2)));
  
+	case SAVE_EXPR:
+	  /* save_expr () never wraps anything containing a placeholder */
+	  return 0;
+
  	default:
  	  break;
  	}
*** gcc/common.opt.ori	Wed Oct  1 11:57:37 2008
--- gcc/common.opt	Wed Oct  1 11:57:45 2008
*************** fsee
*** 948,953 ****
--- 948,957 ----
  Common Report Var(flag_see) Init(0)
  Eliminate redundant sign extensions using LCM.
  
+ fpreserve-control-flow
+ Common Report Var(flag_preserve_control_flow) Init(0)
+ Preserve explicit control flow as much as possible.  Default off.
+ 
  fshow-column
  Common C ObjC C++ ObjC++ Report Var(flag_show_column) Init(0)
  Show column numbers in diagnostics, when available.  Default off
*** gcc/doc/invoke.texi.ori	Wed Oct  1 11:57:37 2008
--- gcc/doc/invoke.texi	Wed Oct  1 11:57:45 2008
*************** then  replace  all  occurrences with  ca
*** 6613,6618 ****
--- 6613,6626 ----
  subroutine. It is kind of an opposite of @option{-finline-functions}.
  This optimization runs at RTL level.
  
+ @item -fpreserve-control-flow
+ @opindex preserve-control-flow
+ Preserve the user level expressed control flow down to assembly code.
+ This typically disables a number of expression folding or phi-node
+ optimizations as well as passes like if-conversion, which is useful to
+ help infering source condition/decision coverage from binary instruction
+ and branch coverage.  This is not enabled by default.
+ 
  @item -fsignaling-nans
  @opindex fsignaling-nans
  Compile code assuming that IEEE signaling NaNs may generate user-visible
*** gcc/tree-ssa-phiopt.c.ori	Wed Oct  1 11:57:37 2008
--- gcc/tree-ssa-phiopt.c	Wed Oct  1 11:57:45 2008
*************** cond_store_replacement (basic_block midd
*** 1349,1360 ****
    return true;
  }
  
! /* Always do these optimizations if we have SSA
!    trees to work on.  */
  static bool
  gate_phiopt (void)
  {
!   return 1;
  }
  
  struct tree_opt_pass pass_phiopt =
--- 1349,1359 ----
    return true;
  }
  
! /* Run phi-node optimizers unless we are to preseve control flow.  */
  static bool
  gate_phiopt (void)
  {
!   return !flag_preserve_control_flow;
  }
  
  struct tree_opt_pass pass_phiopt =
*** gcc/opts.c.ori	Wed Oct  1 11:57:37 2008
--- gcc/opts.c	Wed Oct  1 11:57:45 2008
*************** decode_options (unsigned int argc, const
*** 999,1004 ****
--- 999,1011 ----
    /* Do not generate runtime descriptors if they are not requested.  */
    flag_trampolines = 1;
  #endif
+ 
+   /* Disable control-flow altering passes when requested to do so.  */
+   if (flag_preserve_control_flow)
+     {
+       flag_if_conversion = 0;
+       flag_if_conversion2 = 0;
+     }
  }
  
  #define LEFT_COLUMN	27
*** gcc/fold-const.c.ori	Wed Oct  1 11:57:37 2008
--- gcc/fold-const.c	Wed Oct  1 11:57:45 2008
*************** combine_comparisons (enum tree_code code
*** 2912,2922 ****
  
    switch (code)
      {
!     case TRUTH_AND_EXPR: case TRUTH_ANDIF_EXPR:
        compcode = lcompcode & rcompcode;
        break;
  
!     case TRUTH_OR_EXPR: case TRUTH_ORIF_EXPR:
        compcode = lcompcode | rcompcode;
        break;
  
--- 2912,2930 ----
  
    switch (code)
      {
!     case TRUTH_ANDIF_EXPR:
!       if (flag_preserve_control_flow)
! 	return NULL_TREE;
!       /* Fall through.  */
!     case TRUTH_AND_EXPR:
        compcode = lcompcode & rcompcode;
        break;
  
!     case TRUTH_ORIF_EXPR:
!       if (flag_preserve_control_flow)
! 	return NULL_TREE;
!       /* Fall through.  */
!     case TRUTH_OR_EXPR:
        compcode = lcompcode | rcompcode;
        break;
  
*************** fold_range_test (enum tree_code code, tr
*** 5341,5346 ****
--- 5349,5358 ----
    const char * const warnmsg = G_("assuming signed overflow does not occur "
  				  "when simplifying range test");
  
+   if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)
+       && flag_preserve_control_flow)
+     return NULL_TREE;
+ 
    /* If this is an OR operation, invert both sides; we will invert
       again at the end.  */
    if (or_op)
*************** fold_truthop (enum tree_code code, tree 
*** 5560,5565 ****
--- 5572,5581 ----
  	}
      }
  
+   if ((code == TRUTH_ORIF_EXPR || code == TRUTH_ANDIF_EXPR)
+       && flag_preserve_control_flow)
+     return NULL_TREE;
+ 
    code = ((code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR)
  	  ? TRUTH_AND_EXPR : TRUTH_OR_EXPR);
  
*************** fold_binary (enum tree_code code, tree t
*** 11903,11912 ****
  	 ANDIF and ORIF operators.  If B contains side effects, this
  	 might change the truth-value of A.  */
        if (TREE_CODE (arg0) == TREE_CODE (arg1)
! 	  && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR
! 	      || TREE_CODE (arg0) == TRUTH_ORIF_EXPR
! 	      || TREE_CODE (arg0) == TRUTH_AND_EXPR
! 	      || TREE_CODE (arg0) == TRUTH_OR_EXPR)
  	  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
  	{
  	  tree a00 = TREE_OPERAND (arg0, 0);
--- 11919,11929 ----
  	 ANDIF and ORIF operators.  If B contains side effects, this
  	 might change the truth-value of A.  */
        if (TREE_CODE (arg0) == TREE_CODE (arg1)
! 	  && (((TREE_CODE (arg0) == TRUTH_ANDIF_EXPR
! 		|| TREE_CODE (arg0) == TRUTH_ORIF_EXPR )
! 	       && !flag_preserve_control_flow)
! 	      || (TREE_CODE (arg0) == TRUTH_AND_EXPR
! 		  || TREE_CODE (arg0) == TRUTH_OR_EXPR))
  	  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
  	{
  	  tree a00 = TREE_OPERAND (arg0, 0);
*** gcc/doc/gcov.texi.ori	Wed Oct  1 11:57:37 2008
--- gcc/doc/gcov.texi	Wed Oct  1 11:57:45 2008
*************** included in the gfdl(7) man page.
*** 38,45 ****
  test code coverage in your programs.
  
  @menu
! * Gcov Intro::         	        Introduction to gcov.
! * Invoking Gcov::       	How to use gcov.
  * Gcov and Optimization::       Using gcov with GCC optimization.
  * Gcov Data Files::             The files used by gcov.
  * Cross-profiling::             Data file relocation.
--- 38,46 ----
  test code coverage in your programs.
  
  @menu
! * Gcov Intro::                  Introduction to gcov.
! * Invoking Gcov::               How to use gcov.
! * Precise Decision Coverage::   Doing precise decision coverage with gcov.
  * Gcov and Optimization::       Using gcov with GCC optimization.
  * Gcov Data Files::             The files used by gcov.
  * Cross-profiling::             Data file relocation.
*************** the file doesn't match the executable (d
*** 447,452 ****
--- 448,502 ----
  counts) it will ignore the contents of the file.  It then adds in the
  new execution counts and finally writes the data to the file.
  
+ @node Precise Decision Coverage
+ @section Precise Decision Coverage
+ 
+ @command{gcov} can genuinely perform decision coverage by using option
+ @option{-b} (ie showing that each branch was taken).  But you can even
+ go further, showing that each individual subcondition is covered and can
+ modify the global decision.  For example:
+ 
+ @smallexample
+ int is_cond (int a, int b, int c)
+ @{
+   return (a >= 0) || (b == 0 && c != 0);
+ @}
+ @end smallexample
+ 
+ You have to write testcases (the minimum is 4 here) to show that each
+ argument can make the function returning 0.
+ 
+ In principle, you can achieve this result with @command{gcov} by using a
+ particular coding style: always use short-circuit boolean operators.
+ This is a very natural coding style in C as the boolean operators
+ @code{||} and @code{&&} are short-circuit operators.
+ 
+ A consequence of the short-circuit operator is that a decision is made
+ for each individual subcondition.  With a properly written test harness,
+ the result of @samp{gcov -b -c} on the previous example can be:
+ 
+ @smallexample
+         -:    1:int is_cond (int a, int b, int c)
+ function is_cond called 4 returned 100% blocks executed 100%
+         4:    2:@{
+         4:    3:  return (a >= 0) || (b == 0 && c != 0);
+ branch  0 taken 3 (fallthrough)
+ branch  1 taken 1
+ branch  2 taken 2 (fallthrough)
+ branch  3 taken 1
+ branch  4 taken 1 (fallthrough)
+ branch  5 taken 1
+         -:    4:@}
+ @end smallexample
+ 
+ There are 3 decisions and thus 6 branches (1 for the true path and one for
+ the false path).  And with the 4 tests all the branches were taken.
+ 
+ By default, GCC optimizers may defeat this approach by performing
+ transformations that break the low level control flow representativity
+ of the source level expressed control.  @option{-fpreserve-control-flow}
+ was introduced to disable such transformations.
+ 
  @node Gcov and Optimization
  @section Using @command{gcov} with GCC Optimization
  
*** gcc/dwarf2out.c.ori	Tue Sep 30 14:51:02 2008
--- gcc/dwarf2out.c	Tue Sep 30 14:51:15 2008
*************** loc_descriptor_from_tree_1 (tree loc, in
*** 9796,9801 ****
--- 9796,9804 ----
        }
        break;
  
+     case CONST_DECL:
+       return loc_descriptor_from_tree_1 (DECL_INITIAL (loc), want_address);
+ 
      case INDIRECT_REF:
        ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);
        have_address = 1;
*************** loc_descriptor_from_tree_1 (tree loc, in
*** 9862,9867 ****
--- 9865,9873 ----
  	return 0;
        break;
  
+     case COMPLEX_CST:
+       return 0;
+ 
      case CONSTRUCTOR:
        {
  	/* Get an RTL for this, if something has been emitted.  */
*************** rtl_for_decl_location (tree decl)
*** 10921,10927 ****
    /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,
       and will have been substituted directly into all expressions that use it.
       C does not have such a concept, but C++ and other languages do.  */
!   if (!rtl && TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))
      rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));
  
    if (rtl)
--- 10927,10935 ----
    /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,
       and will have been substituted directly into all expressions that use it.
       C does not have such a concept, but C++ and other languages do.  */
!   if (!rtl 
!       && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)
!       && DECL_INITIAL (decl))
      rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));
  
    if (rtl)
*************** add_location_or_const_value_attribute (d
*** 10989,10994 ****
--- 10997,11003 ----
      return;
  
    gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL
+ 	      || TREE_CODE (decl) == CONST_DECL
  	      || TREE_CODE (decl) == RESULT_DECL);
  
    /* See if we possibly have multiple locations for this variable.  */
*************** gen_decl_die (tree decl, dw_die_ref cont
*** 14185,14195 ****
      case ERROR_MARK:
        break;
  
-     case CONST_DECL:
-       /* The individual enumerators of an enum type get output when we output
- 	 the Dwarf representation of the relevant enum type itself.  */
-       break;
- 
      case FUNCTION_DECL:
        /* Don't output any DIEs to represent mere function declarations,
  	 unless they are class members or explicit block externs.  */
--- 14194,14199 ----
*************** gen_decl_die (tree decl, dw_die_ref cont
*** 14278,14283 ****
--- 14282,14293 ----
  	gen_label_die (decl, context_die);
        break;
  
+     case CONST_DECL:
+       /* The individual enumerators of an enum type get output when we output
+ 	 the Dwarf representation of the relevant enum type itself.  */
+       if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)
+ 	break;
+ 
      case VAR_DECL:
      case RESULT_DECL:
        /* If we are in terse mode, don't generate any DIEs to represent any
*************** dwarf2out_decl (tree decl)
*** 14496,14501 ****
--- 14506,14517 ----
  	context_die = NULL;
        break;
  
+     case CONST_DECL:
+       if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)
+ 	return;
+ 
+       /* ... fall through ...  */
+ 
      case VAR_DECL:
        /* Ignore this VAR_DECL if it refers to a file-scope extern data object
  	 declaration and if the declaration was never even referenced from
*** gcc/dbxout.c.ori	Wed Oct  1 16:25:53 2008
--- gcc/dbxout.c	Wed Oct  1 16:25:57 2008
*************** along with GCC; see the file COPYING3.  
*** 162,167 ****
--- 162,182 ----
  #define DBX_CONTIN_CHAR '\\'
  #endif
  
+ /* dbxout_symbol_location needs to know if it should prevent
+    STATIC_BLOCK_STARTs and ENDs for static debug-only symbols, which
+    is very target specific.
+ 
+    AIX features a smart garbage collecting linker which would leave
+    the debug-only symbols out if they were in a block of their own,
+    and a tolerant enough assembler not to barf on what we emit in
+    these cases.  */
+ 
+ #ifndef TARGET_AIX
+ #define TARGET_AIX 0
+ #endif
+ 
+ #define PREVENT_STATIC_DEBUG_ONLY_BLOCKS TARGET_AIX
+ 
  enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};
  
  /* Structure recording information about a C data type.
*************** dbxout_symbol_location (tree decl, tree 
*** 3066,3074 ****
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   /* A null address denotes a pure debug entity associated
!      with no real symbol so keep using the current block.  */
!   if (addr != const0_rtx)
      DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
--- 3081,3090 ----
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   /* A null address denotes a pure debug entity associated with no
!      real symbol, for which we might want to prevent a static block
!      creation.  */
!   if (addr != const0_rtx || ! PREVENT_STATIC_DEBUG_ONLY_BLOCKS)
      DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
*************** dbxout_symbol_location (tree decl, tree 
*** 3079,3085 ****
  
  #ifdef DBX_STATIC_BLOCK_END
    /* See comment just above.  */
!   if (addr != const0_rtx)
      DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
--- 3095,3101 ----
  
  #ifdef DBX_STATIC_BLOCK_END
    /* See comment just above.  */
!   if (addr != const0_rtx || ! PREVENT_STATIC_DEBUG_ONLY_BLOCKS)
      DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
*** gcc/varasm.c.ori	Wed Oct  1 16:54:29 2008
--- gcc/varasm.c	Wed Oct  1 16:54:33 2008
*************** default_section_type_flags (tree decl, c
*** 5864,5869 ****
--- 5864,5870 ----
    if (strcmp (name, ".bss") == 0
        || strncmp (name, ".bss.", 5) == 0
        || strncmp (name, ".gnu.linkonce.b.", 16) == 0
+       || strcmp (name, ".persistent.bss") == 0
        || strcmp (name, ".sbss") == 0
        || strncmp (name, ".sbss.", 6) == 0
        || strncmp (name, ".gnu.linkonce.sb.", 17) == 0)
*** gcc/dbxout.c.ori	Wed Oct  1 19:06:25 2008
--- gcc/dbxout.c	Wed Oct  1 19:06:31 2008
*************** along with GCC; see the file COPYING3.  
*** 177,182 ****
--- 177,186 ----
  
  #define PREVENT_STATIC_DEBUG_ONLY_BLOCKS TARGET_AIX
  
+ /* The base name for function "scope" labels.  */
+ 
+ #define SCOPE_LABEL_BASENAME "Lscope" 
+ 
  enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};
  
  /* Structure recording information about a C data type.
*************** static void dbxout_handle_pch (unsigned)
*** 354,359 ****
--- 358,364 ----
  
  static void dbxout_source_line (unsigned int, const char *);
  static void dbxout_begin_prologue (unsigned int, const char *);
+ static void dbxout_end_epilogue (unsigned int, const char *);
  static void dbxout_source_file (const char *);
  static void dbxout_function_end (tree);
  static void dbxout_begin_function (tree);
*************** const struct gcc_debug_hooks dbx_debug_h
*** 375,381 ****
    dbxout_source_line,		         /* source_line */
    dbxout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
!   debug_nothing_int_charstar,	         /* end_epilogue */
  #ifdef DBX_FUNCTION_FIRST
    dbxout_begin_function,
  #else
--- 380,386 ----
    dbxout_source_line,		         /* source_line */
    dbxout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
!   dbxout_end_epilogue,		         /* end_epilogue */
  #ifdef DBX_FUNCTION_FIRST
    dbxout_begin_function,
  #else
*************** dbxout_function_end (tree decl)
*** 923,947 ****
  {
    char lscope_label_name[100];
  
-   /* The Lscope label must be emitted even if we aren't doing anything
-      else; dbxout_block needs it.  */
-   switch_to_section (function_section (current_function_decl));
-   
-   /* Convert Lscope into the appropriate format for local labels in case
-      the system doesn't insert underscores in front of user generated
-      labels.  */
-   ASM_GENERATE_INTERNAL_LABEL (lscope_label_name, "Lscope", scope_labelno);
-   targetm.asm_out.internal_label (asm_out_file, "Lscope", scope_labelno);
- 
    /* The N_FUN tag at the end of the function is a GNU extension,
!      which may be undesirable, and is unnecessary if we do not have
!      named sections.  */
    if (!use_gnu_debug_info_extensions
        || NO_DBX_FUNCTION_END
-       || !targetm.have_named_sections
        || DECL_IGNORED_P (decl))
      return;
  
    /* By convention, GCC will mark the end of a function with an N_FUN
       symbol and an empty string.  */
    if (flag_reorder_blocks_and_partition)
--- 928,945 ----
  {
    char lscope_label_name[100];
  
    /* The N_FUN tag at the end of the function is a GNU extension,
!      which may be undesirable.  */
    if (!use_gnu_debug_info_extensions
        || NO_DBX_FUNCTION_END
        || DECL_IGNORED_P (decl))
      return;
  
+   switch_to_section (function_section (current_function_decl));
+ 
+   ASM_GENERATE_INTERNAL_LABEL
+     (lscope_label_name, SCOPE_LABEL_BASENAME, scope_labelno);
+ 
    /* By convention, GCC will mark the end of a function with an N_FUN
       symbol and an empty string.  */
    if (flag_reorder_blocks_and_partition)
*************** dbxout_begin_prologue (unsigned int line
*** 1284,1289 ****
--- 1282,1309 ----
    targetm.asm_out.internal_label (asm_out_file, "LFBB", scope_labelno);
  }
  
+ /* Right after the function's epilogue, emit the function "scope" label.  */
+ 
+ static void
+ dbxout_end_epilogue (unsigned int lineno ATTRIBUTE_UNUSED,
+ 		     const char *filename ATTRIBUTE_UNUSED)
+ {
+   /* The function scope label must be emitted even if we aren't doing
+      anything else because dbxout_block needs it.
+ 
+      We emit it here because we know we are still in function's section,
+      and the typical use is from dbxout_function_end, where we emit an
+      expression to compute the function size as the difference between the
+      address of this label and that of the function entry point.  
+ 
+      We used to emit the label from dbxout_function_end itself, but we need
+      to switch back into the function section there and some assemblers
+      can't process the difference in this context.  */
+ 
+   targetm.asm_out.internal_label
+     (asm_out_file, SCOPE_LABEL_BASENAME, scope_labelno);
+ }
+ 
  /* Output a line number symbol entry for source file FILENAME and line
     number LINENO.  */
  
*************** dbxout_block (tree block, int depth, tre
*** 3547,3554 ****
  	      if (depth == 0)
  		/* The outermost block doesn't get LBE labels;
  		   use the "scope" label which will be emitted
! 		   by dbxout_function_end.  */
! 		ASM_GENERATE_INTERNAL_LABEL (buf, "Lscope", scope_labelno);
  	      else
  		ASM_GENERATE_INTERNAL_LABEL (buf, "LBE", blocknum);
  
--- 3567,3575 ----
  	      if (depth == 0)
  		/* The outermost block doesn't get LBE labels;
  		   use the "scope" label which will be emitted
! 		   by dbxout_end_epilogue.  */
! 		ASM_GENERATE_INTERNAL_LABEL
! 		  (buf, SCOPE_LABEL_BASENAME, scope_labelno);
  	      else
  		ASM_GENERATE_INTERNAL_LABEL (buf, "LBE", blocknum);
  
*** gcc/dbxout.c.0	2008-10-01 20:43:13.000000000 +0200
--- gcc/dbxout.c	2008-10-01 21:47:36.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 134,145 ****
  #define DBX_REGPARM_STABS_LETTER 'P'
  #endif
  
! #ifndef NO_DBX_FUNCTION_END
! #define NO_DBX_FUNCTION_END 0
! #endif
! 
! #ifndef NO_DBX_BNSYM_ENSYM
! #define NO_DBX_BNSYM_ENSYM 0
  #endif
  
  #ifndef NO_DBX_MAIN_SOURCE_DIRECTORY
--- 134,141 ----
  #define DBX_REGPARM_STABS_LETTER 'P'
  #endif
  
! #ifndef DBX_BNSYM_ENSYM
! #define DBX_BNSYM_ENSYM 0
  #endif
  
  #ifndef NO_DBX_MAIN_SOURCE_DIRECTORY
*************** dbxout_function_end (tree decl)
*** 930,938 ****
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions
!       || NO_DBX_FUNCTION_END
!       || DECL_IGNORED_P (decl))
      return;
  
    switch_to_section (function_section (current_function_decl));
--- 926,932 ----
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions || DECL_IGNORED_P (decl))
      return;
  
    switch_to_section (function_section (current_function_decl));
*************** dbxout_function_end (tree decl)
*** 956,966 ****
        char begin_label[20];
        /* Reference current function start using LFBB.  */
        ASM_GENERATE_INTERNAL_LABEL (begin_label, "LFBB", scope_labelno);
        dbxout_begin_empty_stabs (N_FUN);
        dbxout_stab_value_label_diff (lscope_label_name, begin_label);
      }
  
!   if (!NO_DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)
      dbxout_stabd (N_ENSYM, 0);
  }
  #endif /* DBX_DEBUGGING_INFO */
--- 950,964 ----
        char begin_label[20];
        /* Reference current function start using LFBB.  */
        ASM_GENERATE_INTERNAL_LABEL (begin_label, "LFBB", scope_labelno);
+ #ifdef DBX_OUTPUT_NFUN
+       DBX_OUTPUT_NFUN (asm_out_file, lscope_label_name, begin_label);
+ #else
        dbxout_begin_empty_stabs (N_FUN);
        dbxout_stab_value_label_diff (lscope_label_name, begin_label);
+ #endif
      }
  
!   if (DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)
      dbxout_stabd (N_ENSYM, 0);
  }
  #endif /* DBX_DEBUGGING_INFO */
*************** static void
*** 1267,1274 ****
  dbxout_begin_prologue (unsigned int lineno, const char *filename)
  {
    if (use_gnu_debug_info_extensions
!       && !NO_DBX_FUNCTION_END
!       && !NO_DBX_BNSYM_ENSYM
        && !flag_debug_only_used_symbols)
      dbxout_stabd (N_BNSYM, 0);
  
--- 1265,1271 ----
  dbxout_begin_prologue (unsigned int lineno, const char *filename)
  {
    if (use_gnu_debug_info_extensions
!       && DBX_BNSYM_ENSYM
        && !flag_debug_only_used_symbols)
      dbxout_stabd (N_BNSYM, 0);
  
*** gcc/mips-tfile.c.0	2008-10-01 20:43:13.000000000 +0200
--- gcc/mips-tfile.c	2008-10-01 20:43:21.000000000 +0200
*************** static alloc_info_t alloc_counts[ (int) 
*** 1453,1458 ****
--- 1453,1461 ----
  
  /* Pointers and such to the original symbol table that is read in.  */
  static struct filehdr orig_file_header;		/* global object file header */
+ static struct scnhdr *section_headers;			/* section headers */
+ static Size_t rdata_vaddr;				/* .rdata section address */
+ static char  *rdata_ptr;				/* .rdata section contents */
  
  static HDRR	 orig_sym_hdr;			/* symbolic header on input */
  static char	*orig_linenum;			/* line numbers */
*************** parse_stabs_common (const char *string_s
*** 3669,3681 ****
  	    {
  	      sc = scNil;
  	      st = stNil;
  	    }
  	  else
  	    {
  	      sc = (sc_t) sym_ptr->sc;
  	      st = (st_t) sym_ptr->st;
  	    }
- 	  value = sym_ptr->value;
  
  	  ch = *end_p1++;
  	  if (ch != '\n')
--- 3672,3702 ----
  	    {
  	      sc = scNil;
  	      st = stNil;
+ 	      value = sym_ptr->value;
+ 	    }
+ 	  /* Special case of N_FUN with empty string: the value is the
+ 	     32-bit numeric value pointed to by the symbol.  */
+ 	  else if (code == (int) N_FUN
+ 		   && string_start == string_end
+ 		   && sym_ptr->sc == scRData
+ 		   && rdata_vaddr > 0)
+ 	    {
+ 	      unsigned char *q = rdata_ptr + sym_ptr->value - rdata_vaddr;
+ 	      sc = scNil;
+ 	      st = stNil;
+ 	      if (init_file.fdr.fBigendian)
+ 		value = ((symint_t)q[0]<<24) + ((symint_t)q[1]<<16)
+ 			  + ((symint_t)q[2]<<8) + (symint_t)q[3];
+ 	      else
+ 		value = (symint_t)q[0] + ((symint_t)q[1]<<8)
+ 			  + ((symint_t)q[2]<<16) + ((symint_t)q[3]<<24);
  	    }
  	  else
  	    {
  	      sc = (sc_t) sym_ptr->sc;
  	      st = (st_t) sym_ptr->st;
+ 	      value = sym_ptr->value;
  	    }
  
  	  ch = *end_p1++;
  	  if (ch != '\n')
*************** copy_object (void)
*** 4321,4327 ****
    int remaining;
    int num_write;
    int sys_write;
!   int fd, es;
    int delete_ifd = 0;
    int *remap_file_number;
    struct stat stat_buf;
--- 4342,4348 ----
    int remaining;
    int num_write;
    int sys_write;
!   int fd, es, i;
    int delete_ifd = 0;
    int *remap_file_number;
    struct stat stat_buf;
*************** copy_object (void)
*** 4356,4361 ****
--- 4377,4400 ----
  	   input_name, (long) orig_file_header.f_nsyms, (long) sizeof (HDRR));
  
  
+   /* Read in the sections headers.  */
+   section_headers
+     = (SCNHDR *) read_seek (orig_file_header.f_nscns * sizeof (SCNHDR),
+ 			    sizeof (FILHDR) + orig_file_header.f_opthdr,
+ 			    "Section headers");
+ 
+   /* Look for the .rdata section.  */
+   for (i = 0; i < orig_file_header.f_nscns; i++)
+     if (strncmp (section_headers[i].s_name, _RDATA, 8) == 0)
+       {
+ 	rdata_vaddr = section_headers[i].s_vaddr;
+ 	rdata_ptr = (char *) read_seek (section_headers[i].s_size,
+ 					section_headers[i].s_scnptr,
+ 					"Read-only data section");
+ 	break;
+       }
+ 
+ 
    /* Read in the current symbolic header.  */
    if (fseek (obj_in_stream, (long) orig_file_header.f_symptr, SEEK_SET) != 0)
      pfatal_with_name (input_name);
*** gcc/doc/tm.texi.0	2008-10-01 19:53:36.000000000 +0200
--- gcc/doc/tm.texi	2008-10-01 22:13:19.000000000 +0200
*************** generate @code{N_BINCL} or @code{N_EINCL
*** 8737,8742 ****
--- 8737,8749 ----
  number for a type number.
  @end defmac
  
+ @defmac DBX_BNSYM_ENSYM
+ Define this macro if GCC should generate @code{N_BNSYM} and
+ @code{N_ENSYM} stabs for functions, as on Darwin systems.  Normally, GCC
+ does not generate @code{N_BNSYM} or @code{N_ENSYM} stabs because some
+ assemblers cannot grok them.
+ @end defmac
+ 
  @node DBX Hooks
  @subsection Open-Ended Hooks for DBX Format
  
*************** argument @var{name} is the name of an as
*** 8754,8760 ****
  Like @code{DBX_OUTPUT_LBRAC}, but for the end of a scope level.
  @end defmac
  
! @defmac DBX_OUTPUT_NFUN (@var{stream}, @var{lscope_label}, @var{decl})
  Define this macro if the target machine requires special handling to
  output an @code{N_FUN} entry for the function @var{decl}.
  @end defmac
--- 8761,8767 ----
  Like @code{DBX_OUTPUT_LBRAC}, but for the end of a scope level.
  @end defmac
  
! @defmac DBX_OUTPUT_NFUN (@var{stream}, @var{lscope_label}, @var{begin_label})
  Define this macro if the target machine requires special handling to
  output an @code{N_FUN} entry for the function @var{decl}.
  @end defmac
*************** This macro should not be defined if the 
*** 8770,8788 ****
  if it can be made correct by defining @code{DBX_LINES_FUNCTION_RELATIVE}.
  @end defmac
  
- @defmac NO_DBX_FUNCTION_END
- Some stabs encapsulation formats (in particular ECOFF), cannot handle the
- @code{.stabs "",N_FUN,,0,0,Lscope-function-1} gdb dbx extension construct.
- On those machines, define this macro to turn this feature off without
- disturbing the rest of the gdb extensions.
- @end defmac
- 
- @defmac NO_DBX_BNSYM_ENSYM
- Some assemblers cannot handle the @code{.stabd BNSYM/ENSYM,0,0} gdb dbx
- extension construct.  On those machines, define this macro to turn this
- feature off without disturbing the rest of the gdb extensions.
- @end defmac
- 
  @node File Names and DBX
  @subsection File Names in DBX Format
  
--- 8777,8782 ----
*** gcc/config/darwin.h.0	2008-10-01 20:43:13.000000000 +0200
--- gcc/config/darwin.h	2008-10-01 20:43:21.000000000 +0200
*************** extern GTY(()) int darwin_ms_struct;
*** 408,413 ****
--- 408,414 ----
  /* We still allow output of STABS.  */
  
  #define DBX_DEBUGGING_INFO 1
+ #define DBX_BNSYM_ENSYM    1
  
  #define DWARF2_DEBUGGING_INFO
  #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
*** gcc/config/alpha/alpha.h.0	2008-10-01 20:43:13.000000000 +0200
--- gcc/config/alpha/alpha.h	2008-10-01 20:43:21.000000000 +0200
*************** extern int num_source_filenames;
*** 1396,1412 ****
  #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)			\
    alpha_output_filename (STREAM, NAME)
  
- /* mips-tfile.c limits us to strings of one page.  We must underestimate this
-    number, because the real length runs past this up to the next
-    continuation point.  This is really a dbxout.c bug.  */
- #define DBX_CONTIN_LENGTH 3000
- 
  /* By default, turn on GDB extensions.  */
  #define DEFAULT_GDB_EXTENSIONS 1
  
- /* Stabs-in-ECOFF can't handle dbxout_function_end().  */
- #define NO_DBX_FUNCTION_END 1
- 
  /* If we are smuggling stabs through the ALPHA ECOFF object
     format, put a comment in front of the .stab<x> operation so
     that the ALPHA assembler does not choke.  The mips-tfile program
--- 1396,1404 ----
*** gcc/config/alpha/osf.h.0	2008-10-01 20:43:13.000000000 +0200
--- gcc/config/alpha/osf.h	2008-10-01 21:54:06.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 133,138 ****
--- 133,188 ----
  
  #endif
  
+ /* The mips-tfile post-processor limits us to strings of one page.
+    We must underestimate this number, because the real length runs
+    past this up to the next continuation point.  This is really a
+    dbxout.c bug.  */
+ #define DBX_CONTIN_LENGTH 3000
+ 
+ /* The mips-tfile post-processor cannot compute the difference
+    of labels so we need to use an indirection for the special
+    N_FUN emitted at the end of the STABS for a function:
+    
+ 	.ent _ada_p
+    _ada_p:
+ 	[...]
+    $Lscope:
+ 	.end _ada_p
+ 	[...]
+ 	.rdata
+    $Lspan:
+ 	.align 0
+ 	.long $Lscope-_ada_p
+ 	.text
+     #.stabs "",36,0,0,$Lspan
+ 
+    But we don't want to do this when we use the GNU assembler.  */
+ #define DBX_OUTPUT_NFUN(FILE, LSCOPE, BEGIN)				     \
+ {									     \
+   if (TARGET_GAS)							     \
+     {									     \
+       dbxout_begin_empty_stabs (N_FUN);					     \
+       dbxout_stab_value_label_diff (LSCOPE, BEGIN);			     \
+     }									     \
+   else									     \
+     {									     \
+       char lspan_label_name[100];					     \
+       switch_to_section (readonly_data_section);			     \
+       ASM_GENERATE_INTERNAL_LABEL					     \
+ 	(lspan_label_name, "Lspan", current_function_funcdef_no);	     \
+       ASM_OUTPUT_LABEL (FILE, lspan_label_name);			     \
+       fputs (integer_asm_op (4, 0), FILE);				     \
+       output_addr_const (FILE,						     \
+ 			 gen_rtx_MINUS (Pmode,				     \
+ 					gen_rtx_SYMBOL_REF (Pmode, LSCOPE),  \
+ 					gen_rtx_SYMBOL_REF (Pmode, BEGIN))); \
+       fputc ('\n', FILE);						     \
+       switch_to_section (function_section (current_function_decl));          \
+       dbxout_begin_empty_stabs (N_FUN);					     \
+       dbxout_stab_value_label (lspan_label_name);			     \
+     }									     \
+ }
+ 
  #undef EXTRA_SPECS
  #define EXTRA_SPECS { "asm_oldas", ASM_OLDAS_SPEC }
  
*** gcc/expr.c.ori	Thu Oct  2 16:43:11 2008
--- gcc/expr.c	Thu Oct  2 16:29:58 2008
*************** convert_move (rtx to, rtx from, int unsi
*** 567,576 ****
        /* No special multiword conversion insn; do it by hand.  */
        start_sequence ();
  
!       /* Since we will turn this into a no conflict block, we must ensure
! 	 that the source does not overlap the target.  */
  
!       if (reg_overlap_mentioned_p (to, from))
  	from = force_reg (from_mode, from);
  
        /* Get a copy of FROM widened to a word, if necessary.  */
--- 567,579 ----
        /* No special multiword conversion insn; do it by hand.  */
        start_sequence ();
  
!       /* Since we will turn this into a no conflict block, we must ensure the
!          the source does not overlap the target so force it into an isolated
!          register when maybe so.  Likewise for any MEM input, since the
!          conversion sequence might require several references to it and we
!          must ensure we're getting the same value every time.  */
  
!       if (MEM_P (from) || reg_overlap_mentioned_p (to, from))
  	from = force_reg (from_mode, from);
  
        /* Get a copy of FROM widened to a word, if necessary.  */
*** gcc/tree.h.0	2008-10-02 16:28:30.000000000 +0200
--- gcc/tree.h	2008-10-01 22:29:00.000000000 +0200
*************** struct tree_memory_partition_tag GTY(())
*** 2701,2707 ****
    (DECL_COMMON_CHECK (NODE)->decl_common.debug_expr_is_from)
  
  /* Nonzero for a given ..._DECL node means that the name of this node should
!    be ignored for symbolic debug purposes.  */
  #define DECL_IGNORED_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)
  
  /* Nonzero for a given ..._DECL node means that this node represents an
--- 2701,2708 ----
    (DECL_COMMON_CHECK (NODE)->decl_common.debug_expr_is_from)
  
  /* Nonzero for a given ..._DECL node means that the name of this node should
!    be ignored for symbolic debug purposes.  Moreover, for a FUNCTION_DECL,
!    the body of the function should also be ignored.  */
  #define DECL_IGNORED_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)
  
  /* Nonzero for a given ..._DECL node means that this node represents an
*** gcc/dbxout.c.0	2008-10-02 16:28:30.000000000 +0200
--- gcc/dbxout.c	2008-10-02 16:28:42.000000000 +0200
*************** dbxout_finish_complex_stabs (tree sym, S
*** 920,932 ****
  #if defined (DBX_DEBUGGING_INFO)
  
  static void
! dbxout_function_end (tree decl)
  {
    char lscope_label_name[100];
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions || DECL_IGNORED_P (decl))
      return;
  
    switch_to_section (function_section (current_function_decl));
--- 920,932 ----
  #if defined (DBX_DEBUGGING_INFO)
  
  static void
! dbxout_function_end (tree decl ATTRIBUTE_UNUSED)
  {
    char lscope_label_name[100];
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions)
      return;
  
    switch_to_section (function_section (current_function_decl));
*************** dbxout_begin_function (tree decl)
*** 3586,3594 ****
  {
    int saved_tree_used1;
  
-   if (DECL_IGNORED_P (decl))
-     return;
- 
    saved_tree_used1 = TREE_USED (decl);
    TREE_USED (decl) = 1;
    if (DECL_NAME (DECL_RESULT (decl)) != 0)
--- 3586,3591 ----
*** gcc/final.c.0	2008-10-02 16:28:30.000000000 +0200
--- gcc/final.c	2008-10-02 16:36:08.000000000 +0200
*************** remap_debug_filename (const char *filena
*** 1465,1470 ****
--- 1465,1484 ----
    return ggc_strdup (s);
  }
  
+ /* Return true if DWARF2 debug info can be emitted for DECL.  */
+ 
+ static bool
+ dwarf2_debug_info_emitted_p (tree decl)
+ {
+   if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG)
+     return false;
+ 
+   if (DECL_IGNORED_P (decl))
+     return false;
+ 
+   return true;
+ }
+ 
  /* Output assembler code for the start of a function,
     and initialize some of the variables in this file
     for the new function.  The label for the function and associated
*************** final_start_function (rtx first ATTRIBUT
*** 1488,1497 ****
  
    high_block_linenum = high_function_linenum = last_linenum;
  
!   (*debug_hooks->begin_prologue) (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO) || defined (TARGET_UNWIND_INFO)
!   if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG)
      dwarf2out_begin_prologue (0, NULL);
  #endif
  
--- 1502,1512 ----
  
    high_block_linenum = high_function_linenum = last_linenum;
  
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->begin_prologue (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO) || defined (TARGET_UNWIND_INFO)
!   if (!dwarf2_debug_info_emitted_p (current_function_decl))
      dwarf2out_begin_prologue (0, NULL);
  #endif
  
*************** final_end_function (void)
*** 1619,1635 ****
  {
    app_disable ();
  
!   (*debug_hooks->end_function) (high_function_linenum);
  
    /* Finally, output the function epilogue:
       code to restore the stack frame and return to the caller.  */
    targetm.asm_out.function_epilogue (asm_out_file, get_frame_size ());
  
    /* And debug output.  */
!   (*debug_hooks->end_epilogue) (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO)
!   if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG
        && dwarf2out_do_frame ())
      dwarf2out_end_epilogue (last_linenum, last_filename);
  #endif
--- 1634,1652 ----
  {
    app_disable ();
  
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->end_function (high_function_linenum);
  
    /* Finally, output the function epilogue:
       code to restore the stack frame and return to the caller.  */
    targetm.asm_out.function_epilogue (asm_out_file, get_frame_size ());
  
    /* And debug output.  */
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->end_epilogue (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO)
!   if (!dwarf2_debug_info_emitted_p (current_function_decl)
        && dwarf2out_do_frame ())
      dwarf2out_end_epilogue (last_linenum, last_filename);
  #endif
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1783,1789 ****
  	    dwarf2out_switch_text_section ();
  	  else
  #endif
! 	    (*debug_hooks->switch_text_section) ();
  
  	  switch_to_section (current_function_section ());
  	  break;
--- 1800,1807 ----
  	    dwarf2out_switch_text_section ();
  	  else
  #endif
! 	  if (!DECL_IGNORED_P (current_function_decl))
! 	    debug_hooks->switch_text_section ();
  
  	  switch_to_section (current_function_section ());
  	  break;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1841,1847 ****
  
  	case NOTE_INSN_FUNCTION_BEG:
  	  app_disable ();
! 	  (*debug_hooks->end_prologue) (last_linenum, last_filename);
  
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
--- 1859,1866 ----
  
  	case NOTE_INSN_FUNCTION_BEG:
  	  app_disable ();
! 	  if (!DECL_IGNORED_P (current_function_decl))
! 	    debug_hooks->end_prologue (last_linenum, last_filename);
  
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1869,1875 ****
  	      high_block_linenum = last_linenum;
  
  	      /* Output debugging info about the symbol-block beginning.  */
! 	      (*debug_hooks->begin_block) (last_linenum, n);
  
  	      /* Mark this block as output.  */
  	      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;
--- 1888,1895 ----
  	      high_block_linenum = last_linenum;
  
  	      /* Output debugging info about the symbol-block beginning.  */
! 	      if (!DECL_IGNORED_P (current_function_decl))
! 		debug_hooks->begin_block (last_linenum, n);
  
  	      /* Mark this block as output.  */
  	      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1903,1909 ****
  	      --block_depth;
  	      gcc_assert (block_depth >= 0);
  
! 	      (*debug_hooks->end_block) (high_block_linenum, n);
  	    }
  	  if (write_symbols == DBX_DEBUG
  	      || write_symbols == SDB_DEBUG)
--- 1923,1930 ----
  	      --block_depth;
  	      gcc_assert (block_depth >= 0);
  
! 	      if (!DECL_IGNORED_P (current_function_decl))
! 		debug_hooks->end_block (high_block_linenum, n);
  	    }
  	  if (write_symbols == DBX_DEBUG
  	      || write_symbols == SDB_DEBUG)
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1933,1939 ****
  	  break;
  
  	case NOTE_INSN_VAR_LOCATION:
! 	  (*debug_hooks->var_location) (insn);
  	  break;
  
  	default:
--- 1954,1961 ----
  	  break;
  
  	case NOTE_INSN_VAR_LOCATION:
! 	  if (!DECL_IGNORED_P (current_function_decl))
! 	    debug_hooks->var_location (insn);
  	  break;
  
  	default:
*************** final_scan_insn (rtx insn, FILE *file, i
*** 2000,2007 ****
  	}
  #endif
  
!       if (LABEL_NAME (insn))
! 	(*debug_hooks->label) (insn);
  
        if (app_on)
  	{
--- 2022,2029 ----
  	}
  #endif
  
!       if (!DECL_IGNORED_P (current_function_decl) && LABEL_NAME (insn))
! 	debug_hooks->label (insn);
  
        if (app_on)
  	{
*************** final_scan_insn (rtx insn, FILE *file, i
*** 2169,2178 ****
  	  }
  	/* Output this line note if it is the first or the last line
  	   note in a row.  */
! 	if (notice_source_line (insn))
! 	  {
! 	    (*debug_hooks->source_line) (last_linenum, last_filename);
! 	  }
  
  	if (GET_CODE (body) == ASM_INPUT)
  	  {
--- 2191,2199 ----
  	  }
  	/* Output this line note if it is the first or the last line
  	   note in a row.  */
! 	if (!DECL_IGNORED_P (current_function_decl)
! 	    && notice_source_line (insn))
! 	  debug_hooks->source_line (last_linenum, last_filename);
  
  	if (GET_CODE (body) == ASM_INPUT)
  	  {
*************** rest_of_handle_final (void)
*** 4157,4163 ****
       *will* be routed past here.  */
  
    timevar_push (TV_SYMOUT);
!   (*debug_hooks->function_decl) (current_function_decl);
    timevar_pop (TV_SYMOUT);
  
    /* Release the blocks that are linked to DECL_INITIAL() to free the memory.  */
--- 4185,4192 ----
       *will* be routed past here.  */
  
    timevar_push (TV_SYMOUT);
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->function_decl (current_function_decl);
    timevar_pop (TV_SYMOUT);
  
    /* Release the blocks that are linked to DECL_INITIAL() to free the memory.  */
*** gcc/varasm.c.0	2008-10-02 16:28:30.000000000 +0200
--- gcc/varasm.c	2008-10-02 16:28:42.000000000 +0200
*************** assemble_start_function (tree decl, cons
*** 1696,1702 ****
    ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);
  #endif
  
!   (*debug_hooks->begin_function) (decl);
  
    /* Make function name accessible from other files, if appropriate.  */
  
--- 1696,1703 ----
    ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);
  #endif
  
!   if (!DECL_IGNORED_P (decl))
!     (*debug_hooks->begin_function) (decl);
  
    /* Make function name accessible from other files, if appropriate.  */
  
*** gcc/config/rs6000/xcoff.h.0	2008-10-02 16:28:30.000000000 +0200
--- gcc/config/rs6000/xcoff.h	2008-10-02 16:28:42.000000000 +0200
***************
*** 172,178 ****
    putc ('.', FILE);						\
    RS6000_OUTPUT_BASENAME (FILE, NAME);				\
    fputs (":\n", FILE);						\
!   if (write_symbols != NO_DEBUG)				\
      xcoffout_declare_function (FILE, DECL, NAME);		\
  }
  
--- 172,178 ----
    putc ('.', FILE);						\
    RS6000_OUTPUT_BASENAME (FILE, NAME);				\
    fputs (":\n", FILE);						\
!   if (write_symbols != NO_DEBUG && !DECL_IGNORED_P (DECL))	\
      xcoffout_declare_function (FILE, DECL, NAME);		\
  }
  
*** gcc/config/rs6000/vxworks.h.ori	Thu Oct  2 17:57:47 2008
--- gcc/config/rs6000/vxworks.h	Thu Oct  2 17:58:55 2008
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 150,155 ****
--- 150,157 ----
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
  
+ /* On some versions of VxWorks at least ...  */
+ #define TARGET_INTERRUPTS_CLOBBER_STACK 1
  
  /* Support for table based unwinding and exception propagation:
  
*** gcc/config/rs6000/rs6000.c.ori	Thu Oct  2 17:54:49 2008
--- gcc/config/rs6000/rs6000.c	Thu Oct  2 18:38:34 2008
***************
*** 68,73 ****
--- 68,89 ----
  #define TARGET_NO_PROTOTYPE 0
  #endif
  
+ /* TARGET_INTERRUPTS_CLOBBER_STACK
+   
+    This should be 1 if interrupt handlers may run on the same stack as the
+    interrupted thread and clobber memory at arbitrary locations below sp, as
+    the base V4 ABI allows.
+ 
+    This controls stack-ties used to prevent mem accesses from beeing scheduled
+    across the prologue/epilogue stack pointer adjustments, telling whether we
+    may only tie "register saves/restores" (value 0), or if we have to tie any
+    mem access so that no stack access is ever scheduled prior/past the stack
+    frame allocation/deallocation.  */
+ 
+ #ifndef TARGET_INTERRUPTS_CLOBBER_STACK
+ #define TARGET_INTERRUPTS_CLOBBER_STACK 0
+ #endif
+  
  #define min(A,B)	((A) < (B) ? (A) : (B))
  #define max(A,B)	((A) > (B) ? (A) : (B))
  
*************** struct processor_costs power6_cost = {
*** 711,717 ****
  static bool rs6000_function_ok_for_sibcall (tree, tree);
  static const char *rs6000_invalid_within_doloop (const_rtx);
  static rtx rs6000_generate_compare (enum rtx_code);
! static void rs6000_emit_stack_tie (void);
  static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);
  static rtx spe_synthesize_frame_save (rtx);
  static bool spe_func_has_64bit_regs_p (void);
--- 727,733 ----
  static bool rs6000_function_ok_for_sibcall (tree, tree);
  static const char *rs6000_invalid_within_doloop (const_rtx);
  static rtx rs6000_generate_compare (enum rtx_code);
! static void rs6000_emit_stack_tie (bool);
  static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);
  static rtx spe_synthesize_frame_save (rtx);
  static bool spe_func_has_64bit_regs_p (void);
*************** rs6000_aix_emit_builtin_unwind_init (voi
*** 15184,15198 ****
    emit_label (no_toc_save_needed);
  }
  
! /* This ties together stack memory (MEM with an alias set of frame_alias_set)
!    and the change to the stack pointer.  */
  
  static void
! rs6000_emit_stack_tie (void)
  {
    rtx mem = gen_frame_mem (BLKmode,
  			   gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));
  
    emit_insn (gen_stack_tie (mem));
  }
  
--- 15200,15217 ----
    emit_label (no_toc_save_needed);
  }
  
! /* This ties changes to the stack pointer together with accesses to any MEM
!    if STRONG_P, or to stack MEM (with frame_alias_set) otherwise.  */
  
  static void
! rs6000_emit_stack_tie (bool strong_p)
  {
    rtx mem = gen_frame_mem (BLKmode,
  			   gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));
  
+   if (strong_p)
+     set_mem_alias_set (mem, 0);
+ 
    emit_insn (gen_stack_tie (mem));
  }
  
*************** rs6000_emit_prologue (void)
*** 15803,15810 ****
  				       || info->first_fp_reg_save < 64
  				       || info->first_gp_reg_save < 32
  				       )));
!       if (frame_reg_rtx != sp_reg_rtx)
! 	rs6000_emit_stack_tie ();
      }
  
    /* Handle world saves specially here.  */
--- 15822,15829 ----
  				       || info->first_fp_reg_save < 64
  				       || info->first_gp_reg_save < 32
  				       )));
!       if (TARGET_INTERRUPTS_CLOBBER_STACK || frame_reg_rtx != sp_reg_rtx)
! 	rs6000_emit_stack_tie (TARGET_INTERRUPTS_CLOBBER_STACK);
      }
  
    /* Handle world saves specially here.  */
*************** rs6000_emit_prologue (void)
*** 16207,16214 ****
  				   && ((info->altivec_size != 0)
  				       || (info->vrsave_mask != 0)
  				       )));
!       if (frame_reg_rtx != sp_reg_rtx)
! 	rs6000_emit_stack_tie ();
      }
  
    /* Set frame pointer, if needed.  */
--- 16226,16233 ----
  				   && ((info->altivec_size != 0)
  				       || (info->vrsave_mask != 0)
  				       )));
!       if (TARGET_INTERRUPTS_CLOBBER_STACK || frame_reg_rtx != sp_reg_rtx)
! 	rs6000_emit_stack_tie (TARGET_INTERRUPTS_CLOBBER_STACK);
      }
  
    /* Set frame pointer, if needed.  */
*************** rs6000_emit_epilogue (int sibcall)
*** 16895,16905 ****
  
    /* If this is V.4, unwind the stack pointer after all of the loads
       have been done.  */
!   if (frame_reg_rtx != sp_reg_rtx)
      {
        /* This blockage is needed so that sched doesn't decide to move
  	 the sp change before the register restores.  */
!       rs6000_emit_stack_tie ();
        if (sp_offset != 0)
          emit_insn (gen_addsi3 (sp_reg_rtx, frame_reg_rtx,
  			       GEN_INT (sp_offset)));
--- 16914,16924 ----
  
    /* If this is V.4, unwind the stack pointer after all of the loads
       have been done.  */
!   if (TARGET_INTERRUPTS_CLOBBER_STACK || frame_reg_rtx != sp_reg_rtx)
      {
        /* This blockage is needed so that sched doesn't decide to move
  	 the sp change before the register restores.  */
!       rs6000_emit_stack_tie (TARGET_INTERRUPTS_CLOBBER_STACK);
        if (sp_offset != 0)
          emit_insn (gen_addsi3 (sp_reg_rtx, frame_reg_rtx,
  			       GEN_INT (sp_offset)));
*** gcc/doc/tm.texi.ori	Wed Oct  1 18:17:36 2008
--- gcc/doc/tm.texi	Wed Oct  1 18:17:50 2008
*************** Dwarf 2 frame information.  If @code{DWA
*** 8863,8868 ****
--- 8863,8876 ----
  information not matter how you define @code{DWARF2_FRAME_INFO}.
  @end defmac
  
+ @defmac DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET
+ Define this macro to evaluate to a nonzero value if GCC should refrain
+ from generating location lists in DWARF2 debug information, for instance
+ if your target is stuck with an old version of GDB that is unable to
+ process them properly. This automatically disables variable tracking, with
+ a warning if it has been requested explicitly.
+ @end defmac
+ 
  @defmac DWARF2_ASM_LINE_DEBUG_INFO
  Define this macro to be a nonzero value if the assembler can generate Dwarf 2
  line debug info sections.  This will result in much more compact line number
*** gcc/defaults.h.ori	Wed Oct  1 18:17:36 2008
--- gcc/defaults.h	Wed Oct  1 18:17:50 2008
*************** along with GCC; see the file COPYING3.  
*** 663,668 ****
--- 663,675 ----
  #define PREFERRED_DEBUGGING_TYPE NO_DEBUG
  #endif
  
+ /* For DWARF2, assume there is proper support for location lists on the
+    target by default.  */
+ #if defined (DWARF2_DEBUGGING_INFO) \
+     && !defined (DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET)
+ #define DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET 0
+ #endif
+ 
  /* Define codes for all the float formats that we know of.  */
  #define UNKNOWN_FLOAT_FORMAT 0
  #define IEEE_FLOAT_FORMAT 1
*** gcc/dwarf2out.c.ori	Wed Oct  1 18:17:36 2008
--- gcc/dwarf2out.c	Fri Oct  3 11:48:12 2008
*************** add_location_or_const_value_attribute (d
*** 11000,11006 ****
  	      || TREE_CODE (decl) == CONST_DECL
  	      || TREE_CODE (decl) == RESULT_DECL);
  
!   /* See if we possibly have multiple locations for this variable.  */
    loc_list = lookup_decl_loc (decl);
  
    /* If it truly has multiple locations, the first and last node will
--- 11000,11008 ----
  	      || TREE_CODE (decl) == CONST_DECL
  	      || TREE_CODE (decl) == RESULT_DECL);
  
!   /* See if we possibly have multiple locations for this variable.  We expect
!      the call to always return 0 when var-tracking is disabled and the latter
!      to be enforced if DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET.  */
    loc_list = lookup_decl_loc (decl);
  
    /* If it truly has multiple locations, the first and last node will
*************** gen_subprogram_die (tree decl, dw_die_re
*** 12784,12791 ****
      }
    else if (!DECL_EXTERNAL (decl))
      {
-       HOST_WIDE_INT cfa_fb_offset;
- 
        if (!old_die || !get_AT (old_die, DW_AT_inline))
  	equate_decl_number_to_die (decl, subr_die);
  
--- 12786,12791 ----
*************** gen_subprogram_die (tree decl, dw_die_re
*** 12822,12856 ****
        add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);
  #endif
  
!       cfa_fb_offset = CFA_FRAME_BASE_OFFSET (decl);
! 
!       /* We define the "frame base" as the function's CFA.  This is more
! 	 convenient for several reasons: (1) It's stable across the prologue
! 	 and epilogue, which makes it better than just a frame pointer,
! 	 (2) With dwarf3, there exists a one-byte encoding that allows us
! 	 to reference the .debug_frame data by proxy, but failing that,
! 	 (3) We can at least reuse the code inspection and interpretation
! 	 code that determines the CFA position at various points in the
! 	 function.  */
!       /* ??? Use some command-line or configury switch to enable the use
! 	 of dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf
! 	 consumers that understand it; fall back to "pure" dwarf2 and
! 	 convert the CFA data into a location list.  */
!       {
! 	dw_loc_list_ref list = convert_cfa_to_fb_loc_list (cfa_fb_offset);
! 	if (list->dw_loc_next)
! 	  add_AT_loc_list (subr_die, DW_AT_frame_base, list);
! 	else
! 	  add_AT_loc (subr_die, DW_AT_frame_base, list->expr);
!       }
! 
!       /* Compute a displacement from the "steady-state frame pointer" to
! 	 the CFA.  The former is what all stack slots and argument slots
! 	 will reference in the rtl; the later is what we've told the
! 	 debugger about.  We'll need to adjust all frame_base references
! 	 by this displacement.  */
!       compute_frame_pointer_to_fb_displacement (cfa_fb_offset);
! 
        if (cfun->static_chain_decl)
  	add_AT_location_description (subr_die, DW_AT_static_link,
  		 loc_descriptor_from_tree (cfun->static_chain_decl));
--- 12822,12877 ----
        add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);
  #endif
  
!       /* On targets where there is proper support for DWARF2 locations list,
!  	 convert the CFA data into this form and define this as the function's
!  	 "frame base".
!  
!  	 Having the function's CFA as the "frame base" is more convenient for
!  	 several reasons: (1) It's stable across the prologue and epilogue,
!  	 which makes it better than just a frame pointer, (2) With dwarf3,
!  	 there exists a one-byte encoding that allows us to reference the
!  	 .debug_frame data by proxy, but failing that, (3) We can at least
!  	 reuse the code inspection and interpretation code that determines the
!  	 CFA position at various points in the function.
!        
!  	 ??? Use some command-line or configury switch to enable the use of
!  	 dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf consumers
!  	 that understand it;  */
!       if (!DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET)
! 	{
! 	  HOST_WIDE_INT cfa_fb_offset = CFA_FRAME_BASE_OFFSET (decl);
! 
! 	  dw_loc_list_ref list = convert_cfa_to_fb_loc_list (cfa_fb_offset);
! 	  if (list->dw_loc_next)
! 	    add_AT_loc_list (subr_die, DW_AT_frame_base, list);
! 	  else
! 	    add_AT_loc (subr_die, DW_AT_frame_base, list->expr);
!       
! 	  /* Compute a displacement from the "steady-state frame pointer" to
! 	     the CFA.  The former is what all stack slots and argument slots
! 	     will reference in the rtl; the later is what we've told the
! 	     debugger about.  We'll need to adjust all frame_base references
! 	     by this displacement.  */
! 	  compute_frame_pointer_to_fb_displacement (cfa_fb_offset);
! 	}
!       /* On other targets, use the frame pointer or stack pointer registers,
! 	 since the RTL for local variables is relative to one of them.  This
! 	 yields inaccurate debug info for prologue instructions but there is
! 	 not much we can do about this on such targets.  */
!       else
! 	{
! 	  rtx fp_reg
! 	    = (frame_pointer_needed
! 	       ? hard_frame_pointer_rtx : stack_pointer_rtx);
! 	  
! 	  add_AT_loc
! 	    (subr_die, DW_AT_frame_base,
! 	     reg_loc_descriptor (fp_reg, VAR_INIT_STATUS_INITIALIZED));
! 	  
! 	  /* We just made "frame base" the frame pointer register, so ...  */
! 	  frame_pointer_fb_offset = 0;
! 	}
!       
        if (cfun->static_chain_decl)
  	add_AT_location_description (subr_die, DW_AT_static_link,
  		 loc_descriptor_from_tree (cfun->static_chain_decl));
*** gcc/toplev.c.ori	Wed Oct  1 18:17:36 2008
--- gcc/toplev.c	Wed Oct  1 18:17:50 2008
*************** process_options (void)
*** 1977,1982 ****
--- 1977,1997 ----
    /* Now we know which debug output will be used so we can set
       flag_var_tracking, flag_rename_registers if the user has
       not specified them.  */
+ 
+   /* var_tracking relies on location lists support for DWARF2, for which a
+      target might not have full support.  Honor this.  */
+ #ifdef DWARF2_DEBUGGING_INFO
+   if (write_symbols == DWARF2_DEBUG
+       && DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET)
+     {
+       if (flag_var_tracking == 1)
+ 	warning (0, "variable tracking requested, but not supported "
+ 		 "in this configuration");
+ 
+       flag_var_tracking = 0;
+     }
+ #endif
+   
    if (debug_info_level < DINFO_LEVEL_NORMAL
        || debug_hooks->var_location == do_nothing_debug_hooks.var_location)
      {
*** gcc/config/mips/iris.h.ori	Fri Oct  3 12:07:48 2008
--- gcc/config/mips/iris.h	Fri Oct  3 12:07:02 2008
*************** along with GCC; see the file COPYING3.  
*** 22,27 ****
--- 22,31 ----
  #undef TARGET_IRIX
  #define TARGET_IRIX 1
  
+ /* We're still using gdb 5.3 on irix targets, so ...  */
+ #undef  DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET
+ #define DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET 1
+ 
  /* The size in bytes of a DWARF field indicating an offset or length
     relative to a debug info section, specified to be 4 bytes in the DWARF-2
     specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */
*** gcc/config/i386/i386.h.ori	Fri Oct  3 15:22:29 2008
--- gcc/config/i386/i386.h	Fri Oct  3 15:22:38 2008
*************** typedef struct ix86_args {
*** 1723,1730 ****
  #define FUNCTION_PROFILER(FILE, LABELNO) x86_function_profiler (FILE, LABELNO)
  
  #define MCOUNT_NAME "_mcount"
  
! #define PROFILE_COUNT_REGISTER "edx"
  
  /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
     the stack pointer does not matter.  The value is tested only in
--- 1723,1732 ----
  #define FUNCTION_PROFILER(FILE, LABELNO) x86_function_profiler (FILE, LABELNO)
  
  #define MCOUNT_NAME "_mcount"
+ #define PROFILE_COUNT_REGNUM 1  /* edx */
  
! /* Assume mcount preserves all regs by default.  */
! #define MCOUNT_PRESERVES_ALL_REGS 1
  
  /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
     the stack pointer does not matter.  The value is tested only in
*** gcc/config/i386/i386.c.ori	Fri Oct  3 15:22:29 2008
--- gcc/config/i386/i386.c	Fri Oct  3 16:06:34 2008
*************** x86_field_alignment (tree field, int com
*** 23622,23661 ****
    return computed;
  }
  
! /* Output assembler code to FILE to increment profiler label # LABELNO
!    for profiling a function entry.  */
! void
! x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
! {
!   if (TARGET_64BIT)
!     {
! #ifndef NO_PROFILE_COUNTERS
!       fprintf (file, "\tleaq\t%sP%d@(%%rip),%%r11\n", LPREFIX, labelno);
  #endif
  
!       if (!TARGET_64BIT_MS_ABI && flag_pic)
! 	fprintf (file, "\tcall\t*%s@GOTPCREL(%%rip)\n", MCOUNT_NAME);
!       else
! 	fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
!     }
!   else if (flag_pic)
      {
! #ifndef NO_PROFILE_COUNTERS
!       fprintf (file, "\tleal\t%sP%d@GOTOFF(%%ebx),%%%s\n",
! 	       LPREFIX, labelno, PROFILE_COUNT_REGISTER);
! #endif
        fprintf (file, "\tcall\t*%s@GOT(%%ebx)\n", MCOUNT_NAME);
      }
    else
      {
! #ifndef NO_PROFILE_COUNTERS
!       fprintf (file, "\tmovl\t$%sP%d,%%%s\n", LPREFIX, labelno,
! 	       PROFILE_COUNT_REGISTER);
! #endif
        fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
      }
  }
  
  /* We don't have exact information about the insn sizes, but we may assume
     quite safely that we are informed about all 1 byte insns and memory
     address sizes.  This is enough to eliminate unnecessary padding in
--- 23622,23715 ----
    return computed;
  }
  
! /* Variants of x86_function_profiler for the 32/64bit ABIs.  Output assembler
!    code to FILE to increment profiler label # LABELNO for profiling a function
!    entry.  */
! 
! /* We'll need to check several times if NO_PROFILE_COUNTERS is #defined and
!    using preprocessor directives everywhere really impairs readability.  */
! #ifdef NO_PROFILE_COUNTERS
! #define X86_SET_PROFILE_COUNTERS 0
! #else
! #define X86_SET_PROFILE_COUNTERS 1
  #endif
  
! /* 64bit ABI implementation.  */
! static void
! x86_64_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
! {
!   if (X86_SET_PROFILE_COUNTERS)
!     fprintf (file, "\tleaq\t%sP%d@(%%rip),%%r11\n", LPREFIX, labelno);
! 
!   if (!TARGET_64BIT_MS_ABI && flag_pic)
!     fprintf (file, "\tcall\t*%s@GOTPCREL(%%rip)\n", MCOUNT_NAME);
!   else
!     fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
! }
! 
! /* 32bit ABI implementation.  */
! static void
! x86_32_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
! {
!   /* We must be careful not to clobber the internal arg pointer used for stack
!      realignment purposes, if any.  This could happen in two different ways
!      from the code we emit below:  calling a careless 'mcount', which doesn't
!      save/restore the ABI caller-saved registers, or moving a value into the
!      PROFILE_COUNT register.  */
! 
!   unsigned int reg_to_preserve = INVALID_REGNUM;
! 
!   if (cfun->machine->force_align_arg_pointer)
!     reg_to_preserve = REGNO (cfun->machine->force_align_arg_pointer);
!   
!   /* No action is actually needed if mcount is safe and we're not going
!      to clobber ourselves.  */
!   if (reg_to_preserve != INVALID_REGNUM
!       && MCOUNT_PRESERVES_ALL_REGS
!       && (! X86_SET_PROFILE_COUNTERS
! 	  || reg_to_preserve != PROFILE_COUNT_REGNUM))
!     reg_to_preserve = INVALID_REGNUM;
! 
!   /* Push reg we need to preserve, if any.  */
!   if (reg_to_preserve != INVALID_REGNUM)
!     ASM_OUTPUT_REG_PUSH (file, reg_to_preserve);
! 
!   /* Emit the profiling code per se.  */
!   if (flag_pic)
      {
!       if (X86_SET_PROFILE_COUNTERS)
! 	fprintf (file, "\tleal\t%sP%d@GOTOFF(%%ebx),%%e%s\n",
! 		 LPREFIX, labelno, reg_names [PROFILE_COUNT_REGNUM]);
!       
        fprintf (file, "\tcall\t*%s@GOT(%%ebx)\n", MCOUNT_NAME);
      }
    else
      {
!       if (X86_SET_PROFILE_COUNTERS)
! 	fprintf (file, "\tmovl\t$%sP%d,%%e%s\n",
! 		 LPREFIX, labelno, reg_names [PROFILE_COUNT_REGNUM]);
!       
        fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
      }
+ 
+   /* Pop reg we need to preserve, if any.  */
+   if (reg_to_preserve != INVALID_REGNUM)
+     ASM_OUTPUT_REG_POP (file, reg_to_preserve);
  }
  
+ /* Output assembler code to FILE to increment profiler label # LABELNO for
+    profiling a function entry.  FUNCTION_PROFILER gate to either the 64bit or
+    the 32bit helper above.  */
+ void
+ x86_function_profiler (FILE *file, int labelno)
+ {
+   if (TARGET_64BIT)
+     x86_64_function_profiler (file, labelno);
+   else
+     x86_32_function_profiler (file, labelno);
+ }
+ 
+ 
  /* We don't have exact information about the insn sizes, but we may assume
     quite safely that we are informed about all 1 byte insns and memory
     address sizes.  This is enough to eliminate unnecessary padding in
*** gcc/config/i386/sol2.h.ori	Fri Oct  3 15:22:30 2008
--- gcc/config/i386/sol2.h	Fri Oct  3 15:49:15 2008
*************** along with GCC; see the file COPYING3.  
*** 47,52 ****
--- 47,56 ----
  #undef EH_TABLES_CAN_BE_READ_ONLY
  #define EH_TABLES_CAN_BE_READ_ONLY (TARGET_64BIT)
  
+ /* The solaris mcount may clobber caller-saved registers, so ...  */
+ #undef  MCOUNT_PRESERVES_ALL_REGS
+ #define MCOUNT_PRESERVES_ALL_REGS 0
+ 
  /* Solaris 2/Intel as chokes on #line directives.  */
  #undef CPP_SPEC
  #define CPP_SPEC "%{,assembler-with-cpp:-P} %(cpp_subtarget)"
*** gcc/config/i386/freebsd.h.ori	Fri Oct  3 15:22:30 2008
--- gcc/config/i386/freebsd.h	Fri Oct  3 15:22:38 2008
*************** along with GCC; see the file COPYING3.  
*** 46,51 ****
--- 46,55 ----
  #undef  MCOUNT_NAME
  #define MCOUNT_NAME ".mcount"
  
+ /* mcount may clobber caller-saved registers, so ...  */
+ #undef  MCOUNT_PRESERVES_ALL_REGS
+ #define MCOUNT_PRESERVES_ALL_REGS 0
+ 
  /* Make gcc agree with <machine/ansi.h>.  */
  
  #undef  SIZE_TYPE
*** config/mh-ppc-aix.ori	Fri Oct  3 17:21:14 2008
--- config/mh-ppc-aix	Fri Oct  3 18:26:01 2008
***************
*** 6,9 ****
  # the compiler with -mminimal-toc does not cause any harm.
  BOOT_ADAFLAGS = -gnatapg -mminimal-toc
  BOOT_LDFLAGS = -Wl,-bbigtoc
! LDFLAGS = `case $(CC) in *gcc*) echo -Wl,-bbigtoc ;; esac;`
--- 6,9 ----
  # the compiler with -mminimal-toc does not cause any harm.
  BOOT_ADAFLAGS = -gnatapg -mminimal-toc
  BOOT_LDFLAGS = -Wl,-bbigtoc
! LDFLAGS = `case '$(CC)' in *gcc*) echo -Wl,-bbigtoc ;; esac;`
*** libcpp/include/cpplib.h	(revision 140660)
--- libcpp/include/cpplib.h	(working copy)
*************** extern const char *cpp_type2name (enum c
*** 835,840 ****
--- 835,870 ----
  extern cppchar_t cpp_parse_escape (cpp_reader *, const unsigned char ** pstr,
  				   const unsigned char *limit, int wide);
  
+ /* Structure used to hold a comment block at a given location in the
+    source code.  */
+ 
+ typedef struct
+ {
+   /* Text of the comment including the terminators.  */
+   char *comment;
+ 
+   /* source location for the given comment.  */
+   source_location sloc;
+ } cpp_comment;
+ 
+ /* Structure holding all comments for a given cpp_reader.  */
+ 
+ typedef struct
+ {
+   /* table of comment entries.  */
+   cpp_comment *entries;
+ 
+   /* number of actual entries entered in the table.  */
+   int count;
+ 
+   /* number of entries allocated currently.  */
+   int allocated;
+ } cpp_comment_table;
+ 
+ /* Returns the table of comments encountered by the preprocessor. This
+    table is only populated when pfile->state.save_comments is true. */
+ extern cpp_comment_table *cpp_get_comments (cpp_reader *);
+ 
  /* In cpphash.c */
  
  /* Lookup an identifier in the hashtable.  Puts the identifier in the
*** libcpp/init.c	(revision 140660)
--- libcpp/init.c	(working copy)
*************** cpp_destroy (cpp_reader *pfile)
*** 242,247 ****
--- 242,248 ----
  {
    cpp_context *context, *contextn;
    tokenrun *run, *runn;
+   int i;
  
    free (pfile->op_stack);
  
*************** cpp_destroy (cpp_reader *pfile)
*** 284,289 ****
--- 285,298 ----
        free (context);
      }
  
+   if (pfile->comments.entries)
+     {
+       for (i = 0; i < pfile->comments.count; i++)
+ 	free (pfile->comments.entries[i].comment);
+ 
+       free (pfile->comments.entries);
+     }
+ 
    free (pfile);
  }
  
*** libcpp/internal.h	(revision 140660)
--- libcpp/internal.h	(working copy)
*************** struct cpp_reader
*** 462,467 ****
--- 462,470 ----
  
    /* Next value of __COUNTER__ macro. */
    unsigned int counter;
+ 
+   /* Table of comments, when state.save_comments is true.  */
+   cpp_comment_table comments;
  };
  
  /* Character classes.  Based on the more primitive macros in safe-ctype.h.
*** libcpp/lex.c	(revision 140660)
--- libcpp/lex.c	(working copy)
*************** static int skip_line_comment (cpp_reader
*** 55,60 ****
--- 55,61 ----
  static void skip_whitespace (cpp_reader *, cppchar_t);
  static void lex_string (cpp_reader *, cpp_token *, const uchar *);
  static void save_comment (cpp_reader *, cpp_token *, const uchar *, cppchar_t);
+ static void store_comment (cpp_reader *, cpp_token *);
  static void create_literal (cpp_reader *, cpp_token *, const uchar *,
  			    unsigned int, enum cpp_ttype);
  static bool warn_in_comment (cpp_reader *, _cpp_line_note *);
*************** lex_string (cpp_reader *pfile, cpp_token
*** 666,671 ****
--- 667,717 ----
    create_literal (pfile, token, base, cur - base, type);
  }
  
+ /* Return the comment table. The client may not make any assumption
+    about the ordering of the table.  */
+ cpp_comment_table *
+ cpp_get_comments (cpp_reader *pfile)
+ {
+   return &pfile->comments;
+ }
+ 
+ /* Append a comment to the end of the comment table. */
+ static void 
+ store_comment (cpp_reader *pfile, cpp_token *token) 
+ {
+   int len;
+ 
+   if (pfile->comments.allocated == 0)
+     {
+       pfile->comments.allocated = 256; 
+       pfile->comments.entries = (cpp_comment *) xmalloc
+ 	(pfile->comments.allocated * sizeof (cpp_comment));
+     }
+ 
+   if (pfile->comments.count == pfile->comments.allocated)
+     {
+       pfile->comments.allocated *= 2;
+       pfile->comments.entries = (cpp_comment *) xrealloc
+ 	(pfile->comments.entries,
+ 	 pfile->comments.allocated * sizeof (cpp_comment));
+     }
+ 
+   len = token->val.str.len;
+ 
+   /* Copy comment. Note, token may not be NULL terminated. */
+   pfile->comments.entries[pfile->comments.count].comment = 
+     (char *) xmalloc (sizeof (char) * (len + 1));
+   memcpy (pfile->comments.entries[pfile->comments.count].comment,
+ 	  token->val.str.text, len);
+   pfile->comments.entries[pfile->comments.count].comment[len] = '\0';
+ 
+   /* Set source location. */
+   pfile->comments.entries[pfile->comments.count].sloc = token->src_loc;
+ 
+   /* Increment the count of entries in the comment table. */
+   pfile->comments.count++;
+ }
+ 
  /* The stored comment includes the comment start and any terminator.  */
  static void
  save_comment (cpp_reader *pfile, cpp_token *token, const unsigned char *from,
*************** save_comment (cpp_reader *pfile, cpp_tok
*** 705,710 ****
--- 751,759 ----
        buffer[clen - 2] = '*';
        buffer[clen - 1] = '/';
      }
+ 
+   /* Finally store this comment for use by clients of libcpp. */
+   store_comment (pfile, token);
  }
  
  /* Allocate COUNT tokens for RUN.  */
*** gcc/tree-ssa-live.c.0	2008-10-05 21:09:45.000000000 +0200
--- gcc/tree-ssa-live.c	2008-10-05 21:37:37.000000000 +0200
*************** remove_unused_scope_block_p (tree scope)
*** 557,562 ****
--- 557,563 ----
  		    && ((BLOCK_ABSTRACT_ORIGIN (scope)
  			!= BLOCK_ABSTRACT_ORIGIN (BLOCK_SUPERCONTEXT (scope)))))))
       unused = false;
+    TREE_USED (scope) = !unused;
     return unused;
  }
  
*** gcc/collect2.c.ori	Mon Oct  6 11:15:10 2008
--- gcc/collect2.c	Mon Oct  6 11:45:34 2008
*************** static char *response_file;		/* Name of 
*** 213,218 ****
--- 213,224 ----
  struct obstack temporary_obstack;
  char * temporary_firstobj;
  
+ /* Whether we may unlink the output file, which should be set as soon as we
+    know we have successfully produced it.  This is typically useful to prevent
+    blindly attempting to unlink a read-only output that the target linker
+    would leave untouched.  */
+ bool may_unlink_output_file = false;
+ 
  /* Structure to hold all the directories in which to search for files to
     execute.  */
  
*************** fork_execute (const char *prog, char **a
*** 1739,1753 ****
    do_wait (prog, pex);
  }
  
! /* Unlink a file unless we are debugging.  */
  
  static void
  maybe_unlink (const char *file)
  {
!   if (!debug)
!     unlink_if_ordinary (file);
!   else
!     notice ("[Leaving %s]\n", file);
  }
  
  
--- 1745,1766 ----
    do_wait (prog, pex);
  }
  
! /* Unlink FILE unless we are debugging or this is the output_file
!    and we may not unlink it.  */
  
  static void
  maybe_unlink (const char *file)
  {
!   if (debug)
!     {
!       notice ("[Leaving %s]\n", file);
!       return;
!     }
! 
!   if (file == output_file && !may_unlink_output_file)
!     return;
! 
!   unlink_if_ordinary (file);
  }
  
  
*** gcc/collect2.h.ori	Mon Oct  6 11:26:28 2008
--- gcc/collect2.h	Mon Oct  6 11:36:40 2008
*************** extern const char *c_file_name;
*** 39,44 ****
--- 39,45 ----
  extern struct obstack temporary_obstack;
  extern char *temporary_firstobj;
  extern int vflag, debug;
+ extern bool may_unlink_output_file;
  
  extern void error (const char *, ...) ATTRIBUTE_PRINTF_1;
  extern void notice (const char *, ...) ATTRIBUTE_PRINTF_1;
*** gcc/tlink.c.ori	Mon Oct  6 11:15:18 2008
--- gcc/tlink.c	Mon Oct  6 11:38:42 2008
*************** do_tlink (char **ld_argv, char **object_
*** 798,801 ****
--- 798,807 ----
        error ("ld returned %d exit status", exit);
        collect_exit (exit);
      }
+   else
+     {
+       /* We have just successfully produced an output file, so assume that we
+ 	 may unlink it if need be for now on.  */ 
+       may_unlink_output_file = true;
+     }
  }
*** gcc/dbxout.c.0	2008-10-06 21:29:02.000000000 +0200
--- gcc/dbxout.c	2008-10-06 21:29:56.000000000 +0200
*************** dbxout_symbol (tree decl, int local ATTR
*** 2800,2808 ****
        }
  
      case PARM_DECL:
!       /* Parm decls go in their own separate chains
! 	 and are output by dbxout_reg_parms and dbxout_parms.  */
!       gcc_unreachable ();
  
      case RESULT_DECL:
      case VAR_DECL:
--- 2800,2812 ----
        }
  
      case PARM_DECL:
!       if (DECL_HAS_VALUE_EXPR_P (decl))
! 	decl = DECL_VALUE_EXPR (decl);
! 
!       /* PARM_DECLs go in their own separate chain and are output by
! 	 dbxout_reg_parms and dbxout_parms, except for those that are
! 	 disguised VAR_DECLs like Out parameters in Ada.  */
!       gcc_assert (TREE_CODE (decl) == VAR_DECL);
  
      case RESULT_DECL:
      case VAR_DECL:
*** fixincludes/fixinc.in.old	Thu Nov 30 01:38:35 2006
--- fixincludes/fixinc.in	Thu Nov 30 01:39:45 2006
***************
*** 75,81 ****
  #
  if test -z "${target_canonical}" ; then
    if test -x ./config.guess ; then
!     target_canonical="`config.guess`" ; fi
    test -z "${target_canonical}" && target_canonical=unknown
  fi
  export target_canonical
--- 75,81 ----
  #
  if test -z "${target_canonical}" ; then
    if test -x ./config.guess ; then
!     target_canonical="`./config.guess`" ; fi
    test -z "${target_canonical}" && target_canonical=unknown
  fi
  export target_canonical
*** gcc/gimplify.c.0	2008-10-07 12:31:53.000000000 +0200
--- gcc/gimplify.c	2008-10-07 15:46:00.000000000 +0200
*************** unshare_expr (tree expr)
*** 989,994 ****
--- 989,1019 ----
    return expr;
  }
  
+ /* Callback for walk_tree to force a source location on *TP.  */
+ 
+ static tree
+ force_location_on_expr_r (tree *tp, int *walk_subtrees, void *data)
+ {
+   location_t *loc = (location_t *) data;
+   tree t = *tp;
+ 
+   if (GIMPLE_STMT_P (t) || (EXPR_P (t) && TREE_CODE (t) != LABEL_EXPR))
+     SET_EXPR_LOCUS (t, loc);
+ 
+   if (IS_TYPE_OR_DECL_P (t))
+     *walk_subtrees = 0;
+ 
+   return NULL_TREE;
+ }
+ 
+ /* Force source location LOC on EXPR recursively.  */
+ 
+ static void
+ force_location_on_expr (tree expr, location_t *loc)
+ {
+   walk_tree (&expr, force_location_on_expr_r, loc, NULL);
+ }
+ 
  /* A terser interface for building a representation of an exception
     specification.  */
  
*************** gimplify_call_expr (tree *expr_p, tree *
*** 2135,2140 ****
--- 2160,2166 ----
    tree decl, parms, p;
    enum gimplify_status ret;
    int i, nargs;
+   tree arg_pre = NULL_TREE;
  
    gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);
  
*************** gimplify_call_expr (tree *expr_p, tree *
*** 2300,2311 ****
      {
        enum gimplify_status t;
  
!       t = gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p);
  
        if (t == GS_ERROR)
  	ret = GS_ERROR;
      }
  
    /* Try this again in case gimplification exposed something.  */
    if (ret != GS_ERROR)
      {
--- 2326,2346 ----
      {
        enum gimplify_status t;
  
!       t = gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), &arg_pre);
  
        if (t == GS_ERROR)
  	ret = GS_ERROR;
      }
  
+   /* Use the source location of the calling expression for the argument
+      preparation statements.  This will mask the detrimental effect of
+      the potential reversal above on the 'next' debugger's command.  */
+   if (arg_pre)
+     {
+       force_location_on_expr (arg_pre, EXPR_LOCUS (*expr_p));
+       append_to_statement_list (arg_pre, pre_p);
+     }
+ 
    /* Try this again in case gimplification exposed something.  */
    if (ret != GS_ERROR)
      {
*** gcc/config/avr/avr.c.ori	Thu Oct  9 12:43:43 2008
--- gcc/config/avr/avr.c	Thu Oct  9 12:44:35 2008
*************** expand_prologue (void)
*** 666,672 ****
        /* Prevent any attempt to delete the setting of ZERO_REG!  */
        emit_insn (gen_rtx_USE (VOIDmode, zero_reg_rtx));
      }
!   if (minimize && (frame_pointer_needed || live_seq > 6)) 
      {
        insn = emit_move_insn (gen_rtx_REG (HImode, REG_X), 
                               gen_int_mode (size, HImode));
--- 666,674 ----
        /* Prevent any attempt to delete the setting of ZERO_REG!  */
        emit_insn (gen_rtx_USE (VOIDmode, zero_reg_rtx));
      }
!   if (minimize && (frame_pointer_needed 
! 		   || (AVR_2_BYTE_PC && live_seq > 6)
! 		   || live_seq > 7)) 
      {
        insn = emit_move_insn (gen_rtx_REG (HImode, REG_X), 
                               gen_int_mode (size, HImode));
*** gcc/config/avr/avr.md.ori	Thu Oct  9 12:43:43 2008
--- gcc/config/avr/avr.md	Thu Oct  9 12:44:35 2008
***************
*** 2766,2773 ****
     (use (reg:HI REG_X))
     (clobber (reg:HI REG_Z))]
    ""
!   "ldi r30,pm_lo8(1f)
! 	ldi r31,pm_hi8(1f)
  	%~jmp __prologue_saves__+((18 - %0) * 2)
  1:"
    [(set_attr_alternative "length"
--- 2766,2773 ----
     (use (reg:HI REG_X))
     (clobber (reg:HI REG_Z))]
    ""
!   "ldi r30,lo8(gs(1f))
! 	ldi r31,hi8(gs(1f))
  	%~jmp __prologue_saves__+((18 - %0) * 2)
  1:"
    [(set_attr_alternative "length"
*** gcc/gcc.c.ori	Fri Oct 10 12:30:36 2008
--- gcc/gcc.c	Fri Oct 10 12:37:24 2008
*************** execute (void)
*** 3064,3071 ****
  #endif
  	      fatal_ice ("\
  Internal error: %s (program %s)\n\
! Please submit a full bug report.\n\
! See %s for instructions.",
  		 	strsignal (WTERMSIG (status)), commands[i].prog,
  		 	bug_report_url);
  	  }
--- 3064,3072 ----
  #endif
  	      fatal_ice ("\
  Internal error: %s (program %s)\n\
! Please submit a full bug report to\n\
! %s\n\
! with preprocessed source if appropriate.",
  		 	strsignal (WTERMSIG (status)), commands[i].prog,
  		 	bug_report_url);
  	  }
*************** main (int argc, char **argv)
*** 6508,6514 ****
  
        if (! verbose_flag)
  	{
! 	  printf (_("\nFor bug reporting instructions, please see:\n"));
  	  printf ("%s.\n", bug_report_url);
  
  	  return (0);
--- 6509,6517 ----
  
        if (! verbose_flag)
  	{
! 	  printf (_("\nPlease submit a full bug report,\n\
! with preprocessed source if appropriate, \n\
! to:\n"));
  	  printf ("%s.\n", bug_report_url);
  
  	  return (0);
*************** main (int argc, char **argv)
*** 6808,6814 ****
  
    if (print_help_list)
      {
!       printf (("\nFor bug reporting instructions, please see:\n"));
        printf ("%s\n", bug_report_url);
      }
  
--- 6811,6819 ----
  
    if (print_help_list)
      {
!       printf (("\nPlease submit a full bug report,\n\
! with preprocessed source if appropriate, \n\
! to:\n"));
        printf ("%s\n", bug_report_url);
      }
  
*** gcc/gcov.c.ori	Fri Oct 10 12:30:36 2008
--- gcc/gcov.c	Fri Oct 10 12:36:17 2008
*************** print_usage (int error_p)
*** 446,452 ****
    fnotice (file, "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n");
    fnotice (file, "  -p, --preserve-paths            Preserve all pathname components\n");
    fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
!   fnotice (file, "\nFor bug reporting instructions, please see:\n%s.\n",
  	   bug_report_url);
    exit (status);
  }
--- 446,452 ----
    fnotice (file, "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n");
    fnotice (file, "  -p, --preserve-paths            Preserve all pathname components\n");
    fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
!   fnotice (file, "\nFor bug reporting instructions, please contact:\n%s.\n",
  	   bug_report_url);
    exit (status);
  }
*** gcc/tree.h.0	2008-10-12 10:25:46.000000000 +0200
--- gcc/tree.h	2008-10-11 13:26:00.000000000 +0200
*************** extern tree get_unwidened (tree, tree);
*** 4616,4621 ****
--- 4616,4625 ----
  
  extern tree get_narrower (tree, int *);
  
+ /* Return 1 if T is an expression that get_inner_reference handles.  */
+ 
+ extern int handled_component_p (const_tree);
+ 
  /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,
     look for nested component-refs or array-refs at constant positions
     and find the ultimate containing object, which is returned.  */
*************** extern tree get_inner_reference (tree, H
*** 4624,4651 ****
  				 tree *, enum machine_mode *, int *, int *,
  				 bool);
  
! /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,
!    look for whether EXP or any nested component-refs within EXP is marked
!    as PACKED.  */
  
  extern bool contains_packed_reference (const_tree exp);
  
- /* Return 1 if T is an expression that get_inner_reference handles.  */
- 
- extern int handled_component_p (const_tree);
- 
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF.  */
  
  extern tree array_ref_element_size (tree);
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  extern tree array_ref_low_bound (tree);
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  extern tree array_ref_up_bound (tree);
  
--- 4628,4651 ----
  				 tree *, enum machine_mode *, int *, int *,
  				 bool);
  
! /* Given an expression EXP that may be a COMPONENT_REF, an ARRAY_REF or an
!    ARRAY_RANGE_REF, look for whether EXP or any nested component-refs within
!    EXP is marked as PACKED.  */
  
  extern bool contains_packed_reference (const_tree exp);
  
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  extern tree array_ref_element_size (tree);
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  extern tree array_ref_low_bound (tree);
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  extern tree array_ref_up_bound (tree);
  
*** gcc/expr.c.0	2008-10-12 10:25:46.000000000 +0200
--- gcc/expr.c	2008-10-12 10:26:42.000000000 +0200
*************** get_inner_reference (tree exp, HOST_WIDE
*** 6056,6064 ****
    return exp;
  }
  
! /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,
!    look for whether EXP or any nested component-refs within EXP is marked
!    as PACKED.  */
  
  bool
  contains_packed_reference (const_tree exp)
--- 6056,6064 ----
    return exp;
  }
  
! /* Given an expression EXP that may be a COMPONENT_REF, an ARRAY_REF or an
!    ARRAY_RANGE_REF, look for whether EXP or any nested component-refs within
!    EXP is marked as PACKED.  */
  
  bool
  contains_packed_reference (const_tree exp)
*************** contains_packed_reference (const_tree ex
*** 6098,6104 ****
  }
  
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF.  */
  
  tree
  array_ref_element_size (tree exp)
--- 6098,6104 ----
  }
  
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  tree
  array_ref_element_size (tree exp)
*************** array_ref_element_size (tree exp)
*** 6125,6131 ****
  }
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  tree
  array_ref_low_bound (tree exp)
--- 6125,6131 ----
  }
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  tree
  array_ref_low_bound (tree exp)
*************** array_ref_low_bound (tree exp)
*** 6146,6152 ****
  }
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  tree
  array_ref_up_bound (tree exp)
--- 6146,6152 ----
  }
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  tree
  array_ref_up_bound (tree exp)
*** gcc/tree-ssa-loop-ivopts.c.0	2008-10-12 10:25:46.000000000 +0200
--- gcc/tree-ssa-loop-ivopts.c	2008-10-12 10:26:42.000000000 +0200
*************** static bool
*** 628,634 ****
  idx_contains_abnormal_ssa_name_p (tree base, tree *index,
  				  void *data ATTRIBUTE_UNUSED)
  {
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))
  	return false;
--- 628,634 ----
  idx_contains_abnormal_ssa_name_p (tree base, tree *index,
  				  void *data ATTRIBUTE_UNUSED)
  {
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))
  	return false;
*************** idx_find_step (tree base, tree *idx, voi
*** 1321,1328 ****
       reference out of the loop (in order to take its address in strength
       reduction).  In order for this to work we need both lower bound
       and step to be loop invariants.  */
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        step = array_ref_element_size (base);
        lbound = array_ref_low_bound (base);
  
--- 1321,1333 ----
       reference out of the loop (in order to take its address in strength
       reduction).  In order for this to work we need both lower bound
       and step to be loop invariants.  */
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
+       /* Moreover, for a range, the size needs to be invariant as well.  */
+       if (TREE_CODE (base) == ARRAY_RANGE_REF
+ 	  && !expr_invariant_in_loop_p (loop, TYPE_SIZE (TREE_TYPE (base))))
+ 	return false;
+ 
        step = array_ref_element_size (base);
        lbound = array_ref_low_bound (base);
  
*************** idx_find_step (tree base, tree *idx, voi
*** 1346,1352 ****
    if (integer_zerop (iv->step))
      return true;
  
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        step = array_ref_element_size (base);
  
--- 1351,1357 ----
    if (integer_zerop (iv->step))
      return true;
  
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        step = array_ref_element_size (base);
  
*************** idx_record_use (tree base, tree *idx,
*** 1383,1389 ****
  {
    struct ivopts_data *data = (struct ivopts_data *) vdata;
    find_interesting_uses_op (data, *idx);
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        find_interesting_uses_op (data, array_ref_element_size (base));
        find_interesting_uses_op (data, array_ref_low_bound (base));
--- 1388,1394 ----
  {
    struct ivopts_data *data = (struct ivopts_data *) vdata;
    find_interesting_uses_op (data, *idx);
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        find_interesting_uses_op (data, array_ref_element_size (base));
        find_interesting_uses_op (data, array_ref_low_bound (base));
*************** strip_offset_1 (tree expr, bool inside_a
*** 1816,1821 ****
--- 1821,1827 ----
        return fold_convert (orig_type, expr);
  
      case ARRAY_REF:
+     case ARRAY_RANGE_REF:
        if (!inside_addr)
  	return orig_expr;
  
*************** idx_remove_ssa_names (tree base, tree *i
*** 5096,5102 ****
    if (TREE_CODE (*idx) == SSA_NAME)
      *idx = SSA_NAME_VAR (*idx);
  
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        op = &TREE_OPERAND (base, 2);
        if (*op
--- 5102,5108 ----
    if (TREE_CODE (*idx) == SSA_NAME)
      *idx = SSA_NAME_VAR (*idx);
  
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        op = &TREE_OPERAND (base, 2);
        if (*op
*** gcc/config/i386/linux64.h.0	2008-10-13 10:55:11.000000000 +0200
--- gcc/config/i386/linux64.h	2008-10-13 10:57:06.000000000 +0200
***************
*** 64,69 ****
--- 64,76 ----
  #define SPEC_64 "m64"
  #endif
  
+ #undef LIB_SPEC
+ #define LIB_SPEC \
+   "%{pthread:-lpthread} \
+    %{p|pg:-lgnatmon} \
+    %{shared:-lc} \
+    %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+ 
  #undef	LINK_SPEC
  #define LINK_SPEC "%{" SPEC_64 ":-m elf_x86_64} %{" SPEC_32 ":-m elf_i386} \
    %{shared:-shared} \
*** gcc/config/i386/linux.h.0	2008-10-13 10:55:11.000000000 +0200
--- gcc/config/i386/linux.h	2008-10-13 10:57:31.000000000 +0200
***************
*** 107,112 ****
--- 107,119 ----
    { "link_emulation", LINK_EMULATION },\
    { "dynamic_linker", LINUX_DYNAMIC_LINKER }
  
+ #undef LIB_SPEC
+ #define LIB_SPEC \
+   "%{pthread:-lpthread} \
+    %{p|pg:-lgnatmon} \
+    %{shared:-lc} \
+    %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+ 
  #undef	LINK_SPEC
  #define LINK_SPEC "-m %(link_emulation) %{shared:-shared} \
    %{!shared: \
*** gcc/config/i386/mingw32.h.0	2008-10-13 10:55:11.000000000 +0200
--- gcc/config/i386/mingw32.h	2008-10-13 10:58:00.000000000 +0200
***************
*** 64,70 ****
  /* For Windows applications, include more libraries, but always include
     kernel32.  */
  #undef LIB_SPEC
! #define LIB_SPEC "%{pg:-lgmon} %{mwindows:-lgdi32 -lcomdlg32} \
                    -luser32 -lkernel32 -ladvapi32 -lshell32"
  
  /* Include in the mingw32 libraries with libgcc */
--- 64,70 ----
  /* For Windows applications, include more libraries, but always include
     kernel32.  */
  #undef LIB_SPEC
! #define LIB_SPEC "%{pg:-lgnatmon} %{mwindows:-lgdi32 -lcomdlg32} \
                    -luser32 -lkernel32 -ladvapi32 -lshell32"
  
  /* Include in the mingw32 libraries with libgcc */
***************
*** 94,100 ****
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
!   %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s} \
    crtbegin.o%s"
  
  #undef ENDFILE_SPEC
--- 94,100 ----
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
!   %{!shared:%{!mdll:crt2%O%s}} \
    crtbegin.o%s"
  
  #undef ENDFILE_SPEC
*** gcc/config/sol2.h.0	2008-10-13 10:55:11.000000000 +0200
--- gcc/config/sol2.h	2008-10-13 10:58:44.000000000 +0200
***************
*** 94,100 ****
       %{!symbolic:\
         %{pthreads|pthread:-lpthread} \
         %{!pthreads:%{!pthread:%{threads:-lthread}}} \
!        %{p|pg:-ldl} -lc}}"
  
  #undef  ENDFILE_SPEC
  #define ENDFILE_SPEC "crtend.o%s crtn.o%s"
--- 94,100 ----
       %{!symbolic:\
         %{pthreads|pthread:-lpthread} \
         %{!pthreads:%{!pthread:%{threads:-lthread}}} \
!        %{p|pg:-ldl -lgnatmon} -lc}}"
  
  #undef  ENDFILE_SPEC
  #define ENDFILE_SPEC "crtend.o%s crtn.o%s"
***************
*** 105,111 ****
  			 %{!symbolic: \
  			  %{p:mcrt1.o%s} \
                            %{!p: \
! 	                    %{pg:gcrt1.o%s gmon.o%s} \
                              %{!pg:crt1.o%s}}}} \
  			crti.o%s %(startfile_arch) \
  			crtbegin.o%s"
--- 105,111 ----
  			 %{!symbolic: \
  			  %{p:mcrt1.o%s} \
                            %{!p: \
! 	                    %{pg:gcrt1.o%s} \
                              %{!pg:crt1.o%s}}}} \
  			crti.o%s %(startfile_arch) \
  			crtbegin.o%s"
*** gcc/doc/tm.texi.ori	Mon Oct 13 14:32:45 2008
--- gcc/doc/tm.texi	Mon Oct 13 14:32:50 2008
*************** addresses.  Many RISC machines have no m
*** 5446,5451 ****
--- 5446,5461 ----
  You may assume that @var{addr} is a valid address for the machine.
  @end defmac
  
+ @defmac GO_IF_MAY_NARROW_ACCESS_TO (@var{addr}, @var{mode}, @var{label})
+ A C statement or compound statement with a conditional @code{goto
+ @var{label};} executed if @var{addr}, an RTX for a legitimate memory
+ address in mode, may be accessed using a narrower mode for the purpose
+ of an ``offsettable'' reference.
+ 
+ The default definition implements a win if @var{addr} is not mode
+ dependent.
+ @end defmac
+ 
  @defmac LEGITIMATE_CONSTANT_P (@var{x})
  A C expression that is nonzero if @var{x} is a legitimate constant for
  an immediate operand on the target machine.  You can assume that
*** gcc/config/rs6000/rs6000.c.ori	Mon Oct 13 14:32:45 2008
--- gcc/config/rs6000/rs6000.c	Mon Oct 13 14:32:50 2008
*************** rs6000_legitimate_address (enum machine_
*** 4234,4249 ****
    return 0;
  }
  
! /* Go to LABEL if ADDR (a legitimate address expression)
!    has an effect that depends on the machine mode it is used for.
  
     On the RS/6000 this is true of all integral offsets (since AltiVec
!    modes don't allow them) or is a pre-increment or decrement.
! 
!    ??? Except that due to conceptual problems in offsettable_address_p
!    we can't really report the problems of integral offsets.  So leave
!    this assuming that the adjustable offset must be valid for the
!    sub-words of a TFmode operand, which is what we had before.  */
  
  bool
  rs6000_mode_dependent_address (rtx addr)
--- 4234,4244 ----
    return 0;
  }
  
! /* Whether ADDR, a legitimate address expression, has an effect that depends
!    on the machine mode it is used for.
  
     On the RS/6000 this is true of all integral offsets (since AltiVec
!    modes don't allow them) or is a pre-increment or decrement.  */
  
  bool
  rs6000_mode_dependent_address (rtx addr)
*************** rs6000_mode_dependent_address (rtx addr)
*** 4252,4261 ****
      {
      case PLUS:
        if (GET_CODE (XEXP (addr, 1)) == CONST_INT)
! 	{
! 	  unsigned HOST_WIDE_INT val = INTVAL (XEXP (addr, 1));
! 	  return val + 12 + 0x8000 >= 0x10000;
! 	}
        break;
  
      case LO_SUM:
--- 4247,4253 ----
      {
      case PLUS:
        if (GET_CODE (XEXP (addr, 1)) == CONST_INT)
! 	return true;
        break;
  
      case LO_SUM:
*************** rs6000_mode_dependent_address (rtx addr)
*** 4273,4278 ****
--- 4265,4290 ----
    return false;
  }
  
+ /* Whether ADDR, a legitimate address expression for MODE, may be accessed
+    using a narrower mode for the purpose of an "offsettable" reference.  */
+ 
+ bool
+ rs6000_may_narrow_access_to (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED)
+ {
+   switch (GET_CODE (addr))
+     {
+     case LO_SUM:
+       return false;
+ 
+     case PRE_INC:
+     case PRE_DEC:
+       return !TARGET_UPDATE;
+ 
+     default:
+       return true;
+     }
+ }
+ 
  /* More elaborate version of recog's offsettable_memref_p predicate
     that works around the ??? note of rs6000_mode_dependent_address.
     In particular it accepts
*** gcc/config/rs6000/rs6000.h.ori	Mon Oct 13 14:32:45 2008
--- gcc/config/rs6000/rs6000.h	Mon Oct 13 14:32:50 2008
*************** do {								\
*** 1803,1808 ****
--- 1803,1818 ----
    if (rs6000_mode_dependent_address (ADDR))			\
      goto LABEL;							\
  } while (0)
+ 
+ /* Go to LABEL if ADDR, a legitimate address expression in MODE,
+    may be accessed using a narrower mode for the purpose of an
+    "offsettable" constraint check.  */
+ 
+ #define GO_IF_MAY_NARROW_ACCESS_TO(ADDR,MODE,LABEL)		\
+ do {								\
+   if (rs6000_may_narrow_access_to ((ADDR), (MODE)))		\
+     goto LABEL;							\
+ } while (0)
  
  /* The register number of the register used to address a table of
     static data addresses in memory.  In some cases this register is
*** gcc/recog.c.ori	Mon Oct 13 14:32:45 2008
--- gcc/recog.c	Mon Oct 13 14:32:50 2008
*************** along with GCC; see the file COPYING3.  
*** 63,68 ****
--- 63,69 ----
  static void validate_replace_rtx_1 (rtx *, rtx, rtx, rtx);
  static void validate_replace_src_1 (rtx *, void *);
  static rtx split_insn (rtx);
+ static int may_narrow_access_to (rtx, enum machine_mode);
  
  /* Nonzero means allow operands to be volatile.
     This should be 0 if you are generating rtl, such as if you are calling
*************** offsettable_address_p (int strictp, enum
*** 1820,1826 ****
    /* Adjusting an offsettable address involves changing to a narrower mode.
       Make sure that's OK.  */
  
!   if (mode_dependent_address_p (y))
      return 0;
  
    /* ??? How much offset does an offsettable BLKmode reference need?
--- 1821,1827 ----
    /* Adjusting an offsettable address involves changing to a narrower mode.
       Make sure that's OK.  */
  
!   if (!may_narrow_access_to (y, mode))
      return 0;
  
    /* ??? How much offset does an offsettable BLKmode reference need?
*************** mode_dependent_address_p (rtx addr)
*** 1893,1898 ****
--- 1894,1926 ----
   win: ATTRIBUTE_UNUSED_LABEL
    return 1;
  }
+ 
+ /* Default GO_IF_MAY_NARROW_ACCESS_TO. Go to LABEL if ADDR, a legitimate
+    address expression for MODE, may be accessed using a narrower mode for the
+    purpose of an "offsettable" reference.  */
+  
+ #ifndef GO_IF_MAY_NARROW_ACCESS_TO
+ #define GO_IF_MAY_NARROW_ACCESS_TO(ADDR,MODE,LABEL)		\
+ do {								\
+       /* We may for sure access ADDR using a narrower		\
+ 	 mode than MODE if the effect is mode independant.  */	\
+      if (!mode_dependent_address_p (ADDR))			\
+        goto LABEL;						\
+ } while (0)
+ #endif
+ 
+ /* Return 1 if ADDR, known to be valid for MODE, might be accessed using a
+    narrower mode for the purpose of an "offsettable" reference.  */
+ 
+ static int
+ may_narrow_access_to (rtx addr ATTRIBUTE_UNUSED,
+ 		      enum machine_mode mode ATTRIBUTE_UNUSED)
+ {
+   GO_IF_MAY_NARROW_ACCESS_TO (addr, mode, win);
+   return 0;
+  win: ATTRIBUTE_UNUSED_LABEL
+   return 1;
+ }
  
  /* Like extract_insn, but save insn extracted and don't extract again, when
     called again for the same insn expecting that recog_data still contain the
*** gcc/config/rs6000/rs6000-protos.h.ori	Mon Oct 13 14:32:45 2008
--- gcc/config/rs6000/rs6000-protos.h	Mon Oct 13 14:32:50 2008
*************** extern int rs6000_legitimate_address (en
*** 113,118 ****
--- 113,119 ----
  extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);
  extern bool rs6000_mode_dependent_address (rtx);
  extern bool rs6000_offsettable_memref_p (rtx);
+ extern bool rs6000_may_narrow_access_to (rtx, enum machine_mode);
  extern rtx rs6000_return_addr (int, rtx);
  extern void rs6000_output_symbol_ref (FILE*, rtx);
  extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);
*** gcc/tree-ssa-loop-ivopts.c.0	2008-10-12 18:30:12.000000000 +0200
--- gcc/tree-ssa-loop-ivopts.c	2008-10-13 11:20:51.000000000 +0200
*************** force_expr_to_var_cost (tree expr)
*** 3205,3211 ****
    if (SSA_VAR_P (expr))
      return zero_cost;
  
!   if (TREE_INVARIANT (expr))
      {
        if (TREE_CODE (expr) == INTEGER_CST)
  	return new_cost (integer_cost, 0);
--- 3205,3211 ----
    if (SSA_VAR_P (expr))
      return zero_cost;
  
!   if (is_gimple_min_invariant (expr))
      {
        if (TREE_CODE (expr) == INTEGER_CST)
  	return new_cost (integer_cost, 0);
*** gcc/gcse.c.ori	Tue Oct 14 10:37:41 2008
--- gcc/gcse.c	Tue Oct 14 10:40:37 2008
*************** try_replace_reg (rtx from, rtx to, rtx i
*** 2678,2689 ****
  	  && validate_change (insn, &SET_SRC (set), src, 0))
  	success = 1;
  
!       /* If we've failed to do replacement, have a single SET, don't already
! 	 have a note, and have no special SET, add a REG_EQUAL note to not
! 	 lose information.  */
!       if (!success && note == 0 && set != 0
! 	  && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT
! 	  && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)
  	note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));
      }
  
--- 2678,2687 ----
  	  && validate_change (insn, &SET_SRC (set), src, 0))
  	success = 1;
  
!       /* If we've failed perform the replacement, have a single SET to
! 	 a REG destination and don't yet have a note, add a REG_EQUAL note
! 	 to not lose information.  */
!       if (!success && note == 0 && set != 0 && REG_P (SET_DEST (set)))
  	note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));
      }
  
*** gcc/fwprop.c.ori	Tue Oct 14 10:29:45 2008
--- gcc/fwprop.c	Tue Oct 14 10:37:30 2008
***************  forward_propagate_and_simplify (struct d
*** 906,915 ****
  	loc = &SET_SRC (use_set);
  
        /* Do not replace an existing REG_EQUAL note if the insn is not
! 	 recognized.  Either we're already replacing in the note, or
! 	 we'll separately try plugging the definition in the note and
! 	 simplifying.  */
!       set_reg_equal = (note == NULL_RTX);
      }
  
    if (GET_MODE (*loc) == VOIDmode)
--- 906,915 ----
  	loc = &SET_SRC (use_set);
  
        /* Do not replace an existing REG_EQUAL note if the insn is not
! 	 recognized.  Either we're already replacing in the note, or we'll
! 	 separately try plugging the definition in the note and simplifying.
! 	 Only install a REQ_EQUAL note when the destination is a REG.  */
!       set_reg_equal = (note == NULL_RTX && REG_P (SET_DEST (use_set)));
      }
  
    if (GET_MODE (*loc) == VOIDmode)
*** gcc/doc/invoke.texi.0	2008-10-14 18:41:04.000000000 +0200
--- gcc/doc/invoke.texi	2008-10-14 18:41:10.000000000 +0200
*************** Free form Fortran source code which shou
*** 949,954 ****
--- 949,957 ----
  Free form Fortran source code which must be preprocessed (with the
  traditional preprocessor).
  
+ @item @var{file}.idl
+ OMG IDL file which must be preprocessed.
+ 
  @c FIXME: Descriptions of Java file types.
  @c @var{file}.java
  @c @var{file}.class
*************** objective-c++ objective-c++-header objec
*** 1002,1007 ****
--- 1005,1011 ----
  assembler  assembler-with-cpp
  ada
  f95  f95-cpp-input
+ idl
  java
  treelang
  @end smallexample
*** gcc/c.opt.0	2008-10-14 18:41:04.000000000 +0200
--- gcc/c.opt	2008-10-14 18:41:10.000000000 +0200
*************** C Undocumented
*** 868,873 ****
--- 868,876 ----
  lang-fortran
  C Undocumented
  
+ lang-idl
+ C Undocumented
+ 
  lang-objc
  C ObjC C++ ObjC++ Undocumented
  
*** gcc/c-opts.c.0	2008-10-14 18:41:04.000000000 +0200
--- gcc/c-opts.c	2008-10-14 18:41:10.000000000 +0200
*************** c_common_init_options (unsigned int argc
*** 249,254 ****
--- 249,259 ----
  	    result |= CL_C | CL_ObjC | CL_CXX | CL_ObjCXX;
  	    break;
  	  }
+ 	else if (! strcmp (argv[i], "-lang-idl"))
+ 	  {
+ 	    result |= CL_C | CL_CXX;
+ 	    break;
+ 	  }
  
  #ifdef CL_Fortran
        for (i = 1; i < argc; i++)
*************** c_common_handle_option (size_t scode, co
*** 894,899 ****
--- 899,908 ----
        lang_fortran = true;
        break;
  
+     case OPT_lang_idl:
+       cpp_set_lang (parse_in, CLK_CXX98);
+       break;
+ 
      case OPT_lang_objc:
        cpp_opts->objc = 1;
        break;
*** gcc/gcc.c.0	2008-10-14 18:41:04.000000000 +0200
--- gcc/gcc.c	2008-10-14 18:41:10.000000000 +0200
*************** static const struct compiler default_com
*** 1038,1043 ****
--- 1038,1047 ----
         as %(asm_debug) %(asm_options) %m.s %A }}}}"
  #endif
     , 0, 1, 0},
+   {".idl", "@idl", 0, 1, 0},
+   {"@idl",
+     "%{E:%(trad_capable_cpp) -lang-idl %(cpp_options) %(cpp_debug_options)}\
+      %{!E:%e-E required for IDL file}", 0, 1, 0},
  
  #include "specs.h"
    /* Mark end of table.  */
*** gcc/tree-pass.h.0	2008-10-15 11:07:11.000000000 +0200
--- gcc/tree-pass.h	2008-02-21 12:22:00.000000000 +0100
*************** extern struct tree_opt_pass pass_jump2;
*** 362,367 ****
--- 362,368 ----
  extern struct tree_opt_pass pass_lower_subreg;
  extern struct tree_opt_pass pass_cse;
  extern struct tree_opt_pass pass_fast_rtl_dce;
+ extern struct tree_opt_pass pass_fast_rtl_dce_no_opt;
  extern struct tree_opt_pass pass_ud_rtl_dce;
  extern struct tree_opt_pass pass_rtl_dce;
  extern struct tree_opt_pass pass_rtl_dse1;
*** gcc/dce.c.0	2008-10-15 11:07:08.000000000 +0200
--- gcc/dce.c	2008-10-15 11:11:13.000000000 +0200
*************** struct tree_opt_pass pass_fast_rtl_dce =
*** 880,882 ****
--- 880,908 ----
    TODO_ggc_collect,                     /* todo_flags_finish */
    'w'                                   /* letter */
  };
+ 
+ 
+ static bool
+ gate_fast_dce_no_opt (void)
+ {
+   return optimize == 0 && flag_dce;
+ }
+ 
+ struct tree_opt_pass pass_fast_rtl_dce_no_opt =
+ {
+   "dce",                                /* name */
+   gate_fast_dce_no_opt,                 /* gate */
+   rest_of_handle_fast_dce,              /* execute */
+   NULL,                                 /* sub */
+   NULL,                                 /* next */
+   0,                                    /* static_pass_number */
+   TV_DCE,                               /* tv_id */
+   0,                                    /* properties_required */
+   0,                                    /* properties_provided */
+   0,                                    /* properties_destroyed */
+   0,                                    /* todo_flags_start */
+   TODO_dump_func |
+   TODO_df_finish | TODO_verify_rtl_sharing |
+   TODO_ggc_collect,                     /* todo_flags_finish */
+   'w'                                   /* letter */
+ };
*** gcc/passes.c.0	2008-10-15 11:20:46.000000000 +0200
--- gcc/passes.c	2008-10-15 11:21:15.000000000 +0200
*************** init_optimization_passes (void)
*** 730,735 ****
--- 730,736 ----
        NEXT_PASS (pass_split_all_insns);
        NEXT_PASS (pass_lower_subreg2);
        NEXT_PASS (pass_df_initialize_no_opt);
+       NEXT_PASS (pass_fast_rtl_dce_no_opt);
        NEXT_PASS (pass_stack_ptr_mod);
        NEXT_PASS (pass_mode_switching);
        NEXT_PASS (pass_see);
*** gcc/config/ia64/hpux.h.ori	Wed Oct 15 14:20:31 2008
--- gcc/config/ia64/hpux.h	Wed Oct 15 14:22:18 2008
*************** do {							\
*** 65,79 ****
     affect only aCC's C++ library (Rogue Wave-derived) which we do not
     use, and they violate the user's name space.  */
  
  #undef  ASM_EXTRA_SPEC
! #define ASM_EXTRA_SPEC "%{milp32:-milp32} %{mlp64:-mlp64}"
  
  #undef ENDFILE_SPEC
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{!shared:%{static:crt0%O%s} \
! 			  %{mlp64:/usr/lib/hpux64/unix98%O%s} \
! 			  %{!mlp64:/usr/lib/hpux32/unix98%O%s}}"
  
  #undef LINK_SPEC
  #define LINK_SPEC \
--- 65,85 ----
     affect only aCC's C++ library (Rogue Wave-derived) which we do not
     use, and they violate the user's name space.  */
  
+ #undef CC1_SPEC
+ #define CC1_SPEC "%{!milp32:-mlp64} %{G*}"
+ 
+ #undef ASM_SPEC
+ #define ASM_SPEC "-W -x %{mconstant-gp} %{mauto-pic} %(asm_extra)"
+ 
  #undef  ASM_EXTRA_SPEC
! #define ASM_EXTRA_SPEC "%{milp32:-milp32} %{!milp32:-mlp64}"
  
  #undef ENDFILE_SPEC
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{!shared:%{static:crt0%O%s} \
! 			  %{!milp32:/usr/lib/hpux64/unix98%O%s} \
! 			  %{milp32:/usr/lib/hpux32/unix98%O%s}}"
  
  #undef LINK_SPEC
  #define LINK_SPEC \
*** gcc/config/ia64/hpux.h.ori	Wed Oct 15 14:40:38 2008
--- gcc/config/ia64/hpux.h	Wed Oct 15 14:40:43 2008
*************** along with GCC; see the file COPYING3.  
*** 35,40 ****
--- 35,44 ----
  #undef WCHAR_TYPE_SIZE
  #define WCHAR_TYPE_SIZE 32
  
+ /* Widest floating-point type efficiently supported by hardware and OS.  */
+ #undef WIDEST_HARDWARE_FP_SIZE
+ #define WIDEST_HARDWARE_FP_SIZE 64
+ 
  /* Target OS builtins.  */
  #define TARGET_OS_CPP_BUILTINS()			\
  do {							\
*** gcc/config/i386/i386.md.ori	Thu Oct 16 22:46:26 2008
--- gcc/config/i386/i386.md	Thu Oct 16 22:46:36 2008
***************
*** 19943,19961 ****
     (set_attr "mode" "DI")])
  
  (define_insn "allocate_stack_worker_32"
!   [(set (match_operand:SI 0 "register_operand" "+a")
! 	(unspec_volatile:SI [(match_dup 0)] UNSPECV_STACK_PROBE))
     (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
     (clobber (reg:CC FLAGS_REG))]
    "!TARGET_64BIT && ix86_target_stack_probe ()"
!   "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
  
  (define_insn "allocate_stack_worker_64"
!   [(set (match_operand:DI 0 "register_operand" "+a")
! 	(unspec_volatile:DI [(match_dup 0)] UNSPECV_STACK_PROBE))
     (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))
     (clobber (reg:DI R10_REG))
     (clobber (reg:DI R11_REG))
     (clobber (reg:CC FLAGS_REG))]
--- 19943,19972 ----
     (set_attr "mode" "DI")])
  
  (define_insn "allocate_stack_worker_32"
!   [(unspec_volatile:SI [(match_operand:SI 0 "register_operand" "a")]
!                        UNSPECV_STACK_PROBE)
     (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
+    (clobber (match_scratch:SI 1 "=a"))
     (clobber (reg:CC FLAGS_REG))]
    "!TARGET_64BIT && ix86_target_stack_probe ()"
!   "call\t___chkstk"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
  
+ (define_expand "allocate_stack_worker_32_postreload"
+   [(parallel [(unspec_volatile:SI [(match_operand:SI 0 "register_operand" "a")]
+                                    UNSPECV_STACK_PROBE)
+               (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
+               (clobber (match_dup 0))
+               (clobber (reg:CC FLAGS_REG))])]
+   ""
+   "")
+ 
  (define_insn "allocate_stack_worker_64"
!   [(unspec_volatile:DI [(match_operand:DI 0 "register_operand" "a")]
!                        UNSPECV_STACK_PROBE)
     (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))
+    (clobber (match_scratch:DI 1 "=a"))
     (clobber (reg:DI R10_REG))
     (clobber (reg:DI R11_REG))
     (clobber (reg:CC FLAGS_REG))]
***************
*** 19964,19969 ****
--- 19975,19991 ----
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
  
+ (define_expand "allocate_stack_worker_64_postreload"
+   [(parallel [(unspec_volatile:DI [(match_operand:DI 0 "register_operand" "a")]
+                                   UNSPECV_STACK_PROBE)
+               (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))
+               (clobber (match_dup 0))
+               (clobber (reg:DI R10_REG))
+               (clobber (reg:DI R11_REG))
+               (clobber (reg:CC FLAGS_REG))])]
+   ""
+   "")
+ 
  (define_expand "allocate_stack"
    [(match_operand 0 "register_operand" "")
     (match_operand 1 "general_operand" "")]
*** gcc/config/i386/i386.c.ori	Thu Oct 16 22:46:26 2008
--- gcc/config/i386/i386.c	Thu Oct 16 22:46:36 2008
*************** ix86_expand_prologue (void)
*** 7076,7084 ****
        emit_move_insn (eax, GEN_INT (allocate));
  
        if (TARGET_64BIT)
! 	insn = gen_allocate_stack_worker_64 (eax);
        else
! 	insn = gen_allocate_stack_worker_32 (eax);
        insn = emit_insn (insn);
        RTX_FRAME_RELATED_P (insn) = 1;
        t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));
--- 7076,7084 ----
        emit_move_insn (eax, GEN_INT (allocate));
  
        if (TARGET_64BIT)
! 	insn = gen_allocate_stack_worker_64_postreload (eax);
        else
! 	insn = gen_allocate_stack_worker_32_postreload (eax);
        insn = emit_insn (insn);
        RTX_FRAME_RELATED_P (insn) = 1;
        t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));
*** gcc/dbxout.c.0	2008-10-17 10:06:31.000000000 +0200
--- gcc/dbxout.c	2008-10-17 10:21:42.000000000 +0200
*************** dbxout_parms (tree parms)
*** 3244,3251 ****
  	       an erroneous value.  */
  	    eff_type = DECL_ARG_TYPE (parms);
  	  }
! 	else if (REG_P (DECL_RTL (parms)))
  	  {
  	    rtx best_rtl;
  
  	    /* Parm passed in registers and lives in registers or nowhere.  */
--- 3244,3256 ----
  	       an erroneous value.  */
  	    eff_type = DECL_ARG_TYPE (parms);
  	  }
! 	else if (REG_P (DECL_RTL (parms))
! 		 || (GET_CODE (DECL_RTL (parms)) == CONCATN
! 		     && REG_P (XVECEXP (DECL_RTL (parms), 0, 0))))
  	  {
+ 	    rtx raw_rtl = REG_P (DECL_RTL (parms))
+ 			  ? DECL_RTL (parms)
+ 			  : XVECEXP (DECL_RTL (parms), 0, 0);
  	    rtx best_rtl;
  
  	    /* Parm passed in registers and lives in registers or nowhere.  */
*************** dbxout_parms (tree parms)
*** 3262,3269 ****
  	       in practice that register usually holds something else.
  	       If the parm lives nowhere, use the register where it
  	       was passed.  */
! 	    if (REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
! 	      best_rtl = DECL_RTL (parms);
  	    else
  	      best_rtl = DECL_INCOMING_RTL (parms);
  
--- 3267,3276 ----
  	       in practice that register usually holds something else.
  	       If the parm lives nowhere, use the register where it
  	       was passed.  */
! 	    if (REGNO (raw_rtl) < FIRST_PSEUDO_REGISTER)
! 	      best_rtl = raw_rtl;
! 	    else if (GET_CODE (DECL_INCOMING_RTL (parms)) == PARALLEL)
! 	      best_rtl = XEXP (XVECEXP (DECL_INCOMING_RTL (parms), 0, 0), 0);
  	    else
  	      best_rtl = DECL_INCOMING_RTL (parms);
  
*** gcc/basic-block.h.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/basic-block.h	2008-10-19 19:51:01.000000000 +0200
*************** struct edge_def GTY(())
*** 129,135 ****
    /* Auxiliary info specific to a pass.  */
    PTR GTY ((skip (""))) aux;
  
!   /* Location of any goto implicit in the edge, during tree-ssa.  */
    source_locus goto_locus;
  
    /* The index number corresponding to this edge in the edge vector
--- 129,136 ----
    /* Auxiliary info specific to a pass.  */
    PTR GTY ((skip (""))) aux;
  
!   /* Location of any goto implicit in the edge and associated BLOCK.  */
!   tree goto_block;
    source_locus goto_locus;
  
    /* The index number corresponding to this edge in the edge vector
*** gcc/rtl.h.0	2008-10-19 21:34:11.000000000 +0200
--- gcc/rtl.h	2008-10-18 12:39:00.000000000 +0200
*************** extern const char * insn_file (const_rtx
*** 1624,1629 ****
--- 1624,1630 ----
  extern int locator_line (int);
  extern const char * locator_file (int);
  extern bool non_final_source_line (const_rtx);
+ extern bool locator_eq (int, int);
  extern int prologue_locator, epilogue_locator;
  
  /* In jump.c */
*** gcc/cfgcleanup.c.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/cfgcleanup.c	2008-10-19 21:34:44.000000000 +0200
*************** try_forward_edges (int mode, basic_block
*** 428,434 ****
    for (ei = ei_start (b->succs); (e = ei_safe_edge (ei)); )
      {
        basic_block target, first;
!       int counter;
        bool threaded = false;
        int nthreaded_edges = 0;
        bool may_thread = first_pass | df_get_bb_dirty (b);
--- 428,434 ----
    for (ei = ei_start (b->succs); (e = ei_safe_edge (ei)); )
      {
        basic_block target, first;
!       int counter, goto_locus;
        bool threaded = false;
        int nthreaded_edges = 0;
        bool may_thread = first_pass | df_get_bb_dirty (b);
*************** try_forward_edges (int mode, basic_block
*** 446,451 ****
--- 446,452 ----
  
        target = first = e->dest;
        counter = NUM_FIXED_BLOCKS;
+       goto_locus = e->goto_locus;
  
        /* If we are partitioning hot/cold basic_blocks, we don't want to mess
  	 up jumps that cross between hot/cold sections.
*************** try_forward_edges (int mode, basic_block
*** 475,480 ****
--- 476,503 ----
  	      new_target = single_succ (target);
  	      if (target == new_target)
  		counter = n_basic_blocks;
+ 	      else if (!optimize)
+ 		{
+ 		  /* When not optimizing, ensure that edges or forwarder
+ 		     blocks with different locus are not optimized out.  */
+ 		  int locus = single_succ_edge (target)->goto_locus;
+ 
+ 		  if (locus && goto_locus && !locator_eq (locus, goto_locus))
+ 		    counter = n_basic_blocks;
+ 		  else if (locus)
+ 		    goto_locus = locus;
+ 
+ 		  if (INSN_P (BB_END (target)))
+ 		    {
+ 		      locus = INSN_LOCATOR (BB_END (target));
+ 
+ 		      if (locus && goto_locus
+ 			  && !locator_eq (locus, goto_locus))
+ 			counter = n_basic_blocks;
+ 		      else if (locus)
+ 			goto_locus = locus;
+ 		    }
+ 		}
  	    }
  
  	  /* Allow to thread only over one edge at time to simplify updating
*************** try_forward_edges (int mode, basic_block
*** 538,543 ****
--- 561,568 ----
  	  int edge_frequency;
  	  int n = 0;
  
+ 	  e->goto_locus = goto_locus;
+ 
  	  /* Don't force if target is exit block.  */
  	  if (threaded && target != EXIT_BLOCK_PTR)
  	    {
*** gcc/cfgexpand.c.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/cfgexpand.c	2008-10-19 21:07:58.000000000 +0200
*************** expand_gimple_cond_expr (basic_block bb,
*** 1316,1322 ****
        add_reg_br_prob_note (last, true_edge->probability);
        maybe_dump_rtl_for_tree_stmt (stmt, last);
        if (true_edge->goto_locus)
!   	set_curr_insn_source_location (location_from_locus (true_edge->goto_locus));
        false_edge->flags |= EDGE_FALLTHRU;
        return NULL;
      }
--- 1316,1327 ----
        add_reg_br_prob_note (last, true_edge->probability);
        maybe_dump_rtl_for_tree_stmt (stmt, last);
        if (true_edge->goto_locus)
! 	{
! 	  set_curr_insn_source_location (location_from_locus (true_edge->goto_locus));
! 	  set_curr_insn_block (true_edge->goto_block);
! 	  true_edge->goto_locus = curr_insn_locator ();
! 	}
!       true_edge->goto_block = NULL;
        false_edge->flags |= EDGE_FALLTHRU;
        return NULL;
      }
*************** expand_gimple_cond_expr (basic_block bb,
*** 1326,1332 ****
        add_reg_br_prob_note (last, false_edge->probability);
        maybe_dump_rtl_for_tree_stmt (stmt, last);
        if (false_edge->goto_locus)
!   	set_curr_insn_source_location (location_from_locus (false_edge->goto_locus));
        true_edge->flags |= EDGE_FALLTHRU;
        return NULL;
      }
--- 1331,1342 ----
        add_reg_br_prob_note (last, false_edge->probability);
        maybe_dump_rtl_for_tree_stmt (stmt, last);
        if (false_edge->goto_locus)
! 	{
! 	  set_curr_insn_source_location (location_from_locus (false_edge->goto_locus));
! 	  set_curr_insn_block (false_edge->goto_block);
! 	  false_edge->goto_locus = curr_insn_locator ();
! 	}
!       false_edge->goto_block = NULL;
        true_edge->flags |= EDGE_FALLTHRU;
        return NULL;
      }
*************** expand_gimple_cond_expr (basic_block bb,
*** 1334,1339 ****
--- 1344,1356 ----
    jumpif (pred, label_rtx_for_bb (true_edge->dest));
    add_reg_br_prob_note (last, true_edge->probability);
    last = get_last_insn ();
+   if (false_edge->goto_locus)
+     {
+       set_curr_insn_source_location (location_from_locus (false_edge->goto_locus));
+       set_curr_insn_block (false_edge->goto_block);
+       false_edge->goto_locus = curr_insn_locator ();
+     }
+   false_edge->goto_block = NULL;
    emit_jump (label_rtx_for_bb (false_edge->dest));
  
    BB_END (bb) = last;
*************** expand_gimple_cond_expr (basic_block bb,
*** 1356,1363 ****
  
    maybe_dump_rtl_for_tree_stmt (stmt, last2);
  
!   if (false_edge->goto_locus)
!     set_curr_insn_source_location (location_from_locus (false_edge->goto_locus));
  
    return new_bb;
  }
--- 1373,1385 ----
  
    maybe_dump_rtl_for_tree_stmt (stmt, last2);
  
!   if (true_edge->goto_locus)
!     {
!       set_curr_insn_source_location (location_from_locus (true_edge->goto_locus));
!       set_curr_insn_block (true_edge->goto_block);
!       true_edge->goto_locus = curr_insn_locator ();
!     }
!   true_edge->goto_block = NULL;
  
    return new_bb;
  }
*************** expand_gimple_basic_block (basic_block b
*** 1613,1631 ****
  	}
      }
  
!   /* Expand implicit goto.  */
    FOR_EACH_EDGE (e, ei, bb->succs)
      {
!       if (e->flags & EDGE_FALLTHRU)
! 	break;
!     }
! 
!   if (e && e->dest != bb->next_bb)
!     {
!       emit_jump (label_rtx_for_bb (e->dest));
!       if (e->goto_locus)
!         set_curr_insn_source_location (location_from_locus (e->goto_locus));
!       e->flags &= ~EDGE_FALLTHRU;
      }
  
    do_pending_stack_adjust ();
--- 1635,1655 ----
  	}
      }
  
!   /* Expand implicit goto and convert goto_locus.  */
    FOR_EACH_EDGE (e, ei, bb->succs)
      {
!       if (e->goto_locus && e->goto_block)
! 	{
! 	  set_curr_insn_source_location (location_from_locus (e->goto_locus));
! 	  set_curr_insn_block (e->goto_block);
! 	  e->goto_locus = curr_insn_locator ();
! 	}
!       e->goto_block = NULL;
!       if ((e->flags & EDGE_FALLTHRU) && e->dest != bb->next_bb)
! 	{
! 	  emit_jump (label_rtx_for_bb (e->dest));
! 	  e->flags &= ~EDGE_FALLTHRU;
! 	}
      }
  
    do_pending_stack_adjust ();
*** gcc/cfglayout.c.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/cfglayout.c	2008-10-19 21:34:44.000000000 +0200
*************** change_scope (rtx orig_insn, tree s1, tr
*** 448,460 ****
      }
  }
  
! /* Return lexical scope block insn belong to.  */
  static tree
! insn_scope (const_rtx insn)
  {
    int max = VEC_length (int, block_locators_locs);
    int min = 0;
-   int loc = INSN_LOCATOR (insn);
  
    /* When block_locators_locs was initialized, the pro- and epilogue
       insns didn't exist yet and can therefore not be found this way.
--- 448,459 ----
      }
  }
  
! /* Return lexical scope block locator belongs to.  */
  static tree
! locator_scope (int loc)
  {
    int max = VEC_length (int, block_locators_locs);
    int min = 0;
  
    /* When block_locators_locs was initialized, the pro- and epilogue
       insns didn't exist yet and can therefore not be found this way.
*************** insn_scope (const_rtx insn)
*** 488,493 ****
--- 487,499 ----
    return VEC_index (tree, block_locators_blocks, min);
  }
  
+ /* Return lexical scope block insn belongs to.  */
+ static tree
+ insn_scope (const_rtx insn)
+ {
+   return locator_scope (INSN_LOCATOR (insn));
+ }
+ 
  /* Return line number of the statement specified by the locator.  */
  static location_t
  locator_location (int loc)
*************** non_final_source_line (const_rtx insn)
*** 577,582 ****
--- 583,599 ----
    return true;
  }
  
+ /* Return true if LOC1 and LOC2 locators have the same location and scope.  */
+ bool
+ locator_eq (int loc1, int loc2)
+ {
+   if (loc1 == loc2)
+     return true;
+   if (locator_location (loc1) != locator_location (loc2))
+     return false;
+   return locator_scope (loc1) == locator_scope (loc2);
+ }
+ 
  /* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based
     on the scope tree and the newly reordered instructions.  */
  
*************** fixup_reorder_chain (void)
*** 914,919 ****
--- 931,982 ----
        if (e && !can_fallthru (e->src, e->dest))
  	force_nonfallthru (e);
      }
+ 
+   /* Ensure goto_locus from edges has some instructions with that locus
+      in RTL.  */
+   if (!optimize)
+     FOR_EACH_BB (bb)
+       {
+         edge e;
+         edge_iterator ei;
+ 
+         FOR_EACH_EDGE (e, ei, bb->succs)
+ 	  if (e->goto_locus && !(e->flags & EDGE_ABNORMAL))
+ 	    {
+ 	      basic_block nb;
+ 	      rtx end;
+ 
+ 	      insn = BB_END (e->src);
+ 	      end = PREV_INSN (BB_HEAD (e->src));
+ 	      while (insn != end
+ 		     && (!INSN_P (insn) || INSN_LOCATOR (insn) == 0))
+ 		insn = PREV_INSN (insn);
+ 	      if (insn != end
+ 		  && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))
+ 		continue;
+ 	      if (simplejump_p (BB_END (e->src))
+ 		  && INSN_LOCATOR (BB_END (e->src)) == 0)
+ 		{
+ 		  INSN_LOCATOR (BB_END (e->src)) = e->goto_locus;
+ 		  continue;
+ 		}
+ 	      if (e->dest != EXIT_BLOCK_PTR)
+ 		{
+ 		  insn = BB_HEAD (e->dest);
+ 		  end = NEXT_INSN (BB_END (e->dest));
+ 		  while (insn != end && !INSN_P (insn))
+ 		    insn = NEXT_INSN (insn);
+ 		  if (insn != end && INSN_LOCATOR (insn)
+ 		      && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))
+ 		    continue;
+ 		}
+ 	      nb = split_edge (e);
+ 	      if (!INSN_P (BB_END (nb)))
+ 		BB_END (nb) = emit_insn_after_noloc (gen_nop (), BB_END (nb),
+ 						     nb);
+ 	      INSN_LOCATOR (BB_END (nb)) = e->goto_locus;
+ 	    }
+       }
  }
  
  /* Perform sanity checks on the insn chain.
*** gcc/cfgrtl.c.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/cfgrtl.c	2008-10-19 21:34:44.000000000 +0200
*************** force_nonfallthru_and_redirect (edge e, 
*** 1012,1017 ****
--- 1012,1018 ----
    rtx note;
    edge new_edge;
    int abnormal_edge_flags = 0;
+   int loc;
  
    /* In the case the last instruction is conditional jump to the next
       instruction, first redirect the jump itself and then continue
*************** force_nonfallthru_and_redirect (edge e, 
*** 1134,1144 ****
    else
      jump_block = e->src;
  
    e->flags &= ~EDGE_FALLTHRU;
    if (target == EXIT_BLOCK_PTR)
      {
  #ifdef HAVE_return
! 	emit_jump_insn_after_noloc (gen_return (), BB_END (jump_block));
  #else
  	gcc_unreachable ();
  #endif
--- 1135,1149 ----
    else
      jump_block = e->src;
  
+   if (e->goto_locus && e->goto_block == NULL)
+     loc = e->goto_locus;
+   else
+     loc = 0;
    e->flags &= ~EDGE_FALLTHRU;
    if (target == EXIT_BLOCK_PTR)
      {
  #ifdef HAVE_return
! 	emit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);
  #else
  	gcc_unreachable ();
  #endif
*************** force_nonfallthru_and_redirect (edge e, 
*** 1146,1152 ****
    else
      {
        rtx label = block_label (target);
!       emit_jump_insn_after_noloc (gen_jump (label), BB_END (jump_block));
        JUMP_LABEL (BB_END (jump_block)) = label;
        LABEL_NUSES (label)++;
      }
--- 1151,1157 ----
    else
      {
        rtx label = block_label (target);
!       emit_jump_insn_after_setloc (gen_jump (label), BB_END (jump_block), loc);
        JUMP_LABEL (BB_END (jump_block)) = label;
        LABEL_NUSES (label)++;
      }
*************** cfg_layout_merge_blocks (basic_block a, 
*** 2614,2619 ****
--- 2619,2652 ----
      try_redirect_by_replacing_jump (EDGE_SUCC (a, 0), b, true);
    gcc_assert (!JUMP_P (BB_END (a)));
  
+   /* When not optimizing and the edge is the only place in RTL which holds
+      some unique locus, emit a nop with that locus in between.  */
+   if (!optimize && EDGE_SUCC (a, 0)->goto_locus)
+     {
+       rtx insn = BB_END (a), end = PREV_INSN (BB_HEAD (a));
+       int goto_locus = EDGE_SUCC (a, 0)->goto_locus;
+ 
+       while (insn != end && (!INSN_P (insn) || INSN_LOCATOR (insn) == 0))
+ 	insn = PREV_INSN (insn);
+       if (insn != end && locator_eq (INSN_LOCATOR (insn), goto_locus))
+ 	goto_locus = 0;
+       else
+ 	{
+ 	  insn = BB_HEAD (b);
+ 	  end = NEXT_INSN (BB_END (b));
+ 	  while (insn != end && !INSN_P (insn))
+ 	    insn = NEXT_INSN (insn);
+ 	  if (insn != end && INSN_LOCATOR (insn) != 0
+ 	      && locator_eq (INSN_LOCATOR (insn), goto_locus))
+ 	    goto_locus = 0;
+ 	}
+       if (goto_locus)
+ 	{
+ 	  BB_END (a) = emit_insn_after_noloc (gen_nop (), BB_END (a), a);
+ 	  INSN_LOCATOR (BB_END (a)) = goto_locus;
+ 	}
+     }
+ 
    /* Possible line number notes should appear in between.  */
    if (b->il.rtl->header)
      {
*** gcc/gimple-low.c.0	2008-10-19 21:11:00.000000000 +0200
--- gcc/gimple-low.c	2008-10-19 21:27:53.000000000 +0200
*************** lower_function_body (void)
*** 94,99 ****
--- 94,100 ----
      {
        x = build1 (RETURN_EXPR, void_type_node, NULL);
        SET_EXPR_LOCATION (x, cfun->function_end_locus);
+       TREE_BLOCK (x) = DECL_INITIAL (current_function_decl);
        tsi_link_after (&i, x, TSI_CONTINUE_LINKING);
      }
  
*************** lower_return_expr (tree_stmt_iterator *t
*** 589,594 ****
--- 590,596 ----
   found:
    t = build1 (GOTO_EXPR, void_type_node, label);
    SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+   TREE_BLOCK (t) = TREE_BLOCK (stmt);
    tsi_link_before (tsi, t, TSI_SAME_STMT);
    tsi_delink (tsi);
  }
*************** lower_builtin_setjmp (tree_stmt_iterator
*** 671,676 ****
--- 673,679 ----
    t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];
    t = build_call_expr (t, 2, CALL_EXPR_ARG (stmt, 0), arg);
    SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+   TREE_BLOCK (t) = TREE_BLOCK (stmt);
    tsi_link_before (tsi, t, TSI_SAME_STMT);
  
    /* Build 'DEST = 0' and insert.  */
*************** lower_builtin_setjmp (tree_stmt_iterator
*** 679,684 ****
--- 682,688 ----
        t = build_gimple_modify_stmt (dest, fold_convert (TREE_TYPE (dest),
  							integer_zero_node));
        SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+       GIMPLE_STMT_BLOCK (t) = TREE_BLOCK (stmt);
        tsi_link_before (tsi, t, TSI_SAME_STMT);
      }
  
*************** lower_builtin_setjmp (tree_stmt_iterator
*** 695,700 ****
--- 699,705 ----
    t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];
    t = build_call_expr (t, 1, arg);
    SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+   TREE_BLOCK (t) = TREE_BLOCK (stmt);
    tsi_link_before (tsi, t, TSI_SAME_STMT);
  
    /* Build 'DEST = 1' and insert.  */
*************** lower_builtin_setjmp (tree_stmt_iterator
*** 703,708 ****
--- 708,714 ----
        t = build_gimple_modify_stmt (dest, fold_convert (TREE_TYPE (dest),
  							integer_one_node));
        SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+       GIMPLE_STMT_BLOCK (t) = TREE_BLOCK (stmt);
        tsi_link_before (tsi, t, TSI_SAME_STMT);
      }
  
*** gcc/profile.c.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/profile.c	2008-10-19 20:02:26.000000000 +0200
*************** branch_prob (void)
*** 818,831 ****
  	      && (LOCATION_FILE (e->goto_locus)
  	          != LOCATION_FILE (EXPR_LOCATION  (last))
  		  || (LOCATION_LINE (e->goto_locus)
! 		      != LOCATION_LINE (EXPR_LOCATION  (last)))))
  #else
  	      && (e->goto_locus->file != EXPR_LOCUS (last)->file
  		  || (e->goto_locus->line != EXPR_LOCUS (last)->line)))
  #endif
  	    {
! 	      basic_block new = split_edge (e);
! 	      single_succ_edge (new)->goto_locus = e->goto_locus;
  	    }
  	  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))
  	       && e->dest != EXIT_BLOCK_PTR)
--- 818,833 ----
  	      && (LOCATION_FILE (e->goto_locus)
  	          != LOCATION_FILE (EXPR_LOCATION  (last))
  		  || (LOCATION_LINE (e->goto_locus)
! 		      != LOCATION_LINE (EXPR_LOCATION (last)))))
  #else
  	      && (e->goto_locus->file != EXPR_LOCUS (last)->file
  		  || (e->goto_locus->line != EXPR_LOCUS (last)->line)))
  #endif
  	    {
! 	      basic_block new_bb = split_edge (e);
! 	      edge ne = single_succ_edge (new_bb);
! 	      ne->goto_locus = e->goto_locus;
! 	      ne->goto_block = e->goto_block;
  	    }
  	  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))
  	       && e->dest != EXIT_BLOCK_PTR)
*** gcc/tree-cfg.c.0	2008-10-19 19:49:07.000000000 +0200
--- gcc/tree-cfg.c	2008-10-19 21:30:12.000000000 +0200
*************** make_cond_expr_edges (basic_block bb)
*** 633,638 ****
--- 633,640 ----
  #else
    e->goto_locus = EXPR_LOCUS (COND_EXPR_THEN (entry));
  #endif
+   if (e->goto_locus)
+     e->goto_block = TREE_BLOCK (COND_EXPR_THEN (entry));
    e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);
    if (e)
      {
*************** make_cond_expr_edges (basic_block bb)
*** 641,646 ****
--- 643,650 ----
  #else
        e->goto_locus = EXPR_LOCUS (COND_EXPR_ELSE (entry));
  #endif
+       if (e->goto_locus)
+ 	e->goto_block = TREE_BLOCK (COND_EXPR_ELSE (entry));
      }
  
    /* We do not need the gotos anymore.  */
*************** make_goto_expr_edges (basic_block bb)
*** 840,845 ****
--- 844,851 ----
  #else
        e->goto_locus = EXPR_LOCUS (goto_t);
  #endif
+       if (e->goto_locus)
+ 	e->goto_block = TREE_BLOCK (goto_t);
        bsi_remove (&last, true);
        return;
      }
*************** move_block_to_fn (struct function *dest_
*** 5871,5876 ****
--- 5877,5887 ----
        update_stmt (stmt);
        pop_cfun ();
      }
+ 
+   if (d.block)
+     FOR_EACH_EDGE (e, ei, bb->succs)
+       if (e->goto_locus)
+ 	e->goto_block = d.block;
  }
  
  /* Examine the statements in BB (which is in SRC_CFUN); find and return
*** gcc/tree-ssa-live.c.0	2008-10-19 21:11:00.000000000 +0200
--- gcc/tree-ssa-live.c	2008-10-19 21:32:52.000000000 +0200
*************** remove_unused_locals (void)
*** 592,597 ****
--- 592,599 ----
      {
        block_stmt_iterator bsi;
        tree phi, def;
+       edge_iterator ei;
+       edge e;
  
        /* Walk the statements.  */
        for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))
*************** remove_unused_locals (void)
*** 615,620 ****
--- 617,626 ----
  	      mark_all_vars_used (&arg, NULL);
              }
          }
+ 
+       FOR_EACH_EDGE (e, ei, bb->succs)
+ 	if (e->goto_locus)
+ 	  TREE_USED (e->goto_block) = true;
      }
  
    /* Remove unmarked local vars from unexpanded_var_list.  */
*** gcc/config/rs6000/vxworks.h.ori	Mon Oct 20 16:44:32 2008
--- gcc/config/rs6000/vxworks.h	Mon Oct 20 16:58:28 2008
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 120,128 ****
  /* Override sysv4.h, reset to the default.  */
  #undef  PREFERRED_STACK_BOUNDARY
  
! /* Make -mcpu=8540 imply SPE.  ISEL is automatically enabled, the
!    others must be done by hand.  Handle -mrtp.  Disable -fPIC
!    for -mrtp - the VxWorks PIC model is not compatible with it.  */
  #undef SUBSUBTARGET_OVERRIDE_OPTIONS
  #define SUBSUBTARGET_OVERRIDE_OPTIONS		\
    do {						\
--- 120,129 ----
  /* Override sysv4.h, reset to the default.  */
  #undef  PREFERRED_STACK_BOUNDARY
  
! /* Make -mcpu=8540 imply SPE.  ISEL is automatically enabled, the others must
!    be done by hand.  Be careful not to downgrade explicit settings already
!    there.  Handle -mrtp.  Disable -fPIC for -mrtp - the VxWorks PIC model is
!    not compatible with it.  */
  #undef SUBSUBTARGET_OVERRIDE_OPTIONS
  #define SUBSUBTARGET_OVERRIDE_OPTIONS		\
    do {						\
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 130,136 ****
        {						\
  	rs6000_spe = 1;				\
  	rs6000_spe_abi = 1;			\
! 	rs6000_float_gprs = 1;			\
        }						\
  						\
    if (!g_switch_set)				\
--- 131,137 ----
        {						\
  	rs6000_spe = 1;				\
  	rs6000_spe_abi = 1;			\
! 	rs6000_float_gprs = MAX (rs6000_float_gprs, 1);	\
        }						\
  						\
    if (!g_switch_set)				\
*** gcc/calls.c.0	2008-10-26 19:34:53.000000000 +0100
--- gcc/calls.c	2008-10-26 19:42:56.000000000 +0100
*************** restore_fixed_argument_area (rtx save_ar
*** 867,879 ****
  static void
  store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)
  {
    int i, j;
  
    for (i = 0; i < num_actuals; i++)
      if (args[i].reg != 0 && ! args[i].pass_on_stack
  	&& args[i].mode == BLKmode
! 	&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))
! 	    < (unsigned int) MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))
        {
  	int bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
  	int endian_correction = 0;
--- 867,880 ----
  static void
  store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)
  {
+   const unsigned int ralign = MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD);
    int i, j;
  
    for (i = 0; i < num_actuals; i++)
      if (args[i].reg != 0 && ! args[i].pass_on_stack
  	&& args[i].mode == BLKmode
! 	&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value)) < ralign
! 	    || (MEM_P (args[i].value) && MEM_ALIGN (args[i].value) < ralign)))
        {
  	int bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
  	int endian_correction = 0;
*** gcc/config/rs6000/sysv4.h	(revision 124006)
--- gcc/config/rs6000/sysv4.h	(revision 124005)
*************** extern int fixuplabelno;
*** 755,761 ****
    mcall-openbsd: %(startfile_openbsd)     ; \
                 : %(startfile_default)     }"
  
! #define	STARTFILE_DEFAULT_SPEC "ecrti.o%s crtbegin.o%s"
  
  /* Override svr4.h definition.  */
  #undef	LIB_SPEC
--- 755,761 ----
    mcall-openbsd: %(startfile_openbsd)     ; \
                 : %(startfile_default)     }"
  
! #define	STARTFILE_DEFAULT_SPEC ""
  
  /* Override svr4.h definition.  */
  #undef	LIB_SPEC
*************** extern int fixuplabelno;
*** 772,778 ****
    mcall-openbsd: %(lib_openbsd)     ; \
                 : %(lib_default)     }"
  
! #define LIB_DEFAULT_SPEC "-lc"
  
  /* Override svr4.h definition.  */
  #undef	ENDFILE_SPEC
--- 772,778 ----
    mcall-openbsd: %(lib_openbsd)     ; \
                 : %(lib_default)     }"
  
! #define LIB_DEFAULT_SPEC ""
  
  /* Override svr4.h definition.  */
  #undef	ENDFILE_SPEC
*************** extern int fixuplabelno;
*** 791,797 ****
  
  #define CRTSAVRES_DEFAULT_SPEC "crtsavres.o%s"
  
! #define	ENDFILE_DEFAULT_SPEC "crtend.o%s ecrtn.o%s"
  
  /* Motorola ADS support.  */
  #define LIB_ADS_SPEC "--start-group -lads -lc --end-group"
--- 791,797 ----
  
  #define CRTSAVRES_DEFAULT_SPEC "crtsavres.o%s"
  
! #define	ENDFILE_DEFAULT_SPEC ""
  
  /* Motorola ADS support.  */
  #define LIB_ADS_SPEC "--start-group -lads -lc --end-group"
*** gcc/config/i386/i386.c.0	2008-10-29 20:08:47.000000000 +0100
--- gcc/config/i386/i386.c	2008-10-29 21:00:18.000000000 +0100
*************** classify_argument (enum machine_mode mod
*** 3813,3819 ****
  	    /* The partial classes are now full classes.  */
  	    if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)
  	      subclasses[0] = X86_64_SSE_CLASS;
! 	    if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)
  	      subclasses[0] = X86_64_INTEGER_CLASS;
  
  	    for (i = 0; i < words; i++)
--- 3813,3820 ----
  	    /* The partial classes are now full classes.  */
  	    if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)
  	      subclasses[0] = X86_64_SSE_CLASS;
! 	    if (subclasses[0] == X86_64_INTEGERSI_CLASS
! 		&& !((bit_offset % 64) == 0 && bytes == 4))
  	      subclasses[0] = X86_64_INTEGER_CLASS;
  
  	    for (i = 0; i < words; i++)
*** gcc/config/i386/darwin.h.old	Fri Oct 31 16:33:59 2008
--- gcc/config/i386/darwin.h	Tue Nov  4 10:35:12 2008
*************** extern void darwin_x86_file_end (void);
*** 297,299 ****
--- 297,305 ----
     used in Mach-O.  */
  #undef MACHO_SYMBOL_FLAG_VARIABLE
  #define MACHO_SYMBOL_FLAG_VARIABLE ((SYMBOL_FLAG_MACH_DEP) << 3)
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* An alternate stack is used to recover.  Use a small offset.  */
+ #define STACK_CHECK_PROTECT 64
*** gcc/tree.h.ori	Fri Oct 31 15:36:25 2008
--- gcc/tree.h	Fri Oct 31 16:59:09 2008
*************** struct tree_vec GTY(())
*** 1578,1583 ****
--- 1578,1588 ----
      _ce___->value = VALUE; \
    } while (0)
  
+ /* True if NODE, a FIELD_DECL, is to be processed as a bitfield for
+    constructor output purposes.  */
+ #define CONSTRUCTOR_BITFIELD_P(NODE) \
+   ((DECL_BIT_FIELD (FIELD_DECL_CHECK (NODE)) && DECL_MODE (NODE) != BLKmode))
+ 
  /* A single element of a CONSTRUCTOR. VALUE holds the actual value of the
     element. INDEX can optionally design the position of VALUE: in arrays,
     it is the index where VALUE has to be placed; in structures, it is the
*** gcc/varasm.c.ori	Thu Oct 30 11:15:22 2008
--- gcc/varasm.c	Fri Oct 31 16:03:24 2008
*************** output_constructor (tree exp, unsigned H
*** 5069,5077 ****
        /* For a field that is neither a true bitfield nor part of an outer one,
  	 known to be at least byte aligned and multiple-of-bytes long.  */
        else if (!outer
! 	       && (local.field == 0
! 		   || !DECL_BIT_FIELD (local.field)
! 		   || DECL_MODE (local.field) == BLKmode))
  	output_constructor_regular_field (&local);
        
        /* For a true bitfield or part of an outer one.  */
--- 5069,5075 ----
        /* For a field that is neither a true bitfield nor part of an outer one,
  	 known to be at least byte aligned and multiple-of-bytes long.  */
        else if (!outer
! 	       && (local.field == 0 || !CONSTRUCTOR_BITFIELD_P (local.field)))
  	output_constructor_regular_field (&local);
        
        /* For a true bitfield or part of an outer one.  */
*** gcc/config/i386/cygming.h.0	2008-11-11 00:12:30.000000000 +0100
--- gcc/config/i386/cygming.h	2008-11-07 13:13:00.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 55,61 ****
     won't allow it.  */
  #define ASM_OUTPUT_DWARF_OFFSET(FILE, SIZE, LABEL, SECTION)	\
    do {								\
!     if (SIZE != 4)						\
        abort ();							\
  								\
      fputs ("\t.secrel32\t", FILE);				\
--- 55,61 ----
     won't allow it.  */
  #define ASM_OUTPUT_DWARF_OFFSET(FILE, SIZE, LABEL, SECTION)	\
    do {								\
!     if (SIZE != 4 && (!TARGET_64BIT || SIZE != 8))		\
        abort ();							\
  								\
      fputs ("\t.secrel32\t", FILE);				\
*** gcc/config/i386/i386.c.0	2008-11-11 00:12:30.000000000 +0100
--- gcc/config/i386/i386.c	2008-11-11 00:15:12.000000000 +0100
*************** function_arg_64 (CUMULATIVE_ARGS *cum, e
*** 4465,4471 ****
  
  static rtx
  function_arg_ms_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,
! 		    enum machine_mode orig_mode, int named)
  {
    unsigned int regno;
  
--- 4465,4472 ----
  
  static rtx
  function_arg_ms_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,
! 		    enum machine_mode orig_mode, int named,
! 		    HOST_WIDE_INT bytes)
  {
    unsigned int regno;
  
*************** function_arg_ms_64 (CUMULATIVE_ARGS *cum
*** 4497,4502 ****
--- 4498,4511 ----
  	  return gen_rtx_PARALLEL (mode, gen_rtvec (2, t1, t2));
  	}
      }
+   /* Handle aggregated types passed in register.  */
+   if (orig_mode == BLKmode)
+     {
+       if (bytes > 0 && bytes <= 8)
+         mode = (bytes > 4 ? DImode : SImode);
+       if (mode == BLKmode)
+         mode = DImode;
+     }
  
    return gen_reg_or_parallel (mode, orig_mode, regno);
  }
*************** function_arg (CUMULATIVE_ARGS *cum, enum
*** 4520,4526 ****
      mode = type_natural_mode (type);
  
    if (TARGET_64BIT_MS_ABI)
!     return function_arg_ms_64 (cum, mode, omode, named);
    else if (TARGET_64BIT)
      return function_arg_64 (cum, mode, omode, type);
    else
--- 4529,4535 ----
      mode = type_natural_mode (type);
  
    if (TARGET_64BIT_MS_ABI)
!     return function_arg_ms_64 (cum, mode, omode, named, bytes);
    else if (TARGET_64BIT)
      return function_arg_64 (cum, mode, omode, type);
    else
*************** ix86_pass_by_reference (CUMULATIVE_ARGS 
*** 4538,4545 ****
--- 4547,4556 ----
  			enum machine_mode mode ATTRIBUTE_UNUSED,
  			const_tree type, bool named ATTRIBUTE_UNUSED)
  {
+   /* See Windows x64 Software Convention.  */
    if (TARGET_64BIT_MS_ABI)
      {
+       int msize = (int) GET_MODE_SIZE (mode);
        if (type)
  	{
  	  /* Arrays are passed by reference.  */
*************** ix86_pass_by_reference (CUMULATIVE_ARGS 
*** 4550,4565 ****
  	    {
  	      /* Structs/unions of sizes other than 8, 16, 32, or 64 bits
  	         are passed by reference.  */
! 	      int el2 = exact_log2 (int_size_in_bytes (type));
! 	      return !(el2 >= 0 && el2 <= 3);
  	    }
  	}
  
        /* __m128 is passed by reference.  */
!       /* ??? How to handle complex?  For now treat them as structs,
! 	 and pass them by reference if they're too large.  */
!       if (GET_MODE_SIZE (mode) > 8)
! 	return true;
      }
    else if (TARGET_64BIT && type && int_size_in_bytes (type) == -1)
      return 1;
--- 4561,4577 ----
  	    {
  	      /* Structs/unions of sizes other than 8, 16, 32, or 64 bits
  	         are passed by reference.  */
! 	      msize = int_size_in_bytes (type);
  	    }
  	}
  
        /* __m128 is passed by reference.  */
!       switch (msize) {
!       case 1: case 2: case 4: case 8:
!         break;
!       default:
!         return true;
!       }
      }
    else if (TARGET_64BIT && type && int_size_in_bytes (type) == -1)
      return 1;
*************** function_value_ms_64 (enum machine_mode 
*** 4772,4783 ****
  
    if (TARGET_SSE)
      {
!       if (mode == SFmode || mode == DFmode)
! 	regno = FIRST_SSE_REG;
!       else if (VECTOR_MODE_P (mode) || GET_MODE_SIZE (mode) == 16)
! 	regno = FIRST_SSE_REG;
      }
- 
    return gen_rtx_REG (orig_mode, regno);
  }
  
--- 4784,4805 ----
  
    if (TARGET_SSE)
      {
!       switch (GET_MODE_SIZE (mode))
!         {
!         case 16:
!           if((SCALAR_INT_MODE_P (mode) || VECTOR_MODE_P (mode))
! 	     && !COMPLEX_MODE_P (mode))
! 	    regno = FIRST_SSE_REG;
! 	  break;
! 	case 8:
! 	case 4:
! 	  if (mode == SFmode || mode == DFmode)
! 	    regno = FIRST_SSE_REG;
! 	  break;
! 	default:
! 	  break;
!         }
      }
    return gen_rtx_REG (orig_mode, regno);
  }
  
*************** return_in_memory_ms_64 (const_tree type,
*** 4871,4878 ****
  {
    HOST_WIDE_INT size = int_size_in_bytes (type);
  
!   /* __m128 and friends are returned in xmm0.  */
!   if (!COMPLEX_MODE_P (mode) && size == 16 && VECTOR_MODE_P (mode))
      return 0;
  
    /* Otherwise, the size must be exactly in [1248]. But not for complex. */
--- 4893,4901 ----
  {
    HOST_WIDE_INT size = int_size_in_bytes (type);
  
!   /* __m128 is returned in xmm0.  */
!   if ((SCALAR_INT_MODE_P (mode) || VECTOR_MODE_P (mode))
!       && !COMPLEX_MODE_P (mode) && (GET_MODE_SIZE (mode) == 16 || size == 16))
      return 0;
  
    /* Otherwise, the size must be exactly in [1248]. But not for complex. */
*************** ix86_file_end (void)
*** 5861,5871 ****
  	  switch_to_section (text_section);
  	  ASM_OUTPUT_LABEL (asm_out_file, name);
  	}
! 
!       xops[0] = gen_rtx_REG (SImode, regno);
!       xops[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);
!       output_asm_insn ("mov{l}\t{%1, %0|%0, %1}", xops);
!       output_asm_insn ("ret", xops);
      }
  
    if (NEED_INDICATE_EXEC_STACK)
--- 5884,5903 ----
  	  switch_to_section (text_section);
  	  ASM_OUTPUT_LABEL (asm_out_file, name);
  	}
!       if (TARGET_64BIT_MS_ABI)
!         {
! 	  xops[0] = gen_rtx_REG (Pmode, regno);
! 	  xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);
! 	  output_asm_insn ("mov{q}\t{%1, %0|%0, %1}", xops);
! 	  output_asm_insn ("ret", xops);
!         }
!       else
!         {
! 	  xops[0] = gen_rtx_REG (SImode, regno);
! 	  xops[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);
! 	  output_asm_insn ("mov{l}\t{%1, %0|%0, %1}", xops);
! 	  output_asm_insn ("ret", xops);
! 	}
      }
  
    if (NEED_INDICATE_EXEC_STACK)
*** gcc/ipa-inline.c.0	2008-11-04 14:43:43.000000000 +0100
--- gcc/ipa-inline.c	2008-11-06 15:45:44.000000000 +0100
*************** cgraph_estimate_growth (struct cgraph_no
*** 312,329 ****
  {
    int growth = 0;
    struct cgraph_edge *e;
    if (node->global.estimated_growth != INT_MIN)
      return node->global.estimated_growth;
  
    for (e = node->callers; e; e = e->next_caller)
!     if (e->inline_failed)
!       growth += (cgraph_estimate_size_after_inlining (1, e->caller, node)
! 		 - e->caller->global.insns);
  
!   /* ??? Wrong for self recursive functions or cases where we decide to not
!      inline for different reasons, but it is not big deal as in that case
!      we will keep the body around, but we will also avoid some inlining.  */
!   if (!node->needed && !DECL_EXTERNAL (node->decl))
      growth -= node->global.insns;
  
    node->global.estimated_growth = growth;
--- 312,336 ----
  {
    int growth = 0;
    struct cgraph_edge *e;
+   bool self_recursive = false;
+ 
    if (node->global.estimated_growth != INT_MIN)
      return node->global.estimated_growth;
  
    for (e = node->callers; e; e = e->next_caller)
!     {
!       if (e->caller == node)
!         self_recursive = true;
!       if (e->inline_failed)
! 	growth += (cgraph_estimate_size_after_inlining (1, e->caller, node)
! 		   - e->caller->global.insns);
!     }
  
!   /* ??? Wrong for non-trivially self recursive functions or cases where
!      we decide to not inline for different reasons, but it is not big deal
!      as in that case we will keep the body around, but we will also avoid
!      some inlining.  */
!   if (!node->needed && !DECL_EXTERNAL (node->decl) && !self_recursive)
      growth -= node->global.insns;
  
    node->global.estimated_growth = growth;
*** gcc/config/sparc/leon.h.old	Fri Nov  7 18:39:12 2008
--- gcc/config/sparc/leon.h	Fri Nov  7 18:44:51 2008
*************** Boston, MA 02110-1301, USA.  */
*** 22,28 ****
  /* Use the required linker script file (if none has been specified) */
  
  #undef LINK_SPEC
! #define LINK_SPEC "%{!T:-T leon.ld%s}"
  
  /* Make the BSP and the C library available */
  
--- 22,28 ----
  /* Use the required linker script file (if none has been specified) */
  
  #undef LINK_SPEC
! #define LINK_SPEC "%{!T:%{micsdm:-T leon2_icsdm.ld%s} %{!micsdm:-T leon.ld%s}}"
  
  /* Make the BSP and the C library available */
  
*************** Boston, MA 02110-1301, USA.  */
*** 34,40 ****
     crtbegin/crtend and crti/crtn machinery. */
  
  #undef STARTFILE_SPEC
! #define STARTFILE_SPEC "crt0.o%s"
  
  #undef ENDFILE_SPEC
  #define ENDFILE_SPEC ""
--- 34,40 ----
     crtbegin/crtend and crti/crtn machinery. */
  
  #undef STARTFILE_SPEC
! #define STARTFILE_SPEC "%{micsdm:crt0_icsdm.o%s} %{!micsdm:crt0.o%s}"
  
  #undef ENDFILE_SPEC
  #define ENDFILE_SPEC ""
*** gcc/dbxout.c.0	2009-04-28 13:29:07.000000000 +0200
--- gcc/dbxout.c	2009-05-09 22:23:04.000000000 +0200
*************** dbxout_type (tree type, int full)
*** 1709,1714 ****
--- 1709,1721 ----
        vector_type = true;
      }
  
+   /* If this is a subtype that should not be emitted as a subrange type,
+      use the base type.  */
+   if (TREE_CODE (type) == INTEGER_TYPE
+       && TREE_TYPE (type) != NULL_TREE
+       && !subrange_type_for_debug_p (type))
+     type = TREE_TYPE (type);
+ 
    /* If there was an input error and we don't really have a type,
       avoid crashing and write something that is at least valid
       by assuming `int'.  */
*** gcc/dwarf2out.c.0	2009-04-28 13:29:07.000000000 +0200
--- gcc/dwarf2out.c	2009-05-09 22:23:04.000000000 +0200
*************** static void output_line_info (void);
*** 4468,4474 ****
  static void output_file_names (void);
  static dw_die_ref base_type_die (tree);
  static int is_base_type (tree);
- static bool is_subrange_type (const_tree);
  static dw_die_ref subrange_type_die (tree, dw_die_ref);
  static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);
  static int type_is_enum (const_tree);
--- 4468,4473 ----
*************** base_type_die (tree type)
*** 8684,8689 ****
--- 8683,8693 ----
    if (TREE_CODE (type) == ERROR_MARK || TREE_CODE (type) == VOID_TYPE)
      return 0;
  
+   /* If this is a subtype that should not be emitted as a subrange type,
+      use the base type.  See subrange_type_for_debug_p.  */
+   if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != NULL_TREE)
+     type = TREE_TYPE (type);
+ 
    switch (TREE_CODE (type))
      {
      case INTEGER_TYPE:
*************** simple_type_size_in_bits (const_tree typ
*** 8803,8864 ****
      return TYPE_ALIGN (type);
  }
  
- /* Return true if the debug information for the given type should be
-    emitted as a subrange type.  */
- 
- static inline bool
- is_subrange_type (const_tree type)
- {
-   tree subtype = TREE_TYPE (type);
- 
-   /* Subrange types are identified by the fact that they are integer
-      types, and that they have a subtype which is either an integer type
-      or an enumeral type.  */
- 
-   if (TREE_CODE (type) != INTEGER_TYPE
-       || subtype == NULL_TREE)
-     return false;
- 
-   if (TREE_CODE (subtype) != INTEGER_TYPE
-       && TREE_CODE (subtype) != ENUMERAL_TYPE
-       && TREE_CODE (subtype) != BOOLEAN_TYPE)
-     return false;
- 
-   if (TREE_CODE (type) == TREE_CODE (subtype)
-       && int_size_in_bytes (type) == int_size_in_bytes (subtype)
-       && TYPE_MIN_VALUE (type) != NULL
-       && TYPE_MIN_VALUE (subtype) != NULL
-       && tree_int_cst_equal (TYPE_MIN_VALUE (type), TYPE_MIN_VALUE (subtype))
-       && TYPE_MAX_VALUE (type) != NULL
-       && TYPE_MAX_VALUE (subtype) != NULL
-       && tree_int_cst_equal (TYPE_MAX_VALUE (type), TYPE_MAX_VALUE (subtype)))
-     {
-       /* The type and its subtype have the same representation.  If in
- 	 addition the two types also have the same name, then the given
- 	 type is not a subrange type, but rather a plain base type.  */
-       /* FIXME: brobecker/2004-03-22:
- 	 Sizetype INTEGER_CSTs nodes are canonicalized.  It should
- 	 therefore be sufficient to check the TYPE_SIZE node pointers
- 	 rather than checking the actual size.  Unfortunately, we have
- 	 found some cases, such as in the Ada "integer" type, where
- 	 this is not the case.  Until this problem is solved, we need to
- 	 keep checking the actual size.  */
-       tree type_name = TYPE_NAME (type);
-       tree subtype_name = TYPE_NAME (subtype);
- 
-       if (type_name != NULL && TREE_CODE (type_name) == TYPE_DECL)
- 	type_name = DECL_NAME (type_name);
- 
-       if (subtype_name != NULL && TREE_CODE (subtype_name) == TYPE_DECL)
- 	subtype_name = DECL_NAME (subtype_name);
- 
-       if (type_name == subtype_name)
- 	return false;
-     }
- 
-   return true;
- }
- 
  /*  Given a pointer to a tree node for a subrange type, return a pointer
      to a DIE that describes the given type.  */
  
--- 8807,8812 ----
*************** modified_type_die (tree type, int is_con
*** 8972,8978 ****
  		       simple_type_size_in_bits (type) / BITS_PER_UNIT);
        item_type = TREE_TYPE (type);
      }
!   else if (is_subrange_type (type))
      {
        mod_type_die = subrange_type_die (type, context_die);
        item_type = TREE_TYPE (type);
--- 8920,8928 ----
  		       simple_type_size_in_bits (type) / BITS_PER_UNIT);
        item_type = TREE_TYPE (type);
      }
!   else if (code == INTEGER_TYPE
! 	   && TREE_TYPE (type) != NULL_TREE
! 	   && subrange_type_for_debug_p (type))
      {
        mod_type_die = subrange_type_die (type, context_die);
        item_type = TREE_TYPE (type);
*** gcc/tree.c.0	2009-04-28 13:29:07.000000000 +0200
--- gcc/tree.c	2009-05-10 13:09:15.000000000 +0200
*************** build_range_type (tree type, tree lowval
*** 5788,5793 ****
--- 5788,5832 ----
      return itype;
  }
  
+ /* Return true if the debug information for TYPE, a subtype, should be emitted
+    as a subrange type.  Sometimes doing so unnecessarily obfuscates the debug
+    information and doesn't reflect the source code.  */
+ 
+ bool
+ subrange_type_for_debug_p (const_tree type)
+ {
+   tree base_type = TREE_TYPE (type);
+ 
+   /* Subrange types have a base type which is an integral type.  */
+   if (!INTEGRAL_TYPE_P (base_type))
+     return false;
+ 
+   /* If the type and its base type have the same representation and the same
+      name, then the type is not a subrange but a copy of the base type.  */
+   if ((TREE_CODE (base_type) == INTEGER_TYPE
+        || TREE_CODE (base_type) == BOOLEAN_TYPE)
+       && int_size_in_bytes (type) == int_size_in_bytes (base_type)
+       && tree_int_cst_equal (TYPE_MIN_VALUE (type),
+ 			     TYPE_MIN_VALUE (base_type))
+       && tree_int_cst_equal (TYPE_MAX_VALUE (type),
+ 			     TYPE_MAX_VALUE (base_type)))
+     {
+       tree type_name = TYPE_NAME (type);
+       tree base_type_name = TYPE_NAME (base_type);
+ 
+       if (type_name && TREE_CODE (type_name) == TYPE_DECL)
+ 	type_name = DECL_NAME (type_name);
+ 
+       if (base_type_name && TREE_CODE (base_type_name) == TYPE_DECL)
+ 	base_type_name = DECL_NAME (base_type_name);
+ 
+       if (type_name == base_type_name)
+ 	return false;
+     }
+ 
+   return true;
+ }
+ 
  /* Just like build_index_type, but takes lowval and highval instead
     of just highval (maxval).  */
  
*** gcc/tree.h.0	2009-04-28 13:29:07.000000000 +0200
--- gcc/tree.h	2009-05-08 19:06:00.000000000 +0200
*************** extern void build_common_tree_nodes_2 (i
*** 4973,4978 ****
--- 4973,4979 ----
  extern void build_common_builtin_nodes (void);
  extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);
  extern tree build_range_type (tree, tree, tree);
+ extern bool subrange_type_for_debug_p (const_tree);
  extern HOST_WIDE_INT int_cst_value (const_tree);
  extern tree build_addr (tree, tree);
  
*** gcc/builtins.def.old	2008-11-20 10:18:25.000000000 +0100
--- gcc/builtins.def	2008-11-20 10:28:54.000000000 +0100
*************** DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_
*** 748,755 ****
  DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, "profile_func_exit")
  
  /* TLS emulation.  */
! DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, "__emutls_get_address", BT_FN_PTR_PTR, ATTR_CONST_NOTHROW_NONNULL)
! DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON, "__emutls_register_common", BT_FN_VOID_PTR_WORD_WORD_PTR, ATTR_NOTHROW_LIST)
  
  /* Synchronization Primitives.  */
  #include "sync-builtins.def"
--- 748,763 ----
  DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, "profile_func_exit")
  
  /* TLS emulation.  */
! DEF_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, targetm.emutls.get_address,
! 	     BUILT_IN_NORMAL,
! 	     BT_FN_PTR_PTR,  BT_FN_PTR_PTR,
! 	     true, true, true, ATTR_CONST_NOTHROW_NONNULL, false,
! 	     !targetm.have_tls)
! DEF_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON,
! 	     targetm.emutls.register_common, BUILT_IN_NORMAL,
! 	     BT_FN_VOID_PTR_WORD_WORD_PTR, BT_FN_VOID_PTR_WORD_WORD_PTR,
! 	     true, true, true, ATTR_NOTHROW_LIST, false,
! 	     !targetm.have_tls)
  
  /* Synchronization Primitives.  */
  #include "sync-builtins.def"
*** gcc/c-common.c.old	2008-11-12 23:08:01.000000000 +0100
--- gcc/c-common.c	2008-11-20 10:28:54.000000000 +0100
*************** handle_section_attribute (tree *node, tr
*** 5404,5409 ****
--- 5404,5416 ----
  		     *node);
  	      *no_add_attrs = true;
  	    }
+ 	  else if (TREE_CODE (decl) == VAR_DECL
+ 		   && !targetm.have_tls && targetm.emutls.tmpl_section
+ 		   && DECL_THREAD_LOCAL_P (decl))
+ 	    {
+ 	      error ("section of %q+D cannot be overridden", *node);
+ 	      *no_add_attrs = true;
+ 	    }
  	  else
  	    DECL_SECTION_NAME (decl) = TREE_VALUE (args);
  	}
*** gcc/config/i386/i386.c.old	2008-11-20 10:18:26.000000000 +0100
--- gcc/config/i386/i386.c	2008-11-20 10:28:54.000000000 +0100
*************** x86_64_elf_select_section (tree decl, in
*** 2830,2835 ****
--- 2830,2838 ----
  	  /* We don't split these for medium model.  Place them into
  	     default sections and hope for best.  */
  	  break;
+ 	case SECCAT_EMUTLS_VAR:
+ 	case SECCAT_EMUTLS_TMPL:
+ 	  gcc_unreachable ();
  	}
        if (sname)
  	{
*************** x86_64_elf_unique_section (tree decl, in
*** 2866,2881 ****
  	case SECCAT_DATA_REL_LOCAL:
  	case SECCAT_DATA_REL_RO:
  	case SECCAT_DATA_REL_RO_LOCAL:
!           prefix = one_only ? ".gnu.linkonce.ld." : ".ldata.";
  	  break;
  	case SECCAT_BSS:
!           prefix = one_only ? ".gnu.linkonce.lb." : ".lbss.";
  	  break;
  	case SECCAT_RODATA:
  	case SECCAT_RODATA_MERGE_STR:
  	case SECCAT_RODATA_MERGE_STR_INIT:
  	case SECCAT_RODATA_MERGE_CONST:
!           prefix = one_only ? ".gnu.linkonce.lr." : ".lrodata.";
  	  break;
  	case SECCAT_SRODATA:
  	case SECCAT_SDATA:
--- 2869,2884 ----
  	case SECCAT_DATA_REL_LOCAL:
  	case SECCAT_DATA_REL_RO:
  	case SECCAT_DATA_REL_RO_LOCAL:
!           prefix = one_only ? ".ld" : ".ldata";
  	  break;
  	case SECCAT_BSS:
!           prefix = one_only ? ".lb" : ".lbss";
  	  break;
  	case SECCAT_RODATA:
  	case SECCAT_RODATA_MERGE_STR:
  	case SECCAT_RODATA_MERGE_STR_INIT:
  	case SECCAT_RODATA_MERGE_CONST:
!           prefix = one_only ? ".lr" : ".lrodata";
  	  break;
  	case SECCAT_SRODATA:
  	case SECCAT_SDATA:
*************** x86_64_elf_unique_section (tree decl, in
*** 2887,2909 ****
  	  /* We don't split these for medium model.  Place them into
  	     default sections and hope for best.  */
  	  break;
  	}
        if (prefix)
  	{
! 	  const char *name;
! 	  size_t nlen, plen;
  	  char *string;
- 	  plen = strlen (prefix);
  
  	  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
  	  name = targetm.strip_name_encoding (name);
! 	  nlen = strlen (name);
! 
! 	  string = (char *) alloca (nlen + plen + 1);
! 	  memcpy (string, prefix, plen);
! 	  memcpy (string + plen, name, nlen + 1);
! 
! 	  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
  	  return;
  	}
      }
--- 2890,2917 ----
  	  /* We don't split these for medium model.  Place them into
  	     default sections and hope for best.  */
  	  break;
+ 	case SECCAT_EMUTLS_VAR:
+ 	  prefix = targetm.emutls.var_section;
+ 	  break;
+ 	case SECCAT_EMUTLS_TMPL:
+ 	  prefix = targetm.emutls.tmpl_section;
+ 	  break;
  	}
        if (prefix)
  	{
! 	  const char *name, *linkonce;
  	  char *string;
  
  	  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
  	  name = targetm.strip_name_encoding (name);
! 	  
! 	  /* If we're using one_only, then there needs to be a .gnu.linkonce
!      	     prefix to the section name.  */
! 	  linkonce = one_only ? ".gnu.linkonce" : "";
!   
! 	  string = ACONCAT ((linkonce, prefix, ".", name, NULL));
! 	  
! 	  DECL_SECTION_NAME (decl) = build_string (strlen (string), string);
  	  return;
  	}
      }
*** gcc/config/vxworks.c.old	2007-08-02 12:49:31.000000000 +0200
--- gcc/config/vxworks.c	2008-11-20 10:28:54.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 26,31 ****
--- 26,32 ----
  #include "toplev.h"
  #include "output.h"
  #include "tm.h"
+ #include "tree.h"
  
  /* Like default_named_section_asm_out_constructor, except that even
     constructors with DEFAULT_INIT_PRIORITY must go in a numbered
*************** vxworks_asm_out_destructor (rtx symbol, 
*** 56,66 ****
--- 57,143 ----
    assemble_addr_to_section (symbol, sec);
  }
  
+ /* Return the list of FIELD_DECLs that make up an emulated TLS
+    variable's control object.  TYPE is the structure these are fields
+    of and *NAME will be filled in with the structure tag that should
+    be used.  */
+ 
+ static tree
+ vxworks_emutls_var_fields (tree type, tree *name)
+ {
+   tree field, next_field;
+   
+   *name = get_identifier ("__tls_var");
+   
+   field = build_decl (FIELD_DECL, get_identifier ("size"),
+ 		      unsigned_type_node);
+   DECL_CONTEXT (field) = type;
+   next_field = field;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("module_id"),
+ 		      unsigned_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+   next_field = field;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("offset"),
+ 		      unsigned_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+ 
+   return field;
+ }
+ 
+ /* Return the CONSTRUCTOR to initialize an emulated TLS control
+    object.  VAR is the control object.  DECL is the TLS object itself
+    and TMPL_ADDR is the address (an ADDR_EXPR) of the initializer for
+    that object.  */
+ 
+ static tree
+ vxworks_emutls_var_init (tree var, tree decl, tree tmpl_addr)
+ {
+   VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 3);
+   constructor_elt *elt;
+   
+   tree type = TREE_TYPE (var);
+   tree field = TYPE_FIELDS (type);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   elt->index = field;
+   elt->value = fold_convert (TREE_TYPE (field), tmpl_addr);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = build_int_cst (TREE_TYPE (field), 0);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
+   
+   return build_constructor (type, v);
+ }
+ 
  /* Do VxWorks-specific parts of OVERRIDE_OPTIONS.  */
  
  void
  vxworks_override_options (void)
  {
+   /* We don't support __thread via target hooks.  */
+   targetm.have_tls = false;
+ 
+   targetm.emutls.get_address = "__builtin___tls_lookup";
+   targetm.emutls.register_common = NULL;
+   targetm.emutls.var_section = ".tls_vars";
+   targetm.emutls.tmpl_section = ".tls_data";
+   targetm.emutls.var_prefix = "__tls__";
+   targetm.emutls.tmpl_prefix = "";
+   targetm.emutls.var_fields = vxworks_emutls_var_fields;
+   targetm.emutls.var_init = vxworks_emutls_var_init;
+   targetm.emutls.var_align_fixed = true;
+   targetm.emutls.debug_form_tls_address = true;
+   
    /* We can use .ctors/.dtors sections only in RTP mode.  */
    targetm.have_ctors_dtors = TARGET_VXWORKS_RTP;
  
*** gcc/coretypes.h.old	2007-07-26 10:37:01.000000000 +0200
--- gcc/coretypes.h	2008-11-20 10:28:54.000000000 +0100
*************** struct cpp_reader;
*** 69,75 ****
     to it, so it's here.  */
  enum tls_model {
    TLS_MODEL_NONE,
!   TLS_MODEL_GLOBAL_DYNAMIC,
    TLS_MODEL_LOCAL_DYNAMIC,
    TLS_MODEL_INITIAL_EXEC,
    TLS_MODEL_LOCAL_EXEC
--- 69,77 ----
     to it, so it's here.  */
  enum tls_model {
    TLS_MODEL_NONE,
!   TLS_MODEL_EMULATED,
!   TLS_MODEL_REAL,
!   TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
    TLS_MODEL_LOCAL_DYNAMIC,
    TLS_MODEL_INITIAL_EXEC,
    TLS_MODEL_LOCAL_EXEC
*** gcc/doc/tm.texi.old	2008-11-20 10:18:26.000000000 +0100
--- gcc/doc/tm.texi	2008-11-20 10:28:54.000000000 +0100
*************** through the macros defined in the @file{
*** 50,55 ****
--- 50,56 ----
  * Floating Point::      Handling floating point for cross-compilers.
  * Mode Switching::      Insertion of mode-switching instructions.
  * Target Attributes::   Defining target-specific uses of @code{__attribute__}.
+ * Emulated TLS::        Emulated TLS support.
  * MIPS Coprocessors::   MIPS coprocessor support and how to customize it.
  * PCH Target::          Validity checking for precompiled headers.
  * C++ ABI::             Controlling C++ ABI changes.
*************** attributes, @code{false} otherwise.  By 
*** 9257,9262 ****
--- 9258,9341 ----
  target specific attribute attached to it, it will not be inlined.
  @end deftypefn
  
+ @node Emulated TLS
+ @section Emulating TLS
+ @cindex Emulated TLS
+ 
+ For targets whose psABI does not provide Thread Local Storage via
+ specific relocations and instruction sequences, an emulation layer is
+ used.  A set of target hooks allows this emulation layer to be
+ configured for the requirements of a particular target.  For instance
+ the psABI may infact specify TLS support in terms of an emulation
+ layer.
+ 
+ The emulation layer works by creating a control object for every TLS
+ object.  To access the TLS object, a lookup function is provided
+ which, when given the address of the control object, will return the
+ address of the current thread's instance of the TLS object.
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_GET_ADDRESS
+ Contains the name of the helper function that uses a TLS control
+ object to locate a TLS instance.  The default causes libgcc's
+ emulated TLS helper function to be used.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_REGISTER_COMMON
+ Contains the name of the helper function that should be used at
+ program startup to register TLS objects that are implicitly
+ initialized to zero.  If this is @code{NULL}, all TLS objects will
+ have explicit initializers.  The default causes libgcc's emulated TLS
+ registration function to be used.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_SECTION
+ Contains the name of the section in which TLS control variables should
+ be placed.  The default of @code{NULL} allows these to be placed in
+ any section.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_SECTION
+ Contains the name of the section in which TLS initializers should be
+ placed.  The default of @code{NULL} allows these to be placed in any
+ section.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_PREFIX
+ Contains the prefix to be prepended to TLS control variable names.
+ The default of @code{NULL} uses a target-specific prefix.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_PREFIX
+ Contains the prefix to be prepended to TLS initializer objects.  The
+ default of @code{NULL} uses a target-specific prefix.
+ @end deftypevr
+ 
+ @deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_FIELDS (tree @var{type}, tree *@var{name})
+ Specifies a function that generates the FIELD_DECLs for a TLS control
+ object type.  @var{type} is the RECORD_TYPE the fields are for and
+ @var{name} should be filled with the structure tag, if the default of
+ @code{__emutls_object} is unsuitable.  The default creates a type suitable
+ for libgcc's emulated TLS function.
+ @end deftypefn
+ 
+ @deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_INIT (tree @var{var}, tree @var{decl}, tree @var{tmpl_addr})
+ Specifies a function that generates the CONSTRUCTOR to initialize a
+ TLS control object.  @var{var} is the TLS control object, @var{decl}
+ is the TLS object and @var{tmpl_addr} is the address of the
+ initializer.  The default initializes libgcc's emulated TLS control object.
+ @end deftypefn
+ 
+ @deftypevr {Target Hook} {bool} TARGET_EMUTLS_VAR_ALIGN_FIXED
+ Specifies whether the alignment of TLS control variable objects is
+ fixed and should not be increased as some backends may do to optimize
+ single objects.  The default is false.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {bool} TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
+ Specifies whether a DWARF @code{DW_OP_form_tls_address} location descriptor
+ may be used to describe emulated TLS control objects.
+ @end deftypevr
+ 
  @node MIPS Coprocessors
  @section Defining coprocessor specifics for MIPS targets.
  @cindex MIPS coprocessor-definition macros
*** gcc/dwarf2out.c.old	2008-11-20 10:18:26.000000000 +0100
--- gcc/dwarf2out.c	2008-11-20 10:28:54.000000000 +0100
*************** loc_descriptor_from_tree_1 (tree loc, in
*** 9667,9682 ****
        if (DECL_THREAD_LOCAL_P (loc))
  	{
  	  rtx rtl;
  
! 	  /* If this is not defined, we have no way to emit the data.  */
! 	  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)
! 	    return 0;
! 
! 	  /* The way DW_OP_GNU_push_tls_address is specified, we can only
! 	     look up addresses of objects in the current module.  */
! 	  if (DECL_EXTERNAL (loc))
! 	    return 0;
! 
  	  rtl = rtl_for_decl_location (loc);
  	  if (rtl == NULL_RTX)
  	    return 0;
--- 9667,9699 ----
        if (DECL_THREAD_LOCAL_P (loc))
  	{
  	  rtx rtl;
+ 	  unsigned first_op;
+ 	  unsigned second_op;
  
! 	  if (targetm.have_tls)
! 	    {
! 	      /* If this is not defined, we have no way to emit the
! 	         data.  */
! 	      if (!targetm.asm_out.output_dwarf_dtprel)
! 		return 0;
! 
! 	       /* The way DW_OP_GNU_push_tls_address is specified, we
! 	     	  can only look up addresses of objects in the current
! 	     	  module.  */
! 	      if (DECL_EXTERNAL (loc))
! 		return 0;
! 	      first_op = INTERNAL_DW_OP_tls_addr;
! 	      second_op = DW_OP_GNU_push_tls_address;
! 	    }
! 	  else
! 	    {
! 	      if (!targetm.emutls.debug_form_tls_address)
! 		return 0;
! 	      loc = emutls_decl (loc);
! 	      first_op = DW_OP_addr;
! 	      second_op = DW_OP_form_tls_address;
! 	    }
! 	  
  	  rtl = rtl_for_decl_location (loc);
  	  if (rtl == NULL_RTX)
  	    return 0;
*************** loc_descriptor_from_tree_1 (tree loc, in
*** 9687,9697 ****
  	  if (! CONSTANT_P (rtl))
  	    return 0;
  
! 	  ret = new_loc_descr (INTERNAL_DW_OP_tls_addr, 0, 0);
  	  ret->dw_loc_oprnd1.val_class = dw_val_class_addr;
  	  ret->dw_loc_oprnd1.v.val_addr = rtl;
! 
! 	  ret1 = new_loc_descr (DW_OP_GNU_push_tls_address, 0, 0);
  	  add_loc_descr (&ret, ret1);
  
  	  have_address = 1;
--- 9704,9714 ----
  	  if (! CONSTANT_P (rtl))
  	    return 0;
  
! 	  ret = new_loc_descr (first_op, 0, 0);
  	  ret->dw_loc_oprnd1.val_class = dw_val_class_addr;
  	  ret->dw_loc_oprnd1.v.val_addr = rtl;
! 	  
! 	  ret1 = new_loc_descr (second_op, 0, 0);
  	  add_loc_descr (&ret, ret1);
  
  	  have_address = 1;
*** gcc/output.h.old	2008-11-20 10:18:26.000000000 +0100
--- gcc/output.h	2008-11-20 10:28:54.000000000 +0100
*************** enum section_category
*** 465,471 ****
  
    SECCAT_BSS,
    SECCAT_SBSS,
!   SECCAT_TBSS
  };
  
  /* Information that is provided by all instances of the section type.  */
--- 465,474 ----
  
    SECCAT_BSS,
    SECCAT_SBSS,
!   SECCAT_TBSS,
! 
!   SECCAT_EMUTLS_VAR,
!   SECCAT_EMUTLS_TMPL
  };
  
  /* Information that is provided by all instances of the section type.  */
*** gcc/target-def.h.old	2008-06-28 12:43:12.000000000 +0200
--- gcc/target-def.h	2008-11-20 10:28:54.000000000 +0100
***************
*** 695,700 ****
--- 695,755 ----
      TARGET_CXX_ADJUST_CLASS_AT_DEFINITION	\
    }
  
+ /* EMUTLS specific */
+ #ifndef TARGET_EMUTLS_GET_ADDRESS
+ #define TARGET_EMUTLS_GET_ADDRESS "__builtin___emutls_get_address"
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_REGISTER_COMMON
+ #define TARGET_EMUTLS_REGISTER_COMMON "__builtin___emutls_register_common"
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_SECTION
+ #define TARGET_EMUTLS_VAR_SECTION NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_TMPL_SECTION
+ #define TARGET_EMUTLS_TMPL_SECTION NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_PREFIX
+ #define TARGET_EMUTLS_VAR_PREFIX NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_TMPL_PREFIX
+ #define TARGET_EMUTLS_TMPL_PREFIX NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_FIELDS
+ #define TARGET_EMUTLS_VAR_FIELDS default_emutls_var_fields
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_INIT
+ #define TARGET_EMUTLS_VAR_INIT default_emutls_var_init
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_ALIGN_FIXED
+ #define TARGET_EMUTLS_VAR_ALIGN_FIXED false
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
+ #define TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS false
+ #endif
+ 
+ #define TARGET_EMUTLS				\
+   {						\
+     TARGET_EMUTLS_GET_ADDRESS,  		\
+     TARGET_EMUTLS_REGISTER_COMMON,  		\
+     TARGET_EMUTLS_VAR_SECTION,  		\
+     TARGET_EMUTLS_TMPL_SECTION,  		\
+     TARGET_EMUTLS_VAR_PREFIX,  			\
+     TARGET_EMUTLS_TMPL_PREFIX,  		\
+     TARGET_EMUTLS_VAR_FIELDS,			\
+     TARGET_EMUTLS_VAR_INIT,			\
+     TARGET_EMUTLS_VAR_ALIGN_FIXED,		\
+     TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS	\
+   }
+ 
  /* The whole shebang.  */
  #define TARGET_INITIALIZER			\
  {						\
***************
*** 787,792 ****
--- 842,848 ----
    TARGET_INSTANTIATE_DECLS,			\
    TARGET_C,					\
    TARGET_CXX,					\
+   TARGET_EMUTLS,				\
    TARGET_EXTRA_LIVE_ON_ENTRY,			\
    TARGET_UNWIND_TABLES_DEFAULT,			\
    TARGET_HAVE_NAMED_SECTIONS,			\
*** gcc/target.h.old	2008-06-28 12:43:12.000000000 +0200
--- gcc/target.h	2008-11-20 10:28:54.000000000 +0100
*************** struct gcc_target
*** 920,925 ****
--- 920,953 ----
      void (*adjust_class_at_definition) (tree type);
    } cxx;
  
+   /* Functions and data for emulated TLS support.  */
+   struct emutls {
+     /* Name of the address and common functions.  */
+     const char *get_address;
+     const char *register_common;
+ 
+     /* Prefixes for proxy variable and template.  */
+     const char *var_section;
+     const char *tmpl_section;
+ 
+     /* Prefixes for proxy variable and template.  */
+     const char *var_prefix;
+     const char *tmpl_prefix;
+     
+     /* Function to generate field definitions of the proxy variable.  */
+     tree (*var_fields) (tree, tree *);
+ 
+     /* Function to initialize a proxy variable.  */
+     tree (*var_init) (tree, tree, tree);
+ 
+     /* Whether we are allowed to alter the usual alignment of the
+        proxy variable.  */
+     bool var_align_fixed;
+ 
+     /* Whether we can emit debug information for TLS vars.  */
+     bool debug_form_tls_address;
+   } emutls;  
+ 
    /* For targets that need to mark extra registers as live on entry to
       the function, they should define this target hook and set their
       bits in the bitmap passed in. */  
*** gcc/targhooks.h.old	2008-06-28 12:43:12.000000000 +0200
--- gcc/targhooks.h	2008-11-20 10:28:54.000000000 +0100
*************** extern void hook_void_bitmap (bitmap);
*** 95,97 ****
--- 95,99 ----
  extern bool default_handle_c_option (size_t, const char *, int);
  extern int default_reloc_rw_mask (void);
  extern tree default_mangle_decl_assembler_name (tree, tree);
+ extern tree default_emutls_var_fields (tree, tree *);
+ extern tree default_emutls_var_init (tree, tree, tree);
*** gcc/tree.h.old	2008-11-20 10:18:26.000000000 +0100
--- gcc/tree.h	2008-11-20 10:28:54.000000000 +0100
*************** extern void decl_fini_priority_insert (t
*** 3226,3232 ****
  /* In a VAR_DECL, nonzero if the data should be allocated from
     thread-local storage.  */
  #define DECL_THREAD_LOCAL_P(NODE) \
!   (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model != TLS_MODEL_NONE)
  
  struct tree_var_decl GTY(())
  {
--- 3226,3232 ----
  /* In a VAR_DECL, nonzero if the data should be allocated from
     thread-local storage.  */
  #define DECL_THREAD_LOCAL_P(NODE) \
!   (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL)
  
  struct tree_var_decl GTY(())
  {
*** gcc/varasm.c.old	2008-11-20 10:18:26.000000000 +0100
--- gcc/varasm.c	2008-11-20 10:28:54.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 48,53 ****
--- 48,54 ----
  #include "tm_p.h"
  #include "debug.h"
  #include "target.h"
+ #include "targhooks.h"
  #include "tree-mudflap.h"
  #include "cgraph.h"
  #include "cfglayout.h"
*************** static GTY(()) struct rtx_constant_pool 
*** 197,264 ****
  static GTY ((if_marked ("tree_map_marked_p"), param_is (struct tree_map)))
       htab_t emutls_htab;
  static GTY (()) tree emutls_object_type;
! 
! #ifndef NO_DOT_IN_LABEL
! # define EMUTLS_VAR_PREFIX	"__emutls_v."
! # define EMUTLS_TMPL_PREFIX	"__emutls_t."
! #elif !defined NO_DOLLAR_IN_LABEL
! # define EMUTLS_VAR_PREFIX	"__emutls_v$"
! # define EMUTLS_TMPL_PREFIX	"__emutls_t$"
  #else
! # define EMUTLS_VAR_PREFIX	"__emutls_v_"
! # define EMUTLS_TMPL_PREFIX	"__emutls_t_"
  #endif
  
! /* Create an identifier for the struct __emutls_object, given an identifier
!    of the DECL_ASSEMBLY_NAME of the original object.  */
  
  static tree
! get_emutls_object_name (tree name)
  {
!   char *toname = alloca (strlen (IDENTIFIER_POINTER (name))
! 			 + sizeof (EMUTLS_VAR_PREFIX));
!   strcpy (toname, EMUTLS_VAR_PREFIX);
!   strcpy (toname + sizeof (EMUTLS_VAR_PREFIX) - 1, IDENTIFIER_POINTER (name));
  
    return get_identifier (toname);
  }
  
! /* Create the structure for struct __emutls_object.  This should match the
!    structure at the top of emutls.c, modulo the union there.  */
  
  static tree
! get_emutls_object_type (void)
  {
!   tree type, type_name, field, next_field, word_type_node;
! 
!   type = emutls_object_type;
!   if (type)
!     return type;
! 
!   emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);
!   type_name = get_identifier ("__emutls_object");
!   type_name = build_decl (TYPE_DECL, type_name, type);
!   TYPE_NAME (type) = type_name;
  
    field = build_decl (FIELD_DECL, get_identifier ("__templ"), ptr_type_node);
    DECL_CONTEXT (field) = type;
    next_field = field;
! 
!   field = build_decl (FIELD_DECL, get_identifier ("__offset"), ptr_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
! 
    word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);
!   field = build_decl (FIELD_DECL, get_identifier ("__align"), word_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
! 
    field = build_decl (FIELD_DECL, get_identifier ("__size"), word_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
  
    TYPE_FIELDS (type) = field;
    layout_type (type);
  
--- 198,292 ----
  static GTY ((if_marked ("tree_map_marked_p"), param_is (struct tree_map)))
       htab_t emutls_htab;
  static GTY (()) tree emutls_object_type;
! /* Emulated TLS objects have the TLS model TLS_MODEL_EMULATED.  This
!    macro can be used on them to distinguish the control variable from
!    the initialization template.  */
! #define DECL_EMUTLS_VAR_P(D)  (TREE_TYPE (D) == emutls_object_type)
! 
! #if !defined (NO_DOT_IN_LABEL)
! # define EMUTLS_SEPARATOR	"."
! #elif !defined (NO_DOLLAR_IN_LABEL)
! # define EMUTLS_SEPARATOR	"$"
  #else
! # define EMUTLS_SEPARATOR	"_"
  #endif
  
! /* Create an IDENTIFIER_NODE by prefixing PREFIX to the
!    IDENTIFIER_NODE NAME's name.  */
  
  static tree
! prefix_name (const char *prefix, tree name)
  {
!   unsigned plen = strlen (prefix);
!   unsigned nlen = strlen (IDENTIFIER_POINTER (name));
!   char *toname = alloca (plen + nlen + 1);
!   
!   memcpy (toname, prefix, plen);
!   memcpy (toname + plen, IDENTIFIER_POINTER (name), nlen + 1);
  
    return get_identifier (toname);
  }
  
! /* Create an identifier for the struct __emutls_object, given an identifier
!    of the DECL_ASSEMBLY_NAME of the original object.  */
  
  static tree
! get_emutls_object_name (tree name)
  {
!   const char *prefix = (targetm.emutls.var_prefix
! 			? targetm.emutls.var_prefix
! 			: "__emutls_v" EMUTLS_SEPARATOR);
!   return prefix_name (prefix, name);
! }
  
+ tree
+ default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)
+ {
+   tree word_type_node, field, next_field;
+   
    field = build_decl (FIELD_DECL, get_identifier ("__templ"), ptr_type_node);
    DECL_CONTEXT (field) = type;
    next_field = field;
!     
!   field = build_decl (FIELD_DECL, get_identifier ("__offset"),
! 		      ptr_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
!   
    word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);
!   field = build_decl (FIELD_DECL, get_identifier ("__align"),
! 		      word_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
!   
    field = build_decl (FIELD_DECL, get_identifier ("__size"), word_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
  
+   return field;
+ }
+ 
+ /* Create the structure for struct __emutls_object.  This should match the
+    structure at the top of emutls.c, modulo the union there.  */
+ 
+ static tree
+ get_emutls_object_type (void)
+ {
+   tree type, type_name, field;
+ 
+   type = emutls_object_type;
+   if (type)
+     return type;
+ 
+   emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);
+   type_name = NULL;
+   field = targetm.emutls.var_fields (type, &type_name);
+   if (!type_name)
+     type_name = get_identifier ("__emutls_object");
+   type_name = build_decl (TYPE_DECL, type_name, type);
+   TYPE_NAME (type) = type_name;
    TYPE_FIELDS (type) = field;
    layout_type (type);
  
*************** static tree
*** 272,297 ****
  get_emutls_init_templ_addr (tree decl)
  {
    tree name, to;
!   char *toname;
! 
!   if (!DECL_INITIAL (decl))
      return null_pointer_node;
  
    name = DECL_ASSEMBLER_NAME (decl);
!   toname = alloca (strlen (IDENTIFIER_POINTER (name))
! 		   + sizeof (EMUTLS_TMPL_PREFIX));
!   strcpy (toname, EMUTLS_TMPL_PREFIX);
!   strcpy (toname + sizeof (EMUTLS_TMPL_PREFIX) - 1, IDENTIFIER_POINTER (name));
!   name = get_identifier (toname);
  
    to = build_decl (VAR_DECL, name, TREE_TYPE (decl));
    SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
! 
    DECL_ARTIFICIAL (to) = 1;
    TREE_USED (to) = TREE_USED (decl);
    TREE_READONLY (to) = 1;
    DECL_IGNORED_P (to) = 1;
    DECL_CONTEXT (to) = DECL_CONTEXT (decl);
    DECL_WEAK (to) = DECL_WEAK (decl);
    if (DECL_ONE_ONLY (decl))
      {
--- 300,329 ----
  get_emutls_init_templ_addr (tree decl)
  {
    tree name, to;
!   
!   if (targetm.emutls.register_common && !DECL_INITIAL (decl)
!       && !DECL_SECTION_NAME (decl))
      return null_pointer_node;
  
    name = DECL_ASSEMBLER_NAME (decl);
!   if (!targetm.emutls.tmpl_prefix || targetm.emutls.tmpl_prefix[0])
!     {
!       const char *prefix = (targetm.emutls.tmpl_prefix
! 			    ? targetm.emutls.tmpl_prefix
! 			    : "__emutls_t" EMUTLS_SEPARATOR);
!       name = prefix_name (prefix, name);
!     }
  
    to = build_decl (VAR_DECL, name, TREE_TYPE (decl));
    SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
!   DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;
    DECL_ARTIFICIAL (to) = 1;
    TREE_USED (to) = TREE_USED (decl);
    TREE_READONLY (to) = 1;
    DECL_IGNORED_P (to) = 1;
    DECL_CONTEXT (to) = DECL_CONTEXT (decl);
+   DECL_SECTION_NAME (to) = DECL_SECTION_NAME (decl);
+   
    DECL_WEAK (to) = DECL_WEAK (decl);
    if (DECL_ONE_ONLY (decl))
      {
*************** emutls_decl (tree decl)
*** 351,364 ****
        h->to = to;
        *(struct tree_map **) loc = h;
  
        DECL_ARTIFICIAL (to) = 1;
        DECL_IGNORED_P (to) = 1;
        TREE_READONLY (to) = 0;
- 
        SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
        if (DECL_ONE_ONLY (decl))
  	make_decl_one_only (to);
        DECL_CONTEXT (to) = DECL_CONTEXT (decl);
      }
  
    /* Note that these fields may need to be updated from time to time from
--- 383,400 ----
        h->to = to;
        *(struct tree_map **) loc = h;
  
+       DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;
        DECL_ARTIFICIAL (to) = 1;
        DECL_IGNORED_P (to) = 1;
        TREE_READONLY (to) = 0;
        SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
        if (DECL_ONE_ONLY (decl))
  	make_decl_one_only (to);
        DECL_CONTEXT (to) = DECL_CONTEXT (decl);
+       if (targetm.emutls.var_align_fixed)
+ 	/* If we're not allowed to change the proxy object's
+ 	   alignment, pretend it's been set by the user.  */
+ 	DECL_USER_ALIGN (to) = 1;
      }
  
    /* Note that these fields may need to be updated from time to time from
*************** emutls_common_1 (void **loc, void *xstmt
*** 416,431 ****
  void
  emutls_finish (void)
  {
!   tree body = NULL_TREE;
! 
!   if (emutls_htab == NULL)
!     return;
  
!   htab_traverse_noresize (emutls_htab, emutls_common_1, &body);
!   if (body == NULL_TREE)
!     return;
  
!   cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);
  }
  
  /* Helper routines for maintaining section_htab.  */
--- 452,470 ----
  void
  emutls_finish (void)
  {
!   if (!targetm.emutls.register_common)
!     {
!       tree body = NULL_TREE;
  
!       if (emutls_htab == NULL)
! 	return;
  
!       htab_traverse_noresize (emutls_htab, emutls_common_1, &body);
!       if (body == NULL_TREE)
! 	return;
!       
!       cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);
!     }
  }
  
  /* Helper routines for maintaining section_htab.  */
*************** get_variable_section (tree decl, bool pr
*** 1128,1134 ****
      {
        if (DECL_THREAD_LOCAL_P (decl))
  	return tls_comm_section;
!       if (TREE_PUBLIC (decl) && bss_initializer_p (decl))
  	return comm_section;
      }
  
--- 1167,1178 ----
      {
        if (DECL_THREAD_LOCAL_P (decl))
  	return tls_comm_section;
!       /* This cannot be common bss for an emulated TLS object without
! 	 a register_common hook.  */
!       else if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED
! 	       && !targetm.emutls.register_common)
! 	;
!       else if (TREE_PUBLIC (decl) && bss_initializer_p (decl))
  	return comm_section;
      }
  
*************** assemble_variable_contents (tree decl, c
*** 1954,1959 ****
--- 1998,2037 ----
      }
  }
  
+ /* Initialize emulated tls object TO, which refers to TLS variable
+    DECL and is initialized by PROXY.  */
+ 
+ tree
+ default_emutls_var_init (tree to, tree decl, tree proxy)
+ {
+   VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);
+   constructor_elt *elt;
+   tree type = TREE_TYPE (to);
+   tree field = TYPE_FIELDS (type);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   elt->index = field;
+   elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = build_int_cst (TREE_TYPE (field),
+ 			      DECL_ALIGN_UNIT (decl));
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = null_pointer_node;
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = proxy;
+   
+   return build_constructor (type, v);
+ }
+ 
  /* Assemble everything that is needed for a variable or function declaration.
     Not used for automatic variables, and not used for function definitions.
     Should not be called for variables of incomplete structure type.
*************** assemble_variable (tree decl, int top_le
*** 1988,2019 ****
  	      || (DECL_INITIAL (decl)
  		  && DECL_INITIAL (decl) != error_mark_node)))
  	{
! 	  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);
! 	  constructor_elt *elt;
! 	  tree type = TREE_TYPE (to);
! 	  tree field = TYPE_FIELDS (type);
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  elt->index = field;
! 	  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  field = TREE_CHAIN (field);
! 	  elt->index = field;
! 	  elt->value = build_int_cst (TREE_TYPE (field),
! 				      DECL_ALIGN_UNIT (decl));
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  field = TREE_CHAIN (field);
! 	  elt->index = field;
! 	  elt->value = null_pointer_node;
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  field = TREE_CHAIN (field);
! 	  elt->index = field;
! 	  elt->value = get_emutls_init_templ_addr (decl);
! 
! 	  DECL_INITIAL (to) = build_constructor (type, v);
  
  	  /* Make sure the template is marked as needed early enough.
  	     Without this, if the variable is placed in a
--- 2066,2073 ----
  	      || (DECL_INITIAL (decl)
  		  && DECL_INITIAL (decl) != error_mark_node)))
  	{
! 	  DECL_INITIAL (to) = targetm.emutls.var_init
! 	    (to, decl, get_emutls_init_templ_addr (decl));
  
  	  /* Make sure the template is marked as needed early enough.
  	     Without this, if the variable is placed in a
*************** categorize_decl_for_section (const_tree 
*** 6096,6108 ****
      ret = SECCAT_RODATA;
  
    /* There are no read-only thread-local sections.  */
!   if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))
      {
        /* Note that this would be *just* SECCAT_BSS, except that there's
  	 no concept of a read-only thread-local-data section.  */
!       if (ret == SECCAT_BSS
! 	  || (flag_zero_initialized_in_bss
! 	      && initializer_zerop (DECL_INITIAL (decl))))
  	ret = SECCAT_TBSS;
        else
  	ret = SECCAT_TDATA;
--- 6150,6175 ----
      ret = SECCAT_RODATA;
  
    /* There are no read-only thread-local sections.  */
!   if (TREE_CODE (decl) == VAR_DECL && DECL_TLS_MODEL (decl))
      {
+       if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED)
+ 	{
+ 	  if (DECL_EMUTLS_VAR_P (decl))
+ 	    {
+ 	      if (targetm.emutls.var_section)
+ 		ret = SECCAT_EMUTLS_VAR;
+ 	    }
+ 	  else
+ 	    {
+ 	      if (targetm.emutls.tmpl_prefix)
+ 		ret = SECCAT_EMUTLS_TMPL;
+ 	    }
+ 	}
        /* Note that this would be *just* SECCAT_BSS, except that there's
  	 no concept of a read-only thread-local-data section.  */
!       else if (ret == SECCAT_BSS
! 	       || (flag_zero_initialized_in_bss
! 		   && initializer_zerop (DECL_INITIAL (decl))))
  	ret = SECCAT_TBSS;
        else
  	ret = SECCAT_TDATA;
*************** default_elf_select_section (tree decl, i
*** 6194,6199 ****
--- 6261,6272 ----
      case SECCAT_TBSS:
        sname = ".tbss";
        break;
+     case SECCAT_EMUTLS_VAR:
+       sname = targetm.emutls.var_section;
+       break;
+     case SECCAT_EMUTLS_TMPL:
+       sname = targetm.emutls.tmpl_section;
+       break;
      default:
        gcc_unreachable ();
      }
*************** default_unique_section (tree decl, int r
*** 6211,6279 ****
  {
    /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
    bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;
!   const char *prefix, *name;
!   size_t nlen, plen;
    char *string;
  
    switch (categorize_decl_for_section (decl, reloc))
      {
      case SECCAT_TEXT:
!       prefix = one_only ? ".gnu.linkonce.t." : ".text.";
        break;
      case SECCAT_RODATA:
      case SECCAT_RODATA_MERGE_STR:
      case SECCAT_RODATA_MERGE_STR_INIT:
      case SECCAT_RODATA_MERGE_CONST:
!       prefix = one_only ? ".gnu.linkonce.r." : ".rodata.";
        break;
      case SECCAT_SRODATA:
!       prefix = one_only ? ".gnu.linkonce.s2." : ".sdata2.";
        break;
      case SECCAT_DATA:
!       prefix = one_only ? ".gnu.linkonce.d." : ".data.";
        break;
      case SECCAT_DATA_REL:
!       prefix = one_only ? ".gnu.linkonce.d.rel." : ".data.rel.";
        break;
      case SECCAT_DATA_REL_LOCAL:
!       prefix = one_only ? ".gnu.linkonce.d.rel.local." : ".data.rel.local.";
        break;
      case SECCAT_DATA_REL_RO:
!       prefix = one_only ? ".gnu.linkonce.d.rel.ro." : ".data.rel.ro.";
        break;
      case SECCAT_DATA_REL_RO_LOCAL:
!       prefix = one_only ? ".gnu.linkonce.d.rel.ro.local."
! 	       : ".data.rel.ro.local.";
        break;
      case SECCAT_SDATA:
!       prefix = one_only ? ".gnu.linkonce.s." : ".sdata.";
        break;
      case SECCAT_BSS:
!       prefix = one_only ? ".gnu.linkonce.b." : ".bss.";
        break;
      case SECCAT_SBSS:
!       prefix = one_only ? ".gnu.linkonce.sb." : ".sbss.";
        break;
      case SECCAT_TDATA:
!       prefix = one_only ? ".gnu.linkonce.td." : ".tdata.";
        break;
      case SECCAT_TBSS:
!       prefix = one_only ? ".gnu.linkonce.tb." : ".tbss.";
        break;
      default:
        gcc_unreachable ();
      }
-   plen = strlen (prefix);
  
    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
    name = targetm.strip_name_encoding (name);
-   nlen = strlen (name);
  
!   string = alloca (nlen + plen + 1);
!   memcpy (string, prefix, plen);
!   memcpy (string + plen, name, nlen + 1);
  
!   DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
  }
  
  /* Like compute_reloc_for_constant, except for an RTX.  The return value
--- 6284,6356 ----
  {
    /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
    bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;
!   const char *prefix, *name, *linkonce;
    char *string;
  
    switch (categorize_decl_for_section (decl, reloc))
      {
      case SECCAT_TEXT:
!       prefix = one_only ? ".t" : ".text";
        break;
      case SECCAT_RODATA:
      case SECCAT_RODATA_MERGE_STR:
      case SECCAT_RODATA_MERGE_STR_INIT:
      case SECCAT_RODATA_MERGE_CONST:
!       prefix = one_only ? ".r" : ".rodata";
        break;
      case SECCAT_SRODATA:
!       prefix = one_only ? ".s2" : ".sdata2";
        break;
      case SECCAT_DATA:
!       prefix = one_only ? ".d" : ".data";
        break;
      case SECCAT_DATA_REL:
!       prefix = one_only ? ".d.rel" : ".data.rel";
        break;
      case SECCAT_DATA_REL_LOCAL:
!       prefix = one_only ? ".d.rel.local" : ".data.rel.local";
        break;
      case SECCAT_DATA_REL_RO:
!       prefix = one_only ? ".d.rel.ro" : ".data.rel.ro";
        break;
      case SECCAT_DATA_REL_RO_LOCAL:
!       prefix = one_only ? ".d.rel.ro.local" : ".data.rel.ro.local";
        break;
      case SECCAT_SDATA:
!       prefix = one_only ? ".s" : ".sdata";
        break;
      case SECCAT_BSS:
!       prefix = one_only ? ".b" : ".bss";
        break;
      case SECCAT_SBSS:
!       prefix = one_only ? ".sb" : ".sbss";
        break;
      case SECCAT_TDATA:
!       prefix = one_only ? ".td" : ".tdata";
        break;
      case SECCAT_TBSS:
!       prefix = one_only ? ".tb" : ".tbss";
!       break;
!     case SECCAT_EMUTLS_VAR:
!       prefix = targetm.emutls.var_section;
!       break;
!     case SECCAT_EMUTLS_TMPL:
!       prefix = targetm.emutls.tmpl_section;
        break;
      default:
        gcc_unreachable ();
      }
  
    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
    name = targetm.strip_name_encoding (name);
  
!   /* If we're using one_only, then there needs to be a .gnu.linkonce
!      prefix to the section name.  */
!   linkonce = one_only ? ".gnu.linkonce" : "";
!   
!   string = ACONCAT ((linkonce, prefix, ".", name, NULL));
  
!   DECL_SECTION_NAME (decl) = build_string (strlen (string), string);
  }
  
  /* Like compute_reloc_for_constant, except for an RTX.  The return value
*** gcc/config/sparc/sol2-unwind.h.old	Fri Nov 21 09:56:46 2008
--- gcc/config/sparc/sol2-unwind.h	Fri Nov 21 10:01:32 2008
*************** sparc_fallback_frame_state (struct _Unwi
*** 367,372 ****
--- 367,382 ----
  	   another with a stack frame of 160 bytes (the call_user_handler
  	   frame).  The ucontext_t structure is after this offset.  */
  	regs_off = 96 + 96 + 96 + 160;
+       else if (*(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4)
+ 		==  0x9410001b)
+ 	/* This matches the call_user_handler pattern for Solaris 8
+ 	   running inside Solaris Containers. We need to move up four
+ 	   frames (kernel, sigacthandler, call_user_handler, and
+ 	   __sighndlr). Three of them have the minimum stack frame size
+ 	   (kernel, sigacthandler,  and __sighndlr) of 96 bytes, and the
+ 	   call_user_handler frame size is equal to 160 bytes. The
+ 	   ucontext_t structure is after this offset.  */
+ 	regs_off = 96 + 96 + 160 + 96;
        else
  	/* We need to move up three frames (the kernel frame, the
  	   sigacthandler frame, and the __sighndlr frame).  Two of them
*** gcc/config/avr/avr.c.old	Tue Nov 25 11:20:02 2008
--- gcc/config/avr/avr.c	Tue Nov 25 15:03:05 2008
***************
*** 624,629 ****
--- 624,632 ----
  	      && !cfun->machine->is_OS_task
  	      && live_seq);
  
+   if (flag_stack_usage_info)
+     current_function_static_stack_size = size + (AVR_3_BYTE_PC ? 3 : 2);
+ 
    if (cfun->machine->is_interrupt || cfun->machine->is_signal)
      {
        if (cfun->machine->is_interrupt)
***************
*** 648,653 ****
--- 651,659 ----
        insn = emit_move_insn (pushbyte, tmp_reg_rtx);
        RTX_FRAME_RELATED_P (insn) = 1;
  
+       if (flag_stack_usage_info)
+ 	current_function_static_stack_size += 3;
+ 
        /* Push RAMPZ.  */
        if(AVR_HAVE_RAMPZ 
           && (TEST_HARD_REG_BIT (set, REG_Z) && TEST_HARD_REG_BIT (set, REG_Z + 1)))
***************
*** 657,662 ****
--- 663,670 ----
            RTX_FRAME_RELATED_P (insn) = 1;
            insn = emit_move_insn (pushbyte, tmp_reg_rtx);
            RTX_FRAME_RELATED_P (insn) = 1;
+ 	  if (flag_stack_usage_info)
+ 	    current_function_static_stack_size++;
          }
  	
        /* Clear zero reg.  */
***************
*** 678,683 ****
--- 686,693 ----
          emit_insn (gen_call_prologue_saves (gen_int_mode (live_seq, HImode),
  					    gen_int_mode (size + live_seq, HImode)));
        RTX_FRAME_RELATED_P (insn) = 1;
+       if (flag_stack_usage_info)
+ 	current_function_static_stack_size += live_seq;
      }
    else
      {
***************
*** 687,694 ****
            if (TEST_HARD_REG_BIT (set, reg))
              {
                /* Emit push of register to save.  */
!               insn=emit_move_insn (pushbyte, gen_rtx_REG (QImode, reg));
                RTX_FRAME_RELATED_P (insn) = 1;
              }
          }
        if (frame_pointer_needed)
--- 697,706 ----
            if (TEST_HARD_REG_BIT (set, reg))
              {
                /* Emit push of register to save.  */
!               insn = emit_move_insn (pushbyte, gen_rtx_REG (QImode, reg));
                RTX_FRAME_RELATED_P (insn) = 1;
+ 	      if (flag_stack_usage_info)
+ 		current_function_static_stack_size++;
              }
          }
        if (frame_pointer_needed)
***************
*** 698,703 ****
--- 710,717 ----
                /* Push frame pointer.  */
  	      insn = emit_move_insn (pushword, frame_pointer_rtx);
                RTX_FRAME_RELATED_P (insn) = 1;
+ 	      if (flag_stack_usage_info)
+ 		current_function_static_stack_size += 2;
  	    }
  
            if (!size)
***************
*** 776,782 ****
                                           gen_rtx_PLUS (GET_MODE(myfp), myfp, 
                                                         gen_int_mode (-size, GET_MODE(myfp))));
                    RTX_FRAME_RELATED_P (insn) = 1;
!                   insn = emit_move_insn ( stack_pointer_rtx, frame_pointer_rtx);
                    RTX_FRAME_RELATED_P (insn) = 1;
                  }
              }
--- 790,796 ----
                                           gen_rtx_PLUS (GET_MODE(myfp), myfp, 
                                                         gen_int_mode (-size, GET_MODE(myfp))));
                    RTX_FRAME_RELATED_P (insn) = 1;
!                   insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);
                    RTX_FRAME_RELATED_P (insn) = 1;
                  }
              }
*** gcc/c-decl.c.0	2008-06-26 17:42:07.000000000 +0200
--- gcc/c-decl.c	2008-09-25 12:33:34.000000000 +0200
*************** c_write_global_declarations_2 (tree glob
*** 8054,8059 ****
--- 8054,8180 ----
  /* Preserve the external declarations scope across a garbage collect.  */
  static GTY(()) tree ext_block;
  
+ /* Iterate over all global declarations. */
+ static void
+ for_each_global_decl (void (*callback) (tree decl)) {
+   tree t;
+   tree decls;
+   tree decl;
+ 
+   for (t = all_translation_units; t; t = TREE_CHAIN (t))
+     {
+       decls = DECL_INITIAL (t);
+       for (decl = BLOCK_VARS (decls); decl; decl = TREE_CHAIN (decl))
+ 	callback (decl);
+     }
+ 
+   if (ext_block)
+     for (decl = BLOCK_VARS (ext_block); decl; decl = TREE_CHAIN (decl))
+       callback (decl);
+ }
+ 
+ static const char **source_refs = NULL;
+ static int source_refs_used = 0;
+ static int source_refs_allocd = 0;
+ 
+ /* Add an entry to the table source_refs. */
+ static void
+ collect_source_ref (const char *filename)
+ {
+   int i;
+ 
+   if (!filename)
+     return;
+ 
+   if (source_refs_allocd == 0) 
+     {
+       source_refs_allocd = 1024;
+       source_refs = (const char **) 
+ 	xmalloc (source_refs_allocd * sizeof (const char *));
+     }
+ 
+   for (i = 0; i < source_refs_used; i++)
+     if (filename == source_refs [i])
+       return;
+ 
+   if (source_refs_used == source_refs_allocd)
+     {
+       source_refs_allocd *= 2;
+       source_refs = (const char **) 
+ 	xrealloc (source_refs, source_refs_allocd * sizeof (const char *));
+     }
+ 
+   source_refs [source_refs_used++] = filename;
+ }
+ 
+ /* Callback to collect a source_ref from a DECL. */
+ static void
+ collect_source_ref_cb (tree decl)
+ {
+   if (!DECL_IS_BUILTIN (decl))
+     collect_source_ref (LOCATION_FILE (decl_sloc (decl, false)));
+ }
+ 
+ /* Dump all the declarations in source_file to an ada spec. */
+ static void
+ dump_ads (const char *source_file)
+ {
+   char *ads_name;
+   char *pkg_name;
+   char *s;
+   FILE *f;
+ 
+   pkg_name = get_ada_package (source_file);
+ 
+   /* Construct the the .ads filename and package name. */
+   ads_name = xstrdup (pkg_name);
+ 
+   for (s = ads_name; *s; s++)
+     *s = TOLOWER (*s);
+ 
+   ads_name = reconcat (ads_name, ads_name, ".ads", NULL);
+ 
+   /* Write out the .ads file. */
+   f = fopen (ads_name, "w");
+   if (f) 
+     {
+       pretty_printer pp;
+       tree t;
+ 
+       pp_construct (&pp, NULL, 0);
+       pp_needs_newline (&pp) = true;
+       pp.buffer->stream = f;
+       
+       /* Dump all relevant macros */
+       dump_ada_macros (&pp, source_file);
+ 
+       /* Reset the table of withs for this file. */
+       reset_ada_withs ();
+ 
+       /* Collect all references. */
+       for (t = all_translation_units; t; t = TREE_CHAIN (t))
+ 	collect_ada_nodes (BLOCK_VARS (DECL_INITIAL (t)), source_file);
+       
+       if (ext_block)
+ 	collect_ada_nodes (BLOCK_VARS (ext_block), source_file);
+ 
+       /* Dump all references. */
+       dump_ada_nodes (&pp, source_file, NULL);
+ 
+       /* Dump withs. */
+       dump_ada_withs (f);
+ 
+       fprintf (f, "\npackage %s is\n\n", pkg_name);
+       pp_write_text_to_stream (&pp);
+       /* ??? need to free pp */
+       fprintf (f, "end %s;\n", pkg_name);
+       fclose (f);      
+     }
+ 
+   free (ads_name);
+   free (pkg_name);
+ }
+ 
  void
  c_write_global_declarations (void)
  {
*************** c_write_global_declarations (void)
*** 8073,8078 ****
--- 8194,8218 ----
    external_scope = 0;
    gcc_assert (!current_scope);
  
+   /* Handle -fdump-ada-spec[-slim]. */
+   if (dump_enabled_p (TDI_ada))
+     {
+       int i;
+       
+       /* Build a table of files to generate specs for */
+       if (get_dump_file_info (TDI_ada)->flags & TDF_SLIM)
+ 	collect_source_ref (main_input_filename);
+       else
+ 	for_each_global_decl (collect_source_ref_cb);
+       
+       /* Iterate over the list of files to dump specs for */
+       for (i = 0; i < source_refs_used; i++) 
+ 	dump_ads (source_refs [i]);
+ 
+       /* Free files table */
+       free (source_refs);
+     }
+ 
    if (ext_block)
      {
        tree tmp = BLOCK_VARS (ext_block);
*** gcc/c-lex.c.0	2008-06-12 00:45:26.000000000 +0200
--- gcc/c-lex.c	2008-09-25 12:16:55.000000000 +0200
*************** c_lex_with_flags (tree *value, location_
*** 473,485 ****
      case CPP_PRAGMA:
        *value = build_int_cst (NULL, tok->val.pragma);
        break;
! 
!       /* These tokens should not be visible outside cpplib.  */
      case CPP_HEADER_NAME:
-     case CPP_COMMENT:
      case CPP_MACRO_ARG:
        gcc_unreachable ();
  
      default:
        *value = NULL_TREE;
        break;
--- 473,489 ----
      case CPP_PRAGMA:
        *value = build_int_cst (NULL, tok->val.pragma);
        break;
!       
!     /* These tokens should not be visible outside cpplib.  */
      case CPP_HEADER_NAME:
      case CPP_MACRO_ARG:
        gcc_unreachable ();
  
+    /* CPP_COMMENT will appear when compiling with -C and should be
+       ignored. */
+     case CPP_COMMENT:
+       goto retry;
+ 
      default:
        *value = NULL_TREE;
        break;
*** gcc/diagnostic.h.0	2007-09-27 09:24:58.000000000 +0200
--- gcc/diagnostic.h	2008-11-27 17:44:04.000000000 +0100
*************** extern void print_generic_stmt_indented 
*** 219,224 ****
--- 219,238 ----
  extern void print_generic_expr (FILE *, tree, int);
  extern void print_generic_decl (FILE *, tree, int);
  
+ /* In tree-ada-spec.c  */
+ extern void print_generic_ada_decl (pretty_printer *, tree, int (*)(tree, int),
+ 				    const char *);
+ extern char *get_ada_package (const char *);
+ extern location_t decl_sloc (const_tree, bool);
+ extern void collect_ada_nodes (tree t, const char *source_file);
+ extern void dump_ada_nodes (pretty_printer *, const char *, 
+ 			    int (*)(tree, int));
+ extern void reset_ada_withs (void);
+ extern void dump_ada_withs (FILE *f);
+ 
+ /* In c-macros.c  */
+ extern void dump_ada_macros (pretty_printer *, const char *);
+ 
  extern void debug_generic_expr (tree);
  extern void debug_generic_stmt (tree);
  extern void debug_tree_chain (tree);
*** gcc/gcc.c.0	2008-11-27 17:21:04.000000000 +0100
--- gcc/gcc.c	2008-11-27 17:21:38.000000000 +0100
*************** static const char *trad_capable_cpp =
*** 789,796 ****
     therefore no dependency entry, confuses make into thinking a .o
     file that happens to exist is up-to-date.  */
  static const char *cpp_unique_options =
! "%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\
!  %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\
   %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
   %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\
   %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\
--- 789,795 ----
     therefore no dependency entry, confuses make into thinking a .o
     file that happens to exist is up-to-date.  */
  static const char *cpp_unique_options =
! "%{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\
   %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
   %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\
   %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\
*************** static const struct compiler default_com
*** 1011,1021 ****
  		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\
  		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \
  			%(cc1_options)\
!                         -o %g.s %{!o*:--output-pch=%i.gch}\
                          %W{o*:--output-pch=%*}%V}\
  	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
  		cc1 %(cpp_unique_options) %(cc1_options)\
!                     -o %g.s %{!o*:--output-pch=%i.gch}\
                      %W{o*:--output-pch=%*}%V}}}}}}", 0, 0, 0},
    {".i", "@cpp-output", 0, 1, 0},
    {"@cpp-output",
--- 1010,1020 ----
  		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\
  		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \
  			%(cc1_options)\
!                         -o %g.s %{!o*:%{!fdump-ada*:--output-pch=%i.gch}}\
                          %W{o*:--output-pch=%*}%V}\
  	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
  		cc1 %(cpp_unique_options) %(cc1_options)\
!                     -o %g.s %{!o*:%{!fdump-ada*:--output-pch=%i.gch}}\
                      %W{o*:--output-pch=%*}%V}}}}}}", 0, 0, 0},
    {".i", "@cpp-output", 0, 1, 0},
    {"@cpp-output",
*** gcc/Makefile.in.0	2008-11-27 17:21:02.000000000 +0100
--- gcc/Makefile.in	2008-11-27 17:21:23.000000000 +0100
*************** C_AND_OBJC_OBJS = attribs.o c-errors.o c
*** 1009,1015 ****
    c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
    c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
    c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \
!   c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o
  
  # Language-specific object files for C.
  C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)
--- 1009,1015 ----
    c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
    c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
    c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \
!   c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o c-macros.o
  
  # Language-specific object files for C.
  C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)
*************** OBJS-common = \
*** 1169,1174 ****
--- 1169,1175 ----
  	timevar.o \
  	toplev.o \
  	tracer.o \
+ 	tree-ada-spec.o \
  	tree-affine.o \
  	tree-cfg.o \
  	tree-cfgcleanup.o \
*************** c-common.o : c-common.c $(CONFIG_H) $(SY
*** 1828,1833 ****
--- 1829,1837 ----
  	intl.h opts.h $(REAL_H) $(CPPLIB_H) $(TREE_INLINE_H) $(HASHTAB_H) \
  	$(BUILTINS_DEF)
  
+ c-macros.o : c-macros.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+ 	$(DIAGNOSTIC_H) $(TOPLEV_H) $(C_PRAGMA_H) $(CPP_ID_DATA_H)
+ 
  c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \
  	$(C_TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(REAL_H) \
  	$(DIAGNOSTIC_H) tree-iterator.h fixed-value.h
*************** tree-pretty-print.o : tree-pretty-print.
*** 2335,2340 ****
--- 2339,2348 ----
     $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \
     $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h tree-pass.h \
     value-prof.h fixed-value.h output.h
+ tree-ada-spec.o : tree-ada-spec.c $(CONFIG_H) $(SYSTEM_H) \
+    $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \
+    $(TM_H) coretypes.h tree-iterator.h tree-pass.h \
+    value-prof.h fixed-value.h output.h
  fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(TREE_H) $(FLAGS_H) $(REAL_H) toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) \
     $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h fixed-value.h
*** gcc/tree-dump.c.0	2008-02-13 12:15:51.000000000 +0100
--- gcc/tree-dump.c	2008-09-25 12:37:52.000000000 +0200
*************** static struct dump_file_info dump_files[
*** 790,796 ****
    {".gimple", "tree-gimple", NULL, TDF_TREE, 0, 4, 0},
    {".nested", "tree-nested", NULL, TDF_TREE, 0, 5, 0},
    {".vcg", "tree-vcg", NULL, TDF_TREE, 0, 6, 0},
! #define FIRST_AUTO_NUMBERED_DUMP 7
  
    {NULL, "tree-all", NULL, TDF_TREE, 0, 0, 0},
    {NULL, "rtl-all", NULL, TDF_RTL, 0, 0, 0},
--- 790,797 ----
    {".gimple", "tree-gimple", NULL, TDF_TREE, 0, 4, 0},
    {".nested", "tree-nested", NULL, TDF_TREE, 0, 5, 0},
    {".vcg", "tree-vcg", NULL, TDF_TREE, 0, 6, 0},
!   {".ads", "ada-spec", NULL, 0, 0, 7, 0},
! #define FIRST_AUTO_NUMBERED_DUMP 8
  
    {NULL, "tree-all", NULL, TDF_TREE, 0, 0, 0},
    {NULL, "rtl-all", NULL, TDF_RTL, 0, 0, 0},
*** gcc/tree-pass.h.0	2008-11-27 17:21:04.000000000 +0100
--- gcc/tree-pass.h	2008-11-27 17:21:38.000000000 +0100
*************** enum tree_dump_index
*** 37,42 ****
--- 37,43 ----
    TDI_nested,			/* dump each function after unnesting it */
    TDI_vcg,			/* create a VCG graph file for each
  				   function's flowgraph.  */
+   TDI_ada,                      /* dump declarations in Ada syntax. */
    TDI_tree_all,                 /* enable all the GENERIC/GIMPLE dumps.  */
    TDI_rtl_all,                  /* enable all the RTL dumps.  */
    TDI_ipa_all,                  /* enable all the IPA dumps.  */
*** /dev/null	2006-06-16 15:07:58.000000000 +0200
--- gcc/tree-ada-spec.c	2008-11-27 17:28:05.000000000 +0100
***************
*** 0 ****
--- 1,2096 ----
+ /* Print GENERIC declaration (functions, variables, types) trees in Ada syntax.
+    Copyright (C) 2008
+    Free Software Foundation, Inc.
+    Adapted from tree-pretty-print.c by Arnaud Charlet  <charlet@adacore.com>
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "coretypes.h"
+ #include "tm.h"
+ #include "tree.h"
+ #include "output.h"
+ #include "diagnostic.h"
+ #include "real.h"
+ #include "hashtab.h"
+ #include "tree-flow.h"
+ #include "langhooks.h"
+ #include "tree-iterator.h"
+ #include "tree-chrec.h"
+ #include "tree-pass.h"
+ #include "fixed-value.h"
+ #include "value-prof.h"
+ #include "predict.h"
+ #include "cpplib.h"
+ #include "c-pragma.h"
+ 
+ /* Local functions, macros and variables.  */
+ static int dump_generic_ada_node (pretty_printer *, tree, tree,
+ 				  int (*)(tree, int), int, int, bool);
+ static int print_ada_declaration (pretty_printer *, tree, tree,
+ 				  int (*cpp_check)(tree, int), int);
+ static void print_ada_struct_decl (pretty_printer *, const_tree, tree,
+ 				   int (*cpp_check)(tree, int), int, bool);
+ static void dump_sloc (pretty_printer *buffer, tree node);
+ 
+ static void print_comment (pretty_printer *, const char *);
+ 
+ static int is_struct_like (const_tree type);
+ 
+ /* This macro should be in input.h. */
+ #define LOCATION_COL(LOC) ((expand_location (LOC)).column)
+ 
+ #define INDENT(SPACE) do { \
+   int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)
+ 
+ static const char *source_file_base;
+ 
+ /* Compare the declaration of struct-like types based on the sloc of
+    their last field, so that more nested types collate before less
+    nested ones. */
+ 
+ location_t
+ decl_sloc (const_tree decl, bool last) 
+ {
+   tree type = TREE_TYPE (decl);
+ 
+   if (TREE_CODE (decl) == TYPE_DECL 
+       && !DECL_ORIGINAL_TYPE (decl)
+       && is_struct_like (type) 
+       && TYPE_FIELDS (type))
+     {
+       tree f = TYPE_FIELDS (type);
+ 
+       if (last)
+ 	while (TREE_CHAIN (f))
+ 	  f = TREE_CHAIN (f);
+ 
+       return DECL_SOURCE_LOCATION (f);
+     }
+   else
+     return DECL_SOURCE_LOCATION (decl);
+ }
+ 
+ /* Sort two declarations by source location. */
+ 
+ static int 
+ compare_node (const void *lp, const void *rp)
+ {
+   const_tree lhs = *((const tree *) lp);
+   const_tree rhs = *((const tree *) rp);
+ 
+   return decl_sloc (lhs, true) - decl_sloc (rhs, true);
+ }
+ 
+ /* Sort two comments by source location. */
+ 
+ static int
+ compare_comment (const void *lp, const void *rp)
+ {
+   const cpp_comment *lhs = (const cpp_comment *) lp;
+   const cpp_comment *rhs = (const cpp_comment *) rp;
+   
+   if (LOCATION_FILE (lhs->sloc) != LOCATION_FILE (rhs->sloc))
+     return strcmp (LOCATION_FILE (lhs->sloc), LOCATION_FILE (rhs->sloc));
+ 
+   if (LOCATION_LINE (lhs->sloc) != LOCATION_LINE (rhs->sloc))
+     return LOCATION_LINE (lhs->sloc) - LOCATION_LINE (rhs->sloc);
+ 
+   if (LOCATION_COL (lhs->sloc) != LOCATION_COL (rhs->sloc))
+     return LOCATION_COL (lhs->sloc) - LOCATION_COL (rhs->sloc);
+ 
+   return 0;
+ }
+ 
+ static tree *to_dump = NULL;
+ static int to_dump_count = 0;
+ 
+ /* Collect a list of declarations to be dumped by a subsequent call to
+    dump_ada_nodes. */
+ 
+ void
+ collect_ada_nodes (tree t, const char *source_file) 
+ {
+   tree n;
+   int i = to_dump_count;
+ 
+   /* Count the likely relevant nodes. */
+   for (n = t; n; n = TREE_CHAIN (n)) 
+     if (!DECL_IS_BUILTIN (n)
+ 	&& LOCATION_FILE (decl_sloc (n, false)) == source_file)
+       to_dump_count++;
+   
+   /* Allocate sufficient storage for all nodes. */
+   to_dump = (tree *) xrealloc (to_dump, sizeof (tree) * to_dump_count);
+ 
+   /* Store the relevant nodes. */
+   for (n = t; n; n = TREE_CHAIN (n))
+     if (!DECL_IS_BUILTIN (n)
+ 	&& LOCATION_FILE (decl_sloc (n, false)) == source_file)
+       to_dump [i++] = n;
+ }
+ 
+ /* Dump nodes collected by previous calls to collect_ada_nodes. */
+ 
+ void
+ dump_ada_nodes (pretty_printer *pp, const char *source_file,
+ 		int (*cpp_check)(tree, int))
+ { 
+   int i,j;
+   cpp_comment_table *comments;
+ 
+   /* Sort the table of declarations to dump by sloc. */
+   qsort (to_dump, to_dump_count, sizeof (tree), compare_node);
+ 
+   /* Fetch the table of comments. */
+   comments = cpp_get_comments (parse_in);
+   
+   /* Sort the comments table by sloc. */
+   qsort (comments->entries, comments->count, sizeof (cpp_comment), 
+ 	 compare_comment);
+   
+   /* Interleave comments and declarations in line number order. */
+   i = j = 0;
+   do 
+     {
+       /* Advance j until comment j is in this file. */
+       while (j != comments->count 
+ 	     && LOCATION_FILE (comments->entries[j].sloc) != source_file)
+ 	j++;
+ 
+       /* Advance j until comment j is not a duplicate. */
+       while (j < comments->count - 1 &&
+ 	     !compare_comment (&comments->entries[j], 
+ 			       &comments->entries[j + 1]))
+ 	j++;
+   
+       /* Write decls until decl i collates after comment j. */
+       while (i != to_dump_count)
+ 	{
+ 	  if (j == comments->count 
+ 	      || LOCATION_LINE (decl_sloc (to_dump[i], false)) 
+ 	      <  LOCATION_LINE (comments->entries[j].sloc))
+ 	    print_generic_ada_decl (pp, to_dump[i++], cpp_check, source_file);
+ 	  else
+ 	    break;
+ 	}
+ 	 
+       /* Write comment j, if there is one. */
+       if (j != comments->count)
+ 	print_comment (pp, comments->entries[j++].comment);
+ 	
+     } while (i != to_dump_count || j != comments->count);
+ 
+   /* Finalize the to_dump table. */
+   if (to_dump) 
+     {
+       free (to_dump);
+       to_dump = NULL;
+       to_dump_count = 0;
+     }
+ } 
+ 
+ /* Print a comment to the output stream. */
+ 
+ static void 
+ print_comment (pretty_printer *pp, const char *comment) 
+ {
+   int len = strlen (comment);
+   char *str = (char *) alloca (len + 1);
+   char *tok; 
+   bool extra_newline = false;
+ 
+   memcpy (str, comment, len + 1);
+ 
+   /* Trim C/C++ comment indicators. */
+   if (str[len - 2] == '*' && str[len - 1] == '/')
+     {
+       str[len - 2] = ' ';
+       str[len - 1] = '\0';
+     }
+   str += 2;
+ 
+   tok = strtok (str, "\n"); 
+   while (tok) {
+     pp_string (pp, "  --");
+     pp_string (pp, tok);
+     pp_newline (pp);
+     tok = strtok (NULL, "\n");
+ 
+     /* Leave a blank line after multi-line comments. */
+     if (tok) 
+       extra_newline = true;
+   }
+ 
+   if (extra_newline)
+     pp_newline (pp);
+ }
+ 
+ /* Same as print_generic_decl with Ada syntax */
+ 
+ void
+ print_generic_ada_decl (pretty_printer *pp, tree decl,
+ 			int (*cpp_check)(tree, int),
+ 			const char* source_file)
+ {
+   source_file_base = source_file;
+ 
+   if (print_ada_declaration (pp, decl, 0, cpp_check, 2))
+     {
+       pp_newline (pp);
+       pp_newline (pp);
+     }
+ }
+ 
+ static void
+ newline_and_indent (pretty_printer *buffer, int spc)
+ {
+   pp_newline (buffer);
+   INDENT (spc);
+ }
+ 
+ struct with { char *s; const char *in_file; int limited; };
+ static struct with *withs = NULL;
+ static int withs_max = 4096;
+ static int with_len = 0;
+ 
+ static void
+ append_withs (const char *s, int limited_access)
+ {
+   int i;
+ 
+   if (withs == NULL)
+     withs = (struct with *)xmalloc (withs_max * sizeof (struct with));
+ 
+   if (with_len == withs_max)
+     {
+       withs_max *= 2;
+       withs = (struct with *)
+ 	xrealloc (withs, withs_max * sizeof (struct with));
+     }
+ 
+   for (i = 0; i < with_len; i++)
+     if (!strcmp (s, withs [i].s)
+ 	&& source_file_base == withs [i].in_file)
+       {
+ 	withs [i].limited &= limited_access;
+ 	return;
+       }
+ 
+   withs [with_len].s = xstrdup (s);
+   withs [with_len].in_file = source_file_base;
+   withs [with_len].limited = limited_access;
+   with_len++;
+ }
+ 
+ void
+ reset_ada_withs (void)
+ {
+   int i;
+ 
+   if (!withs)
+     return;
+ 
+   for (i = 0; i < with_len; i++)
+     free (withs [i].s);
+   free (withs);
+   withs = NULL;
+   withs_max = 4096;
+   with_len = 0;
+ }
+ 
+ void
+ dump_ada_withs (FILE *f)
+ {
+   int i;
+ 
+   fprintf (f, "with Interfaces.C; use Interfaces.C;\n");
+ 
+   for (i = 0; i < with_len; i++)
+     fprintf
+       (f, "%swith %s;\n", withs [i].limited ? "limited " : "", withs [i].s);
+ }
+ 
+ char *
+ get_ada_package (const char *file)
+ {
+   const char *base;
+   char *res;
+   const char *s;
+   int i;
+ 
+   s = strstr (file, "/include/");
+   if (s)
+     base = s + 9;
+   else
+     base = lbasename (file);
+   res = (char *) xmalloc (strlen (base) + 1);
+ 
+   for (i = 0; *base; base++, i++)
+     switch (*base)
+       {
+ 	case '+':
+ 	  res [i] = 'p';
+ 	  break;
+ 
+ 	case '.':
+ 	case '-':
+ 	case '_':
+ 	case '/':
+ 	case '\\':
+ 	  res [i] = (i == 0 || res [i - 1] == '_') ? 'u' : '_';
+ 	  break;
+ 
+ 	default:
+ 	  res [i] = *base;
+ 	  break;
+       }
+   res [i] = '\0';
+ 
+   return res;
+ }
+ 
+ static const char *ada_reserved[] = {
+   "abort", "abs", "abstract", "accept", "access", "aliased", "all", "and",
+   "array", "at", "begin", "body", "case", "constant", "declare", "delay",
+   "delta", "digits", "do", "else", "elsif", "end", "entry", "exception",
+   "exit", "for", "function", "generic", "goto", "if", "in", "interface", "is",
+   "limited", "loop", "mod", "new", "not", "null", "others", "out", "of", "or",
+   "overriding", "package", "pragma", "private", "procedure", "protected",
+   "raise", "range", "record", "rem", "renames", "requeue", "return", "reverse",
+   "select", "separate", "subtype", "synchronized", "tagged", "task",
+   "terminate", "then", "type", "until", "use", "when", "while", "with", "xor",
+   NULL};
+ 
+ /* ??? would be nice to specify this list via a config file, so that users
+    can create their own dictionnary of conflicts.  */
+ static const char *c_duplicates[] = {
+   /* system will cause troubles with System.Address */
+   "system",
+ 
+   /* the following values have other definitions with same name/other casing */
+   "funmap",
+   "rl_vi_fWord",
+   "rl_vi_bWord",
+   "rl_vi_eWord",
+   "rl_readline_version",
+   "_Vx_ushort",
+   "USHORT",
+   "XLookupKeysym",
+   NULL};
+ 
+ static int
+ is_struct_like (const_tree type)
+ {
+   return TREE_CODE (type) == RECORD_TYPE
+          || TREE_CODE (type) == UNION_TYPE
+          || TREE_CODE (type) == QUAL_UNION_TYPE;
+ }
+ 
+ static tree
+ get_underlying_decl (tree type)
+ {
+   tree decl = NULL_TREE;
+ 
+   if (type == NULL_TREE)
+     return NULL_TREE;
+ 
+   /* type is a declaration. */
+   if (DECL_P (type))
+     decl = type;
+ 
+   /* type is a typedef. */
+   if (TYPE_P (type) && TYPE_NAME (type) && DECL_P (TYPE_NAME (type)))
+     decl = TYPE_NAME (type);
+ 
+   /* TYPE_STUB_DECL has been set for type. */
+   if (TYPE_P (type) && TYPE_STUB_DECL (type) &&
+       DECL_P (TYPE_STUB_DECL (type)))
+     decl = TYPE_STUB_DECL (type);
+ 
+   return decl;
+ }
+ 
+ /* Dump the name of an identifier node, following Ada syntax */
+ 
+ static void
+ pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,
+ 			int limited_access)
+ {
+   const char *name = IDENTIFIER_POINTER (node);
+   const char **names;
+   int len = IDENTIFIER_LENGTH (node);
+   int j, len2 = 0;
+   int space_found = false;
+   int found = false;
+   char *s = (char *) alloca (len * 2 + 5);
+   char c;
+   tree decl;
+ 
+   /* Add trailing "c_" if name is an Ada reserved word */
+   for (names = ada_reserved; *names; names++)
+     if (!strcmp (name, *names))
+       {
+ 	s [len2++] = 'c';
+ 	s [len2++] = '_';
+ 	found = true;
+ 	break;
+       }
+ 
+   if (!found)
+     /* Add trailing "c_" if name is an potential case sensitive duplicate */
+     for (names = c_duplicates; *names; names++)
+       if (!strcmp (name, *names))
+ 	{
+ 	  s [len2++] = 'c';
+ 	  s [len2++] = '_';
+ 	  found = true;
+ 	  break;
+ 	}
+ 
+   for (j = 0; name [j] == '_'; j++)
+     s [len2++] = 'u';
+ 
+   if (j > 0)
+     s [len2++] = '_';
+   else if (*name == '.')
+     {
+       s [0] = 'a';
+       s [1] = 'n';
+       s [2] = 'o';
+       s [3] = 'n';
+       len2 = 4;
+       j++;
+     }
+ 
+   /* Replace unsuitable characters for Ada identifiers */
+ 
+   for (; j < len; j++)
+     switch (name [j])
+       {
+ 	case ' ':
+ 	  space_found = true;
+ 	  s [len2++] = '_';
+ 	  break;
+ 
+ 	/* ??? missing some C++ operators */
+ 	case '=':
+ 	  s [len2++] = '_';
+ 
+ 	  if (name [j + 1] == '=')
+ 	    {
+ 	      s [len2++] = 'e';
+ 	      s [len2++] = 'q';
+ 	    }
+ 	  else
+ 	    {
+ 	      s [len2++] = 'a';
+ 	      s [len2++] = 's';
+ 	    }
+ 	  break;
+ 
+ 	case '<':
+ 	case '>':
+ 	  c = name [j] == '<' ? 'l' : 'g';
+ 	  s [len2++] = '_';
+ 
+ 	  switch (name [j + 1]) {
+ 	    case '\0':
+ 	      s [len2++] = c;
+ 	      s [len2++] = 't';
+ 	      break;
+ 	    case '=':
+ 	      s [len2++] = c;
+ 	      s [len2++] = 'e';
+ 	      break;
+ 	    case '>':
+ 	      s [len2++] = 's';
+ 	      s [len2++] = 'r';
+ 	      break;
+ 	    case '<':
+ 	      s [len2++] = 's';
+ 	      s [len2++] = 'l';
+ 	      break;
+ 	    default:
+ 	      break;
+ 	  }
+ 	  break;
+ 
+ 	case '_':
+ 	  if (len2 && s [len2 - 1] == '_')
+ 	    s [len2++] = 'u';
+ 	  /* falltrough */
+ 
+ 	default:
+ 	  s [len2++] = name [j];
+       }
+ 
+   if (s [len2 - 1] == '_')
+     s [len2++] = 'u';
+ 
+   s [len2] = '\0';
+ 
+   /* If the entity comes from another file, generate "package" prefix */
+ 
+   decl = get_underlying_decl (type);
+ 
+   if (decl)
+     {
+       expanded_location xloc = expand_location (decl_sloc (decl, false));
+ 
+       if (xloc.file && xloc.line)
+ 	{
+ 	  if (xloc.file != source_file_base)
+ 	    {
+ 	      char *s1 = get_ada_package (xloc.file);
+ 
+ 	      append_withs (s1, limited_access);
+ 	      pp_string (buffer, s1);
+ 	      pp_character (buffer, '.');
+ 	      free (s1);
+ 	    }
+ 	}
+     }
+ 
+   if (space_found)
+     if (!strcmp (s, "short_int"))
+       pp_string (buffer, "short");
+     else if (!strcmp (s, "short_unsigned_int"))
+       pp_string (buffer, "unsigned_short");
+     else if (!strcmp (s, "unsigned_int"))
+       pp_string (buffer, "unsigned");
+     else if (!strcmp (s, "long_int"))
+       pp_string (buffer, "long");
+     else if (!strcmp (s, "long_unsigned_int"))
+       pp_string (buffer, "unsigned_long");
+     else if (!strcmp (s, "long_long_int"))
+       pp_string (buffer, "Long_Long_Integer");
+     else if (!strcmp (s, "long_long_unsigned_int"))
+       {
+ 	append_withs ("Interfaces.C.Extensions", false);
+ 	pp_string (buffer, "Extensions.unsigned_long_long");
+       }
+     else
+       pp_string(buffer, s);
+   else
+     pp_string(buffer, s);
+ }
+ 
+ static void
+ pp_asm_name (pretty_printer *buffer, tree t)
+ {
+   tree name = DECL_ASSEMBLER_NAME (t);
+   char *ada_name = (char *)alloca (IDENTIFIER_LENGTH (name) + 1), *s;
+   const char *ident = IDENTIFIER_POINTER (name);
+ 
+   for (s = ada_name; *ident; ident++)
+     {
+       if (*ident == ' ')
+ 	break;
+       else if (*ident != '*')
+ 	*s++ = *ident;
+     }
+ 
+   *s = '\0';
+   pp_string (buffer, ada_name);
+ }
+ 
+ /* Dump the name of a _DECL node if set, following Ada syntax */
+ 
+ static void
+ dump_ada_decl_name (pretty_printer *buffer, tree decl, int limited_access)
+ {
+   if (DECL_NAME (decl))
+     pp_ada_tree_identifier (buffer, DECL_NAME (decl), decl, limited_access);
+   else 
+     {
+       tree type_name = TYPE_NAME (TREE_TYPE (decl));
+       if (TREE_CODE (type_name) == IDENTIFIER_NODE)
+ 	pp_ada_tree_identifier (buffer, type_name, decl, limited_access);
+     }
+ }
+ 
+ static void
+ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2, const char *s)
+ {
+   if (DECL_NAME (t1))
+     pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, false);
+   else
+     {
+       pp_string (buffer, "anon");
+       pp_scalar (buffer, "%d", DECL_UID (t1));
+     }
+ 
+   pp_character (buffer, '_');
+ 
+   if (DECL_NAME (t1))
+     pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, false);
+   else
+     {
+       pp_string (buffer, "anon");
+       pp_scalar (buffer, "%d", DECL_UID (t2));
+     }
+ 
+   pp_string (buffer, s);
+ }
+ 
+ /* Dump pragma Import C/CPP on a given node */
+ 
+ static void
+ dump_ada_import (pretty_printer *buffer, tree t)
+ {
+   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));
+ 
+   if (name [0] == '_' && name [1] == 'Z')
+     pp_string (buffer, "pragma Import (CPP, ");
+   else
+     pp_string (buffer, "pragma Import (C, ");
+ 
+   dump_ada_decl_name (buffer, t, false);
+   pp_string (buffer, ", \"");
+   pp_asm_name (buffer, t);
+   pp_string (buffer, "\");");
+ }
+ 
+ /* check whether t and its type have different names, and append "the_"
+   otherwise.  */
+ static void
+ check_name (pretty_printer *buffer, tree t)
+ {
+   const char *s;
+   tree tmp = TREE_TYPE (t);
+ 
+   while (TREE_CODE (tmp) == POINTER_TYPE)
+     tmp = TREE_TYPE (tmp);
+ 
+   if (TREE_CODE (tmp) != FUNCTION_TYPE)
+     {
+       if (TREE_CODE (tmp) == IDENTIFIER_NODE)
+ 	s = IDENTIFIER_POINTER (tmp);
+       else if (!TYPE_NAME (tmp))
+         s = "";
+       else if (TREE_CODE (TYPE_NAME (tmp)) == IDENTIFIER_NODE)
+ 	s = IDENTIFIER_POINTER (TYPE_NAME (tmp));
+       else
+ 	s = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (tmp)));
+ 
+       if (!strcasecmp (IDENTIFIER_POINTER (DECL_NAME (t)), s))
+ 	pp_string (buffer, "the_");
+     }
+ }
+ 
+ /* Dump a function declaration with Ada syntax */
+ 
+ static int
+ dump_ada_function_declaration (pretty_printer *buffer, tree func, tree type,
+ 			       int is_method, int is_constructor, int spc)
+ {
+   tree arg;
+   tree node = TREE_TYPE (func);
+   char buf [16];
+   int num = 0, num_args = 0, have_args = true, have_ellipsis = false;
+ 
+   /* Compute number of arguments */
+   arg = TYPE_ARG_TYPES (node);
+ 
+   if (arg)
+     {
+       while (TREE_CHAIN (arg) && arg != error_mark_node)
+ 	{
+ 	  num_args++;
+ 	  arg = TREE_CHAIN (arg);
+ 	}
+ 
+       if (TREE_CODE (TREE_VALUE (arg)) != VOID_TYPE)
+ 	{
+ 	  num_args++;
+ 	  have_ellipsis = true;
+ 	}
+     }
+ 
+   if (is_constructor)
+     num_args--;
+ 
+   if (num_args > 2)
+     newline_and_indent (buffer, spc + 1);
+ 
+   if (num_args > 0)
+     {
+       pp_space (buffer);
+       pp_character (buffer, '(');
+     }
+ 
+   if (TREE_CODE (func) == FUNCTION_DECL)
+     arg = DECL_ARGUMENTS (func);
+   else
+     arg = NULL_TREE;
+ 
+   if (arg == NULL_TREE)
+     {
+       have_args = false;
+       arg = TYPE_ARG_TYPES (node);
+ 
+       if (arg && TREE_CODE (TREE_VALUE (arg)) == VOID_TYPE)
+ 	arg = NULL_TREE;
+     }
+ 
+   if (is_constructor)
+     arg = TREE_CHAIN (arg);
+ 
+   /* Print the argument names (if available) & types. */
+ 
+   while (arg && arg != error_mark_node)
+     {
+       num++;
+ 
+       if (have_args)
+ 	{
+ 	  if (DECL_NAME (arg))
+ 	    {
+ 	      check_name (buffer, arg);
+ 	      pp_ada_tree_identifier (buffer, DECL_NAME (arg), 0, false);
+ 	      pp_string (buffer, " : ");
+ 	    }
+ 	  else
+ 	    {
+ 	      sprintf (buf, "arg%d : ", num);
+ 	      pp_string (buffer, buf);
+ 	    }
+ 
+ 	  dump_generic_ada_node
+ 	    (buffer, TREE_TYPE (arg), type, NULL, spc, 0, true);
+ 	}
+       else
+ 	{
+ 	  sprintf (buf, "arg%d : ", num);
+ 	  pp_string (buffer, buf);
+ 	  dump_generic_ada_node
+ 	    (buffer, TREE_VALUE (arg), type, NULL, spc, 0, true);
+ 	}
+ 
+       if (is_method && num == 1 && !DECL_VINDEX (func) && !is_constructor)
+         pp_string (buffer, "'Class");
+ 
+       arg = TREE_CHAIN (arg);
+ 
+       if (arg == NULL_TREE ||
+ 	  (!have_args && TREE_CODE (TREE_VALUE (arg)) == VOID_TYPE))
+         break;
+ 
+       pp_character (buffer, ';');
+ 
+       if (num_args > 2)
+ 	newline_and_indent (buffer, spc + 3);
+       else
+ 	pp_space (buffer);
+     }
+ 
+   if (have_ellipsis)
+     {
+       pp_string (buffer, "  -- , ...");
+       newline_and_indent (buffer, spc + 2);
+     }
+ 
+   if (num_args > 0)
+     pp_character (buffer, ')');
+   return num_args;
+ }
+ 
+ /* Dump all the domains associated with an array, using Ada syntax.  */
+ 
+ static void
+ dump_ada_array_domains (pretty_printer *buffer, tree node, int spc)
+ {
+   int first = 1;
+   pp_character (buffer, '(');
+ 
+   for (; TREE_CODE (node) == ARRAY_TYPE; node = TREE_TYPE (node))
+     {
+       tree domain = TYPE_DOMAIN (node);
+ 
+       if (domain)
+         {
+           tree min = TYPE_MIN_VALUE (domain);
+           tree max = TYPE_MAX_VALUE (domain);
+ 
+ 	  if (!first)
+ 	    pp_string (buffer, ", ");
+ 	  first = 0;
+ 
+           if (min)
+ 	    dump_generic_ada_node
+ 	      (buffer, min, NULL_TREE, NULL, spc, 0, true);
+           pp_string (buffer, " .. ");
+ 
+ 	  /* If the upper bound is zero, gcc may generate a NULL_TREE
+ 	     for TYPE_MAX_VALUE rather than an integer_cst. */
+           if (max)
+ 	    dump_generic_ada_node
+ 	      (buffer, max, NULL_TREE, NULL, spc, 0, true);
+ 	  else
+ 	    pp_string (buffer, "0");
+ 	    
+         }
+       else
+         pp_string (buffer, "0 .. int'Last");
+     }
+   pp_character (buffer, ')');
+ }
+ 
+ /* Ada version */
+ 
+ static void
+ dump_sloc (pretty_printer *buffer, tree node)
+ {
+   expanded_location xloc;
+ 
+   xloc.file = NULL;
+ 
+   if (TREE_CODE_CLASS (TREE_CODE (node)) == tcc_declaration)
+     xloc = expand_location (DECL_SOURCE_LOCATION (node));
+   else if (EXPR_HAS_LOCATION (node))
+     xloc = expand_location (EXPR_LOCATION (node));
+ 
+   if (xloc.file)
+     {
+       pp_string (buffer, xloc.file);
+       pp_string (buffer, ":");
+       pp_decimal_int (buffer, xloc.line);
+       pp_string (buffer, ":");
+       pp_decimal_int (buffer, xloc.column);
+     }
+ }
+ 
+ static bool in_function = true;
+ static bool bitfield_used = false;
+ 
+ static int
+ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,
+ 		       int (*cpp_check)(tree, int), int spc,
+ 		       int limited_access, bool name_only)
+ {
+   bool is_expr;
+ 
+   if (node == NULL_TREE)
+     return spc;
+ 
+   is_expr = EXPR_P (node) || GIMPLE_STMT_P (node);
+ 
+   switch (TREE_CODE (node))
+     {
+     case ERROR_MARK:
+       pp_string (buffer, "<<< error >>>");
+       break;
+ 
+     case IDENTIFIER_NODE:
+       pp_ada_tree_identifier (buffer, node, type, limited_access);
+       break;
+ 
+     case TREE_LIST:
+       while (node && node != error_mark_node)
+ 	{
+ 	  if (TREE_PURPOSE (node))
+ 	    {
+ 	      dump_generic_ada_node
+ 		(buffer, TREE_PURPOSE (node), type, cpp_check, spc,
+ 		 limited_access, name_only);
+ 	      pp_space (buffer);
+ 	    }
+ 	  dump_generic_ada_node
+ 	    (buffer, TREE_VALUE (node), type, cpp_check,
+ 	     spc, limited_access, name_only);
+ 	  node = TREE_CHAIN (node);
+ 	  if (node && TREE_CODE (node) == TREE_LIST)
+ 	    {
+ 	      pp_character (buffer, ',');
+ 	      pp_space (buffer);
+ 	    }
+ 	}
+       break;
+ 
+     case TREE_BINFO:
+       dump_generic_ada_node
+ 	(buffer, BINFO_TYPE (node), type, cpp_check,
+ 	 spc, limited_access, name_only);
+ 
+     case TREE_VEC:
+       {
+ 	size_t i;
+ 	if (TREE_VEC_LENGTH (node) > 0)
+ 	  {
+ 	    size_t len = TREE_VEC_LENGTH (node);
+ 	    for (i = 0; i < len - 1; i++)
+ 	      {
+ 		dump_generic_ada_node
+ 		  (buffer, TREE_VEC_ELT (node, i), type, cpp_check,
+ 		   spc, limited_access, name_only);
+ 		pp_character (buffer, ',');
+ 		pp_space (buffer);
+ 	      }
+ 	    dump_generic_ada_node
+ 	      (buffer, TREE_VEC_ELT (node, len - 1), type, cpp_check,
+ 	       spc, limited_access, name_only);
+ 	  }
+       }
+       break;
+ 
+     case VOID_TYPE:
+       append_withs ("System", false);
+       pp_string (buffer, "System.Address");
+       break;
+ 
+     case VECTOR_TYPE:
+       pp_string (buffer, "<vector>");
+       break;
+ 
+     case COMPLEX_TYPE:
+       pp_string (buffer, "<complex>");
+       break;
+ 
+     case ENUMERAL_TYPE:
+       if (name_only)
+         dump_generic_ada_node
+           (buffer, TYPE_NAME (node), node, cpp_check, spc, 0, true);
+       else
+         {
+           tree value;
+ 
+           pp_string (buffer, "unsigned");
+ 
+           for (value = TYPE_VALUES (node); value; value = TREE_CHAIN (value))
+ 	    {
+ 	      pp_semicolon (buffer);
+ 	      newline_and_indent (buffer, spc);
+ 
+ 	      pp_ada_tree_identifier
+ 		(buffer, TREE_PURPOSE (value), node, false);
+ 	      pp_string (buffer, " : constant ");
+ 
+               dump_generic_ada_node
+                 (buffer, DECL_NAME (type) ? type : TYPE_NAME (node), type,
+ 		 cpp_check, spc, 0, true);
+ 
+ 	      pp_string (buffer, " := ");
+ 	      dump_generic_ada_node
+ 		(buffer,
+ 		 TREE_CODE (TREE_VALUE (value)) == INTEGER_CST ?
+ 		   TREE_VALUE (value) : DECL_INITIAL (TREE_VALUE (value)),
+ 		 node,
+ 		 cpp_check, spc, false, true);
+ 	    }
+         }
+       break;
+ 
+     case INTEGER_TYPE:
+     case REAL_TYPE:
+     case FIXED_POINT_TYPE:
+     case BOOLEAN_TYPE:
+       {
+ 	enum tree_code_class tclass;
+ 
+ 	tclass = TREE_CODE_CLASS (TREE_CODE (node));
+ 
+ 	if (tclass == tcc_declaration)
+ 	  {
+ 	    if (DECL_NAME (node))
+ 	      pp_ada_tree_identifier
+ 		(buffer, DECL_NAME (node), 0, limited_access);
+ 	    else
+               pp_string (buffer, "<unnamed type decl>");
+ 	  }
+ 	else if (tclass == tcc_type)
+ 	  {
+ 	    if (TYPE_NAME (node))
+ 	      {
+ 		if (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)
+ 		  pp_ada_tree_identifier (buffer, TYPE_NAME (node),
+ 					  node, limited_access);
+ 		else if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL
+ 			 && DECL_NAME (TYPE_NAME (node)))
+ 		  dump_ada_decl_name (buffer, TYPE_NAME (node), limited_access);
+ 		else
+ 		  pp_string (buffer, "<unnamed type>");
+ 	      }
+ 	    else if (TREE_CODE (node) == INTEGER_TYPE)
+ 	      {
+ 		append_withs ("Interfaces.C.Extensions", false);
+ 		bitfield_used = true;
+ 
+ 		if (TYPE_PRECISION (node) == 1)
+ 		  pp_string (buffer, "Extensions.Unsigned_1");
+ 		else
+ 		  {
+ 		    pp_string (buffer, (TYPE_UNSIGNED (node)
+ 				        ? "Extensions.Unsigned_"
+ 				        : "Extensions.Signed_"));
+ 		    pp_decimal_int (buffer, TYPE_PRECISION (node));
+ 		  }
+ 	      }
+ 	    else
+               pp_string (buffer, "<unnamed type>");
+ 	  }
+ 	break;
+       }
+ 
+     case POINTER_TYPE:
+     case REFERENCE_TYPE:
+       if (TREE_CODE (TREE_TYPE (node)) == FUNCTION_TYPE)
+         {
+ 	  tree fnode = TREE_TYPE (node);
+ 	  bool is_function;
+ 	  bool prev_in_function = in_function;
+ 
+           if (VOID_TYPE_P (TREE_TYPE (fnode)))
+             {
+ 	      is_function = false;
+               pp_string (buffer, "access procedure");
+             }
+           else
+             {
+               is_function = true;
+               pp_string (buffer, "access function");
+             }
+ 
+           in_function = is_function;
+           dump_ada_function_declaration
+ 	    (buffer, node, type, false, false, spc + 2);
+           in_function = prev_in_function;
+ 
+           if (is_function)
+             {
+               pp_string (buffer, " return ");
+               dump_generic_ada_node
+                 (buffer, TREE_TYPE (fnode), type, cpp_check,
+ 		 spc, 0, true);
+             }
+ 	}
+       else
+         {
+ 	  int is_access = false;
+ 	  unsigned int quals = TYPE_QUALS (TREE_TYPE (node));
+ 
+           if (VOID_TYPE_P (TREE_TYPE (node)))
+ 	    {
+ 	      append_withs ("System", false);
+ 	      if (!name_only)
+ 	        pp_string (buffer, "new ");
+ 	      pp_string (buffer, "System.Address");
+ 	    }
+ 	  else
+ 	    {
+ 	      if (TREE_CODE (node) == POINTER_TYPE
+ 		  && TREE_CODE (TREE_TYPE (node)) == INTEGER_TYPE
+ 		  && !strcmp
+ 			(IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME
+ 			  (TREE_TYPE (node)))), "char"))
+ 	        {
+ 	          if (!name_only)
+ 	            pp_string (buffer, "new ");
+ 
+ 	          pp_string (buffer, "Interfaces.C.Strings.chars_ptr");
+ 	          append_withs ("Interfaces.C.Strings", false);
+ 	        }
+ 	      else
+ 		{
+ 	          /* For now, handle all access-to-access or
+ 		     access-to-unknown-structs as opaque system.address */
+ 
+ 		  tree typ = TYPE_NAME (TREE_TYPE (node));
+ 		  tree typ2 = !type || DECL_P (type) ? type : TYPE_NAME (type);
+ 		  tree underlying_type = get_underlying_decl (TREE_TYPE (node));
+ 
+ 	          if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE
+ 		      /* is pointer to pointer */
+ 
+ 		      || (is_struct_like (TREE_TYPE (node))
+ 			  && (!underlying_type
+ 			      || !TYPE_FIELDS (TREE_TYPE (underlying_type))))
+ 		      /* is pointer to opaque structure */
+ 
+ 		      || (typ && typ2
+ 			  && DECL_P (underlying_type)
+ 			  && DECL_P (typ2)
+ 			  && decl_sloc (underlying_type, true) > decl_sloc (typ2, true)
+ 			  && DECL_SOURCE_FILE (underlying_type) == DECL_SOURCE_FILE (typ2)))
+ 		    {
+ 		      append_withs ("System", false);
+ 		      if (!name_only)
+ 			pp_string (buffer, "new ");
+ 	              pp_string (buffer, "System.Address");
+ 	              return spc;
+ 	            }
+ 
+ 		  if (AGGREGATE_TYPE_P (TREE_TYPE (node)))
+ 		    {
+ 		      if (!type || TREE_CODE (type) != FUNCTION_DECL)
+ 		        {
+ 		          pp_string (buffer, "access ");
+ 		          is_access = true;
+ 		        }
+ 		      else if (quals & TYPE_QUAL_CONST)
+ 		        pp_string (buffer, "in ");
+ 		      else if (in_function)
+ 			{
+ 			  is_access = true;
+ 			  pp_string (buffer, "access ");
+ 			}
+ 		      else
+ 			{
+ 			  is_access = true;
+ 		          pp_string (buffer, "access ");
+ 		          /* ??? should be configurable: access or in out */
+ 		        }
+ 		    }
+ 		  else
+ 		    {
+ 		      is_access = true;
+ 		      pp_string (buffer, "access ");
+ 		    }
+ 
+ 	          if (is_struct_like (TREE_TYPE (node)))
+ 		    { 
+ 		      tree name = TYPE_NAME (TREE_TYPE (node));
+ 		      tree tmp;
+ 
+ 		      if (TREE_CODE (name) == TYPE_DECL
+ 			  && DECL_ORIGINAL_TYPE (name)
+ 			  && TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (name)))
+ 			{
+ 			  tmp = TYPE_NAME (TREE_TYPE (TYPE_STUB_DECL
+                             (DECL_ORIGINAL_TYPE (name))));
+ 
+ 		          if (tmp == NULL_TREE)
+ 		            tmp = TYPE_NAME (TREE_TYPE (node));
+ 			}
+ 		      else
+ 		        tmp = TYPE_NAME (TREE_TYPE (node));
+ 
+ 		      dump_generic_ada_node
+ 			(buffer, tmp,
+ 			 TREE_TYPE (node), cpp_check, spc, is_access, true);
+ 		    }
+ 		  else
+ 		    dump_generic_ada_node
+ 		      (buffer, TREE_TYPE (node), TREE_TYPE (node),
+ 		       cpp_check, spc, 0, true);
+ 		}
+ 	    }
+ 	}
+       break;
+ 
+     case RECORD_TYPE:
+     case UNION_TYPE:
+     case QUAL_UNION_TYPE:
+       if (name_only)
+ 	dump_generic_ada_node
+ 	  (buffer, TYPE_NAME (node), node, cpp_check,
+ 	   spc, limited_access, true);
+       else
+         print_ada_struct_decl
+ 	  (buffer, node, type, cpp_check, spc, true);
+       break;
+ 
+     case INTEGER_CST:
+       if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE)
+ 	{
+ 	  pp_wide_integer (buffer, TREE_INT_CST_LOW (node));
+ 	  pp_string (buffer, "B"); /* pseudo-unit */
+ 	}
+       else if (! host_integerp (node, 0))
+ 	{
+ 	  tree val = node;
+ 	  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (val);
+ 	  HOST_WIDE_INT high = TREE_INT_CST_HIGH (val);
+ 
+ 	  if (tree_int_cst_sgn (val) < 0)
+ 	    {
+ 	      pp_character (buffer, '-');
+ 	      high = ~high + !low;
+ 	      low = -low;
+ 	    }
+ 	  sprintf (pp_buffer (buffer)->digit_buffer,
+ 	  HOST_WIDE_INT_PRINT_DOUBLE_HEX,
+ 	    (unsigned HOST_WIDE_INT) high, low);
+ 	  pp_string (buffer, pp_buffer (buffer)->digit_buffer);
+ 	}
+       else
+ 	pp_wide_integer (buffer, TREE_INT_CST_LOW (node));
+       break;
+ 
+     case REAL_CST:
+     case FIXED_CST:
+     case COMPLEX_CST:
+     case STRING_CST:
+     case VECTOR_CST:
+       break;
+ 
+     case FUNCTION_DECL:
+     case CONST_DECL:
+       dump_ada_decl_name (buffer, node, limited_access);
+       break;
+ 
+     case TYPE_DECL:
+       if (DECL_IS_BUILTIN (node))
+ 	{
+ 	  /* Don't print the declaration of built-in types.  */
+ 	  break;
+ 	}
+ 
+       if (name_only)
+ 	dump_ada_decl_name (buffer, node, limited_access);
+       else
+ 	{
+ 	  if (is_struct_like (TREE_TYPE (node))
+ 	      && TYPE_METHODS (TREE_TYPE (node)))
+ 	    {
+ 	      tree tmp = TYPE_FIELDS (TREE_TYPE (node));
+ 	      int first = 1;
+ 
+ 	      /* Look for ancestors */
+ 	      for (; tmp; tmp = TREE_CHAIN (tmp))
+ 		{
+ 		  if (!DECL_NAME (tmp))
+ 		    {
+ 		      if (first)
+ 			{
+ 			  pp_string (buffer, "new ");
+ 			  first = 0;
+ 			}
+ 		      else
+ 			pp_string (buffer, " and ");
+ 
+ 		      dump_ada_decl_name
+ 			(buffer, TYPE_NAME (TREE_TYPE (tmp)), false);
+ 		    }
+ 		}
+ 
+ 	      pp_string (buffer, first ? "tagged limited " : " with ");
+ 	    }
+ 
+ 	  dump_generic_ada_node
+ 	    (buffer, TREE_TYPE (node), type, cpp_check,
+ 	     spc, false, false);
+ 	}
+       break;
+ 
+     case SYMBOL_MEMORY_TAG:
+     case NAME_MEMORY_TAG:
+     case VAR_DECL:
+     case PARM_DECL:
+     case FIELD_DECL:
+     case NAMESPACE_DECL:
+     case MEMORY_PARTITION_TAG:
+       dump_ada_decl_name (buffer, node, false);
+       break;
+ 
+     default:
+       /* Ignore other nodes (e.g. expressions) */
+       break;
+     }
+ 
+   return spc;
+ }
+ 
+ /* dump array type in Ada syntax. Assume that the "type" keyword and name
+    have already been printed. */
+ 
+ static void
+ dump_ada_array_type (pretty_printer *buffer, tree t, int spc)
+ {
+   tree tmp;
+ 
+   pp_string (buffer, "array ");
+   /* Print the dimensions.  */
+   dump_ada_array_domains (buffer, TREE_TYPE (t), spc);
+ 
+   /* Print array's type.  */
+   tmp = TREE_TYPE (t);
+   while (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)
+     tmp = TREE_TYPE (tmp);
+ 
+   pp_string (buffer, " of ");
+ 
+   if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE)
+     pp_string (buffer, "aliased ");
+ 
+   dump_generic_ada_node
+     (buffer, TREE_TYPE (tmp), TREE_TYPE (t), NULL, spc, false, true);
+ }
+ 
+ /* Print the methods of the class in Ada syntax, if any.  */
+ 
+ #define IS_ABSTRACT 0
+ #define IS_CONSTRUCTOR 1
+ #define IS_DESTRUCTOR 2
+ 
+ static void
+ print_ada_methods (pretty_printer *buffer, const_tree node,
+ 		   int (*cpp_check)(tree, int), int spc)
+ {
+   tree tmp = TYPE_METHODS (node);
+   int res = 1;
+ 
+   if (tmp)
+     {
+       pp_semicolon (buffer);
+ 
+       for (; tmp; tmp = TREE_CHAIN (tmp))
+ 	{
+ 	  if (res)
+ 	    {
+ 	      pp_newline (buffer);
+ 	      pp_newline (buffer);
+ 	    }
+ 	  res = print_ada_declaration (buffer, tmp, 0, cpp_check, spc);
+ 	}
+     }
+ }
+ 
+ static void
+ dump_nested_types (pretty_printer *buffer, tree t, tree parent,
+ 		   int (*cpp_check)(tree, int), int spc)
+ {
+   tree field;
+   tree outer;
+   int found = false;
+ 
+   /* Find possible anonymous arrays/unions/structs recursively */
+ 
+   outer = TREE_TYPE (t);
+ 
+   if (outer == NULL_TREE)
+     return;
+ 
+   field = TYPE_FIELDS (outer);
+   while (field)
+     {
+       if ((TREE_TYPE (field) != outer
+ 	   || (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE
+ 	       && TREE_TYPE (TREE_TYPE (field)) != outer))
+           && (!TYPE_NAME (TREE_TYPE (field))
+ 	      || TREE_CODE (field) == TYPE_DECL))
+ 	{
+ 	  if (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE)
+ 	    {
+ 	      tree ptr = TREE_TYPE (field);
+ 
+ 	      tree decl = get_underlying_decl (TREE_TYPE (ptr));
+ 
+ 	      if (decl
+ 		  && DECL_P (decl)
+ 		  && decl_sloc (decl, true) > decl_sloc (t, true)
+ 		  && DECL_SOURCE_FILE (decl) == DECL_SOURCE_FILE (t)
+ 		  && (!is_struct_like (TREE_TYPE (decl))
+ 		      || TYPE_FIELDS (TREE_TYPE (decl))))
+ 		{
+ 		  /* Generate forward declaration. */
+ 
+ 		  pp_string (buffer, "type ");
+ 		  dump_generic_ada_node
+ 		    (buffer, decl, 0, cpp_check, spc, false, true);
+ 		  pp_semicolon (buffer);
+ 		  newline_and_indent (buffer, spc);
+ 		}
+ 	    }
+ 
+ 	  switch (TREE_CODE (TREE_TYPE (field)))
+ 	    {
+ 	      case ARRAY_TYPE:
+ 		pp_string (buffer, "type ");
+ 		dump_ada_double_name (buffer, parent, field, "_array is ");
+ 		dump_ada_array_type (buffer, field, spc);
+ 		pp_semicolon (buffer);
+ 		newline_and_indent (buffer, spc);
+ 		break;
+ 
+ 	      case UNION_TYPE:
+ 		dump_nested_types (buffer, field, t, cpp_check, spc);
+ 
+ 		pp_string (buffer, "type ");
+ 
+ 		if (TYPE_NAME (TREE_TYPE (field)))
+ 		  {
+ 		    dump_generic_ada_node
+ 		      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, cpp_check,
+ 		       spc, false, true);
+ 		    pp_string (buffer, " (discr : unsigned := 0) is ");
+ 		    print_ada_struct_decl
+ 		      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);
+ 
+ 		    pp_string (buffer, "pragma Convention (C, ");
+ 		    dump_generic_ada_node
+ 		      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, cpp_check,
+ 		       spc, false, true);
+ 		    pp_string (buffer, ");");
+ 		    newline_and_indent (buffer, spc);
+ 
+ 		    pp_string (buffer, "pragma Unchecked_Union (");
+ 		    dump_generic_ada_node
+ 		      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, cpp_check,
+ 		       spc, false, true);
+ 		    pp_string (buffer, ");");
+ 		  }
+ 		else
+ 		  {
+ 		    dump_ada_double_name
+ 		      (buffer, parent, field,
+ 		       	"_union (discr : unsigned := 0) is ");
+ 		    print_ada_struct_decl
+ 		      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);
+ 		    pp_string (buffer, "pragma Convention (C, ");
+ 		    dump_ada_double_name (buffer, parent, field, "_union);");
+ 		    newline_and_indent (buffer, spc);
+ 
+ 		    pp_string (buffer, "pragma Unchecked_Union (");
+ 		    dump_ada_double_name (buffer, parent, field, "_union);");
+ 		  }
+ 
+ 		newline_and_indent (buffer, spc);
+ 		break;
+ 
+ 	      case RECORD_TYPE:
+ 		if (!found)
+ 		  {
+ 		    found = true;
+ 		    pp_string (buffer, "type ");
+ 		    dump_generic_ada_node
+ 		      (buffer, t, parent, 0, spc, false, true);
+ 		    pp_semicolon (buffer);
+ 		    newline_and_indent (buffer, spc);
+ 		  }
+ 
+ 		dump_nested_types (buffer, field, t, cpp_check, spc);
+ 		pp_string (buffer, "type ");
+ 
+ 		if (TYPE_NAME (TREE_TYPE (field)))
+ 		  {
+ 		    dump_generic_ada_node
+ 		      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, cpp_check,
+ 		       spc, false, true);
+ 		    pp_string (buffer, " is ");
+ 		    print_ada_struct_decl
+ 		      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);
+ 		    pp_string (buffer, "pragma Convention (C, ");
+ 		    dump_generic_ada_node
+ 		      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, cpp_check,
+ 		       spc, false, true);
+ 		    pp_string (buffer, ");");
+ 		  }
+ 		else
+ 		  {
+ 		    dump_ada_double_name
+ 		      (buffer, parent, field, "_struct is ");
+ 		    print_ada_struct_decl
+ 		      (buffer, TREE_TYPE (field), t, cpp_check, spc, false);
+ 		    pp_string (buffer, "pragma Convention (C, ");
+ 		    dump_ada_double_name (buffer, parent, field, "_struct);");
+ 		  }
+ 
+ 		newline_and_indent (buffer, spc);
+ 		break;
+ 
+ 	      default:
+ 		break;
+ 	    }
+ 	}
+       field = TREE_CHAIN (field);
+     }
+ }
+ 
+ static void
+ print_destructor (pretty_printer *buffer, tree t)
+ {
+   const char *s = IDENTIFIER_POINTER (DECL_NAME (t)) + 2;
+ 
+   for (; *s != ' '; s++)
+     pp_character (buffer, *s);
+ }
+ 
+ /* Return the name of type t */
+ 
+ static const char *
+ type_name (tree t)
+ {
+   tree n = TYPE_NAME (t);
+ 
+   if (TREE_CODE (n) == IDENTIFIER_NODE)
+     return IDENTIFIER_POINTER (n);
+   else
+     return IDENTIFIER_POINTER (DECL_NAME (n));
+ }
+ 
+ /* Print the declaration of a variable. Ada version.
+    Return 1 if a declaration was printed, 0 otherwise. */
+ 
+ static int
+ print_ada_declaration (pretty_printer *buffer, tree t, tree type,
+ 		       int (*cpp_check)(tree, int), int spc)
+ {
+   int is_var = 0, need_indent = 0;
+   int is_interface;
+   int is_class = false;
+   tree name = TYPE_NAME (TREE_TYPE (t));
+   tree decl_name = DECL_NAME (t);
+   bool dump_internal = get_dump_file_info (TDI_ada)->flags & TDF_RAW;
+ 
+   if (TREE_CODE (t) == CONST_DECL && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)
+     /* Skip enumeral values: will be handled as part of the type itself */
+     return 0;
+ 
+   if (TREE_CODE (t) == TYPE_DECL)
+     {
+       if (DECL_ORIGINAL_TYPE (t) && TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (t)))
+ 	{
+ 	  tree typ = TREE_TYPE (TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (t)));
+ 
+ 	  if (TYPE_NAME (typ))
+ 	    {
+ 	      /* If types have same representation, and same name (ignoring
+ 		 casing), then ignore the second type.  */
+ 	      if (type_name (typ) == type_name (TREE_TYPE (t))
+ 		  || !strcasecmp (type_name (typ), type_name (TREE_TYPE (t))))
+ 		return 0;
+ 
+ 	      INDENT (spc);
+ 	      pp_string (buffer, "subtype ");
+ 	      dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 	      pp_string (buffer, " is ");
+ 	      dump_generic_ada_node (buffer, typ, type, 0, spc, false, true);
+ 	      pp_semicolon (buffer);
+ 
+ 	      return 1;
+ 	    }
+ 	}
+ 
+       if (!DECL_ORIGINAL_TYPE (t) && !decl_name && !name)
+ 	{
+ 	  /* skip unnamed or anonymous structs/unions.
+            */
+           return 0;
+ 	}
+ 
+       if (!DECL_ORIGINAL_TYPE (t)
+ 	  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE
+ 	  && decl_name
+ 	  && *IDENTIFIER_POINTER (decl_name) == '.')
+         /* skip anonymous enum types (duplicates of real types */
+         return 0;
+ 
+       INDENT (spc);
+ 
+       switch (TREE_CODE (TREE_TYPE (t)))
+ 	{
+ 	  case RECORD_TYPE:
+ 	  case UNION_TYPE:
+ 	  case QUAL_UNION_TYPE:
+ 	    /* skip empty structs (typically forward references to real
+ 	       structs).  */
+ 	    if (!TYPE_FIELDS (TREE_TYPE (t)))
+ 	      {
+ 		pp_string (buffer, "--  skipped empty struct ");
+ 		dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 		return 1;
+ 	      }
+ 
+ 	    if (decl_name && *IDENTIFIER_POINTER (decl_name) == '.')
+ 	      {
+ 		pp_string (buffer, "--  skipped anonymous struct ");
+ 		dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 		return 1;
+ 	      }
+ 
+ 	    dump_nested_types (buffer, t, t, cpp_check, spc);
+ 
+ 	    if (TYPE_METHODS (TREE_TYPE (t)))
+ 	      {
+ 	        is_class = true;
+ 	        pp_string (buffer, "package Class_");
+ 	        dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 	        pp_string (buffer, " is");
+ 	        spc += 2;
+ 	        newline_and_indent (buffer, spc);
+ 	      }
+ 
+ 	    pp_string (buffer, "type ");
+ 	    break;
+ 
+ 	  case ARRAY_TYPE:
+ 	  case POINTER_TYPE:
+ 	  case REFERENCE_TYPE:
+ 	    pp_string (buffer, "type ");
+ 	    break;
+ 
+ 	  case FUNCTION_TYPE:
+ 	    pp_string (buffer, "--  skipped function type ");
+ 	    dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 	    return 1;
+ 	    break;
+ 
+ 	  default:
+ 	    pp_string (buffer, "subtype ");
+ 	}
+     }
+   else
+     {
+       if (!dump_internal
+ 	  && TREE_CODE (t) == VAR_DECL
+ 	  && decl_name
+ 	  && *IDENTIFIER_POINTER (decl_name) == '_')
+ 	{
+ 	  pp_string (buffer, "  --  skipped var ");
+ 	  pp_string (buffer, IDENTIFIER_POINTER (DECL_NAME (t)));
+ 	  return 1;
+ 	}
+ 
+       need_indent = 1;
+     }
+ 
+   /* Print the type and name.  */
+   if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)
+     {
+       if (need_indent)
+         INDENT (spc);
+ 
+       /* Print variable's name.  */
+       dump_generic_ada_node (buffer, t, type, cpp_check, spc, false, true);
+ 
+       if (TREE_CODE (t) == TYPE_DECL)
+         {
+           pp_string (buffer, " is ");
+ 	  dump_ada_array_type (buffer, t, spc);
+ 	}
+       else
+         {
+ 	  tree tmp = TYPE_NAME (TREE_TYPE (t));
+ 
+ 	  if (spc == 2)
+ 	    is_var = 1;
+ 
+           pp_string (buffer, " : ");
+ 
+ 	  if (tmp)
+ 	    {
+ 	      if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE)
+                 pp_string (buffer, "aliased ");
+ 
+ 	      dump_generic_ada_node (buffer, tmp, type, 0, spc, false, true);
+ 	    }
+ 	  else
+ 	    {
+               pp_string (buffer, "aliased ");
+ 
+ 	      if (!type)
+ 	        dump_ada_array_type (buffer, t, spc);
+ 	      else
+ 	        dump_ada_double_name (buffer, type, t, "_array");
+ 	    }
+         }
+     }
+   else if (TREE_CODE (t) == FUNCTION_DECL)
+     {
+       int is_function = 1, is_method;
+       tree decl_name = DECL_NAME (t);
+       int prev_in_function = in_function;
+       const int is_abstract = cpp_check && cpp_check (t, IS_ABSTRACT);
+       const int is_constructor = cpp_check && cpp_check (t, IS_CONSTRUCTOR);
+       const int is_destructor = cpp_check && cpp_check (t, IS_DESTRUCTOR);
+ 
+       if (!decl_name)
+ 	return 0;
+ 
+       if (is_destructor && *IDENTIFIER_POINTER (decl_name) != '_')
+ 	/* Skip pseudo destructor which is redundant with __comp_dtor and
+ 	   __deleting_dtor */
+ 	return 0;
+ 
+       /* If this function has an entry in the dispatch table, we cannot
+ 	 omit it. */
+       if (!dump_internal && !DECL_VINDEX (t)
+ 	  && *IDENTIFIER_POINTER (decl_name) == '_')
+ 	{
+ 	  if (IDENTIFIER_POINTER (decl_name)[1] == '_')
+ 	    return 0;
+ 
+ 	  pp_string (buffer, "  --  skipped func ");
+ 	  pp_string (buffer, IDENTIFIER_POINTER (decl_name));
+ 	  pp_newline (buffer);
+ 	  return 0;
+ 	}
+ 
+       if (need_indent)
+         INDENT (spc);
+ 
+       if (is_constructor)
+ 	pp_string (buffer, "function New_");
+       else if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (t))))
+ 	{
+ 	  is_function = 0;
+ 	  pp_string (buffer, "procedure ");
+ 	}
+       else
+ 	pp_string (buffer, "function ");
+ 
+       in_function = is_function;
+       is_method = TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE;
+ 
+       if (is_destructor)
+ 	print_destructor (buffer, t);
+       else
+         dump_ada_decl_name (buffer, t, false);
+ 
+       dump_ada_function_declaration
+ 	(buffer, t, type, is_method, is_constructor, spc);
+       in_function = prev_in_function;
+ 
+       if (is_function)
+ 	{
+ 	  pp_string (buffer, " return ");
+ 
+ 	  if (is_constructor)
+ 	    {
+ 	      dump_ada_decl_name (buffer, t, false);
+ 	      pp_string (buffer, "'Class");
+ 	    }
+ 	  else
+ 	    {
+ 	      dump_generic_ada_node
+ 		(buffer, TREE_TYPE (TREE_TYPE (t)), type, cpp_check,
+ 		 spc, false, true);
+ 	    }
+ 	}
+ 
+       if (is_abstract)
+         pp_string (buffer, " is abstract");
+ 
+       pp_semicolon (buffer);
+       pp_string (buffer, "  -- ");
+       dump_sloc (buffer, t);
+ 
+       if (is_abstract)
+ 	return 1;
+ 
+       newline_and_indent (buffer, spc);
+ 
+       if (is_constructor)
+         {
+           pp_string (buffer, "pragma CPP_Constructor (New_");
+ 	  dump_ada_decl_name (buffer, t, false);
+           pp_string (buffer, ");");
+           newline_and_indent (buffer, spc);
+ 	  pp_string (buffer, "pragma Import (CPP, New_");
+ 	  dump_ada_decl_name (buffer, t, false);
+ 	  pp_string (buffer, ", \"");
+ 	  pp_asm_name (buffer, t);
+ 	  pp_string (buffer, "\");");
+ 	}
+       else if (is_destructor)
+ 	{
+ 	  pp_string (buffer, "pragma Import (CPP, ");
+ 	  print_destructor (buffer, t);
+ 	  pp_string (buffer, ", \"");
+ 	  pp_asm_name (buffer, t);
+ 	  pp_string (buffer, "\");");
+ 	}
+       else
+ 	{
+ 	  dump_ada_import (buffer, t);
+ 	}
+ 
+       return 1;
+     }
+   else if (TREE_CODE (t) == TYPE_DECL && !DECL_ORIGINAL_TYPE (t))
+     {
+       if (need_indent)
+         INDENT (spc);
+ 
+       /* anonymous structs/unions */
+       dump_generic_ada_node
+ 	(buffer, name, name, cpp_check, spc, false, true);
+ 
+       if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
+ 	  || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)
+ 	{
+ 	  pp_string (buffer, " (discr : unsigned := 0)");
+ 	}
+ 
+       pp_string (buffer, " is ");
+ 
+       is_interface = 0;
+ 
+       /* check whether we have an Ada interface compatible class */
+       if (cpp_check && AGGREGATE_TYPE_P (TREE_TYPE (t))
+ 	  && TYPE_METHODS (TREE_TYPE (t)))
+ 	{
+ 	  int num_fields = 0;
+ 	  tree tmp = TYPE_FIELDS (TREE_TYPE (t));
+ 
+ 	  /* check that there are no fields other than the virtual table */
+ 	  for (; tmp; tmp = TREE_CHAIN (tmp))
+ 	    {
+ 	      if (TREE_TYPE (tmp) == TREE_TYPE (t))
+ 		continue;
+ 	      num_fields++;
+ 	    }
+ 
+ 	  /* also check that there are only virtual methods */
+ 	  if (num_fields == 1)
+ 	    {
+               tmp = TYPE_METHODS (TREE_TYPE (t));
+ 	      is_interface = 1;
+ 
+               for (; tmp; tmp = TREE_CHAIN (tmp))
+                 if (!cpp_check (tmp, IS_ABSTRACT))
+ 		  {
+ 		    is_interface = 0;
+                     break;
+                   }
+ 	    }
+ 	}
+ 
+       if (is_interface)
+         {
+ 	  pp_string (buffer, "limited interface;  -- ");
+ 	  dump_sloc (buffer, t);
+ 	  newline_and_indent (buffer, spc);
+ 	  pp_string (buffer, "pragma Import (CPP, ");
+  	  dump_generic_ada_node
+ 	    (buffer, TYPE_NAME (TREE_TYPE (t)), type, cpp_check,
+ 	     spc, false, true);
+   	  pp_character (buffer, ')');
+ 
+ 	  print_ada_methods (buffer, TREE_TYPE (t), cpp_check, spc);
+ 	}
+       else
+         dump_generic_ada_node
+ 	  (buffer, t, t, cpp_check, spc, false, false);
+     }
+   else
+     {
+       if (need_indent)
+         INDENT (spc);
+ 
+       if (TREE_CODE (t) == FIELD_DECL && DECL_NAME (t))
+ 	check_name (buffer, t);
+ 
+       /* Print variable/type's name. */
+       dump_generic_ada_node (buffer, t, t, cpp_check, spc, false, true);
+ 
+       if (TREE_CODE (t) == TYPE_DECL)
+ 	{
+ 	  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
+ 	      || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)
+ 	    pp_string (buffer, " (discr : unsigned := 0)");
+ 
+ 	  pp_string (buffer, " is ");
+ 
+ 	  dump_generic_ada_node
+ 	    (buffer, DECL_ORIGINAL_TYPE (t), t, cpp_check, spc, false, false);
+ 	}
+       else
+ 	{
+ 	  if (spc == 2)
+ 	    is_var = 1;
+ 
+ 	  pp_string (buffer, " : ");
+ 
+           /* Print type declaration.  */
+ 
+           if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
+ 	      && !TYPE_NAME (TREE_TYPE (t)))
+             {
+ 	      pp_string (buffer, "aliased ");
+ 	      dump_ada_double_name (buffer, type, t, "_union");
+ 	    }
+           else if (is_struct_like (TREE_TYPE (t)))
+             {
+ 	      pp_string (buffer, "aliased ");
+ 	      dump_generic_ada_node
+ 		(buffer, TYPE_NAME (TREE_TYPE (t)), TREE_TYPE (t),
+ 		 cpp_check, spc, false, true);
+             }
+           else
+             {
+ 	      if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)
+ 		pp_string (buffer, "aliased ");
+ 
+               dump_generic_ada_node
+ 		(buffer, TREE_TYPE (t), TREE_TYPE (t), cpp_check,
+ 		 spc, false, true);
+             }
+         }
+     }
+ 
+   if (is_class)
+     {
+       spc -= 2;
+       newline_and_indent (buffer, spc);
+       pp_string (buffer, "end;");
+       newline_and_indent (buffer, spc);
+       pp_string (buffer, "use Class_");
+       dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+       pp_semicolon (buffer);
+       pp_newline (buffer);
+ 
+       /* All needed indentation/newline performed at this stage, so return 0 */
+       return 0;
+     }
+   else
+     {
+       pp_string (buffer, ";  -- ");
+       dump_sloc (buffer, t);
+     }
+ 
+   if (is_var)
+     {
+       newline_and_indent (buffer, spc);
+       dump_ada_import (buffer, t);
+     }
+ 
+   return 1;
+ }
+ 
+ /* Prints a structure: name, fields, and methods with Ada syntax.  */
+ 
+ static void
+ print_ada_struct_decl (pretty_printer *buffer, const_tree node, tree type,
+ 		       int (*cpp_check)(tree, int), int spc,
+ 		       bool display_convention)
+ {
+   tree tmp;
+   int is_union =
+     TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;
+   char buf [16];
+   int field_num = 0;
+   int field_spc = spc + 2;
+ 
+   bitfield_used = false;
+ 
+   if (!TYPE_FIELDS (node))
+     pp_string (buffer, "null record;");
+   else
+     {
+       pp_string (buffer, "record");
+ 
+       /* Print the contents of the structure.  */
+ 
+       if (is_union)
+ 	{
+ 	  newline_and_indent (buffer, spc + 2);
+ 	  pp_string (buffer, "case discr is");
+ 	  field_spc = spc + 6;
+ 	}
+ 
+       pp_newline (buffer);
+ 
+       /* Print the fields of the structure.  */
+       for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))
+ 	{
+ 	  /* Avoid to print recursively the structure.  */
+ 	  /* FIXME : Not implemented correctly...,
+ 	     what about the case when we have a cycle in the contain graph? ...
+ 	     Maybe this could be solved by looking at the scope in which the
+ 	     structure was declared.  */
+           if ((TREE_TYPE (tmp) != node
+                || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE
+                    && TREE_TYPE (TREE_TYPE (tmp)) != node))
+               && DECL_NAME (tmp)
+               && TREE_CODE (tmp) != TYPE_DECL)
+ 	    {
+ 	      /* skip internal virtual table field */
+ 	      if (strncmp (IDENTIFIER_POINTER (DECL_NAME (tmp)), "_vptr.", 6))
+ 	        {
+ 	          if (is_union)
+ 	            {
+ 	              if (TREE_CHAIN (tmp)
+ 			  && TREE_TYPE (TREE_CHAIN (tmp)) != node)
+ 	                sprintf (buf, "when %d =>", field_num);
+ 	              else
+ 	                sprintf (buf, "when others =>");
+ 
+ 	              INDENT (spc + 4);
+ 	              pp_string (buffer, buf);
+ 	              pp_newline (buffer);
+ 	            }
+ 
+ 	          print_ada_declaration
+ 		    (buffer, tmp, type, cpp_check, field_spc);
+ 	          pp_newline (buffer);
+ 	          field_num++;
+ 	        }
+ 	    }
+         }
+ 
+       if (is_union)
+ 	{
+ 	  INDENT (spc + 2);
+ 	  pp_string (buffer, "end case;");
+ 	  pp_newline (buffer);
+ 	}
+ 
+       if (field_num == 0)
+ 	{
+ 	  INDENT (spc + 2);
+ 	  pp_string (buffer, "null;");
+ 	  pp_newline (buffer);
+ 	}
+ 
+       INDENT (spc);
+       pp_string (buffer, "end record;");
+     }
+ 
+   newline_and_indent (buffer, spc);
+ 
+   if (!display_convention)
+     return;
+ 
+   if (is_struct_like (TREE_TYPE (type)) && TYPE_METHODS (TREE_TYPE (type)))
+     pp_string (buffer, "pragma Import (CPP, ");
+   else
+     pp_string (buffer, "pragma Convention (C, ");
+ 
+   tmp = TYPE_NAME (TREE_TYPE (type));
+ 
+   dump_generic_ada_node
+     (buffer, tmp, type, cpp_check, spc, false, true);
+   pp_character (buffer, ')');
+ 
+   if (is_union)
+     {
+       pp_semicolon (buffer);
+       newline_and_indent (buffer, spc);
+       pp_string (buffer, "pragma Unchecked_Union (");
+ 
+       dump_generic_ada_node
+ 	(buffer, tmp, type, cpp_check, spc, false, true);
+       pp_character (buffer, ')');
+     }
+ 
+   if (bitfield_used)
+     {
+       pp_semicolon (buffer);
+       newline_and_indent (buffer, spc);
+       pp_string (buffer, "pragma Pack (");
+       dump_generic_ada_node
+ 	(buffer, tmp, type, cpp_check, spc, false, true);
+       pp_character (buffer, ')');
+       bitfield_used = false;
+     }
+ 
+   print_ada_methods (buffer, node, cpp_check, spc);
+ }
+ 
*** /dev/null	2006-06-16 15:07:58.000000000 +0200
--- gcc/c-macros.c	2008-11-27 17:26:56.000000000 +0100
***************
*** 0 ****
--- 1,344 ----
+ /* Macro processing for C/C++ compilers.
+    Copyright (C) 2008 Free Software Foundation, Inc.
+    Contributed by Arnaud Charlet  <charlet@adacore.com>
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "coretypes.h"
+ #include "tm.h"
+ #include "tree.h"
+ #include "diagnostic.h"
+ #include "toplev.h"
+ #include "c-pragma.h"
+ #include "cpp-id-data.h"
+ 
+ /* Convert C macros to Ada constants when possible */
+ 
+ static void
+ print_ada_macros (pretty_printer *pp, cpp_hashnode **macros, int max_ada_macros)
+ {
+   int j, num_macros = 0, prev_line = -1;
+ 
+   for (j = 0; j < max_ada_macros; j++)
+     {
+       cpp_hashnode *node = macros [j];
+       const cpp_macro *macro = node->value.macro;
+       unsigned i;
+       unsigned char s [4096], params [4096];
+       unsigned char *buffer = s, *buf_param = params, *prev;
+       int supported = 1;
+       int is_string = 0;
+ 
+       if (macro->fun_like)
+ 	{
+ 	  *buf_param++ = '(';
+ 	  for (i = 0; i < macro->paramc; i++)
+ 	    {
+ 	      cpp_hashnode *param = macro->params[i];
+ 
+ 	      memcpy (buf_param, NODE_NAME (param), NODE_LEN (param));
+ 	      buf_param += NODE_LEN (param);
+ 
+ 	      if (i + 1 < macro->paramc)
+ 		{
+ 		  *buf_param++ = ',';
+ 		  *buf_param++ = ' ';
+ 		}
+ 	      else if (macro->variadic)
+ 		{
+ 		  supported = 0;
+ 		  break;
+ 		}
+ 	  }
+ 	  *buf_param++ = ')';
+ 	  *buf_param = '\0';
+ 	}
+ 
+       for (i = 0; supported && i < macro->count; i++)
+         {
+           cpp_token *token = &macro->exp.tokens[i];
+ 
+           if (token->flags & PREV_WHITE)
+             *buffer++ = ' ';
+ 
+           if (token->flags & STRINGIFY_ARG || token->flags & PASTE_LEFT)
+             {
+ 	      supported = 0;
+ 	      break;
+             }
+ 
+ 	  prev = buffer;
+ 
+ 	  if (token->type == CPP_MACRO_ARG)
+ 	    { 
+ 	      memcpy (buffer,
+ 		      NODE_NAME (macro->params[token->val.arg_no - 1]),
+ 	      	      NODE_LEN (macro->params[token->val.arg_no - 1]));
+ 	      buffer += NODE_LEN (macro->params[token->val.arg_no - 1]);
+ 	    }
+ 	  else
+ 	    buffer = cpp_spell_token (parse_in, token, buffer, false);
+ 
+ 	  if (!is_string)
+ 	    switch (*prev)
+ 	      {
+ 	        case '"':
+ 		  is_string = 1;
+ 		  break;
+ 	        case '<':
+ 		  if (prev + 2 == buffer && prev [1] == '<')
+ 		    {
+ 		      if (prev [-1] == '1')
+ 		        prev [-1] = '2';
+ 		      else if (prev [-1] == ' '
+ 			       && prev [-2] == '1')
+ 		        prev [-2] = '2';
+ 
+ 		      prev [0] = '*';
+ 		      prev [1] = '*';
+ 		    }
+ 		  break;
+ 
+ 	        case '0':
+ 	          if (prev + 1 < buffer && prev [1] == 'x')
+ 	            {
+ 	              /* convert 0x.... into 16#....# */
+ 
+ 	              prev [0] = '1';
+ 	              prev [1] = '6';
+ 	              memmove (prev + 3, prev + 2, buffer - prev - 2);
+ 	              prev [2] = '#';
+ 
+ 		      if (*buffer != 'L')
+ 	                buffer++;
+ 	              *buffer++ = '#';
+ 	              break;
+ 	            }
+ 	            /* fallthrough */
+ 
+ 	        case '1': case '2': case '3': case '4': case '5':
+ 	        case '6': case '7': case '8': case '9':
+ 		  if (buffer [-1] == 'L' || buffer [-1] == 'l')
+ 		    buffer--;
+ 		  break;
+ 
+ 	        case '(': case ')': case '+':
+ 	          break;
+ 
+ 	        case '-':
+ 	          if (prev + 2 == buffer && prev [1] == '>')
+ 		    {
+ 	              *prev = '.';
+ 	              buffer--;
+ 	            }
+ 	          break;
+ 
+ 	        case '&':
+ 	          if (prev + 1 == buffer)
+ 	            {
+ 	              *prev = 'a';
+ 	              *buffer++ = 'n';
+ 	              *buffer++ = 'd';
+ 	            }
+ 	          else if (prev + 2 == buffer && prev [1] == '&')
+ 	            {
+ 	              strcpy ((char *)prev, "and then");
+ 	              buffer += 6;
+ 	            }
+ 	          else
+ 	            supported = 0;
+ 	          break;
+ 
+ 	        case '|':
+ 	          if (prev + 1 == buffer)
+ 	            {
+ 	              *prev = 'o';
+ 	              *buffer++ = 'r';
+ 	            }
+ 	          else if (prev + 2 == buffer && prev [1] == '|')
+ 	            {
+ 	              strcpy ((char *)prev, "or else");
+ 	              buffer += 5;
+ 	            }
+ 	          else
+ 	            supported = 0;
+ 	          break;
+ 
+ 	        case '=':
+ 	          if (prev + 1 == buffer)
+ 	            {
+ 	              *prev = ':';
+ 	              *buffer++ = '=';
+ 	            }
+ 	          else if (prev + 2 == buffer && prev [1] == '=')
+ 	            buffer--;
+ 	          else
+ 	            supported = 0;
+ 	          break;
+ 
+ 	        case '*': case '_':
+ 	          supported = 0;
+ 	          break;
+ 
+ 	        default:
+ 	          if (!macro->fun_like)
+ 	            supported = 0;
+ 	      }
+         }
+ 
+       *buffer = '\0';
+ 
+       if (macro->fun_like && supported)
+ 	{
+ 	  char *start = (char *) s;
+ 	  int is_function = 0;
+ 
+ 	  pp_string (pp, "  --  arg-macro: ");
+ 
+ 	  if (*start == '(' && buffer [-1] == ')')
+ 	    {
+ 	      start++;
+ 	      buffer [-1] = '\0';
+ 	      is_function = 1;
+ 	      pp_string (pp, "function ");
+ 	    }
+ 	  else
+ 	    {
+ 	      pp_string (pp, "procedure ");
+ 	    }
+ 
+ 	  pp_string (pp, (const char *)NODE_NAME (node));
+ 	  pp_space (pp);
+ 	  pp_string (pp, (char *)params);
+ 	  pp_newline (pp);
+ 	  pp_string (pp, "  --    ");
+ 
+ 	  if (is_function)
+ 	    {
+ 	      pp_string (pp, "return ");
+ 	      pp_string (pp, start);
+ 	      pp_semicolon (pp);
+ 	    }
+ 	  else
+ 	    pp_string (pp, start);
+ 
+ 	  pp_newline (pp);
+ 	}
+       else if (supported)
+ 	{
+ 	  expanded_location sloc = expand_location (macro->line);
+ 
+ 	  if (sloc.line != prev_line + 1)
+ 	    pp_newline (pp);
+ 
+ 	  num_macros++;
+ 	  prev_line = sloc.line;
+ 
+ 	  pp_string (pp, "  ");
+ 	  pp_string (pp, (const char *)NODE_NAME (node));
+ 	  pp_string (pp, " : ");
+ 	  pp_string (pp, is_string ? "aliased constant String" : "constant");
+ 	  pp_string (pp, " := ");
+ 	  pp_string (pp, (char *)s);
+ 
+ 	  if (is_string)
+ 	    pp_string (pp, " & ASCII.NUL");
+ 
+ 	  pp_string (pp, ";  --  ");
+ 	  pp_string (pp, sloc.file);
+ 	  pp_character (pp, ':');
+ 	  pp_scalar (pp, "%d", sloc.line);
+ 	  pp_newline (pp);
+         }
+       else
+ 	{
+ 	  pp_string (pp, "  --  unsupported macro: ");
+ 	  pp_string (pp, (const char *) cpp_macro_definition (parse_in, node));
+ 	  pp_newline (pp);
+ 	}
+     }
+ 
+   if (num_macros > 0)
+     pp_newline (pp);
+ }
+ 
+ static const char *source_file;
+ static int max_ada_macros;
+ 
+ static int
+ count_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)
+ {
+   const cpp_macro *macro = node->value.macro;
+ 
+   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)
+       && macro->count
+       && *NODE_NAME (node) != '_'
+       && LOCATION_FILE (macro->line) == source_file)
+     max_ada_macros++;
+ 
+   return 1;
+ }
+ 
+ static int store_ada_macro_index;
+ 
+ static int
+ store_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED,
+ 		 cpp_hashnode *node, void *v)
+ {
+   const cpp_macro *macro = node->value.macro;
+ 
+   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)
+       && macro->count
+       && *NODE_NAME (node) != '_'
+       && LOCATION_FILE (macro->line) == source_file)
+     ((cpp_hashnode **)v)[store_ada_macro_index++] = node;
+ 
+   return 1;
+ }
+ 
+ static int
+ compare_macro (const void *node1, const void *node2)
+ {
+   typedef const cpp_hashnode *const_hnode;
+ 
+   const_hnode n1 = *(const const_hnode *)node1;
+   const_hnode n2 = *(const const_hnode *)node2;
+ 
+   return n1->value.macro->line - n2->value.macro->line;
+ }
+ 
+ /* Dump all relevant macros appearing in source_file. */
+ void
+ dump_ada_macros (pretty_printer *pp, const char* file)
+ {
+   cpp_hashnode **macros;
+ 
+   /* Initialize file-scope variables. */
+   max_ada_macros = 0;
+   store_ada_macro_index = 0;
+   source_file = file;
+ 
+   /* Count all potentially relevant macros, and then sort them by sloc */  
+   cpp_forall_identifiers (parse_in, count_ada_macro, NULL);
+   macros = (cpp_hashnode **) alloca (sizeof (cpp_hashnode *) * max_ada_macros);
+   cpp_forall_identifiers (parse_in, store_ada_macro, macros);
+   qsort (macros, max_ada_macros, sizeof (cpp_hashnode *), compare_macro);
+ 
+   print_ada_macros (pp, macros, max_ada_macros);
+ }
*** gcc/cp/decl2.c	2008-07-30 15:18:31.000000000 +0200
--- gcc/cp/decl2.c	2008-09-25 12:26:38.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 51,56 ****
--- 51,58 ----
  #include "c-pragma.h"
  #include "tree-dump.h"
  #include "intl.h"
+ #include "langhooks.h"
+ #include "diagnostic.h"
  
  extern cpp_reader *parse_in;
  
*************** build_java_method_aliases (void)
*** 3279,3284 ****
--- 3281,3404 ----
      }
  }
  
+ #define IS_PURE_VIRTUAL 0
+ #define IS_CONSTRUCTOR 1
+ #define IS_DESTRUCTOR 2
+ 
+ static int
+ cpp_check (tree t, int op)
+ {
+   switch (op)
+     {
+       case IS_PURE_VIRTUAL:
+ 	return DECL_PURE_VIRTUAL_P (t);
+       case IS_CONSTRUCTOR:
+ 	return DECL_CONSTRUCTOR_P (t);
+       case IS_DESTRUCTOR:
+ 	return DECL_DESTRUCTOR_P (t);
+       default:
+         return 0;
+     }
+ }
+ 
+ static const char *source_file;
+ static const char **source_refs = NULL;
+ static int source_refs_used = 0;
+ static int source_refs_allocd = 0;
+ 
+ /* Add an entry to the table source_refs. */
+ 
+ static void
+ collect_source_ref (const char *filename)
+ {
+   int i;
+ 
+   if (!filename)
+     return;
+ 
+   if (source_refs_allocd == 0) 
+     {
+       source_refs_allocd = 1024;
+       source_refs = (const char **) 
+ 	xmalloc (source_refs_allocd * sizeof (const char *));
+     }
+ 
+   for (i = 0; i < source_refs_used; i++)
+     if (filename == source_refs[i])
+       return;
+ 
+   if (source_refs_used == source_refs_allocd)
+     {
+       source_refs_allocd *= 2;
+       source_refs = (const char **) 
+ 	xrealloc (source_refs, source_refs_allocd * sizeof (const char *));
+     }
+ 
+   source_refs [source_refs_used++] = filename;
+ }
+ 
+ /* Collect source file references recursively, starting from
+    namespace. */
+ 
+ static void 
+ collect_source_refs (tree namespace) 
+ {
+   tree t;
+ 
+   if (!namespace) 
+     return;
+ 
+   /* Iterate over names in this name space. */
+   for (t = NAMESPACE_LEVEL (namespace)->names; t; t = TREE_CHAIN (t))
+     if (!DECL_IS_BUILTIN (t) )
+       collect_source_ref (DECL_SOURCE_FILE (t));
+   
+   /* Dump siblings, if any */
+   collect_source_refs (TREE_CHAIN (namespace));
+ 
+   /* Dump children, if any */
+   collect_source_refs (NAMESPACE_LEVEL (namespace)->namespaces);
+ }
+ 
+ /* Collect decls from all namespaces recursively, starting from
+   namespace. */
+ 
+ static void
+ collect_ada_namespace (pretty_printer *pp, tree namespace)
+ {
+   if (!namespace)
+     return;
+ 
+   /* This doesn't work now that we are only calling dump_ada_nodes
+      once. This should be replaced by logic in tree-ada-spec.c driven
+      by the context of dumped decls.  */
+   
+   /* 
+   if (namespace != global_namespace && DECL_NAME (namespace))
+     {
+       const char *s = IDENTIFIER_POINTER (DECL_NAME (namespace));
+ 
+       if (strcmp (s, "std") && strcmp (s, "__cxxabiv1"))
+ 	{
+ 	  pp_string (pp, "  --  namespace: ");
+ 	  pp_string (pp, s);
+ 	  pp_newline (pp);
+ 	  pp_newline (pp);
+ 	}
+     }
+   */
+ 
+   /* Collect decls from this namespace. */
+   collect_ada_nodes
+     (NAMESPACE_LEVEL (namespace)->names, source_file);
+ 
+   /* Collect siblings, if any */
+   collect_ada_namespace (pp, TREE_CHAIN (namespace));
+ 
+   /* Collect children, if any */
+   collect_ada_namespace (pp, NAMESPACE_LEVEL (namespace)->namespaces);
+ }
+ 
  /* This routine is called at the end of compilation.
     Its job is to create all the code needed to initialize and
     destroy the global aggregates.  We do the destruction
*************** cp_write_global_declarations (void)
*** 3305,3310 ****
--- 3425,3490 ----
    if (pch_file)
      c_common_write_pch ();
  
+   /* Handle -fdump-ada-spec[-slim]. */
+   if (dump_enabled_p (TDI_ada))
+     {
+       int i;
+ 
+       if (get_dump_file_info (TDI_ada)->flags & TDF_SLIM)
+ 	collect_source_ref (main_input_filename);
+       else
+ 	collect_source_refs (global_namespace);
+ 
+       for (i = 0; i < source_refs_used; i++)
+ 	{
+ 	  FILE *f;
+ 	  char *ads_name;
+ 	  char *pkg_name;
+ 	  char *s;
+ 
+ 	  pkg_name = get_ada_package (source_refs [i]);
+ 
+ 	  /* Construct the the .ads filename and package name. */
+ 	  ads_name = xstrdup (pkg_name);
+ 
+ 	  for (s = ads_name; *s; s++)
+ 	    *s = TOLOWER (*s);
+ 
+ 	  ads_name = reconcat (ads_name, ads_name, ".ads", NULL);
+ 
+ 	  f = fopen (ads_name, "w");
+ 	  if (f)
+ 	    {
+ 	      pretty_printer pp;
+ 	      pp_construct (&pp, NULL, 0);
+ 	      pp_needs_newline (&pp) = true;
+ 	      pp.buffer->stream = f;
+ 
+ 	      /* Dump all relevant macros */
+ 	      dump_ada_macros (&pp, source_refs [i]);
+ 
+ 	      reset_ada_withs ();
+ 
+ 	      /* Collect declarations from all namespaces recursively. */
+ 	      source_file = source_refs [i];
+ 	      collect_ada_namespace (&pp, global_namespace);
+ 
+ 	      dump_ada_nodes (&pp, source_file, cpp_check);
+ 	      dump_ada_withs (f);
+ 	      fprintf (f, "\npackage %s is\n\n", pkg_name);
+ 	      pp_write_text_to_stream (&pp);
+ 	      fprintf (f, "end %s;\n", pkg_name);
+ 	      fclose (f);
+ 	    }
+ 
+ 	  free (ads_name);
+ 	  free (pkg_name);
+ 	}
+ 
+       /* Free files table */
+       free (source_refs);
+     }
+ 
  #ifdef USE_MAPPED_LOCATION
    /* FIXME - huh? */
  #else
*** gcc/cp/lang-specs.h	2007-08-06 13:10:19.000000000 +0200
--- gcc/cp/lang-specs.h	2008-10-04 23:52:01.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 48,54 ****
        cc1plus %{save-temps|no-integrated-cpp:-fpreprocessed %{save-temps:%b.ii} %{!save-temps:%g.ii}}\
  	      %{!save-temps:%{!no-integrated-cpp:%(cpp_unique_options)}}\
  	%(cc1_options) %2 %{+e1*}\
! 	%{!fsyntax-only:-o %g.s %{!o*:--output-pch=%i.gch} %W{o*:--output-pch=%*}%V}}}}",
       CPLUSPLUS_CPP_SPEC, 0, 0},
    {"@c++",
      "%{E|M|MM:cc1plus -E %(cpp_options) %2 %(cpp_debug_options)}\
--- 48,55 ----
        cc1plus %{save-temps|no-integrated-cpp:-fpreprocessed %{save-temps:%b.ii} %{!save-temps:%g.ii}}\
  	      %{!save-temps:%{!no-integrated-cpp:%(cpp_unique_options)}}\
  	%(cc1_options) %2 %{+e1*}\
! 	%{!fsyntax-only:-o %g.s %{!o*:%{!fdump-ada*:--output-pch=%i.gch}}\
!         %W{o*:--output-pch=%*}%V}}}}",
       CPLUSPLUS_CPP_SPEC, 0, 0},
    {"@c++",
      "%{E|M|MM:cc1plus -E %(cpp_options) %2 %(cpp_debug_options)}\
*** gcc/cp/Make-lang.in	2008-02-27 10:26:24.000000000 +0100
--- gcc/cp/Make-lang.in	2008-09-25 12:22:21.000000000 +0200
*************** g++-cross$(exeext): g++$(exeext)
*** 73,79 ****
  CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \
  	c-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \
  	c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
! 	c-gimplify.o c-omp.o tree-inline.o
  
  # Language-specific object files for C++ and Objective C++.
  CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \
--- 73,79 ----
  CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \
  	c-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \
  	c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
! 	c-gimplify.o c-omp.o tree-inline.o c-macros.o
  
  # Language-specific object files for C++ and Objective C++.
  CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \
*** gcc/c-macros.c	(revision 129138)
--- gcc/c-macros.c	(working copy)
*************** print_ada_macros (pretty_printer *pp, cp
*** 125,131 ****
  	              memmove (prev + 3, prev + 2, buffer - prev - 2);
  	              prev [2] = '#';
  
! 		      if (*buffer != 'L')
  	                buffer++;
  	              *buffer++ = '#';
  	              break;
--- 125,131 ----
  	              memmove (prev + 3, prev + 2, buffer - prev - 2);
  	              prev [2] = '#';
  
! 		      if (*buffer != 'L' && *buffer != 'U')
  	                buffer++;
  	              *buffer++ = '#';
  	              break;
*************** print_ada_macros (pretty_printer *pp, cp
*** 204,209 ****
--- 204,213 ----
  
        *buffer = '\0';
  
+       /* Special case null for now, need to find a more generic approach */
+       if (!strcasecmp ((const char *)NODE_NAME (node), "null"))
+         supported = 0;
+ 
        if (macro->fun_like && supported)
  	{
  	  char *start = (char *) s;
*** gcc/tree-ada-spec.c	(revision 129138)
--- gcc/tree-ada-spec.c	(working copy)
*************** pp_ada_tree_identifier (pretty_printer *
*** 444,450 ****
  
    /* Add trailing "c_" if name is an Ada reserved word */
    for (names = ada_reserved; *names; names++)
!     if (!strcmp (name, *names))
        {
  	s [len2++] = 'c';
  	s [len2++] = '_';
--- 444,450 ----
  
    /* Add trailing "c_" if name is an Ada reserved word */
    for (names = ada_reserved; *names; names++)
!     if (!strcasecmp (name, *names))
        {
  	s [len2++] = 'c';
  	s [len2++] = '_';
*** gcc/varasm.c.ori	Thu Nov 27 18:56:21 2008
--- gcc/varasm.c	Thu Nov 27 18:57:11 2008
*************** get_variable_section (tree decl, bool pr
*** 1176,1187 ****
  	return comm_section;
      }
  
!   if (DECL_INITIAL (decl) == error_mark_node)
!     reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;
!   else if (DECL_INITIAL (decl))
!     reloc = compute_reloc_for_constant (DECL_INITIAL (decl));
!   else
!     reloc = 0;
  
    resolve_unique_section (decl, reloc, flag_data_sections);
    if (IN_NAMED_SECTION (decl))
--- 1176,1182 ----
  	return comm_section;
      }
  
!   reloc = compute_reloc_for_decl (decl);
  
    resolve_unique_section (decl, reloc, flag_data_sections);
    if (IN_NAMED_SECTION (decl))
*************** compute_reloc_for_constant (tree exp)
*** 4056,4061 ****
--- 4051,4073 ----
    return reloc;
  }
  
+ /* Determine what kind of relocations DECL may need.  */
+ 
+ int
+ compute_reloc_for_decl (tree decl)
+ {
+   int reloc;
+ 
+   if (DECL_INITIAL (decl) == error_mark_node)
+     reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;
+   else if (DECL_INITIAL (decl))
+     reloc = compute_reloc_for_constant (DECL_INITIAL (decl));
+   else
+     reloc = 0;
+   
+   return reloc;
+ }
+ 
  /* Find all the constants whose addresses are referenced inside of EXP,
     and make sure assembler code with a label has been output for each one.
     Indicate whether an ADDR_EXPR has been encountered.  */
*** gcc/output.h.ori	Wed Nov 26 18:53:18 2008
--- gcc/output.h	Thu Nov 27 18:58:17 2008
*************** extern bool decl_readonly_section (const
*** 389,394 ****
--- 389,397 ----
     given a constant expression.  */
  extern int compute_reloc_for_constant (tree);
  
+ /* Determine what kind of relocations DECL may need.  */
+ extern int compute_reloc_for_decl (tree);
+ 
  /* User label prefix in effect for this compilation.  */
  extern const char *user_label_prefix;
  
*** gcc/xcoffout.h.ori	Wed Nov 26 18:42:43 2008
--- gcc/xcoffout.h	Thu Nov 27 19:03:17 2008
*************** along with GCC; see the file COPYING3.  
*** 40,49 ****
  
  /* For static variables, output code to define the start of a static block.  */
  
! #define DBX_STATIC_BLOCK_START(ASMFILE,CODE)				\
  {									\
    if ((CODE) == N_STSYM)						\
!     fprintf ((ASMFILE), "\t.bs\t%s[RW]\n", xcoff_private_data_section_name);\
    else if ((CODE) == N_LCSYM)						\
      fprintf ((ASMFILE), "\t.bs\t%s\n", xcoff_bss_section_name);	\
  }
--- 40,55 ----
  
  /* For static variables, output code to define the start of a static block.  */
  
! #define DBX_STATIC_BLOCK_START(ASMFILE,CODE,DECL)			\
  {									\
    if ((CODE) == N_STSYM)						\
!     {									\
!       bool ro = decl_readonly_section ((DECL),			\
! 				       compute_reloc_for_decl (DECL));	\
! 									\
!       fprintf ((ASMFILE), "\t.bs\t%s[%s]\n",				\
! 	       xcoff_private_data_section_name, (ro) ? "RO" : "RW");	\
!     }									\
    else if ((CODE) == N_LCSYM)						\
      fprintf ((ASMFILE), "\t.bs\t%s\n", xcoff_bss_section_name);	\
  }
*** gcc/dbxout.c.ori	Wed Nov 26 18:43:00 2008
--- gcc/dbxout.c	Thu Nov 27 19:00:45 2008
*************** dbxout_symbol_location (tree decl, tree 
*** 3113,3119 ****
       real symbol, for which we might want to prevent a static block
       creation.  */
    if (addr != const0_rtx || ! PREVENT_STATIC_DEBUG_ONLY_BLOCKS)
!     DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
    dbxout_begin_complex_stabs_noforcetext ();
--- 3113,3119 ----
       real symbol, for which we might want to prevent a static block
       creation.  */
    if (addr != const0_rtx || ! PREVENT_STATIC_DEBUG_ONLY_BLOCKS)
!       DBX_STATIC_BLOCK_START (asm_out_file, code, decl);
  #endif
  
    dbxout_begin_complex_stabs_noforcetext ();
*** libstdc++-v3/configure.orig	Mon Dec 01 17:17:36 2008
--- libstdc++-v3/configure	Mon Dec 01 17:19:46 2008
***************
*** 114696,114702 ****
      enable_symvers=no
    else
      if test $with_gnu_ld = yes ; then
!       enable_symvers=gnu
      else
        case ${target_os} in
          darwin*)
--- 114696,114705 ----
      enable_symvers=no
    else
      if test $with_gnu_ld = yes ; then
!       case $target in
!          *-*-mingw*) enable_symvers=no;;
!                   *) enable_symvers=gnu;;
!       esac
      else
        case ${target_os} in
          darwin*)
*** gcc/tree-ada-spec.c	(revision 132849)
--- gcc/tree-ada-spec.c	(working copy)
*************** print_ada_declaration (pretty_printer *b
*** 1567,1578 ****
  		return 0;
  
  	      INDENT (spc);
- 	      pp_string (buffer, "subtype ");
- 	      dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
- 	      pp_string (buffer, " is ");
- 	      dump_generic_ada_node (buffer, typ, type, 0, spc, false, true);
- 	      pp_semicolon (buffer);
  
  	      return 1;
  	    }
  	}
--- 1567,1587 ----
  		return 0;
  
  	      INDENT (spc);
  
+ 	      if (is_struct_like (typ) && !TYPE_FIELDS (typ))
+ 		{
+ 		  pp_string (buffer, "--  skipped empty struct ");
+ 		  dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 		}
+ 	      else
+ 	        {
+ 	          pp_string (buffer, "subtype ");
+ 	          dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
+ 	          pp_string (buffer, " is ");
+ 	          dump_generic_ada_node
+ 		    (buffer, typ, type, 0, spc, false, true);
+ 	          pp_semicolon (buffer);
+ 	        }
  	      return 1;
  	    }
  	}
*** gcc/config.gcc.orig	Fri Dec  5 10:26:56 2008
--- gcc/config.gcc	Fri Dec  5 10:23:23 2008
***************
*** 781,787 ****
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h"
  	tmake_file="arm/t-arm arm/t-arm-elf"
  	;;
! arm*-*-eabi* | arm*-*-symbianelf* )
  	# The BPABI long long divmod functions return a 128-bit value in
  	# registers r0-r3.  Correctly modeling that requires the use of
  	# TImode.
--- 781,787 ----
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h"
  	tmake_file="arm/t-arm arm/t-arm-elf"
  	;;
! arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-nucleus* )
  	# The BPABI long long divmod functions return a 128-bit value in
  	# registers r0-r3.  Correctly modeling that requires the use of
  	# TImode.
***************
*** 799,804 ****
--- 799,808 ----
  	  # provides its own implementation of the BPABI functions.
  	  tmake_file="${tmake_file} arm/t-symbian"
  	  ;;
+         arm*-*-nucleus*)
+           tm_file="${tm_file} arm/nucleus.h"
+           tmake_file="${tmake_file} arm/t-bpabi arm/t-nucleus"
+           ;;
  	esac
  	tm_file="${tm_file} arm/aout.h arm/arm.h"
  	;;
*** libcpp/configure.ac.orig	Fri Dec  5 10:27:57 2008
--- libcpp/configure.ac	Fri Dec  5 10:24:52 2008
***************
*** 116,121 ****
--- 116,122 ----
  	alpha*-*-* | \
  	arm*-*-*eabi* | \
  	arm*-*-symbianelf* | \
+         arm*-*-nucleus* | \
  	x86_64-*-* | \
  	ia64-*-* | \
  	hppa*64*-*-* | parisc*64*-*-* | \
*** libcpp/configure.orig	Fri Dec  5 10:27:50 2008
--- libcpp/configure	Fri Dec  5 10:25:11 2008
***************
*** 8298,8303 ****
--- 8298,8304 ----
  	alpha*-*-* | \
  	arm*-*-*eabi* | \
  	arm*-*-symbianelf* | \
+         arm*-*-nucleus* | \
  	x86_64-*-* | \
  	ia64-*-* | \
  	hppa*64*-*-* | parisc*64*-*-* | \
*** /dev/null	Fri Jun 16 15:07:58 2006
--- gcc/config/arm/nucleus.h	Fri Dec  5 10:20:26 2008
***************
*** 0 ****
--- 1,70 ----
+ /* Configuration file for Nucleus OS on ARM processors.
+    Copyright (C) 2007 Free Software Foundation, Inc.
+    Contributed by AdaCore, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to
+    the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.  */
+ 
+ /* Nucleus OS does not use crt*.o, unlike the generic unknown-elf
+    configuration.  */
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC ""
+ 
+ #undef ENDFILE_SPEC
+ #define ENDFILE_SPEC ""
+ 
+ /* Do not link with any libraries by default.  On Nucleus OS, the user
+    must supply all required libraries on the command line.  */
+ #undef LIB_SPEC
+ #define LIB_SPEC ""
+ 
+ /* This macro is called when code is dynamically generated for use
+    with trampolines. On ARM, it is necessary to also flush the data
+    cache to ensure the new instructions can be executed. There is no
+    API on Nucleus to do this, so execute the relevant instructions
+    directly.  */
+ #undef CLEAR_INSN_CACHE
+ #define CLEAR_INSN_CACHE(BEG,END) \
+   do                                                                 \
+     {                                                                \
+       unsigned long addr=(unsigned long)(BEG) & ~(31UL);             \
+       do                                                             \
+       {                                                            \
+         /* Flush data cache line */                                \
+         asm volatile("mcr    p15,0, %0, c7,c14,1" : : "r" (addr)); \
+         addr += 32;                                                \
+       }                                                            \
+       while (addr && addr < (unsigned long) (END));                  \
+     }                                                                \
+   while (0)
+ 
+ /* Define the __nucleus__ macro.  */
+ #undef TARGET_OS_CPP_BUILTINS
+ #define TARGET_OS_CPP_BUILTINS()              \
+   do                                          \
+     {                                         \
+       /* Include the default BPABI stuff.  */ \
+       TARGET_BPABI_CPP_BUILTINS ();           \
+       builtin_define ("__nucleus__");         \
+     }                                         \
+   while (false)
+ 
+ #undef  TARGET_VERSION
+ #define TARGET_VERSION        fputs (" (ARM/Nucleus OS)", stderr);
+ 
+ /* There is no default multilib.  */
+ #undef MULTILIB_DEFAULTS
*** /dev/null	Fri Jun 16 15:07:58 2006
--- gcc/config/arm/t-nucleus	Fri Dec  5 10:20:26 2008
***************
*** 0 ****
--- 1,8 ----
+ MULTILIB_OPTIONS     =
+ MULTILIB_DIRNAMES    =
+ 
+ # There is no C library to link against on Nucleus OS
+ SHLIB_LC =
+ 
+ # Nucleus OS provides its own startup code.
+ EXTRA_MULTILIB_PARTS=
*** libgcc/config.host.orig	Fri Dec  5 10:59:55 2008
--- libgcc/config.host	Fri Dec  5 11:00:30 2008
***************
*** 231,237 ****
  	;;
  arm*-*-ecos-elf)
  	;;
! arm*-*-eabi* | arm*-*-symbianelf* )
  	;;
  arm*-*-rtems*)
  	;;
--- 231,237 ----
  	;;
  arm*-*-ecos-elf)
  	;;
! arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-nucleus*)
  	;;
  arm*-*-rtems*)
  	;;
*** gcc/config/avr/avr.c.old	Tue Nov 25 11:20:02 2008
--- gcc/config/avr/avr.c	Fri Dec  5 11:47:42 2008
*************** avr_reorg (void)
*** 5616,5621 ****
--- 5630,5644 ----
  	    }
  	}
      }
+ 
+   /* Re-create the REG_DEAD notes.  These notes are used in the machine
+      description to use the best assembly directives.  */
+   if (optimize)
+     {
+       df_note_add_problem ();
+       df_analyze ();
+       df_remove_problem (df_note);
+     }
  }
  
  /* Returns register number for function return value.*/
*** gcc/tree-ada-spec.c	(revision 133063)
--- gcc/tree-ada-spec.c	(working copy)
*************** check_name (pretty_printer *buffer, tree
*** 675,681 ****
    const char *s;
    tree tmp = TREE_TYPE (t);
  
!   while (TREE_CODE (tmp) == POINTER_TYPE)
      tmp = TREE_TYPE (tmp);
  
    if (TREE_CODE (tmp) != FUNCTION_TYPE)
--- 675,681 ----
    const char *s;
    tree tmp = TREE_TYPE (t);
  
!   while (TREE_CODE (tmp) == POINTER_TYPE && !TYPE_NAME (tmp))
      tmp = TREE_TYPE (tmp);
  
    if (TREE_CODE (tmp) != FUNCTION_TYPE)
*************** dump_generic_ada_node (pretty_printer *b
*** 1084,1090 ****
  	  int is_access = false;
  	  unsigned int quals = TYPE_QUALS (TREE_TYPE (node));
  
!           if (VOID_TYPE_P (TREE_TYPE (node)))
  	    {
  	      append_withs ("System", false);
  	      if (!name_only)
--- 1084,1094 ----
  	  int is_access = false;
  	  unsigned int quals = TYPE_QUALS (TREE_TYPE (node));
  
! 	  if (name_only && TYPE_NAME (node))
! 	    dump_generic_ada_node
! 	      (buffer, TYPE_NAME (node), node, cpp_check,
! 	       spc, limited_access, true);
!           else if (VOID_TYPE_P (TREE_TYPE (node)))
  	    {
  	      append_withs ("System", false);
  	      if (!name_only)
*** gcc/tree-ada-spec.c	(revision 134573)
--- gcc/tree-ada-spec.c	(working copy)
*************** dump_generic_ada_node (pretty_printer *b
*** 1145,1150 ****
--- 1145,1153 ----
  		        {
  		          pp_string (buffer, "access ");
  		          is_access = true;
+ 
+ 			  if (!name_only)
+ 			    pp_string (buffer, "all ");
  		        }
  		      else if (quals & TYPE_QUAL_CONST)
  		        pp_string (buffer, "in ");
*************** dump_generic_ada_node (pretty_printer *b
*** 1164,1169 ****
--- 1167,1175 ----
  		    {
  		      is_access = true;
  		      pp_string (buffer, "access ");
+ 
+ 		      if (!name_only)
+ 		        pp_string (buffer, "all ");
  		    }
  
  	          if (is_struct_like (TREE_TYPE (node)))
*** gcc/tree-ada-spec.c	(revision 134574)
--- gcc/tree-ada-spec.c	(working copy)
*************** print_ada_declaration (pretty_printer *b
*** 1704,1710 ****
  
  	  if (tmp)
  	    {
! 	      if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE)
                  pp_string (buffer, "aliased ");
  
  	      dump_generic_ada_node (buffer, tmp, type, 0, spc, false, true);
--- 1704,1711 ----
  
  	  if (tmp)
  	    {
! 	      if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE
! 		  && TREE_CODE (tmp) != INTEGER_TYPE)
                  pp_string (buffer, "aliased ");
  
  	      dump_generic_ada_node (buffer, tmp, type, 0, spc, false, true);
*************** print_ada_declaration (pretty_printer *b
*** 1944,1950 ****
              }
            else
              {
! 	      if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)
  		pp_string (buffer, "aliased ");
  
                dump_generic_ada_node
--- 1945,1953 ----
              }
            else
              {
! 	      if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE
! 		  && (TYPE_NAME (TREE_TYPE (t))
! 		      || TREE_CODE (TREE_TYPE (t)) != INTEGER_TYPE))
  		pp_string (buffer, "aliased ");
  
                dump_generic_ada_node
*** gcc/opts.c.ori	Mon Dec  8 10:16:40 2008
--- gcc/opts.c	Mon Dec  8 10:21:38 2008
*************** decode_options (unsigned int argc, const
*** 1005,1010 ****
--- 1005,1016 ----
      {
        flag_if_conversion = 0;
        flag_if_conversion2 = 0;
+       
+       /* -fpreserve-control-flow is in principle orthogonal to the
+ 	 optimization level.  We haven't yet investigated much at -O > 1,
+ 	 however, so ...  */
+       if (optimize > 1)
+ 	inform ("-fpreserve-control-flow is not supported for -O > 1");
      }
  }
  
*** gcc/config/i386/freebsd.h.1	2008-12-09 17:19:29.013380000 +0100
--- gcc/config/i386/freebsd.h	2008-12-09 17:20:33.840376619 +0100
***************
*** 138,147 ****
  #undef  DEFAULT_PCC_STRUCT_RETURN
  #define DEFAULT_PCC_STRUCT_RETURN 0
  
! /* FreeBSD sets the rounding precision of the FPU to 53 bits.  Let the
!    compiler get the contents of <float.h> and std::numeric_limits correct.  */
  #undef TARGET_96_ROUND_53_LONG_DOUBLE
! #define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
--- 138,147 ----
  #undef  DEFAULT_PCC_STRUCT_RETURN
  #define DEFAULT_PCC_STRUCT_RETURN 0
  
! /* FreeBSD sets the rounding precision of the FPU to 53 bits, but GNAT
!    resets it to full precision.  */
  #undef TARGET_96_ROUND_53_LONG_DOUBLE
! #define TARGET_96_ROUND_53_LONG_DOUBLE 0
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/tree.h.ori	Wed Dec 10 15:14:02 2008
--- gcc/tree.h	Wed Dec 10 15:22:24 2008
*************** struct varray_head_tag;
*** 2087,2092 ****
--- 2087,2097 ----
  
  #define BLOCK_SOURCE_LOCATION(NODE) (BLOCK_CHECK (NODE)->block.locus)
  
+ /* This gives the location of the end of the block, useful to attach 
+    code implictly generated for outgoing paths.  */
+ 
+ #define BLOCK_SOURCE_END_LOCATION(NODE) (BLOCK_CHECK (NODE)->block.end_locus)
+ 
  struct tree_block GTY(())
  {
    struct tree_common common;
*************** struct tree_block GTY(())
*** 2096,2101 ****
--- 2101,2107 ----
    unsigned block_num : 30;
  
    location_t locus;
+   location_t end_locus;
  
    tree vars;
    tree subblocks;
*** gcc/gimplify.c.ori	Mon Dec  8 19:07:36 2008
--- gcc/gimplify.c	Fri Dec 12 18:22:28 2008
*************** gimplify_bind_expr (tree *expr_p, tree *
*** 1186,1191 ****
--- 1186,1199 ----
  	 format of the emitted code: see mx_register_decls().  */
        build_stack_save_restore (&stack_save, &stack_restore);
  
+       /* Source location wise, the stack_restore code belongs to the end
+ 	 of the block so propagate what we have.  */
+       gcc_assert (GIMPLE_STMT_P (stack_restore) || EXPR_P (stack_restore));
+       if (BIND_EXPR_BLOCK (bind_expr))
+ 	SET_EXPR_LOCATION
+ 	  (stack_restore,
+ 	   BLOCK_SOURCE_END_LOCATION (BIND_EXPR_BLOCK (bind_expr)));
+ 
        t = build2 (TRY_FINALLY_EXPR, void_type_node,
  		  BIND_EXPR_BODY (bind_expr), NULL_TREE);
        append_to_statement_list (stack_restore, &TREE_OPERAND (t, 1));
*** gcc/fold-const.c.0	2008-12-11 10:47:40.000000000 +0100
--- gcc/fold-const.c	2008-12-11 20:08:18.000000000 +0100
*************** optimize_minmax_comparison (enum tree_co
*** 6010,6019 ****
     expression would not overflow or that overflow is undefined for the type
     in the language in question.
  
-    We also canonicalize (X + 7) * 4 into X * 4 + 28 in the hope that either
-    the machine has a multiply-accumulate insn or that this is part of an
-    addressing calculation.
- 
     If we return a non-null expression, it is an equivalent form of the
     original computation, but need not be in the original type.
  
--- 6010,6015 ----
*************** fold_plusminus_mult_expr (enum tree_code
*** 7459,7497 ****
    else if (operand_equal_p (arg01, arg10, 0))
      same = arg01, alt0 = arg00, alt1 = arg11;
  
!   /* No identical multiplicands; see if we can find a common
!      power-of-two factor in non-power-of-two multiplies.  This
!      can help in multi-dimensional array access.  */
!   else if (host_integerp (arg01, 0)
! 	   && host_integerp (arg11, 0))
!     {
!       HOST_WIDE_INT int01, int11, tmp;
!       bool swap = false;
!       tree maybe_same;
!       int01 = TREE_INT_CST_LOW (arg01);
!       int11 = TREE_INT_CST_LOW (arg11);
  
        /* Move min of absolute values to int11.  */
!       if ((int01 >= 0 ? int01 : -int01)
! 	  < (int11 >= 0 ? int11 : -int11))
!         {
  	  tmp = int01, int01 = int11, int11 = tmp;
! 	  alt0 = arg00, arg00 = arg10, arg10 = alt0;
! 	  maybe_same = arg01;
  	  swap = true;
  	}
        else
! 	maybe_same = arg11;
  
!       if (exact_log2 (abs (int11)) > 0 && int01 % int11 == 0)
!         {
  	  alt0 = fold_build2 (MULT_EXPR, TREE_TYPE (arg00), arg00,
  			      build_int_cst (TREE_TYPE (arg00),
! 					     int01 / int11));
! 	  alt1 = arg10;
! 	  same = maybe_same;
  	  if (swap)
! 	    maybe_same = alt0, alt0 = alt1, alt1 = maybe_same;
  	}
      }
  
--- 7455,7497 ----
    else if (operand_equal_p (arg01, arg10, 0))
      same = arg01, alt0 = arg00, alt1 = arg11;
  
!   /* No identical multiplicands; see if we can find a common positive
!      power-of-two factor.  This can help in multi-dim array accesses.  */
!   else if (host_integerp (arg01, 0) && host_integerp (arg11, 0))
!     {
!       HOST_WIDE_INT int01 = TREE_INT_CST_LOW (arg01);
!       HOST_WIDE_INT int11 = TREE_INT_CST_LOW (arg11);
!       HOST_WIDE_INT factor, tmp;
!       tree tmp_tree;
!       bool swap;
  
        /* Move min of absolute values to int11.  */
!       if ((int01 >= 0 ? int01 : -int01) < (int11 >= 0 ? int11 : -int11))
! 	{
  	  tmp = int01, int01 = int11, int11 = tmp;
! 	  tmp_tree = arg00, arg00 = arg10, arg10 = tmp_tree;
  	  swap = true;
  	}
        else
! 	swap = false;
  
!       if (int11 < 0)
! 	factor = -int11;
!       else
! 	factor = int11;
! 
!       if (exact_log2 (factor) > 0 && (int01 % factor) == 0)
! 	{
  	  alt0 = fold_build2 (MULT_EXPR, TREE_TYPE (arg00), arg00,
  			      build_int_cst (TREE_TYPE (arg00),
! 					     int01 / factor));
! 	  if (int11 < 0)
! 	    alt1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (arg10), arg10);
! 	  else
! 	    alt1 = arg10;
  	  if (swap)
! 	    tmp_tree = alt0, alt0 = alt1, alt1 = tmp_tree;
! 	  same = build_int_cst (TREE_TYPE (arg10), factor);
  	}
      }
  
*** gcc/expr.c.0	2008-12-11 10:54:49.000000000 +0100
--- gcc/expr.c	2008-12-11 20:29:28.000000000 +0100
*************** get_inner_reference (tree exp, HOST_WIDE
*** 6042,6047 ****
--- 6042,6066 ----
      {
        *pbitpos = tree_low_cst (bit_offset, 0);
        *poffset = offset;
+ 
+       /* The middle-end used to canonicalize (X + 7) * 4 into X * 4 + 28 at
+ 	 the tree level, but that is no longer the case.  However the latter
+ 	 form is still the preferred one in addressing calculations.  */
+       if (TREE_CODE (offset) == MULT_EXPR
+ 	  && TREE_CODE (TREE_OPERAND (offset, 1)) == INTEGER_CST)
+ 	{
+ 	  tree op0 = TREE_OPERAND (offset, 0), disp;
+ 	  enum tree_code code = TREE_CODE (op0);
+ 	  if ((code == PLUS_EXPR || code == MINUS_EXPR)
+ 	      && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST
+ 	      && (disp = int_const_binop (MULT_EXPR, TREE_OPERAND (op0, 1),
+ 					  TREE_OPERAND (offset, 1), 0))
+ 	      && !TREE_OVERFLOW (disp))
+ 	    *poffset = build2 (code, TREE_TYPE (offset),
+ 			       size_binop (MULT_EXPR, TREE_OPERAND (op0, 0),
+ 					   TREE_OPERAND (offset, 1)),
+ 			       disp);
+ 	}
      }
  
    /* We can use BLKmode for a byte-aligned BLKmode bitfield.  */
*** gcc/passes.c.0	2008-12-11 10:47:40.000000000 +0100
--- gcc/passes.c	2008-12-11 10:47:51.000000000 +0100
*************** init_optimization_passes (void)
*** 667,673 ****
  	 may help.  */
        NEXT_PASS (pass_late_warn_uninitialized);
        NEXT_PASS (pass_dse);
!       NEXT_PASS (pass_forwprop);
        NEXT_PASS (pass_phiopt);
        NEXT_PASS (pass_tail_calls);
        NEXT_PASS (pass_rename_ssa_copies);
--- 667,673 ----
  	 may help.  */
        NEXT_PASS (pass_late_warn_uninitialized);
        NEXT_PASS (pass_dse);
!       NEXT_PASS (pass_forwprop_final);
        NEXT_PASS (pass_phiopt);
        NEXT_PASS (pass_tail_calls);
        NEXT_PASS (pass_rename_ssa_copies);
*** gcc/tree-pass.h.0	2008-12-11 10:47:40.000000000 +0100
--- gcc/tree-pass.h	2008-12-11 09:34:00.000000000 +0100
*************** extern struct tree_opt_pass pass_warn_fu
*** 306,311 ****
--- 306,312 ----
  extern struct tree_opt_pass pass_cselim;
  extern struct tree_opt_pass pass_phiopt;
  extern struct tree_opt_pass pass_forwprop;
+ extern struct tree_opt_pass pass_forwprop_final;
  extern struct tree_opt_pass pass_phiprop;
  extern struct tree_opt_pass pass_tree_ifcombine;
  extern struct tree_opt_pass pass_dse;
*** gcc/tree-ssa-forwprop.c.0	2008-12-11 10:47:40.000000000 +0100
--- gcc/tree-ssa-forwprop.c	2008-12-12 12:56:18.000000000 +0100
*************** simplify_switch_expr (tree stmt)
*** 955,964 ****
      }
  }
  
  /* Main entry point for the forward propagation optimizer.  */
  
  static unsigned int
! tree_ssa_forward_propagate_single_use_vars (void)
  {
    basic_block bb;
    unsigned int todoflags = 0;
--- 955,1123 ----
      }
  }
  
+ /* REF is a reference, in the statement pointed to by BSI, of the form
+ 
+      ARRAY_REF <ARRAY_REF <...>>
+ 
+    Try to forward propagate small perturbations into the index of
+    inner array references to avoid pessimizing the initial RTL.
+ 
+    Consider
+ 
+      R[0] = A[i1+1][i2][i3]   + A[i1][i2+1][i3] + A[i1][i2][i3+1]
+      R[1] = A[i1+1][i2][i3+1] + A[i1][i2][i3]   + A[i1-1][i2][i3-1]
+      R[2] = A[i1-1][i2][i3+1] + A[i1][i2][i3]   + A[i1+1][i2][i3-1]
+ 
+    Gimplification and Common Subexpression Elimination have created
+    temporaries for the perturbated variables i1+1, i1-1, i2+1, i3+1
+    and i3-1 as well as unified the duplicated ones.  Now, since TER
+    only operates on temporaries with a single use, the code handed
+    down to the RTL expander would be:
+ 
+      D1 = i1+1
+      D2 = i1-1
+      D3 = i3+1
+      D4 = i3-1
+      R[0] = A[D1][i2][i3] + A[i1][i2+1][i3] + A[i1][i2][D3]
+      R[1] = A[D1][i2][D3] + A[i1][i2][i3]   + A[D2][i2][D4]
+      R[2] = A[D2][i2][D3] + A[i1][i2][i3]   + A[D1][i2][D4]
+ 
+    While the small perturbations contained in D3 and D4 can easily be
+    retrofitted after the array references have been flattened to RTL,
+    those contained in D1 and D2 cannot because their effect is spread
+    over numerous computations.
+ 
+    We use the property that ARRAY_RANGE_REF of an array doesn't "cut"
+    the (outermost) dimension but only "renumbers" it, to rewrite the
+    original ARRAY_REF using the perturbation as the index in a new
+    dimension centered around the fixed part:
+ 
+      A[i1+1][i2][i3] -> A[i1 ...][1][i2][i3]
+ 
+    In doing so we generate formally out-of-bounds array references,
+    but the compiler is supposed to be able to cope with them since
+    they are a common idiom of the C language.  */
+ 
+ #define CONTAINS_INNER_ARRAY_REF_P(NODE)		\
+   (TREE_CODE ((NODE)) == ARRAY_REF			\
+    && TREE_CODE (TREE_OPERAND ((NODE), 0)) == ARRAY_REF)
+ 
+ #define FIRST_INNER_ARRAY_REF(NODE) TREE_OPERAND ((NODE), 0)
+ 
+ static void
+ forward_propagate_into_inner_array_ref (tree ref, block_stmt_iterator bsi)
+ {
+   tree t, next;
+   bool changed = false;
+ 
+   /* Loop over inner array references from the outermost to the innermost.
+      Note that we may be expanding the chain while we are walking it, so
+      we must be careful and for example prefetch the next step.  */
+   for (t = FIRST_INNER_ARRAY_REF (ref); TREE_CODE (t) == ARRAY_REF; t = next)
+     {
+       tree def_stmt, index, index_type, range_type, base, offset;
+       bool with_cast = false;
+ 
+       /* See above comment.  */
+       next = TREE_OPERAND (t, 0);
+ 
+       /* We're looking for an SSA_NAME index...  */
+       index = TREE_OPERAND (t, 1);
+       index_type = TREE_TYPE (index);
+       if (TREE_CODE (index) != SSA_NAME)
+ 	continue;
+ 
+       /* ... whose defining RHS...  */
+       def_stmt = SSA_NAME_DEF_STMT (index);
+       if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)
+ 	continue;
+ 
+       /* ... modulo a cast...  */
+       index = GIMPLE_STMT_OPERAND (def_stmt, 1);
+       if (TREE_CODE (index) == NOP_EXPR)
+ 	{
+ 	  index = TREE_OPERAND (index, 0);
+ 	  if (TREE_CODE (index) != SSA_NAME)
+ 	    continue;
+ 
+ 	  def_stmt = SSA_NAME_DEF_STMT (index);
+ 	  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)
+ 	    continue;
+ 
+ 	  index = GIMPLE_STMT_OPERAND (def_stmt, 1);
+ 	  with_cast = true;
+ 	}
+ 
+       /* ... is an additive perturbation of small extent.  */
+       if ((TREE_CODE (index) == PLUS_EXPR || TREE_CODE (index) == MINUS_EXPR)
+ 	  && TREE_CODE (TREE_OPERAND (index, 1)) == INTEGER_CST)
+ 	{
+ 	  offset = TREE_OPERAND (index, 1);
+ 	  base = TREE_OPERAND (index, 0);
+ 
+ 	  /* Strip off cast from the base as well.  */
+ 	  if (TREE_CODE (base) == SSA_NAME
+ 	      && TREE_CODE (SSA_NAME_DEF_STMT (base)) == GIMPLE_MODIFY_STMT)
+ 	    {
+ 	      tree rhs = GIMPLE_STMT_OPERAND (SSA_NAME_DEF_STMT (base), 1);
+ 	      if (TREE_CODE (rhs) == NOP_EXPR)
+ 		base = TREE_OPERAND (rhs, 0);
+ 	    }
+ 	}
+ 
+       /* Otherwise fall back to the original index if there was a cast.
+ 	 This may seem useless but actually is not because we're going
+ 	 to make a new instance of the casted variable, which will make
+ 	 it possible for TER to fold the cast into the array reference.  */
+       else if (with_cast)
+ 	{
+ 	  offset = NULL_TREE;
+ 	  base = GIMPLE_STMT_OPERAND (def_stmt, 0);
+ 	}
+ 
+       else
+ 	continue;
+ 
+       /* Preserve type consistency for the index.  TER will fold it.  */
+       if (TREE_TYPE (base) != index_type)
+ 	{
+ 	  tree tmp = make_rename_temp (index_type, "fwptmp");
+ 	  tree stmt
+ 	    = build_gimple_modify_stmt (tmp, fold_convert (index_type, base));
+ 	  bsi_insert_before (&bsi, stmt, TSI_SAME_STMT);
+ 	  base = tmp;
+ 	}
+ 
+       if (offset)
+ 	{
+ 	  /* Insert the ARRAY_RANGE_REF and change the ARRAY_REF.  */
+ 	  range_type = build_array_type (TREE_TYPE (t),
+ 	  				 build_index_type (size_zero_node));
+ 	  TREE_OPERAND (t, 0) = build4 (ARRAY_RANGE_REF, range_type,
+ 					TREE_OPERAND (t, 0), base,
+ 					TREE_OPERAND (t, 2),
+ 					TREE_OPERAND (t, 3));
+ 	  index_type = signed_type_for (index_type);
+ 	  offset = fold_convert (index_type, offset);
+ 	  if (TREE_CODE (index) == MINUS_EXPR)
+ 	    offset = fold_build1 (NEGATE_EXPR, index_type, offset);
+ 	  TREE_OPERAND (t, 1) = offset;
+ 	  TREE_OPERAND (t, 2) = build_int_cst (index_type, 0);
+ 	}
+       else
+ 	TREE_OPERAND (t, 1) = base;
+ 
+       changed = true;
+     }
+ 
+   if (changed)
+     update_stmt (bsi_stmt (bsi));
+ }
+ 
  /* Main entry point for the forward propagation optimizer.  */
  
  static unsigned int
! tree_ssa_forward_propagate_vars (bool final)
  {
    basic_block bb;
    unsigned int todoflags = 0;
*************** tree_ssa_forward_propagate_single_use_va
*** 1036,1041 ****
--- 1195,1207 ----
  		  else
  		    bsi_next (&bsi);
  		}
+ 	      /* During the final pass, try to make inner array
+ 		 references more suitable for RTL expansion.  */
+ 	      else if (final && CONTAINS_INNER_ARRAY_REF_P (rhs))
+ 		{
+ 		  forward_propagate_into_inner_array_ref (rhs, bsi);
+ 		  bsi_next (&bsi);
+ 		}
  	      else
  		bsi_next (&bsi);
  	    }
*************** tree_ssa_forward_propagate_single_use_va
*** 1065,1070 ****
--- 1228,1244 ----
    return todoflags;
  }
  
+ static unsigned int
+ tree_ssa_forward_propagate_single_use_vars (void)
+ {
+   return tree_ssa_forward_propagate_vars (false);
+ }
+ 
+ static unsigned int
+ tree_ssa_forward_propagate_final_vars (void)
+ {
+   return tree_ssa_forward_propagate_vars (true);
+ }
  
  static bool
  gate_forwprop (void)
*************** struct tree_opt_pass pass_forwprop = {
*** 1091,1096 ****
--- 1271,1295 ----
    0				/* letter */
  };
  
+ struct tree_opt_pass pass_forwprop_final = {
+   "forwpropfinal",			/* name */
+   gate_forwprop,		/* gate */
+   tree_ssa_forward_propagate_final_vars,	/* execute */
+   NULL,				/* sub */
+   NULL,				/* next */
+   0,				/* static_pass_number */
+   TV_TREE_FORWPROP,		/* tv_id */
+   PROP_cfg | PROP_ssa,		/* properties_required */
+   0,				/* properties_provided */
+   0,				/* properties_destroyed */
+   0,				/* todo_flags_start */
+   TODO_dump_func
+   | TODO_ggc_collect
+   | TODO_update_ssa
+   | TODO_verify_ssa,		/* todo_flags_finish */
+   0				/* letter */
+ };
+ 
  
  /* Structure to keep track of the value of a dereferenced PHI result
     and the set of virtual operands used for that dereference.  */
*** gcc/collect2.c.orig	Thu Dec 18 14:10:45 2008
--- gcc/collect2.c	Thu Dec 18 14:13:29 2008
***************
*** 881,886 ****
--- 881,887 ----
    const char **ld2;
    char **object_lst;
    const char **object;
+   int object_nbr = argc;
    int first_file;
    int num_c_args;
    char **old_argv;
***************
*** 918,924 ****
  
    ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+4));
    ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+11));
!   object = (const char **)(object_lst = xcalloc(sizeof (char *), argc));
  
  #ifdef DEBUG
    debug = 1;
--- 919,925 ----
  
    ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+4));
    ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+11));
!   object = (const char **)(object_lst = XNEWVEC(char *, object_nbr));
  
  #ifdef DEBUG
    debug = 1;
***************
*** 1180,1185 ****
--- 1181,1238 ----
  		  *ld1++ = *ld2++ = *argv;
  		}
  	      break;
+ 
+ #ifdef OBJECT_FORMAT_COFF
+ 	    case 'f':
+ 	      /* File containing a list of input files to process.  */
+ 	      {
+ 		FILE *stream;
+ 		char buf[MAXPATHLEN + 2];
+ 		/* Number of additionnal object files.  */
+ 		int add_nbr = 0;
+ 		/* Maximum of additionnal object files before vector
+ 		   expansion.  */
+ 		int add_max = 0;
+ 		const char *list_filename = arg + 2;
+ 
+ 		/* Accept -fFILENAME and -f FILENAME.  */
+ 		if (*list_filename == '\0' && argv[1])
+ 		  {
+ 		    ++argv;
+ 		    list_filename = *argv;
+ 		    *ld1++ = *ld2++ = *argv;
+ 		  }
+ 
+ 		stream = fopen (list_filename, "r");
+ 		if (stream == NULL)
+ 		  fatal_perror ("can't open %s", list_filename);
+ 
+ 		while (fgets (buf, sizeof buf, stream) != NULL)
+ 		  {
+ 		    /* Remove end of line.  */
+ 		    int len = strlen (buf);
+ 		    if (len >= 1 && buf[len - 1] =='\n')
+ 		      buf[len - 1] = '\0';
+ 		
+ 		    /* Put on object vector.
+ 		       Note: we only expanse vector here, so we must keep
+ 		       extra space for remaining arguments.  */
+ 		    if (add_nbr >= add_max)
+ 		      {
+ 			int pos = (char **)object - object_lst;
+ 			add_max = (add_max == 0) ? 16 : add_max * 2;
+ 			object_lst = XRESIZEVEC(char *, object_lst,
+ 						object_nbr + add_max);
+ 			object = (const char **)object_lst + pos;
+ 			object_nbr += add_max;
+ 		      }
+ 		    *object++ = xstrdup(buf);
+ 		    add_nbr++;
+ 		  }
+ 		fclose (stream);
+ 	      }
+ 	      break;
+ #endif
  
  	    case 'l':
  	      if (first_file)
*** gcc/libgcov.c.orig	2008-12-18 14:23:53.000000000 +0100
--- gcc/libgcov.c	2008-12-18 14:20:31.000000000 +0100
***************
*** 132,140 ****
     
  static int
  gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,
! 	      const char *filename)
  {
!   if (version != GCOV_VERSION)
      {
        char v[4], e[4];
  
--- 132,141 ----
     
  static int
  gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,
! 	      const char *filename, int strict_p)
  {
!   if ((version != GCOV_VERSION && strict_p)
!       || version < (gcov_unsigned_t)0x33303432)
      {
        char v[4], e[4];
  
***************
*** 328,334 ****
  	      goto read_fatal;
  	    }
  	  length = gcov_read_unsigned ();
! 	  if (!gcov_version (gi_ptr, length, gi_filename))
  	    goto read_fatal;
  
  	  length = gcov_read_unsigned ();
--- 329,335 ----
  	      goto read_fatal;
  	    }
  	  length = gcov_read_unsigned ();
! 	  if (!gcov_version (gi_ptr, length, gi_filename, 1))
  	    goto read_fatal;
  
  	  length = gcov_read_unsigned ();
***************
*** 539,545 ****
  {
    if (!info->version)
      return;
!   if (gcov_version (info, info->version, 0))
      {
        const char *ptr = info->filename;
        gcov_unsigned_t crc32 = gcov_crc32;
--- 540,546 ----
  {
    if (!info->version)
      return;
!   if (gcov_version (info, info->version, 0, 0))
      {
        const char *ptr = info->filename;
        gcov_unsigned_t crc32 = gcov_crc32;
*** gcc/gcov.c.original	Fri Dec 19 11:54:06 2008
--- gcc/gcov.c	Fri Dec 19 12:14:14 2008
*************** static int flag_unconditional = 0;
*** 297,302 ****
--- 297,307 ----
  
  static int flag_gcov_file = 1;
  
+ /* Output progress indication if this is true. This is off by default
+    and can be turned on by the -d option.  */
+ 
+ static int flag_display_progress = 0;
+ 
  /* For included files, make the gcov output file name include the name
     of the input source file.  For example, if x.h is included in a.c,
     then the output file name is a.c##x.h.gcov instead of x.h.gcov.  */
*************** int
*** 357,362 ****
--- 362,368 ----
  main (int argc, char **argv)
  {
    int argno;
+   int first_arg;
  
    /* Unlock the stdio streams.  */
    unlock_std_streams ();
*************** main (int argc, char **argv)
*** 373,380 ****
    if (argc - argno > 1)
      multiple_files = 1;
  
    for (; argno != argc; argno++)
!     process_file (argv[argno]);
  
    generate_results (multiple_files ? NULL : argv[argc - 1]);
  
--- 379,393 ----
    if (argc - argno > 1)
      multiple_files = 1;
  
+   first_arg = argno;
+   
    for (; argno != argc; argno++)
!     {
!       if (flag_display_progress)
!         printf("Processing file %d out of %d\n",  
!                argno - first_arg + 1, argc - first_arg);
!       process_file (argv[argno]);
!     }
  
    generate_results (multiple_files ? NULL : argv[argc - 1]);
  
*************** print_usage (int error_p)
*** 446,451 ****
--- 459,465 ----
    fnotice (file, "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n");
    fnotice (file, "  -p, --preserve-paths            Preserve all pathname components\n");
    fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
+   fnotice (file, "  -d, --display-progress          Display progress information\n");
    fnotice (file, "\nFor bug reporting instructions, please contact:\n%s.\n",
  	   bug_report_url);
    exit (status);
*************** static const struct option options[] =
*** 480,485 ****
--- 494,500 ----
    { "object-directory",     required_argument, NULL, 'o' },
    { "object-file",          required_argument, NULL, 'o' },
    { "unconditional-branches", no_argument,     NULL, 'u' },
+   { "display-progress",     no_argument,       NULL, 'd' },
    { 0, 0, 0, 0 }
  };
  
*************** process_args (int argc, char **argv)
*** 490,496 ****
  {
    int opt;
  
!   while ((opt = getopt_long (argc, argv, "abcfhlno:puv", options, NULL)) != -1)
      {
        switch (opt)
  	{
--- 505,511 ----
  {
    int opt;
  
!   while ((opt = getopt_long (argc, argv, "abcdfhlno:puv", options, NULL)) != -1)
      {
        switch (opt)
  	{
*************** process_args (int argc, char **argv)
*** 524,529 ****
--- 539,547 ----
  	case 'u':
  	  flag_unconditional = 1;
  	  break;
+         case 'd':
+           flag_display_progress = 1;
+           break;
  	case 'v':
  	  print_version ();
  	  /* print_version will exit.  */
*** gcc/doc/gcov.texi.orig	Fri Dec 19 10:26:34 2008
--- gcc/doc/gcov.texi	Fri Dec 19 15:44:47 2008
*************** gcov [@option{-v}|@option{--version}] [@
*** 131,136 ****
--- 131,137 ----
       [@option{-f}|@option{--function-summaries}]
       [@option{-o}|@option{--object-directory} @var{directory|file}] @var{sourcefiles}
       [@option{-u}|@option{--unconditional-branches}]
+      [@option{-d}|@option{--display-progress}]
  @c man end
  @c man begin SEEALSO
  gpl(7), gfdl(7), fsf-funding(7), gcc(1) and the Info entry for @file{gcc}.
*************** option is not supplied, it defaults to t
*** 212,217 ****
--- 213,222 ----
  When branch probabilities are given, include those of unconditional branches.
  Unconditional branches are normally not interesting.
  
+ @item -d
+ @itemx --display-progress
+ Display the progress on the standard output.
+ 
  @end table
  
  @command{gcov} should be run with the current directory the same as that
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** dump_ada_array_domains (pretty_printer *
*** 852,859 ****
    pp_character (buffer, ')');
  }
  
- /* Ada version */
- 
  static void
  dump_sloc (pretty_printer *buffer, tree node)
  {
--- 852,857 ----
*************** dump_sloc (pretty_printer *buffer, tree 
*** 876,881 ****
--- 874,905 ----
      }
  }
  
+ /* dump array type in Ada syntax. Assume that the "type" keyword and name
+    have already been printed. */
+ 
+ static void
+ dump_ada_array_type (pretty_printer *buffer, tree t, int spc)
+ {
+   tree tmp;
+ 
+   pp_string (buffer, "array ");
+   /* Print the dimensions.  */
+   dump_ada_array_domains (buffer, TREE_TYPE (t), spc);
+ 
+   /* Print array's type.  */
+   tmp = TREE_TYPE (t);
+   while (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)
+     tmp = TREE_TYPE (tmp);
+ 
+   pp_string (buffer, " of ");
+ 
+   if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE)
+     pp_string (buffer, "aliased ");
+ 
+   dump_generic_ada_node
+     (buffer, TREE_TYPE (tmp), TREE_TYPE (t), NULL, spc, false, true);
+ }
+ 
  static bool in_function = true;
  static bool bitfield_used = false;
  
*************** dump_generic_ada_node (pretty_printer *b
*** 1203,1208 ****
--- 1227,1241 ----
  	}
        break;
  
+     case ARRAY_TYPE:
+       if (name_only)
+ 	dump_generic_ada_node
+ 	  (buffer, TYPE_NAME (node), node, cpp_check,
+ 	   spc, limited_access, true);
+       else
+         dump_ada_array_type (buffer, node, spc);
+       break;
+ 
      case RECORD_TYPE:
      case UNION_TYPE:
      case QUAL_UNION_TYPE:
*************** dump_generic_ada_node (pretty_printer *b
*** 1316,1347 ****
    return spc;
  }
  
- /* dump array type in Ada syntax. Assume that the "type" keyword and name
-    have already been printed. */
- 
- static void
- dump_ada_array_type (pretty_printer *buffer, tree t, int spc)
- {
-   tree tmp;
- 
-   pp_string (buffer, "array ");
-   /* Print the dimensions.  */
-   dump_ada_array_domains (buffer, TREE_TYPE (t), spc);
- 
-   /* Print array's type.  */
-   tmp = TREE_TYPE (t);
-   while (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)
-     tmp = TREE_TYPE (tmp);
- 
-   pp_string (buffer, " of ");
- 
-   if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE)
-     pp_string (buffer, "aliased ");
- 
-   dump_generic_ada_node
-     (buffer, TREE_TYPE (tmp), TREE_TYPE (t), NULL, spc, false, true);
- }
- 
  /* Print the methods of the class in Ada syntax, if any.  */
  
  #define IS_ABSTRACT 0
--- 1349,1354 ----
*************** print_ada_declaration (pretty_printer *b
*** 1564,1572 ****
  
    if (TREE_CODE (t) == TYPE_DECL)
      {
!       if (DECL_ORIGINAL_TYPE (t) && TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (t)))
  	{
! 	  tree typ = TREE_TYPE (TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (t)));
  
  	  if (TYPE_NAME (typ))
  	    {
--- 1571,1581 ----
  
    if (TREE_CODE (t) == TYPE_DECL)
      {
!       tree orig = DECL_ORIGINAL_TYPE (t);
! 
!       if (orig && TYPE_STUB_DECL (orig))
  	{
! 	  tree typ = TREE_TYPE (TYPE_STUB_DECL (orig));
  
  	  if (TYPE_NAME (typ))
  	    {
*************** print_ada_declaration (pretty_printer *b
*** 1596,1609 ****
  	    }
  	}
  
!       if (!DECL_ORIGINAL_TYPE (t) && !decl_name && !name)
  	{
  	  /* skip unnamed or anonymous structs/unions.
             */
            return 0;
  	}
  
!       if (!DECL_ORIGINAL_TYPE (t)
  	  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE
  	  && decl_name
  	  && *IDENTIFIER_POINTER (decl_name) == '.')
--- 1605,1618 ----
  	    }
  	}
  
!       if (!orig && !decl_name && !name)
  	{
  	  /* skip unnamed or anonymous structs/unions.
             */
            return 0;
  	}
  
!       if (!orig
  	  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE
  	  && decl_name
  	  && *IDENTIFIER_POINTER (decl_name) == '.')
*************** print_ada_declaration (pretty_printer *b
*** 1633,1657 ****
  		return 1;
  	      }
  
! 	    dump_nested_types (buffer, t, t, cpp_check, spc);
! 
! 	    if (TYPE_METHODS (TREE_TYPE (t)))
  	      {
! 	        is_class = true;
! 	        pp_string (buffer, "package Class_");
! 	        dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
! 	        pp_string (buffer, " is");
! 	        spc += 2;
! 	        newline_and_indent (buffer, spc);
! 	      }
  
! 	    pp_string (buffer, "type ");
  	    break;
  
  	  case ARRAY_TYPE:
  	  case POINTER_TYPE:
  	  case REFERENCE_TYPE:
! 	    pp_string (buffer, "type ");
  	    break;
  
  	  case FUNCTION_TYPE:
--- 1642,1675 ----
  		return 1;
  	      }
  
! 	    if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))
! 	      pp_string (buffer, "subtype ");
! 	    else
  	      {
! 		dump_nested_types (buffer, t, t, cpp_check, spc);
! 
! 		if (TYPE_METHODS (TREE_TYPE (t)))
! 		  {
! 		    is_class = true;
! 		    pp_string (buffer, "package Class_");
! 		    dump_generic_ada_node
! 		      (buffer, t, type, 0, spc, false, true);
! 		    pp_string (buffer, " is");
! 		    spc += 2;
! 		    newline_and_indent (buffer, spc);
! 		  }
  
! 		pp_string (buffer, "type ");
! 	      }
  	    break;
  
  	  case ARRAY_TYPE:
  	  case POINTER_TYPE:
  	  case REFERENCE_TYPE:
! 	    if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))
! 	      pp_string (buffer, "subtype ");
! 	    else
! 	      pp_string (buffer, "type ");
  	    break;
  
  	  case FUNCTION_TYPE:
*************** print_ada_declaration (pretty_printer *b
*** 1912,1925 ****
  
        if (TREE_CODE (t) == TYPE_DECL)
  	{
  	  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
  	      || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)
  	    pp_string (buffer, " (discr : unsigned := 0)");
  
  	  pp_string (buffer, " is ");
  
  	  dump_generic_ada_node
! 	    (buffer, DECL_ORIGINAL_TYPE (t), t, cpp_check, spc, false, false);
  	}
        else
  	{
--- 1930,1948 ----
  
        if (TREE_CODE (t) == TYPE_DECL)
  	{
+           tree orig;
+ 
  	  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
  	      || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)
  	    pp_string (buffer, " (discr : unsigned := 0)");
  
  	  pp_string (buffer, " is ");
  
+           orig = DECL_ORIGINAL_TYPE (t);
  	  dump_generic_ada_node
! 	    (buffer, orig, t, cpp_check, spc, false,
! 	     orig && TYPE_NAME (orig) && orig != TREE_TYPE (t));
! 
  	}
        else
  	{
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** print_ada_declaration (pretty_printer *b
*** 1564,1569 ****
--- 1564,1570 ----
    tree name = TYPE_NAME (TREE_TYPE (t));
    tree decl_name = DECL_NAME (t);
    bool dump_internal = get_dump_file_info (TDI_ada)->flags & TDF_RAW;
+   tree orig = NULL_TREE;
  
    if (TREE_CODE (t) == CONST_DECL && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)
      /* Skip enumeral values: will be handled as part of the type itself */
*************** print_ada_declaration (pretty_printer *b
*** 1571,1577 ****
  
    if (TREE_CODE (t) == TYPE_DECL)
      {
!       tree orig = DECL_ORIGINAL_TYPE (t);
  
        if (orig && TYPE_STUB_DECL (orig))
  	{
--- 1572,1578 ----
  
    if (TREE_CODE (t) == TYPE_DECL)
      {
!       orig = DECL_ORIGINAL_TYPE (t);
  
        if (orig && TYPE_STUB_DECL (orig))
  	{
*************** print_ada_declaration (pretty_printer *b
*** 1709,1715 ****
        if (TREE_CODE (t) == TYPE_DECL)
          {
            pp_string (buffer, " is ");
! 	  dump_ada_array_type (buffer, t, spc);
  	}
        else
          {
--- 1710,1722 ----
        if (TREE_CODE (t) == TYPE_DECL)
          {
            pp_string (buffer, " is ");
! 
! 	  if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))
! 	    dump_generic_ada_node
! 	      (buffer, TYPE_NAME (orig), type,
! 	       cpp_check, spc, false, true);
! 	  else
! 	    dump_ada_array_type (buffer, t, spc);
  	}
        else
          {
*************** print_ada_declaration (pretty_printer *b
*** 1914,1921 ****
  	  print_ada_methods (buffer, TREE_TYPE (t), cpp_check, spc);
  	}
        else
!         dump_generic_ada_node
! 	  (buffer, t, t, cpp_check, spc, false, false);
      }
    else
      {
--- 1921,1927 ----
  	  print_ada_methods (buffer, TREE_TYPE (t), cpp_check, spc);
  	}
        else
!         dump_generic_ada_node (buffer, t, t, cpp_check, spc, false, false);
      }
    else
      {
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** get_underlying_decl (tree type)
*** 426,431 ****
--- 426,444 ----
    return decl;
  }
  
+ static int
+ has_static_fields (tree type)
+ {
+   tree tmp;
+ 
+   for (tmp = TYPE_FIELDS (type); tmp; tmp = TREE_CHAIN (tmp))
+     {
+       if (DECL_NAME (tmp) && TREE_STATIC (tmp))
+ 	return true;
+     }
+   return false;
+ }
+ 
  /* Dump the name of an identifier node, following Ada syntax */
  
  static void
*************** print_ada_declaration (pretty_printer *b
*** 1649,1662 ****
  	      {
  		dump_nested_types (buffer, t, t, cpp_check, spc);
  
! 		if (TYPE_METHODS (TREE_TYPE (t)))
  		  {
  		    is_class = true;
  		    pp_string (buffer, "package Class_");
  		    dump_generic_ada_node
  		      (buffer, t, type, 0, spc, false, true);
  		    pp_string (buffer, " is");
! 		    spc += 2;
  		    newline_and_indent (buffer, spc);
  		  }
  
--- 1662,1676 ----
  	      {
  		dump_nested_types (buffer, t, t, cpp_check, spc);
  
! 		if (TYPE_METHODS (TREE_TYPE (t))
! 		    || has_static_fields (TREE_TYPE (t)))
  		  {
  		    is_class = true;
  		    pp_string (buffer, "package Class_");
  		    dump_generic_ada_node
  		      (buffer, t, type, 0, spc, false, true);
  		    pp_string (buffer, " is");
! 		    spc += 3;
  		    newline_and_indent (buffer, spc);
  		  }
  
*************** print_ada_declaration (pretty_printer *b
*** 1722,1728 ****
          {
  	  tree tmp = TYPE_NAME (TREE_TYPE (t));
  
! 	  if (spc == 2)
  	    is_var = 1;
  
            pp_string (buffer, " : ");
--- 1736,1742 ----
          {
  	  tree tmp = TYPE_NAME (TREE_TYPE (t));
  
! 	  if (spc == 2 || TREE_STATIC (t))
  	    is_var = 1;
  
            pp_string (buffer, " : ");
*************** print_ada_declaration (pretty_printer *b
*** 1952,1958 ****
  	}
        else
  	{
! 	  if (spc == 2)
  	    is_var = 1;
  
  	  pp_string (buffer, " : ");
--- 1966,1972 ----
  	}
        else
  	{
! 	  if (spc == 2 || TREE_STATIC (t))
  	    is_var = 1;
  
  	  pp_string (buffer, " : ");
*************** print_ada_declaration (pretty_printer *b
*** 1988,1994 ****
  
    if (is_class)
      {
!       spc -= 2;
        newline_and_indent (buffer, spc);
        pp_string (buffer, "end;");
        newline_and_indent (buffer, spc);
--- 2002,2008 ----
  
    if (is_class)
      {
!       spc -= 3;
        newline_and_indent (buffer, spc);
        pp_string (buffer, "end;");
        newline_and_indent (buffer, spc);
*************** print_ada_struct_decl (pretty_printer *b
*** 2028,2033 ****
--- 2042,2048 ----
    char buf [16];
    int field_num = 0;
    int field_spc = spc + 2;
+   int need_semicolon;
  
    bitfield_used = false;
  
*************** print_ada_struct_decl (pretty_printer *b
*** 2048,2066 ****
  
        pp_newline (buffer);
  
!       /* Print the fields of the structure.  */
        for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))
  	{
! 	  /* Avoid to print recursively the structure.  */
! 	  /* FIXME : Not implemented correctly...,
! 	     what about the case when we have a cycle in the contain graph? ...
! 	     Maybe this could be solved by looking at the scope in which the
! 	     structure was declared.  */
            if ((TREE_TYPE (tmp) != node
                 || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE
                     && TREE_TYPE (TREE_TYPE (tmp)) != node))
!               && DECL_NAME (tmp)
!               && TREE_CODE (tmp) != TYPE_DECL)
  	    {
  	      /* skip internal virtual table field */
  	      if (strncmp (IDENTIFIER_POINTER (DECL_NAME (tmp)), "_vptr.", 6))
--- 2063,2078 ----
  
        pp_newline (buffer);
  
!       /* Print the non-static fields of the structure.  */
        for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))
  	{
! 	  /* Avoid printing the structure recursively.  */
            if ((TREE_TYPE (tmp) != node
                 || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE
                     && TREE_TYPE (TREE_TYPE (tmp)) != node))
! 		   && DECL_NAME (tmp)
! 		   && TREE_CODE (tmp) != TYPE_DECL
! 		   && !TREE_STATIC (tmp))
  	    {
  	      /* skip internal virtual table field */
  	      if (strncmp (IDENTIFIER_POINTER (DECL_NAME (tmp)), "_vptr.", 6))
*************** print_ada_struct_decl (pretty_printer *b
*** 2143,2147 ****
      }
  
    print_ada_methods (buffer, node, cpp_check, spc);
- }
  
--- 2155,2175 ----
      }
  
    print_ada_methods (buffer, node, cpp_check, spc);
  
+   /* Print the static fields of the structure, if any.  */
+   need_semicolon = TYPE_METHODS (node) == NULL_TREE;
+   for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))
+     {
+       if (DECL_NAME (tmp) && TREE_STATIC (tmp))
+ 	{
+ 	  if (need_semicolon)
+ 	    {
+ 	      need_semicolon = false;
+ 	      pp_semicolon (buffer);
+ 	    }
+ 	  pp_newline (buffer);
+ 	  pp_newline (buffer);
+ 	  print_ada_declaration (buffer, tmp, type, cpp_check, spc);
+ 	}
+     }
+ }
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** print_ada_struct_decl (pretty_printer *b
*** 2075,2081 ****
  		   && !TREE_STATIC (tmp))
  	    {
  	      /* skip internal virtual table field */
! 	      if (strncmp (IDENTIFIER_POINTER (DECL_NAME (tmp)), "_vptr.", 6))
  	        {
  	          if (is_union)
  	            {
--- 2075,2081 ----
  		   && !TREE_STATIC (tmp))
  	    {
  	      /* skip internal virtual table field */
! 	      if (strncmp (IDENTIFIER_POINTER (DECL_NAME (tmp)), "_vptr", 5))
  	        {
  	          if (is_union)
  	            {
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** pp_ada_tree_identifier (pretty_printer *
*** 481,487 ****
  
    if (j > 0)
      s [len2++] = '_';
!   else if (*name == '.')
      {
        s [0] = 'a';
        s [1] = 'n';
--- 481,487 ----
  
    if (j > 0)
      s [len2++] = '_';
!   else if (*name == '.' || *name == '$')
      {
        s [0] = 'a';
        s [1] = 'n';
*************** print_ada_declaration (pretty_printer *b
*** 1629,1636 ****
        if (!orig
  	  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE
  	  && decl_name
! 	  && *IDENTIFIER_POINTER (decl_name) == '.')
!         /* skip anonymous enum types (duplicates of real types */
          return 0;
  
        INDENT (spc);
--- 1629,1637 ----
        if (!orig
  	  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE
  	  && decl_name
! 	  && (*IDENTIFIER_POINTER (decl_name) == '.'
! 	      || *IDENTIFIER_POINTER (decl_name) == '$'))
!         /* skip anonymous enum types (duplicates of real types) */
          return 0;
  
        INDENT (spc);
*************** print_ada_declaration (pretty_printer *b
*** 1649,1655 ****
  		return 1;
  	      }
  
! 	    if (decl_name && *IDENTIFIER_POINTER (decl_name) == '.')
  	      {
  		pp_string (buffer, "--  skipped anonymous struct ");
  		dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
--- 1650,1658 ----
  		return 1;
  	      }
  
! 	    if (decl_name
! 		&& (*IDENTIFIER_POINTER (decl_name) == '.'
! 		    || *IDENTIFIER_POINTER (decl_name) == '$'))
  	      {
  		pp_string (buffer, "--  skipped anonymous struct ");
  		dump_generic_ada_node (buffer, t, type, 0, spc, false, true);
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** static void
*** 668,682 ****
  dump_ada_import (pretty_printer *buffer, tree t)
  {
    const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));
  
!   if (name [0] == '_' && name [1] == 'Z')
      pp_string (buffer, "pragma Import (CPP, ");
    else
      pp_string (buffer, "pragma Import (C, ");
  
    dump_ada_decl_name (buffer, t, false);
    pp_string (buffer, ", \"");
!   pp_asm_name (buffer, t);
    pp_string (buffer, "\");");
  }
  
--- 668,691 ----
  dump_ada_import (pretty_printer *buffer, tree t)
  {
    const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));
+   int is_stdcall = TREE_CODE (t) == FUNCTION_DECL &&
+     lookup_attribute ("stdcall", TYPE_ATTRIBUTES (TREE_TYPE (t)));
  
!   if (is_stdcall)
!     pp_string (buffer, "pragma Import (Stdcall, ");
!   else if (name [0] == '_' && name [1] == 'Z')
      pp_string (buffer, "pragma Import (CPP, ");
    else
      pp_string (buffer, "pragma Import (C, ");
  
    dump_ada_decl_name (buffer, t, false);
    pp_string (buffer, ", \"");
! 
!   if (is_stdcall)
!     pp_string (buffer, IDENTIFIER_POINTER (DECL_NAME (t)));
!   else
!     pp_asm_name (buffer, t);
! 
    pp_string (buffer, "\");");
  }
  
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** print_ada_declaration (pretty_printer *b
*** 1962,1980 ****
  
        if (TREE_CODE (t) == TYPE_DECL)
  	{
!           tree orig;
  
! 	  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
! 	      || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)
  	    pp_string (buffer, " (discr : unsigned := 0)");
  
  	  pp_string (buffer, " is ");
  
-           orig = DECL_ORIGINAL_TYPE (t);
  	  dump_generic_ada_node
! 	    (buffer, orig, t, cpp_check, spc, false,
! 	     orig && TYPE_NAME (orig) && orig != TREE_TYPE (t));
! 
  	}
        else
  	{
--- 1962,1979 ----
  
        if (TREE_CODE (t) == TYPE_DECL)
  	{
!           tree orig = DECL_ORIGINAL_TYPE (t);
! 	  int is_subtype = orig && TYPE_NAME (orig) && orig != TREE_TYPE (t);
  
! 	  if (!is_subtype
! 	      && (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE
! 		  || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE))
  	    pp_string (buffer, " (discr : unsigned := 0)");
  
  	  pp_string (buffer, " is ");
  
  	  dump_generic_ada_node
! 	    (buffer, orig, t, cpp_check, spc, false, is_subtype);
  	}
        else
  	{
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** dump_generic_ada_node (pretty_printer *b
*** 1313,1318 ****
--- 1313,1326 ----
        if (DECL_IS_BUILTIN (node))
  	{
  	  /* Don't print the declaration of built-in types.  */
+ 
+           if (name_only)
+             {
+               /* If we're in the middle of a declaration, defaults to
+ 	         System.Address.  */
+ 	      append_withs ("System", false);
+ 	      pp_string (buffer, "System.Address");
+             }
  	  break;
  	}
  
*** gcc/config/sparc/leon.h.old	Fri Jan  9 16:47:14 2009
--- gcc/config/sparc/leon.h	Fri Jan  9 16:48:41 2009
***************
*** 1,6 ****
  /* Definitions for a LEON machine running in a bare board
     configuration using the ELF object format.
!    Copyright (C) 2004-2006 Free Software Foundation, Inc.
  
  This file is part of GNU CC.
  
--- 1,6 ----
  /* Definitions for a LEON machine running in a bare board
     configuration using the ELF object format.
!    Copyright (C) 2004-2009 Free Software Foundation, Inc.
  
  This file is part of GNU CC.
  
*************** Boston, MA 02110-1301, USA.  */
*** 22,28 ****
  /* Use the required linker script file (if none has been specified) */
  
  #undef LINK_SPEC
! #define LINK_SPEC "%{!T:%{micsdm:-T leon2_icsdm.ld%s} %{!micsdm:-T leon.ld%s}}"
  
  /* Make the BSP and the C library available */
  
--- 22,28 ----
  /* Use the required linker script file (if none has been specified) */
  
  #undef LINK_SPEC
! #define LINK_SPEC "%{!T:%{micm:-T leon2_icm.ld%s} %{!micm:-T leon.ld%s}}"
  
  /* Make the BSP and the C library available */
  
*************** Boston, MA 02110-1301, USA.  */
*** 34,40 ****
     crtbegin/crtend and crti/crtn machinery. */
  
  #undef STARTFILE_SPEC
! #define STARTFILE_SPEC "%{micsdm:crt0_icsdm.o%s} %{!micsdm:crt0.o%s}"
  
  #undef ENDFILE_SPEC
  #define ENDFILE_SPEC ""
--- 34,40 ----
     crtbegin/crtend and crti/crtn machinery. */
  
  #undef STARTFILE_SPEC
! #define STARTFILE_SPEC "%{micm:crt0_icm.o%s} %{!micm:crt0.o%s}"
  
  #undef ENDFILE_SPEC
  #define ENDFILE_SPEC ""
*** gcc/config/sparc/sparc.c.ori	Fri Jan  9 17:18:26 2009
--- gcc/config/sparc/sparc.c	Mon Jan 12 16:18:52 2009
*************** sparc_can_use_return_insn_p (void)
*** 4401,4411 ****
  static void
  sparc_asm_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
  {
!   /* If code does not drop into the epilogue, we have to still output
!      a dummy nop for the sake of sane backtraces.  Otherwise, if the
!      last two instructions of a function were "call foo; dslot;" this
!      can make the return PC of foo (i.e. address of call instruction
!      plus 8) point to the first instruction in the next function.  */
  
    rtx insn, last_real_insn;
  
--- 4401,4411 ----
  static void
  sparc_asm_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
  {
!   /* If the last two instructions of a function are "call foo; dslot;"
!      the return address might point to the first instruction in the next
!      function and we have to output a dummy nop for the sake of sane
!      backtraces in such cases.  This is pointless for sibling calls since
!      the return address is explicitely adjusted.  */
  
    rtx insn, last_real_insn;
  
*************** sparc_asm_function_epilogue (FILE *file,
*** 4417,4423 ****
        && GET_CODE (PATTERN (last_real_insn)) == SEQUENCE)
      last_real_insn = XVECEXP (PATTERN (last_real_insn), 0, 0);
  
!   if (last_real_insn && GET_CODE (last_real_insn) == CALL_INSN)
      fputs("\tnop\n", file);
  
    sparc_output_deferred_case_vectors ();
--- 4417,4424 ----
        && GET_CODE (PATTERN (last_real_insn)) == SEQUENCE)
      last_real_insn = XVECEXP (PATTERN (last_real_insn), 0, 0);
  
!   if (last_real_insn && GET_CODE (last_real_insn) == CALL_INSN
!       && !SIBLING_CALL_P (last_real_insn))
      fputs("\tnop\n", file);
  
    sparc_output_deferred_case_vectors ();
*** gcc/c-macros.c.old
--- gcc/c-macros.c
*************** print_ada_macros (pretty_printer *pp, cp
*** 125,131 ****
  	              memmove (prev + 3, prev + 2, buffer - prev - 2);
  	              prev [2] = '#';
  
! 		      if (*buffer != 'L' && *buffer != 'U')
  	                buffer++;
  	              *buffer++ = '#';
  	              break;
--- 125,131 ----
  	              memmove (prev + 3, prev + 2, buffer - prev - 2);
  	              prev [2] = '#';
  
! 		      if (*buffer != 'L' && *buffer != 'l' && *buffer != 'U')
  	                buffer++;
  	              *buffer++ = '#';
  	              break;
*************** print_ada_macros (pretty_printer *pp, cp
*** 134,140 ****
  
  	        case '1': case '2': case '3': case '4': case '5':
  	        case '6': case '7': case '8': case '9':
! 		  if (buffer [-1] == 'L' || buffer [-1] == 'l')
  		    buffer--;
  		  break;
  
--- 134,142 ----
  
  	        case '1': case '2': case '3': case '4': case '5':
  	        case '6': case '7': case '8': case '9':
! 		  if (buffer [-1] == 'L'
! 		      || buffer [-1] == 'l'
! 		      || buffer [-1] == 'U')
  		    buffer--;
  		  break;
  
*** gcc/dwarf2out.c.0	2009-01-16 14:34:38.000000000 +0100
--- gcc/dwarf2out.c	2009-01-16 14:42:25.000000000 +0100
*************** limbo_die_node;
*** 4110,4126 ****
  /* Define a macro which returns nonzero for a TYPE_DECL which was
     implicitly generated for a tagged type.
  
!    Note that unlike the gcc front end (which generates a NULL named
     TYPE_DECL node for each complete tagged type, each array type, and
!    each function type node created) the g++ front end generates a
     _named_ TYPE_DECL node for each tagged type node created.
     These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to
!    generate a DW_TAG_typedef DIE for them.  */
  
  #define TYPE_DECL_IS_STUB(decl)				\
    (DECL_NAME (decl) == NULL_TREE			\
     || (DECL_ARTIFICIAL (decl)				\
!        && is_tagged_type (TREE_TYPE (decl))		\
         && ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))	\
  	   /* This is necessary for stub decls that	\
  	      appear in nested inline functions.  */	\
--- 4110,4127 ----
  /* Define a macro which returns nonzero for a TYPE_DECL which was
     implicitly generated for a tagged type.
  
!    Note that unlike the C front end (which generates a NULL named
     TYPE_DECL node for each complete tagged type, each array type, and
!    each function type node created) the C++ front end generates a
     _named_ TYPE_DECL node for each tagged type node created.
     These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to
!    generate a DW_TAG_typedef DIE for them.  Likewise with the Ada
!    front-end but for each type, tagged or not.  */
  
  #define TYPE_DECL_IS_STUB(decl)				\
    (DECL_NAME (decl) == NULL_TREE			\
     || (DECL_ARTIFICIAL (decl)				\
!        && (is_tagged_type (TREE_TYPE (decl)) || is_ada ())\
         && ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))	\
  	   /* This is necessary for stub decls that	\
  	      appear in nested inline functions.  */	\
*** gcc/tree-sra.c.0	2009-01-22 10:36:50.000000000 +0100
--- gcc/tree-sra.c	2009-01-22 13:43:59.000000000 +0100
*************** decide_block_copy (struct sra_elt *elt)
*** 1937,1957 ****
  	  full_count = count_type_elements (elt->type, false);
  	  inst_count = sum_instantiated_sizes (elt, &inst_size);
  
- 	  /* If there is only one scalar field in the record, don't block copy.  */
- 	  if (single_scalar_field_in_record_p (elt->type))
- 	    use_block_copy = false;
- 
  	  /* ??? What to do here.  If there are two fields, and we've only
  	     instantiated one, then instantiating the other is clearly a win.
  	     If there are a large number of fields then the size of the copy
  	     is much more of a factor.  */
  
  	  /* If the structure is small, and we've made copies, go ahead
  	     and instantiate, hoping that the copies will go away.  */
! 	  if (full_size <= max_size
! 	      && (full_count - inst_count) <= max_count
! 	      && elt->n_copies > elt->n_uses)
  	    use_block_copy = false;
  	  else if (inst_count * 100 >= full_count * SRA_FIELD_STRUCTURE_RATIO
  		   && inst_size * 100 >= full_size * SRA_FIELD_STRUCTURE_RATIO)
  	    use_block_copy = false;
--- 1937,1963 ----
  	  full_count = count_type_elements (elt->type, false);
  	  inst_count = sum_instantiated_sizes (elt, &inst_size);
  
  	  /* ??? What to do here.  If there are two fields, and we've only
  	     instantiated one, then instantiating the other is clearly a win.
  	     If there are a large number of fields then the size of the copy
  	     is much more of a factor.  */
  
+ 	  /* If this is a small type, avoid replacing simple word moves
+ 	     with subword accesses.  */
+ 	  if (full_size <= UNITS_PER_WORD && inst_count == 0)
+ 	    use_block_copy = true;
+ 
+ 	  /* If there is only one scalar field, don't use block copy.  */
+ 	  else if (single_scalar_field_in_record_p (elt->type))
+ 	    use_block_copy = false;
+ 
  	  /* If the structure is small, and we've made copies, go ahead
  	     and instantiate, hoping that the copies will go away.  */
! 	  else if (full_size <= max_size
! 		   && (full_count - inst_count) <= max_count
! 		   && elt->n_copies > elt->n_uses)
  	    use_block_copy = false;
+ 
  	  else if (inst_count * 100 >= full_count * SRA_FIELD_STRUCTURE_RATIO
  		   && inst_size * 100 >= full_size * SRA_FIELD_STRUCTURE_RATIO)
  	    use_block_copy = false;
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** check_name (pretty_printer *buffer, tree
*** 720,726 ****
  
  static int
  dump_ada_function_declaration (pretty_printer *buffer, tree func, tree type,
! 			       int is_method, int is_constructor, int spc)
  {
    tree arg;
    tree node = TREE_TYPE (func);
--- 720,727 ----
  
  static int
  dump_ada_function_declaration (pretty_printer *buffer, tree func, tree type,
! 			       int is_method, int is_constructor,
! 			       int is_destructor, int spc)
  {
    tree arg;
    tree node = TREE_TYPE (func);
*************** dump_ada_function_declaration (pretty_pr
*** 748,753 ****
--- 749,757 ----
    if (is_constructor)
      num_args--;
  
+   if (is_destructor)
+     num_args = 1;
+ 
    if (num_args > 2)
      newline_and_indent (buffer, spc + 1);
  
*************** dump_ada_function_declaration (pretty_pr
*** 776,785 ****
  
    /* Print the argument names (if available) & types. */
  
!   while (arg && arg != error_mark_node)
      {
-       num++;
- 
        if (have_args)
  	{
  	  if (DECL_NAME (arg))
--- 780,787 ----
  
    /* Print the argument names (if available) & types. */
  
!   for (num = 1; num <= num_args; num++)
      {
        if (have_args)
  	{
  	  if (DECL_NAME (arg))
*************** dump_ada_function_declaration (pretty_pr
*** 810,825 ****
  
        arg = TREE_CHAIN (arg);
  
!       if (arg == NULL_TREE ||
! 	  (!have_args && TREE_CODE (TREE_VALUE (arg)) == VOID_TYPE))
!         break;
! 
!       pp_character (buffer, ';');
  
!       if (num_args > 2)
! 	newline_and_indent (buffer, spc + 3);
!       else
! 	pp_space (buffer);
      }
  
    if (have_ellipsis)
--- 812,826 ----
  
        arg = TREE_CHAIN (arg);
  
!       if (num < num_args)
! 	{
! 	  pp_character (buffer, ';');
  
! 	  if (num_args > 2)
! 	    newline_and_indent (buffer, spc + 3);
! 	  else
! 	    pp_space (buffer);
! 	}
      }
  
    if (have_ellipsis)
*************** dump_ada_array_type (pretty_printer *buf
*** 922,927 ****
--- 923,999 ----
      (buffer, TREE_TYPE (tmp), TREE_TYPE (t), NULL, spc, false, true);
  }
  
+ /* Dump type names associated with a template, each prepended with '_'.
+    types is the TREE_PURPOSE of a DECL_TEMPLATE_INSTANTIATIONS.  */
+ 
+ static void
+ dump_template_types (pretty_printer *buffer, tree types,
+ 		     int (*cpp_check)(tree, int), int spc)
+ {
+   size_t i;
+   size_t len = TREE_VEC_LENGTH (types);
+ 
+   for (i = 0; i < len; i++)
+     { 
+       pp_character (buffer, '_');
+       dump_generic_ada_node
+ 	(buffer, TREE_VEC_ELT (types, i), 0, cpp_check,
+ 	 spc, false, true);
+     }
+ }
+ 
+ /* Dump contents of all instantiations associated with a given template.  */
+ 
+ static int
+ dump_ada_template (pretty_printer *buffer, tree t,
+ 		   int (*cpp_check)(tree, int), int spc)
+ {
+   tree instantiations = DECL_VINDEX (t);
+   /* DECL_VINDEX is DECL_TEMPLATE_INSTANTIATIONS in this context */
+   int num_inst = 0;
+ 
+   while (instantiations && instantiations != error_mark_node)
+     {
+       tree types = TREE_PURPOSE (instantiations);
+       tree instance = TREE_VALUE (instantiations);
+ 
+       if (TREE_VEC_LENGTH (types) == 0)
+ 	break;
+ 
+       num_inst++;
+ 
+       INDENT (spc);
+       pp_string (buffer, "package ");
+       dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);
+       dump_template_types (buffer, types, cpp_check, spc);
+       pp_string (buffer, " is");
+       spc += 3;
+       newline_and_indent (buffer, spc);
+ 
+       pp_string (buffer, "type ");
+       dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);
+ 
+       pp_string (buffer, " is tagged limited ");
+       dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, false);
+       pp_newline (buffer);
+       spc -= 3;
+       newline_and_indent (buffer, spc);
+ 
+       pp_string (buffer, "end;");
+       newline_and_indent (buffer, spc);
+       pp_string (buffer, "use ");
+       dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);
+       dump_template_types (buffer, types, cpp_check, spc);
+       pp_semicolon (buffer);
+       pp_newline (buffer);
+       pp_newline (buffer);
+ 
+       instantiations = TREE_CHAIN (instantiations);
+     }
+ 
+   return num_inst > 0;
+ }
+ 
  static bool in_function = true;
  static bool bitfield_used = false;
  
*************** dump_generic_ada_node (pretty_printer *b
*** 948,972 ****
        break;
  
      case TREE_LIST:
!       while (node && node != error_mark_node)
! 	{
! 	  if (TREE_PURPOSE (node))
! 	    {
! 	      dump_generic_ada_node
! 		(buffer, TREE_PURPOSE (node), type, cpp_check, spc,
! 		 limited_access, name_only);
! 	      pp_space (buffer);
! 	    }
! 	  dump_generic_ada_node
! 	    (buffer, TREE_VALUE (node), type, cpp_check,
! 	     spc, limited_access, name_only);
! 	  node = TREE_CHAIN (node);
! 	  if (node && TREE_CODE (node) == TREE_LIST)
! 	    {
! 	      pp_character (buffer, ',');
! 	      pp_space (buffer);
! 	    }
! 	}
        break;
  
      case TREE_BINFO:
--- 1020,1026 ----
        break;
  
      case TREE_LIST:
!       pp_string (buffer, "--- unexpected node: TREE_LIST");
        break;
  
      case TREE_BINFO:
*************** dump_generic_ada_node (pretty_printer *b
*** 975,998 ****
  	 spc, limited_access, name_only);
  
      case TREE_VEC:
!       {
! 	size_t i;
! 	if (TREE_VEC_LENGTH (node) > 0)
! 	  {
! 	    size_t len = TREE_VEC_LENGTH (node);
! 	    for (i = 0; i < len - 1; i++)
! 	      {
! 		dump_generic_ada_node
! 		  (buffer, TREE_VEC_ELT (node, i), type, cpp_check,
! 		   spc, limited_access, name_only);
! 		pp_character (buffer, ',');
! 		pp_space (buffer);
! 	      }
! 	    dump_generic_ada_node
! 	      (buffer, TREE_VEC_ELT (node, len - 1), type, cpp_check,
! 	       spc, limited_access, name_only);
! 	  }
!       }
        break;
  
      case VOID_TYPE:
--- 1029,1035 ----
  	 spc, limited_access, name_only);
  
      case TREE_VEC:
!       pp_string (buffer, "--- unexpected node: TREE_VEC");
        break;
  
      case VOID_TYPE:
*************** dump_generic_ada_node (pretty_printer *b
*** 1114,1120 ****
  
            in_function = is_function;
            dump_ada_function_declaration
! 	    (buffer, node, type, false, false, spc + 2);
            in_function = prev_in_function;
  
            if (is_function)
--- 1151,1157 ----
  
            in_function = is_function;
            dump_ada_function_declaration
! 	    (buffer, node, type, false, false, false, spc + 2);
            in_function = prev_in_function;
  
            if (is_function)
*************** dump_generic_ada_node (pretty_printer *b
*** 1384,1389 ****
--- 1421,1427 ----
  #define IS_ABSTRACT 0
  #define IS_CONSTRUCTOR 1
  #define IS_DESTRUCTOR 2
+ #define IS_TEMPLATE 3
  
  static void
  print_ada_methods (pretty_printer *buffer, const_tree node,
*************** dump_nested_types (pretty_printer *buffe
*** 1562,1571 ****
  static void
  print_destructor (pretty_printer *buffer, tree t)
  {
!   const char *s = IDENTIFIER_POINTER (DECL_NAME (t)) + 2;
  
!   for (; *s != ' '; s++)
!     pp_character (buffer, *s);
  }
  
  /* Return the name of type t */
--- 1600,1615 ----
  static void
  print_destructor (pretty_printer *buffer, tree t)
  {
!   const char *s = IDENTIFIER_POINTER (DECL_NAME (t));
  
!   if (*s == '_')
!     for (s += 2; *s != ' '; s++)
!       pp_character (buffer, *s);
!   else
!     {
!       pp_string (buffer, "Delete_");
!       pp_ada_tree_identifier (buffer, DECL_NAME (t), t, false);
!     }
  }
  
  /* Return the name of type t */
*************** print_ada_declaration (pretty_printer *b
*** 1596,1601 ****
--- 1640,1648 ----
    bool dump_internal = get_dump_file_info (TDI_ada)->flags & TDF_RAW;
    tree orig = NULL_TREE;
  
+   if (cpp_check && cpp_check (t, IS_TEMPLATE))
+     return dump_ada_template (buffer, t, cpp_check, spc);
+ 
    if (TREE_CODE (t) == CONST_DECL && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)
      /* Skip enumeral values: will be handled as part of the type itself */
      return 0;
*************** print_ada_declaration (pretty_printer *b
*** 1792,1800 ****
        if (!decl_name)
  	return 0;
  
!       if (is_destructor && *IDENTIFIER_POINTER (decl_name) != '_')
! 	/* Skip pseudo destructor which is redundant with __comp_dtor and
! 	   __deleting_dtor */
  	return 0;
  
        /* If this function has an entry in the dispatch table, we cannot
--- 1839,1848 ----
        if (!decl_name)
  	return 0;
  
!       /* Skip __comp_dtor destructor which is redundant with the '~class()'
! 	 destructor */
!       if (is_destructor
! 	  && !strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6))
  	return 0;
  
        /* If this function has an entry in the dispatch table, we cannot
*************** print_ada_declaration (pretty_printer *b
*** 1833,1839 ****
          dump_ada_decl_name (buffer, t, false);
  
        dump_ada_function_declaration
! 	(buffer, t, type, is_method, is_constructor, spc);
        in_function = prev_in_function;
  
        if (is_function)
--- 1881,1887 ----
          dump_ada_decl_name (buffer, t, false);
  
        dump_ada_function_declaration
! 	(buffer, t, type, is_method, is_constructor, is_destructor, spc);
        in_function = prev_in_function;
  
        if (is_function)
*** gcc/cp/decl2.c.old
--- gcc/cp/decl2.c
*************** build_java_method_aliases (void)
*** 3284,3289 ****
--- 3284,3290 ----
  #define IS_PURE_VIRTUAL 0
  #define IS_CONSTRUCTOR 1
  #define IS_DESTRUCTOR 2
+ #define IS_TEMPLATE 3
  
  static int
  cpp_check (tree t, int op)
*************** cpp_check (tree t, int op)
*** 3296,3301 ****
--- 3297,3304 ----
  	return DECL_CONSTRUCTOR_P (t);
        case IS_DESTRUCTOR:
  	return DECL_DESTRUCTOR_P (t);
+       case IS_TEMPLATE:
+ 	return TREE_CODE (t) == TEMPLATE_DECL;
        default:
          return 0;
      }
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** dump_generic_ada_node (pretty_printer *b
*** 1229,1235 ****
  		          pp_string (buffer, "access ");
  		          is_access = true;
  
! 			  if (!name_only)
  			    pp_string (buffer, "all ");
  		        }
  		      else if (quals & TYPE_QUAL_CONST)
--- 1229,1237 ----
  		          pp_string (buffer, "access ");
  		          is_access = true;
  
! 			  if (quals & TYPE_QUAL_CONST)
! 			    pp_string (buffer, "constant ");
! 			  else if (!name_only)
  			    pp_string (buffer, "all ");
  		        }
  		      else if (quals & TYPE_QUAL_CONST)
*** gcc/gimplify.c.0	2009-01-30 12:37:40.000000000 +0100
--- gcc/gimplify.c	2009-01-31 12:45:03.000000000 +0100
*************** gimplify_call_expr (tree *expr_p, tree *
*** 2381,2392 ****
     condition is true or false, respectively.  If null, we should generate
     our own to skip over the evaluation of this specific expression.
  
     This function is the tree equivalent of do_jump.
  
     shortcut_cond_r should only be called by shortcut_cond_expr.  */
  
  static tree
! shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p)
  {
    tree local_label = NULL_TREE;
    tree t, expr = NULL;
--- 2381,2395 ----
     condition is true or false, respectively.  If null, we should generate
     our own to skip over the evaluation of this specific expression.
  
+    LOCUS is the source location of the COND_EXPR.
+ 
     This function is the tree equivalent of do_jump.
  
     shortcut_cond_r should only be called by shortcut_cond_expr.  */
  
  static tree
! shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,
! 		 location_t locus)
  {
    tree local_label = NULL_TREE;
    tree t, expr = NULL;
*************** shortcut_cond_r (tree pred, tree *true_l
*** 2396,2401 ****
--- 2399,2406 ----
       shortcut_cond_expr will append the real blocks later.  */
    if (TREE_CODE (pred) == TRUTH_ANDIF_EXPR)
      {
+       location_t new_locus;
+ 
        /* Turn if (a && b) into
  
  	 if (a); else goto no;
*************** shortcut_cond_r (tree pred, tree *true_l
*** 2405,2419 ****
        if (false_label_p == NULL)
  	false_label_p = &local_label;
  
!       t = shortcut_cond_r (TREE_OPERAND (pred, 0), NULL, false_label_p);
        append_to_statement_list (t, &expr);
  
!       t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,
! 			   false_label_p);
        append_to_statement_list (t, &expr);
      }
    else if (TREE_CODE (pred) == TRUTH_ORIF_EXPR)
      {
        /* Turn if (a || b) into
  
  	 if (a) goto yes;
--- 2410,2429 ----
        if (false_label_p == NULL)
  	false_label_p = &local_label;
  
!       /* Keep the original source location on the first 'if'.  */
!       t = shortcut_cond_r (TREE_OPERAND (pred, 0), NULL, false_label_p, locus);
        append_to_statement_list (t, &expr);
  
!       /* Set the source location of the && on the second 'if'.  */
!       new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;
!       t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p, false_label_p,
! 			   new_locus);
        append_to_statement_list (t, &expr);
      }
    else if (TREE_CODE (pred) == TRUTH_ORIF_EXPR)
      {
+       location_t new_locus;
+ 
        /* Turn if (a || b) into
  
  	 if (a) goto yes;
*************** shortcut_cond_r (tree pred, tree *true_l
*** 2423,2453 ****
        if (true_label_p == NULL)
  	true_label_p = &local_label;
  
!       t = shortcut_cond_r (TREE_OPERAND (pred, 0), true_label_p, NULL);
        append_to_statement_list (t, &expr);
  
!       t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,
! 			   false_label_p);
        append_to_statement_list (t, &expr);
      }
    else if (TREE_CODE (pred) == COND_EXPR)
      {
        /* As long as we're messing with gotos, turn if (a ? b : c) into
  	 if (a)
  	   if (b) goto yes; else goto no;
  	 else
  	   if (c) goto yes; else goto no;  */
        expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (pred, 0),
  		     shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,
! 				      false_label_p),
  		     shortcut_cond_r (TREE_OPERAND (pred, 2), true_label_p,
! 				      false_label_p));
      }
    else
      {
        expr = build3 (COND_EXPR, void_type_node, pred,
  		     build_and_jump (true_label_p),
  		     build_and_jump (false_label_p));
      }
  
    if (local_label)
--- 2433,2473 ----
        if (true_label_p == NULL)
  	true_label_p = &local_label;
  
!       /* Keep the original source location on the first 'if'.  */
!       t = shortcut_cond_r (TREE_OPERAND (pred, 0), true_label_p, NULL, locus);
        append_to_statement_list (t, &expr);
  
!       /* Set the source location of the || on the second 'if'.  */
!       new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;
!       t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p, false_label_p,
! 			   new_locus);
        append_to_statement_list (t, &expr);
      }
    else if (TREE_CODE (pred) == COND_EXPR)
      {
+       location_t new_locus;
+ 
        /* As long as we're messing with gotos, turn if (a ? b : c) into
  	 if (a)
  	   if (b) goto yes; else goto no;
  	 else
  	   if (c) goto yes; else goto no;  */
+ 
+       /* Keep the original source location on the first 'if'.  Set the source
+ 	 location of the ? on the second 'if'.  */
+       new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;
        expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (pred, 0),
  		     shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,
! 				      false_label_p, locus),
  		     shortcut_cond_r (TREE_OPERAND (pred, 2), true_label_p,
! 				      false_label_p, new_locus));
      }
    else
      {
        expr = build3 (COND_EXPR, void_type_node, pred,
  		     build_and_jump (true_label_p),
  		     build_and_jump (false_label_p));
+       SET_EXPR_LOCATION (expr, locus);
      }
  
    if (local_label)
*************** shortcut_cond_expr (tree expr)
*** 2475,2488 ****
    /* First do simple transformations.  */
    if (!else_se)
      {
!       /* If there is no 'else', turn (a && b) into if (a) if (b).  */
        while (TREE_CODE (pred) == TRUTH_ANDIF_EXPR)
  	{
  	  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);
  	  then_ = shortcut_cond_expr (expr);
  	  then_se = then_ && TREE_SIDE_EFFECTS (then_);
  	  pred = TREE_OPERAND (pred, 0);
  	  expr = build3 (COND_EXPR, void_type_node, pred, then_, NULL_TREE);
  	}
      }
    if (!then_se)
--- 2495,2518 ----
    /* First do simple transformations.  */
    if (!else_se)
      {
!       /* If there is no 'else', turn
! 	   if (a && b) then c
! 	 into
! 	   if (a) if (b) then c.  */
        while (TREE_CODE (pred) == TRUTH_ANDIF_EXPR)
  	{
+ 	  /* Keep the original source location on the first 'if'.  */
+ 	  location_t locus = EXPR_HAS_LOCATION (expr)
+ 			     ? EXPR_LOCATION (expr) : input_location;
  	  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);
+ 	  /* Set the source location of the && on the second 'if'.  */
+ 	  if (EXPR_HAS_LOCATION (pred))
+ 	    SET_EXPR_LOCATION (expr, EXPR_LOCATION (pred));
  	  then_ = shortcut_cond_expr (expr);
  	  then_se = then_ && TREE_SIDE_EFFECTS (then_);
  	  pred = TREE_OPERAND (pred, 0);
  	  expr = build3 (COND_EXPR, void_type_node, pred, then_, NULL_TREE);
+ 	  SET_EXPR_LOCATION (expr, locus);
  	}
      }
    if (!then_se)
*************** shortcut_cond_expr (tree expr)
*** 2493,2503 ****
--- 2523,2540 ----
  	   if (a); else if (b); else d.  */
        while (TREE_CODE (pred) == TRUTH_ORIF_EXPR)
  	{
+ 	  /* Keep the original source location on the first 'if'.  */
+ 	  location_t locus = EXPR_HAS_LOCATION (expr)
+ 			     ? EXPR_LOCATION (expr) : input_location;
  	  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);
+ 	  /* Set the source location of the || on the second 'if'.  */
+ 	  if (EXPR_HAS_LOCATION (pred))
+ 	    SET_EXPR_LOCATION (expr, EXPR_LOCATION (pred));
  	  else_ = shortcut_cond_expr (expr);
  	  else_se = else_ && TREE_SIDE_EFFECTS (else_);
  	  pred = TREE_OPERAND (pred, 0);
  	  expr = build3 (COND_EXPR, void_type_node, pred, NULL_TREE, else_);
+ 	  SET_EXPR_LOCATION (expr, locus);
  	}
      }
  
*************** shortcut_cond_expr (tree expr)
*** 2551,2567 ****
  
    /* If there was nothing else in our arms, just forward the label(s).  */
    if (!then_se && !else_se)
!     return shortcut_cond_r (pred, true_label_p, false_label_p);
  
    /* If our last subexpression already has a terminal label, reuse it.  */
    if (else_se)
!     expr = expr_last (else_);
    else if (then_se)
!     expr = expr_last (then_);
    else
!     expr = NULL;
!   if (expr && TREE_CODE (expr) == LABEL_EXPR)
!     end_label = LABEL_EXPR_LABEL (expr);
  
    /* If we don't care about jumping to the 'else' branch, jump to the end
       if the condition is false.  */
--- 2588,2606 ----
  
    /* If there was nothing else in our arms, just forward the label(s).  */
    if (!then_se && !else_se)
!     return shortcut_cond_r (pred, true_label_p, false_label_p,
! 			    EXPR_HAS_LOCATION (expr)
! 			    ? EXPR_LOCATION (expr) : input_location);
  
    /* If our last subexpression already has a terminal label, reuse it.  */
    if (else_se)
!     t = expr_last (else_);
    else if (then_se)
!     t = expr_last (then_);
    else
!     t = NULL;
!   if (t && TREE_CODE (t) == LABEL_EXPR)
!     end_label = LABEL_EXPR_LABEL (t);
  
    /* If we don't care about jumping to the 'else' branch, jump to the end
       if the condition is false.  */
*************** shortcut_cond_expr (tree expr)
*** 2582,2588 ****
       non-void function.  */
    jump_over_else = block_may_fallthru (then_);
  
!   pred = shortcut_cond_r (pred, true_label_p, false_label_p);
  
    expr = NULL;
    append_to_statement_list (pred, &expr);
--- 2621,2629 ----
       non-void function.  */
    jump_over_else = block_may_fallthru (then_);
  
!   pred = shortcut_cond_r (pred, true_label_p, false_label_p,
! 			  EXPR_HAS_LOCATION (expr)
! 			  ? EXPR_LOCATION (expr) : input_location);
  
    expr = NULL;
    append_to_statement_list (pred, &expr);
*************** shortcut_cond_expr (tree expr)
*** 2592,2598 ****
--- 2633,2642 ----
      {
        if (jump_over_else)
  	{
+ 	  tree last = expr_last (expr);
  	  t = build_and_jump (&end_label);
+ 	  if (EXPR_HAS_LOCATION (last))
+ 	    SET_EXPR_LOCATION (t, EXPR_LOCATION (last));
  	  append_to_statement_list (t, &expr);
  	}
        if (emit_false)
*************** gimplify_scalar_mode_aggregate_compare (
*** 4142,4154 ****
  
  	a && b ? true : false
  
!     gimplify_cond_expr will do the rest.
! 
!     PRE_P points to the list where side effects that must happen before
! 	*EXPR_P should be stored.  */
  
  static enum gimplify_status
! gimplify_boolean_expr (tree *expr_p)
  {
    /* Preserve the original type of the expression.  */
    tree type = TREE_TYPE (*expr_p);
--- 4186,4196 ----
  
  	a && b ? true : false
  
!     LOCUS is the source location to be put on the generated COND_EXPR.
!     gimplify_cond_expr will do the rest.  */
  
  static enum gimplify_status
! gimplify_boolean_expr (tree *expr_p, location_t locus)
  {
    /* Preserve the original type of the expression.  */
    tree type = TREE_TYPE (*expr_p);
*************** gimplify_boolean_expr (tree *expr_p)
*** 4157,4162 ****
--- 4199,4206 ----
  		    fold_convert (type, boolean_true_node),
  		    fold_convert (type, boolean_false_node));
  
+   SET_EXPR_LOCATION (*expr_p, locus);
+ 
    return GS_OK;
  }
  
*************** gimplify_expr (tree *expr_p, tree *pre_p
*** 5841,5847 ****
  
  	case TRUTH_ANDIF_EXPR:
  	case TRUTH_ORIF_EXPR:
! 	  ret = gimplify_boolean_expr (expr_p);
  	  break;
  
  	case TRUTH_NOT_EXPR:
--- 5885,5892 ----
  
  	case TRUTH_ANDIF_EXPR:
  	case TRUTH_ORIF_EXPR:
! 	  /* Pass the source location of the outer expression.  */
! 	  ret = gimplify_boolean_expr (expr_p, saved_location);
  	  break;
  
  	case TRUTH_NOT_EXPR:
*** gcc/rtl.h.0	2009-01-30 10:39:07.000000000 +0100
--- gcc/rtl.h	2009-01-29 18:53:00.000000000 +0100
*************** extern int insn_line (const_rtx);
*** 1623,1628 ****
--- 1623,1629 ----
  extern const char * insn_file (const_rtx);
  extern int locator_line (int);
  extern const char * locator_file (int);
+ extern expanded_location insn_location (const_rtx);
  extern bool non_final_source_line (const_rtx);
  extern bool locator_eq (int, int);
  extern int prologue_locator, epilogue_locator;
*** gcc/cfglayout.c.0	2009-01-30 10:29:01.000000000 +0100
--- gcc/cfglayout.c	2009-01-30 10:49:54.000000000 +0100
*************** locator_location (int loc)
*** 519,524 ****
--- 519,539 ----
    return *VEC_index (location_t, locations_locators_vals, min);
  }
  
+ /* Return expanded location of the statement that produced this insn.  */
+ expanded_location
+ insn_location (const_rtx insn)
+ {
+   const expanded_location null_location = { NULL, 0
+ #ifdef USE_MAPPED_LOCATION
+                                             , 0
+ #endif
+                                           };
+   int loc = INSN_LOCATOR (insn);
+   if (!loc)
+     return null_location;
+   return expand_location (locator_location (loc));
+ }
+ 
  /* Return source line of the statement that produced this insn.  */
  int
  locator_line (int loc)
*** gcc/debug.h.0	2009-01-30 11:40:58.000000000 +0100
--- gcc/debug.h	2009-01-30 12:26:03.000000000 +0100
*************** struct gcc_debug_hooks
*** 58,65 ****
       though the BLOCK information is messed up.  Defaults to true.  */
    bool (* ignore_block) (const_tree);
  
!   /* Record a source file location at (FILE, LINE).  */
!   void (* source_line) (unsigned int line, const char *file);
  
    /* Called at start of prologue code.  LINE is the first line in the
       function.  This has been given the same prototype as source_line,
--- 58,65 ----
       though the BLOCK information is messed up.  Defaults to true.  */
    bool (* ignore_block) (const_tree);
  
!   /* Record a source file location at (FILE, LINE, COL).  */
!   void (* source_loc) (unsigned int line, unsigned int col, const char *file);
  
    /* Called at start of prologue code.  LINE is the first line in the
       function.  This has been given the same prototype as source_line,
*************** extern const struct gcc_debug_hooks *deb
*** 135,140 ****
--- 135,142 ----
  extern void debug_nothing_void (void);
  extern void debug_nothing_charstar (const char *);
  extern void debug_nothing_int_charstar (unsigned int, const char *);
+ extern void debug_nothing_int_int_charstar (unsigned int, unsigned int,
+ 					    const char *);
  extern void debug_nothing_int (unsigned int);
  extern void debug_nothing_int_int (unsigned int, unsigned int);
  extern void debug_nothing_tree (tree);
*** gcc/debug.c.0	2009-01-30 12:05:17.000000000 +0100
--- gcc/debug.c	2009-01-30 12:24:23.000000000 +0100
*************** const struct gcc_debug_hooks do_nothing_
*** 33,39 ****
    debug_nothing_int_int,	         /* begin_block */
    debug_nothing_int_int,	         /* end_block */
    debug_true_const_tree,	         /* ignore_block */
!   debug_nothing_int_charstar,	         /* source_line */
    debug_nothing_int_charstar,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
    debug_nothing_int_charstar,	         /* end_epilogue */
--- 33,39 ----
    debug_nothing_int_int,	         /* begin_block */
    debug_nothing_int_int,	         /* end_block */
    debug_true_const_tree,	         /* ignore_block */
!   debug_nothing_int_int_charstar,	 /* source_loc */
    debug_nothing_int_charstar,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
    debug_nothing_int_charstar,	         /* end_epilogue */
*************** debug_nothing_int_charstar (unsigned int
*** 94,99 ****
--- 94,106 ----
  }
  
  void
+ debug_nothing_int_int_charstar (unsigned int line ATTRIBUTE_UNUSED,
+ 				unsigned int col ATTRIBUTE_UNUSED,
+ 				const char *text ATTRIBUTE_UNUSED)
+ {
+ }
+ 
+ void
  debug_nothing_int (unsigned int line ATTRIBUTE_UNUSED)
  {
  }
*** gcc/dbxout.c.0	2009-01-30 12:08:05.000000000 +0100
--- gcc/dbxout.c	2009-01-30 20:11:14.000000000 +0100
*************** static void dbxout_handle_pch (unsigned)
*** 352,358 ****
  /* The debug hooks structure.  */
  #if defined (DBX_DEBUGGING_INFO)
  
! static void dbxout_source_line (unsigned int, const char *);
  static void dbxout_begin_prologue (unsigned int, const char *);
  static void dbxout_end_epilogue (unsigned int, const char *);
  static void dbxout_source_file (const char *);
--- 352,358 ----
  /* The debug hooks structure.  */
  #if defined (DBX_DEBUGGING_INFO)
  
! static void dbxout_source_loc (unsigned int, unsigned int, const char *);
  static void dbxout_begin_prologue (unsigned int, const char *);
  static void dbxout_end_epilogue (unsigned int, const char *);
  static void dbxout_source_file (const char *);
*************** const struct gcc_debug_hooks dbx_debug_h
*** 373,379 ****
    dbxout_begin_block,
    dbxout_end_block,
    debug_true_const_tree,	         /* ignore_block */
!   dbxout_source_line,		         /* source_line */
    dbxout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
    dbxout_end_epilogue,		         /* end_epilogue */
--- 373,379 ----
    dbxout_begin_block,
    dbxout_end_block,
    debug_true_const_tree,	         /* ignore_block */
!   dbxout_source_loc,		         /* source_loc */
    dbxout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
    dbxout_end_epilogue,		         /* end_epilogue */
*************** const struct gcc_debug_hooks xcoff_debug
*** 409,415 ****
    xcoffout_begin_block,
    xcoffout_end_block,
    debug_true_const_tree,	         /* ignore_block */
!   xcoffout_source_line,
    xcoffout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
    xcoffout_end_epilogue,
--- 409,415 ----
    xcoffout_begin_block,
    xcoffout_end_block,
    debug_true_const_tree,	         /* ignore_block */
!   xcoffout_source_loc,
    xcoffout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
    xcoffout_end_epilogue,
*************** dbxout_begin_prologue (unsigned int line
*** 1272,1278 ****
    /* pre-increment the scope counter */
    scope_labelno++;
  
!   dbxout_source_line (lineno, filename);
    /* Output function begin block at function scope, referenced 
       by dbxout_block, dbxout_source_line and dbxout_function_end.  */
    emit_pending_bincls_if_required ();
--- 1272,1278 ----
    /* pre-increment the scope counter */
    scope_labelno++;
  
!   dbxout_source_loc (lineno, 0, filename);
    /* Output function begin block at function scope, referenced 
       by dbxout_block, dbxout_source_line and dbxout_function_end.  */
    emit_pending_bincls_if_required ();
*************** dbxout_end_epilogue (unsigned int lineno
*** 1305,1311 ****
     number LINENO.  */
  
  static void
! dbxout_source_line (unsigned int lineno, const char *filename)
  {
    dbxout_source_file (filename);
  
--- 1305,1312 ----
     number LINENO.  */
  
  static void
! dbxout_source_loc (unsigned int lineno, unsigned int col ATTRIBUTE_UNUSED,
! 		   const char *filename)
  {
    dbxout_source_file (filename);
  
*** gcc/dwarf2out.c.0	2009-01-30 12:08:14.000000000 +0100
--- gcc/dwarf2out.c	2009-01-30 18:39:44.000000000 +0100
*************** along with GCC; see the file COPYING3.  
*** 91,97 ****
  #include "input.h"
  
  #ifdef DWARF2_DEBUGGING_INFO
! static void dwarf2out_source_line (unsigned int, const char *);
  #endif
  
  #ifndef DWARF2_FRAME_INFO
--- 91,97 ----
  #include "input.h"
  
  #ifdef DWARF2_DEBUGGING_INFO
! static void dwarf2out_source_loc (unsigned int, unsigned int, const char *);
  #endif
  
  #ifndef DWARF2_FRAME_INFO
*************** dwarf2out_begin_prologue (unsigned int l
*** 2870,2876 ****
       prologue case, not the eh frame case.  */
  #ifdef DWARF2_DEBUGGING_INFO
    if (file)
!     dwarf2out_source_line (line, file);
  #endif
  }
  
--- 2870,2876 ----
       prologue case, not the eh frame case.  */
  #ifdef DWARF2_DEBUGGING_INFO
    if (file)
!     dwarf2out_source_loc (line, 0, file);
  #endif
  }
  
*************** const struct gcc_debug_hooks dwarf2_debu
*** 3955,3961 ****
    dwarf2out_begin_block,
    dwarf2out_end_block,
    dwarf2out_ignore_block,
!   dwarf2out_source_line,
    dwarf2out_begin_prologue,
    debug_nothing_int_charstar,	/* end_prologue */
    dwarf2out_end_epilogue,
--- 3955,3961 ----
    dwarf2out_begin_block,
    dwarf2out_end_block,
    dwarf2out_ignore_block,
!   dwarf2out_source_loc,
    dwarf2out_begin_prologue,
    debug_nothing_int_charstar,	/* end_prologue */
    dwarf2out_end_epilogue,
*************** typedef struct dw_line_info_struct GTY((
*** 4010,4015 ****
--- 4010,4016 ----
  {
    unsigned long dw_file_num;
    unsigned long dw_line_num;
+   unsigned long dw_col_num;
  }
  dw_line_info_entry;
  
*************** typedef struct dw_separate_line_info_str
*** 4019,4024 ****
--- 4020,4026 ----
  {
    unsigned long dw_file_num;
    unsigned long dw_line_num;
+   unsigned long dw_col_num;
    unsigned long function;
  }
  dw_separate_line_info_entry;
*************** print_dwarf_line_table (FILE *outfile)
*** 6233,6241 ****
    for (i = 1; i < line_info_table_in_use; i++)
      {
        line_info = &line_info_table[i];
!       fprintf (outfile, "%5d: %4ld %6ld\n", i,
  	       line_info->dw_file_num,
! 	       line_info->dw_line_num);
      }
  
    fprintf (outfile, "\n\n");
--- 6235,6244 ----
    for (i = 1; i < line_info_table_in_use; i++)
      {
        line_info = &line_info_table[i];
!       fprintf (outfile, "%5d: %4ld %6ld %3ld\n", i,
  	       line_info->dw_file_num,
! 	       line_info->dw_line_num,
! 	       line_info->dw_col_num);
      }
  
    fprintf (outfile, "\n\n");
*************** output_line_info (void)
*** 8368,8373 ****
--- 8371,8377 ----
    unsigned n_op_args;
    unsigned long lt_index;
    unsigned long current_line;
+   unsigned long current_col;
    long line_offset;
    long line_delta;
    unsigned long current_file;
*************** output_line_info (void)
*** 8441,8446 ****
--- 8445,8451 ----
       a series of state machine operations.  */
    current_file = 1;
    current_line = 1;
+   current_col = 0;
  
    if (cfun && in_cold_section_p)
      strcpy (prev_line_label, cfun->cold_section_label);
*************** output_line_info (void)
*** 8527,8532 ****
--- 8532,8546 ----
        else
  	/* We still need to start a new row, so output a copy insn.  */
  	dw2_asm_output_data (1, DW_LNS_copy, "DW_LNS_copy");
+ 
+       /* Emit debug info for the column number of the current line, if
+ 	 different from the previous line.  */
+       if (line_info->dw_col_num != current_col)
+ 	{
+ 	  current_col = line_info->dw_col_num;
+ 	  dw2_asm_output_data (1, DW_LNS_set_column, "DW_LNS_set_column");
+ 	  dw2_asm_output_data_uleb128 (current_col, NULL);
+ 	}
      }
  
    /* Emit debug info for the address of the end of the function.  */
*************** output_line_info (void)
*** 8551,8556 ****
--- 8565,8571 ----
    function = 0;
    current_file = 1;
    current_line = 1;
+   current_col = 0;
    for (lt_index = 0; lt_index < separate_line_info_table_in_use;)
      {
        dw_separate_line_info_ref line_info
*************** output_line_info (void)
*** 8629,8634 ****
--- 8644,8657 ----
        else
  	dw2_asm_output_data (1, DW_LNS_copy, "DW_LNS_copy");
  
+       /* Emit debug info for the column number of the current line, if
+ 	 different from the previous line.  */
+       if (line_info->dw_col_num != current_col)
+ 	{
+ 	  current_col = line_info->dw_col_num;
+ 	  dw2_asm_output_data (1, DW_LNS_set_column, "DW_LNS_set_column");
+ 	  dw2_asm_output_data_uleb128 (current_col, NULL);
+ 	}
  #if 0
      cont:
  #endif
*************** output_line_info (void)
*** 8641,8646 ****
--- 8664,8670 ----
  	{
  	  current_file = 1;
  	  current_line = 1;
+ 	  current_col = 0;
  
  	  /* Emit debug info for the address of the end of the function.  */
  	  ASM_GENERATE_INTERNAL_LABEL (line_label, FUNC_END_LABEL, function);
*************** dwarf2out_begin_function (tree fun)
*** 14762,14768 ****
     'line_info_table' for later output of the .debug_line section.  */
  
  static void
! dwarf2out_source_line (unsigned int line, const char *filename)
  {
    if (debug_info_level >= DINFO_LEVEL_NORMAL
        && line != 0)
--- 14786,14792 ----
     'line_info_table' for later output of the .debug_line section.  */
  
  static void
! dwarf2out_source_loc (unsigned int line, unsigned int col, const char *filename)
  {
    if (debug_info_level >= DINFO_LEVEL_NORMAL
        && line != 0)
*************** dwarf2out_source_line (unsigned int line
*** 14773,14785 ****
  
        /* If requested, emit something human-readable.  */
        if (flag_debug_asm)
! 	fprintf (asm_out_file, "\t%s %s:%d\n", ASM_COMMENT_START,
! 		 filename, line);
  
        if (DWARF2_ASM_LINE_DEBUG_INFO)
  	{
  	  /* Emit the .loc directive understood by GNU as.  */
! 	  fprintf (asm_out_file, "\t.loc %d %d 0\n", file_num, line);
  
  	  /* Indicate that line number info exists.  */
  	  line_info_table_in_use++;
--- 14797,14815 ----
  
        /* If requested, emit something human-readable.  */
        if (flag_debug_asm)
! 	{
! 	  if (col != 0)
! 	    fprintf (asm_out_file, "\t%s %s:%d:%d\n", ASM_COMMENT_START,
! 		     filename, line, col);
! 	  else
! 	    fprintf (asm_out_file, "\t%s %s:%d\n", ASM_COMMENT_START,
! 		     filename, line);
! 	}
  
        if (DWARF2_ASM_LINE_DEBUG_INFO)
  	{
  	  /* Emit the .loc directive understood by GNU as.  */
! 	  fprintf (asm_out_file, "\t.loc %d %d %d\n", file_num, line, col);
  
  	  /* Indicate that line number info exists.  */
  	  line_info_table_in_use++;
*************** dwarf2out_source_line (unsigned int line
*** 14812,14817 ****
--- 14842,14848 ----
  	    = &separate_line_info_table[separate_line_info_table_in_use++];
  	  line_info->dw_file_num = file_num;
  	  line_info->dw_line_num = line;
+ 	  line_info->dw_col_num = col;
  	  line_info->function = current_function_funcdef_no;
  	}
        else
*************** dwarf2out_source_line (unsigned int line
*** 14836,14841 ****
--- 14867,14873 ----
  	  /* Add the new entry at the end of the line_info_table.  */
  	  line_info = &line_info_table[line_info_table_in_use++];
  	  line_info->dw_file_num = file_num;
+ 	  line_info->dw_col_num = col;
  	  line_info->dw_line_num = line;
  	}
      }
*** gcc/sdbout.c.0	2009-01-30 12:08:18.000000000 +0100
--- gcc/sdbout.c	2009-01-30 20:26:15.000000000 +0100
*************** static void sdbout_start_source_file	(un
*** 116,122 ****
  static void sdbout_end_source_file	(unsigned int);
  static void sdbout_begin_block		(unsigned int, unsigned int);
  static void sdbout_end_block		(unsigned int, unsigned int);
! static void sdbout_source_line		(unsigned int, const char *);
  static void sdbout_end_epilogue		(unsigned int, const char *);
  static void sdbout_global_decl		(tree);
  #ifndef MIPS_DEBUGGING_INFO
--- 116,123 ----
  static void sdbout_end_source_file	(unsigned int);
  static void sdbout_begin_block		(unsigned int, unsigned int);
  static void sdbout_end_block		(unsigned int, unsigned int);
! static void sdbout_source_loc		(unsigned int, unsigned int,
! 					 const char *);
  static void sdbout_end_epilogue		(unsigned int, const char *);
  static void sdbout_global_decl		(tree);
  #ifndef MIPS_DEBUGGING_INFO
*************** const struct gcc_debug_hooks sdb_debug_h
*** 313,319 ****
    sdbout_begin_block,		         /* begin_block */
    sdbout_end_block,		         /* end_block */
    debug_true_const_tree,	         /* ignore_block */
!   sdbout_source_line,		         /* source_line */
  #ifdef MIPS_DEBUGGING_INFO
    /* Defer on MIPS systems so that parameter descriptions follow
       function entry.  */
--- 314,320 ----
    sdbout_begin_block,		         /* begin_block */
    sdbout_end_block,		         /* end_block */
    debug_true_const_tree,	         /* ignore_block */
!   sdbout_source_loc,		         /* source_loc */
  #ifdef MIPS_DEBUGGING_INFO
    /* Defer on MIPS systems so that parameter descriptions follow
       function entry.  */
*************** sdbout_end_block (unsigned int line, uns
*** 1532,1538 ****
     number LINE.  */
  
  static void
! sdbout_source_line (unsigned int line, const char *filename ATTRIBUTE_UNUSED)
  {
    /* COFF relative line numbers must be positive.  */
    if ((int) line > sdb_begin_function_line)
--- 1533,1540 ----
     number LINE.  */
  
  static void
! sdbout_source_loc (unsigned int line, unsigned int col ATTRIBUTE_UNUSED,
! 		   const char *filename ATTRIBUTE_UNUSED)
  {
    /* COFF relative line numbers must be positive.  */
    if ((int) line > sdb_begin_function_line)
*** gcc/vmsdbgout.c.0	2009-01-30 12:08:29.000000000 +0100
--- gcc/vmsdbgout.c	2009-01-30 12:33:01.000000000 +0100
*************** static void vmsdbgout_end_source_file (u
*** 173,179 ****
  static void vmsdbgout_begin_block (unsigned int, unsigned int);
  static void vmsdbgout_end_block (unsigned int, unsigned int);
  static bool vmsdbgout_ignore_block (const_tree);
! static void vmsdbgout_source_line (unsigned int, const char *);
  static void vmsdbgout_begin_prologue (unsigned int, const char *);
  static void vmsdbgout_end_prologue (unsigned int, const char *);
  static void vmsdbgout_end_function (unsigned int);
--- 173,179 ----
  static void vmsdbgout_begin_block (unsigned int, unsigned int);
  static void vmsdbgout_end_block (unsigned int, unsigned int);
  static bool vmsdbgout_ignore_block (const_tree);
! static void vmsdbgout_source_loc (unsigned int, unsigned int, const char *);
  static void vmsdbgout_begin_prologue (unsigned int, const char *);
  static void vmsdbgout_end_prologue (unsigned int, const char *);
  static void vmsdbgout_end_function (unsigned int);
*************** const struct gcc_debug_hooks vmsdbg_debu
*** 195,201 ****
     vmsdbgout_begin_block,
     vmsdbgout_end_block,
     vmsdbgout_ignore_block,
!    vmsdbgout_source_line,
     vmsdbgout_begin_prologue,
     vmsdbgout_end_prologue,
     vmsdbgout_end_epilogue,
--- 195,201 ----
     vmsdbgout_begin_block,
     vmsdbgout_end_block,
     vmsdbgout_ignore_block,
!    vmsdbgout_source_loc,
     vmsdbgout_begin_prologue,
     vmsdbgout_end_prologue,
     vmsdbgout_end_epilogue,
*************** vmsdbgout_end_prologue (unsigned int lin
*** 1296,1302 ****
        ASM_OUTPUT_LABEL (asm_out_file, label);
  
        /* VMS PCA expects every PC range to correlate to some line and file.  */
!       vmsdbgout_source_line (line, file);
      }
  }
  
--- 1296,1302 ----
        ASM_OUTPUT_LABEL (asm_out_file, label);
  
        /* VMS PCA expects every PC range to correlate to some line and file.  */
!       vmsdbgout_source_loc (line, 0, file);
      }
  }
  
*************** vmsdbgout_end_epilogue (unsigned int lin
*** 1330,1336 ****
        ASM_OUTPUT_LABEL (asm_out_file, label);
  
        /* VMS PCA expects every PC range to correlate to some line and file.  */
!       vmsdbgout_source_line (line, file);
      }
  }
  
--- 1330,1336 ----
        ASM_OUTPUT_LABEL (asm_out_file, label);
  
        /* VMS PCA expects every PC range to correlate to some line and file.  */
!       vmsdbgout_source_line (line, 0, file);
      }
  }
  
*************** lookup_filename (const char *file_name)
*** 1533,1542 ****
     'line_info_table' for later output of the .debug_line section.  */
  
  static void
! vmsdbgout_source_line (register unsigned line, register const char *filename)
  {
    if (write_symbols == VMS_AND_DWARF2_DEBUG)
!     (*dwarf2_debug_hooks.source_line) (line, filename);
  
    if (debug_info_level >= DINFO_LEVEL_TERSE)
      {
--- 1533,1542 ----
     'line_info_table' for later output of the .debug_line section.  */
  
  static void
! vmsdbgout_source_loc (unsigned int line, unsigned int col, const char *filename)
  {
    if (write_symbols == VMS_AND_DWARF2_DEBUG)
!     (*dwarf2_debug_hooks.source_line) (line, col, filename);
  
    if (debug_info_level >= DINFO_LEVEL_TERSE)
      {
*** gcc/xcoffout.h.0	2009-01-30 20:11:37.000000000 +0100
--- gcc/xcoffout.h	2009-01-30 20:13:36.000000000 +0100
*************** extern void xcoffout_end_function (unsig
*** 188,191 ****
  extern void xcoffout_end_block (unsigned, unsigned);
  extern int xcoff_assign_fundamental_type_number (tree);
  extern void xcoffout_declare_function (FILE *, tree, const char *);
! extern void xcoffout_source_line (unsigned int, const char *);
--- 188,191 ----
  extern void xcoffout_end_block (unsigned, unsigned);
  extern int xcoff_assign_fundamental_type_number (tree);
  extern void xcoffout_declare_function (FILE *, tree, const char *);
! extern void xcoffout_source_loc (unsigned int, unsigned int, const char *);
*** gcc/xcoffout.c.0	2009-01-30 20:11:41.000000000 +0100
--- gcc/xcoffout.c	2009-01-30 20:12:30.000000000 +0100
*************** xcoffout_source_file (FILE *file, const 
*** 322,328 ****
  /* Output a line number symbol entry for location (FILENAME, LINE).  */
  
  void
! xcoffout_source_line (unsigned int line, const char *filename)
  {
    bool inline_p = (strcmp (xcoff_current_function_file, filename) != 0
  		   || (int) line < xcoff_begin_function_line);
--- 322,329 ----
  /* Output a line number symbol entry for location (FILENAME, LINE).  */
  
  void
! xcoffout_source_loc (unsigned int line, unsigned int col ATTRIBUTE_UNUSED,
! 		     const char *filename)
  {
    bool inline_p = (strcmp (xcoff_current_function_file, filename) != 0
  		   || (int) line < xcoff_begin_function_line);
*** gcc/final.c.0	2009-02-02 16:56:42.000000000 +0100
--- gcc/final.c	2009-02-03 08:55:34.000000000 +0100
*************** static int high_function_linenum;
*** 139,150 ****
  /* Filename of last NOTE.  */
  static const char *last_filename;
  
  /* Override filename and line number.  */
  static const char *override_filename;
  static int override_linenum;
  
  /* Whether to force emission of a line note before the next insn.  */
! static bool force_source_line = false;
  
  extern const int length_unit_log; /* This is defined in insn-attrtab.c.  */
  
--- 139,156 ----
  /* Filename of last NOTE.  */
  static const char *last_filename;
  
+ /* Column number of last NOTE.  */
+ static int last_colnum;
+ 
  /* Override filename and line number.  */
  static const char *override_filename;
  static int override_linenum;
  
+ /* Whether to request emission of a line note before the next insn.  */
+ static bool request_source_line;
+ 
  /* Whether to force emission of a line note before the next insn.  */
! static bool force_source_line;
  
  extern const int length_unit_log; /* This is defined in insn-attrtab.c.  */
  
*************** final_start_function (rtx first ATTRIBUT
*** 1499,1507 ****
--- 1505,1517 ----
  
    last_filename = locator_file (prologue_locator);
    last_linenum = locator_line (prologue_locator);
+   last_colnum = 0;
  
    high_block_linenum = high_function_linenum = last_linenum;
  
+   request_source_line = false;
+   force_source_line = false;
+ 
    if (!DECL_IGNORED_P (current_function_decl))
      debug_hooks->begin_prologue (last_linenum, last_filename);
  
*************** final_scan_insn (rtx insn, FILE *file, i
*** 2193,2199 ****
  	   note in a row.  */
  	if (!DECL_IGNORED_P (current_function_decl)
  	    && notice_source_line (insn))
! 	  debug_hooks->source_line (last_linenum, last_filename);
  
  	if (GET_CODE (body) == ASM_INPUT)
  	  {
--- 2203,2214 ----
  	   note in a row.  */
  	if (!DECL_IGNORED_P (current_function_decl)
  	    && notice_source_line (insn))
! 	  debug_hooks->source_loc (last_linenum, last_colnum, last_filename);
! 
! 	/* If we're preserving control flow, try to output a line note for
! 	   each control flow change.  */
! 	if (flag_preserve_control_flow && JUMP_P (insn))
! 	  request_source_line = true;
  
  	if (GET_CODE (body) == ASM_INPUT)
  	  {
*************** static bool
*** 2686,2710 ****
  notice_source_line (rtx insn)
  {
    const char *filename;
!   int linenum;
  
    if (override_filename)
      {
        filename = override_filename;
        linenum = override_linenum;
      }
    else
      {
!       filename = insn_file (insn);
!       linenum = insn_line (insn);
      }
  
    if (filename
        && (force_source_line
  	  || filename != last_filename
! 	  || last_linenum != linenum))
      {
        force_source_line = false;
        last_filename = filename;
        last_linenum = linenum;
        high_block_linenum = MAX (last_linenum, high_block_linenum);
--- 2701,2741 ----
  notice_source_line (rtx insn)
  {
    const char *filename;
!   int linenum, colnum;
  
    if (override_filename)
      {
        filename = override_filename;
        linenum = override_linenum;
+       colnum = 0;
      }
    else
      {
!       expanded_location xloc = insn_location (insn);
!       filename = xloc.file;
!       linenum = xloc.line;
! #ifdef USE_MAPPED_LOCATION
!       colnum = xloc.column;
! #else
!       colnum = 0;
! #endif
      }
  
    if (filename
        && (force_source_line
  	  || filename != last_filename
! 	  || last_linenum != linenum
! 	  /* Use the column if requested or already done in the line.  */
! 	  || ((request_source_line || last_colnum != 0)
! 	      && last_colnum != colnum)))
      {
+       request_source_line = false;
        force_source_line = false;
+       /* Set the column number if we are in the middle of a line.  */
+       if (filename == last_filename && last_linenum == linenum)
+ 	last_colnum = colnum;
+       else
+ 	last_colnum = 0;
        last_filename = filename;
        last_linenum = linenum;
        high_block_linenum = MAX (last_linenum, high_block_linenum);
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** print_ada_declaration (pretty_printer *b
*** 1919,1928 ****
          {
            pp_string (buffer, "pragma CPP_Constructor (New_");
  	  dump_ada_decl_name (buffer, t, false);
-           pp_string (buffer, ");");
-           newline_and_indent (buffer, spc);
- 	  pp_string (buffer, "pragma Import (CPP, New_");
- 	  dump_ada_decl_name (buffer, t, false);
  	  pp_string (buffer, ", \"");
  	  pp_asm_name (buffer, t);
  	  pp_string (buffer, "\");");
--- 1919,1924 ----
*** gcc/fold-const.c.0	2009-02-09 16:18:35.000000000 +0100
--- gcc/fold-const.c	2009-02-09 17:26:28.000000000 +0100
*************** make_range (tree exp, int *pin_p, tree *
*** 4648,4655 ****
  static tree
  build_range_check (tree type, tree exp, int in_p, tree low, tree high)
  {
!   tree etype = TREE_TYPE (exp);
!   tree value;
  
  #ifdef HAVE_canonicalize_funcptr_for_compare
    /* Disable this optimization for function pointer expressions
--- 4648,4655 ----
  static tree
  build_range_check (tree type, tree exp, int in_p, tree low, tree high)
  {
!   tree etype = TREE_TYPE (exp), value;
!   enum tree_code code;
  
  #ifdef HAVE_canonicalize_funcptr_for_compare
    /* Disable this optimization for function pointer expressions
*************** build_range_check (tree type, tree exp, 
*** 4733,4752 ****
  
    /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).
       This requires wrap-around arithmetics for the type of the expression.  */
!   switch (TREE_CODE (etype))
      {
      case INTEGER_TYPE:
        /* There is no requirement that LOW be within the range of ETYPE
  	 if the latter is a subtype.  It must, however, be within the base
  	 type of ETYPE.  So be sure we do the subtraction in that type.  */
!       if (TREE_TYPE (etype))
! 	etype = TREE_TYPE (etype);
!       break;
  
!     case ENUMERAL_TYPE:
!     case BOOLEAN_TYPE:
!       etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
! 					      TYPE_UNSIGNED (etype));
        break;
  
      default:
--- 4733,4757 ----
  
    /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).
       This requires wrap-around arithmetics for the type of the expression.  */
!   code = TREE_CODE (etype);
!   switch (code)
      {
      case INTEGER_TYPE:
+     case ENUMERAL_TYPE:
+     case BOOLEAN_TYPE:
        /* There is no requirement that LOW be within the range of ETYPE
  	 if the latter is a subtype.  It must, however, be within the base
  	 type of ETYPE.  So be sure we do the subtraction in that type.  */
!       if (code == INTEGER_TYPE && TREE_TYPE (etype))
! 	{
! 	  etype = TREE_TYPE (etype);
! 	  /* But not in an enumeral or boolean type though.  */
! 	  code = TREE_CODE (etype);
! 	}
  
!       if (code != INTEGER_TYPE)
! 	etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
! 						TYPE_UNSIGNED (etype));
        break;
  
      default:
*** gcc/tree-profile.c.0	2009-02-11 12:43:18.000000000 +0100
--- gcc/tree-profile.c	2009-02-11 12:49:31.000000000 +0100
*************** tree_profiling (void)
*** 426,431 ****
--- 426,437 ----
        || cfun->after_tree_profile)
      return 0;
  
+   /* Don't profile functions produced for builtin stuff.  */
+ #ifdef USE_MAPPED_LOCATION
+   if (DECL_SOURCE_LOCATION (current_function_decl) == BUILTINS_LOCATION)
+     return 0;
+ #endif
+ 
    /* Re-set global shared temporary variable for edge-counters.  */
    gcov_type_tmp_var = NULL_TREE;
  
*** gcc/tree-ssa-sink.c.0	2009-02-11 23:03:03.000000000 +0100
--- gcc/tree-ssa-sink.c	2009-02-11 23:07:49.000000000 +0100
*************** statement_sink_location (tree stmt, basi
*** 321,326 ****
--- 321,327 ----
    ann = stmt_ann (stmt);
    if (stmt_ends_bb_p (stmt)
        || TREE_SIDE_EFFECTS (rhs)
+       || tree_could_trap_p (rhs)
        || TREE_CODE (rhs) == EXC_PTR_EXPR
        || TREE_CODE (rhs) == FILTER_EXPR
        || is_hidden_global_store (stmt)
*** gcc/config/rs6000/rs6000.c.ori	Wed Feb 11 13:58:59 2009
--- gcc/config/rs6000/rs6000.c	Wed Feb 11 13:59:36 2009
*************** rs6000_emit_prologue (void)
*** 16073,16079 ****
         rtx spe_save_area_ptr;
         int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE
                                     && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)
!                                    && !call_used_regs[STATIC_CHAIN_REGNUM]);
   
         /* Determine whether we can address all of the registers that need
            to be saved with an offset from the stack pointer that fits in
--- 16073,16079 ----
         rtx spe_save_area_ptr;
         int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE
                                     && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)
!                                    && call_used_regs[STATIC_CHAIN_REGNUM]);
   
         /* Determine whether we can address all of the registers that need
            to be saved with an offset from the stack pointer that fits in
*** config.sub.ori	Fri Sep 12 13:23:16 2008
--- config.sub	Wed Sep 10 15:49:38 2008
*************** case $os in
*** 214,219 ****
--- 214,222 ----
  	-isc*)
  		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
+ 	-lynx*5)
+ 		os=-lynxos5
+ 		;;
  	-lynx*)
  		os=-lynxos
  		;;
*** gcc/config.gcc.ori	2007-09-13 10:26:32.950015000 -0400
--- gcc/config.gcc	2007-09-14 04:38:34.650015000 -0400
*************** powerpc-wrs-windiss*)  # Instruction-lev
*** 2038,2043 ****
--- 2038,2052 ----
  	thread_file=""
  	use_fixproto=yes
  	;;
+ powerpc-xcoff-lynxos*)
+ 	tm_file="${tm_file} rs6000/lynx.h lynx.h"
+ 	tm_file="${tm_file} rs6000/xcoff.h rs6000/lynx-xcoff.h"
+ 	tmake_file="rs6000/t-fprules"
+ 	extra_options="${extra_options} lynx.opt rs6000/lynx-xcoff.opt"
+ 	thread_file=lynx
+ 	gnu_ld=yes
+ 	gas=yes
+ 	;;
  powerpc-*-lynxos*)
  	xm_defines=POSIX
  	tm_file="${tm_file} dbxelf.h elfos.h rs6000/sysv4.h rs6000/lynx.h lynx.h"
*** gcc/config/rs6000/rs6000.h.ori	2007-09-13 10:26:32.780015000 -0400
--- gcc/config/rs6000/rs6000.h	2007-09-13 10:27:48.010015000 -0400
***************
*** 40,45 ****
--- 40,49 ----
  #define TARGET_AIX 0
  #endif
  
+ #ifndef TARGET_LYNXOS
+ #define TARGET_LYNXOS 0
+ #endif
+ 
  /* Control whether function entry points use a "dot" symbol when
     ABI_AIX.  */
  #define DOT_SYMBOLS 1
*** gcc/config/lynx.h.ori	2007-09-13 10:26:32.810015000 -0400
--- gcc/config/lynx.h	2007-09-13 10:27:48.030015000 -0400
*************** Boston, MA 02110-1301, USA.  */
*** 25,30 ****
--- 25,33 ----
     them here we might accidentally disable some target-specific
     defines.  */
  
+ #undef  TARGET_LYNXOS
+ #define TARGET_LYNXOS 1
+ 
  #ifndef EXTRA_OS_LYNX_TARGET_SPECS
  # define EXTRA_OS_LYNX_TARGET_SPECS
  #endif
*** gcc/config/rs6000/lynx-xcoff.h.ori	2007-09-13 10:29:50.351839000 -0400
--- gcc/config/rs6000/lynx-xcoff.h	2007-09-13 10:27:47.950015000 -0400
***************
*** 0 ****
--- 1,64 ----
+ /* Target independent definitions for LynxOS XCOFF on PowerPC.
+    Copyright (C) 1993, 1994, 1995, 1996, 1999, 2000, 2002, 2003, 2004
+    Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Use the AIX ABI and borrow other bits of the AIX configuration.  */
+ 
+ #define DEFAULT_ABI ABI_AIX
+ 
+ #define TARGET_NO_TOC 0
+ #define TARGET_TOC 1
+ 
+ #define FIXED_R2 1
+ #define FIXED_R13 0
+ 
+ #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)
+ 
+ /* Then override generic settings according to the lynx-xcoff
+    specificities.  */
+ 
+ #undef  STARTFILE_SPEC
+ #define STARTFILE_SPEC \
+   "%{p:%{pg:%e-p and -pg options are incompatible}}\
+    %{p:pinit1.o%s} %{pg:gpinit1.o%s}\
+    %{!p:%{!pg:init1.o%s}}"
+ 
+ #undef  ENDFILE_SPEC
+ 
+ #undef  LINK_SPEC
+ #define LINK_SPEC "-T0x10001000 -D0x20000000"
+ 
+ #undef  DEFAULT_SIGNED_CHAR
+ #define DEFAULT_SIGNED_CHAR 1
+ 
+ #undef  RS6000_DEFAULT_LONG_DOUBLE_SIZE
+ #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 64
+ 
+ #undef  PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG
+ 
+ #undef  TARGET_DEFAULT
+ #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)
+ 
+ #undef  USER_LABEL_PREFIX
+ #define USER_LABEL_PREFIX ""
+ 
+ #undef  FUNCTION_PROFILER
+ #define FUNCTION_PROFILER(file, profile_label_no)
*** gcc/config/rs6000/lynx-xcoff.opt.ori	2007-09-13 10:29:52.756879000 -0400
--- gcc/config/rs6000/lynx-xcoff.opt	2007-09-13 10:27:47.980015000 -0400
***************
*** 0 ****
--- 1,28 ----
+ ; Lynx/XCOFF options for PPC port.
+ ;
+ ; Copyright (C) 2007 Free Software Foundation, Inc.
+ ;
+ ; This file is part of GCC.
+ ;
+ ; GCC is free software; you can redistribute it and/or modify it under
+ ; the terms of the GNU General Public License as published by the Free
+ ; Software Foundation; either version 2, or (at your option) any later
+ ; version.
+ ;
+ ; GCC is distributed in the hope that it will be useful, but WITHOUT
+ ; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ ; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+ ; License for more details.
+ ;
+ ; You should have received a copy of the GNU General Public License
+ ; along with GCC; see the file COPYING.  If not, write to the Free
+ ; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+ ; 02110-1301, USA.
+ 
+ m64
+ Target Report RejectNegative Mask(64BIT)
+ Generate 64-bit code
+ 
+ m32
+ Target Report RejectNegative InverseMask(64BIT)
+ Generate 32-bit code
*** gcc/config/rs6000/rs6000.c.ori	2007-09-13 10:26:32.750015000 -0400
--- gcc/config/rs6000/rs6000.c	2007-09-13 10:27:47.940015000 -0400
*************** static const char alt_reg_names[][8] =
*** 1028,1036 ****
  /* Default unaligned ops are only provided for ELF.  Find the ops needed
     for non-ELF systems.  */
  #ifndef OBJECT_FORMAT_ELF
! #if TARGET_XCOFF
! /* For XCOFF.  rs6000_assemble_integer will handle unaligned DIs on
!    64-bit targets.  */
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.vbyte\t2,"
  #undef TARGET_ASM_UNALIGNED_SI_OP
--- 1028,1038 ----
  /* Default unaligned ops are only provided for ELF.  Find the ops needed
     for non-ELF systems.  */
  #ifndef OBJECT_FORMAT_ELF
! 
! /* For XCOFF, use .vbyte, except on Lynx where the system assembler
!    doesn't support it. rs6000_assemble_integer will handle unaligned
!    DIs on 64-bit targets. .  */
! #if TARGET_XCOFF && !TARGET_LYNXOS
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.vbyte\t2,"
  #undef TARGET_ASM_UNALIGNED_SI_OP
*************** static const char alt_reg_names[][8] =
*** 1038,1044 ****
  #undef TARGET_ASM_UNALIGNED_DI_OP
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.vbyte\t8,"
  #else
! /* For Darwin.  */
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.short\t"
  #undef TARGET_ASM_UNALIGNED_SI_OP
--- 1040,1046 ----
  #undef TARGET_ASM_UNALIGNED_DI_OP
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.vbyte\t8,"
  #else
! /* For LynxOS/XCOFF or Darwin.  */
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.short\t"
  #undef TARGET_ASM_UNALIGNED_SI_OP
*************** print_operand_address (FILE *file, rtx x
*** 12301,12307 ****
  #endif
    else if (legitimate_constant_pool_address_p (x))
      {
!       if (TARGET_AIX && (!TARGET_ELF || !TARGET_MINIMAL_TOC))
  	{
  	  rtx contains_minus = XEXP (x, 1);
  	  rtx minus, symref;
--- 12303,12310 ----
  #endif
    else if (legitimate_constant_pool_address_p (x))
      {
!       if ((TARGET_AIX && (!TARGET_ELF || !TARGET_MINIMAL_TOC))
! 	  || (TARGET_LYNXOS && TARGET_XCOFF))
  	{
  	  rtx contains_minus = XEXP (x, 1);
  	  rtx minus, symref;
*** gcc/config.gcc.orig	2009-02-17 17:26:33.898389685 +0100
--- gcc/config.gcc	2009-02-17 09:55:02.761478008 +0100
*************** erc32-*-elf*)
*** 2523,2529 ****
          ;;
  leon-*-elf*)
          tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/leon.h"
!         tmake_file="sparc/t-elf sparc/t-crtfm"
          extra_parts="crti.o crtn.o crtbegin.o crtend.o"
          use_fixproto=yes
          ;;
--- 2523,2529 ----
          ;;
  leon-*-elf*)
          tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/leon.h"
!         tmake_file="sparc/t-elf sparc/t-crtfm sparc/t-leon"
          extra_parts="crti.o crtn.o crtbegin.o crtend.o"
          use_fixproto=yes
          ;;
*** /dev/null	2009-01-28 09:41:02.178295000 +0100
--- gcc/config/sparc/t-leon	2009-02-17 15:53:08.838315572 +0100
***************
*** 0 ****
--- 1,7 ----
+ # Multilibs for LEON
+ # LEON is a SPARC V8, but the AT697 implementation has a bug in the
+ # V8-specific instructions.
+ 
+ MULTILIB_OPTIONS = mcpu=v7/mcpu=v8
+ MULTILIB_DIRNAMES = v7 v8
+ MULTILIB_MATCHES = mcpu?v7=mv7 mcpu?v8=mv8
*** gcc/config/arm/t-arm-elf.ori	Mon Feb  9 17:02:23 2009
--- gcc/config/arm/t-arm-elf	Mon Feb  9 17:11:25 2009
*************** MULTILIB_MATCHES     =
*** 28,70 ****
  # MULTILIB_OPTIONS     += mlittle-endian/mbig-endian
  # MULTILIB_DIRNAMES    += le be
  # MULTILIB_MATCHES     += mbig-endian=mbe mlittle-endian=mle
! # 
! # MULTILIB_OPTIONS    += mhard-float/msoft-float
! # MULTILIB_DIRNAMES   += fpu soft
! # MULTILIB_EXCEPTIONS += *mthumb/*mhard-float*
! # 
! # MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork
! # MULTILIB_DIRNAMES   += normal interwork
! # 
  # MULTILIB_OPTIONS    += fno-leading-underscore/fleading-underscore
  # MULTILIB_DIRNAMES   += elf under
! # 
! # MULTILIB_OPTIONS    += mcpu=arm7
! # MULTILIB_DIRNAMES   += nofmult
! # MULTILIB_EXCEPTIONS += *mthumb*/*mcpu=arm7*
! # # Note: the multilib_exceptions matches both -mthumb and
! # # -mthumb-interwork
! # #
! # # We have to match all the arm cpu variants which do not have the
! # # multiply instruction and treat them as if the user had specified
! # # -mcpu=arm7.  Note that in the following the ? is interpreted as
! # # an = for the purposes of matching command line options.
! # # FIXME: There ought to be a better way to do this.
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7d
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7di
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm70
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm700
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm700i
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm710
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm710c
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7100
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7500
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7500fe
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm6
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm60
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm600
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm610
! # MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm620
  
  EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
  
--- 28,70 ----
  # MULTILIB_OPTIONS     += mlittle-endian/mbig-endian
  # MULTILIB_DIRNAMES    += le be
  # MULTILIB_MATCHES     += mbig-endian=mbe mlittle-endian=mle
!  
! MULTILIB_OPTIONS    += mhard-float/msoft-float
! MULTILIB_DIRNAMES   += fpu soft
! MULTILIB_EXCEPTIONS += *mthumb/*mhard-float*
!  
! MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork
! MULTILIB_DIRNAMES   += normal interwork
!  
  # MULTILIB_OPTIONS    += fno-leading-underscore/fleading-underscore
  # MULTILIB_DIRNAMES   += elf under
!  
! MULTILIB_OPTIONS    += mcpu=arm7
! MULTILIB_DIRNAMES   += nofmult
! MULTILIB_EXCEPTIONS += *mthumb*/*mcpu=arm7*
! # Note: the multilib_exceptions matches both -mthumb and
! # -mthumb-interwork
! #
! # We have to match all the arm cpu variants which do not have the
! # multiply instruction and treat them as if the user had specified
! # -mcpu=arm7.  Note that in the following the ? is interpreted as
! # an = for the purposes of matching command line options.
! # FIXME: There ought to be a better way to do this.
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7d
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7di
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm70
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm700
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm700i
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm710
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm710c
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7100
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7500
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7500fe
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm6
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm60
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm600
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm610
! MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm620
  
  EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
  

*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** static int dump_generic_ada_node (pretty
*** 44,50 ****
  				  int (*)(tree, int), int, int, bool);
  static int print_ada_declaration (pretty_printer *, tree, tree,
  				  int (*cpp_check)(tree, int), int);
! static void print_ada_struct_decl (pretty_printer *, const_tree, tree,
  				   int (*cpp_check)(tree, int), int, bool);
  static void dump_sloc (pretty_printer *buffer, tree node);
  
--- 44,50 ----
  				  int (*)(tree, int), int, int, bool);
  static int print_ada_declaration (pretty_printer *, tree, tree,
  				  int (*cpp_check)(tree, int), int);
! static void print_ada_struct_decl (pretty_printer *, tree, tree,
  				   int (*cpp_check)(tree, int), int, bool);
  static void dump_sloc (pretty_printer *buffer, tree node);
  
*************** static int is_struct_like (const_tree ty
*** 58,63 ****
--- 58,65 ----
  #define INDENT(SPACE) do { \
    int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)
  
+ #define INDENT_INCR 3
+ 
  static const char *source_file_base;
  
  /* Compare the declaration of struct-like types based on the sloc of
*************** print_generic_ada_decl (pretty_printer *
*** 250,256 ****
  {
    source_file_base = source_file;
  
!   if (print_ada_declaration (pp, decl, 0, cpp_check, 2))
      {
        pp_newline (pp);
        pp_newline (pp);
--- 252,258 ----
  {
    source_file_base = source_file;
  
!   if (print_ada_declaration (pp, decl, 0, cpp_check, INDENT_INCR))
      {
        pp_newline (pp);
        pp_newline (pp);
*************** get_underlying_decl (tree type)
*** 427,433 ****
  }
  
  static int
! has_static_fields (tree type)
  {
    tree tmp;
  
--- 429,435 ----
  }
  
  static int
! has_static_fields (const_tree type)
  {
    tree tmp;
  
*************** has_static_fields (tree type)
*** 439,444 ****
--- 441,467 ----
    return false;
  }
  
+ static int
+ is_tagged_type (const_tree type)
+ {
+   if (!is_struct_like (type))
+     return false;
+ 
+ #if 0  /* enable this code when GNAT supports tagged types with no vtable */
+   return TYPE_METHODS (type) != NULL_TREE;
+ #else
+   {
+     tree tmp;
+ 
+     for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))
+       if (DECL_VINDEX (tmp))
+ 	return true;
+   }
+ 
+   return false;
+ #endif
+ }
+ 
  /* Dump the name of an identifier node, following Ada syntax */
  
  static void
*************** dump_ada_function_declaration (pretty_pr
*** 807,814 ****
  	    (buffer, TREE_VALUE (arg), type, NULL, spc, 0, true);
  	}
  
!       if (is_method && num == 1 && !DECL_VINDEX (func) && !is_constructor)
!         pp_string (buffer, "'Class");
  
        arg = TREE_CHAIN (arg);
  
--- 830,838 ----
  	    (buffer, TREE_VALUE (arg), type, NULL, spc, 0, true);
  	}
  
!       if (is_method && num == 1 && !DECL_VINDEX (func) && !is_constructor
! 	  && is_tagged_type (TREE_TYPE (TREE_TYPE (arg))))
!           pp_string (buffer, "'Class");
  
        arg = TREE_CHAIN (arg);
  
*************** dump_ada_function_declaration (pretty_pr
*** 817,823 ****
  	  pp_character (buffer, ';');
  
  	  if (num_args > 2)
! 	    newline_and_indent (buffer, spc + 3);
  	  else
  	    pp_space (buffer);
  	}
--- 841,847 ----
  	  pp_character (buffer, ';');
  
  	  if (num_args > 2)
! 	    newline_and_indent (buffer, spc + INDENT_INCR);
  	  else
  	    pp_space (buffer);
  	}
*************** dump_ada_function_declaration (pretty_pr
*** 826,832 ****
    if (have_ellipsis)
      {
        pp_string (buffer, "  -- , ...");
!       newline_and_indent (buffer, spc + 2);
      }
  
    if (num_args > 0)
--- 850,856 ----
    if (have_ellipsis)
      {
        pp_string (buffer, "  -- , ...");
!       newline_and_indent (buffer, spc + INDENT_INCR);
      }
  
    if (num_args > 0)
*************** dump_ada_template (pretty_printer *buffe
*** 973,979 ****
        pp_string (buffer, "type ");
        dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);
  
!       pp_string (buffer, " is tagged limited ");
        dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, false);
        pp_newline (buffer);
        spc -= 3;
--- 997,1007 ----
        pp_string (buffer, "type ");
        dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);
  
!       if (is_tagged_type (instance))
!         pp_string (buffer, " is tagged limited ");
!       else
!         pp_string (buffer, " is limited ");
! 
        dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, false);
        pp_newline (buffer);
        spc -= 3;
*************** dump_generic_ada_node (pretty_printer *b
*** 1151,1157 ****
  
            in_function = is_function;
            dump_ada_function_declaration
! 	    (buffer, node, type, false, false, false, spc + 2);
            in_function = prev_in_function;
  
            if (is_function)
--- 1179,1185 ----
  
            in_function = is_function;
            dump_ada_function_declaration
! 	    (buffer, node, type, false, false, false, spc + INDENT_INCR);
            in_function = prev_in_function;
  
            if (is_function)
*************** dump_generic_ada_node (pretty_printer *b
*** 1198,1205 ****
  		     access-to-unknown-structs as opaque system.address */
  
  		  tree typ = TYPE_NAME (TREE_TYPE (node));
! 		  tree typ2 = !type || DECL_P (type) ? type : TYPE_NAME (type);
! 		  tree underlying_type = get_underlying_decl (TREE_TYPE (node));
  
  	          if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE
  		      /* is pointer to pointer */
--- 1226,1235 ----
  		     access-to-unknown-structs as opaque system.address */
  
  		  tree typ = TYPE_NAME (TREE_TYPE (node));
! 		  const_tree typ2 = !type ||
! 		    DECL_P (type) ? type : TYPE_NAME (type);
! 		  const_tree underlying_type =
! 		    get_underlying_decl (TREE_TYPE (node));
  
  	          if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE
  		      /* is pointer to pointer */
*************** dump_generic_ada_node (pretty_printer *b
*** 1367,1374 ****
  	dump_ada_decl_name (buffer, node, limited_access);
        else
  	{
! 	  if (is_struct_like (TREE_TYPE (node))
! 	      && TYPE_METHODS (TREE_TYPE (node)))
  	    {
  	      tree tmp = TYPE_FIELDS (TREE_TYPE (node));
  	      int first = 1;
--- 1397,1403 ----
  	dump_ada_decl_name (buffer, node, limited_access);
        else
  	{
! 	  if (is_tagged_type (TREE_TYPE (node)))
  	    {
  	      tree tmp = TYPE_FIELDS (TREE_TYPE (node));
  	      int first = 1;
*************** dump_generic_ada_node (pretty_printer *b
*** 1376,1382 ****
  	      /* Look for ancestors */
  	      for (; tmp; tmp = TREE_CHAIN (tmp))
  		{
! 		  if (!DECL_NAME (tmp))
  		    {
  		      if (first)
  			{
--- 1405,1411 ----
  	      /* Look for ancestors */
  	      for (; tmp; tmp = TREE_CHAIN (tmp))
  		{
! 		  if (!DECL_NAME (tmp) && is_tagged_type (TREE_TYPE (tmp)))
  		    {
  		      if (first)
  			{
*************** dump_generic_ada_node (pretty_printer *b
*** 1393,1398 ****
--- 1422,1430 ----
  
  	      pp_string (buffer, first ? "tagged limited " : " with ");
  	    }
+ 	  else if (is_struct_like (TREE_TYPE (node))
+ 		   && TYPE_METHODS (TREE_TYPE (node)))
+ 	    pp_string (buffer, "limited ");
  
  	  dump_generic_ada_node
  	    (buffer, TREE_TYPE (node), type, cpp_check,
*************** dump_generic_ada_node (pretty_printer *b
*** 1426,1432 ****
  #define IS_TEMPLATE 3
  
  static void
! print_ada_methods (pretty_printer *buffer, const_tree node,
  		   int (*cpp_check)(tree, int), int spc)
  {
    tree tmp = TYPE_METHODS (node);
--- 1458,1464 ----
  #define IS_TEMPLATE 3
  
  static void
! print_ada_methods (pretty_printer *buffer, tree node,
  		   int (*cpp_check)(tree, int), int spc)
  {
    tree tmp = TYPE_METHODS (node);
*************** print_ada_methods (pretty_printer *buffe
*** 1443,1449 ****
  	      pp_newline (buffer);
  	      pp_newline (buffer);
  	    }
! 	  res = print_ada_declaration (buffer, tmp, 0, cpp_check, spc);
  	}
      }
  }
--- 1475,1481 ----
  	      pp_newline (buffer);
  	      pp_newline (buffer);
  	    }
! 	  res = print_ada_declaration (buffer, tmp, node, cpp_check, spc);
  	}
      }
  }
*************** dump_nested_types (pretty_printer *buffe
*** 1475,1481 ****
  	  if (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE)
  	    {
  	      tree ptr = TREE_TYPE (field);
- 
  	      tree decl = get_underlying_decl (TREE_TYPE (ptr));
  
  	      if (decl
--- 1507,1512 ----
*************** print_ada_declaration (pretty_printer *b
*** 1773,1781 ****
  	  && decl_name
  	  && *IDENTIFIER_POINTER (decl_name) == '_')
  	{
! 	  pp_string (buffer, "  --  skipped var ");
! 	  pp_string (buffer, IDENTIFIER_POINTER (DECL_NAME (t)));
! 	  return 1;
  	}
  
        need_indent = 1;
--- 1804,1810 ----
  	  && decl_name
  	  && *IDENTIFIER_POINTER (decl_name) == '_')
  	{
! 	  return 0;
  	}
  
        need_indent = 1;
*************** print_ada_declaration (pretty_printer *b
*** 1805,1811 ****
          {
  	  tree tmp = TYPE_NAME (TREE_TYPE (t));
  
! 	  if (spc == 2 || TREE_STATIC (t))
  	    is_var = 1;
  
            pp_string (buffer, " : ");
--- 1834,1840 ----
          {
  	  tree tmp = TYPE_NAME (TREE_TYPE (t));
  
! 	  if (spc == INDENT_INCR || TREE_STATIC (t))
  	    is_var = 1;
  
            pp_string (buffer, " : ");
*************** print_ada_declaration (pretty_printer *b
*** 1837,1842 ****
--- 1866,1872 ----
        const int is_abstract = cpp_check && cpp_check (t, IS_ABSTRACT);
        const int is_constructor = cpp_check && cpp_check (t, IS_CONSTRUCTOR);
        const int is_destructor = cpp_check && cpp_check (t, IS_DESTRUCTOR);
+       const int is_tagged = type && is_tagged_type (type);
  
        if (!decl_name)
  	return 0;
*************** print_ada_declaration (pretty_printer *b
*** 1893,1899 ****
  	  if (is_constructor)
  	    {
  	      dump_ada_decl_name (buffer, t, false);
! 	      pp_string (buffer, "'Class");
  	    }
  	  else
  	    {
--- 1923,1930 ----
  	  if (is_constructor)
  	    {
  	      dump_ada_decl_name (buffer, t, false);
! 	      if (is_tagged)
! 	        pp_string (buffer, "'Class");
  	    }
  	  else
  	    {
*************** print_ada_declaration (pretty_printer *b
*** 1917,1923 ****
  
        if (is_constructor)
          {
!           pp_string (buffer, "pragma CPP_Constructor (New_");
  	  dump_ada_decl_name (buffer, t, false);
  	  pp_string (buffer, ", \"");
  	  pp_asm_name (buffer, t);
--- 1948,1957 ----
  
        if (is_constructor)
          {
!           if (is_tagged)
!             pp_string (buffer, "pragma CPP_Constructor (New_");
!           else
!             pp_string (buffer, "pragma Import (CPP, New_");
  	  dump_ada_decl_name (buffer, t, false);
  	  pp_string (buffer, ", \"");
  	  pp_asm_name (buffer, t);
*************** print_ada_declaration (pretty_printer *b
*** 2031,2037 ****
  	}
        else
  	{
! 	  if (spc == 2 || TREE_STATIC (t))
  	    is_var = 1;
  
  	  pp_string (buffer, " : ");
--- 2065,2071 ----
  	}
        else
  	{
! 	  if (spc == INDENT_INCR || TREE_STATIC (t))
  	    is_var = 1;
  
  	  pp_string (buffer, " : ");
*************** print_ada_declaration (pretty_printer *b
*** 2097,2103 ****
  /* Prints a structure: name, fields, and methods with Ada syntax.  */
  
  static void
! print_ada_struct_decl (pretty_printer *buffer, const_tree node, tree type,
  		       int (*cpp_check)(tree, int), int spc,
  		       bool display_convention)
  {
--- 2131,2137 ----
  /* Prints a structure: name, fields, and methods with Ada syntax.  */
  
  static void
! print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,
  		       int (*cpp_check)(tree, int), int spc,
  		       bool display_convention)
  {
*************** print_ada_struct_decl (pretty_printer *b
*** 2106,2112 ****
      TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;
    char buf [16];
    int field_num = 0;
!   int field_spc = spc + 2;
    int need_semicolon;
  
    bitfield_used = false;
--- 2140,2146 ----
      TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;
    char buf [16];
    int field_num = 0;
!   int field_spc = spc + INDENT_INCR;
    int need_semicolon;
  
    bitfield_used = false;
*************** print_ada_struct_decl (pretty_printer *b
*** 2121,2127 ****
  
        if (is_union)
  	{
! 	  newline_and_indent (buffer, spc + 2);
  	  pp_string (buffer, "case discr is");
  	  field_spc = spc + 6;
  	}
--- 2155,2161 ----
  
        if (is_union)
  	{
! 	  newline_and_indent (buffer, spc + INDENT_INCR);
  	  pp_string (buffer, "case discr is");
  	  field_spc = spc + 6;
  	}
*************** print_ada_struct_decl (pretty_printer *b
*** 2131,2141 ****
        /* Print the non-static fields of the structure.  */
        for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))
  	{
  	  /* Avoid printing the structure recursively.  */
!           if ((TREE_TYPE (tmp) != node
                 || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE
                     && TREE_TYPE (TREE_TYPE (tmp)) != node))
- 		   && DECL_NAME (tmp)
  		   && TREE_CODE (tmp) != TYPE_DECL
  		   && !TREE_STATIC (tmp))
  	    {
--- 2165,2195 ----
        /* Print the non-static fields of the structure.  */
        for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))
  	{
+ 	  /* Add parent field if needed */
+ 	  if (!DECL_NAME (tmp))
+ 	    {
+ 	      if (!is_tagged_type (TREE_TYPE (tmp)))
+ 		{
+ 	          INDENT (spc + INDENT_INCR);
+ 
+ 		  if (field_num == 0)
+ 		    pp_string (buffer, "Parent : ");
+ 		  else
+ 		    {
+ 		      sprintf (buf, "Parent%d : ", field_num + 1);
+ 		      pp_string (buffer, buf);
+ 		    }
+ 		  dump_ada_decl_name
+ 		    (buffer, TYPE_NAME (TREE_TYPE (tmp)), false);
+ 		  pp_semicolon (buffer);
+ 	          pp_newline (buffer);
+ 	          field_num++;
+ 		}
+ 	    }
  	  /* Avoid printing the structure recursively.  */
!           else if ((TREE_TYPE (tmp) != node
                 || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE
                     && TREE_TYPE (TREE_TYPE (tmp)) != node))
  		   && TREE_CODE (tmp) != TYPE_DECL
  		   && !TREE_STATIC (tmp))
  	    {
*************** print_ada_struct_decl (pretty_printer *b
*** 2150,2156 ****
  	              else
  	                sprintf (buf, "when others =>");
  
! 	              INDENT (spc + 4);
  	              pp_string (buffer, buf);
  	              pp_newline (buffer);
  	            }
--- 2204,2210 ----
  	              else
  	                sprintf (buf, "when others =>");
  
! 	              INDENT (spc + INDENT_INCR * 2);
  	              pp_string (buffer, buf);
  	              pp_newline (buffer);
  	            }
*************** print_ada_struct_decl (pretty_printer *b
*** 2165,2178 ****
  
        if (is_union)
  	{
! 	  INDENT (spc + 2);
  	  pp_string (buffer, "end case;");
  	  pp_newline (buffer);
  	}
  
        if (field_num == 0)
  	{
! 	  INDENT (spc + 2);
  	  pp_string (buffer, "null;");
  	  pp_newline (buffer);
  	}
--- 2219,2232 ----
  
        if (is_union)
  	{
! 	  INDENT (spc + INDENT_INCR);
  	  pp_string (buffer, "end case;");
  	  pp_newline (buffer);
  	}
  
        if (field_num == 0)
  	{
! 	  INDENT (spc + INDENT_INCR);
  	  pp_string (buffer, "null;");
  	  pp_newline (buffer);
  	}
*************** print_ada_struct_decl (pretty_printer *b
*** 2186,2192 ****
    if (!display_convention)
      return;
  
!   if (is_struct_like (TREE_TYPE (type)) && TYPE_METHODS (TREE_TYPE (type)))
      pp_string (buffer, "pragma Import (CPP, ");
    else
      pp_string (buffer, "pragma Convention (C, ");
--- 2240,2246 ----
    if (!display_convention)
      return;
  
!   if (is_tagged_type (TREE_TYPE (type)))
      pp_string (buffer, "pragma Import (CPP, ");
    else
      pp_string (buffer, "pragma Convention (C, ");
*** gcc/config/rs6000/vxworks-unwind.h.ori	Mon Mar 16 18:08:16 2009
--- gcc/config/rs6000/vxworks-unwind.h	Mon Mar 16 18:37:19 2009
***************
*** 42,48 ****
     We need to #include the version we need directly here, and prevent the
     possibly indirect inclusion of the GCC one, as its contents is useless to
     us and it depends on several other headers that we don't have at hand.  */
! #include <arch/ppc/regsPpc.h>
  #define GCC_REGS_H
  
  #include <sigLib.h>
--- 42,48 ----
     We need to #include the version we need directly here, and prevent the
     possibly indirect inclusion of the GCC one, as its contents is useless to
     us and it depends on several other headers that we don't have at hand.  */
! #include <arch/../regs.h>
  #define GCC_REGS_H
  
  #include <sigLib.h>
*************** sigcontext_for (struct _Unwind_Context *
*** 74,84 ****
         && *(ra - 1) == 0x4e800021   /* blrl */
         && *(ra - 0) == 0x7fc3f378)) /* or     r3,r30,r30 */
      {
! 	struct {
! 	    char pad [0x40];
! 	    sigcontext_t sigcontext;
! 	} * frame = context->cfa;
! 	return &frame->sigcontext;
      }
  
    return 0;
--- 74,131 ----
         && *(ra - 1) == 0x4e800021   /* blrl */
         && *(ra - 0) == 0x7fc3f378)) /* or     r3,r30,r30 */
      {
!       struct {
! 	char pad [0x40];
! 	sigcontext_t sigcontext;
!       } * frame = context->cfa;
!       return &frame->sigcontext;
!     }
! 
!   /* Vxworks 6.4, 6.5.  */
!   if (*(ra - 5) == 0x809e0018       /* lwz         r4,24(r30) */
!       && *(ra - 4) == 0x7fa903a6    /* mtspr       CTR,r29 */
!       && *(ra - 3) == 0x38be0000    /* addi        r5,r30,0x0 */
!       && *(ra - 2) == 0x387f0000    /* addi        r3,r31,0x0 */
!       && *(ra - 1) == 0x4e800421    /* bcctrl      0x14,0 */
!       && *(ra - 0) == 0x387e0000    /* addi        r3,r30,0x0 */
!       && *(ra + 1) == 0x39610020)   /* addi        r11,r1,0x20  */
!     {
!       struct {
! 	char pad [0x30];
! 	sigcontext_t sigcontext;
!       } * frame = context->cfa;
!       return &frame->sigcontext;
!     }
! 
!   /* Vxworks 6.6.  */
!   if (*(ra - 7) == 0x389e0010       /* addi        r4,r30,0x10 */
!       && *(ra - 5) == 0x809e0018    /* lwz         r4,24(r30) */
!       && *(ra - 4) == 0x7fa903a6    /* mtspr       CTR,r29 */
!       && *(ra - 3) == 0x38be0000    /* addi        r5,r30,0x0 */
!       && *(ra - 2) == 0x387f0000    /* addi        r3,r31,0x0 */
!       && *(ra - 1) == 0x4e800421    /* bcctrl      0x14,0 */
!       && *(ra - 0) == 0x387e0000)   /* addi        r3,r30,0x0 */
!     {
!       struct {
! 	char pad [0x2];
! 	sigcontext_t sigcontext;
!       } * frame = context->cfa;
!       return &frame->sigcontext;
!     }
! 
!   /* VxWorks 6.7.  */
!   if (*(ra - 5) == 0x809f0018       /* lwz         r4,24(r31) */
!       && *(ra - 4) == 0x7fc903a6    /* mtspr       CTR,r30 */
!       && *(ra - 3) == 0x38bf0000    /* addi        r5,r31,0x0 */
!       && *(ra - 2) == 0x387d0000    /* addi        r3,r29,0x0 */
!       && *(ra - 1) == 0x4e800421    /* bcctrl      0x14,0 */
!       && *(ra - 0) == 0x387f0000)    /* addi        r3,r31,0x0 */
!     {
!       struct {
! 	char pad [0x38];
! 	sigcontext_t sigcontext;
!       } * frame = context->cfa;
!       return &frame->sigcontext;
      }
  
    return 0;
*** gcc/gimplify.c.0	2009-03-18 12:02:08.000000000 +0100
--- gcc/gimplify.c	2009-03-18 12:26:31.000000000 +0100
*************** gimplify_init_constructor (tree *expr_p,
*** 3433,3439 ****
  	    else
  	      align = TYPE_ALIGN (type);
  
! 	    if (size > 0 && !can_move_by_pieces (size, align))
  	      {
  		tree new;
  
--- 3433,3443 ----
  	    else
  	      align = TYPE_ALIGN (type);
  
! 	    /* Do a block move either if the size is so small as to make
! 	       each individual move a sub-unit move on average, or if it
! 	       is so large as to make individual moves inefficient.  */
! 	    if (size > 0 && (size < num_type_elements
! 			     || !can_move_by_pieces (size, align)))
  	      {
  		tree new;
  
*************** gimplify_modify_expr_rhs (tree *expr_p, 
*** 3699,3709 ****
      switch (TREE_CODE (*from_p))
        {
        case VAR_DECL:
! 	/* If we're assigning from a constant constructor, move the
! 	   constructor expression to the RHS of the MODIFY_EXPR.  */
  	if (DECL_INITIAL (*from_p)
  	    && TREE_READONLY (*from_p)
  	    && !TREE_THIS_VOLATILE (*from_p)
  	    && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)
  	  {
  	    tree old_from = *from_p;
--- 3703,3716 ----
      switch (TREE_CODE (*from_p))
        {
        case VAR_DECL:
! 	/* If we're assigning from a read-only variable initialized with
! 	   a constructor, do the direct assignment from the constructor,
! 	   but only if neither source nor target are volatile since this
! 	   latter assignment might end up being done on a per-field basis.  */
  	if (DECL_INITIAL (*from_p)
  	    && TREE_READONLY (*from_p)
  	    && !TREE_THIS_VOLATILE (*from_p)
+ 	    && !TREE_THIS_VOLATILE (*to_p)
  	    && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)
  	  {
  	    tree old_from = *from_p;
*** gcc/tree-ssa.c.0	2009-03-22 19:55:48.000000000 +0100
--- gcc/tree-ssa.c	2009-03-22 21:05:16.000000000 +0100
*************** useless_type_conversion_p_1 (tree outer_
*** 949,954 ****
--- 949,976 ----
  	      || TREE_TYPE (outer_type) == NULL_TREE))
  	return false;
  
+       /* ??? Conversions between non-base types are not useless if the
+ 	 bounds are all constant and the target range is not a subset
+ 	 of the source range.  That's somewhat artifical a criterion as
+ 	 there is no invariant to be preserved in this case, but yields
+ 	 the property that a pair of non-base types with constant bounds
+ 	 are compatible if and only if their ranges are equal.  This will
+ 	 guarantee that passes substituting SSA names correctly preserve
+ 	 constant ranges for VRP.  */
+       if (TREE_TYPE (inner_type)
+ 	  && TREE_TYPE (inner_type) != inner_type
+ 	  && TREE_TYPE(outer_type)
+ 	  && TREE_TYPE (outer_type) != outer_type
+ 	  && TREE_CODE (TYPE_MIN_VALUE (inner_type)) == INTEGER_CST
+ 	  && TREE_CODE (TYPE_MAX_VALUE (inner_type)) == INTEGER_CST
+ 	  && TREE_CODE (TYPE_MIN_VALUE (outer_type)) == INTEGER_CST
+ 	  && TREE_CODE (TYPE_MAX_VALUE (outer_type)) == INTEGER_CST
+ 	  && (tree_int_cst_lt (TYPE_MIN_VALUE (outer_type),
+ 			       TYPE_MIN_VALUE (inner_type))
+ 	      || tree_int_cst_lt (TYPE_MAX_VALUE (inner_type),
+ 				  TYPE_MAX_VALUE (outer_type))))
+ 	return false;
+ 
        /* We don't need to preserve changes in the types minimum or
  	 maximum value in general as these do not generate code
  	 unless the types precisions are different.  */
*** gcc/gcov.c.old	Thu Nov  6 17:16:22 2008
--- gcc/gcov.c	Tue Mar 24 14:52:19 2009
***************
*** 758,766 ****
    if (!file_name)
      file_name = "<unknown>";
  
!   for (src = sources; src; src = src->next)
      if (!strcmp (file_name, src->name))
        break;
  
    if (!src)
      {
--- 758,772 ----
    if (!file_name)
      file_name = "<unknown>";
  
!   for (src = sources; src; src = src->next) {
! #ifdef _WIN32
!     if (!strcasecmp (file_name, src->name))
!       break;
! #else
      if (!strcmp (file_name, src->name))
        break;
+ #endif
+   }
  
    if (!src)
      {
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** dump_generic_ada_node (pretty_printer *b
*** 1287,1293 ****
  		        pp_string (buffer, "all ");
  		    }
  
! 	          if (is_struct_like (TREE_TYPE (node)))
  		    { 
  		      tree name = TYPE_NAME (TREE_TYPE (node));
  		      tree tmp;
--- 1287,1294 ----
  		        pp_string (buffer, "all ");
  		    }
  
! 	          if (is_struct_like (TREE_TYPE (node))
! 		      && TYPE_NAME (TREE_TYPE (node)))
  		    { 
  		      tree name = TYPE_NAME (TREE_TYPE (node));
  		      tree tmp;
*************** dump_nested_types (pretty_printer *buffe
*** 1582,1588 ****
  		break;
  
  	      case RECORD_TYPE:
! 		if (!found)
  		  {
  		    found = true;
  		    pp_string (buffer, "type ");
--- 1583,1589 ----
  		break;
  
  	      case RECORD_TYPE:
! 		if (!found && TYPE_NAME (TREE_TYPE (t)))
  		  {
  		    found = true;
  		    pp_string (buffer, "type ");
*************** print_ada_struct_decl (pretty_printer *b
*** 2168,2174 ****
  	  /* Add parent field if needed */
  	  if (!DECL_NAME (tmp))
  	    {
! 	      if (!is_tagged_type (TREE_TYPE (tmp)))
  		{
  	          INDENT (spc + INDENT_INCR);
  
--- 2169,2176 ----
  	  /* Add parent field if needed */
  	  if (!DECL_NAME (tmp))
  	    {
! 	      if (!is_tagged_type (TREE_TYPE (tmp))
! 		  && TYPE_NAME (TREE_TYPE (tmp)))
  		{
  	          INDENT (spc + INDENT_INCR);
  
*** gcc/c-parser.c.0	2009-03-30 13:14:53.000000000 +0200
--- gcc/c-parser.c	2009-03-30 21:06:49.000000000 +0200
*************** c_parser_statement_after_labels (c_parse
*** 3910,3924 ****
  static tree
  c_parser_paren_condition (c_parser *parser)
  {
-   location_t loc;
    tree cond;
    if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
      return error_mark_node;
-   loc = c_parser_peek_token (parser)->location;
    cond = c_objc_common_truthvalue_conversion
      (c_parser_expression_conv (parser).value);
-   if (CAN_HAVE_LOCATION_P (cond))
-     SET_EXPR_LOCATION (cond, loc);
    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, "expected %<)%>");
    return cond;
  }
--- 3910,3920 ----
*************** c_parser_binary_expression (c_parser *pa
*** 4667,4672 ****
--- 4663,4670 ----
      enum prec prec;
      /* The operation on its left.  */
      enum tree_code op;
+     /* The source location of this operation.  */
+     location_t loc;
    } stack[NUM_PRECS];
    int sp;
  #define POP								      \
*************** c_parser_binary_expression (c_parser *pa
*** 4689,4694 ****
--- 4687,4694 ----
      stack[sp - 1].expr = parser_build_binary_op (stack[sp].op,		      \
  						 stack[sp - 1].expr,	      \
  						 stack[sp].expr);	      \
+     if (CAN_HAVE_LOCATION_P (stack[sp-1].expr.value))			      \
+       SET_EXPR_LOCATION (stack[sp-1].expr.value, stack[sp].loc);	      \
      sp--;								      \
    } while (0)
    gcc_assert (!after || c_dialect_objc ());
*************** c_parser_binary_expression (c_parser *pa
*** 4699,4704 ****
--- 4699,4705 ----
      {
        enum prec oprec;
        enum tree_code ocode;
+       location_t loc;
        if (parser->error)
  	goto out;
        switch (c_parser_peek_token (parser)->type)
*************** c_parser_binary_expression (c_parser *pa
*** 4780,4785 ****
--- 4781,4787 ----
  	     expression.  */
  	  goto out;
  	}
+       loc = c_parser_peek_token (parser)->location;
        c_parser_consume_token (parser);
        while (oprec <= stack[sp].prec)
  	POP;
*************** c_parser_binary_expression (c_parser *pa
*** 4804,4809 ****
--- 4806,4812 ----
  	}
        sp++;
        stack[sp].expr = c_parser_cast_expression (parser, NULL);
+       stack[sp].loc = loc;
        stack[sp].prec = oprec;
        stack[sp].op = ocode;
      }
*** gcc/fold-const.c.0	2009-03-30 21:04:51.000000000 +0200
--- gcc/fold-const.c	2009-03-30 21:20:06.000000000 +0200
*************** omit_two_operands (tree type, tree resul
*** 3626,3632 ****
  tree
  fold_truth_not_expr (tree arg)
  {
!   tree type = TREE_TYPE (arg);
    enum tree_code code = TREE_CODE (arg);
  
    /* If this is a comparison, we can simply invert it, except for
--- 3626,3632 ----
  tree
  fold_truth_not_expr (tree arg)
  {
!   tree t, type = TREE_TYPE (arg);
    enum tree_code code = TREE_CODE (arg);
  
    /* If this is a comparison, we can simply invert it, except for
*************** fold_truth_not_expr (tree arg)
*** 3641,3656 ****
  	  && code != ORDERED_EXPR && code != UNORDERED_EXPR
  	  && code != NE_EXPR && code != EQ_EXPR)
  	return NULL_TREE;
!       else
! 	{
! 	  code = invert_tree_comparison (code,
! 					 HONOR_NANS (TYPE_MODE (op_type)));
! 	  if (code == ERROR_MARK)
! 	    return NULL_TREE;
! 	  else
! 	    return build2 (code, type,
! 			   TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));
! 	}
      }
  
    switch (code)
--- 3641,3655 ----
  	  && code != ORDERED_EXPR && code != UNORDERED_EXPR
  	  && code != NE_EXPR && code != EQ_EXPR)
  	return NULL_TREE;
! 
!       code = invert_tree_comparison (code, HONOR_NANS (TYPE_MODE (op_type)));
!       if (code == ERROR_MARK)
! 	return NULL_TREE;
! 
!       t = build2 (code, type, TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));
!       if (EXPR_HAS_LOCATION (arg))
! 	SET_EXPR_LOCUS (t, EXPR_LOCUS (arg));
!       return t;
      }
  
    switch (code)
*************** fold_truth_not_expr (tree arg)
*** 3659,3672 ****
        return constant_boolean_node (integer_zerop (arg), type);
  
      case TRUTH_AND_EXPR:
!       return build2 (TRUTH_OR_EXPR, type,
! 		     invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		     invert_truthvalue (TREE_OPERAND (arg, 1)));
  
      case TRUTH_OR_EXPR:
!       return build2 (TRUTH_AND_EXPR, type,
! 		     invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		     invert_truthvalue (TREE_OPERAND (arg, 1)));
  
      case TRUTH_XOR_EXPR:
        /* Here we can invert either operand.  We invert the first operand
--- 3658,3673 ----
        return constant_boolean_node (integer_zerop (arg), type);
  
      case TRUTH_AND_EXPR:
!       t = build2 (TRUTH_OR_EXPR, type,
! 		  invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		  invert_truthvalue (TREE_OPERAND (arg, 1)));
!       break;
  
      case TRUTH_OR_EXPR:
!       t = build2 (TRUTH_AND_EXPR, type,
! 		  invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		  invert_truthvalue (TREE_OPERAND (arg, 1)));
!       break;
  
      case TRUTH_XOR_EXPR:
        /* Here we can invert either operand.  We invert the first operand
*************** fold_truth_not_expr (tree arg)
*** 3675,3696 ****
  	 negation of the second operand.  */
  
        if (TREE_CODE (TREE_OPERAND (arg, 1)) == TRUTH_NOT_EXPR)
! 	return build2 (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),
! 		       TREE_OPERAND (TREE_OPERAND (arg, 1), 0));
        else
! 	return build2 (TRUTH_XOR_EXPR, type,
! 		       invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		       TREE_OPERAND (arg, 1));
  
      case TRUTH_ANDIF_EXPR:
!       return build2 (TRUTH_ORIF_EXPR, type,
! 		     invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		     invert_truthvalue (TREE_OPERAND (arg, 1)));
  
      case TRUTH_ORIF_EXPR:
!       return build2 (TRUTH_ANDIF_EXPR, type,
! 		     invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		     invert_truthvalue (TREE_OPERAND (arg, 1)));
  
      case TRUTH_NOT_EXPR:
        return TREE_OPERAND (arg, 0);
--- 3676,3700 ----
  	 negation of the second operand.  */
  
        if (TREE_CODE (TREE_OPERAND (arg, 1)) == TRUTH_NOT_EXPR)
! 	t = build2 (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),
! 		    TREE_OPERAND (TREE_OPERAND (arg, 1), 0));
        else
! 	t = build2 (TRUTH_XOR_EXPR, type,
! 		    invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		    TREE_OPERAND (arg, 1));
!       break;
  
      case TRUTH_ANDIF_EXPR:
!       t = build2 (TRUTH_ORIF_EXPR, type,
! 		  invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		  invert_truthvalue (TREE_OPERAND (arg, 1)));
!       break;
  
      case TRUTH_ORIF_EXPR:
!       t = build2 (TRUTH_ANDIF_EXPR, type,
! 		  invert_truthvalue (TREE_OPERAND (arg, 0)),
! 		  invert_truthvalue (TREE_OPERAND (arg, 1)));
!       break;
  
      case TRUTH_NOT_EXPR:
        return TREE_OPERAND (arg, 0);
*************** fold_truth_not_expr (tree arg)
*** 3702,3748 ****
  	/* A COND_EXPR may have a throw as one operand, which
  	   then has void type.  Just leave void operands
  	   as they are.  */
! 	return build3 (COND_EXPR, type, TREE_OPERAND (arg, 0),
! 		       VOID_TYPE_P (TREE_TYPE (arg1))
! 		       ? arg1 : invert_truthvalue (arg1),
! 		       VOID_TYPE_P (TREE_TYPE (arg2))
! 		       ? arg2 : invert_truthvalue (arg2));
        }
  
      case COMPOUND_EXPR:
!       return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),
! 		     invert_truthvalue (TREE_OPERAND (arg, 1)));
  
      case NON_LVALUE_EXPR:
        return invert_truthvalue (TREE_OPERAND (arg, 0));
  
      case NOP_EXPR:
        if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)
! 	return build1 (TRUTH_NOT_EXPR, type, arg);
  
      case CONVERT_EXPR:
      case FLOAT_EXPR:
!       return build1 (TREE_CODE (arg), type,
! 		     invert_truthvalue (TREE_OPERAND (arg, 0)));
  
      case BIT_AND_EXPR:
        if (!integer_onep (TREE_OPERAND (arg, 1)))
! 	break;
!       return build2 (EQ_EXPR, type, arg,
! 		     build_int_cst (type, 0));
  
      case SAVE_EXPR:
!       return build1 (TRUTH_NOT_EXPR, type, arg);
  
      case CLEANUP_POINT_EXPR:
!       return build1 (CLEANUP_POINT_EXPR, type,
! 		     invert_truthvalue (TREE_OPERAND (arg, 0)));
  
      default:
        break;
      }
  
!   return NULL_TREE;
  }
  
  /* Return a simplified tree node for the truth-negation of ARG.  This
--- 3706,3766 ----
  	/* A COND_EXPR may have a throw as one operand, which
  	   then has void type.  Just leave void operands
  	   as they are.  */
! 	t = build3 (COND_EXPR, type, TREE_OPERAND (arg, 0),
! 		    VOID_TYPE_P (TREE_TYPE (arg1))
! 		    ? arg1 : invert_truthvalue (arg1),
! 		    VOID_TYPE_P (TREE_TYPE (arg2))
! 		    ? arg2 : invert_truthvalue (arg2));
! 	break;
        }
  
      case COMPOUND_EXPR:
!       t = build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),
! 		  invert_truthvalue (TREE_OPERAND (arg, 1)));
!       break;
  
      case NON_LVALUE_EXPR:
        return invert_truthvalue (TREE_OPERAND (arg, 0));
  
      case NOP_EXPR:
        if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)
! 	{
! 	  t = build1 (TRUTH_NOT_EXPR, type, arg);
! 	  break;
! 	}
! 
!       /* ... fall through ...  */
  
      case CONVERT_EXPR:
      case FLOAT_EXPR:
!       t = build1 (TREE_CODE (arg), type,
! 		  invert_truthvalue (TREE_OPERAND (arg, 0)));
!       break;
  
      case BIT_AND_EXPR:
        if (!integer_onep (TREE_OPERAND (arg, 1)))
! 	return NULL_TREE;
!       t = build2 (EQ_EXPR, type, arg, build_int_cst (type, 0));
!       break;
  
      case SAVE_EXPR:
!       t = build1 (TRUTH_NOT_EXPR, type, arg);
!       break;
  
      case CLEANUP_POINT_EXPR:
!       t = build1 (CLEANUP_POINT_EXPR, type,
! 		  invert_truthvalue (TREE_OPERAND (arg, 0)));
!       break;
  
      default:
+       t = NULL_TREE;
        break;
      }
  
!   if (t && EXPR_HAS_LOCATION (arg))
!     SET_EXPR_LOCUS (t, EXPR_LOCUS (arg));
! 
!   return t;
  }
  
  /* Return a simplified tree node for the truth-negation of ARG.  This
*** gcc/tree.h.0	2009-04-01 11:32:22.000000000 +0200
--- gcc/tree.h	2009-04-01 11:33:32.000000000 +0200
*************** struct phi_arg_d GTY(())
*** 1990,1995 ****
--- 1990,1996 ----
       pointer arithmetic with it.  See phi_arg_index_from_use.  */
    struct ssa_use_operand_d imm_use;
    tree def;
+   location_t locus;
  };
  
  struct tree_phi_node GTY(())
*** gcc/tree-flow-inline.h.0	2009-04-01 11:32:22.000000000 +0200
--- gcc/tree-flow-inline.h	2009-04-01 11:46:51.000000000 +0200
*************** get_phi_arg_def_ptr (tree phi, int i)
*** 573,578 ****
--- 573,599 ----
    return &(PHI_ARG_IMM_USE_NODE (phi,i));
  }
  
+ /* Return the source location of argument I of phi node PHI.  */
+ static inline location_t
+ phi_arg_location (tree phi, int i)
+ {
+   return PHI_ARG_ELT (phi,i).locus;
+ }
+ 
+ /* Set the source location of argument I of phi node PHI to LOC.  */
+ static inline void
+ phi_arg_set_location (tree phi, int i, location_t loc)
+ {
+   PHI_ARG_ELT (phi,i).locus = loc;
+ }
+ 
+ /* Return TRUE if argument I of phi node PHI has a location record.  */
+ static inline bool
+ phi_arg_has_location (tree phi, int i)
+ {
+   return phi_arg_location (phi,i) != UNKNOWN_LOCATION;
+ }
+ 
  
  /* Return the bitmap of addresses taken by STMT, or NULL if it takes
     no addresses.  */
*** gcc/tree-cfgcleanup.c.0	2009-04-01 12:46:28.000000000 +0200
--- gcc/tree-cfgcleanup.c	2009-04-01 12:48:17.000000000 +0200
*************** remove_forwarder_block (basic_block bb)
*** 432,438 ****
  	  /* Create arguments for the phi nodes, since the edge was not
  	     here before.  */
  	  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))
! 	    add_phi_arg (phi, PHI_ARG_DEF (phi, succ->dest_idx), s);
  	}
      }
  
--- 432,442 ----
  	  /* Create arguments for the phi nodes, since the edge was not
  	     here before.  */
  	  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))
! 	    {
! 	      location_t locus = phi_arg_location (phi, succ->dest_idx);
! 	      add_phi_arg (phi, PHI_ARG_DEF (phi, succ->dest_idx), s);
! 	      phi_arg_set_location (phi, s->dest_idx, locus);
! 	    }
  	}
      }
  
*** gcc/tree-inline.c.0	2009-04-01 12:48:35.000000000 +0200
--- gcc/tree-inline.c	2009-04-01 12:54:24.000000000 +0200
*************** copy_phis_for_bb (basic_block bb, copy_b
*** 1238,1243 ****
--- 1238,1244 ----
        tree new_res = res;
        tree new_phi;
        edge new_edge;
+       int i;
  
        if (is_gimple_reg (res))
  	{
*************** copy_phis_for_bb (basic_block bb, copy_b
*** 1265,1270 ****
--- 1266,1277 ----
  		}
  	      add_phi_arg (new_phi, new_arg, new_edge);
  	    }
+ 	  /* Duplicate the locus's on each inlined argument.  */
+ 	  for (i = 0; i < PHI_NUM_ARGS (new_phi); i++)
+ 	    {
+ 	      location_t locus = phi_arg_location (phi, i);
+ 	      phi_arg_set_location (new_phi, i, locus);
+ 	    }
  	}
      }
  }
*************** self_inlining_addr_expr (tree value, tre
*** 1465,1471 ****
  
  static void
  setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,
! 		     basic_block bb, tree *vars)
  {
    tree init_stmt;
    tree var;
--- 1472,1478 ----
  
  static void
  setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,
! 		     basic_block bb, tree *vars, location_t call_locus)
  {
    tree init_stmt;
    tree var;
*************** setup_one_parameter (copy_body_data *id,
*** 1638,1643 ****
--- 1645,1653 ----
        else
          init_stmt = build_gimple_modify_stmt (var, rhs);
  
+       /* Set the source location.  */
+       SET_EXPR_LOCATION (init_stmt, call_locus);
+ 
        /* If we did not create a gimple value and we did not create a gimple
  	 cast of a gimple value, then we will need to gimplify INIT_STMTS
  	 at the end.  Note that is_gimple_cast only checks the outer
*************** initialize_inlined_parameters (copy_body
*** 1686,1691 ****
--- 1696,1702 ----
    tree vars = NULL_TREE;
    call_expr_arg_iterator iter;
    tree static_chain = CALL_EXPR_STATIC_CHAIN (exp);
+   location_t locus = EXPR_LOCATION (exp);
  
    /* Figure out what the parameters are.  */
    parms = DECL_ARGUMENTS (fn);
*************** initialize_inlined_parameters (copy_body
*** 1694,1700 ****
       equivalent VAR_DECL, appropriately initialized.  */
    for (p = parms, a = first_call_expr_arg (exp, &iter); p;
         a = next_call_expr_arg (&iter), p = TREE_CHAIN (p))
!     setup_one_parameter (id, p, a, fn, bb, &vars);
  
    /* Initialize the static chain.  */
    p = DECL_STRUCT_FUNCTION (fn)->static_chain_decl;
--- 1705,1711 ----
       equivalent VAR_DECL, appropriately initialized.  */
    for (p = parms, a = first_call_expr_arg (exp, &iter); p;
         a = next_call_expr_arg (&iter), p = TREE_CHAIN (p))
!     setup_one_parameter (id, p, a, fn, bb, &vars, locus);
  
    /* Initialize the static chain.  */
    p = DECL_STRUCT_FUNCTION (fn)->static_chain_decl;
*************** initialize_inlined_parameters (copy_body
*** 1704,1710 ****
        /* No static chain?  Seems like a bug in tree-nested.c.  */
        gcc_assert (static_chain);
  
!       setup_one_parameter (id, p, static_chain, fn, bb, &vars);
      }
  
    declare_inline_vars (id->block, vars);
--- 1715,1721 ----
        /* No static chain?  Seems like a bug in tree-nested.c.  */
        gcc_assert (static_chain);
  
!       setup_one_parameter (id, p, static_chain, fn, bb, &vars, locus);
      }
  
    declare_inline_vars (id->block, vars);
*** gcc/tree-into-ssa.c.0	2009-04-01 11:32:22.000000000 +0200
--- gcc/tree-into-ssa.c	2009-04-01 11:55:03.000000000 +0200
*************** rewrite_add_phi_arguments (struct dom_wa
*** 1404,1412 ****
  
        for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))
  	{
! 	  tree currdef;
  	  currdef = get_reaching_def (SSA_NAME_VAR (PHI_RESULT (phi)));
  	  add_phi_arg (phi, currdef, e);
  	}
      }
  }
--- 1404,1421 ----
  
        for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))
  	{
! 	  tree currdef, stmt;
  	  currdef = get_reaching_def (SSA_NAME_VAR (PHI_RESULT (phi)));
  	  add_phi_arg (phi, currdef, e);
+ 
+ 	  /* If there is a source location, add it to the phi argument.  */
+ 	  stmt = SSA_NAME_DEF_STMT (currdef);
+ 	  if (EXPR_HAS_LOCATION (stmt))
+ 	    {
+ 	      use_operand_p use = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);
+ 	      int index = PHI_ARG_INDEX_FROM_USE (use);
+ 	      phi_arg_set_location (phi, index, EXPR_LOCATION (stmt));
+ 	    }
  	}
      }
  }
*** gcc/tree-outof-ssa.c.0	2009-04-01 11:32:22.000000000 +0200
--- gcc/tree-outof-ssa.c	2009-04-01 12:28:59.000000000 +0200
*************** along with GCC; see the file COPYING3.  
*** 35,40 ****
--- 35,43 ----
  #include "toplev.h"
  
  
+ DEF_VEC_I(location_t);
+ DEF_VEC_ALLOC_I(location_t,heap);
+ 
  /* Used to hold all the components required to do SSA PHI elimination.
     The node and pred/succ list is a simple linear list of nodes and
     edges represented as pairs of nodes.
*************** typedef struct _elim_graph {
*** 66,71 ****
--- 69,77 ----
    /*  The predecessor and successor edge list.  */
    VEC(int,heap) *edge_list;
  
+   /* Source locus on each edge */
+   VEC(location_t,heap) *edge_locus;
+ 
    /* Visited vector.  */
    sbitmap visited;
  
*************** typedef struct _elim_graph {
*** 80,85 ****
--- 86,94 ----
  
    /* List of constant copies to emit.  These are pushed on in pairs.  */
    VEC(tree,heap) *const_copies;
+ 
+   /* Source locations for any constant copies.  */
+   VEC(location_t,heap) *copy_locus;
  } *elim_graph;
  
  
*************** create_temp (tree t)
*** 137,148 ****
     variable DEST on edge E.  */
  
  static void
! insert_copy_on_edge (edge e, tree dest, tree src)
  {
    tree copy;
  
    copy = build_gimple_modify_stmt (dest, src);
    set_is_used (dest);
  
    if (TREE_CODE (src) == ADDR_EXPR)
      src = TREE_OPERAND (src, 0);
--- 146,158 ----
     variable DEST on edge E.  */
  
  static void
! insert_copy_on_edge (edge e, tree dest, tree src, location_t locus)
  {
    tree copy;
  
    copy = build_gimple_modify_stmt (dest, src);
    set_is_used (dest);
+   SET_EXPR_LOCATION (copy, locus);
  
    if (TREE_CODE (src) == ADDR_EXPR)
      src = TREE_OPERAND (src, 0);
*************** new_elim_graph (int size)
*** 173,179 ****
--- 183,191 ----
  
    g->nodes = VEC_alloc (tree, heap, 30);
    g->const_copies = VEC_alloc (tree, heap, 20);
+   g->copy_locus = VEC_alloc (location_t, heap, 10);
    g->edge_list = VEC_alloc (int, heap, 20);
+   g->edge_locus = VEC_alloc (location_t, heap, 10);
    g->stack = VEC_alloc (int, heap, 30);
    
    g->visited = sbitmap_alloc (size);
*************** clear_elim_graph (elim_graph g)
*** 189,194 ****
--- 201,207 ----
  {
    VEC_truncate (tree, g->nodes, 0);
    VEC_truncate (int, g->edge_list, 0);
+   VEC_truncate (location_t, g->edge_locus, 0);
  }
  
  
*************** delete_elim_graph (elim_graph g)
*** 202,207 ****
--- 215,222 ----
    VEC_free (int, heap, g->edge_list);
    VEC_free (tree, heap, g->const_copies);
    VEC_free (tree, heap, g->nodes);
+   VEC_free (location_t, heap, g->copy_locus);
+   VEC_free (location_t, heap, g->edge_locus);
    free (g);
  }
  
*************** elim_graph_add_node (elim_graph g, tree 
*** 233,242 ****
  /* Add the edge PRED->SUCC to graph G.  */
  
  static inline void
! elim_graph_add_edge (elim_graph g, int pred, int succ)
  {
    VEC_safe_push (int, heap, g->edge_list, pred);
    VEC_safe_push (int, heap, g->edge_list, succ);
  }
  
  
--- 248,258 ----
  /* Add the edge PRED->SUCC to graph G.  */
  
  static inline void
! elim_graph_add_edge (elim_graph g, int pred, int succ, location_t locus)
  {
    VEC_safe_push (int, heap, g->edge_list, pred);
    VEC_safe_push (int, heap, g->edge_list, succ);
+   VEC_safe_push (location_t, heap, g->edge_locus, locus);
  }
  
  
*************** elim_graph_add_edge (elim_graph g, int p
*** 244,250 ****
     return the successor node.  -1 is returned if there is no such edge.  */
  
  static inline int
! elim_graph_remove_succ_edge (elim_graph g, int node)
  {
    int y;
    unsigned x;
--- 260,266 ----
     return the successor node.  -1 is returned if there is no such edge.  */
  
  static inline int
! elim_graph_remove_succ_edge (elim_graph g, int node, location_t *locus)
  {
    int y;
    unsigned x;
*************** elim_graph_remove_succ_edge (elim_graph 
*** 254,261 ****
--- 270,280 ----
          VEC_replace (int, g->edge_list, x, -1);
  	y = VEC_index (int, g->edge_list, x + 1);
  	VEC_replace (int, g->edge_list, x + 1, -1);
+ 	*locus = VEC_index (location_t, g->edge_locus, x / 2);
+ 	VEC_replace (location_t, g->edge_locus, x / 2, UNKNOWN_LOCATION);
  	return y;
        }
+   *locus = UNKNOWN_LOCATION;
    return -1;
  }
  
*************** elim_graph_remove_succ_edge (elim_graph 
*** 264,270 ****
     edge list.  VAR will hold the partition number found.  CODE is the
     code fragment executed for every node found.  */
  
! #define FOR_EACH_ELIM_GRAPH_SUCC(GRAPH, NODE, VAR, CODE)		\
  do {									\
    unsigned x_;								\
    int y_;								\
--- 283,289 ----
     edge list.  VAR will hold the partition number found.  CODE is the
     code fragment executed for every node found.  */
  
! #define FOR_EACH_ELIM_GRAPH_SUCC(GRAPH, NODE, VAR, LOCUS, CODE)		\
  do {									\
    unsigned x_;								\
    int y_;								\
*************** do {									\
*** 274,279 ****
--- 293,299 ----
        if (y_ != (NODE))							\
          continue;							\
        (VAR) = VEC_index (int, (GRAPH)->edge_list, x_ + 1);		\
+       (LOCUS) = VEC_index (location_t, (GRAPH)->edge_locus, x_ / 2);	\
        CODE;								\
      }									\
  } while (0)
*************** do {									\
*** 283,289 ****
     GRAPH.  VAR will hold the partition number found.  CODE is the
     code fragment executed for every node found.  */
  
! #define FOR_EACH_ELIM_GRAPH_PRED(GRAPH, NODE, VAR, CODE)		\
  do {									\
    unsigned x_;								\
    int y_;								\
--- 303,309 ----
     GRAPH.  VAR will hold the partition number found.  CODE is the
     code fragment executed for every node found.  */
  
! #define FOR_EACH_ELIM_GRAPH_PRED(GRAPH, NODE, VAR, LOCUS, CODE)		\
  do {									\
    unsigned x_;								\
    int y_;								\
*************** do {									\
*** 293,298 ****
--- 313,319 ----
        if (y_ != (NODE))							\
          continue;							\
        (VAR) = VEC_index (int, (GRAPH)->edge_list, x_);			\
+       (LOCUS) = VEC_index (location_t, (GRAPH)->edge_locus, x_ / 2);	\
        CODE;								\
      }									\
  } while (0)
*************** eliminate_build (elim_graph g, basic_blo
*** 316,321 ****
--- 337,343 ----
    tree phi;
    tree T0, Ti;
    int p0, pi;
+   location_t locus;
  
    clear_elim_graph (g);
    
*************** eliminate_build (elim_graph g, basic_blo
*** 328,333 ****
--- 350,356 ----
  	continue;
  
        Ti = PHI_ARG_DEF (phi, g->e->dest_idx);
+       locus = phi_arg_location (phi, g->e->dest_idx);
  
        /* If this argument is a constant, or a SSA_NAME which is being
  	 left in SSA form, just queue a copy to be emitted on this
*************** eliminate_build (elim_graph g, basic_blo
*** 340,345 ****
--- 363,369 ----
  	     on this edge.  */
  	  VEC_safe_push (tree, heap, g->const_copies, T0);
  	  VEC_safe_push (tree, heap, g->const_copies, Ti);
+ 	  VEC_safe_push (location_t, heap, g->copy_locus, locus);
  	}
        else
          {
*************** eliminate_build (elim_graph g, basic_blo
*** 350,356 ****
  	      eliminate_name (g, Ti);
  	      p0 = var_to_partition (g->map, T0);
  	      pi = var_to_partition (g->map, Ti);
! 	      elim_graph_add_edge (g, p0, pi);
  	    }
  	}
      }
--- 374,380 ----
  	      eliminate_name (g, Ti);
  	      p0 = var_to_partition (g->map, T0);
  	      pi = var_to_partition (g->map, Ti);
! 	      elim_graph_add_edge (g, p0, pi, locus);
  	    }
  	}
      }
*************** static void 
*** 363,370 ****
  elim_forward (elim_graph g, int T)
  {
    int S;
    SET_BIT (g->visited, T);
!   FOR_EACH_ELIM_GRAPH_SUCC (g, T, S,
      {
        if (!TEST_BIT (g->visited, S))
          elim_forward (g, S);
--- 387,396 ----
  elim_forward (elim_graph g, int T)
  {
    int S;
+   location_t locus;
+ 
    SET_BIT (g->visited, T);
!   FOR_EACH_ELIM_GRAPH_SUCC (g, T, S, locus,
      {
        if (!TEST_BIT (g->visited, S))
          elim_forward (g, S);
*************** static int
*** 379,385 ****
  elim_unvisited_predecessor (elim_graph g, int T)
  {
    int P;
!   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, 
      {
        if (!TEST_BIT (g->visited, P))
          return 1;
--- 405,413 ----
  elim_unvisited_predecessor (elim_graph g, int T)
  {
    int P;
!   location_t locus;
! 
!   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,
      {
        if (!TEST_BIT (g->visited, P))
          return 1;
*************** static void
*** 393,407 ****
  elim_backward (elim_graph g, int T)
  {
    int P;
    SET_BIT (g->visited, T);
!   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, 
      {
        if (!TEST_BIT (g->visited, P))
          {
  	  elim_backward (g, P);
  	  insert_copy_on_edge (g->e, 
  			       partition_to_var (g->map, P), 
! 			       partition_to_var (g->map, T));
  	}
      });
  }
--- 421,438 ----
  elim_backward (elim_graph g, int T)
  {
    int P;
+   location_t locus;
+ 
    SET_BIT (g->visited, T);
!   FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,
      {
        if (!TEST_BIT (g->visited, P))
          {
  	  elim_backward (g, P);
  	  insert_copy_on_edge (g->e, 
  			       partition_to_var (g->map, P), 
! 			       partition_to_var (g->map, T),
! 			       locus);
  	}
      });
  }
*************** elim_create (elim_graph g, int T)
*** 414,442 ****
  {
    tree U;
    int P, S;
  
    if (elim_unvisited_predecessor (g, T))
      {
        U = create_temp (partition_to_var (g->map, T));
!       insert_copy_on_edge (g->e, U, partition_to_var (g->map, T));
!       FOR_EACH_ELIM_GRAPH_PRED (g, T, P, 
  	{
  	  if (!TEST_BIT (g->visited, P))
  	    {
  	      elim_backward (g, P);
! 	      insert_copy_on_edge (g->e, partition_to_var (g->map, P), U);
  	    }
  	});
      }
    else
      {
!       S = elim_graph_remove_succ_edge (g, T);
        if (S != -1)
  	{
  	  SET_BIT (g->visited, T);
  	  insert_copy_on_edge (g->e, 
  			       partition_to_var (g->map, T), 
! 			       partition_to_var (g->map, S));
  	}
      }
    
--- 445,477 ----
  {
    tree U;
    int P, S;
+   location_t locus;
  
    if (elim_unvisited_predecessor (g, T))
      {
        U = create_temp (partition_to_var (g->map, T));
!       insert_copy_on_edge (g->e, U, partition_to_var (g->map, T),
! 			   UNKNOWN_LOCATION);
!       FOR_EACH_ELIM_GRAPH_PRED (g, T, P, locus,
  	{
  	  if (!TEST_BIT (g->visited, P))
  	    {
  	      elim_backward (g, P);
! 	      insert_copy_on_edge (g->e, partition_to_var (g->map, P), U,
! 				   locus);
  	    }
  	});
      }
    else
      {
!       S = elim_graph_remove_succ_edge (g, T, &locus);
        if (S != -1)
  	{
  	  SET_BIT (g->visited, T);
  	  insert_copy_on_edge (g->e, 
  			       partition_to_var (g->map, T), 
! 			       partition_to_var (g->map, S),
! 			       locus);
  	}
      }
    
*************** eliminate_phi (edge e, elim_graph g)
*** 452,457 ****
--- 487,493 ----
    basic_block B = e->dest;
  
    gcc_assert (VEC_length (tree, g->const_copies) == 0);
+   gcc_assert (VEC_length (location_t, g->copy_locus) == 0);
  
    /* Abnormal edges already have everything coalesced.  */
    if (e->flags & EDGE_ABNORMAL)
*************** eliminate_phi (edge e, elim_graph g)
*** 487,496 ****
    /* If there are any pending constant copies, issue them now.  */
    while (VEC_length (tree, g->const_copies) > 0)
      {
!       tree src, dest;
!       src = VEC_pop (tree, g->const_copies);
!       dest = VEC_pop (tree, g->const_copies);
!       insert_copy_on_edge (e, dest, src);
      }
  }
  
--- 523,532 ----
    /* If there are any pending constant copies, issue them now.  */
    while (VEC_length (tree, g->const_copies) > 0)
      {
!       tree src = VEC_pop (tree, g->const_copies);
!       tree dest = VEC_pop (tree, g->const_copies);
!       location_t locus = VEC_pop (location_t, g->copy_locus);
!       insert_copy_on_edge (e, dest, src, locus);
      }
  }
  
*************** insert_backedge_copies (void)
*** 1469,1474 ****
--- 1505,1514 ----
  		  name = make_ssa_name (result_var, stmt);
  		  GIMPLE_STMT_OPERAND (stmt, 0) = name;
  
+ 		  /* Copy location if present.  */
+ 		  if (phi_arg_has_location (phi, i))
+ 		    SET_EXPR_LOCATION (stmt, phi_arg_location (phi, i));
+ 
  		  /* Insert the new statement into the block and update
  		     the PHI node.  */
  		  if (last && stmt_ends_bb_p (last))
*** gcc/tree-phinodes.c.0	2009-04-01 11:32:22.000000000 +0200
--- gcc/tree-phinodes.c	2009-04-01 12:34:02.000000000 +0200
*************** make_phi_node (tree var, int len)
*** 225,230 ****
--- 225,231 ----
    for (i = 0; i < capacity; i++)
      {
        use_operand_p  imm;
+       phi_arg_set_location (phi, i, UNKNOWN_LOCATION);
        imm = &(PHI_ARG_IMM_USE_NODE (phi, i));
        imm->use = &(PHI_ARG_DEF_TREE (phi, i));
        imm->prev = NULL;
*************** resize_phi_node (tree *phi, int len)
*** 293,298 ****
--- 294,300 ----
    for (i = PHI_NUM_ARGS (new_phi); i < len; i++)
      {
        use_operand_p imm;
+       phi_arg_set_location (new_phi, i, UNKNOWN_LOCATION);
        imm = &(PHI_ARG_IMM_USE_NODE (new_phi, i));
        imm->use = &(PHI_ARG_DEF_TREE (new_phi, i));
        imm->prev = NULL;
*** gcc/tree-pretty-print.c.0	2009-04-01 11:32:44.000000000 +0200
--- gcc/tree-pretty-print.c	2009-04-01 12:05:52.000000000 +0200
*************** dump_generic_node (pretty_printer *buffe
*** 1727,1732 ****
--- 1727,1745 ----
  	    pp_string (buffer, "(");
  	    pp_decimal_int (buffer, PHI_ARG_EDGE (node, i)->src->index);
  	    pp_string (buffer, ")");
+ 	    if ((flags & TDF_LINENO) && phi_arg_has_location (node, i))
+ 	      {
+ 		expanded_location
+ 		  xloc = expand_location (phi_arg_location (node, i));
+ 		pp_character (buffer, '[');
+ 		if (xloc.file)
+ 		  {
+ 		    pp_string (buffer, xloc.file);
+ 		    pp_string (buffer, " : ");
+ 		  }
+ 		pp_decimal_int (buffer, xloc.line);
+ 		pp_string (buffer, "] ");
+ 	      }
  	    if (i < PHI_NUM_ARGS (node) - 1)
  	      pp_string (buffer, ", ");
  	  }
*** gcc/tree-ssa-phiopt.c.0	2009-04-01 12:57:22.000000000 +0200
--- gcc/tree-ssa-phiopt.c	2009-04-01 13:25:21.000000000 +0200
*************** conditional_replacement (basic_block con
*** 588,593 ****
--- 588,594 ----
  	  && !is_gimple_val (TREE_OPERAND (cond, 0)))
  	{
  	  tree op0, tmp, cond_tmp;
+ 	  location_t locus;
  
  	  /* Only "real" casts are OK here, not everything that is
  	     acceptable to is_gimple_cast.  Make sure we don't do
*************** conditional_replacement (basic_block con
*** 602,607 ****
--- 603,614 ----
  	  new_stmt = build_gimple_modify_stmt (cond_tmp, op0);
  	  SSA_NAME_DEF_STMT (cond_tmp) = new_stmt;
  
+ 	  /* Set the locus to the first argument, unless it has none.  */
+ 	  locus = phi_arg_location (phi, 0);
+ 	  if (locus == UNKNOWN_LOCATION)
+ 	    locus = phi_arg_location (phi, 1);
+ 	  SET_EXPR_LOCATION (new_stmt, locus);
+ 
  	  bsi_insert_after (&bsi, new_stmt, BSI_NEW_STMT);
  	  cond = fold_convert (TREE_TYPE (result), cond_tmp);
  	}
*** gcc/tree-ssa-ter.c.0	2009-04-01 11:32:22.000000000 +0200
--- gcc/tree-ssa-ter.c	2009-04-01 20:55:18.000000000 +0200
*************** dump_replaceable_exprs (FILE *f, tree *e
*** 678,683 ****
--- 678,695 ----
  	gcc_assert (var != NULL_TREE);
  	print_generic_expr (f, var, TDF_SLIM);
  	fprintf (f, " replace with --> ");
+ 	if ((dump_flags & TDF_LINENO) && EXPR_HAS_LOCATION (expr[x]))
+ 	  {
+ 	    expanded_location
+ 	      xlc = expand_location (EXPR_LOCATION (expr[x]));
+ 	    fprintf (f, "[");
+ 	    if (xlc.file)
+ 	      {
+ 		fprintf (f, "%s", xlc.file);
+ 		fprintf (f, " :");
+ 	      }
+ 	    fprintf (f, "%d]", xlc.line);
+ 	  }
  	print_generic_expr (f, GENERIC_TREE_OPERAND (stmt, 1),
  			    TDF_SLIM);
  	fprintf (f, "\n");
*** gcc/stor-layout.c.0	2009-04-06 19:56:48.000000000 +0200
--- gcc/stor-layout.c	2009-04-06 19:57:26.000000000 +0200
*************** initialize_sizetypes (bool signed_p)
*** 2199,2213 ****
  void
  set_sizetype (tree type)
  {
    int oprecision = TYPE_PRECISION (type);
    /* The *bitsizetype types use a precision that avoids overflows when
       calculating signed sizes / offsets in bits.  However, when
       cross-compiling from a 32 bit to a 64 bit host, we are limited to 64 bit
       precision.  */
!   int precision = MIN (MIN (oprecision + BITS_PER_UNIT_LOG + 1,
! 			    MAX_FIXED_MODE_SIZE),
! 		       2 * HOST_BITS_PER_WIDE_INT);
!   tree t;
  
    gcc_assert (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));
  
--- 2199,2216 ----
  void
  set_sizetype (tree type)
  {
+   tree t;
    int oprecision = TYPE_PRECISION (type);
    /* The *bitsizetype types use a precision that avoids overflows when
       calculating signed sizes / offsets in bits.  However, when
       cross-compiling from a 32 bit to a 64 bit host, we are limited to 64 bit
       precision.  */
!   int precision
!     = MIN (oprecision + BITS_PER_UNIT_LOG + 1, MAX_FIXED_MODE_SIZE);
!   precision
!     = GET_MODE_PRECISION (smallest_mode_for_size (precision, MODE_INT));
!   if (precision > HOST_BITS_PER_WIDE_INT * 2)
!     precision = HOST_BITS_PER_WIDE_INT * 2;
  
    gcc_assert (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));
  
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** has_static_fields (const_tree type)
*** 444,465 ****
  static int
  is_tagged_type (const_tree type)
  {
!   if (!is_struct_like (type))
      return false;
  
! #if 0  /* enable this code when GNAT supports tagged types with no vtable */
!   return TYPE_METHODS (type) != NULL_TREE;
! #else
!   {
!     tree tmp;
! 
!     for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))
!       if (DECL_VINDEX (tmp))
! 	return true;
!   }
  
    return false;
- #endif
  }
  
  /* Dump the name of an identifier node, following Ada syntax */
--- 444,459 ----
  static int
  is_tagged_type (const_tree type)
  {
!   tree tmp;
! 
!   if (!type || !is_struct_like (type))
      return false;
  
!   for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))
!     if (DECL_VINDEX (tmp))
!       return true;
  
    return false;
  }
  
  /* Dump the name of an identifier node, following Ada syntax */
*************** pp_ada_tree_identifier (pretty_printer *
*** 530,535 ****
--- 524,530 ----
  
  	  if (name [j + 1] == '=')
  	    {
+ 	      j++;
  	      s [len2++] = 'e';
  	      s [len2++] = 'q';
  	    }
*************** pp_ada_tree_identifier (pretty_printer *
*** 540,545 ****
--- 535,608 ----
  	    }
  	  break;
  
+ 	case '!':
+ 	  s [len2++] = '_';
+ 	  if (name [j + 1] == '=')
+ 	    {
+ 	      j++;
+ 	      s [len2++] = 'n';
+ 	      s [len2++] = 'e';
+ 	    }
+ 	  break;
+ 
+ 	case '+':
+ 	case '-':
+ 	case '*':
+ 	case '/':
+ 	case '(':
+ 	case '[':
+ 	  if (name [j - 1] != '_')
+ 	    s [len2++] = '_';
+ 
+ 	  switch (name [j + 1]) {
+ 	    case '\0':
+ 	      j++;
+ 	      switch (name [j - 1]) {
+ 	        case '+': s [len2++] = 'p'; break;  /* + */
+ 	        case '-': s [len2++] = 'm'; break;  /* - */
+ 	        case '*': s [len2++] = 't'; break;  /* * */
+ 	        case '/': s [len2++] = 'd'; break;  /* / */
+ 	      }
+ 	      break;
+ 
+ 	    case '=':
+ 	      j++;
+ 	      switch (name [j - 1]) {
+ 	        case '+': s [len2++] = 'p'; break;  /* += */
+ 	        case '-': s [len2++] = 'm'; break;  /* -= */
+ 	        case '*': s [len2++] = 't'; break;  /* *= */
+ 	        case '/': s [len2++] = 'd'; break;  /* /= */
+ 	      }
+ 	      s [len2++] = 'a';
+ 	      break;
+ 
+ 	    case '-':  /* -- */
+ 	      j++;
+ 	      s [len2++] = 'm';
+ 	      s [len2++] = 'm';
+ 	      break;
+ 
+ 	    case '+':  /* ++ */
+ 	      j++;
+ 	      s [len2++] = 'p';
+ 	      s [len2++] = 'p';
+ 	      break;
+ 
+ 	    case ')':  /* () */
+ 	      j++;
+ 	      s [len2++] = 'o';
+ 	      s [len2++] = 'p';
+ 	      break;
+ 
+ 	    case ']':  /* [] */
+ 	      j++;
+ 	      s [len2++] = 'o';
+ 	      s [len2++] = 'b';
+ 	      break;
+ 	  }
+ 
+ 	  break;
+ 
  	case '<':
  	case '>':
  	  c = name [j] == '<' ? 'l' : 'g';
*************** pp_ada_tree_identifier (pretty_printer *
*** 551,564 ****
--- 614,630 ----
  	      s [len2++] = 't';
  	      break;
  	    case '=':
+ 	      j++;
  	      s [len2++] = c;
  	      s [len2++] = 'e';
  	      break;
  	    case '>':
+ 	      j++;
  	      s [len2++] = 's';
  	      s [len2++] = 'r';
  	      break;
  	    case '<':
+ 	      j++;
  	      s [len2++] = 's';
  	      s [len2++] = 'l';
  	      break;
*************** pp_ada_tree_identifier (pretty_printer *
*** 581,587 ****
  
    s [len2] = '\0';
  
!   /* If the entity comes from another file, generate "package" prefix */
  
    decl = get_underlying_decl (type);
  
--- 647,654 ----
  
    s [len2] = '\0';
  
!   /* If the entity is a type and comes from another file, generate "package"
!      prefix.  */
  
    decl = get_underlying_decl (type);
  
*************** pp_ada_tree_identifier (pretty_printer *
*** 593,604 ****
  	{
  	  if (xloc.file != source_file_base)
  	    {
! 	      char *s1 = get_ada_package (xloc.file);
! 
! 	      append_withs (s1, limited_access);
! 	      pp_string (buffer, s1);
! 	      pp_character (buffer, '.');
! 	      free (s1);
  	    }
  	}
      }
--- 660,673 ----
  	{
  	  if (xloc.file != source_file_base)
  	    {
! 	      if (TREE_CODE (type) == TYPE_DECL)
! 		{
! 		  char *s1 = get_ada_package (xloc.file);
! 		  append_withs (s1, limited_access);
! 		  pp_string (buffer, s1);
! 		  pp_character (buffer, '.');
! 		  free (s1);
! 		}
  	    }
  	}
      }
*************** pp_ada_tree_identifier (pretty_printer *
*** 624,630 ****
      else
        pp_string(buffer, s);
    else
!     pp_string(buffer, s);
  }
  
  static void
--- 693,705 ----
      else
        pp_string(buffer, s);
    else
!     if (!strcmp (s, "bool"))
!       {
! 	append_withs ("Interfaces.C.Extensions", false);
! 	pp_string (buffer, "Extensions.bool");
!       }
!     else
!       pp_string(buffer, s);
  }
  
  static void
*************** dump_ada_function_declaration (pretty_pr
*** 830,838 ****
  	    (buffer, TREE_VALUE (arg), type, NULL, spc, 0, true);
  	}
  
!       if (is_method && num == 1 && !DECL_VINDEX (func) && !is_constructor
  	  && is_tagged_type (TREE_TYPE (TREE_TYPE (arg))))
!           pp_string (buffer, "'Class");
  
        arg = TREE_CHAIN (arg);
  
--- 905,914 ----
  	    (buffer, TREE_VALUE (arg), type, NULL, spc, 0, true);
  	}
  
!       if (is_method
! 	  && (num != 1 || (!DECL_VINDEX (func) && !is_constructor))
  	  && is_tagged_type (TREE_TYPE (TREE_TYPE (arg))))
!         pp_string (buffer, "'Class");
  
        arg = TREE_CHAIN (arg);
  
*************** dump_nested_types (pretty_printer *buffe
*** 1489,1494 ****
--- 1565,1574 ----
    tree outer;
    int found = false;
  
+   /* Avoid recursing over the same tree */
+   if (TREE_VISITED (t))
+     return;
+ 
    /* Find possible anonymous arrays/unions/structs recursively */
  
    outer = TREE_TYPE (t);
*************** dump_nested_types (pretty_printer *buffe
*** 1496,1501 ****
--- 1576,1583 ----
    if (outer == NULL_TREE)
      return;
  
+   TREE_VISITED (t) = 1;
+ 
    field = TYPE_FIELDS (outer);
    while (field)
      {
*************** dump_nested_types (pretty_printer *buffe
*** 1629,1634 ****
--- 1711,1718 ----
  	}
        field = TREE_CHAIN (field);
      }
+ 
+   TREE_VISITED (t) = 0;
  }
  
  static void
*************** print_ada_declaration (pretty_printer *b
*** 1667,1673 ****
  		       int (*cpp_check)(tree, int), int spc)
  {
    int is_var = 0, need_indent = 0;
-   int is_interface;
    int is_class = false;
    tree name = TYPE_NAME (TREE_TYPE (t));
    tree decl_name = DECL_NAME (t);
--- 1751,1756 ----
*************** print_ada_declaration (pretty_printer *b
*** 1867,1873 ****
        const int is_abstract = cpp_check && cpp_check (t, IS_ABSTRACT);
        const int is_constructor = cpp_check && cpp_check (t, IS_CONSTRUCTOR);
        const int is_destructor = cpp_check && cpp_check (t, IS_DESTRUCTOR);
-       const int is_tagged = type && is_tagged_type (type);
  
        if (!decl_name)
  	return 0;
--- 1950,1955 ----
*************** print_ada_declaration (pretty_printer *b
*** 1924,1931 ****
  	  if (is_constructor)
  	    {
  	      dump_ada_decl_name (buffer, t, false);
- 	      if (is_tagged)
- 	        pp_string (buffer, "'Class");
  	    }
  	  else
  	    {
--- 2006,2011 ----
*************** print_ada_declaration (pretty_printer *b
*** 1949,1958 ****
  
        if (is_constructor)
          {
!           if (is_tagged)
!             pp_string (buffer, "pragma CPP_Constructor (New_");
!           else
!             pp_string (buffer, "pragma Import (CPP, New_");
  	  dump_ada_decl_name (buffer, t, false);
  	  pp_string (buffer, ", \"");
  	  pp_asm_name (buffer, t);
--- 2029,2035 ----
  
        if (is_constructor)
          {
!           pp_string (buffer, "pragma CPP_Constructor (New_");
  	  dump_ada_decl_name (buffer, t, false);
  	  pp_string (buffer, ", \"");
  	  pp_asm_name (buffer, t);
*************** print_ada_declaration (pretty_printer *b
*** 1975,1980 ****
--- 2052,2061 ----
      }
    else if (TREE_CODE (t) == TYPE_DECL && !DECL_ORIGINAL_TYPE (t))
      {
+       int is_interface = 0;
+       int is_abstract_record = 0;
+       int found_abstract = 0;
+ 
        if (need_indent)
          INDENT (spc);
  
*************** print_ada_declaration (pretty_printer *b
*** 1990,1997 ****
  
        pp_string (buffer, " is ");
  
-       is_interface = 0;
- 
        /* check whether we have an Ada interface compatible class */
        if (cpp_check && AGGREGATE_TYPE_P (TREE_TYPE (t))
  	  && TYPE_METHODS (TREE_TYPE (t)))
--- 2071,2076 ----
*************** print_ada_declaration (pretty_printer *b
*** 2007,2027 ****
  	      num_fields++;
  	    }
  
  	  /* also check that there are only virtual methods */
! 	  if (num_fields == 1)
! 	    {
!               tmp = TYPE_METHODS (TREE_TYPE (t));
! 	      is_interface = 1;
  
!               for (; tmp; tmp = TREE_CHAIN (tmp))
!                 if (!cpp_check (tmp, IS_ABSTRACT))
! 		  {
! 		    is_interface = 0;
!                     break;
!                   }
! 	    }
  	}
  
        if (is_interface)
          {
  	  pp_string (buffer, "limited interface;  -- ");
--- 2086,2110 ----
  	      num_fields++;
  	    }
  
+ 	  is_abstract_record = 1;
+ 	  is_interface = num_fields == 1;
+ 
  	  /* also check that there are only virtual methods */
!           tmp = TYPE_METHODS (TREE_TYPE (t));
  
!           for (; tmp; tmp = TREE_CHAIN (tmp))
!             if (cpp_check (tmp, IS_ABSTRACT))
! 	      found_abstract = 1;
!             else if (!cpp_check (tmp, IS_CONSTRUCTOR))
! 	      {
! 		is_interface = 0;
! 		is_abstract_record = 0;
!                 break;
! 	      }
  	}
  
+       is_abstract_record = is_abstract_record && found_abstract;
+ 
        if (is_interface)
          {
  	  pp_string (buffer, "limited interface;  -- ");
*************** print_ada_declaration (pretty_printer *b
*** 2036,2042 ****
  	  print_ada_methods (buffer, TREE_TYPE (t), cpp_check, spc);
  	}
        else
!         dump_generic_ada_node (buffer, t, t, cpp_check, spc, false, false);
      }
    else
      {
--- 2119,2129 ----
  	  print_ada_methods (buffer, TREE_TYPE (t), cpp_check, spc);
  	}
        else
!         {
!           if (is_abstract_record)
!             pp_string (buffer, "abstract ");
!           dump_generic_ada_node (buffer, t, t, cpp_check, spc, false, false);
!         }
      }
    else
      {
*************** print_ada_struct_decl (pretty_printer *b
*** 2242,2248 ****
    if (!display_convention)
      return;
  
!   if (is_tagged_type (TREE_TYPE (type)))
      pp_string (buffer, "pragma Import (CPP, ");
    else
      pp_string (buffer, "pragma Convention (C, ");
--- 2329,2336 ----
    if (!display_convention)
      return;
  
!   if (is_struct_like (TREE_TYPE (type))
!       && TYPE_METHODS (TREE_TYPE (type)))
      pp_string (buffer, "pragma Import (CPP, ");
    else
      pp_string (buffer, "pragma Convention (C, ");
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** dump_generic_ada_node (pretty_printer *b
*** 1486,1492 ****
  		    {
  		      if (first)
  			{
! 			  pp_string (buffer, "new ");
  			  first = 0;
  			}
  		      else
--- 1486,1492 ----
  		    {
  		      if (first)
  			{
! 			  pp_string (buffer, "limited new ");
  			  first = 0;
  			}
  		      else
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** print_ada_declaration (pretty_printer *b
*** 2054,2060 ****
      {
        int is_interface = 0;
        int is_abstract_record = 0;
-       int found_abstract = 0;
  
        if (need_indent)
          INDENT (spc);
--- 2054,2059 ----
*************** print_ada_declaration (pretty_printer *b
*** 2086,2110 ****
  	      num_fields++;
  	    }
  
- 	  is_abstract_record = 1;
- 	  is_interface = num_fields == 1;
- 
  	  /* also check that there are only virtual methods */
!           tmp = TYPE_METHODS (TREE_TYPE (t));
! 
!           for (; tmp; tmp = TREE_CHAIN (tmp))
!             if (cpp_check (tmp, IS_ABSTRACT))
! 	      found_abstract = 1;
!             else if (!cpp_check (tmp, IS_CONSTRUCTOR))
! 	      {
! 		is_interface = 0;
! 		is_abstract_record = 0;
!                 break;
! 	      }
  	}
  
-       is_abstract_record = is_abstract_record && found_abstract;
- 
        if (is_interface)
          {
  	  pp_string (buffer, "limited interface;  -- ");
--- 2085,2105 ----
  	      num_fields++;
  	    }
  
  	  /* also check that there are only virtual methods */
! 	  if (num_fields == 1)
! 	    {
! 	      tmp = TYPE_METHODS (TREE_TYPE (t));
! 	      is_interface = 1;
!  
! 	      for (; tmp; tmp = TREE_CHAIN (tmp))
! 		if (!cpp_check (tmp, IS_ABSTRACT))
! 		  {
! 		    is_interface = 0;
! 		    break;
! 		  }
! 	    }
  	}
  
        if (is_interface)
          {
  	  pp_string (buffer, "limited interface;  -- ");
*** gcc/tree-ada-spec.c.old
--- gcc/tree-ada-spec.c
*************** pp_ada_tree_identifier (pretty_printer *
*** 660,672 ****
  	{
  	  if (xloc.file != source_file_base)
  	    {
! 	      if (TREE_CODE (type) == TYPE_DECL)
  		{
! 		  char *s1 = get_ada_package (xloc.file);
! 		  append_withs (s1, limited_access);
! 		  pp_string (buffer, s1);
! 		  pp_character (buffer, '.');
! 		  free (s1);
  		}
  	    }
  	}
--- 660,689 ----
  	{
  	  if (xloc.file != source_file_base)
  	    {
! 	      switch (TREE_CODE (type))
  		{
! 		  case ENUMERAL_TYPE:
! 		  case INTEGER_TYPE:
! 		  case REAL_TYPE:
! 		  case FIXED_POINT_TYPE:
! 		  case BOOLEAN_TYPE:
! 		  case REFERENCE_TYPE:
! 		  case POINTER_TYPE:
! 		  case ARRAY_TYPE:
! 		  case RECORD_TYPE:
! 		  case UNION_TYPE:
! 		  case QUAL_UNION_TYPE:
! 		  case TYPE_DECL:
! 		    {
! 		      char *s1 = get_ada_package (xloc.file);
! 		      append_withs (s1, limited_access);
! 		      pp_string (buffer, s1);
! 		      pp_character (buffer, '.');
! 		      free (s1);
! 		    }
! 		    break;
! 		  default:
! 		    break;
  		}
  	    }
  	}
*** gcc/dwarf2out.c.0	2009-04-14 15:21:21.000000000 +0200
--- gcc/dwarf2out.c	2009-04-14 15:41:54.000000000 +0200
*************** field_byte_offset (const_tree decl)
*** 10204,10224 ****
        unsigned HOST_WIDE_INT type_size_in_bits;
  
        type = field_type (decl);
        field_size_tree = DECL_SIZE (decl);
  
        /* The size could be unspecified if there was an error, or for
           a flexible array member.  */
!       if (! field_size_tree)
          field_size_tree = bitsize_zero_node;
  
!       /* If we don't know the size of the field, pretend it's a full word.  */
        if (host_integerp (field_size_tree, 1))
          field_size_in_bits = tree_low_cst (field_size_tree, 1);
        else
!         field_size_in_bits = BITS_PER_WORD;
  
-       type_size_in_bits = simple_type_size_in_bits (type);
-       type_align_in_bits = simple_type_align_in_bits (type);
        decl_align_in_bits = simple_decl_align_in_bits (decl);
  
        /* The GCC front-end doesn't make any attempt to keep track of the
--- 10204,10225 ----
        unsigned HOST_WIDE_INT type_size_in_bits;
  
        type = field_type (decl);
+       type_size_in_bits = simple_type_size_in_bits (type);
+       type_align_in_bits = simple_type_align_in_bits (type);
+ 
        field_size_tree = DECL_SIZE (decl);
  
        /* The size could be unspecified if there was an error, or for
           a flexible array member.  */
!       if (!field_size_tree)
          field_size_tree = bitsize_zero_node;
  
!       /* If the size of the field is not constant, use the type size.  */
        if (host_integerp (field_size_tree, 1))
          field_size_in_bits = tree_low_cst (field_size_tree, 1);
        else
!         field_size_in_bits = type_size_in_bits;
  
        decl_align_in_bits = simple_decl_align_in_bits (decl);
  
        /* The GCC front-end doesn't make any attempt to keep track of the
*** gcc/gcc.c.BASE	2009-04-06 16:25:03.424338000 +0200
--- gcc/gcc.c	2009-04-15 14:45:31.263453294 +0200
***************
*** 285,296 ****
--- 285,305 ----
  
  static struct obstack collect_obstack;
  
+ /* This is a list of a wrapper program and its arguments.
+    e.g. wrapper_string of "strace,-c"
+    will cause all programs to run as
+        strace -c program arguments
+    instead of just
+        program arguments */
+ static const char  *wrapper_string;
+ 
  /* Forward declaration for prototypes.  */
  struct path_prefix;
  struct prefix_list;
  
  static void init_spec (void);
  static void store_arg (const char *, int, int);
+ static void insert_wrapper (const char *);
  static char *load_specs (const char *);
  static void read_specs (const char *, int);
  static void set_spec (const char *, const char *);
***************
*** 2865,2870 ****
--- 2874,2886 ----
  
    gcc_assert (!processing_spec_function);
  
+   if (wrapper_string)
+     {
+       string = find_a_file (&exec_prefixes, argbuf[0], X_OK, false);
+       argbuf[0] = (string) ? string : argbuf[0];
+       insert_wrapper (wrapper_string);
+     }
+ 
    /* Count # of piped commands.  */
    for (n_commands = 1, i = 0; i < argbuf_index; i++)
      if (strcmp (argbuf[i], "|") == 0)
***************
*** 2879,2888 ****
  
    commands[0].prog = argbuf[0]; /* first command.  */
    commands[0].argv = &argbuf[0];
!   string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false);
! 
!   if (string)
!     commands[0].argv[0] = string;
  
    for (n_commands = 1, i = 0; i < argbuf_index; i++)
      if (strcmp (argbuf[i], "|") == 0)
--- 2895,2906 ----
  
    commands[0].prog = argbuf[0]; /* first command.  */
    commands[0].argv = &argbuf[0];
!  
!   if (!wrapper_string)
!     {
!       string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false);
!       commands[0].argv[0] = (string) ? string : commands[0].argv[0];
!     }
  
    for (n_commands = 1, i = 0; i < argbuf_index; i++)
      if (strcmp (argbuf[i], "|") == 0)
***************
*** 3822,3827 ****
--- 3840,3854 ----
  	  use_pipes = 1;
  	  n_switches++;
  	}
+       else if (strcmp (argv[i], "-wrapper") == 0)
+         {
+ 	  if (++i >= argc)
+ 	    fatal ("argument to '-wrapper' is missing");
+ 
+           wrapper_string = argv[i];
+ 	  n_switches++;
+ 	  n_switches++;
+         }
        else if (strcmp (argv[i], "-###") == 0)
  	{
  	  /* This is similar to -v except that there is no execution
***************
*** 4187,4192 ****
--- 4214,4221 ----
  	  infiles[n_infiles].language = "*";
  	  infiles[n_infiles++].name = argv[i];
  	}
+       else if (strcmp (argv[i], "-wrapper") == 0)
+         i++;
        else if (strcmp (argv[i], "-specs") == 0)
  	i++;
        else if (strncmp (argv[i], "-specs=", 7) == 0)
***************
*** 4438,4443 ****
--- 4467,4518 ----
      }
  }
  
+ 
+ /* Parse the WRAPPER string which is a comma separated list of the command line
+    and insert them into the beginning of argbuf.  */
+ 
+ static void
+ insert_wrapper (const char *wrapper)
+ {
+   int n = 0;
+   int i;
+   char *buf = xstrdup (wrapper);
+   char *p = buf;
+ 
+   do
+     {
+       n++;
+       while (*p == ',')
+         p++;
+     }
+   while ((p = strchr (p, ',')) != NULL);
+ 
+   if (argbuf_index + n >= argbuf_length)
+     {
+       argbuf_length = argbuf_length * 2;
+       while (argbuf_length < argbuf_index + n)
+ 	argbuf_length *= 2;
+       argbuf = xrealloc (argbuf, argbuf_length * sizeof (const char *));
+     }
+   for (i = argbuf_index - 1; i >= 0; i--)
+     argbuf[i + n] = argbuf[i];
+ 
+   i = 0;
+   p = buf;
+   do
+     {
+       while (*p == ',')
+         {
+           *p = 0;
+           p++;
+         }
+       argbuf[i++] = p;
+     }
+   while ((p = strchr (p, ',')) != NULL);
+   gcc_assert (i == n);
+   argbuf_index += n;
+ }
+ 
  /* Process the spec SPEC and run the commands specified therein.
     Returns 0 if the spec is successfully processed; -1 if failed.  */
  
*** gcc/doc/invoke.texi.0	2009-04-16 23:10:01.000000000 +0200
--- gcc/doc/invoke.texi	2009-04-16 23:11:10.000000000 +0200
*************** in the following sections.
*** 164,170 ****
  @xref{Overall Options,,Options Controlling the Kind of Output}.
  @gccoptlist{-c  -S  -E  -o @var{file}  -combine  -pipe  -pass-exit-codes  @gol
  -x @var{language}  -v  -###  --help@r{[}=@var{class}@r{]}  --target-help  @gol
! --version @@@var{file}}
  
  @item C Language Options
  @xref{C Dialect Options,,Options Controlling C Dialect}.
--- 164,170 ----
  @xref{Overall Options,,Options Controlling the Kind of Output}.
  @gccoptlist{-c  -S  -E  -o @var{file}  -combine  -pipe  -pass-exit-codes  @gol
  -x @var{language}  -v  -###  --help@r{[}=@var{class}@r{]}  --target-help  @gol
! --version -wrapper@@@var{file}}
  
  @item C Language Options
  @xref{C Dialect Options,,Options Controlling C Dialect}.
*************** diff /tmp/O2-opts /tmp/O3-opts | grep en
*** 1249,1254 ****
--- 1249,1267 ----
  @opindex version
  Display the version number and copyrights of the invoked GCC@.
  
+ @item -wrapper
+ @opindex wrapper
+ Invoke all subcommands under a wrapper program. It takes a single
+ comma separated list as an argument, which will be used to invoke
+ the wrapper:
+ 
+ @smallexample
+ gcc -c t.c -wrapper gdb,--args
+ @end smallexample
+ 
+ This will invoke all subprograms of gcc under "gdb --args",
+ thus cc1 invocation will be "gdb --args cc1 ...".
+ 
  @include @value{srcdir}/../libiberty/at-file.texi
  @end table
  
*** gcc/dce.c.0	2009-04-18 18:49:10.000000000 +0200
--- gcc/dce.c	2009-04-18 18:51:46.000000000 +0200
*************** delete_corresponding_reg_eq_notes (rtx i
*** 297,302 ****
--- 297,332 ----
  }
  
  
+ /* Return true if INSN contains only a formal nop pattern.
+ 
+    NOTE: This function is coded for speed and thus not meant to be
+    bullet-proof.  Its failure to recognize a nop pattern shouldn't
+    be allowed to generate wrong code.  */
+ 
+ static bool
+ insn_is_nop (const_rtx insn)
+ {
+   rtx pat;
+ 
+   if (!INSN_P (insn))
+     return false;
+ 
+   pat = PATTERN (insn);
+ 
+   /* This is the pattern used by almost all back-ends.  */
+   if (pat == const0_rtx)
+     return true;
+ 
+   /* This is the pattern used by the SPU back-end.  */
+   if (GET_CODE (pat) == UNSPEC_VOLATILE
+       && XVECLEN (pat, 0) == 1
+       && XVECEXP (pat, 0, 0) == const0_rtx)
+     return true;
+ 
+   return false;
+ }
+ 
+ 
  /* Delete every instruction that hasn't been marked.  */
  
  static void
*************** delete_unmarked_insns (void)
*** 336,341 ****
--- 366,375 ----
  	  else if (marked_insn_p (insn))
  	    continue;
  
+ 	  /* Do not delete NOPs created to carry source line info at -O0.  */
+ 	  if (!optimize && insn_is_nop (insn))
+ 	    continue;
+ 
  	  if (!dbg_cnt (dce))
  	    continue;
  
*** gcc/rtl.h.0	2009-04-27 19:07:13.000000000 +0200
--- gcc/rtl.h	2009-04-25 09:13:00.000000000 +0200
*************** extern rtx canon_rtx (rtx);
*** 2258,2264 ****
  extern int true_dependence (const_rtx, enum machine_mode, const_rtx, bool (*)(const_rtx, bool));
  extern rtx get_addr (rtx);
  extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,
! 				  bool (*)(const_rtx, bool));
  extern int read_dependence (const_rtx, const_rtx);
  extern int anti_dependence (const_rtx, const_rtx);
  extern int output_dependence (const_rtx, const_rtx);
--- 2258,2264 ----
  extern int true_dependence (const_rtx, enum machine_mode, const_rtx, bool (*)(const_rtx, bool));
  extern rtx get_addr (rtx);
  extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,
! 				  rtx, bool (*)(const_rtx, bool));
  extern int read_dependence (const_rtx, const_rtx);
  extern int anti_dependence (const_rtx, const_rtx);
  extern int output_dependence (const_rtx, const_rtx);
*** gcc/alias.c.0	2009-04-27 19:07:13.000000000 +0200
--- gcc/alias.c	2009-04-27 19:07:21.000000000 +0200
*************** true_dependence (const_rtx mem, enum mac
*** 2199,2212 ****
     Variant of true_dependence which assumes MEM has already been
     canonicalized (hence we no longer do that here).
     The mem_addr argument has been added, since true_dependence computed
!    this value prior to canonicalizing.  */
  
  int
  canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,
! 		       const_rtx x, bool (*varies) (const_rtx, bool))
  {
-   rtx x_addr;
- 
    if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
      return 1;
  
--- 2199,2211 ----
     Variant of true_dependence which assumes MEM has already been
     canonicalized (hence we no longer do that here).
     The mem_addr argument has been added, since true_dependence computed
!    this value prior to canonicalizing.
!    If x_addr is non-NULL, it is used in preference of XEXP (x, 0).  */
  
  int
  canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,
! 		       const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool))
  {
    if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
      return 1;
  
*************** canon_true_dependence (const_rtx mem, en
*** 2232,2238 ****
    if (nonoverlapping_memrefs_p (x, mem))
      return 0;
  
!   x_addr = get_addr (XEXP (x, 0));
  
    if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))
      return 0;
--- 2231,2238 ----
    if (nonoverlapping_memrefs_p (x, mem))
      return 0;
  
!   if (! x_addr)
!     x_addr = get_addr (XEXP (x, 0));
  
    if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))
      return 0;
*** gcc/cse.c.0	2009-04-27 19:07:13.000000000 +0200
--- gcc/cse.c	2009-04-27 19:07:21.000000000 +0200
*************** check_dependence (rtx *x, void *data)
*** 1657,1663 ****
  {
    struct check_dependence_data *d = (struct check_dependence_data *) data;
    if (*x && MEM_P (*x))
!     return canon_true_dependence (d->exp, d->mode, d->addr, *x,
  		    		  cse_rtx_varies_p);
    else
      return 0;
--- 1657,1663 ----
  {
    struct check_dependence_data *d = (struct check_dependence_data *) data;
    if (*x && MEM_P (*x))
!     return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX,
  		    		  cse_rtx_varies_p);
    else
      return 0;
*** gcc/cselib.c.0	2009-04-27 19:07:13.000000000 +0200
--- gcc/cselib.c	2009-04-27 19:07:21.000000000 +0200
*************** cselib_invalidate_mem (rtx mem_rtx)
*** 1408,1414 ****
  	    }
  	  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)
  	      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx), mem_addr,
! 		      			  x, cselib_rtx_varies_p))
  	    {
  	      has_mem = true;
  	      num_mems++;
--- 1408,1414 ----
  	    }
  	  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)
  	      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx), mem_addr,
! 		      			  x, NULL_RTX, cselib_rtx_varies_p))
  	    {
  	      has_mem = true;
  	      num_mems++;
*** gcc/dse.c.0	2009-04-27 19:07:13.000000000 +0200
--- gcc/dse.c	2009-04-27 19:17:01.000000000 +0200
*************** struct store_info 
*** 215,221 ****
    /* This canonized mem.  */
    rtx mem;
  
!   /* The result of get_addr on mem.  */
    rtx mem_addr;
  
    /* If this is non-zero, it is the alias set of a spill location.  */
--- 215,221 ----
    /* This canonized mem.  */
    rtx mem;
  
!   /* Canonized MEM address for use by canon_true_dependence.  */
    rtx mem_addr;
  
    /* If this is non-zero, it is the alias set of a spill location.  */
*************** struct group_info 
*** 416,423 ****
       do read dependency.  */
    rtx base_mem;
    
!   /* Canonized version of base_mem, most likely the same thing.  */
!   rtx canon_base_mem;
  
    /* These two sets of two bitmaps are used to keep track of how many
       stores are actually referencing that position from this base.  We
--- 416,423 ----
       do read dependency.  */
    rtx base_mem;
    
!   /* Canonized version of base_mem's address.  */
!   rtx canon_base_addr;
  
    /* These two sets of two bitmaps are used to keep track of how many
       stores are actually referencing that position from this base.  We
*************** get_group_info (rtx base)
*** 653,659 ****
        gi->rtx_base = base;
        gi->id = rtx_group_next_id++;
        gi->base_mem = gen_rtx_MEM (QImode, base);
!       gi->canon_base_mem = canon_rtx (gi->base_mem);
        gi->store1_n = BITMAP_ALLOC (NULL);
        gi->store1_p = BITMAP_ALLOC (NULL);
        gi->store2_n = BITMAP_ALLOC (NULL);
--- 653,659 ----
        gi->rtx_base = base;
        gi->id = rtx_group_next_id++;
        gi->base_mem = gen_rtx_MEM (QImode, base);
!       gi->canon_base_addr = canon_rtx (base);
        gi->store1_n = BITMAP_ALLOC (NULL);
        gi->store1_p = BITMAP_ALLOC (NULL);
        gi->store2_n = BITMAP_ALLOC (NULL);
*************** clear_rhs_from_active_local_stores (void
*** 1161,1167 ****
  static int
  record_store (rtx body, bb_info_t bb_info)
  {
!   rtx mem;
    HOST_WIDE_INT offset = 0;
    HOST_WIDE_INT width = 0;
    alias_set_type spill_alias_set;
--- 1161,1167 ----
  static int
  record_store (rtx body, bb_info_t bb_info)
  {
!   rtx mem, mem_addr;
    HOST_WIDE_INT offset = 0;
    HOST_WIDE_INT width = 0;
    alias_set_type spill_alias_set;
*************** record_store (rtx body, bb_info_t bb_inf
*** 1280,1285 ****
--- 1280,1302 ----
       dead.  */
    ptr = active_local_stores;
    last = NULL;
+   mem = canon_rtx (mem);
+   /* For alias_set != 0 canon_true_dependence should be never called.  */
+   if (spill_alias_set)
+     mem_addr = NULL_RTX;
+   else
+     {
+       if (group_id < 0)
+ 	mem_addr = base->val_rtx;
+       else
+ 	{
+ 	  group_info_t group
+ 	    = VEC_index (group_info_t, rtx_group_vec, group_id);
+ 	  mem_addr = group->canon_base_addr;
+ 	}
+       if (offset)
+ 	mem_addr = plus_constant (mem_addr, offset);
+     }
  
    while (ptr)
      {
*************** record_store (rtx body, bb_info_t bb_inf
*** 1334,1340 ****
  	  if (canon_true_dependence (s_info->mem, 
  				     GET_MODE (s_info->mem),
  				     s_info->mem_addr,
! 				     mem, rtx_varies_p))
  	    s_info->rhs = NULL;
  	}
        
--- 1351,1357 ----
  	  if (canon_true_dependence (s_info->mem, 
  				     GET_MODE (s_info->mem),
  				     s_info->mem_addr,
! 				     mem, mem_addr, rtx_varies_p))
  	    s_info->rhs = NULL;
  	}
        
*************** record_store (rtx body, bb_info_t bb_inf
*** 1365,1373 ****
    /* Finish filling in the store_info.  */
    store_info->next = insn_info->store_rec;
    insn_info->store_rec = store_info;
!   store_info->mem = canon_rtx (mem);
    store_info->alias_set = spill_alias_set;
!   store_info->mem_addr = get_addr (XEXP (mem, 0));
    store_info->cse_base = base;
    store_info->positions_needed = (1L << width) - 1;
    store_info->group_id = group_id;
--- 1382,1390 ----
    /* Finish filling in the store_info.  */
    store_info->next = insn_info->store_rec;
    insn_info->store_rec = store_info;
!   store_info->mem = mem;
    store_info->alias_set = spill_alias_set;
!   store_info->mem_addr = mem_addr;
    store_info->cse_base = base;
    store_info->positions_needed = (1L << width) - 1;
    store_info->group_id = group_id;
*************** replace_read (store_info_t store_info, i
*** 1680,1686 ****
  static int
  check_mem_read_rtx (rtx *loc, void *data)
  {
!   rtx mem = *loc;
    bb_info_t bb_info;
    insn_info_t insn_info;
    HOST_WIDE_INT offset = 0;
--- 1697,1703 ----
  static int
  check_mem_read_rtx (rtx *loc, void *data)
  {
!   rtx mem = *loc, mem_addr;
    bb_info_t bb_info;
    insn_info_t insn_info;
    HOST_WIDE_INT offset = 0;
*************** check_mem_read_rtx (rtx *loc, void *data
*** 1732,1737 ****
--- 1749,1770 ----
    read_info->end = offset + width;
    read_info->next = insn_info->read_rec;
    insn_info->read_rec = read_info;
+   /* For alias_set != 0 canon_true_dependence should be never called.  */
+   if (spill_alias_set)
+     mem_addr = NULL_RTX;
+   else
+     {
+       if (group_id < 0)
+ 	mem_addr = base->val_rtx;
+       else
+ 	{
+ 	  group_info_t group
+ 	    = VEC_index (group_info_t, rtx_group_vec, group_id);
+ 	  mem_addr = group->canon_base_addr;
+ 	}
+       if (offset)
+ 	mem_addr = plus_constant (mem_addr, offset);
+     }
  
    /* We ignore the clobbers in store_info.  The is mildly aggressive,
       but there really should not be a clobber followed by a read.  */
*************** check_mem_read_rtx (rtx *loc, void *data
*** 1802,1808 ****
  	      = canon_true_dependence (store_info->mem, 
  				       GET_MODE (store_info->mem),
  				       store_info->mem_addr,
! 				       mem, rtx_varies_p);
  	  
  	  else if (group_id == store_info->group_id)
  	    {
--- 1835,1841 ----
  	      = canon_true_dependence (store_info->mem, 
  				       GET_MODE (store_info->mem),
  				       store_info->mem_addr,
! 				       mem, mem_addr, rtx_varies_p);
  	  
  	  else if (group_id == store_info->group_id)
  	    {
*************** check_mem_read_rtx (rtx *loc, void *data
*** 1813,1819 ****
  		  = canon_true_dependence (store_info->mem, 
  					   GET_MODE (store_info->mem),
  					   store_info->mem_addr,
! 					   mem, rtx_varies_p);
  	      
  	      /* If this read is just reading back something that we just
  		 stored, rewrite the read.  */
--- 1846,1852 ----
  		  = canon_true_dependence (store_info->mem, 
  					   GET_MODE (store_info->mem),
  					   store_info->mem_addr,
! 					   mem, mem_addr, rtx_varies_p);
  	      
  	      /* If this read is just reading back something that we just
  		 stored, rewrite the read.  */
*************** check_mem_read_rtx (rtx *loc, void *data
*** 1902,1908 ****
  	    remove = canon_true_dependence (store_info->mem, 
  					    GET_MODE (store_info->mem),
  					    store_info->mem_addr,
! 					    mem, rtx_varies_p);
  	  
  	  if (remove)
  	    {
--- 1935,1941 ----
  	    remove = canon_true_dependence (store_info->mem, 
  					    GET_MODE (store_info->mem),
  					    store_info->mem_addr,
! 					    mem, mem_addr, rtx_varies_p);
  	  
  	  if (remove)
  	    {
*************** scan_reads_nospill (insn_info_t insn_inf
*** 2588,2595 ****
  		  if ((read_info->group_id < 0)
  		      && canon_true_dependence (group->base_mem, 
  						QImode,
! 						group->canon_base_mem,
! 						read_info->mem, rtx_varies_p))
  		    {
  		      if (kill)
  			bitmap_ior_into (kill, group->group_kill);
--- 2621,2629 ----
  		  if ((read_info->group_id < 0)
  		      && canon_true_dependence (group->base_mem, 
  						QImode,
! 						group->canon_base_addr,
! 						read_info->mem, NULL_RTX,
! 						rtx_varies_p))
  		    {
  		      if (kill)
  			bitmap_ior_into (kill, group->group_kill);
*** gcc/gcse.c.0	2009-04-27 19:07:13.000000000 +0200
--- gcc/gcse.c	2009-04-27 19:07:21.000000000 +0200
*************** compute_transp (const_rtx x, int indx, s
*** 2501,2507 ****
  		    dest_addr = XEXP (list_entry, 0);
  
  		    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,
! 					       x, rtx_addr_varies_p))
  		      {
  			if (set_p)
  			  SET_BIT (bmap[bb_index], indx);
--- 2501,2507 ----
  		    dest_addr = XEXP (list_entry, 0);
  
  		    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,
! 					       x, NULL_RTX, rtx_addr_varies_p))
  		      {
  			if (set_p)
  			  SET_BIT (bmap[bb_index], indx);
*** gcc/resource.c.0	2009-04-29 00:02:21.000000000 +0200
--- gcc/resource.c	2009-04-29 00:06:27.000000000 +0200
*************** update_live_status (rtx dest, const_rtx 
*** 135,142 ****
  static int
  find_basic_block (rtx insn, int search_limit)
  {
-   basic_block bb;
- 
    /* Scan backwards to the previous BARRIER.  Then see if we can find a
       label that starts a basic block.  Return the basic block number.  */
    for (insn = prev_nonnote_insn (insn);
--- 135,140 ----
*************** find_basic_block (rtx insn, int search_l
*** 157,167 ****
    for (insn = next_nonnote_insn (insn);
         insn && LABEL_P (insn);
         insn = next_nonnote_insn (insn))
!     {
!       FOR_EACH_BB (bb)
! 	if (insn == BB_HEAD (bb))
! 	  return bb->index;
!     }
  
    return -1;
  }
--- 155,162 ----
    for (insn = next_nonnote_insn (insn);
         insn && LABEL_P (insn);
         insn = next_nonnote_insn (insn))
!     if (BLOCK_FOR_INSN (insn))
!       return BLOCK_FOR_INSN (insn)->index;
  
    return -1;
  }
*************** return_insn_p (const_rtx insn)
*** 851,863 ****
     (with no intervening active insns) to see if any of them start a basic
     block.  If we hit the start of the function first, we use block 0.
  
!    Once we have found a basic block and a corresponding first insns, we can
!    accurately compute the live status from basic_block_live_regs and
!    reg_renumber.  (By starting at a label following a BARRIER, we are immune
!    to actions taken by reload and jump.)  Then we scan all insns between
!    that point and our target.  For each CLOBBER (or for call-clobbered regs
!    when we pass a CALL_INSN), mark the appropriate registers are dead.  For
!    a SET, mark them as live.
  
     We have to be careful when using REG_DEAD notes because they are not
     updated by such things as find_equiv_reg.  So keep track of registers
--- 846,857 ----
     (with no intervening active insns) to see if any of them start a basic
     block.  If we hit the start of the function first, we use block 0.
  
!    Once we have found a basic block and a corresponding first insn, we can
!    accurately compute the live status (by starting at a label following a
!    BARRIER, we are immune to actions taken by reload and jump.)  Then we
!    scan all insns between that point and our target.  For each CLOBBER (or
!    for call-clobbered regs when we pass a CALL_INSN), mark the appropriate
!    registers are dead.  For a SET, mark them as live.
  
     We have to be careful when using REG_DEAD notes because they are not
     updated by such things as find_equiv_reg.  So keep track of registers
*************** mark_target_live_regs (rtx insns, rtx ta
*** 957,969 ****
       TARGET.  Otherwise, we must assume everything is live.  */
    if (b != -1)
      {
!       regset regs_live = DF_LR_IN (BASIC_BLOCK (b));
        rtx start_insn, stop_insn;
  
!       /* Compute hard regs live at start of block -- this is the real hard regs
! 	 marked live, plus live pseudo regs that have been renumbered to
! 	 hard regs.  */
! 
        REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
  
        /* Get starting and ending insn, handling the case where each might
--- 951,960 ----
       TARGET.  Otherwise, we must assume everything is live.  */
    if (b != -1)
      {
!       regset regs_live = df_get_live_in (BASIC_BLOCK (b));
        rtx start_insn, stop_insn;
  
!       /* Compute hard regs live at start of block.  */
        REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
  
        /* Get starting and ending insn, handling the case where each might
*************** mark_target_live_regs (rtx insns, rtx ta
*** 1049,1058 ****
--- 1040,1063 ----
  
  	  else if (LABEL_P (real_insn))
  	    {
+ 	      basic_block bb;
+ 
  	      /* A label clobbers the pending dead registers since neither
  		 reload nor jump will propagate a value across a label.  */
  	      AND_COMPL_HARD_REG_SET (current_live_regs, pending_dead_regs);
  	      CLEAR_HARD_REG_SET (pending_dead_regs);
+ 
+ 	      /* We must conservatively assume that all registers that used
+ 		 to be live here still are.  The fallthrough edge may have
+ 		 left a live register uninitialized.  */
+ 	      bb = BLOCK_FOR_INSN (real_insn);
+ 	      if (bb)
+ 		{
+ 		  HARD_REG_SET extra_live;
+ 
+ 		  REG_SET_TO_HARD_REG_SET (extra_live, df_get_live_in (bb));
+ 		  IOR_HARD_REG_SET (current_live_regs, extra_live);
+ 		}
  	    }
  
  	  /* The beginning of the epilogue corresponds to the end of the
*************** void
*** 1124,1129 ****
--- 1129,1135 ----
  init_resource_info (rtx epilogue_insn)
  {
    int i;
+   basic_block bb;
  
    /* Indicate what resources are required to be valid at the end of the current
       function.  The condition code never is and memory always is.  If the
*************** init_resource_info (rtx epilogue_insn)
*** 1192,1197 ****
--- 1198,1210 ----
    /* Allocate and initialize the tables used by mark_target_live_regs.  */
    target_hash_table = XCNEWVEC (struct target_info *, TARGET_HASH_PRIME);
    bb_ticks = XCNEWVEC (int, last_basic_block);
+ 
+   /* Set the BLOCK_FOR_INSN of each label that starts a basic block.  */
+   FOR_EACH_BB (bb)
+     if (LABEL_P (BB_HEAD (bb)))
+       BLOCK_FOR_INSN (BB_HEAD (bb)) = bb;
+ 
+   df_analyze ();
  }
  
  /* Free up the resources allocated to mark_target_live_regs ().  This
*************** init_resource_info (rtx epilogue_insn)
*** 1200,1205 ****
--- 1213,1220 ----
  void
  free_resource_info (void)
  {
+   basic_block bb;
+ 
    if (target_hash_table != NULL)
      {
        int i;
*************** free_resource_info (void)
*** 1225,1230 ****
--- 1240,1249 ----
        free (bb_ticks);
        bb_ticks = NULL;
      }
+ 
+   FOR_EACH_BB (bb)
+     if (LABEL_P (BB_HEAD (bb)))
+       BLOCK_FOR_INSN (BB_HEAD (bb)) = NULL;
  }
  
  /* Clear any hashed information that we have stored for INSN.  */
*** configure.orig	Thu May 14 16:57:30 2009
--- configure	Thu May 14 16:58:46 2009
***************
*** 2245,2251 ****
      noconfigdirs="$noconfigdirs ${libgcj}"
      libgloss_dir=arm
      ;;
!   arm-*-elf* | strongarm-*-elf* | xscale-*-elf* | arm*-*-eabi* )
      noconfigdirs="$noconfigdirs target-libffi target-qthreads"
      libgloss_dir=arm
      ;;
--- 2245,2251 ----
      noconfigdirs="$noconfigdirs ${libgcj}"
      libgloss_dir=arm
      ;;
!   arm-*-elf* | strongarm-*-elf* | xscale-*-elf* | arm*-*-eabi* | mindstorms-*-nxt*)
      noconfigdirs="$noconfigdirs target-libffi target-qthreads"
      libgloss_dir=arm
      ;;
*** gcc/config.gcc.orig	Thu May 14 16:59:31 2009
--- gcc/config.gcc	Thu May 14 17:11:21 2009
***************
*** 279,285 ****
  strongarm*-*-*)
  	cpu_type=arm
  	;;
! arm*-*-*)
  	cpu_type=arm
  	extra_headers="mmintrin.h arm_neon.h"
  	c_target_objs="arm-c.o"
--- 279,285 ----
  strongarm*-*-*)
  	cpu_type=arm
  	;;
! arm*-*-* | mindstorms-*-*)
  	cpu_type=arm
  	extra_headers="mmintrin.h arm_neon.h"
  	c_target_objs="arm-c.o"
***************
*** 810,816 ****
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/rtems-elf.h rtems.h"
  	tmake_file="arm/t-arm arm/t-arm-elf t-rtems arm/t-rtems"
  	;;
! arm*-*-elf | ep9312-*-elf)
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
  	tmake_file="arm/t-arm arm/t-arm-elf"
  	;;
--- 810,816 ----
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/rtems-elf.h rtems.h"
  	tmake_file="arm/t-arm arm/t-arm-elf t-rtems arm/t-rtems"
  	;;
! arm*-*-elf | ep9312-*-elf | mindstorms-*-nxt*)
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
  	tmake_file="arm/t-arm arm/t-arm-elf"
  	;;
***************
*** 2895,2901 ****
  		done
  		;;
  
! 	arm*-*-*)
  		supported_defaults="arch cpu float tune fpu abi mode"
  		for which in cpu tune; do
  			# See if it matches any of the entries in arm-cores.def
--- 2895,2901 ----
  		done
  		;;
  
! 	arm*-*-* | mindstorms-*-*)
  		supported_defaults="arch cpu float tune fpu abi mode"
  		for which in cpu tune; do
  			# See if it matches any of the entries in arm-cores.def
***************
*** 3355,3361 ****
  		fi
  		;;
  
! 	arm*-*-*)
  		if test x$target_cpu_cname = x
  		then
  			target_cpu_default2=TARGET_CPU_generic
--- 3355,3361 ----
  		fi
  		;;
  
! 	arm*-*-* | mindstorms-*-*)
  		if test x$target_cpu_cname = x
  		then
  			target_cpu_default2=TARGET_CPU_generic
*** libgcc/config.host.orig	Thu May 14 17:11:45 2009
--- libgcc/config.host	Thu May 14 17:12:56 2009
***************
*** 74,80 ****
  strongarm*-*-*)
  	cpu_type=arm
  	;;
! arm*-*-*)
  	cpu_type=arm
  	;;
  bfin*-*)
--- 74,80 ----
  strongarm*-*-*)
  	cpu_type=arm
  	;;
! arm*-*-* | mindstorms-*-*)
  	cpu_type=arm
  	;;
  bfin*-*)
***************
*** 235,241 ****
  	;;
  arm*-*-rtems*)
  	;;
! arm*-*-elf | ep9312-*-elf)
  	;;
  arm*-wince-pe*)
  	;;
--- 235,241 ----
  	;;
  arm*-*-rtems*)
  	;;
! arm*-*-elf | ep9312-*-elf | mindstorms-*-*)
  	;;
  arm*-wince-pe*)
  	;;
*** config.sub.orig	Thu May 14 16:57:25 2009
--- config.sub	Mon May 18 10:09:15 2009
***************
*** 244,250 ****
  	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
  	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
  	| am33_2.0 \
! 	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
  	| bfin \
  	| c4x | clipper \
  	| d10v | d30v | dlx | dsp16xx \
--- 244,250 ----
  	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
  	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
  	| am33_2.0 \
! 	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 | mindstorms \
  	| bfin \
  	| c4x | clipper \
  	| d10v | d30v | dlx | dsp16xx \
***************
*** 1262,1268 ****
  	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
  	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
  	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
! 	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
  	# Remember, each alternative MUST END IN *, to match a version number.
  		;;
  	-qnx*)
--- 1262,1268 ----
  	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
  	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
  	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
! 	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -nxt*)
  	# Remember, each alternative MUST END IN *, to match a version number.
  		;;
  	-qnx*)
