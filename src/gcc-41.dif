
IMPORTANT NOTE: **** Please format patches as follows in order to comply with
all flavors of patch. ****

   *** <name>.old       Ddd Mmm DD HH:MM:SS YYYY
   --- <name>   Ddd Mmm DD HH:MM:SS YYYY

Where Ddd  = {Mon, Tue, Wed, Thu, Fri, Sat, Sun}
      Mmm  = {Jan - Dec}
      DD   = 00 - 31
      HH   = 00 - 23
      MM   = 00 - 59
      SS   = 00 - 59
      YYYY = a four digit year.

Note the ".old" extension on the old filename - any extension will do, but the
old filename must be different from the new filename.

When the old file doesn't exist, i.e. a brand new file is added, "<name>.old"
must be "/dev/null".

Patches must be generated with option -c3p and the "diff" command line not
appear in the patches themselves.

Patches must be relative to the toplevel directory.

New patches must be added at the bottom of the file.

ChangeLog entries must comply with the GNU Coding Standards and use TABs for
indentation.

ChangeLog entries must contain paths to files that are relative to the gcc/
subdirectory, except for changes at the toplevel or in other first-level
directories which must mention the full path.

ChangeLog entries must end with a line indicating the status of the patch with
regard to its integration in the official GCC tree at the FSF.

New ChangeLog entries must be added at the top of the file.

----------------------------------------------------------------

2009-04-14  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (field_byte_offset): Use the type size as the field size
	if the latter is not constant.

(Superseded by patch in gcc-43.dif)

2009-04-06  Eric Botcazou  <ebotcazou@adacore.com>

	* stor-layout.c (set_sizetype): Use the full precision of their
	machine mode for bitsize types.

(Superseded by patch in gcc-43.dif)

2009-03-18  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_init_constructor): Do a block move for very
	small objects as well.

(Superseded by patch in gcc-43.dif)

2009-03-10  Olivier Hainque  <hainque@adacore.com>

	* expr.c (target_align): Return 1 for BIT_FIELD_REF.

(Superseded by patch in gcc-43.dif)

2009-02-11  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-sink.c (statement_sink_location): Do not sink the statement
	if the RHS could trap.

(Superseded by patch in gcc-43.dif)

2009-02-09  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (build_range_check): Properly deal with enumeral and
	boolean base types.

(Superseded by patch in gcc-43.dif)

2008-12-08  Olivier Hainque  <hainque@adacore.com>

	* opts.c (handle_options): Inform that -fpreserve-control-flow
	is not supported at -O > 1.

(Superseded by patch in gcc-43.dif)

2008-11-18  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_type): Be prepared to deal with subtypes.
	* dwarf2out.c (base_type_die): Likewise.
	(is_subrange_type): Delete.
	(modified_type_die): Call subrange_type_for_debug_p.
	* tree.c (subrange_type_for_debug_p): New predicate based on the
	former is_subrange_type.
	* tree.h (subrange_type_for_debug_p): Declare.

(Superseded by patch in gcc-43.dif)

2008-11-06  Eric Botcazou  <ebotcazou@adacore.com>

	* ipa-inline.c (cgraph_estimate_growth): Discover self recursive
	functions.

(Superseded by patch in gcc-43.dif)

2008-11-05  Olivier Hainque  <hainque@adacore.com>

	* tree.h (CONSTRUCTOR_BITFIELD_P): True if NODE, a FIELD_DECL, is
	to be processed as a bitfield for constructor output purposes.
	* varasm.c (output_constructor): Use it.

(Superseded by patch in gcc-43.dif)

2008-11-05  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3
	* tree-ssa-loop-im.c (movement_possibility): Return MOVE_IMPOSSIBLE
	if the RHS might throw.
	* tree-ssa-pre.c (compute_avail): Don't call make_values_for_stmt
	if the statement might throw.

(Already in GCC 4.3)

2008-10-29  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/i386.c (classify_argument) <ARRAY_TYPE>: Promote partial
	integer class to full integer class if the offset is not word-aligned.

(Superseded by patch in gcc-43.dif)

2008-10-26  Eric Botcazou  <ebotcazou@adacore.com>

	* calls.c (store_unaligned_arguments_into_pseudos): Also look into the
	actual alignment of the argument if it lives in memory.

(Superseded by patch in gcc-43.dif)

2008-10-12  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.h (array_ref_element_size): Mention ARRAY_RANGE_REF in
	head comment.
	(array_ref_low_bound): Likewise.
	(array_ref_up_bound): Likewise.
	* expr.c (array_ref_element_size): Likewise.
	(array_ref_low_bound): Likewise.
	(array_ref_up_bound): Likewise.
	* tree-ssa-loop-ivopts.c (idx_contains_abnormal_ssa_name_p): Deal
	with ARRAY_RANGE_REF.
	(idx_find_step): Likewise.
	(idx_record_use): Likewise.
	(strip_offset_1): Likewise.
	(idx_remove_ssa_names): Likewise.

(Superseded by patch in gcc-43.dif)

2008-10-06  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_symbol) <PARM_DECL>: Deal with parameters pointing
	to variables for debugging purposes.

(Superseded by patch in gcc-43.dif)

2008-10-02  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.h (DECL_IGNORED_P): Document further effect for FUNCTION_DECL.
	* dbxout.c (dbxout_function_end): Do not test DECL_IGNORED_P.
	(dbxout_begin_function): Likewise.
	* final.c (dwarf2_debug_info_emitted_p): New predicate.
	(final_start_function): Do not emit debug info if DECL_IGNORED_P is
	set on the function.
	(final_end_function): Likewise.
	(final_scan_insn): Likewise.
	(rest_of_handle_final): Likewise.
	* varasm.c (assemble_start_function): Likewise.
	* config/rs6000/xcoff.h (ASM_DECLARE_FUNCTION_NAME): Likewise.

(Superseded by patch in gcc-43.dif)

2008-10-01  Tristan Gingold  <gingold@adacore.com>

	* common.opt (fpreserve-control-flow): New option.
	* doc/invoke.texi: Document it.
	* tree-ssa-phiopt.c (gate_phiopt): Disable if we are to
	preserve control flow.
	* opts.c (decode_options): Disable if-conversion if we are to
	preserve control flow.
	* fold-const.c (combine_comparisons): Disable optimizations
	over short-circuit operators if we are to preserve control flow.
	(fold_range_test, fold_truthop, fold_binary): Likewise.
	* doc/gcov.texi (Precise Decision Coverage): New section.

(Superseded by patch in gcc-43.dif)

2008-09-29  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa.c (tree_ssa_useless_type_conversion): Return false for
	VIEW_CONVERT_EXPRs from a non-base to a base integral type.

(Obsolete for GCC 4.3)

2008-09-29  Geert Bosch  <bosch@adacore.com>

	* tree.c (contains_placeholder_p): Return 0 for a SAVE_EXPR.

(Superseded by patch in gcc-43.dif)

2008-09-28  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (div_and_round_double) <ROUND_DIV_EXPR>: Fix typo.

(Installed in GCC 4.2 on 2008-09-28 - revision 140736)

2008-09-17  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 131433
	* tree-inline.c (estimate_num_insns_1): Compute cost of SWITCH_EXPR
	based on number of case labels.

(Already in GCC 4.3)

2008-09-17  Eric Botcazou  <ebotcazou@adacore.com>

	* varasm.c (initializer_constant_valid_p): Forbid view-conversions
	from aggregate to non-aggregate type if the bit pattern is not fully
	preserved afterwards.

(Superseded by patch in gcc-43.dif)

2008-09-12  Matthew Gingell  <gingell@adacore.com>

	* config.sub: Add lynxos5 to the set of canonical target
	operating systems.

(To be submitted)

2008-09-03  Eric Botcazou  <ebotcazou@adacore.com>

	* final.c (non_final_line_note): New function.
	(final_scan_insn): Do not force a source line after the prologue
	if the next instruction is a non-final line note.

(Superseded by patch in gcc-43.dif)

2008-08-12  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.3 (r111644)
	* targhooks.h (default_emutls_var_fields,
	default_emutls_var_init): Declare.
	* tree.h (DECL_THREAD_LOCAL): Compare against TLS_MODEL_REAL.
	* target.h (struct gcc_target): Add struct emutls member.
	* target-def.h (TARGET_EMUTLS_GET_ADDRESS,
	TARGET_EMUTLS_REGISTER_COMMON, TARGET_EMUTLS_VAR_SECTION,
	TARGET_EMUTLS_TMPL_SECTION, TARGET_EMUTLS_VAR_PREFIX,
	TARGET_EMUTLS_TMPL_PREFIX, TARGET_EMUTLS_VAR_FIELDS,
	TARGET_EMUTLS_VAR_INIT, TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS,
	TARGET_EMUTLS_VAR_ALIGN_FIXED, TARGET_EMUTLS): New.
	(TARGET_INITIALIZER): Add TARGET_EMUTLS.
	* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS,
	BUILT_IN_EMUTLS_REGISTER_COMMON): Get name from targetm structure.
	* dwarf2out.c (loc_descriptor_from_tree_1): Check if emutls can
	emit debug information.
	* coretypes.h (tls_model): Add TLS_MODEL_EMULATED, TLS_MODEL_REAL.
	* varasm.c: Include targhooks.h.
	(emutls_object_section, emutls_tmpl_section): New.
	(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): Remove.
	(EMUTLS_SEPARATOR): New.
	(prefix_name): New.
	(get_emutls_object_name): New.
	(default_emutls_var_fields): New, broken out of ...
	(get_emutls_object_type): ... here.  Adjust to use target hooks.
	(get_emutls_init_templ_addr): Adjust to use target hooks.
	(emutls_decl): Adjust to use target hooks.
	(emutls_finish): Likewise.
	(default_emutls_var_init): New, broken out of ...
	(assemble_variable): ... here.  Adjust to use target hooks.
	* output.h (enum section_category): Add SECCAT_EMUTLS_VAR,
	SECCAT_EMUTLS_TMPL.
	* c-common.c (handle_section_attribute): Prevent overriding
	sections for emulated tls with special sections.
	* config/i386/i386.c (x86_64_elf_select_section): Add
	SECCAT_EMUTLS_VAR and SECCAT_EMUTLS_TMPL.
	(x86_64_elf_unique_section): Likewise.
	* config/vxworks.c: Include tree.h.
	(vxworks_emutls_var_fields, vxworks_emutls_var_init): New.
	(vxworks_override_options): Set TLS scheme.
	* gcc/doc/tm.texi (Emulated TLS): New node.

	Partial backport from GCC 4.3 (r122335)
	* output.h (assemble_addr_to_section): Declare.
	(get_cdtor_priority_section): Likewise.
	* varasm.c (assemble_addr_to_section): New function.
	(get_cdtor_priority_section): Likewise.
	(default_named_section_asm_out_destructor): Use them.
	(destor_dtor_section_asm_out_destructor): Likewise.
	(default_named_section_asm_out_constructor): Likewise.
	(default_ctor_section_asm_out_constructor): Likewise.
	* config.gcc (*-*-vxworks*): Include vxworks.o.
	* config/t-vxworks (vxworks.o): New target.
	* config/vxworks.h (ALWAYS_NUMBER_CTORS_SECTIONS): Remove.
	(TARGET_ASM_CONSTRUCTOR): Define.
	(TARGET_ASM_DESTRUCTOR): Likewise.
	(vxworks_asm_out_constructor): Declare.
	(vxworks_asm_out_destructor): Likewise.

	Partial backport from GCC 4.3 (r122657)
	* config/vxworks.h (vxworks_override_options): Declare.
	(VXWORKS_OVERRIDE_OPTIONS): Use it.
	* config/vxworks.c: Include target.h and toplev.h.
	(vxworks_override_options): New function.
	* config/t-vxworks (vxworks.o): Depend on $(TARGET_H) and toplev.h.

(Already in GCC 4.3)

2008-08-12  Tristan Gingold  <gingold@adacore.com>

	Backport from GCC 4.3 (r121800)
	* Makefile.in (libgcc-support, libgcc.mvars): Add emutls.c.
	* builtin-types.def (BT_WORD): Make unsigned.
	(BT_FN_VOID_PTR_WORD_WORD_PTR): New.
	* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS): New.
	(BUILT_IN_EMUTLS_REGISTER_COMMON): New.
	* c-decl.c (grokdeclarator): Don't error if !have_tls.
	* c-parser.c (c_parser_omp_threadprivate): Likewise.
	* dwarf2out.c (loc_descriptor_from_tree_1): Don't do anything for
	emulated tls.
	* expr.c (emutls_var_address): New.
	(expand_expr_real_1): Expand emulated tls.
	(expand_expr_addr_expr_1): Likewise.
	* libgcc-std.ver: Add __emutls_get_address, __emutls_register_common.
	* output.h (emutls_finish): Declare.
	* toplev.c (compile_file): Call it.
	* tree-ssa-address.c (gen_addr_rtx): Check for const-ness of the
	address before wrapping in CONST.
	* varasm.c (emutls_htab, emutls_object_type): New.
	(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): New.
	(get_emutls_object_name, get_emutls_object_type): New.
	(get_emutls_init_templ_addr, emutls_decl): New.
	(emutls_common_1, emutls_finish): New.
	(assemble_variable): When emulating tls, swap decls; generate
	constructor for the emutls objects.
	(do_assemble_alias): When emulating tls, swap decl and target name.
	(default_encode_section_info): Don't add SYMBOL_FLAG_TLS_SHIFT
	for emulated tls.
	* varpool.c (decide_is_variable_needed): Look at force_output.
	Recurse for emulated tls.
	(cgraph_varpool_remove_unreferenced_decls): Remove checks redundant
	with decide_is_variable_needed.
	* emutls.c: New file.
	* config/sparc/sol2.h (ASM_DECLARE_OBJECT_NAME): Only emit
	tls_object for real tls.

(Already in GCC 4.3)

2008-07-08  Eric Botcazou  <ebotcazou@adacore.com>

	* configure.ac (HAVE_GETIPINFO): Check for _Unwind_GetIPInfo.
	* configure: Regenerate.
	* config.in: Likewise.
	* unwind-compat.c (_Unwind_GetIPInfo): New function.
	* unwind-dw2.c (struct _Unwind_Context): Add signal_frame field.
	(extract_cie_info): Handle S flag in augmentation string.
	(execute_cfa_program): If context->signal_frame, execute also
	fs->pc == context->ra instructions.
	(uw_frame_state_for): If context->signal_frame, don't subtract one
	from context->ra to find FDE.
	(uw_update_context_1): Set context->signal_frame to
	fs->signal_frame.
	(_Unwind_GetIPInfo): New function.
	* unwind-dw2.h (_Unwind_FrameState): Add signal_frame field.
	* unwind-c.c (PERSONALITY_FUNCTION): Use _Unwind_GetIPInfo instead
	of _Unwind_GetIP if HAVE_GETIPINFO is defined.
	* unwind-sjlj.c (_Unwind_GetIPInfo): New function.
	* unwind-generic.h (_Unwind_GetIPInfo): New prototype.
	* libgcc-std.ver (_Unwind_GetIPInfo): Export @@GCC_4.2.0.
	* config/alpha/osf5-unwind.h (alpha_fallback_frame_state):
	Set fs->signal_frame.
	* config/arm/unwind-arm.h (_Unwind_GetIPInfo): Define.
	* config/i386/linux-unwind.h (x86_fallback_frame_state,
	x86_64_fallback_frame_state): Set fs->signal_frame.
	(x86_frob_update_context): New function.
	(MD_FROB_UPDATE_CONTEXT): Define.
	* config/i386/freebsd-unwind.h (x86_freebsd_fallback_frame_state):
	Set fs->signal_frame.
	* config/i386/sol2-unwind.h (sol2_fallback_frame_state): Likewise.
	* config/i386/win32-unwind.h (x86_fallback_frame_state): Do not
	restore reg #9.  Remove +1 adjustment to EIP.  Set fs->signal_frame.
	* config/ia64/unwind-ia64.c (_Unwind_GetIPInfo): New function.
	* config/mips/iris6-unwind.h (mips_fallback_frame_state): Remove +4
	adjustment to PC.  Set fs->signal_frame.
	* config/pa/hpux-unwind.h (pa_fallback_frame_state): Likewise.
	* config/rs6000/aix-unwind.h (ppc_aix_fallback_frame_state): Likewise.
	* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Likewise.
	(MD_FROB_UPDATE_CONTEXT): Define unconditionally.
	(frob_update_context): Likewise.  Workaround missing S flag in
	Linux 2.6.12 - 2.6.16 kernel vDSOs.
	* config/rs6000/vxworks-unwind.h (ppc_vxworks_fallback_frame_state):
	Set fs->signal_frame.
	* config/s390/linux-unwind.h (s390_fallback_frame_state): Likewise.
	Remove psw_addr + 1 hack.
	* config/sparc/sol2-unwind.h (sparc64_fallback_frame_state): Do not
	rely on unaligned PC.  Use reg Y location for -8 adjustment to PC.
	(sparc64_frob_update_context): Recognize signal frame explicitly.
	(sparc_fallback_frame_state): Do not rely on unaligned PC.  Use reg
	Y location for -8 adjustment to PC.

(Superseded by patch in gcc-43.dif)

2008-07-08  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-nested.c (walk_stmts) <COND_EXPR>: Request a GIMPLE value.

(Superseded by patch in gcc-43.dif)

2008-07-07  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_reg_parms): Deal with BOOLEAN_TYPE.

(Superseded by patch in gcc-43.dif)

2008-07-07  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (is_subrange_type): Deal with BOOLEAN_TYPE.

(Superseded by patch in gcc-43.dif)

2008-06-30  Eric Botcazou  <ebotcazou@adacore.com>

	* config/sparc/sparc.h (CANNOT_CHANGE_MODE_CLASS): Disable change from
	SFmode to a mode with different size in floating-point registers.

(Superseded by patch in gcc-43.dif)

2008-06-27  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-forwprop.c (forward_propagate_into_cond_1): Fix oversight.

(Irrelevant for GCC 4.3)

2008-06-12  Tristan Gingold  <gingold@adacore.com>

	* tree-pretty-print.c (dump_generic_node): Use "%d" instead of
	HOST_WIDE_INT_PRINT_DEC as a format of pp_printf.

(Irrelevant for GCC 4.3)

2008-06-06  Eric Botcazou  <ebotcazou@adacore.com>
            Olivier Hainque  <hainque@adacore.com>

	* builtins.c (get_memory_rtx): Accept byte-addressable bitfields.
	Use DECL_SIZE_UNIT to retrieve the size of the field.

(Superseded by patch in gcc-43.dif)

2008-05-22  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (highest_pow2_factor) <BIT_AND_EXPR>: New case.

(Superseded by patch in gcc-43.dif)

2008-05-20  Tristan Gingold  <gingold@adacore.com>

	* config/avr/avr.c (avr_3bytes_pc_p): Declare.
	(struct base_arch_s): Add is_3bytes_pc field.
	(avr_arch_types): Add value for is_3bytes_pc, add avr6.
	(avr_mcu_types): Add avr6.
	(avr_override_options): Set avr_3bytes_pc_p.
	(initial_elimination_offset): Takes avr_3bytes_pc_p into account.

(Already in GCC 4.3)

2008-05-19  Tristan Gingold  <gingold@adacore.com>

	* config/avr/avr.c (avr_output_function_prologue): Use gs relocations.

(Superseded by patch in gcc-43.dif)

2008-05-17  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 135468
	* fold-const.c (fold_unary) <CASE_CONVERT>: Fold the cast into
	a BIT_AND_EXPR only for an INTEGER_TYPE.

(Already in GCC 4.3)

2008-05-14  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c: Include pointer-set.h.
	(mostly_copy_tree_r): Copy trees under SAVE_EXPR and TARGET_EXPR
	nodes, but only once.  Stop at BIND_EXPR nodes.  Do not propagate
	the 'data' argument to copy_tree_r.
	(copy_if_shared_r): Unshare trees under SAVE_EXPR and TARGET_EXPR
	nodes, but only once.  Remove redundant code dealing with types,
	decls and constants.  Remove bogus ATTRIBUTE_UNUSED marker.
	Propagate 'data' argument to walk_tree.
	(copy_if_shared): New function.
	(unmark_visited_r): Unmark trees under SAVE_EXPR and TARGET_EXPR
	nodes, but only once.  Remove bogus ATTRIBUTE_UNUSED marker.
	(unmark_visited): New function.
	(unshare_body): Call copy_if_shared instead of doing it manually.
	(unvisit_body): Call unmark_visited instead of doing it manually.
	(unshare_all_trees): Likewise.
	* Makefile.in (gimplify.o): Add pointer-set.h dependency.

(Superseded by patch in gcc-43.dif)

2008-05-06  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (expand_expr_real_1) <VIEW_CONVERT_EXPR>: When converting
	to BLKmode, try to fetch an inner memory reference.  Use 'mode' in
	lieu of TYPE_MODE (type) throughout.

(Superseded by patch in gcc-43.dif)

2008-04-27  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (sra_type_can_be_decomposed_p) <RECORD_TYPE>: Make sure
	that the bitfield is of integral type before testing its precision.

(Superseded by patch in gcc-43.dif)

2008-04-24  Olivier Hainque  <hainque@adacore.com>

	* dwarf2out.c (add_subscript_info): New explicit COLLAPSE_P
	argument, saying whether nested array types should be collapsed
	as multiple outer level subscripts.
	(gen_array_type_die): Factorize comments about the MIPS_DEBUG_INFO
	issues and centralize the nested array types collapsing control.

(Superseded by patch in gcc-43.dif)

2008-04-22  Nicolas Roche <roche@adacore.com>

	* configure.ac: Update to support new gcc-interface subdirectory.
	* configure: Regenerate.
	* gengtype.c: Update to support new  gcc-interface subdirectory.

(Superseded by patch in gcc-43.dif)

2008-04-14  Tristan Gingold  <gingold@adacore.com>

	* dwarf2out.c (loc_descriptor_from_tree_1): Add CONST_DECL and
	COMPLEX_CST cases.

(Superseded by patch in gcc-43.dif)

2008-04-11  Tristan Gingold  <gingold@adacore.com>

	* dwarf2out.c (rtl_for_decl_init): Allow pointers in initializers.
	(rtl_for_decl_location): Get initializer for CONST_DECL.
	(add_location_or_const_value_attribute): Accept CONST_DECL.
	(gen_decl_die): Generated a die for a CONST_DECL if not of
	ENUMERAL_TYPE type.
	(dwarf2out_decl): Ditto.

(Superseded by patch in gcc-43.dif)

2008-04-10  Tristan Gingold  <gingold@adacore.com>

	* config/rs6000/linux.h (STACK_CHECK_STATIC_BUILTIN): Define.

(Superseded by patch in gcc-43.dif)

2008-04-07  Jose Ruiz  <ruiz@adacore.com>

	* config/sparc/erc32.h (LINK_SPEC): Do not use the default linker
	script if there is one that is specified in the command line.
	* config/sparc/leon.h (LINK_SPEC): Likewise.

(Superseded by patch in gcc-43.dif)

2008-04-03  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_modify_expr_rhs) <COND_EXPR>: Gimplify the LHS
	using the is_gimple_lvalue predicate instead of is_gimple_min_lval.

(Superseded by patch in gcc-43.dif)

2008-04-02  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/vxworks-unwind.h (sigcontext_for): Refine code
	pattern matcher.

(Superseded by patch in gcc-43.dif)

2008-04-01  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-inline.c (expand_call_inline): Record the callee before
	initializing the parameters.

(Obsolete for GCC 4.3)

2008-03-29  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold) <ARRAY_REF>: New case.  Try to fold constant
	reference in constructor with non self-referential type.

(Superseded by patch in gcc-43.dif)

2008-03-25  Eric Botcazou  <ebotcazou@adacore.com>

	Stack checking with moving stack pointer
	* expr.h (STACK_CHECK_PROBE_IOR): Define if not defined.
	(STACK_CHECK_MOVING_SP): Likewise.
	* doc/tm.texi (Stack Checking): Document them.
	* explow.c (emit_stack_probe): Deal with STACK_CHECK_PROBE_IOR.
	(probe_stack_range): Make sure the address of probes is valid.
	Try to use [base + disp] addressing mode as much as possible.
	(anti_adjust_stack_and_probe): New function.
	(allocate_dynamic_stack_space): Do not directly allocate space
	if STACK_CHECK_MOVING_SP, instead invoke above function.
	* reload1.c (init_elim_table): Set frame_pointer_needed if
	stack checking is enabled and STACK_CHECK_MOVING_SP.
	* rtlanal.c: Include expr.h.
	(may_trap_p_1) <MEM>: If STACK_CHECK_MOVING_SP, return 1 for
	volatile references to the stack pointer.
	* Makefile.in (rtlanal.o): Add dependency on EXPR_H.
	* config/i386/i386.h (STACK_CHECK_STATIC_BUILTIN): Delete.
	(STACK_CHECK_PROBE_IOR): Define to 1.
	* config/i386/cygming.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/freebsd.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	(STACK_CHECK_MOVING_SP): Likewise.
	* config/i386/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	(STACK_CHECK_MOVING_SP): Likewise.
	* config/i386/lynx.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/sol2.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/vxworks.h (STACK_CHECK_STATIC_BUILTIN): Likewise.
	* config/i386/i386.c (ix86_target_stack_probe): Fix nit.
	(ix86_compute_frame_layout): Force use of push instructions to
	save registers if stack checking with probes is enabled.
	(get_scratch_register_on_entry): New function.
	(release_scratch_register_on_entry): Likewise.
	(ix86_gen_adjust_stack_and_probe): Likewise.
	(ix86_adjust_stack_and_probe): Likewise.
	(output_probe_op): Likewise.
	(output_adjust_stack_and_probe_op): Likewise.
	(output_adjust_stack_and_probe): Likewise.
	(ix86_gen_probe_stack_range): Likewise.
	(ix86_emit_probe_stack_range): Remove unused code.  Use above
	functions to get a scratch register and to deal with 64-bit mode.
	(output_probe_stack_range_op): New function extracted from...
	(output_probe_stack_range): ...here.  Add third parameter, use
	only at most one auxiliary register and deal with 64-bit mode.
	(ix86_expand_prologue): Emit probing code for stack checking
	only after pushing registers in the frame.
	* config/i386/i386-protos.h (output_adjust_stack_and_probe): New.
	(output_probe_stack_range): Add third parameter.
	* config/i386/i386.md (adjust_stack_and_probe): New pattern.
	(probe_stack_range): Deal with 64-bit mode.
	(logical operation peepholes): Do not split stack checking probes.

(Superseded by patch in gcc-43.dif)

2008-03-12  Nicolas Roche  <roche@adacore.com>

	* Makefile.in: Add variable CROSS that contains the value of @CROSS@.

(Superseded by patch in gcc-43.dif)

2008-03-07  Eric Botcazou  <ebotcazou@adacore.com>

	* common.opt (-fsjlj): New option.

(Superseded by patch in gcc-43.dif)

2008-02-25  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/aix.h (COLLECT_PRESERVE_RO_OUTPUT): Define.

(Superseded by patch in gcc-43.dif)

2008-02-25  Olivier Hainque  <hainque@adacore.com>

	* doc/tm.texi (COLLECT_PRESERVE_RO_OUTPUT):  New macro.  Wether
	collect2 should preserve an existing read-only output file and
	return on error if one is found, typically as the target linker
	would.
	* collect2.c (collect_exit): Honor an extra keep_output argument,
	preserve the output_file if non-zero.
	(fatal_perror, fatal, collect_wait, do_wait): Adjust calls.
	(main): Adjust calls and honor COLLECT_PRESERVE_RO_OUTPUT.
	* collect2.h (collect_exit): Adjust prototype.
	* tlink.c (do_tlink): Adjust calls.

(Superseded by patch in gcc-43.dif)

2008-02-20  Olivier Hainque  <hainque@adacore.com>

	* config/alpha/t-osf4 (SHLIB_LINK): Do not hide the dummy weak
	pthread symbols.

(Superseded by patch in gcc-43.dif)

2008-02-19  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/vxworks.h (MD_UNWIND_SUPPORT): Define.
	* config/rs6000/vxworks-unwind.h: New file.

(Superseded by patch in gcc-43.dif)

2008-02-17  Eric Botcazou  <ebotcazou@adacore.com>

	* stor-layout.c (layout_decl): Do not bump the alignment of a
	bit-field to more than byte alignment if it is packed.

(Superseded by patch in gcc-43.dif)

2008-02-08  Olivier Hainque  <hainque@adacore.com>

	* gimplify.c (gimplify_modify_expr): When turning a varsize
	assignment from constructor into memset, assert that the
	constructor is empty.

(Superseded by patch in gcc-43.dif)

2008-02-06  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 132088
	* print-tree.c (print_node) <CONSTRUCTOR>: Print elements.

(Already in GCC 4.3)

2008-02-05  Eric Botcazou  <ebotcazou@adacore.com>

	* cfgbuild.c (control_flow_insn_p) <INSN>: Return false for nops.

(Obsolete for GCC 4.3)

2008-02-01  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (view_convert_barrier_p): New predicate.
	(sra_walk_modify_expr): Use it to disable scalarization of aggregates
	also manipulated as scalar objects of the same size.

(Superseded by patch in gcc-43.dif)

2008-02-01  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-inline.c (copy_body_r): Copy TREE_SIDE_EFFECTS along with
	TREE_THIS_VOLATILE on INDIRECT_REF nodes.

(Superseded by patch in gcc-43.dif)

2008-01-29  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_global_decl): Skip local static variables.

(Superseded by patch in gcc-43.dif)

2008-01-26  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 120681
	* tree-ssa-operands.c (get_indirect_ref_operands): Propagate the
	volatileness of the operand to the statement.

(Already in GCC 4.3)

2008-01-18  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (sra_walk_expr) <VIEW_CONVERT_EXPR>: Disable
	scalarization if on the LHS and not a full access.

(Superseded by patch in gcc-43.dif)

2008-01-18  Olivier Hainque  <hainque@adacore.com>

	* config/arm/arm.c (args_to_rsa_distance): New function.  Distance
	between the arguments and the registers save area.
	(arm_get_frame_offsets): Account for this distance in the frame
	pointer and registers area offset computations.
	(arm_expand_prologue): Count the "ip" push in the amount of space
	we use to save registers past the arguments area.
	(arm_compute_initial_elimination_offset) <from ARG_POINTER_REGNUM>:
	Rewrite expressions along the lines of a straight common pattern.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2008-01/msg00759.html)

2008-01-16  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (store_field): Do a block copy from BLKmode to BLKmode-like.
	(get_inner_reference): Use BLKmode for byte-aligned BLKmode bitfields.

(Superseded by patch in gcc-43.dif)

2008-01-12  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold_unary) <VIEW_CONVERT_EXPR>: Fold an existing
	NOP_EXPR if it is between integral types with the same precision.

(Installed in GCC 4.3 on 2008-01-12 - revision 131493)

2007-12-22  Eric Botcazou  <ebotcazou@adacore.com>

	* flow.c (find_regno_partial): Recognize partial moves involving
	inclusive OR operations.

(Irrelevant for GCC 4.3)

2007-12-18  Jerome Lambourg  <lambourg@adacore.com>

	* libiberty/argv.c (expandargv): Take care of Windows CR files
	by opening the file as a binary file.

(Already in GCC 4.3)

2007-12-15  Eric Botcazou  <ebotcazou@adacore.com>

	* config/rs6000/lynx.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.

(Superseded by patch in gcc-43.dif)

2007-12-13  Jerome Lambourg  <lambourg@adacore.com>

	* config/i386/linux.h (STARTFILE_SPEC): Redefine - do not use special
	startup object for profiling.
	(LIB_SPEC): Redefine - use libgnatmon for profiling.
	* config/i386/linux64.h (STARTFILE_SPEC): Likewise.
	(LIB_SPEC): Likewise.
	* config/i386/mingw32.h (LIB_SPEC): Use libgnatmon for profiling
	instead of libgmon.
	(STARTFILE_SPEC): Do not use special startup object for profiling.
	* config/i386/t-sol2 (gmon.o): Delete.
	* config/i386/t-sol2-10 (EXTRA_MULTILIB_PARTS): Remove gmon.o.
	* config/sol2.h (LIB_SPEC): Use libgnatmon when profiling.
	(STARTFILE_SPEC): Do not use special startup object for profiling.
	* config/sparc/t-sol2 (gmon.o): Delete.
	* config/sparc/t-sol2-64 (EXTRA_MULTILIB_PARTS): Remove gmon.o.
	* config.gcc (i[34567]86-*-solaris2*): Remove gmon.o from extra_parts.
	(sparc-*-solaris2*): Likewise.

(Superseded by patch in gcc-43.dif)

2007-12-05  Geert Bosch  <bosch@adacore.com>

	* config/arm/nucleus.h (CLEAR_CACHE_INSN): New definition for Nucleus.

(Superseded by patch in gcc-43.dif)

2007-12-03  Eric Botcazou  <ebotcazou@adacore.com>

	Stack checking with stack limit
	* explow.c (stack_check_symbol): New public variable.
	(STACK_HIGH, STACK_LOW): New macro.
	(probe_stack_range): Add support for stack limits provided by the
	stack_check_symbol variable.
	* rtl.h (stack_check_symbol): Declare.
	* config/i386/vxworksae.h (VXWORKS_STACK_CHECK_SPEC): Delete.
	* config/i386/vxworks.h (CC1_SPEC): Remove VXWORKS_STACK_CHECK_SPEC.
	(VXWORKS_STACK_CHECK_SPEC): Delete.
	* config/i386/i386-protos.h (output_cond_trap): Declare.
	* config/i386/i386.c (ix86_emit_probe_stack_range): Add support for
	stack limits provided by the stack_check_symbol variable.
	(output_cond_trap): New function.
	* config/i386/i386.md (cond_trap): New pattern.
	* config/rs6000/vxworksae.h (VXWORKS_STACK_CHECK_SPEC): Delete.
	* config/rs6000/vxworks.h (CC1_SPEC): Remove VXWORKS_STACK_CHECK_SPEC.
	(VXWORKS_STACK_CHECK_SPEC): Delete.
	* config/rs6000/rs6000.c (rs6000_emit_probe_stack_range): Add support
	for stack limits provided by the stack_check_symbol variable.

(Superseded by patch in gcc-43.dif)

2007-12-02  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (force_location_on_expr_r): New walk_tree callback.
	(force_location_on_expr): New function.
	(gimplify_call_expr): Use it to force the source location on
	the argument preparation statements.
	* tree.h (force_location_on_expr): Declare.

(Superseded by patch in gcc-43.dif)

2007-11-28  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (constant_size): Use HOST_WIDE_INT in parameter type.

(Superseded by patch in gcc-43.dif)

2007-11-17  Eric Botcazou  <ebotcazou@adacore.com>

	Elimination of stack trampolines
	* common.opt (-Wtrampolines): New warning.
	(-ftrampolines): New option.
	* opts.c (decode_options): Force -ftrampolines if the target doesn't
	use runtime descriptors.
	* doc/invoke.texi (Code Gen Options): Document them.
	* doc/tm.texi (Trampolines): Document USE_RUNTIME_DESCRIPTORS.
	* builtins.def: Add *_init_descriptor and *_adjust_descriptor.
	* builtins.c (expand_builtin_init_trampoline): Do not set
	trampolines_created here.
	(expand_builtin_init_descriptor): New function.
	(expand_builtin_adjust_descriptor): Likewise.
	(expand_builtin) <BUILT_IN_INIT_DESCRIPTOR>: New case.
	<BUILT_IN_ADJUST_DESCRIPTOR>: Likewise.
	* calls.c (prepare_call_address): Change purpose of last parameter.
	Deal with indirect calls by descriptor.
	(call_expr_flags): Set ECF_BY_DESCRIPTOR for calls by descriptor.
	(expand_call): Likewise.  Adjust call to prepare_call_address.
	* rtlanal.c (find_first_parameter_load): Treat the static chain
	register specially if USE_RUNTIME_DESCRIPTORS is 1.
	* tree.h (FUNC_ADDR_BY_DESCRIPTOR): New flag on ADDR_EXPR.
	(CALL_EXPR_BY_DESCRIPTOR): New flag on CALL_EXPR.
	(ECF_BY_DESCRIPTOR): New mask.
	* tree.c (build_common_builtin_nodes): Initialize *_init_descriptor
	and *_adjust_descriptor.
	* tree-nested.c: Include toplev.h.
	(struct nesting_info): Add 'any_descr_created' field.
	(get_trampoline_type): Fix oversight, change field name.
	(get_descriptor_type): New function.
	(lookup_element_for_decl): Likewise.
	(create_field_for_decl): Likewise.
	(lookup_tramp_for_decl): Factor out code into above functions.
	(lookup_descr_for_decl): New function.
	(convert_tramp_reference): Set trampolines_created here.  Issue
	a warning on trampoline generation.  Deal with descriptors.
	(build_init_call_expr): New function.
	(finalize_nesting_tree_1): Factor out code into above function.
	Deal with descriptors.
	* toplev.c (process_options): Force alignment of functions to 16
	at least if -ftrampolines.
	* defaults.h (TRAMPOLINE_ALIGNMENT): Force to 16 at least if
	USE_RUNTIME_DESCRIPTORS is 1.
	* config/alpha/alpha.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/alpha/vms.h (USE_RUNTIME_DESCRIPTORS): Redefine to 0.
	* config/i386/i386.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/i386/i386.md (sibcall_1): Disparage 'c' alternative.
	(sibcall_value_1): Likewise.
	* config/ia64/ia64.h (USE_RUNTIME_DESCRIPTORS): Define to 0.
	* config/mips/mips.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/pa/pa.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/rs6000/rs6000.h (USE_RUNTIME_DESCRIPTORS): Define to 1.
	* config/rs6000/aix.h (USE_RUNTIME_DESCRIPTORS): Redefine to 0.
	* config/sparc/sparc.h (USE_RUNTIME_DESCRIPTORS): Define to 1.

(Superseded by patch in gcc-43.dif)

2007-11-16  Eric Botcazou  <ebotcazou@adacore.com>

	* expmed.c (store_fixed_bit_field): Always use convert_to_mode in
	order to convert between modes.
	(extract_bit_field): Test TRULY_NOOP_TRUNCATION on the right mode.

(Superseded by patch in gcc-43.dif)

2007-10-22  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.h (TREE_STATIC): Fully document usage on ADDR_EXPR.
	* tree-nested.c (convert_tramp_reference) <ADDR_EXPR>: Do not
	build a trampoline if we don't want one.
	* varasm.c (initializer_constant_valid_p) <ADDR_EXPR>: Do not
	return zero for nested functions if we don't want a trampoline.

(Superseded by patch in gcc-43.dif)

2007-10-17  Tristan Gingold  <gingold@adacore.com>

	* libgcov.c (gcov_version): Add strict_p argument and be more
	tolerant if strict_p is false.
	(gcov_exit): Call gcov_version with strict_p set to true.
	(__gcov_init): Call gcov_version with strict_p set to false.

(To be ported, not to be submitted - local fix)

2007-10-16  Olivier Hainque  <hainque@adacore.com>

	* config/arm/unwind-arm.h (_Unwind_Reason_Code): Add missing
	values for _URC_FATAL_PHASE2_ERROR, _URC_FATAL_PHASE1_ERROR and
	_URC_NORMAL_STOP.

(To be submitted)

2007-10-16  Olivier Hainque  <hainque@adacore.com>

	Backport from GCC 4.3 revision 121377
	* config/arm/unwind-arm.h (_sleb128_t, _uleb128_t): New.

(Already in GCC 4.3)

2007-10-15  Olivier Hainque  <hainque@adacore.com>

	Backport from GCC 4.2 revision 117056 (PR 28516)
	* config/arm/arm.c (arm_unwind_emit_set): Handle reg = sp + const.

(Already in GCC 4.2)

2007-10-12  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.h (dbxout_static_link): Declare.
	* dbxout.c (static_link_var): New static variable.
	(dbxout_init): Initialize it with "__link" name.
	(dbxout_begin_function): Call dbxout_static_link if needed.
	(dbxout_static_link): New function.
	* xcoffout.c: Include function.h.
	(xcoffout_begin_prologue): Call dbxout_static_link if needed.
	* Makefile.in (xcoffout.o): Depend on function.h.
	* function.c (instantiate_decls): Process the static chain.
	(expand_function_start): If not optimizing, save the static chain
	onto the stack.
	* tree-nested.c (struct nesting_info): Add address_taken field.
	(mark_reachable_function_1): Add address_taken parameter.
	Set the field of the same name for the function if it is set.
	(mark_reachable_functions_1): Adjust calls to above functions.
	(convert_local_reference): Declare the transformation
	of variables and parameters for debugging purposes.
	(convert_all_function_calls): Always create the static chain for
	nested functions if not optimizing, unless causing trampolines.

(Superseded by patch in gcc-43.dif)

2007-10-08  Geert Bosch  <bosch@adacore.com>

	* config/arm/nucleus.h: New file.
	* config/arm/t-nucleus: New file.
	* config.gcc: Add arm*-*-nucleus*.
	* libcpp/configure.ac: Add arm*-*-nucleus* to list of targets
	  requiring 64-bit host wide int.
	* libcpp/configure: Regenerate.

(Superseded by path in gcc-43.dif)

2007-10-05  Eric Botcazou  <ebotcazou@adacore.com>

	* config/alpha/alpha.c (alpha_in_small_data_p): Compile only for ELF.
	(TARGET_IN_SMALL_DATA_P): Define only for ELF.

(Superseded by patch in gcc-43.dif)

2007-10-04  Tristan Gingold  <gingold@adacore.com>

	* gcov.c (create_file_names): If no object directory is specified,
	keep directories of file_name.

(Superseded by patch in gcc-43.dif)

2007-10-03  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (NO_DBX_FUNCTION_END): Delete.
	(NO_DBX_BNSYM_ENSYM): Likewise.
	(DBX_BNSYM_ENSYM): Define if not defined.
	(dbxout_function_end): Delete uses of NO_DBX_FUNCTION_END and
	replace uses of NO_DBX_BNSYM_ENSYM with DBX_BNSYM_ENSYM.
	(dbxout_begin_prologue): Likewise.
	* mips-tfile.c (section_headers): New static variable.
	(rdata_vaddr): Likewise.
	(rdata_ptr): Likewise.
	(parse_stabs_common): Deal with special N_FUN with empty string.
	(copy_object): Read section headers and contents of .rdata section.
	* doc/tm.texi (DBX Options): Delete NO_DBX_FUNCTION_END and replace
	NO_DBX_BNSYM_ENSYM with DBX_BNSYM_ENSYM.
	* config/darwin.h (DBX_BNSYM_ENSYM): Define to 1.
	* config/alpha/alpha.h (DBX_CONTIN_LENGTH): Move to...
	(NO_DBX_FUNCTION_END): Delete.
	 * config/alpha/osf.h (DBX_CONTIN_LENGTH): ...here.
	(DBX_OUTPUT_NFUN): Define.

(Superseded by patch in gcc-43.dif)

2007-10-01  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/i386-protos.h (i386_pe_rwreloc_select_section): New.
	(i386_pe_rwreloc_select_rtx_section): Likewise.
	* config/i386/mingw32.h (TARGET_ASM_SELECT_SECTION): Redefine.
	(TARGET_ASM_SELECT_RTX_SECTION): Likewise.
	(TARGET_RWRELOC): Define to 1.
	* config/i386/winnt.c (TARGET_RWRELOC): Define if not defined.
	(i386_pe_rwreloc_select_section): New target hook.
	(i386_pe_rwreloc_select_rtx_section): Likewise.
	(i386_pe_unique_section): Deal with TARGET_RWRELOC.
	(i386_pe_section_type_flags): Likewise.

(Superseded by patch in gcc-43.dif)

2007-09-27  Olivier Hainque  <hainque@adacore.com>

	* dbxout.c (SCOPE_LABEL_BASENAME): New local macro.  Use it instead
	of a hardcoded "Lscope" in several places, all below.
	(scope_labelno): Remove. Use current_function_funcdef_no instead.
	(dbxout_end_epilogue): New hook.  Emit the function scope label
	here instead of ...
	(dbxout_function_end): here. Process targets without named sections
	as the others.
	(dbxout_block): Adjust comment mentioning where the label is emitted.

(Superseded by patch in gcc-43.dif)

2007-09-27  Tristan Gingold  <gingold@adacore.com>

	* gcov.c (main): Call expandargv to handle response file.

(Superseded by patch in gcc-43.dif)

2007-09-26  Tristan Gingold  <gingold@adacore.com>

	PR middle-end/29609
	* basic-block.h (EDGE_EXPLICIT): New constant.
	(EDGE_ALL_FLAGS): Updated.
	* cfgcleanup.c (try_forward_edges): Do not forward if an edge is
	explicit.
	(try_optimize_cfg): Likewise.
	* cfghooks.c (tidy_fallthru_edges): Do not tidy explicit edges.
	* cfgrtl.c (try_redirect_by_replacing_jump): Do not replace explicit
	gotos.
	(rtl_verify_flow_info_1): Consider EDGE_EXPLICIT.
	* c-typeck.c (c_finish_goto_label): Set GOTO_EXPLICIT_P if not
	optimizing.
	(c_finish_goto_ptr): Likewise.
	(c_finish_bc_stmt): Likewise.
	* gimple-low.c (lower_cond_expr): Create goto even for branch
	containing only a simple explicit goto.
	* tree-cfg.c (make_goto_expr_edges): An explicit goto creates an
	explicit edge.
	(tree_can_merge_blocks_p): Do not merge if explicit edges.
	(remove_useless_stmts_goto): Do not remove explicit gotos.
	(simple_implicit_goto_p): New function.
	(disband_implicit_edges): Do not disband explicit edges.
	* tree-flow.h: Prototype of simple_implicit_goto_p added.
	* tree.h (GOTO_EXPLICIT_P): New macro.

(Obsolete for GCC 4.3)

2007-09-24  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-dom.c (find_equivalent_equality_comparison): Do not
	propagate SSA names occurring in abnormal PHI nodes.

(Obsolete for GCC 4.3)

2007-09-21  Eric Botcazou  <ebotcazou@adacore.com>

	* alias.h (record_alias_subset): Declare.
	* alias.c (record_alias_subset): Make public.
	* tree-inline.c (struct inline_data): Add ref_all_alias_set field.
	(remap_type_1): Build ref-all pointers and references if their
	designated type can be pointed to by ref-all pointers.
	(remap_type): Do not punt on pointers if there are ref-all pointers.
	(setup_one_parameter): Propagate the TYPE_REF_CAN_ALIAS_ALL flag to
	the new variable if necessary.

(Superseded by patch in gcc-43.dif)

2007-09-18  Olivier Hainque  <hainque@adacore.com>

	* config/mips/t-slibgcc-irix (SHLIB_LC): Add -lm.

(Variant already in GCC 4.3 - PR target/32538 [mips-irix])

2007-09-17  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_parms): Restore adjustment lost in translation.

(Superseded by patch in gcc-43.dif)

2007-09-15  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 118716
	* alias.c (fixed_scalar_and_varying_struct_p): Do not return a
	non-null value if the struct memory access has the null alias set.

(Already in GCC 4.3)

2007-09-14  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (subrange_type_die): Do not create a DIE for the
	enumeration type without looking it up first.

(Obsolete for GCC 4.3)

2007-09-14  Olivier Hainque  <hainque@adacore.com>

	* config.gcc (powerpc-xcoff-lynxos): New target configuration.
	* config/rs6000/rs6000.h (TARGET_LYNXOS): New macro, default to 0.
	* config/lynx.h (TARGET_LYNXOS): Define to 1.
	* config/rs6000/lynx-xcoff.h: New file.
	* config/rs6000/lynx-xcoff.opt: New file.

	* config/rs6000/rs6000.c (TARGET_UNALIGNED_OPs): Don't use the
	generic xcoff definitions for Lynx, fallback to the Darwin ones.
	(print_operand_address): Handle legitimate_constant_pool addresses
	on xcoff lynx the same way as on xcoff aix.
	(rs6000_xcoff_file_start): Open .toc before everything else.

(To be submitted [ppc-lynx])

2007-09-14  Olivier Hainque  <hainque@adacore.com>

	* dbxout.c (PREVENT_STATIC_DEBUG_ONLY_BLOCKS): New internal macro.
	(dbxout_symbol_location): Make a static block for static debug-only
	symbols if !PREVENT_STATIC_DEBUG_ONLY_BLOCKS.

(Superseded by patch in gcc-43.dif)

2007-09-10  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris.h (DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET):
	Define.

(Superseded by patch in gcc-43.dif)

2007-09-08  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 121116
	* unwind-generic.h (_uleb128_t): Define to _Unwind_Word.
	(_sleb128_t): Define to _Unwind_Sword.

(Already in GCC 4.3)

2007-09-07  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_symbol_location): Be prepared for file scope in
	the special (MEM (CONST (...))) case too.
	Deal with null address specially if DBX_STATIC_BLOCK_START.

(Superseded by patch in gcc-43.dif)

2007-09-06  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.3 revision 127136
	* reload.c (find_reloads_address_part): Pass correct MEMREFLOC
	argument to find_reloads_address.

(Already in GCC 4.3)

2007-09-04  Tristan Gingold  <gingold@adacore.com>

	* profile.c (branch_prob): Also call output_location on expression
	of a MODIFY_EXPR.

(Superseded by patch in gcc-43.dif)

2007-09-04  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris6-unwind.h (sigcontext_for): Adjust to
	match more cases of observed code patterns on Irix variants.

(Superseded by patch in gcc-43.dif)

2007-09-04  Olivier Hainque  <hainque@adacore.com>

	* config/mips/mips.h (WIDEST_HARDWARE_FP_SIZE): Define.

(Superseded by patch in gcc-43.dif)

2007-09-04  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris6.h (IRIX_SUBTARGET_LINK_SPEC): Disable all
	linker warnings.

(Superseded by patch in gcc-43.dif)

2007-09-03  Eric Botcazou  <ebotcazou@adacore.com>

	* config/alpha/alpha.md (movti): Use operand_subword for the split.

(Installed in GCC 4.3 on 2007-09-23 - revision 128690)

2007-07-27  Olivier Hainque  <hainque@adacore.com>

	* config/alpha/osf5-unwind.h (alpha_fallback_frame_state): Don't
	adjust sc_pc to compensate the unwinder's assumptions here.  Remove
	related head comments.

(Superseded by patch in gcc-43.dif)
	
2007-07-26  Olivier Hainque  <hainque@adacore.com>

	Backport http://gcc.gnu.org/ml/gcc-patches/2006-09/msg00460.html
	* mips-tfile.c (initialize_init_file): Correct endianness test.

(Already in GCC 4.3)

2007-07-18  Olivier Hainque  <hainque@adacore.com>

	Tweaks to accomodate the need for backtraces via system	library:
	* config/pa/pa.c (pa_output_function_prologue): Adjust the CALLINFO
	generation to help the support of backtraces using the hpux
	unwinding library.
	* config/pa/pa.h (FRAME_POINTER_REQUIRED): Force to 1 to ease
	backtrace computations using the hpux unwinding library, only
	device able to backtrace through non GCC code properly.

(Superseded by patch in gcc-43.dif)

2007-07-18  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris6.h (IRIX_SUBTARGET_LINK_SPEC, native linker):
	Hide __gcc_init, __gcc_fini and __dso_handle in shared libraries.

(Installed in GCC 4.3 and 4.4 on 2008-07-30, revisions 138299 and 138297
 discussions at http://gcc.gnu.org/ml/gcc-patches/2008-06/msg00239.html,
 and http://gcc.gnu.org/ml/gcc-patches/2008-07/msg02019.html)

2007-07-12  Olivier Hainque  <hainque@adacore.com>

	* config/pa/pa.c (output_call): Don't attempt the return address
	adjustment optimization if we're generating call frame information.

(Superseded by patch in gcc-43.dif)

2007-07-12  Olivier Hainque  <hainque@adacore.com>

	* doc/tm.texi (GO_IF_MAY_NARROW_ACCESS_TO): New macro.  Go to
	LABEL if ADDR, a legitimate address expression for MODE, may
	be accessed using a narrower mode for the purpose of an "offsettable"
	reference.
	* recog.c (GO_IF_MAY_NARROW_ACCESS_TO): Default definition.  Win if
	ADDR is mode independent.
	(may_narrow_access_to): New predicate. Wrapper around the new GO_IF
	macro for an address and a mode.
	(offsettable_address_p): Use it instead of mode_dependent_address_p.
	* config/rs6000/rs6000.h (GO_IF_MAY_NARROW_ACCESS_TO): Map to ...
	* config/rs6000/rs6000.c (rs6000_may_narrow_access_to): New function.
	Negation of the current rs6000_mode_dependent_address without the
	CONST_INT offsets tweaks.
	(rs6000_mode_dependent_address): Always return true for PLUS CONST_INT
	and adjust head comment accordingly.
	* config/rs6000/rs6000-protos.h (rs6000_may_narrow_access_to): Declare.

(Superseded by patch in gcc-43.dif)

2007-07-07  Nicolas Setton  <setton@adacore.com>

	* dbxout.c (dbxout_reg_parms): Output informations for parameters
	that live in memory, when DECL_RTL indicates a pseudo-register.

(Superseded by patch in gcc-43.dif)

2007-07-07  Eric Botcazou  <ebotcazou@adacore.com>

	* dbxout.c (dbxout_expand_expr): Add TYPE parameter and adjust.
	<INDIRECT_REF>: New case.
	(dbxout_symbol): Adjust for above change.

(Superseded by patch in gcc-43.dif)

2007-07-02  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/ia64.c (output_probe_stack_range): Probe only the first
	address of the next page for RBS (otherwise Linux raises a SEGV).
	Use st8 instead of st8.rel for probing.

(Superseded by patch in gcc-43.dif)

2007-06-20  Nicolas Setton  <setton@adacore.com>

	Backport from GCC 4.3 revision 123909
	* c-opts.c (c_common_handle_option): Add
	OPT_femit_struct_debug_baseonly, OPT_femit_struct_debug_reduced,
	and OPT_femit_struct_debug_detailed_.
	* c.opt: Add specifications for
	-femit-struct-debug-baseonly, -femit-struct-debug-reduced,
	and -femit-struct-debug-detailed[=...].
	* doc/invoke.texi (Debugging Options): Add documentation for the
	-femit-struct-debug-baseonly, -femit-struct-debug-reduced and
	-femit-struct-debug-detailed[=...] options.
	* opts.c (debug_struct_file): New enumeration.
	(debug_struct_ordinary): New global array.
	(debug_struct_generic): Likewise.
	(set_struct_debug_option): New function.
	(base_of_path): Likewise.
	(matches_main_base): Likewise.
	(main_input_basename, main_input_baselength): New variable.
	(dump_struct_debug): New function.
	(DUMP_GSTRUCT): New macro.
	(should_emit_struct_debug): Likewise.
	* langhooks-def.h (LANG_HOOKS_GENERIC_TYPE_P): Define.
	(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add it.
	* langhooks.h (struct lang_hooks_for_types): Add generic_p.
	* flags.h (debug_info_usage): New enumeration.
	(should_emit_struct_debug): Declare.
	(set_struct_debug_option): Likewise.
	* dwarf2out.c (gen_struct_or_union_type_die): Add a new parameter
	to indicate the program's usage of the type.  Filter structs based
	on the -femit-struct-debug-... specification.
	(gen_type_die): Split into two routines, gen_type_die and
	gen_type_die_with_usage.  gen_type_die is now a wrapper
	that assumes direct usage.
	(gen_type_die_with_usage): Replace calls to gen_type_die
	with gen_type_die_with_usage adding the program usage of
	the referenced type.
	(dwarf2out_imported_module_or_decl): Suppress struct debug
	information using should_emit_struct_debug when appropriate.

(Already in GCC 4.3)

2007-06-14  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (maybe_lookup_element_for_expr) <COMPONENT_REF>: Return
	NULL for variable-sized records too.
	(sra_walk_expr) <COMPONENT_REF>: Stop at variable-sized records too.

(Installed in GCC 4.3 on 2007-09-17 - revision 128553)

2007-06-12  Tristan Gingold  <gingold@adacore.com>

	* gcov.c: Comments updated.
	(source_info): Add file_time field.
	(source_index): New variable.
	(mutiple_files): New variable.
	(generate_results): New function extracted from process_file.
	(process_file): Save and restore chain of functions, generate
	results and free structures only if not merging results.
	(release_structures): File names are now freed in create_file_names
	(create_file_names): Free previous file names.
	(find_source): File date is now read here and modifications in
	source files is checked here.
	(read_graph_file): Only reverse order of functions for the current
	object file.
	(make_gcov_file_name): Do not generate long names if input_name is
	NULL.
	(output_lines): If merging results do not display graph, data and 
	runs informations.
	Checking source file modification is done in find_source.

	* doc/gcov.texi: Append an s to sourcefile.

(Installed in GCC 4.3 on 2007-06-12 - revision 125649)

2007-06-10  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/aix52.h (MALLOC_ALIGNMENT): Define.

(Irrelevant for GCC 4.3)

2007-06-08  Olivier Hainque  <hainque@adacore.com>

	* config/i386/sol2.h (MALLOC_ALIGNMENT): Define.
	* config/i386/vxworks.h (MALLOC_ALIGNMENT): Define.
	* config/mips/iris.h (MALLOC_ALIGNMENT): Define.

(Irrelevant for GCC 4.3)

2007-06-06  Olivier Hainque  <hainque@adacore.com>

	* config/i386/sol2-unwind.h (sol2_fallback_frame_state):
	Enhance the context recognizer to handle solaris 2.8 patterns.

(Superseded by patch in gcc-43.dif)

2007-06-06  Olivier Hainque  <hainque@adacore.com>

	* genmodes.c (tagged_printf, emit_insn_modes_h): Use printf
	return value instead of %n to retrieve the width of a piece
	we output. 

(Already in GCC 4.3)

2007-06-06  Eric Botcazou  <ebotcazou@adacore.com>

	* config/rs6000/rs6000.c (rs6000_output_function_entry): Use
	RS6000_OUTPUT_BASENAME unconditionally.
	(rs6000_output_function_epilogue): Likewise.

(Superseded by patch in gcc-43.dif)

2007-06-05  Olivier Hainque  <hainque@adacore.com>

	* config/i386/sol2-unwind.h: New file.  Implements the
	MD_FALLBACK_FRAME_STATE_FOR service.
	* config/i386/sol2.h (MD_UNWIND_SUPPORT): Define.

(Superseded by patch in gcc-43.dif)

2007-06-05  Olivier Hainque  <hainque@adacore.com>

	* doc/tm.texi (MALLOC_ALIGNMENT): New macro.
	* defaults.h (MALLOC_ALIGNMENT): Default to BIGGEST_ALIGNMENT.
	* config/i386/linux.h (MALLOC_ALIGNMENT): Define.
	* config/i386/cygming.h (MALLOC_ALIGNMENT): Define.

(Irrelevant for GCC 4.3)

2007-06-04  Nicolas Roche  <roche@adacore.com>

	Backport from GCC 4.2 revision 111295
	* Makefile.def (ADAFLAGS, BOOT_ADAFLAGS): New flags_to_pass.
	* Makefile.tpl (BASE_FLAGS_TO_PASS): Support optional flags_to_pass.
	(EXTRA_GCC_FLAGS): Remove BOOT_CFLAGS and BOOT_ADAFLAGS.
	* Makefile.in: Regenerate.

(Already in GCC 4.2)

2007-05-30  Tristan Gingold  <gingold@adacore.com>

	* collect2.c (main): Handle -f option if OBJECT_FORMAT_COFF, argument
	is a filename containing additionnal input files added to the object
	vector.

(Submitted at http://gcc.gnu.org/ml/gcc-patches/2007-04/msg00636.html)

2007-05-24  Ramon Fernandez  <fernandez@adacore.com>

	* config.gcc (i[4567]86-wrs-vxworksae): Add missing header.

(To be submitted)

2007-05-23  Eric Botcazou  <ebotcazou@adacore.com>

	* common.opt (-fdead-non-call-exceptions): New option.
	* doc/invoke.texi (Code Generation Options): Document it.
	* cse.c (insn_live_p): Test it instead of flag_non_call_exceptions.
	* flow.c (insn_dead_p): Likewise but only if the CFG can be modified.
	(update_life_info): Pass PROP_ALLOW_CFG_CHANGES to callees and
	remove it from stabilized_prop_flags once done.
	* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.

(Superseded by patch in gcc-43.dif)

2007-05-20  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-pass.h (pass_forwprop_final): Declare.
	* tree-ssa-forwprop.c (forward_propagate_into_inner_array_ref): New.
	(tree_ssa_forward_propagate_vars): New function, mostly copied from
	the following.  Call forward_propagate_into_inner_array_ref on
	inner array references during the final pass.
	(tree_ssa_forward_propagate_single_use_vars): Call above function.
	(tree_ssa_forward_propagate_final_vars): New function.
	(pass_forwprop_final): New pass.
	* passes.c (init_optimization_passes): Replace third pass_forwprop
	by pass_forwprop_final.

(Superseded by patch in gcc-43.dif)

2007-05-10  Eric Botcazou  <ebotcazou@adacore.com>
            Olivier Hainque  <hainque@adacore.com>

	Support for output of static nested constructors within bitfields
	* output.h (initializer_constant_valid_for_bitfield_p): Declare.
	* varasm.c (initializer_constant_valid_for_bitfield_p): New predicate.
	(output_constructor): Add 4th parameter RECURSE and return total size.
	Be prepared for nested constructors initializing bit-fields.
	(output_constant): Adjust for above change.

(Superseded by patch in gcc-43.dif)

2007-05-10  Olivier Hainque  <hainque@adacore.com>

	* expr.c (target_align): New function.  Alignment the target of an
	assignment may be assume to have.
	(highest_pow2_factor_for_target): Use it instead of relying on
	immediate tree attributes of TARGET, which may not be honored if
	there are outer bitfields involved.

(Superseded by patch in gcc-43.dif)

2007-05-09  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (decide_block_copy): Decide if there are groups.

(Installed in GCC 4.3 on 2007-09-19 - revision 128602)

2007-04-18  Eric Botcazou  <ebotcazou@adacore.com>

	* doc/invoke.texi (Overall Options): Document IDL input language.
	* c.opt (lang-idl): New option.
	* c-opts.c (c_common_init_options): Enable C++ options for -lang-idl.
	(c_common_handle_option) <OPT_lang_idl>: New case.
	* gcc.c (default_compilers): Add IDL input language.

(Superseded by patch in gcc-43.dif)

2007-04-04  Eric Botcazou  <ebotcazou@adacore.com>

	Uniquization of constants at the Tree level
	* function.h (struct function): Add new deferred_constants field.
	(n_deferred_constants): New macro moved from varasm.c.
	* tree-inline.c (expand_call_inline): Update n_deferred_constants.
	* tree.h (tree_output_constant_def): Declare.
	* varasm.c (struct varasm_status): Remove deferred_constants field.
	(n_deferred_constants): Move to function.h.
	(struct constant_descriptor_tree): Add decl field.
	(build_constant_desc): Set it to zero.
	(tree_output_constant_def): New function.
	(init_varasm_status): Do not initialize deferred_constants field.

(Superseded by patch in gcc-43.dif)

2007-03-28  Eric Botcazou  <ebotcazou@adacore.com>

	* cfgexpand.c (tree_expand_cfg): Zap the EH throw statement table
	once finished.
	* tree-cfg.c (bsi_replace): Remove the original statement from the
	EH throw statement table.

(Superseded by patch in gcc-43.dif)

2007-03-27  Eric Botcazou  <ebotcazou@adacore.com>

	* common.opt (-fkeep-nested-functions): New option.
	* doc/invoke.texi (Optimize Options): Document it.
	* tree-nested.c (local_dump_file): New static variable.
	(local_dump_flags): Likewise.
	(finalize_nesting_tree_1): Dump the function directly.
	(unnest_nesting_tree_1): Write the name of the function
	in the dump file if it is discarded.
	(lower_nested_functions): Open and close the dump file.
	Discard unreachable functions unless -fkeep-nested-functions.

(Superseded by patch in gcc-43.dif)

2007-03-26  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-nomudflap.c (gate_mudflap): New static function.
	(pass_mudflap_1): Use it as gate function.
	(pass_mudflap_2): Likewise.

(Installed in GCC 4.3 on 2007-09-17 - revision 128548)

2007-03-18  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold_binary): Associate again expressions with more
	than one variable for sizetypes.

(Superseded by patch in gcc-43.dif)

2007-03-16  Olivier Hainque  <hainque@adacore.com>

	Enhancements to table based EH for Ada ZCX support:
	* collect2.c (scan_flags): New enum, with ORDINARY, SKIP_FRAME_TABLES
	and FRAME_TABLES_ONLY values to control the behavior of ...
	(scan_prog_file, proto): Add scan_flags argument.
	(main): Adjust sequence for AIX: prevent frame tables from being
	collected during the scan aimed at collecting the static constructors.
	Pre-link and scan for frame tables only later to compensate.
	(scan_prog_file, !coff): Accept scan_flags, without effect.
	(scan_libraries): Pass proper scan_flags in calls to scan_prog_file.
	(scan_prog_file, coff): Accept scan_flags and honor it.
	* dwarf2out.c (output_call_frame_info): Add support for new macro,
	DWARF2_EMIT_FRAME_TABLE_ASM_REF, to emit an asm statememt forcing a
	reference to the frame table label from the current function text
	section.
	* config/rs6000/aix.h (DWARF2_EMIT_FRAME_TABLE_ASM_REF): Define to ...
	* config/rs6000/rs6000-protos.h (rs6000_aix_emit_frame_table_asm_ref):
	New function - add prototype.
	* config/rs6000/rs6000.h (EPILOGUE_USES): True for TOC_REGISTER when
	TARGET_MINIMAL_TOC and current_function_calls_eh.
	* config/rs6000/rs6000.c (rs6000_should_save_restore_gpr): New local
	predicate.  Whether gpr regno should be saved/restored by the current
	function.  Current predicate in prologue/epilogue expanders adjusted
	to include the TOC register when current_function_calls_eh_return.
	(rs6000_emit_prologue, rs6000_emit_epilogue): Use it.
	(rs6000_aix_emit_frame_table_asm_ref): Implement.
	* config/rs6000/aix52.h (MD_UNWIND_SUPPORT): Define.
	* config/rs6000/aix-unwind.h: New file.

(Superseded by patch in gcc-43.dif)

2007-03-15  Olivier Hainque  <hainque@adacore.com>

	* expr.c (convert_move): Latch a volatile mem integer input into a
	register before expanding it with a multi-instruction sequence.

(Superseded by patch in gcc-43.dif)

2007-03-12  Jose Ruiz  <ruiz@adacore.com>

	* config.gcc (erc32-elf): Use TARGET_CPU_sparc instead of
	TARGET_CPU_cypress.  It was imported from GCC 3.4 and it
	has changed in GCC 4.1.

(Superseded by patch in gcc-43.dif)

2007-03-06  Nicolas Setton  <setton@adacore.com>

	GNAT extensions to DWARF-2 format.
	* common.opt: Add -gdwarf+.
	* opts.c (flag_gnat_dwarf_extensions): New global variable.
	(common_handle_option): Accept -gdwarf+.
	* flags.h (flag_gnat_dwarf_extensions): Declare.
	* doc/invoke.texi: Document -gdwarf+.
	* dwarf2.h (dwarf_attribute): Add DW_AT_GNAT_encoding and
	DW_AT_GNAT_descriptive_type.
	* dwarf2out.h (dwarf2out_set_gnat_descriptive_type_func): Declare.
	(dwarf2out_set_gnat_encoding_func): Likewise.
	* dwarf2out.c (dwarf2out_set_gnat_descriptive_type_func):
	dwarf2out_set_gnat_encoding_func): New global functions.
	(add_artificial_attribute_for_type): New function.
	(add_descriptive_attribute_for_type): Likewise.
	(dwarf_attr_name): Add cases for DW_AT_GNAT_encoding and
	DW_AT_GNAT_descriptive_type.
	(base_type_die): Add call to add_name_attribute.
	(add_name_attribute): Output GNAT encoding if present.
	(subrange_type_die): Add calls to add_artificial_attribute_for_type
	and add_descriptive_attribute_for_type.
	(gen_array_type_die): Likewise.
	(gen_enumeration_type_die): Likewise.
	(gen_struct_or_union_type_die): Likewise.
	(gen_compile_unit_die): Add "-gdwarf+" to the DW_AT_producer string
	string when compiling with GNAT extensions and "-gdwarf+-" otherwise.

(Superseded by patch in gcc-43.dif)

2007-03-03  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (dwarf2out_frame_init): Initialize the Return Address
	if DWARF2_FRAME_INFO is non-zero.

(Installed in GCC 4.3 on 2007-10-06 - revision 129066)

2007-02-23  Olivier Hainque  <hainque@adacore.com>

	Backport fix for PR profile/26399
	* coverage.c (coverage_checksum_string): Reorganize loop to not read
	after buffer.

(Already in GCC 4.2 - revision 112738)

2007-02-20  Olivier Hainque  <hainque@adacore.com>

	Backport http://gcc.gnu.org/ml/gcc-patches/2006-01/msg00838.html
	* tree-vrp.c (extract_range_from_binary_expr): Cope with
	vrp_int_const_binop returning non-constant nodes.

(Already in GCC 4.2)

2007-02-18  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-cfg.c (dump_function_to_file): Be prepared for functions
	without DECL_STRUCT_FUNCTION initialized.

(Installed in GCC 4.3 on 2007-02-19 - revision 122135)

2007-02-18  Pascal Obry  <obry@adacore.com>

	* config/i386/t-mingw32 (SHLIB_LINK): Build GCC shared libraries
	with multi-threading support on Windows. This is needed to have
	proper exception propagation in multi-tasking programs using
	the ZCX support.

(Superseded by patch in gcc-43.dif)

2007-02-14  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/vxworks.h (CC1_SPEC): Default to -mlongcall.

(Superseded by patch in gcc-43.dif)

2007-02-08  Eric Botcazou  <ebotcazou@adacore.com>

	* calls.c (mem_overlaps_already_clobbered_arg_p): Return true
	for arg pointer based indexed addressing.

(Installed in GCC 4.2 on 2007-02-18 - revision 122096)

2007-02-03  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-eh.c (tree_could_trap_p): Handle VIEW_CONVERT_EXPR.

(Installed in GCC 4.2 on 2007-02-18 - revision 122098)

2007-01-26  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_modify_expr): For optimized compilation and
	during gimplification, attach a DECL on the rhs to a DECL on the lhs
	for debug info purposes if the former is ignored and not the latter.

(Installed in GCC 4.3 on 2007-02-15 - revision 122015)

2007-01-16  Jose Ruiz  <ruiz@adacore.com>

	* config/rs6000/vxworks.h (STACK_CHECK_STATIC_BUILTIN, CC1_SPEC,
	VXWORKS_STACK_CHECK_SPEC): Set static stack checking in RTP mode
	and fall back to the old stack checking mechanism for kernel mode
	and VxWorks 5.
	(STACK_CHECK_PROTECT): 8K is reserved in the stack to propagate
	exceptions reliably in case of stack overflow.
	* config/i386/vxworks.h: Likewise.
	* config/rs6000/vxworksae.h (STACK_CHECK_STATIC_BUILTIN):
	Undefine since it is set in vxworks.h.
	(VXWORKS_STACK_CHECK_SPEC): Undefine because static stack checking
	is supported unconditionally on this target.
	(STACK_CHECK_PROTECT): Redefine to 4K which is enough in this target
	for executing a possible last chance handler.
	* config/i386/vxworksae.h: Likewise.

(Superseded by patch in gcc-43.dif)

2007-01-12  Nicolas Roche  <roche@adacore.com>

	* configure.in: Disable libiberty, libffi,... on powerpc-eabispe.
	* configure: Regenerate.

(Superseded by patch in gcc-43.dif)

2007-01-11  Eric Botcazou  <ebotcazou@adacore.com>

	* dwarf2out.c (round_up_to_align): New static function.
	(field_byte_offset): Use it to round the offset.

(Installed in GCC 4.3 on 2007-02-12 - revision 121859)

2007-01-10  Olivier Hainque  <hainque@adacore.com>
	
	Stack realignment compatibility with mcount profiling calls on x86:
	* config/i386/i386.h (MCOUNT_PRESERVES_ALL_REGS): New target specific
	configuration macro.  Defaults to 1.
	(PROFILE_COUNT_REGISTER): Replaced register name string by ...
	(PROFILE_COUNT_REGNUM): GCC regno for the mcount register argument
	expected to hold the address of the function specific counter unless
	NO_PROFILE_COUNTERS is defined.
	* config/i386/i386.c (x86_function_profiler): Split into ...
	(x86_64_function_profiler): 64bit ABI implementation, and ...
	(x86_32_function_profiler): 32bit ABI implementation, enhanced to
	save/restore the internal arg pointer used to support local stack
	realignment, if any, when either !MCOUNT_PRESERVES_ALL_REGS or
	PROFILE_COUNT_REGNUM is the same and needed as an mcount argument.
	(X86_SET_PROFILE_COUNTERS): New local macro, always defined.  Conveys
	whether NO_PROFILE_COUNTERS is defined or not.
	* config/i386/sol2.h (MCOUNT_PRESERVES_ALL_REGS): Override to 0.
	* config/i386/freebsd.h (MCOUNT_PRESERVES_ALL_REGS): Likewise.

(Superseded by patch in gcc-43.dif)

2007-01-04  Romain Berrendonner  <berrendo@adacore.com>

	* gcc.c (process_command): Update warranty notice for AdaCore use.

(Superseded by patch in gcc-43.dif)

2006-12-22  Olivier Hainque  <hainque@adacore.com>

	* doc/tm.texi (DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET): New
	macro. Document, then ...
	* defaults.h: Default to 0, and ...
	* dwarf2out.c (add_location_or_const_value_attribute): Comment on the
	expected result of lookup_decl_loc when LOCATION_LISTS_SUPPORT_MISSING.
	(gen_subprogram_die): If LOCATION_LISTS_SUPPORT_MISSING, don't define
	frame_base as the CFA.  Fallback to the	previous stack/frame pointer
	use instead.
	* toplev.c (process_options): If generating DWARF2 debug info and
	LOCATION_LISTS_SUPPORT_MISSING, disable var_tracking.

(Superseded by patch in gcc-43.dif)

2006-12-19  Romain Berrendonner  <berrendo@adacore.com>

	* version.c (bug_report_url): Point to report@adacore.com.
	* gcc.c: Adapt message to new bug_report_url.
	* gcov.c: Ditto.

(Superseded by --with-bugurl + patch in gcc-43.dif)

2006-12-18  Thomas Quinot  <quinot@adacore.com>

	* config/i386/freebsd.h (TARGET_96_ROUND_53_LONG_DOUBLE): Define to 0.
	(MD_UNWIND_SUPPORT): Define.
	* config/i386/freebsd-unwind.h: New file.

(Superseded by patch in gcc-43.dif)

2006-12-13  Eric Botcazou  <ebotcazou@adacore.com>

	* doc/invoke.texi (Debugging options): Document -fcallgraph-info=da.
	* opts.c (common_handle_option) <OPT_fcallgraph_info_>: Accept 'da'.
	* flags.h (CALLGRAPH_INFO_DYNAMIC_ALLOC): New constant.
	* cgraph.h (cgraph_final_info): Add 'dynamic_allocs' field.
	(struct cgraph_dynamic_alloc): New structure.
	(cgraph_final_record_dynamic_alloc): Declare.
	* cgraph.c (cgraph_final_record_dynamic_alloc): New global function.
	(dump_cgraph_final_node_vcg): Print list of dynamically-allocated
	objects if -fcallgraph-info=da is specified.
	* gimplify.c (gimplify_decl_expr): Record dynamically-allocated object
	by calling cgraph_final_record_dynamic_alloc if -fcallgraph-info=da is
	specified.

(Superseded by patch in gcc-43.dif)

2006-12-10  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-sra.c (sra_walk_fns) <ldst>: Document new restriction.
	(sra_walk_modify_expr) <rhs_elt>: Treat the reference as a use
	if the lhs has side-effects.
	<lhs_elt>: Treat the reference as a use if the rhs has side-effects.

(Installed in GCC 4.2 on 2007-03-02 - revision 122493)

2006-12-09  Olivier Hainque  <hainque@adacore.com>

	Enhance back-end support for stack realignment on request.
	* config/i386/i386.c (ix86_stack_realignment_for): New helper.
	States what kind of need a function has with respect to stack
	realignment.
	(needs_static_chain_p): Simple helper.
	(ix86_function_regparm): Punt on trying to use an internal regparm
	convention if there is a need for stack realignment.  Don't look at
	DECL_STRUCT_FUNCTION components for this purpose.  Use the new helpers.
	(ix86_eax_maybe_live_in_or_out): New helper.		
	(ix86_edx_maybe_live_in_or_out): Likewise.
	(ix86_ecx_maybe_live_in_or_out): Likewise.
	(ix86_stack_realign_arg_pointer_regno_for): Likewise.
	(ix86_internal_arg_pointer): Don't hardcode ecx as the internal arg
	pointer for stack realignment purposes, hence don't reject nested
	functions upfront any more.
	(ix86_expand_prologue): At the point we're setting up the stack
	worker, eax is live if it has been used as the arg pointer for stack
	realignment purposes.

(Superceded by patch in gcc-43.dif)

2006-12-08  Olivier Hainque  <hainque@adacore.com>

	Backport http://gcc.gnu.org/ml/gcc-patches/2006-05/msg00526.html
	* config/i386/i386.opt (-mstackrealign): New flag.
	* config/i386/i386.c (force_align_arg_pointer): New attribute.
	(ix86_handle_cconv_attribute): Emit error when force_align_arg_pointer
	attribute collides with too many regparms.
	(ix86_function_regparm): Limit regparms when force_align_arg_pointer
	attribute.
	(ix86_internal_arg_pointer): Support stack-realigning prologue in
	non-main functions.  Warn for nested functions on -mstackrealign,
	emit error for nested functions with force_align_arg_pointer attribute.

(Already in GCC 4.2)

2006-12-08  Olivier Hainque  <hainque@adacore.com>

	* Makefile.in (stmp-multilib): Explicitly pass INCLUDES down
	to libgcc.mk to ensure correct expansion of $(@D), as is already
	done for libgcc.a.

(Irrelevant for GCC 4.3 [windows-cross])

2006-12-07  Olivier Hainque  <hainque@adacore.com>

	* tree-nested.c (convert_local_reference): Handle VIEW_CONVERT_EXPR,
	request walking the subtrees only, leaving the current is_lhs/val_only
	indications alone.
	(convert_non_local_reference): Likewise.

(Installed in GCC 4.3 on 2007-06-12 - revision 125646)

2006-12-06  Jose Ruiz  <ruiz@adacore.com>

	* config/sparc/erc32.h (STACK_CHECK_PROTECT): Define to 300
	(75 words) that is enough for either propagating the exception
	(sjlj) or executing a possible last chance handler.
	* config/sparc/leon.h: Likewise.

(Superseded by patch in gcc-43.dif)

2006-12-04  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/rs6000.c (INTERRUPTS_ON_CURRENT_STACK): Document
	and define default value.
	(rs6000_emit_stack_tie): Accept an ALIAS_SET argument to assign to
	the stack_tie reference.
	(rs6000_emit_prologue, rs6000_emit_prologue): Emit stack tie with
	alias set 0 if INTERRUPTS_ON_CURRENT_STACK.
	* config/rs6000/vxworks.h (INTERRUPTS_ON_CURRENT_STACK): Define to 1.

(Superseded by patch in gcc-43.dif)

2006-12-04  Jose Ruiz  <ruiz@adacore.com>

	* config/sparc/erc32.h: crt0.o is the only start file needed
	for the ERC32 target. Neither table based unwinding nor C++
	constructors/destructors are used, so that there is no need
	for the crtbegin/crtend and crti/crtn machinery.
	* config/sparc/leon.h: Likewise.

(Superseded by patch in gcc-43.dif)

2006-12-03  Olivier Hainque  <hainque@adacore.com>

	Support for table driven eh on ppc-vxworks5:
	* config.gcc <powerpc-*-vxworks*> (extra_parts): Define to include
	the crtstuff objects we will be relying on.
	* config/rs6000/vxworks.h (STARTFILE_SPEC, ENDFILE_SPEC,
	HAS_INIT_SECTION, USE_EH_FRAME_REGISTRY, INIT_SECTION_ASM_OP,
	INIT_SECTION_FUNCTION, FINI_SECTION_ASM_OP, FINI_SECTION_FUNCTION):
	Adjust definitions to use tailored crtstuff objects when -static
	or -dynamic is on the command line.  Use crtbeginT.o+crtend.o in the
	former case.  Use crtbegin.o+crtend.o in the latter case.
	(DWARF2_UNWIND_INFO): Redefine to 1.
	* crtstuff.c: Undef JCR_SECTION_NAME for VxWorks.
	<CRTBEGIN> (_ctors, _dtors): Define unless for -static, to
	have the VxWorks modules handler automatically call do_global_c/dtors
	at load/unload time.
	(__module_has_ctors): Always define (for -static and other cases), to
	indicate whether _c/dtors are there or not.

(Superseded by patch in gcc-43.dif)

2006-12-01  Pascal Obry  <obry@adacore.com>

	* gcov.c: Fix path handling on DOS based file systems.

(Superseded by patch in gcc-43.dif)

2006-11-30  Nicolas Roche  <roche@adacore.com>

	* fixincludes/fixinc.in: Use explicit path when calling config.guess.

(Superseded by patch in gcc-43.dif)

2006-11-29  Olivier Hainque  <hainque@adacore.com>

	* expr.c (expand_expr_real_1) <normal_inner_ref>: Force op0 to
	memory if the component is to be referenced in BLKmode according
	to get_inner_reference.

(Superseded by patch in gcc-43.dif)

2006-11-28  Nicolas Roche  <roche@adacore.com>

	* makefile.in: Avoid recompilation of libgcc when
        invoking gcc-no-fixedincludes target

(Superseded by patch in gcc-43.dif)

2006-11-28  Olivier Hainque  <hainque@adacore.com>

	* config/vx-common.h (TARGET_EXECUTABLE_SUFFIX): Define.

(Superseded by patch in gcc-43.dif)

2006-11-22  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_init_ctor_preeval_1): Detect potential overlap
	due to calls to functions taking pointers as parameters.

(Installed in GCC 4.2 on 2007-02-19 - revision 122134)

2006-11-22  Olivier Hainque  <hainque@adacore.com>

	Part of support for pragma Persistent_BSS
	* varasm.c (default_section_type_flags_1): Flag .persistent.bss
	sections as SECTION_BSS too.

(Superseded by patch in gcc-43.dif)

2006-11-07  Geert Bosch  <bosch@adacore.com>

	* config/ia64/hpux.h (WIDEST_HARDWARE_FP_SIZE): Define to 64, the
	widest type supported by both the OS and the hardware.

(Superseded by patch in gcc-43.dif)

2006-11-07  Bernard Banner  <banner@adacore.com>

	* config/ia64/hpux.h (CC1_SPEC): Define to use LP64 mode by default.
	(ASM_SPEC): Likewise.
	(ASM_EXTRA_SPEC): Tweak to use LP64 mode by default.
	(STARTFILE_SPEC): Likewise

(Superseded by patch in gcc-43.dif)

2006-11-06  Nicolas Roche  <roche@adacore.com>

	* mklibgcc.in (os_multilib_dir): Filter out CR chars from the output
	of --print-multi-os-directory.

(Obsolete for GCC 4.3 - workaround for cygwin quirk)

2006-11-03  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.2
	* builtins.c (expand_builtin_return_addr): Only use
	frame_pointer_rtx when count == 0 and we are expanding
	__builtin_return_address.  Deal with FRAME_ADDR_RTX.
	* doc/tm.texi (Basic Stack Layout): Document FRAME_ADDR_RTX.
	* config/sparc/sparc.h (FRAME_ADDR_RTX): Define.

(Already in GCC 4.2)

2006-11-02  Olivier Hainque  <hainque@adacore.com>

	Have -mstrict-align on by default for powerpc-*-(elf|eabi)*:
	* config/rs6000/rs6000.h (SUBTARGET_DEFAULT): New macro.  Extra
	default	flags to be set on a per subtarget basis.
	* config/rs6000/rs6000.c (TARGET_DEFAULT_TARGET_FLAGS): Honor it.
	* config/rs6000/strict-align.h: New file.  Define SUBTARGET_DEFAULT
	to MASK_STRICT_ALIGN.
	* config.gcc <powerpc-*-(elf|eabi)*>: Add strict-align.h to the list
	of target configuration files.

(Superseded by patch in gcc-43.dif)

2006-10-29  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/i386.c (override_options): Disable MMX if the FPU
	is used for floating-point code, unless explicitly requested.
	(ix86_init_builtins): Initialize SSE builtins if SSE is enabled.

(Obsolete for GCC 4.3)

2006-10-24  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold_binary) <EQ_EXPR>: Use the precision of the
	type instead of the size of its mode to compute the highest and
	lowest possible values.  Still check the size of the mode before
	flipping the signedness of the comparison.

(Installed in GCC 4.3 on 2006-12-01 - revision 119422)

2006-10-18  Eric Botcazou  <ebotcazou@adacore.com>

	Factorization of self-referential size trees into functions
	* cgraphunit.c (cgraph_finalize_compilation_unit): Call
	finalize_size_functions before further processing.
	* stor-layout.c: Include cgraph.h, tree-inline.h and tree-dump.h.
	(variable_size): Call self_referential_size on size expressions
	that contain a PLACEHOLDER_EXPR.
	(size_functions): New static variable.
	(copy_self_referential_tree_r): New static function.
	(self_referential_size): Likewise.
	(finalize_size_functions): New global function.
	* tree.c: Include tree-inline.h.
	(push_without_duplicate): New static function.
	(find_substitute_in_expr): New global function.
	(substitute_in_expr) <COMPONENT_REF>: Minor tweaks.
	<tcc_declaration>: Return the replacement object on equality.
	<tcc_expression>: Likewise.
	<CALL_EXPR>: If the replacement object is a constant, try to inline
	the call in the expression.
	Propagate the TREE_READONLY flag without overwriting.
	(substitute_placeholder_in_expr): Likewise.
	(PROCESS_ARG): Do not clear TREE_READONLY if CONSTANT_CLASS_P.
	(build3_stat): Propagate TREE_READONLY for CALL_EXPR and COND_EXPR.
	* tree.h (finalize_size_functions): Declare.
	(find_substitute_in_expr): Likewise.
	(FIND_SUBSTITUTE_IN_EXPR): New macro.
	(substitute_placeholder_in_expr): Update comment.
	* tree-inline.c (struct inline_data): Add do_not_unshare field.
	(remap_decl): Do not unshare trees if do_not_unshare is true.
	(copy_body_r): Likewise.
	(maybe_inline_call_in_expr): New global function.
	* tree-inline.h (maybe_inline_call_in_expr): Declare.

(Superseded by patch in gcc-43.dif)

2006-10-18  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/t-vxworks (TARGET_LIBGCC2_CFLAGS): Add -mlongcall.
	* confif/rs6000/tramp.asm (__trampoline_setup): Use a longcall
	sequence for the call to "abort" in the simple !pic case.

(Superseded by patch in gcc-43.dif)

2006-10-14  Olivier Hainque  <hainque@adacore.com>

	Backport Makefile related changes from FSF revisions 108793 and
	108856 - restoring proper support of BOOT_CFLAGS and BOOT_LDFLAGS.
	* Makefile.def (flags_to_pass): Add BOOT_CFLAGS, BOOT_LDFLAGS.
	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Handle them.
	(stage[+id+]-bubble): Pass flags recursively to the comparison target.
	(stage): Fail if we cannot complete the work.
	* Makefile.in: Regenerate.

(Already in GCC 4.2)

2006-10-10  Olivier Hainque  <hainque@adacore.com>

	* c-decl.c (grokdeclarator) [cdk_pointer]: If we are in a NORMAL or
	DECL context, attach an artificial TYPE_DECL to anonymous pointed-to
	types with components of variable size.

(Installed in GCC 4.2 on 2006-10-06 - revision 117493)

2006-10-09  Eric Botcazou  <ebotcazou@adacore.com>

	* expr.c (expand_expr_real_1) <normal_inner_ref>: If a temporary
	is made and the reference doesn't use the alias set of its type,
	do not create the temporary using that type.

(Installed in GCC 4.3 on 2007-02-15 - revision 122014)

2006-10-08  Olivier Hainque  <hainque@adacore.com>

	* config/vxlib.c: Extract tls related routines into ...
	* config/vxlib-tls.c: ...new file.
	* config/t-vxworks: Add vxlib-tls.c to LIB2FUNCS_EXTRA.

(Installed in GCC 4.3 on 2006-12-12 - revision 119771)

2006-10-07  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/t-vxworks: Remove assignment to LIB2FUNCS_EXTRA.

(Installed in GCC 4.3 on 2006-12-12 - revision 119773)

2006-10-07  Olivier Hainque  <hainque@adacore.com>

	Backport from GCC 4.2
	* config/rs6000/t-pppcomm (LIB2FUNCS_EXTRA): Use '+=' instead of '='.

(Already in GCC 4.2)

2006-10-06  Nicolas Roche  <roche@adacore.com>

	* mklibgcc: Ensure that libgcc.mk will use the shell selected at
	configure time using CONFIG_SHELL variable.

(Obsolete for GCC 4.3)

2006-10-04  Eric Botcazou  <ebotcazou@adacore.com>

	* except.c (finish_eh_generation): Call commit_edge_insertions if
	there are insns queued on the entry edge.
	* config/alpha/alpha.c (alpha_gp_save_rtx): Insert the insns on
	the entry edge.

(Installed in GCC 4.3 on 2007-09-22 - revision 128665)

2006-10-03  Olivier Hainque  <hainque@adacore.com>

	* config/rs6000/xcoff.h (read_only_data_section): Honor the
	current definition of BIGGEST_ALIGNMENT.
	(private_data_section): Likewise.
	(read_only_private_data_section): Likewise.
	(toc_section): Likewise.
	(DATA_SECTION_ASM_OP): Likewise.

(Installed in GCC 4.3 on 2007-08-31)

2006-10-03  Olivier Hainque  <hainque@adacore.com>

	Backport http://gcc.gnu.org/ml/gcc-patches/2006-01/msg01499.html
	* config/rs6000/aix.h (STACK_BOUNDARY): Define.

(Already in GCC 4.2)

2006-10-02  Nicolas Setton  <setton@adacore.com>

	* dwarf2out.c (add_type_attribute): Do not use the inner type when the
	type is a subrange type of an integral type, since subrange type DIEs
	are now properly generated in this case.

(Superseded by patch in gcc-43.dif)

2006-10-01  Olivier Hainque  <hainque@adacore.com>

	* config/i386/win32-unwind.h: Expand comments on register mappings.

(Irrelevant for GCC 4.3)

2006-10-01  Olivier Hainque  <hainque@adacore.com>

	Backport http://gcc.gnu.org/ml/gcc-patches/2006-03/msg00400.html
	* dwarf2out.c (DWARF2_FRAME_REG_OUT): Move up in file.
	(expand_builtin_dwarf_sp_column): Call DWARF2_FRAME_REG_OUT.
	(expand_builtin_init_dwarf_reg_sizes): Likewise.

(Already in GCC 4.2)

2006-09-28  Nicolas Roche  <roche@adacore.com>

	* fixincludes/mkfixinc.sh: Disable fixincludes on VxWorks targets.

(Installed in GCC 4.3 on 2006-12-12 - revision 119769)

2006-09-27  Olivier Hainque  <hainque@adacore.com>

	* config/i386/cygming.h (DWARF_FRAME_REGNUM): Use svr4 mapping
	instead of the base dbx mapping consistently.
	(DWARF2_FRAME_REG_OUT): Define, map .eh_frame regs back to the
	dbx mapping for binary compatibility.

(Irrelevant for GCC 4.3)

2006-09-27  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_init_ctor_preeval): Call maybe_with_size_expr
	on the element before gimplifying it, instead of punting if it is of
	variable size.

(Installed in GCC 4.2 on 2006-09-28 - revision 117288)

2006-09-22  Olivier Hainque  <hainque@adacore.com>

	* config/i386/cygming.h (DWARF_FRAME_REGNUM): Define.
	* config/i386/win32-unwind.h: Adjust register mapping accordingly.

(Irrelevant for GCC 4.3)

2006-09-22  Olivier Hainque  <hainque@adacore.com>

	Backport FSF fix for PR target/28427
	* config/i386/cygming.h (MAX_OFILE_ALIGNMENT): Define.

(Already in GCC 4.2)

2006-09-20  Eric Botcazou  <ebotcazou@adacore.com>

	* builtins.c (expand_builtin_setjmp): Delete.
	(expand_builtin) <BUILT_IN_SETJMP>: Mark as unreachable.
	<BUILT_IN_SETJMP_SETUP>: New case.
	<BUILT_IN_SETJMP_DISPATCHER>: Likewise.
	<BUILT_IN_SETJMP_RECEIVER>: Likewise.
	* builtins.def (BUILT_IN_SETJMP_SETUP): New built-in stub.
	(BUILT_IN_SETJMP_DISPATCHER): Likewise.
	(BUILT_IN_SETJMP_RECEIVER): Likewise.
	* gimple-low.c (struct lower_data): New field calls_builtin_setjmp.
	(lower_function_body): Initialize it to false.  If it is set to true
	at the end of the processing, emit the setjmp dispatcher.
	(lower_stmt) <CALL_EXPR>: Invoke lower_builtin_setjmp if the callee
	is __builtin_setjmp and set calls_builtin_setjmp to true as well.
	<MODIFY_EXPR>: Fall through to above case if there is a CALL_EXPR
	on the rhs of the assignment.
	(lower_builtin_setjmp): New function.
	* tree.c (build_common_builtin_nodes): Build BUILT_IN_SETJMP_SETUP,
	BUILT_IN_SETJMP_DISPATCHER and BUILT_IN_SETJMP_RECEIVER nodes.
	* tree-cfg.c (make_exit_edges) <CALL_EXPR>: Use specific predicate
	to detect calls that can go to non-local labels.  Use specific
	helper to create the abnormal edges associated with them.
	<MODIFY_EXPR>: Merge with above case.
	(make_abnormal_goto_edges): New function extracted from...
	(make_goto_expr_edges): ...here.  Call it for computed gotos.
	(simple_goto_p): Minor tweak.
	(tree_can_make_abnormal_goto): New predicate.
	(tree_redirect_edge_and_branch): Return zero on all abnormal edges.
	(tree_purge_dead_abnormal_call_edges): New function.
	* tree-flow.h (tree_can_make_abnormal_goto): Declare.
	(tree_purge_dead_abnormal_call_edges): Likewise.
	(make_abnormal_goto_edges): Likewise.
	* tree-inline.c (expand_call_inline): Simplify statement frobbing.
	Purge all dead abnormal edges if the call was in the last statement.
	* tree-optimize.c (has_abnormal_outgoing_edge_p): New predicate.
	(execute_fixup_cfg): If there are non-local labels in the function,
	scan the basic blocks and split them at calls that can go to non-local
	labels or add missing abnormal call edges.  Write down the CFG in the
	dump file.
	(pass_fixup_cfg): Remove TODO_dump_func flag.

(Installed in GCC 4.2 on 2006-09-29 - revision 117298)

2006-09-14  Nicolas Roche  <roche@adacore.com>

	* config/rs6000/t-aix43 (LDFLAGS): Double quote $(CC) used as
	a case statement controlling expression.
	* config/rs6000/t-aix52 (LDFLAGS): Likewise.

(Superseded by patch in gcc-43.dif)

2006-09-11  Eric Botcazou  <ebotcazou@adacore.com>

	* param.def (PARAM_GLOBAL_VAR_THRESHOLD): Default to 100000.

(Irrelevant for GCC 4.3)

2006-09-11  Olivier Hainque  <hainque@adacore.com>

	* config/i386/win32-unwind.h (x86_fallback_frame_state): Adjust
	and clarify dwarf register columns used.

(Irrelevant for GCC 4.3)

2006-09-05  Eric Botcazou  <ebotcazou@adacore.com>
            Nicolas Roche  <roche@adacore.com>

	* configure.ac (section merging support): Additionally check
	that the linker can merge marked and non-marked sections.
	* configure: Regenerate.

(Obsolete for GCC 4.3)

2006-09-01  Olivier Hainque  <hainque@adacore.com>

	* config/i386/cygming.h (PREFERRED_DEBUGGING_TYPE): Default to
	DWARF2_DEBUG if available.

(Already in GCC 4.3)

2006-08-31  Olivier Hainque  <hainque@adacore.com>

	* gimplify.c (gimplify_type_sizes): Only gimplify the sizes of
	of pointer designated type if it is anonymous.

(Installed in GCC 4.2 on 2006-10-06 - revision 117493)

2006-08-09  Eric Botcazou  <ebotcazou@adacore.com>

	* config/rs6000/rs6000.c (print_operand) <D>: Fix comment and adjust.
	(rs6000_generate_compare): Tweak comments.
	* config/rs6000/rs6000.md (UNSPEC_MV_CR_GT): Fix comment.

(Installed in GCC 4.2 on 2006-08-09 - revision 116041)

2006-08-08  Eric Botcazou  <ebotcazou@adacore.com>

	* config/i386/winnt.c (i386_pe_encode_section_info): Change the
	DECL_ASSEMBLER_NAME manually.

(Obsolete for GCC 4.3 - PR target/27067)

2006-08-07  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.c (build1_stat): Also propagate the TREE_CONSTANT and
	TREE_INVARIANT flags for a VIEW_CONVERT_EXPR.

(Installed in GCC 4.2 on 2006-08-10 - revision 116071)

2006-07-31  Jose Ruiz  <ruiz@adacore.com>

	* configure: Add erc32-elf and leon-elf to the list of known
	targets.
	* config.sub: Add erc32 and leon to the list of known machines.
	* config.gcc: Add the erc32-elf and leon-elf configurations.
	* config/sparc/erc32.h: Add this file that contains the linker
	script, the bsp library, and the debugging format to be used.
	* config/sparc/leon.h: Add this file that contains the linker
	script, the bsp library, and the debugging format to be used.

(Superseded by patch in gcc-43.dif)

2006-07-24  Olivier Hainque  <hainque@adacore.com>

	* gimplify.c (gimplify_init_constructor): Ensure that constructor
	elements overlapping with the lhs are captured into temporaries
	before being zeroed out if block clearing was to happen.

(Installed in GCC 4.2 on 2006-08-21 - revision 116300)

2006-07-15  Eric Botcazou  <ebotcazou@adacore.com>

	* optabs.c (maybe_encapsulate_block): New function extracted from...
	(emit_libcall_block): ...here.  Invoke it on the block of insns to
	maybe emit REG_LIBCALL/REG_RETVAL notes around the block.
	(emit_no_conflict_block): Likewise.

(Installed in GCC 4.2 on 2006-07-16 - revision 115498)

2006-06-24  Olivier Hainque  <hainque@adacore.com>

	* tree-ssa-loop-im.c (for_each_index): Handle ARRAY_RANGE_REF as
	ARRAY_REF, so have the callback called for the low bound expression.

(Installed in GCC 4.2 on 2006-06-24 - revision 114963)

2006-06-19  Eric Botcazou  <ebotcazou@adacore.com>

	Backport from GCC 4.2
	* Makefile.in (gcc-vers.texi): Define srcdir.
	* doc/invoke.texi: For man pages, include gcc-vers.texi.
	List @file in the option summary.  Include the libiberty
	documentation for @file.
	* gcc.c (main): Change type of argv to "char **".  Call expandargv.

(Already in GCC 4.2)

2006-06-19  Olivier Hainque  <hainque@adacore.com>

	* function.c (aggregate_value_p): Honor DECL_BY_REFERENCE on
	a CALL_EXPR target function declaration.

(Installed in GCC 4.2 on 2006-06-26 - revision 115022)

2006-06-18  Pascal Obry  <obry@adacore.com>

	* config/i386/cygming.h (MD_UNWIND_SUPPORT): Define.
	* config/i386/win32-unwind.h: New file.

(Already in GCC 4.3)

2006-06-17  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.c (range_in_array_bounds_p): New predicate.
	* tree.h (range_in_array_bounds_p): Declare it.
	* tree-eh.c (tree_could_trap_p) <ARRAY_RANGE_REF>: Use it to
	return a less conservative answer.
	* tree-sra.c (struct sra_elt): Add new pointer field 'groups'
	and flag 'is_group'.
	(IS_ELEMENT_FOR_GROUP): New macro.
	(FOR_EACH_ACTUAL_CHILD): Likewise.
	(next_child_for_group): New helper function.
	(can_completely_scalarize_p): Take into account groups.
	(sra_hash_tree): Handle RANGE_EXPR.
	(sra_elt_eq): Likewise.
	(lookup_element): Be prepared for handling groups.
	(is_valid_const_index): Delete.
	(maybe_lookup_element_for_expr) <ARRAY_REF>: Use in_array_bounds_p
	instead of is_valid_const_index.
	<ARRAY_RANGE_REF>: New case.
	(sra_walk_expr) <ARRAY_REF>: Use in_array_bounds_p instead of
	is_valid_const_index.
	<ARRAY_RANGE_REF>: Do not unconditionally punt.
	(scan_dump): Dump info for groups too.
	(decide_instantiation_1): Likewise.
	(decide_block_copy): Assert that the element is not a group.
	Propagate decision to groups.
	(generate_one_element_ref): Handle RANGE_EXPR.
	(mark_no_warning): Iterate over actual childs.
	(generate_copy_inout): Likewise.
	(generate_element_copy): Likewise.
	(generate_element_zero): Likewise.
	(generate_element_init_1): Likewise.
	(dump_sra_elt_name): Handle RANGE_EXPR.

(Installed in GCC 4.2 on 2006-07-03 - revision 115160)

2006-06-15  Olivier Hainque  <hainque@adacore.com>

	* gcse.c (try_replace_reg): On single-set replacement failure,
	only attach a REG_EQUAL note to the insn if the destination is
	a register.

(Superseded by patch in gcc-43.dif)

2006-06-13  Eric Botcazou  <ebotcazou@adacore.com>

	* config/alpha/osf5.h (ASM_OUTPUT_ALIGNED_LOCAL): New macro
	(ASM_OUTPUT_ALIGNED_BSS): Likewise.

(Superseded by patch in gcc-43.dif)

2006-06-09  Eric Botcazou  <ebotcazou@adacore.com>

	* gimplify.c (gimplify_expr): Treat VIEW_CONVERT_EXPR like other
	lvalues in the fb_none case with side-effects.

(Installed in GCC 4.2 on 2006-06-12 - revision 114576)

2006-06-08  Jose Ruiz  <ruiz@adacore.com>
            Eric Botcazou  <ebotcazou@adacore.com>

	* config/sparc/sol2.h (MD_UNWIND_SUPPORT): Define.
	* config/sparc/sol2-unwind.h: New file.

(Superseded by patch in gcc-43.dif)

2006-05-24  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-structalias.h (PTR_IS_REF_ALL): New macro.
	(struct alias_info): Add new field ref_all_type_mem_tag.
	* tree-ssa-alias.c (compute_may_aliases): If the program contains
	ref-all pointers, run a finalization pass for them.
	(compute_flow_insensitive_aliasing): Skip ref-all pointers.
	(finalize_ref_all_pointers): New function.
	(is_escape_site): Return true for conversion from a regular pointer
	type to a ref-all pointer type.
	(get_tmt_for): Return the special memory tag for ref-all pointers.

(Installed in GCC 4.2 on 2006-05-25 - revision 114116)

2006-05-23  Olivier Hainque  <hainque@adacore.com>

	Support for bounded varsize temporaries.
	* tree.c (max_int_size_in_bytes): New function, inspired from
	code in function.c:assign_temp.
	* tree.h (max_int_size_in_bytes): Declare.
	* function.c (assign_temp): Use it.
	* gimplify.c (create_tmp_var): Relax the assertions on the type
	properties, not mandating constant size any more.
	(force_constant_size): New static function.
	(gimple_add_tmp_var): Use it, forcing variable size to a
	constant upper bound if it is not constant on entry.

(Installed in GCC 4.2 on 2006-06-23 - revision 114938)

2006-05-20  Eric Botcazou  <ebotcazou@adacore.com>

	* doc/invoke.texi (Optimize Options): Remove irrelevant note about
	-ftree-sra and the Ada compiler.

(Irrelevant for GCC 4.2)

2006-05-19  Nicolas Setton  <setton@adacore.com>

	* langhooks.h (struct lang_hooks): Add dwarf_name language hook.
	* langhooks.c (lhd_dwarf_name): New function.
	* langhooks-def.h (lhd_dwarf_name): Declare.
	(LANG_HOOKS_DWARF_NAME): New macro, defaults to lhd_dwarf_name.
	* dwarf2out.c (dwarf2_name): Use the dwarf_name language hook.

(Installed in GCC 4.2 on 2006-05-19 - revision 113905)

2006-05-18  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
            Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-loop-ivopts.c (may_be_nonaddressable_p): New function.
	(find_interesting_uses_address): Call it.  No longer need to
	explicitly check for bitfields here.

(Obsolete for GCC 4.3)

2006-05-18  Olivier Hainque  <hainque@adacore.com>

	* gimplify.c (gimplify_scalar_mode_aggregate_compare): New function.
	(gimplify_expr): Use it for tcc_comparison of operands of non BLKmode
	aggregate types.

(Installed in GCC 4.2 on 2006-06-24 - revision 114963)

2006-05-15  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.c (variably_modified_type_p) <ARRAY_TYPE>: Return true
	if the element type is variably modified without recursing.

(Installed in GCC 4.2 on 2006-05-17 - revision 113858)

2006-05-12  Eric Botcazou  <ebotcazou@adacore.com>

	Elimination of unreachable nested functions
	* tree-nested.c (nesting_info): New fields 'next_reachable'
	and 'reachable'.
	(discard_unreachable): New global variable.
	(ni_map): Likewise.
	(ni_hash): New function.
	(ni_eq): Likewise.
	(get_frame_type): Update comment about addressability.
	(walk_all_functions): Check reachability of functions.
	(create_nesting_tree): Populate ni_map.
	(reachable_queue): New global variable.
	(mark_reachable_function_1): New function.
	(mark_reachable_functions_1): Likewise.
	(mark_reachable_functions): Likewise.
	(convert_all_function_calls): Check reachability of functions.
	(finalize_nesting_tree_1): Do not unnest nested functions.
	(finalize_nesting_tree): Check reachability of functions.
	(unnest_nesting_tree_1): New function.
	(unnest_nesting_tree): Likewise.
	(free_nesting_tree): Use 'for' instead of 'do' loop.
	(lower_nested_functions): Initialize and destroy ni_map.
	Set discard_unreachable based on the optimization level.
	Invoke mark_reachable_functions if discard_unreachable is true.
	Invoke unnest_nesting_tree at the end of the pass.

(Superseded by patch in gcc-43.dif)

2006-05-11  Eric Botcazou  <ebotcazou@adacore.com>

	Callgraph info support
	* common.opt (-fcallgraph-info[=]): New option.
	* doc/invoke.texi (Debugging options): Document it.
	* flags.h (flag_stack_usage_info): New flag.
	(flag_callgraph_info): Likewise.
	* opts.c (common_handle_option): Handle -fcallgraph-info[=].
	Set flag_stack_usage_info to 1 if -fstack-usage.
	* calls.c (expand_call): If -fcallgraph-info, record calls.
	Test flag_stack_usage_info instead of flag_stack_usage.
	(emit_library_call_value_1): Likewise.
	* cgraph.h (struct cgraph_final_info): New structure.
	(cgraph_final_edge): Likewise.
	(cgraph_node): Add 'final' field.
	(dump_cgraph_final_vcg): Declare.
	(cgraph_final_record_call): Likewise.
	(cgraph_final_info): Likewise.
	* cgraph.c (cgraph_node): Initialize 'final' field.
	(final_create_edge): New static function.
	(cgraph_final_record_call): New global function.
	(cgraph_final_info): Likewise.
	(dump_cgraph_final_indirect_call_node_vcg): New static function.
	(dump_cgraph_final_edge_vcg): Likewise.
	(dump_cgraph_final_node_vcg): Likewise.
	(external_node_needed_p): Likewise.
	(dump_cgraph_final_vcg): New global function.
	(block_move_fn_node): New global variable.
	(block_clear_fn_node): Likewise
	* explow.c (allocate_dynamic_stack_space): Test flag_stack_usage_info
	instead of flag_stack_usage.
	* expr.c (emit_block_move_via_libcall): Set current source location on
	the new call expression.
	(clear_storage_via_libcall): Likewise.
	(block_move_fn): Make global.
	(block_clear_fn): Likewise.
	Do not include gt-expr.h.
	* function.c (instantiate_virtual_regs): Test flag_stack_usage_info
	instead of flag_stack_usage.
	(prepare_function_start): Likewise.
	* flow.c (rest_of_handle_flow2): Likewise.
	* langhooks.c (lhd_print_decl_source_location): New function.
	* langhooks.h (lang_hooks): New method 'print_decl_source_location'.
	* langhooks-def.h (lhd_print_decl_source_location): Declare it.
	(LANG_HOOKS_PRINT_DECL_SOURCE_LOCATION): Define to above.
	(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_PRINT_DECL_SOURCE_LOCATION.
	* print-tree.c (print_decl_identifier): New function.
	* toplev.h (stack_usage_qual): Declare.
	* toplev.c (flag_callgraph_info): New flag.
	(flag_stack_usage_info): Likewise.
	(stack_usage_qual): New global variable.
	(output_stack_usage): If -fcallgraph-info=su, set stack_usage_kind
	and stack_usage of associated callgraph node.  If -fstack-usage, use
	print_decl_identifier for pretty-printing.
	(finalize): If -fcallgraph-info, invoke dump_cgraph_vcg.
	* tree.h (print_decl_identifier): Declare it.
	(PRINT_DECL_ORIGIN, PRINT_DECL_NAME, PRINT_DECL_UNIQUE_NAME): New.
	(block_move_fn): Declare.
	(block_clear_fn): Likewise.
	* Makefile.in (GTFILES): Remove gt-expr.h.
	(expr.o): Likewise.

(Superseded by patch in gcc-43.dif)

2006-05-11  Nicolas Setton  <setton@adacore.com>

	Backport from GCC 4.2
	* tree.h (TYPE_STRING_FLAG): Document that this field may be used
	on INTEGER_TYPEs to indicate that it denotes a character type.
	* tree.c (build_common_tree_nodes): Set TYPE_STRING_FLAG on
	signed_char_type_node, unsigned_char_type_node and char_type_node.
	* dwarf2out.c (base_type_die): Treat CHAR_TYPE identically to
	INTEGER_TYPE.  Use TYPE_STRING_FLAG to decide whether to emit
	a DW_ATE_[un]signed_char instead of a DW_ATE_[un]signed.

(Already in GCC 4.2)

2006-05-11  Olivier Hainque  <hainque@adacore.com>

	* tree.h (categorize_ctor_elements): Adjust prototype and add
	descriptive comment, both in accordance with the interface change
	described below.
	* varasm.c (constructor_static_from_elts_p): New function.
	Whether a constructor node is a valid static constant initializer
	if all its elements are.
	(initializer_constant_valid_p) <CONSTRUCTOR value>: Use it.
	* output.h: Declare it.
	* expr.c (categorize_ctor_elements_1): Return whether the constructor
	is a valid constant initializer instead of computing the number of
	non-constant elements.  Use constructor_static_from_elts_p for this
	purpose.  Replace the head comment with an indication that this is a
	helper for categorize_ctor_elements.
	(categorize_ctor_elements): Same interface change as for the _1
	helper.  Former head comment from this helper moved here, adjusted to
	account for the interface changes.
	(mostly_zeros_p): Adjust call to categorize_ctor_elements.
	(all_zeros_p): Likewise.
	* gimplify.c (gimplify_init_constructor): Decide whether we can make
	static versions of the constructor from the categorize_ctor_elements
	return value instead of the formerly computed number of non-constant
	elements.

(Installed in GCC 4.2 on 2006-07-18 - revision 115553)

2006-05-07  Eric Botcazou  <ebotcazou@adacore.com>

	Stack usage support
	* common.opt (-fstack-usage): New option.
	* doc/invoke.texi (Debugging options): Document it.
	* expr.h (allocate_dynamic_stack_space): Add 4th bool parameter.
	* builtins.c (expand_builtin_apply): Pass TRUE as 4th argument to
	allocate_dynamic_stack_space.
	(expand_builtin_alloca): Add 4th bool parameter CANNOT_ACCUMULATE
	and propagate it to allocate_dynamic_stack_space.
	(expand_builtin) <BUILT_IN_ALLOCA>: Adjust for above change.
	* calls.c (initialize_argument_information): Pass TRUE as 4th
	argument to allocate_dynamic_stack_space.
	(expand_call): Set current_function_has_unbounded_dynamic_stack_size
	to 1 when pushing a variable-sized argument onto the stack.  Pass
	TRUE as 4th argument to allocate_dynamic_stack_space.
	Update current_function_pushed_stack_size.
	(emit_library_call_value_1): Likewise.
	* explow.c (allocate_dynamic_stack_space): Add 4th bool parameter
	CANNOT_ACCUMULATE.  If flag_stack_usage, look into the size and
	attempt to find an upper bound.  Remove redundant code for the
	SETJMP_VIA_SAVE_AREA case.
	* flow.c (rest_of_handle_flow2): Invoke output_stack_usage if needed.
	* function.h (struct stack_usage): New structure.
	(current_function_pushed_stack_size): New macro.
	(current_function_dynamic_alloc_count): Likewise.
	(current_function_dynamic_stack_size): Likewise.
	(current_function_has_unbounded_dynamic_stack_size): Likewise.
	(current_function_allocates_dynamic_stack_space): Likewise.
	(struct function): Add new field 'su'.
	* function.c (instantiate_virtual_regs): If SETJMP_VIA_SAVE_AREA,
	add the value of the dynamic offset to the dynamic stack usage.
	(prepare_function_start): Allocate cfun->su if flag_stack_usage.
	* gimplify.c (gimplify_decl_expr): Set ALLOCA_FOR_VAR_P on the call
	to BUILT_IN_ALLOCA for variable-sized objects.
	* toplev.h (output_stack_usage): Declare.
	* toplev.c (stack_usage_file): New file pointer.
	(output_stack_usage): New function.
	(open_auxiliary_file): Likewise.
	(lang_dependent_init): Open file if flag_stack_usage is set.
	(finalize): Close file if stack_usage_file is not null.
	* tree.h (ALLOCA_FOR_VAR_P): New macro.
	* target.h (struct gcc_target): Add get_static_stack_usage.
	* target-def.h (TARGET_GET_STATIC_STACK_USAGE): Define to 0.
	(TARGET_INITIALIZER): Add it.
	* doc/tm.texi (Frame layout): Document it.
	* config/alpha/alpha.c (compute_frame_size): New function.
	(alpha_expand_prologue): Use it.
	(alpha_start_function): Likewise.
	(alpha_expand_epilogue): Likewise.
	(alpha_get_static_stack_usage): New function.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.
	* config/i386/i386.c (ix86_get_static_stack_usage): New function.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.
	* config/ia64/ia64.c (ia64_get_static_stack_usage): New function.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.
	* config/mips/mips.c (mips_get_static_stack_usage): New function.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.
	* config/pa/pa.c (pa_get_static_stack_usage): New function.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.
	* config/rs6000/rs6000.c (rs6000_get_static_stack_usage): New.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.
	* config/sparc/sparc.c (sparc_get_static_stack_usage): New function.
	(TARGET_GET_STATIC_STACK_USAGE): Define to it.

(Superseded by patch in gcc-43.dif)

2006-05-07  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-ssa-dom.c (simplify_cond_and_lookup_avail_expr): Really be
	prepared for extract_range_from_cond returning false, as described
	in the comment and implemented in the original fix for PR 19060.

(Irrelevant for GCC 4.2)

2006-05-06  Eric Botcazou  <ebotcazou@adacore.com>

	* tree-vrp.c (extract_range_from_assert): Remove special handling
	for types with super-types.  Set the range to VARYING for LT and GT
	if the computed range is effectively empty.

(Installed in GCC 4.2 on 2006-05-25 - revision 114108)

2006-04-21  Nicolas Roche  <roche@adacore.com>

	* Makefile.in (stamp-collect-ld): Do not remove collect-ld when
	already present in the gcc directory.

(Irrelevant for GCC 4.2)

2006-04-21  Nicolas Roche  <roche@adacore.com>

	* config/i386/mingw32.h (LINK_SPEC): Enable auto import from DLL(s).

(Superseded by patch in gcc-43.dif)

2006-04-21  Nicolas Roche  <roche@adacore.com>

	* config/i386/t-mingw32 (SHLIB_*): New macros.

(Superseded by patch in gcc-43.dif)

2006-04-21  Nicolas Roche  <roche@adacore.com>

	* config/i386/cygming.h (DWARF2_UNWIND_INFO): Set to 1.
	* config.gcc (i[34567]86-*-mingw32*): Add crtbegin.o and crtend.o.
	* crtstuff.c: Add mingw32 version.
	* config/i386/mingw32.h (STARTFILE_SPEC): Add crtbegin.o.
	(ENDFILE_SPEC): New macro.
	* config/i386/cygming.h (ASM_WEAKEN_LABEL): Delete.

(Already in GCC 4.3)

2006-04-21  Nicolas Roche  <roche@adacore.com>

	* cfgexpand.c (tree_expand_cfg): Use DECL_ASSEMBLER_NAME instead
	of DECL_NAME to detect if the current function is the main program.

(Obsolete for GCC 4.3)

2006-04-09  Eric Botcazou  <ebotcazou@adacore.com>

	* config/sparc/sparc.c (function_arg_slotno) <BLKmode>: Handle
	aggregate types other than record and union types.
	(function_arg): Likewise.
	(function_arg_pass_by_reference): In 64-bit mode, return 0 for
	small arrays.
	(function_value): In 64-bit mode, return objects that require it
	in FP registers.

(Installed in GCC 4.2 on 2006-04-11 - revision 112859)

2006-03-24  Eric Botcazou  <ebotcazou@adacore.com>

	* config/rs6000/rs6000-protos.h (rs6000_offsettable_memref_p): Declare.
	(rs6000_legitimate_small_data_p): Delete.
	* config/rs6000/rs6000.c (rs6000_offsettable_memref_p): New predicate.
	(rs6000_legitimate_small_data_p): Rename to legitimate_small_data_p
	and make static.  Add forward declaration.  Update uses.
	(rs6000_split_multireg_move): Use rs6000_offsettable_memref_p instead
	of offsettable_memref_p.
	* config/rs6000/rs6000.md (movdf_hardfloat32): Revert 2005-08-23 fix.
	Use rs6000_offsettable_memref_p instead of a less accurate predicate.

(Installed in GCC 4.2 on 2006-03-24 - revision 112349)

2006-03-21  Eric Botcazou  <ebotcazou@adacore.com>

	* tree.c (walk_type_fields): Do not handle TYPE_MIN_VALUE and
	TYPE_MAX_VALUE for scalar types here but...
	(walk_tree): ...there instead.  Return NULL_TREE if the TYPE_DECL
	is attached an error mark, and the return value of the callback
	if it is not NULL_TREE.
	* cp/pt.c (for_each_template_parm_r) <INTEGER_TYPE>: New case.
	Call for_each_template_parm on TYPE_MIN_VALUE and TYPE_MAX_VALUE.

(Installed in GCC 4.3 on 2006-12-04 - revision 119481)

2006-03-21  Eric Botcazou  <ebotcazou@adacore.com>

	EH-compatible garbage collection of sections
	* except.h (output_function_exception_table): Add
	'const char *' parameter.
	* output.h (default_exception_section): Likewise.
	* target.h (struct gcc_target) <exception_section>: Likewise.
	* except.c (PTR_SIZE): New macro.
	(default_exception_section): Add 'const char *' parameter.
	If named sections are supported and HAVE_LD_EH_GC_SECTIONS is
	defined and flag_function_sections is set, use a function-specific
	section.
	(output_function_exception_table): Add 'const char *' parameter.
	Adjust call to targetm.asm_out.exception_section.
	* final.c (rest_of_handle_final): Adjust calls to
	output_function_exception_table.
	* configure.ac (HAVE_LD_EH_GC_SECTIONS): New check.
	* config.in: Regenerate.
	* configure: Likewise.

(Installed in GCC 4.3 on 2006-10-28 - revision 118107)

2006-03-14  Eric Botcazou  <ebotcazou@adacore.com>

	* config/ia64/unwind-ia64.c (struct _Unwind_Context): Add new
	field 'signal_pfs_loc'.
	(uw_frame_state_for): Remove duplicate code dealing with leaf
	procedures without unwind info.
	If in the frame after unwinding through a signal handler, restore
	the AR.PFS register instead of the CFM if AR.PFS has not been saved.
	* config/ia64/linux-unwind.h (ia64_fallback_frame_state): Do not
	set 'pfs_loc' to the AR.PFS location in the signal context; instead
	set 'signal_pfs_loc'.
	Manually generate the unwind info for the AR.PFS register.
	(ABI_MARKER_OLD_LINUX_SIGTRAMP, ABI_MARKER_OLD_LINUX_INTERRUPT,
	ABI_MARKER_LINUX_SIGTRAMP, ABI_MARKER_LINUX_INTERRUPT): Define.
	(ia64_handle_unwabi): Test 'fs->unwabi' against them.
	Do not set 'pfs_loc' to the AR.PFS location in the signal context;
	instead set 'signal_pfs_loc'.
	Remove code preventing the AR.PFS register from being restored
	from the signal context.

(Superseded by patch in gcc-43.dif)

2006-03-14  Olivier Hainque  <hainque@adacore.com>

	* config/mips/iris6.h (MD_UNWIND_SUPPORT): Define.
	* config/mips/iris6-unwind.h: New file.

(Superseded by patch in gcc-43.dif)

2006-03-14  Olivier Hainque  <hainque@adacore.com>
            Jose Ruiz  <ruiz@adacore.com>

	* config/alpha/alpha.h (DWARF_FRAME_REGNUM): Define, so that fallback
	unwinders can use DWARF_ALT_FRAME_RETURN_COLUMN which depends on it.
	* config/alpha/osf5.h (MD_UNWIND_SUPPORT): Define.
	* config/alpha/osf5-unwind.h: New file.

(Superseded by patch in gcc-43.dif)

2006-03-14  Eric Botcazou  <ebotcazou@adacore.com>

	New stack checking implementation
	* common.opt (-fstack-check): Do not declare the variable here.
	(-fold-stack-check): New option.
	* doc/invoke.texi (Code Gen Options): Document it.
	* expr.h (STACK_CHECK_PROBE_INTERVAL): Delete.
	(STACK_CHECK_PROBE_INTERVAL_EXP): New macro.
	(STACK_CHECK_MAX_FRAME_SIZE): Adjust for above change.
	(STACK_CHECK_STATIC_BUILTIN): New macro.
	(STACK_OLD_CHECK_PROTECT): Likewise.
	(STACK_CHECK_PROTECT): Bump to 3 pages if DWARF-2 EH is used.
	* system.h (STACK_CHECK_PROBE_INTERVAL): Poison it.
	* doc/tm.texi (Stack Checking): Delete STACK_CHECK_PROBE_INTERVAL
	entry.  Add new entries for STACK_CHECK_PROBE_INTERVAL_EXP and
	STACK_CHECK_STATIC_BUILTIN.
	* opts.c: Include expr.h.
	(common_handle_option) <OPT_fold_stack_check>: New case.
	<OPT_fstack_check>: Likewise.
	* calls.c (emit_library_call_value_1): Clear the ECF_NOTHROW flag if
	the libcall is LCT_MAY_THROW.
	(initialize_argument_information): Use TYPE_SIZE_UNIT consistently
	in the test for variable-sized types.  Adjust for new behaviour of
	flag_stack_check.
	* function.c (gimplify_parameters): Use DECL_SIZE_UNIT in the test
	for variable-sized parameters.  Treat all parameters whose size is
	greater than STACK_CHECK_MAX_VAR_SIZE as variable-sized if generic
	stack checking is enabled.
	(expand_function_end): Adjust for new behaviour of flag_stack_check.
	* reload1.c (reload): Likewise.
	* stmt.c (expand_decl): Assert that all automatic variables have
	fixed size at this point and remove dead code.
	* gimplify.c (gimplify_decl_expr): Treat non-static objects whose
	size is greater than STACK_CHECK_MAX_VAR_SIZE as variable-sized
	if generic stack checking is enabled.
	* explow.c: Include except.h.
	(allocate_dynamic_stack_space): Do not take into account
	STACK_CHECK_MAX_FRAME_SIZE for static builtin stack checking.
	(set_stack_check_libfunc): Delete.
	(stack_check_libfunc): Make public.
	(PROBE_INTERVAL): New macro.
	(STACK_GROW_OPTAB): Likewise.
	(probe_stack_range): Cope with SPARC_STACK_BIAS.  Pass LCT_MAY_THROW
	to emit_library_call for the checking routine.  Remove support code
	for MD pattern.  Fix loop condition in the small constant case.
	Rewrite in the general case to be immune to wrap-around.
	Do not include gt-explow.h.
	* Makefile.in (explow.o): Remove gt-explow.h.
	(list of gt files): Likewise.
	* rtl.h (set_stack_check_libfunc): Delete.
	(stack_check_libfunc): Declare.
	(libcall_type enum): Add LCT_MAY_THROW.
	* flags.h (stack_check_type): New enumeration type.
	(flag_stack_check): Change type to above.
	* toplev.c (flag_stack_check): Likewise.
	* tree.c (build_common_builtin_nodes): Do not set ECF_NOTHROW on
	__builtin_alloca if stack checking is enabled.
	* config/alpha/alpha.c (alpha_expand_prologue): If stack checking
	is enabled, probe up to frame_size + STACK_CHECK_PROTECT bytes.
	* config/i386/i386.c (ix86_target_stack_probe): New function.
	(ix86_emit_probe_stack_range): Likewise.
	(output_probe_stack_range): Likewise.
	(ix86_expand_prologue): Invoke ix86_emit_probe_stack_range if static
	builtin stack checking is enabled.
	Test ix86_target_stack_probe instead of TARGET_STACK_PROBE.
	* config/i386/i386.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/i386/i386.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(allocate_stack_worker): Test ix86_target_stack_probe instead of
	TARGET_STACK_PROBE.
	(allocate_stack_worker_1): Likewise.
	(allocate_stack_worker_rex64): Likewise.
	(allocate_stack): Likewise.
	(probe_stack_range): New insn.
	* config/i386/i386-protos.h (ix86_target_stack_probe): Declare.
	(output_probe_stack_range): Likewise.
	* config/ia64/ia64.c (ia64_emit_probe_stack_range): New function.
	(output_probe_stack_range): Likewise.
	(ia64_expand_prologue): Invoke ia64_emit_probe_stack_range if static
	builtin stack checking is enabled.
	(rtx_needs_barrier): Return 1 for inline stack probes.
	(asm_insn_p): New predicate.
	(ia64_dfa_sched_reorder): Use it.
	(ia64_dfa_new_cycle): Likewise.
	(issue_nops_and_insn): Likewise.
	(bundling): Likewise.
	(final_emit_insn_group_barriers): Likewise.
	* config/ia64/ia64.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/ia64/ia64-protos.h (output_probe_stack_range): Declare.
	* config/ia64/linux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/ia64/hpux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	((STACK_CHECK_PROTECT): Define.
	* config/mips/iris6.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/mips/mips.c: Include except.h.
	(mips_emit_probe_stack_range): New function.
	(mips_output_probe_stack_range): Likewise.
	(mips_expand_prologue): Invoke mips_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/mips/mips.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/mips/mips-protos.h (mips_output_probe_stack_range): Declare.
	* config/pa/pa.c (pa_emit_probe_stack_range): New function.
	(output_probe_stack_range): Likewise.
	(hppa_expand_prologue): Invoke pa_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/pa/pa-hpux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/pa/pa.md (probe_stack_range): New insn.
	* config/pa/pa-protos.h (output_probe_stack_range): Declare.
	* config/rs6000/aix.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/rs6000/rs6000.c (rs6000_emit_probe_stack_range): New function.
	(output_probe_stack_range): Likewise.
	(rs6000_emit_prologue): Invoke rs6000_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/rs6000/rs6000.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/rs6000/rs6000-protos.h (output_probe_stack_range): Declare.
	* config/rs6000/vxworksae.h (STACK_CHECK_PROTECT): Define to 4096.
	(STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/sparc/sol2.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.
	* config/sparc/sparc.c: Include except.h.
	(sparc_emit_probe_stack_range): New function.
	(build_big_number): Likewise.
	(output_probe_stack_range): Likewise.
	(sparc_expand_prologue): Invoke sparc_emit_probe_stack_range if static
	builtin stack checking is enabled.
	* config/sparc/sparc.md (UNSPECV_STACK_PROBE_INLINE): New constant.
	(probe_stack_range): New insn.
	* config/sparc/sparc-protos.h (output_probe_stack_range): Declare.

(Superseded by patch in gcc-43.dif)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* config/alpha/alpha.c (alpha_split_tfmode_pair): Rename into
	alpha_split_tmode_pair.  Add 'mode' and 'fixup_overlap' arguments.
	Test against the appropriate null constant for the mode.
	If 'fixup_overlap' is true, swap the operands if they overlap.
	(alpha_split_tfmode_frobsign): Adjust call to alpha_split_tfmode_pair.
	* config/alpha/alpha-protos.h (alpha_split_tfmode_pair): Rename into
	alpha_split_tmode_pair and adjust for above change.
	* config/alpha/alpha.md (movtf_internal): Adjust call to
	alpha_split_tfmode_pair and rely on it to swap the operands.
	(movti_internal): New insn and post-reload splitter.
	(movti): New expander.

(Installed in GCC 4.2 on 2006-01-18 - revision 109882)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* cfglayout.c (fixup_reorder_chain): Remove kludge for the
	case of conditional jump jumping to the next instruction.
	* cfgrtl.c (force_nonfallthru_and_redirect): Accept all
	cases of conditional jump jumping to the next instruction.

(Installed in GCC 4.2 on 2006-01-02 - revision 109247)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (fold_minmax): New static function.
	(fold) <MIN_EXPR>: Call it.
	<MAX_EXPR>: Likewise.
	* stor-layout.c (place_field): Use DECL_SIZE consistently
	in the computation of the new record size.

(Installed in GCC 4.2 on 2006-01-16 - revision 109747)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* config/sparc/sparc.md (setjmp): Rewrite.
	(setjmp_32): Delete.
	(setjmp_64): Likewise.

(Installed in GCC 4.2 on 2006-02-16 - revision 111154)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (build_range_check): Make sure to use a valid type to
	apply the "(c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low)"
	transformation.

(Installed in GCC 4.2 on 2006-03-09 - revision 111866)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* fold-const.c (range_predecessor): New static function.
	(range_successor): Likewise.
	(merge_ranges): Use them to compute predecessors and successors
	of range bounds.

(Installed in GCC 4.2 on 2006-03-09 - revision 111866)

2006-03-12  Eric Botcazou  <ebotcazou@adacore.com>

	* function.h (frame_offset_overflow): Declare.
	* function.c (frame_offset_overflow): New function.
	(assign_stack_local_1): Call it to detect that the offset overflows.
	* cfgexpand.c (alloc_stack_frame_space): Likewise.

(Installed in GCC 4.2 on 2006-03-11 - revision 111964)

=============================================================================
*** gcc/function.h.0	2006-03-12 09:14:47.057749296 +0100
--- gcc/function.h	2006-03-12 09:15:14.296608360 +0100
*************** extern void free_block_changes (void);
*** 543,548 ****
--- 543,553 ----
     the caller may have to do that.  */
  extern HOST_WIDE_INT get_frame_size (void);
  
+ /* Issue an error message and return TRUE if frame OFFSET overflows in
+    the signed target pointer arithmetics for function FUNC.  Otherwise
+    return FALSE.  */
+ extern bool frame_offset_overflow (HOST_WIDE_INT, tree);
+ 
  /* A pointer to a function to create target specific, per-function
     data structures.  */
  extern struct machine_function * (*init_machine_status) (void);
*** gcc/function.c.0	2006-03-12 09:14:47.118740024 +0100
--- gcc/function.c	2006-03-12 09:15:14.300607752 +0100
*************** get_func_frame_size (struct function *f)
*** 358,369 ****
--- 358,390 ----
  /* Return size needed for stack frame based on slots so far allocated.
     This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;
     the caller may have to do that.  */
+ 
  HOST_WIDE_INT
  get_frame_size (void)
  {
    return get_func_frame_size (cfun);
  }
  
+ /* Issue an error message and return TRUE if frame OFFSET overflows in
+    the signed target pointer arithmetics for function FUNC.  Otherwise
+    return FALSE.  */
+ 
+ bool
+ frame_offset_overflow (HOST_WIDE_INT offset, tree func)
+ {  
+   unsigned HOST_WIDE_INT size = FRAME_GROWS_DOWNWARD ? -offset : offset;
+ 
+   if (size > ((unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (Pmode) - 1))
+ 	       /* Leave room for the fixed part of the frame.  */
+ 	       - 64 * UNITS_PER_WORD)
+     {
+       error ("%Jtotal size of local objects too large", func);
+       return TRUE;
+     }
+ 
+   return FALSE;
+ }
+ 
  /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it
     with machine mode MODE.
  
*************** assign_stack_local_1 (enum machine_mode 
*** 479,498 ****
    function->x_stack_slot_list
      = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);
  
!   /* Try to detect frame size overflows on native platforms.  */
! #if BITS_PER_WORD >= 32
!   if ((FRAME_GROWS_DOWNWARD
!        ? (unsigned HOST_WIDE_INT) -function->x_frame_offset
!        : (unsigned HOST_WIDE_INT) function->x_frame_offset)
! 	> ((unsigned HOST_WIDE_INT) 1 << (BITS_PER_WORD - 1))
! 	    /* Leave room for the fixed part of the frame.  */
! 	    - 64 * UNITS_PER_WORD)
!     {
!       error ("%Jtotal size of local objects too large", function->decl);
!       /* Avoid duplicate error messages as much as possible.  */
!       function->x_frame_offset = 0;
!     }
! #endif
  
    return x;
  }
--- 500,507 ----
    function->x_stack_slot_list
      = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);
  
!   if (frame_offset_overflow (function->x_frame_offset, function->decl))
!     function->x_frame_offset = 0;
  
    return x;
  }
*** gcc/cfgexpand.c.0	2006-03-12 09:14:47.135737440 +0100
--- gcc/cfgexpand.c	2006-03-12 09:15:14.302607448 +0100
*************** alloc_stack_frame_space (HOST_WIDE_INT s
*** 194,199 ****
--- 194,202 ----
      }
    frame_offset = new_frame_offset;
  
+   if (frame_offset_overflow (frame_offset, cfun->decl))
+     frame_offset = offset = 0;
+ 
    return offset;
  }
  
*** gcc/fold-const.c.0	2006-03-12 11:00:31.760207912 +0100
--- gcc/fold-const.c	2006-03-12 11:19:14.420537600 +0100
*************** static int all_ones_mask_p (tree, int);
*** 109,114 ****
--- 109,116 ----
  static tree sign_bit_p (tree, tree);
  static int simple_operand_p (tree);
  static tree range_binop (enum tree_code, tree, tree, int, tree, int);
+ static tree range_predecessor (tree);
+ static tree range_successor (tree);
  static tree make_range (tree, int *, tree *, tree *);
  static tree build_range_check (tree, tree, int, tree, tree);
  static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,
*************** build_range_check (tree type, tree exp, 
*** 4089,4094 ****
--- 4091,4124 ----
    return 0;
  }
  
+ /* Return the predecessor of VAL in its type, handling the infinite case.  */
+ 
+ static tree
+ range_predecessor (tree val)
+ {
+   tree type = TREE_TYPE (val);
+ 
+   if (INTEGRAL_TYPE_P (type)
+       && operand_equal_p (val, TYPE_MIN_VALUE (type), 0))
+     return 0;
+   else
+     return range_binop (MINUS_EXPR, NULL_TREE, val, 0, integer_one_node, 0);
+ }
+ 
+ /* Return the successor of VAL in its type, handling the infinite case.  */
+ 
+ static tree
+ range_successor (tree val)
+ {
+   tree type = TREE_TYPE (val);
+ 
+   if (INTEGRAL_TYPE_P (type)
+       && operand_equal_p (val, TYPE_MAX_VALUE (type), 0))
+     return 0;
+   else
+     return range_binop (PLUS_EXPR, NULL_TREE, val, 0, integer_one_node, 0);
+ }
+ 
  /* Given two ranges, see if we can merge them into one.  Return 1 if we
     can, 0 if we can't.  Set the output range into the specified parameters.  */
  
*************** merge_ranges (int *pin_p, tree *plow, tr
*** 4150,4156 ****
        /* If they don't overlap, the result is the first range.  If they are
  	 equal, the result is false.  If the second range is a subset of the
  	 first, and the ranges begin at the same place, we go from just after
! 	 the end of the first range to the end of the second.  If the second
  	 range is not a subset of the first, or if it is a subset and both
  	 ranges end at the same place, the range starts at the start of the
  	 first range and ends just before the second range.
--- 4178,4184 ----
        /* If they don't overlap, the result is the first range.  If they are
  	 equal, the result is false.  If the second range is a subset of the
  	 first, and the ranges begin at the same place, we go from just after
! 	 the end of the second range to the end of the first.  If the second
  	 range is not a subset of the first, or if it is a subset and both
  	 ranges end at the same place, the range starts at the start of the
  	 first range and ends just before the second range.
*************** merge_ranges (int *pin_p, tree *plow, tr
*** 4161,4175 ****
  	in_p = 0, low = high = 0;
        else if (subset && lowequal)
  	{
! 	  in_p = 1, high = high0;
! 	  low = range_binop (PLUS_EXPR, NULL_TREE, high1, 0,
! 			     integer_one_node, 0);
  	}
        else if (! subset || highequal)
  	{
! 	  in_p = 1, low = low0;
! 	  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,
! 			      integer_one_node, 0);
  	}
        else
  	return 0;
--- 4189,4203 ----
  	in_p = 0, low = high = 0;
        else if (subset && lowequal)
  	{
! 	  low = range_successor (high1);
! 	  high = high0;
! 	  in_p = (low != 0);
  	}
        else if (! subset || highequal)
  	{
! 	  low = low0;
! 	  high = range_predecessor (low1);
! 	  in_p = (high != 0);
  	}
        else
  	return 0;
*************** merge_ranges (int *pin_p, tree *plow, tr
*** 4187,4195 ****
  	in_p = 0, low = high = 0;
        else
  	{
! 	  in_p = 1, high = high1;
! 	  low = range_binop (PLUS_EXPR, NULL_TREE, high0, 1,
! 			     integer_one_node, 0);
  	}
      }
  
--- 4215,4223 ----
  	in_p = 0, low = high = 0;
        else
  	{
! 	  low = range_successor (high0);
! 	  high = high1;
! 	  in_p = (low != 0);
  	}
      }
  
*************** merge_ranges (int *pin_p, tree *plow, tr
*** 4204,4212 ****
        if (no_overlap)
  	{
  	  if (integer_onep (range_binop (EQ_EXPR, integer_type_node,
! 					 range_binop (PLUS_EXPR, NULL_TREE,
! 						      high0, 1,
! 						      integer_one_node, 1),
  					 1, low1, 0)))
  	    in_p = 0, low = low0, high = high1;
  	  else
--- 4232,4238 ----
        if (no_overlap)
  	{
  	  if (integer_onep (range_binop (EQ_EXPR, integer_type_node,
! 					 range_successor (high0),
  					 1, low1, 0)))
  	    in_p = 0, low = low0, high = high1;
  	  else
*************** merge_ranges (int *pin_p, tree *plow, tr
*** 4267,4276 ****
  	         return + [x + 1, y - 1].  */
  	      if (low0 == 0 && high1 == 0)
  	        {
! 		  low = range_binop (PLUS_EXPR, NULL_TREE, high0, 1,
! 				     integer_one_node, 1);
! 		  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,
! 				      integer_one_node, 0);
  		  if (low == 0 || high == 0)
  		    return 0;
  
--- 4293,4300 ----
  	         return + [x + 1, y - 1].  */
  	      if (low0 == 0 && high1 == 0)
  	        {
! 		  low = range_successor (high0);
! 		  high = range_predecessor (low1);
  		  if (low == 0 || high == 0)
  		    return 0;
  
*** gcc/fold-const.c.0	2006-03-12 12:41:16.824218496 +0100
--- gcc/fold-const.c	2006-03-12 12:49:08.334538032 +0100
*************** build_range_check (tree type, tree exp, 
*** 4032,4092 ****
  	}
      }
  
!   value = const_binop (MINUS_EXPR, high, low, 0);
!   if (value != 0 && (!flag_wrapv || TREE_OVERFLOW (value))
!       && ! TYPE_UNSIGNED (etype))
      {
        tree utype, minv, maxv;
  
        /* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN
  	 for the type in question, as we rely on this here.  */
!       switch (TREE_CODE (etype))
! 	{
! 	case INTEGER_TYPE:
! 	case ENUMERAL_TYPE:
! 	case CHAR_TYPE:
! 	  /* There is no requirement that LOW be within the range of ETYPE
! 	     if the latter is a subtype.  It must, however, be within the base
! 	     type of ETYPE.  So be sure we do the subtraction in that type.  */
! 	  if (TREE_TYPE (etype))
! 	    etype = TREE_TYPE (etype);
! 	  utype = lang_hooks.types.unsigned_type (etype);
! 	  maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));
! 	  maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,
! 			      integer_one_node, 1);
! 	  minv = fold_convert (utype, TYPE_MIN_VALUE (etype));
! 	  if (integer_zerop (range_binop (NE_EXPR, integer_type_node,
! 					  minv, 1, maxv, 1)))
! 	    {
! 	      etype = utype;
! 	      high = fold_convert (etype, high);
! 	      low = fold_convert (etype, low);
! 	      exp = fold_convert (etype, exp);
! 	      value = const_binop (MINUS_EXPR, high, low, 0);
! 	    }
! 	  break;
! 	default:
! 	  break;
! 	}
      }
  
!   if (value != 0 && ! TREE_OVERFLOW (value))
!     {
!       /* There is no requirement that LOW be within the range of ETYPE
! 	 if the latter is a subtype.  It must, however, be within the base
! 	 type of ETYPE.  So be sure we do the subtraction in that type.  */
!       if (INTEGRAL_TYPE_P (etype) && TREE_TYPE (etype))
! 	{
! 	  etype = TREE_TYPE (etype);
! 	  exp = fold_convert (etype, exp);
! 	  low = fold_convert (etype, low);
! 	  value = fold_convert (etype, value);
! 	}
  
!       return build_range_check (type,
! 				fold_build2 (MINUS_EXPR, etype, exp, low),
! 				1, build_int_cst (etype, 0), value);
!     }
  
    return 0;
  }
--- 4032,4091 ----
  	}
      }
  
!   /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).
!      This requires wrap-around arithmetics for the type of the expression.  */
!   switch (TREE_CODE (etype))
!     {
!     case INTEGER_TYPE:
!       /* There is no requirement that LOW be within the range of ETYPE
! 	 if the latter is a subtype.  It must, however, be within the base
! 	 type of ETYPE.  So be sure we do the subtraction in that type.  */
!       if (TREE_TYPE (etype))
! 	etype = TREE_TYPE (etype);
!       break;
! 
!     case ENUMERAL_TYPE:
!     case BOOLEAN_TYPE:
!     case CHAR_TYPE:
!       etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
! 					      TYPE_UNSIGNED (etype));
!       break;
! 
!     default:
!       break;
!     }
! 
!   /* If we don't have wrap-around arithmetics upfront, try to force it.  */
!   if (TREE_CODE (etype) == INTEGER_TYPE
!       && !TYPE_UNSIGNED (etype) && !flag_wrapv)
      {
        tree utype, minv, maxv;
  
        /* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN
  	 for the type in question, as we rely on this here.  */
!       utype = lang_hooks.types.unsigned_type (etype);
!       maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));
!       maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,
! 			  integer_one_node, 1);
!       minv = fold_convert (utype, TYPE_MIN_VALUE (etype));
! 
!       if (integer_zerop (range_binop (NE_EXPR, integer_type_node,
! 				      minv, 1, maxv, 1)))
! 	etype = utype;
!       else
! 	return 0;
      }
  
!   high = fold_convert (etype, high);
!   low = fold_convert (etype, low);
!   exp = fold_convert (etype, exp);
  
!   value = const_binop (MINUS_EXPR, high, low, 0);
! 
!   if (value != 0 && !TREE_OVERFLOW (value))
!     return build_range_check (type,
! 			      fold_build2 (MINUS_EXPR, etype, exp, low),
! 			      1, build_int_cst (etype, 0), value);
  
    return 0;
  }
*** gcc/config/sparc/sparc.md.0	2006-03-12 14:39:45.012609608 +0100
--- gcc/config/sparc/sparc.md	2006-03-12 14:39:58.000635128 +0100
***************
*** 7285,7309 ****
    [(const_int 0)]
    ""
  {
!   if (TARGET_ARCH64)
!     emit_insn (gen_setjmp_64 ());
!   else
!     emit_insn (gen_setjmp_32 ());
    DONE;
  })
  
- (define_expand "setjmp_32"
-   [(set (mem:SI (plus:SI (reg:SI 14) (const_int 56))) (match_dup 0))
-    (set (mem:SI (plus:SI (reg:SI 14) (const_int 60))) (reg:SI 31))]
-   ""
-   { operands[0] = frame_pointer_rtx; })
- 
- (define_expand "setjmp_64"
-   [(set (mem:DI (plus:DI (reg:DI 14) (const_int 112))) (match_dup 0))
-    (set (mem:DI (plus:DI (reg:DI 14) (const_int 120))) (reg:DI 31))]
-   ""
-   { operands[0] = frame_pointer_rtx; })
- 
  ;; Special pattern for the FLUSH instruction.
  
  ; We do SImode and DImode versions of this to quiet down genrecog's complaints
--- 7285,7304 ----
    [(const_int 0)]
    ""
  {
!   rtx mem;
!   
!   mem = gen_rtx_MEM (Pmode,
! 		     plus_constant (stack_pointer_rtx,
! 				    SPARC_STACK_BIAS + 14 * UNITS_PER_WORD));
!   emit_insn (gen_rtx_SET (VOIDmode, mem, frame_pointer_rtx));
! 
!   mem = gen_rtx_MEM (Pmode,
! 		     plus_constant (stack_pointer_rtx,
! 				    SPARC_STACK_BIAS + 15 * UNITS_PER_WORD));
!   emit_insn (gen_rtx_SET (VOIDmode, mem, gen_rtx_REG (Pmode, 31)));
    DONE;
  })
  
  ;; Special pattern for the FLUSH instruction.
  
  ; We do SImode and DImode versions of this to quiet down genrecog's complaints
*** gcc/fold-const.c.0	2006-03-12 14:43:46.000000000 +0100
--- gcc/fold-const.c	2006-03-12 14:44:25.718935760 +0100
*************** fold_unary (enum tree_code code, tree ty
*** 7061,7066 ****
--- 7061,7109 ----
  }
  
  /* Fold a binary expression of code CODE and type TYPE with operands
+    OP0 and OP1, containing either a MIN-MAX or a MAX-MIN combination.
+    Return the folded expression if folding is successful.  Otherwise,
+    return NULL_TREE.  */
+ 
+ static tree
+ fold_minmax (enum tree_code code, tree type, tree op0, tree op1)
+ {
+   enum tree_code compl_code;
+ 
+   if (code == MIN_EXPR)
+     compl_code = MAX_EXPR;
+   else if (code == MAX_EXPR)
+     compl_code = MIN_EXPR;
+   else
+     gcc_unreachable ();
+ 
+   /* MIN (MAX (a, b), b) == b.  */
+   if (TREE_CODE (op0) == compl_code
+       && operand_equal_p (TREE_OPERAND (op0, 1), op1, 0))
+     return omit_one_operand (type, op1, TREE_OPERAND (op0, 0));
+ 
+   /* MIN (MAX (b, a), b) == b.  */
+   if (TREE_CODE (op0) == compl_code
+       && operand_equal_p (TREE_OPERAND (op0, 0), op1, 0)
+       && reorder_operands_p (TREE_OPERAND (op0, 1), op1))
+     return omit_one_operand (type, op1, TREE_OPERAND (op0, 1));
+ 
+   /* MIN (a, MAX (a, b)) == a.  */
+   if (TREE_CODE (op1) == compl_code
+       && operand_equal_p (op0, TREE_OPERAND (op1, 0), 0)
+       && reorder_operands_p (op0, TREE_OPERAND (op1, 1)))
+     return omit_one_operand (type, op0, TREE_OPERAND (op1, 1));
+ 
+   /* MIN (a, MAX (b, a)) == a.  */
+   if (TREE_CODE (op1) == compl_code
+       && operand_equal_p (op0, TREE_OPERAND (op1, 1), 0)
+       && reorder_operands_p (op0, TREE_OPERAND (op1, 0)))
+     return omit_one_operand (type, op0, TREE_OPERAND (op1, 0));
+ 
+   return NULL_TREE;
+ }
+ 
+ /* Fold a binary expression of code CODE and type TYPE with operands
     OP0 and OP1.  Return the folded expression if folding is
     successful.  Otherwise, return NULL_TREE.  */
  
*************** fold_binary (enum tree_code code, tree t
*** 8766,8771 ****
--- 8809,8817 ----
        if (INTEGRAL_TYPE_P (type)
  	  && operand_equal_p (arg1, TYPE_MIN_VALUE (type), OEP_ONLY_CONST))
  	return omit_one_operand (type, arg1, arg0);
+       tem = fold_minmax (MIN_EXPR, type, arg0, arg1);
+       if (tem)
+ 	return tem;
        goto associate;
  
      case MAX_EXPR:
*************** fold_binary (enum tree_code code, tree t
*** 8775,8780 ****
--- 8821,8829 ----
  	  && TYPE_MAX_VALUE (type)
  	  && operand_equal_p (arg1, TYPE_MAX_VALUE (type), OEP_ONLY_CONST))
  	return omit_one_operand (type, arg1, arg0);
+       tem = fold_minmax (MAX_EXPR, type, arg0, arg1);
+       if (tem)
+ 	return tem;
        goto associate;
  
      case TRUTH_ANDIF_EXPR:
*** gcc/stor-layout.c.0	2006-03-12 14:44:23.814225320 +0100
--- gcc/stor-layout.c	2006-03-12 14:44:25.721935304 +0100
*************** place_field (record_layout_info rli, tre
*** 1251,1258 ****
       is printed in finish_struct.  */
    if (DECL_SIZE (field) == 0)
      /* Do nothing.  */;
!   else if (TREE_CODE (DECL_SIZE_UNIT (field)) != INTEGER_CST
! 	   || TREE_CONSTANT_OVERFLOW (DECL_SIZE_UNIT (field)))
      {
        rli->offset
  	= size_binop (PLUS_EXPR, rli->offset,
--- 1251,1258 ----
       is printed in finish_struct.  */
    if (DECL_SIZE (field) == 0)
      /* Do nothing.  */;
!   else if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST
! 	   || TREE_CONSTANT_OVERFLOW (DECL_SIZE (field)))
      {
        rli->offset
  	= size_binop (PLUS_EXPR, rli->offset,
*** gcc/cfglayout.c.0	2006-03-12 15:42:57.979990920 +0100
--- gcc/cfglayout.c	2006-03-12 15:43:20.602551768 +0100
*************** fixup_reorder_chain (void)
*** 680,720 ****
  		continue;
  
  	      /* The degenerated case of conditional jump jumping to the next
! 		 instruction can happen on target having jumps with side
! 		 effects.
! 
! 		 Create temporarily the duplicated edge representing branch.
! 		 It will get unidentified by force_nonfallthru_and_redirect
! 		 that would otherwise get confused by fallthru edge not pointing
! 		 to the next basic block.  */
  	      if (!e_taken)
! 		{
! 		  rtx note;
! 		  edge e_fake;
! 		  bool redirected;
! 
! 		  e_fake = unchecked_make_edge (bb, e_fall->dest, 0);
! 
! 		  redirected = redirect_jump (BB_END (bb),
! 					      block_label (bb), 0);
! 		  gcc_assert (redirected);
! 		  
! 		  note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);
! 		  if (note)
! 		    {
! 		      int prob = INTVAL (XEXP (note, 0));
  
! 		      e_fake->probability = prob;
! 		      e_fake->count = e_fall->count * prob / REG_BR_PROB_BASE;
! 		      e_fall->probability -= e_fall->probability;
! 		      e_fall->count -= e_fake->count;
! 		      if (e_fall->probability < 0)
! 			e_fall->probability = 0;
! 		      if (e_fall->count < 0)
! 			e_fall->count = 0;
! 		    }
! 		}
! 	      /* There is one special case: if *neither* block is next,
  		 such as happens at the very end of a function, then we'll
  		 need to add a new unconditional jump.  Choose the taken
  		 edge based on known or assumed probability.  */
--- 680,692 ----
  		continue;
  
  	      /* The degenerated case of conditional jump jumping to the next
! 		 instruction can happen for jumps with side effects.  We need
! 		 to construct a forwarder block and this will be done just
! 		 fine by force_nonfallthru below.  */
  	      if (!e_taken)
! 		;
  
! 	      /* There is another special case: if *neither* block is next,
  		 such as happens at the very end of a function, then we'll
  		 need to add a new unconditional jump.  Choose the taken
  		 edge based on known or assumed probability.  */
*** gcc/cfgrtl.c.0	2006-03-12 15:43:03.850098528 +0100
--- gcc/cfgrtl.c	2006-03-12 15:43:20.605551312 +0100
*************** force_nonfallthru_and_redirect (edge e, 
*** 1013,1021 ****
       by creating a basic block afterwards to redirect fallthru edge.  */
    if (e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR
        && any_condjump_p (BB_END (e->src))
-       /* When called from cfglayout, fallthru edges do not
-          necessarily go to the next block.  */
-       && e->src->next_bb == e->dest
        && JUMP_LABEL (BB_END (e->src)) == BB_HEAD (e->dest))
      {
        rtx note;
--- 1013,1018 ----
*** gcc/config/alpha/alpha.c.0	2006-03-12 16:54:42.306633808 +0100
--- gcc/config/alpha/alpha.c	2006-03-12 16:54:51.455243008 +0100
*************** alpha_emit_xfloating_cvt (enum rtx_code 
*** 3232,3243 ****
  					       operands[1]));
  }
  
! /* Split a TFmode OP[1] into DImode OP[2,3] and likewise for
!    OP[0] into OP[0,1].  Naturally, output operand ordering is
!    little-endian.  */
! 
  void
! alpha_split_tfmode_pair (rtx operands[4])
  {
    switch (GET_CODE (operands[1]))
      {
--- 3232,3248 ----
  					       operands[1]));
  }
  
! /* Split a TImode or TFmode move from OP[1] to OP[0] into a pair of
!    DImode moves from OP[2,3] to OP[0,1].  If FIXUP_OVERLAP is true,
!    guarantee that the sequence
!      set (OP[0] OP[2])
!      set (OP[1] OP[3])
!    is valid.  Naturally, output operand ordering is little-endian.
!    This is used by *movtf_internal and *movti_internal.  */
!   
  void
! alpha_split_tmode_pair (rtx operands[4], enum machine_mode mode,
! 			bool fixup_overlap)
  {
    switch (GET_CODE (operands[1]))
      {
*************** alpha_split_tfmode_pair (rtx operands[4]
*** 3251,3258 ****
        operands[2] = adjust_address (operands[1], DImode, 0);
        break;
  
      case CONST_DOUBLE:
!       gcc_assert (operands[1] == CONST0_RTX (TFmode));
        operands[2] = operands[3] = const0_rtx;
        break;
  
--- 3256,3264 ----
        operands[2] = adjust_address (operands[1], DImode, 0);
        break;
  
+     case CONST_INT:
      case CONST_DOUBLE:
!       gcc_assert (operands[1] == CONST0_RTX (mode));
        operands[2] = operands[3] = const0_rtx;
        break;
  
*************** alpha_split_tfmode_pair (rtx operands[4]
*** 3275,3280 ****
--- 3281,3293 ----
      default:
        gcc_unreachable ();
      }
+ 
+   if (fixup_overlap && reg_overlap_mentioned_p (operands[0], operands[3]))
+     {
+       rtx tmp;
+       tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;
+       tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;
+     }
  }
  
  /* Implement negtf2 or abstf2.  Op0 is destination, op1 is source,
*************** alpha_split_tfmode_frobsign (rtx operand
*** 3288,3294 ****
    rtx scratch;
    int move;
  
!   alpha_split_tfmode_pair (operands);
  
    /* Detect three flavors of operand overlap.  */
    move = 1;
--- 3301,3307 ----
    rtx scratch;
    int move;
  
!   alpha_split_tmode_pair (operands, TFmode, false);
  
    /* Detect three flavors of operand overlap.  */
    move = 1;
*** gcc/config/alpha/alpha.md.0	2006-03-12 16:54:42.346627728 +0100
--- gcc/config/alpha/alpha.md	2006-03-12 16:54:51.485238448 +0100
***************
*** 5157,5169 ****
    [(set (match_dup 0) (match_dup 2))
     (set (match_dup 1) (match_dup 3))]
  {
!   alpha_split_tfmode_pair (operands);
!   if (reg_overlap_mentioned_p (operands[0], operands[3]))
!     {
!       rtx tmp;
!       tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;
!       tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;
!     }
  })
  
  (define_expand "movsf"
--- 5157,5163 ----
    [(set (match_dup 0) (match_dup 2))
     (set (match_dup 1) (match_dup 3))]
  {
!   alpha_split_tmode_pair (operands, TFmode, true); 
  })
  
  (define_expand "movsf"
***************
*** 5649,5654 ****
--- 5643,5722 ----
      FAIL;
  })
  
+ ;; We need to prevent reload from splitting TImode moves, because it
+ ;; might decide to overwrite a pointer with the value it points to.
+ ;; In that case we have to do the loads in the appropriate order so
+ ;; that the pointer is not destroyed too early.
+ 
+ (define_insn_and_split "*movti_internal"
+   [(set (match_operand:TI 0 "nonimmediate_operand" "=r,o")
+         (match_operand:TI 1 "input_operand" "roJ,rJ"))]
+   "(register_operand (operands[0], TImode)
+     /* Prevent rematerialization of constants.  */
+     && ! CONSTANT_P (operands[1]))
+    || reg_or_0_operand (operands[1], TImode)"
+   "#"
+   "reload_completed"
+   [(set (match_dup 0) (match_dup 2))
+    (set (match_dup 1) (match_dup 3))]
+ {
+   alpha_split_tmode_pair (operands, TImode, true);
+ })
+ 
+ (define_expand "movti"
+   [(set (match_operand:TI 0 "nonimmediate_operand" "")
+         (match_operand:TI 1 "general_operand" ""))]
+   ""
+ {
+   if (GET_CODE (operands[0]) == MEM
+       && ! reg_or_0_operand (operands[1], TImode))
+     operands[1] = force_reg (TImode, operands[1]);
+ 
+   if (operands[1] == const0_rtx)
+     ;
+   /* We must put 64-bit constants in memory.  We could keep the
+      32-bit constants in TImode and rely on the splitter, but
+      this doesn't seem to be worth the pain.  */
+   else if (GET_CODE (operands[1]) == CONST_INT
+ 	   || GET_CODE (operands[1]) == CONST_DOUBLE)
+     {
+       rtx in[2], out[2], target;
+ 
+       gcc_assert (!no_new_pseudos);
+ 
+       split_double (operands[1], &in[0], &in[1]);
+ 
+       if (in[0] == const0_rtx)
+ 	out[0] = const0_rtx;
+       else
+ 	{
+ 	  out[0] = gen_reg_rtx (DImode);
+ 	  emit_insn (gen_movdi (out[0], in[0]));
+ 	}
+ 
+       if (in[1] == const0_rtx)
+ 	out[1] = const0_rtx;
+       else
+ 	{
+ 	  out[1] = gen_reg_rtx (DImode);
+ 	  emit_insn (gen_movdi (out[1], in[1]));
+ 	}
+ 
+       if (GET_CODE (operands[0]) != REG)
+ 	target = gen_reg_rtx (TImode);
+       else
+ 	target = operands[0];
+ 
+       emit_insn (gen_movdi (gen_rtx_SUBREG (DImode, target, 0), out[0]));
+       emit_insn (gen_movdi (gen_rtx_SUBREG (DImode, target, 8), out[1]));
+ 
+       if (target != operands[0])
+ 	emit_insn (gen_rtx_SET (VOIDmode, operands[0], target));
+ 
+       DONE;
+     }
+ })
+ 
  ;; These are the partial-word cases.
  ;;
  ;; First we have the code to load an aligned word.  Operand 0 is the register
*** gcc/config/alpha/alpha-protos.h.0	2006-03-12 16:54:42.349627272 +0100
--- gcc/config/alpha/alpha-protos.h	2006-03-12 16:54:51.486238296 +0100
*************** extern bool alpha_expand_mov_nobwx (enum
*** 64,70 ****
  extern void alpha_expand_movmisalign (enum machine_mode, rtx *);
  extern void alpha_emit_floatuns (rtx[]);
  extern rtx alpha_emit_conditional_move (rtx, enum machine_mode);
! extern void alpha_split_tfmode_pair (rtx[]);
  extern void alpha_split_tfmode_frobsign (rtx[], rtx (*)(rtx, rtx, rtx));
  extern void alpha_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,
  					 HOST_WIDE_INT, int);
--- 64,70 ----
  extern void alpha_expand_movmisalign (enum machine_mode, rtx *);
  extern void alpha_emit_floatuns (rtx[]);
  extern rtx alpha_emit_conditional_move (rtx, enum machine_mode);
! extern void alpha_split_tmode_pair (rtx[], enum machine_mode, bool);
  extern void alpha_split_tfmode_frobsign (rtx[], rtx (*)(rtx, rtx, rtx));
  extern void alpha_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,
  					 HOST_WIDE_INT, int);
*** gcc/common.opt.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/common.opt	2006-03-16 22:30:05.751386704 +0100
@@ -799,10 +823,12 @@
 Common Report Var(flag_variable_expansion_in_unroller) 
 Apply variable expansion when loops are unrolled
 
-; Emit code to probe the stack, to help detect stack overflow; also
-; may cause large objects to be allocated dynamically.
+fold-stack-check
+Common Report
+Insert old-style stack checking code into the program
+
 fstack-check
-Common Report Var(flag_stack_check)
+Common Report
 Insert stack checking code into the program
 
 fstack-limit
*** gcc/doc/invoke.texi.0	2006-03-16 21:49:12.643315816 +0100
--- gcc/doc/invoke.texi	2006-03-16 22:25:00.910729528 +0100
*************** See S/390 and zSeries Options.
*** 755,761 ****
  -fno-jump-tables @gol
  -freg-struct-return  -fshared-data  -fshort-enums @gol
  -fshort-double  -fshort-wchar @gol
! -fverbose-asm  -fpack-struct[=@var{n}]  -fstack-check @gol
  -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fleading-underscore @gol
--- 755,762 ----
  -fno-jump-tables @gol
  -freg-struct-return  -fshared-data  -fshort-enums @gol
  -fshort-double  -fshort-wchar @gol
! -fverbose-asm  -fpack-struct[=@var{n}] @gol
! -fstack-check  -fold-stack-check @gol
  -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fleading-underscore @gol
*************** a single-threaded environment since stac
*** 13087,13094 ****
  detected on nearly all systems if there is only one stack.
  
  Note that this switch does not actually cause checking to be done; the
! operating system must do that.  The switch causes generation of code
! to ensure that the operating system sees the stack being extended.
  
  @item -fstack-limit-register=@var{reg}
  @itemx -fstack-limit-symbol=@var{sym}
--- 13088,13120 ----
  detected on nearly all systems if there is only one stack.
  
  Note that this switch does not actually cause checking to be done; the
! operating system or the language runtime must do that.  The switch causes
! generation of code to ensure that they see the stack being extended.
! 
! @item -fold-stack-check
! @opindex fold-stack-check
! Same as above, but forces the use of old-style, pre-GCC4 stack checking.
! Old-style stack checking is a generic mechanism that requires no specific
! target support in the compiler but comes with the following drawbacks:
! 
! @enumerate
! @item
! Modified allocation strategy for large objects: they will always be
! allocated dynamically if their size exceeds a fixed threshold.
! 
! @item
! Fixed limit on the size of the static frame of functions: when it is
! topped by a particular function, stack checking is not reliable and
! a warning is issued by the compiler.
! 
! @item
! Inefficiency: because of both the modified allocation strategy and the
! generic implementation, the performances of the code are hampered.
! @end enumerate
! 
! Note that old-style stack checking is also the fallback method for
! @option{-fstack-check} if no specific target support has been added
! in the compiler.
  
  @item -fstack-limit-register=@var{reg}
  @itemx -fstack-limit-symbol=@var{sym}
*** gcc/expr.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/expr.h	2006-03-16 18:03:59.000000000 +0100
*************** do {							\
*** 202,214 ****
  
  /* Provide default values for the macros controlling stack checking.  */
  
  #ifndef STACK_CHECK_BUILTIN
  #define STACK_CHECK_BUILTIN 0
  #endif
  
! /* The default interval is one page.  */
! #ifndef STACK_CHECK_PROBE_INTERVAL
! #define STACK_CHECK_PROBE_INTERVAL 4096
  #endif
  
  /* The default is to do a store into the stack.  */
--- 202,220 ----
  
  /* Provide default values for the macros controlling stack checking.  */
  
+ /* The default is neither full builtin stack checking...  */
  #ifndef STACK_CHECK_BUILTIN
  #define STACK_CHECK_BUILTIN 0
  #endif
  
! /* ...nor static builtin stack checking.  */
! #ifndef STACK_CHECK_STATIC_BUILTIN
! #define STACK_CHECK_STATIC_BUILTIN 0
! #endif
! 
! /* The default interval is one page (4096 bytes).  */
! #ifndef STACK_CHECK_PROBE_INTERVAL_EXP
! #define STACK_CHECK_PROBE_INTERVAL_EXP 12
  #endif
  
  /* The default is to do a store into the stack.  */
*************** do {							\
*** 216,231 ****
  #define STACK_CHECK_PROBE_LOAD 0
  #endif
  
! /* This value is arbitrary, but should be sufficient for most machines.  */
  #ifndef STACK_CHECK_PROTECT
! #define STACK_CHECK_PROTECT (75 * UNITS_PER_WORD)
  #endif
  
  /* Make the maximum frame size be the largest we can and still only need
     one probe per function.  */
  #ifndef STACK_CHECK_MAX_FRAME_SIZE
  #define STACK_CHECK_MAX_FRAME_SIZE \
!   (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)
  #endif
  
  /* This is arbitrary, but should be large enough everywhere.  */
--- 222,252 ----
  #define STACK_CHECK_PROBE_LOAD 0
  #endif
  
! /* This is a kludge to try to capture the discrepancy between the old
!    mechanism (generic stack checking) and the new mechanism (static
!    builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped
!    for the latter because part of the protection area is effectively
!    included in STACK_CHECK_MAX_FRAME_SIZE for the former.  */
! #ifdef STACK_CHECK_PROTECT
! #define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT
! #else
! #define STACK_OLD_CHECK_PROTECT \
!  (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 8 * 1024)
! #endif
! 
! /* Minimum amount of stack required to recover from an anticipated stack
!    overflow detection.  The default value conveys an estimate of the amount
!    of stack required to propagate an exception.  */
  #ifndef STACK_CHECK_PROTECT
! #define STACK_CHECK_PROTECT \
!  (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 12 * 1024)
  #endif
  
  /* Make the maximum frame size be the largest we can and still only need
     one probe per function.  */
  #ifndef STACK_CHECK_MAX_FRAME_SIZE
  #define STACK_CHECK_MAX_FRAME_SIZE \
!   ((1 << STACK_CHECK_PROBE_INTERVAL_EXP) - UNITS_PER_WORD)
  #endif
  
  /* This is arbitrary, but should be large enough everywhere.  */
*** gcc/system.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/system.h	2006-03-16 18:03:59.000000000 +0100
*************** extern void fancy_abort (const char *, i
*** 728,734 ****
          TARGET_ESC TARGET_FF TARGET_NEWLINE TARGET_TAB TARGET_VT	   \
          LINK_LIBGCC_SPECIAL DONT_ACCESS_GBLS_AFTER_EPILOGUE		   \
  	TARGET_OPTIONS TARGET_SWITCHES EXTRA_CC_MODES FINALIZE_PIC	   \
! 	PREDICATE_CODES SPECIAL_MODE_PREDICATES HOST_PTR_PRINTF
  
  /* Hooks that are no longer used.  */
   #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE	\
--- 728,735 ----
          TARGET_ESC TARGET_FF TARGET_NEWLINE TARGET_TAB TARGET_VT	   \
          LINK_LIBGCC_SPECIAL DONT_ACCESS_GBLS_AFTER_EPILOGUE		   \
  	TARGET_OPTIONS TARGET_SWITCHES EXTRA_CC_MODES FINALIZE_PIC	   \
! 	PREDICATE_CODES SPECIAL_MODE_PREDICATES HOST_PTR_PRINTF		   \
! 	STACK_CHECK_PROBE_INTERVAL
  
  /* Hooks that are no longer used.  */
   #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE	\
*** gcc/doc/tm.texi.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/doc/tm.texi	2006-03-16 22:39:33.940008904 +0100
*************** linkage is necessary.  The default is @c
*** 3105,3149 ****
  @node Stack Checking
  @subsection Specifying How Stack Checking is Done
  
! GCC will check that stack references are within the boundaries of
! the stack, if the @option{-fstack-check} is specified, in one of three ways:
  
  @enumerate
  @item
  If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC
! will assume that you have arranged for stack checking to be done at
! appropriate places in the configuration files, e.g., in
! @code{TARGET_ASM_FUNCTION_PROLOGUE}.  GCC will do not other special
! processing.
  
  @item
! If @code{STACK_CHECK_BUILTIN} is zero and you defined a named pattern
! called @code{check_stack} in your @file{md} file, GCC will call that
! pattern with one argument which is the address to compare the stack
! value against.  You must arrange for this pattern to report an error if
! the stack pointer is out of range.
  
  @item
  If neither of the above are true, GCC will generate code to periodically
  ``probe'' the stack pointer using the values of the macros defined below.
  @end enumerate
  
! Normally, you will use the default values of these macros, so GCC
! will use the third approach.
  
  @defmac STACK_CHECK_BUILTIN
  A nonzero value if stack checking is done by the configuration files in a
  machine-dependent manner.  You should define this macro if stack checking
! is require by the ABI of your machine or if you would like to have to stack
! checking in some more efficient way than GCC's portable approach.
! The default value of this macro is zero.
! @end defmac
! 
! @defmac STACK_CHECK_PROBE_INTERVAL
! An integer representing the interval at which GCC must generate stack
! probe instructions.  You will normally define this macro to be no larger
! than the size of the ``guard pages'' at the end of a stack area.  The
! default value of 4096 is suitable for most systems.
  @end defmac
  
  @defmac STACK_CHECK_PROBE_LOAD
--- 3105,3161 ----
  @node Stack Checking
  @subsection Specifying How Stack Checking is Done
  
! GCC will check that stack references are within the boundaries of the
! stack, if the option @option{-fstack-check} is specified, in one of
! three ways:
  
  @enumerate
  @item
  If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC
! will assume that you have arranged for full stack checking to be done
! at appropriate places in the configuration files.  GCC will not do
! other special processing.
  
  @item
! If @code{STACK_CHECK_BUILTIN} is zero and the value of the
! @code{STACK_CHECK_STATIC_BUILTIN} macro is nonzero, GCC will assume
! that you have arranged for static stack checking (checking of the
! static stack frame of functions) to be done at appropriate places
! in the configuration files.  GCC will only emit code to do dynamic
! stack checking (checking on dynamic stack allocations) using the third
! approach below.
  
  @item
  If neither of the above are true, GCC will generate code to periodically
  ``probe'' the stack pointer using the values of the macros defined below.
  @end enumerate
  
! If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,
! GCC will change its allocation strategy for large objects if the option
! @option{-fstack-check} is specified: they will always be allocated
! dynamically if their size exceeds @code{STACK_CHECK_MAX_VAR_SIZE} bytes.
  
  @defmac STACK_CHECK_BUILTIN
  A nonzero value if stack checking is done by the configuration files in a
  machine-dependent manner.  You should define this macro if stack checking
! is require by the ABI of your machine or if you would like to do stack
! checking in some more efficient way than the generic approach.  The default
! value of this macro is zero.
! @end defmac
! 
! @defmac STACK_CHECK_STATIC_BUILTIN
! A nonzero value if static stack checking is done by the configuration files
! in a machine-dependent manner.  You should define this macro if you would
! like to do static stack checking in some more efficient way than the generic
! approach.  The default value of this macro is zero.
! @end defmac
! 
! @defmac STACK_CHECK_PROBE_INTERVAL_EXP
! An integer specifying the interval at which GCC must generate stack probe
! instructions, defined as 2 raised to this integer.  You will normally
! define this macro so that the interval be no larger than the size of
! the ``guard pages'' at the end of a stack area.  The default value
! of 12 (4096-byte interval) is suitable for most systems.
  @end defmac
  
  @defmac STACK_CHECK_PROBE_LOAD
*************** for languages where such a recovery is s
*** 3158,3163 ****
--- 3170,3179 ----
  75 words should be adequate for most machines.
  @end defmac
  
+ The following macros are relevant only if neither STACK_CHECK_BUILTIN
+ nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether
+ in the opposite case.
+ 
  @defmac STACK_CHECK_MAX_FRAME_SIZE
  The maximum size of a stack frame, in bytes.  GCC will generate probe
  instructions in non-leaf functions to ensure at least this many bytes of
*** gcc/opts.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/opts.c	2006-03-16 22:30:20.483147136 +0100
*************** Software Foundation, 51 Franklin Street,
*** 26,31 ****
--- 26,32 ----
  #include "tm.h"
  #include "tree.h"
  #include "rtl.h"
+ #include "expr.h"
  #include "ggc.h"
  #include "output.h"
  #include "langhooks.h"
*************** common_handle_option (size_t scode, cons
*** 970,975 ****
--- 971,996 ----
        flag_sched_stalled_insns_dep = value;
        break;
  
+     case OPT_fstack_check:
+       if (value)
+ 	flag_stack_check = STACK_CHECK_BUILTIN
+ 			   ? FULL_BUILTIN_STACK_CHECK
+ 			   : STACK_CHECK_STATIC_BUILTIN
+ 			     ? STATIC_BUILTIN_STACK_CHECK
+ 			     : GENERIC_STACK_CHECK;
+       else
+ 	flag_stack_check = NO_STACK_CHECK;
+       break;
+ 
+     case OPT_fold_stack_check:
+       if (value)
+ 	flag_stack_check = STACK_CHECK_BUILTIN
+ 			   ? FULL_BUILTIN_STACK_CHECK
+ 			   : GENERIC_STACK_CHECK;
+       else
+ 	flag_stack_check = NO_STACK_CHECK;
+       break;
+ 
      case OPT_fstack_limit:
        /* The real switch is -fno-stack-limit.  */
        if (value)
*** gcc/calls.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/calls.c	2006-03-16 21:21:21.917304776 +0100
*************** initialize_argument_information (int num
*** 1025,1034 ****
  	      rtx copy;
  
  	      if (!COMPLETE_TYPE_P (type)
! 		  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST
! 		  || (flag_stack_check && ! STACK_CHECK_BUILTIN
! 		      && (0 < compare_tree_int (TYPE_SIZE_UNIT (type),
! 						STACK_CHECK_MAX_VAR_SIZE))))
  		{
  		  /* This is a variable-sized object.  Make space on the stack
  		     for it.  */
--- 1025,1034 ----
  	      rtx copy;
  
  	      if (!COMPLETE_TYPE_P (type)
! 		  || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST
! 		  || (flag_stack_check == GENERIC_STACK_CHECK
! 		      && compare_tree_int (TYPE_SIZE_UNIT (type),
! 					   STACK_CHECK_MAX_VAR_SIZE) > 0))
  		{
  		  /* This is a variable-sized object.  Make space on the stack
  		     for it.  */
*************** emit_library_call_value_1 (int retval, r
*** 3336,3341 ****
--- 3336,3344 ----
      case LCT_THROW:
        flags = ECF_NORETURN;
        break;
+     case LCT_MAY_THROW:
+       flags &= ~ECF_NOTHROW;
+       break;
      case LCT_RETURNS_TWICE:
        flags = ECF_RETURNS_TWICE;
        break;
*** gcc/function.c.0	2006-03-12 17:02:48.000000000 +0100
--- gcc/function.c	2006-03-19 14:55:04.000000000 +0100
*************** gimplify_parameters (void)
*** 3176,3182 ****
        walk_tree_without_duplicates (&data.passed_type,
  				    gimplify_parm_type, &stmts);
  
!       if (!TREE_CONSTANT (DECL_SIZE (parm)))
  	{
  	  gimplify_one_sizepos (&DECL_SIZE (parm), &stmts);
  	  gimplify_one_sizepos (&DECL_SIZE_UNIT (parm), &stmts);
--- 3185,3191 ----
        walk_tree_without_duplicates (&data.passed_type,
  				    gimplify_parm_type, &stmts);
  
!       if (TREE_CODE (DECL_SIZE_UNIT (parm)) != INTEGER_CST)
  	{
  	  gimplify_one_sizepos (&DECL_SIZE (parm), &stmts);
  	  gimplify_one_sizepos (&DECL_SIZE_UNIT (parm), &stmts);
*************** gimplify_parameters (void)
*** 3190,3198 ****
  	    {
  	      tree local, t;
  
! 	      /* For constant sized objects, this is trivial; for
  		 variable-sized objects, we have to play games.  */
! 	      if (TREE_CONSTANT (DECL_SIZE (parm)))
  		{
  		  local = create_tmp_var (type, get_name (parm));
  		  DECL_IGNORED_P (local) = 0;
--- 3199,3210 ----
  	    {
  	      tree local, t;
  
! 	      /* For constant-sized objects, this is trivial; for
  		 variable-sized objects, we have to play games.  */
! 	      if (TREE_CODE (DECL_SIZE_UNIT (parm)) == INTEGER_CST
! 		  && !(flag_stack_check == GENERIC_STACK_CHECK
! 		       && compare_tree_int (DECL_SIZE_UNIT (parm),
! 					    STACK_CHECK_MAX_VAR_SIZE) > 0))
  		{
  		  local = create_tmp_var (type, get_name (parm));
  		  DECL_IGNORED_P (local) = 0;
*************** expand_function_end (void)
*** 4344,4353 ****
    if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)
      get_arg_pointer_save_area (cfun);
  
!   /* If we are doing stack checking and this function makes calls,
       do a stack probe at the start of the function to ensure we have enough
       space for another stack frame.  */
!   if (flag_stack_check && ! STACK_CHECK_BUILTIN)
      {
        rtx insn, seq;
  
--- 4356,4365 ----
    if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)
      get_arg_pointer_save_area (cfun);
  
!   /* If we are doing generic stack checking and this function makes calls,
       do a stack probe at the start of the function to ensure we have enough
       space for another stack frame.  */
!   if (flag_stack_check == GENERIC_STACK_CHECK)
      {
        rtx insn, seq;
  
*************** expand_function_end (void)
*** 4355,4361 ****
  	if (CALL_P (insn))
  	  {
  	    start_sequence ();
! 	    probe_stack_range (STACK_CHECK_PROTECT,
  			       GEN_INT (STACK_CHECK_MAX_FRAME_SIZE));
  	    seq = get_insns ();
  	    end_sequence ();
--- 4367,4373 ----
  	if (CALL_P (insn))
  	  {
  	    start_sequence ();
! 	    probe_stack_range (STACK_OLD_CHECK_PROTECT,
  			       GEN_INT (STACK_CHECK_MAX_FRAME_SIZE));
  	    seq = get_insns ();
  	    end_sequence ();
*** gcc/reload1.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/reload1.c	2006-03-16 21:21:52.689626672 +0100
*************** reload (rtx first, int global)
*** 1222,1230 ****
  	cleanup_subreg_operands (insn);
        }
  
!   /* If we are doing stack checking, give a warning if this function's
!      frame size is larger than we expect.  */
!   if (flag_stack_check && ! STACK_CHECK_BUILTIN)
      {
        HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;
        static int verbose_warned = 0;
--- 1222,1230 ----
  	cleanup_subreg_operands (insn);
        }
  
!   /* If we are doing generic stack checking, give a warning if this
!      function's frame size is larger than we expect.  */
!   if (flag_stack_check == GENERIC_STACK_CHECK)
      {
        HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;
        static int verbose_warned = 0;
*** gcc/stmt.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/stmt.c	2006-03-16 18:03:59.000000000 +0100
*************** expand_decl (tree decl)
*** 1873,1880 ****
      SET_DECL_RTL (decl, gen_rtx_MEM (BLKmode, const0_rtx));
  
    else if (DECL_SIZE (decl) == 0)
-     /* Variable with incomplete type.  */
      {
        rtx x;
        if (DECL_INITIAL (decl) == 0)
  	/* Error message was already done; now avoid a crash.  */
--- 1873,1880 ----
      SET_DECL_RTL (decl, gen_rtx_MEM (BLKmode, const0_rtx));
  
    else if (DECL_SIZE (decl) == 0)
      {
+       /* Variable with incomplete type.  */
        rtx x;
        if (DECL_INITIAL (decl) == 0)
  	/* Error message was already done; now avoid a crash.  */
*************** expand_decl (tree decl)
*** 1913,1928 ****
  	}
      }
  
!   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST
! 	   && ! (flag_stack_check && ! STACK_CHECK_BUILTIN
! 		 && 0 < compare_tree_int (DECL_SIZE_UNIT (decl),
! 					  STACK_CHECK_MAX_VAR_SIZE)))
      {
-       /* Variable of fixed size that goes on the stack.  */
        rtx oldaddr = 0;
        rtx addr;
        rtx x;
  
        /* If we previously made RTL for this decl, it must be an array
  	 whose size was determined by the initializer.
  	 The old address was a register; set that register now
--- 1913,1927 ----
  	}
      }
  
!   else
      {
        rtx oldaddr = 0;
        rtx addr;
        rtx x;
  
+       /* Variable-sized decls should have been handled in the gimplifier.  */
+       gcc_assert (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST);
+ 
        /* If we previously made RTL for this decl, it must be an array
  	 whose size was determined by the initializer.
  	 The old address was a register; set that register now
*************** expand_decl (tree decl)
*** 1950,1990 ****
  	    emit_move_insn (oldaddr, addr);
  	}
      }
-   else
-     /* Dynamic-size object: must push space on the stack.  */
-     {
-       rtx address, size, x;
- 
-       /* Record the stack pointer on entry to block, if have
- 	 not already done so.  */
-       do_pending_stack_adjust ();
- 
-       /* Compute the variable's size, in bytes.  This will expand any
- 	 needed SAVE_EXPRs for the first time.  */
-       size = expand_expr (DECL_SIZE_UNIT (decl), NULL_RTX, VOIDmode, 0);
-       free_temp_slots ();
- 
-       /* Allocate space on the stack for the variable.  Note that
- 	 DECL_ALIGN says how the variable is to be aligned and we
- 	 cannot use it to conclude anything about the alignment of
- 	 the size.  */
-       address = allocate_dynamic_stack_space (size, NULL_RTX,
- 					      TYPE_ALIGN (TREE_TYPE (decl)));
- 
-       /* Reference the variable indirect through that rtx.  */
-       x = gen_rtx_MEM (DECL_MODE (decl), address);
-       set_mem_attributes (x, decl, 1);
-       SET_DECL_RTL (decl, x);
- 
- 
-       /* Indicate the alignment we actually gave this variable.  */
- #ifdef STACK_BOUNDARY
-       DECL_ALIGN (decl) = STACK_BOUNDARY;
- #else
-       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;
- #endif
-       DECL_USER_ALIGN (decl) = 0;
-     }
  }
  
  /* Emit code to save the current value of stack.  */
--- 1949,1954 ----
*** gcc/gimplify.c.0	2006-11-16 23:02:47.000000000 +0100
--- gcc/gimplify.c	2006-11-17 00:17:39.000000000 +0100
*************** gimplify_decl_expr (tree *stmt_p)
*** 1067,1073 ****
      {
        tree init = DECL_INITIAL (decl);
  
!       if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)
  	{
  	  /* This is a variable-sized decl.  Simplify its size and mark it
  	     for deferred expansion.  Note that mudflap depends on the format
--- 1136,1146 ----
      {
        tree init = DECL_INITIAL (decl);
  
!       if (TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST
! 	  || (!TREE_STATIC (decl)
! 	      && flag_stack_check == GENERIC_STACK_CHECK
! 	      && compare_tree_int (DECL_SIZE_UNIT (decl),
! 				   STACK_CHECK_MAX_VAR_SIZE) > 0))
  	{
  	  /* This is a variable-sized decl.  Simplify its size and mark it
  	     for deferred expansion.  Note that mudflap depends on the format
*** gcc/explow.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/explow.c	2006-03-16 21:21:28.682276344 +0100
*************** Software Foundation, 51 Franklin Street,
*** 29,34 ****
--- 29,35 ----
  #include "tree.h"
  #include "tm_p.h"
  #include "flags.h"
+ #include "except.h"
  #include "function.h"
  #include "expr.h"
  #include "optabs.h"
*************** allocate_dynamic_stack_space (rtx size, 
*** 1148,1155 ****
  
    /* If needed, check that we have the required amount of stack.  Take into
       account what has already been checked.  */
!   if (flag_stack_check && ! STACK_CHECK_BUILTIN)
!     probe_stack_range (STACK_CHECK_MAX_FRAME_SIZE + STACK_CHECK_PROTECT, size);
  
    /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */
    if (target == 0 || !REG_P (target)
--- 1149,1159 ----
  
    /* If needed, check that we have the required amount of stack.  Take into
       account what has already been checked.  */
!   if (flag_stack_check == GENERIC_STACK_CHECK)
!     probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,
! 		       size);
!   else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
!     probe_stack_range (STACK_CHECK_PROTECT, size);
  
    /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */
    if (target == 0 || !REG_P (target)
*************** allocate_dynamic_stack_space (rtx size, 
*** 1245,1260 ****
  }
  
  /* A front end may want to override GCC's stack checking by providing a
!    run-time routine to call to check the stack, so provide a mechanism for
!    calling that routine.  */
  
! static GTY(()) rtx stack_check_libfunc;
! 
! void
! set_stack_check_libfunc (rtx libfunc)
! {
!   stack_check_libfunc = libfunc;
! }
  
  /* Emit one stack probe at ADDRESS, an address within the stack.  */
  
--- 1249,1257 ----
  }
  
  /* A front end may want to override GCC's stack checking by providing a
!    run-time routine to call to check the stack.  */
  
! rtx stack_check_libfunc;
  
  /* Emit one stack probe at ADDRESS, an address within the stack.  */
  
*************** emit_stack_probe (rtx address)
*** 1277,1298 ****
     subtract from the stack.  If SIZE is constant, this is done
     with a fixed number of probes.  Otherwise, we must make a loop.  */
  
  #ifdef STACK_GROWS_DOWNWARD
! #define STACK_GROW_OP MINUS
  #else
! #define STACK_GROW_OP PLUS
  #endif
  
  void
  probe_stack_range (HOST_WIDE_INT first, rtx size)
  {
    /* First ensure SIZE is Pmode.  */
    if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
      size = convert_to_mode (Pmode, size, 1);
  
!   /* Next see if the front end has set up a function for us to call to
!      check the stack.  */
!   if (stack_check_libfunc != 0)
      {
        rtx addr = memory_address (QImode,
  				 gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
--- 1274,1304 ----
     subtract from the stack.  If SIZE is constant, this is done
     with a fixed number of probes.  Otherwise, we must make a loop.  */
  
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
  #ifdef STACK_GROWS_DOWNWARD
! #define STACK_GROW_OP     MINUS
! #define STACK_GROW_OPTAB  sub_optab
  #else
! #define STACK_GROW_OP     PLUS
! #define STACK_GROW_OPTAB  add_optab
  #endif
  
  void
  probe_stack_range (HOST_WIDE_INT first, rtx size)
  {
+ #ifdef SPARC_STACK_BIAS
+   /* The probe offsets are counted negatively whereas the stack bias is
+      counted positively.  */
+   first -= SPARC_STACK_BIAS;
+ #endif
+ 
    /* First ensure SIZE is Pmode.  */
    if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
      size = convert_to_mode (Pmode, size, 1);
  
!   /* Next see if the runtime has got a function for us to call.  */
!   if (stack_check_libfunc)
      {
        rtx addr = memory_address (QImode,
  				 gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1300,1399 ****
  					         plus_constant (size, first)));
  
        addr = convert_memory_address (ptr_mode, addr);
!       emit_library_call (stack_check_libfunc, LCT_NORMAL, VOIDmode, 1, addr,
  			 ptr_mode);
      }
  
!   /* Next see if we have an insn to check the stack.  Use it if so.  */
! #ifdef HAVE_check_stack
!   else if (HAVE_check_stack)
!     {
!       insn_operand_predicate_fn pred;
!       rtx last_addr
! 	= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 stack_pointer_rtx,
! 					 plus_constant (size, first)),
! 			 NULL_RTX);
! 
!       pred = insn_data[(int) CODE_FOR_check_stack].operand[0].predicate;
!       if (pred && ! ((*pred) (last_addr, Pmode)))
! 	last_addr = copy_to_mode_reg (Pmode, last_addr);
! 
!       emit_insn (gen_check_stack (last_addr));
!     }
! #endif
! 
!   /* If we have to generate explicit probes, see if we have a constant
!      small number of them to generate.  If so, that's the easy case.  */
!   else if (GET_CODE (size) == CONST_INT
! 	   && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)
!     {
!       HOST_WIDE_INT offset;
! 
!       /* Start probing at FIRST + N * STACK_CHECK_PROBE_INTERVAL
! 	 for values of N from 1 until it exceeds LAST.  If only one
! 	 probe is needed, this will not generate any code.  Then probe
! 	 at LAST.  */
!       for (offset = first + STACK_CHECK_PROBE_INTERVAL;
! 	   offset < INTVAL (size);
! 	   offset = offset + STACK_CHECK_PROBE_INTERVAL)
  	emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
  					  stack_pointer_rtx,
! 					  GEN_INT (offset)));
  
        emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
  					stack_pointer_rtx,
  					plus_constant (size, first)));
      }
  
!   /* In the variable case, do the same as above, but in a loop.  We emit loop
!      notes so that loop optimization can be done.  */
    else
      {
!       rtx test_addr
! 	= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 stack_pointer_rtx,
! 					 GEN_INT (first + STACK_CHECK_PROBE_INTERVAL)),
! 			 NULL_RTX);
!       rtx last_addr
! 	= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 stack_pointer_rtx,
! 					 plus_constant (size, first)),
! 			 NULL_RTX);
!       rtx incr = GEN_INT (STACK_CHECK_PROBE_INTERVAL);
        rtx loop_lab = gen_label_rtx ();
-       rtx test_lab = gen_label_rtx ();
        rtx end_lab = gen_label_rtx ();
-       rtx temp;
  
!       if (!REG_P (test_addr)
! 	  || REGNO (test_addr) < FIRST_PSEUDO_REGISTER)
! 	test_addr = force_reg (Pmode, test_addr);
  
!       emit_jump (test_lab);
  
        emit_label (loop_lab);
-       emit_stack_probe (test_addr);
  
! #ifdef STACK_GROWS_DOWNWARD
! #define CMP_OPCODE GTU
!       temp = expand_binop (Pmode, sub_optab, test_addr, incr, test_addr,
! 			   1, OPTAB_WIDEN);
! #else
! #define CMP_OPCODE LTU
!       temp = expand_binop (Pmode, add_optab, test_addr, incr, test_addr,
  			   1, OPTAB_WIDEN);
- #endif
  
        gcc_assert (temp == test_addr);
  
!       emit_label (test_lab);
!       emit_cmp_and_jump_insns (test_addr, last_addr, CMP_OPCODE,
! 			       NULL_RTX, Pmode, 1, loop_lab);
!       emit_jump (end_lab);
        emit_label (end_lab);
  
!       emit_stack_probe (last_addr);
      }
  }
  
--- 1306,1414 ----
  					         plus_constant (size, first)));
  
        addr = convert_memory_address (ptr_mode, addr);
!       emit_library_call (stack_check_libfunc, LCT_MAY_THROW, VOIDmode, 1, addr,
  			 ptr_mode);
      }
  
!   /* Otherwise we have to generate explicit probes.  If we have a constant
!      small number of them to generate, that's the easy case.  */
!   else if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
!     {
!       HOST_WIDE_INT i;
! 
!       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
! 	 it exceeds SIZE.  If only one probe is needed, this will not
! 	 generate any code.  Then probe at SIZE.  */
!       for (i = PROBE_INTERVAL; i < INTVAL (size); i += PROBE_INTERVAL)
  	emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
  					  stack_pointer_rtx,
! 					  GEN_INT (i + first)));
  
        emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
  					stack_pointer_rtx,
  					plus_constant (size, first)));
      }
  
!   /* In the variable case, do the same as above, but in a loop.  Note that we
!      must be extra careful with variables wrapping around because we might be
!      at the very top (or the very bottom) of the address space and we have to
!      be able to handle this case properly; in particular, we use an equality
!      test for the loop condition.  */
    else
      {
!       rtx rounded_size, rounded_size_op, test_addr, last_addr, temp;
        rtx loop_lab = gen_label_rtx ();
        rtx end_lab = gen_label_rtx ();
  
!       /* Step 1: round SIZE to the previous multiple of the interval.  */
! 
!       /* ROUNDED_SIZE = SIZE & -PROBE_INTERVAL  */
!       rounded_size = simplify_gen_binary (AND, Pmode,
! 					  size,
! 					  GEN_INT (-PROBE_INTERVAL));
!       rounded_size_op = force_operand (rounded_size, NULL_RTX);
! 
! 
!       /* Step 2: compute initial and final value of the loop counter.  */
! 
!       /* TEST_ADDR = SP + FIRST.  */
!       test_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					 	 stack_pointer_rtx,
! 					 	 GEN_INT (first)),
! 				 NULL_RTX);
! 
!       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
!       last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 						 test_addr,
! 						 rounded_size_op),
! 				 NULL_RTX);
  
! 
!       /* Step 3: the loop
! 
! 	  while (TEST_ADDR != LAST_ADDR)
! 	    {
! 	      TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
! 	      probe at TEST_ADDR
! 	    }
! 
! 	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
! 	 until it exceeds ROUNDED_SIZE.  */
  
        emit_label (loop_lab);
  
!       /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
!       emit_cmp_and_jump_insns (test_addr, last_addr, EQ,
! 			       NULL_RTX, Pmode, 1, end_lab);
! 
!       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
!       temp = expand_binop (Pmode, STACK_GROW_OPTAB, test_addr,
! 			   GEN_INT (PROBE_INTERVAL), test_addr,
  			   1, OPTAB_WIDEN);
  
        gcc_assert (temp == test_addr);
  
!       /* Probe at TEST_ADDR.  */
!       emit_stack_probe (test_addr);
! 
!       emit_jump (loop_lab);
! 
        emit_label (end_lab);
  
!       /* Step 4: probe at SIZE if we cannot assert at compile-time that
! 	 it is equal to ROUNDED_SIZE.  */
! 
!       /* TEMP = SIZE - ROUNDED_SIZE.  */
!       temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);
!       if (temp != const0_rtx)
! 	{
! 	  /* Manual CSE if the difference is not known at compile-time.  */
! 	  if (GET_CODE (temp) != CONST_INT)
! 	    temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);
! 	  emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					    last_addr,
! 					    temp));
! 	}
      }
  }
  
*************** rtx_to_tree_code (enum rtx_code code)
*** 1486,1490 ****
      }
    return ((int) tcode);
  }
- 
- #include "gt-explow.h"
--- 1501,1503 ----
*** gcc/Makefile.in.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/Makefile.in	2006-03-16 18:03:59.000000000 +0100
*************** expmed.o : expmed.c $(CONFIG_H) $(SYSTEM
*** 2119,2125 ****
     toplev.h $(TM_P_H) langhooks.h
  explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
!    toplev.h function.h $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h target.h
  optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \
     $(RECOG_H) reload.h toplev.h $(GGC_H) real.h $(TM_P_H) except.h \
--- 2119,2125 ----
     toplev.h $(TM_P_H) langhooks.h
  explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
!    toplev.h function.h $(GGC_H) $(TM_P_H) langhooks.h target.h
  optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \
     $(RECOG_H) reload.h toplev.h $(GGC_H) real.h $(TM_P_H) except.h \
*************** GTFILES_SRCDIR = @srcdir@
*** 2777,2783 ****
  
  gt-cgraph.h gt-coverage.h gtype-desc.h gtype-desc.c gt-except.h \
  gt-function.h gt-integrate.h gt-tree.h gt-varasm.h \
! gt-emit-rtl.h gt-explow.h gt-stor-layout.h gt-regclass.h \
  gt-lists.h gt-alias.h gt-cselib.h gt-gcse.h \
  gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \
  gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \
--- 2777,2783 ----
  
  gt-cgraph.h gt-coverage.h gtype-desc.h gtype-desc.c gt-except.h \
  gt-function.h gt-integrate.h gt-tree.h gt-varasm.h \
! gt-emit-rtl.h gt-stor-layout.h gt-regclass.h \
  gt-lists.h gt-alias.h gt-cselib.h gt-gcse.h \
  gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \
  gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \
*** gcc/rtl.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/rtl.h	2006-03-16 18:03:59.000000000 +0100
*************** extern int ceil_log2 (unsigned HOST_WIDE
*** 1337,1343 ****
  extern rtx expand_builtin_expect_jump (tree, rtx, rtx);
  
  /* In explow.c */
! extern void set_stack_check_libfunc (rtx);
  extern HOST_WIDE_INT trunc_int_for_mode	(HOST_WIDE_INT, enum machine_mode);
  extern rtx plus_constant (rtx, HOST_WIDE_INT);
  
--- 1337,1343 ----
  extern rtx expand_builtin_expect_jump (tree, rtx, rtx);
  
  /* In explow.c */
! extern GTY(()) rtx stack_check_libfunc;
  extern HOST_WIDE_INT trunc_int_for_mode	(HOST_WIDE_INT, enum machine_mode);
  extern rtx plus_constant (rtx, HOST_WIDE_INT);
  
*************** enum libcall_type
*** 2105,2111 ****
    LCT_PURE_MAKE_BLOCK = 4,
    LCT_NORETURN = 5,
    LCT_THROW = 6,
!   LCT_RETURNS_TWICE = 7
  };
  
  extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,
--- 2105,2112 ----
    LCT_PURE_MAKE_BLOCK = 4,
    LCT_NORETURN = 5,
    LCT_THROW = 6,
!   LCT_MAY_THROW = 7,
!   LCT_RETURNS_TWICE = 8
  };
  
  extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,
*** gcc/flags.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/flags.h	2006-03-16 21:44:09.117458760 +0100
*************** extern int flag_var_tracking;
*** 250,255 ****
--- 250,276 ----
     warning message in case flag was set by -fprofile-{generate,use}.  */
  extern bool flag_speculative_prefetching_set;
  
+ /* Type of stack check.  */
+ enum stack_check_type
+ {
+   /* Do not check the stack.  */
+   NO_STACK_CHECK = 0,
+ 
+   /* Check the stack generically, i.e. assume no specific support
+      from the target configuration files.  */
+   GENERIC_STACK_CHECK,
+ 
+   /* Check the stack and rely on the target configuration files to
+      check the static frame of functions, i.e. use the generic
+      mechanism only for dynamic stack allocations.  */
+   STATIC_BUILTIN_STACK_CHECK,
+ 
+   /* Check the stack and entirely rely on the target configuration
+      files, i.e. do not use the generic mechanism at all.  */
+   FULL_BUILTIN_STACK_CHECK
+ };
+ extern enum stack_check_type flag_stack_check;
+ 
  /* A string that's used when a random name is required.  NULL means
     to make it really random.  */
  
*** gcc/toplev.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/toplev.c	2006-03-16 21:27:37.086270424 +0100
*************** int flag_renumber_insns = 1;
*** 339,344 ****
--- 339,347 ----
     to optimize, debug_info_level and debug_hooks in process_options ().  */
  int flag_var_tracking = AUTODETECT_VALUE;
  
+ /* Type of stack check.  */
+ enum stack_check_type flag_stack_check = NO_STACK_CHECK;
+ 
  /* True if the user has tagged the function with the 'section'
     attribute.  */
  
*** gcc/tree.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/tree.c	2006-03-16 22:33:47.797630544 +0100
*************** build_common_builtin_nodes (void)
*** 6423,6429 ****
        tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);
        ftype = build_function_type (ptr_type_node, tmp);
        local_define_builtin ("__builtin_alloca", ftype, BUILT_IN_ALLOCA,
! 			    "alloca", ECF_NOTHROW | ECF_MALLOC);
      }
  
    tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
--- 6423,6430 ----
        tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);
        ftype = build_function_type (ptr_type_node, tmp);
        local_define_builtin ("__builtin_alloca", ftype, BUILT_IN_ALLOCA,
! 			    "alloca",
! 			    ECF_MALLOC | (flag_stack_check ? 0 : ECF_NOTHROW));
      }
  
    tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
*** gcc/config/alpha/alpha.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/alpha/alpha.c	2006-03-16 18:03:59.000000000 +0100
*************** alpha_expand_prologue (void)
*** 7533,7538 ****
--- 7546,7554 ----
    HOST_WIDE_INT sa_size;
    /* Complete stack size needed.  */
    HOST_WIDE_INT frame_size;
+   /* Probed stack size; it additionally includes the size of
+      the "reserve region" if any.  */
+   HOST_WIDE_INT probed_size;
    /* Offset from base reg to register save area.  */
    HOST_WIDE_INT reg_offset;
    rtx sa_reg;
*************** alpha_expand_prologue (void)
*** 7592,7611 ****
  
       Note that we are only allowed to adjust sp once in the prologue.  */
  
!   if (frame_size <= 32768)
      {
!       if (frame_size > 4096)
  	{
  	  int probed;
  
! 	  for (probed = 4096; probed < frame_size; probed += 8192)
  	    emit_insn (gen_probe_stack (GEN_INT (TARGET_ABI_UNICOSMK
  						 ? -probed + 64
  						 : -probed)));
  
! 	  /* We only have to do this probe if we aren't saving registers.  */
! 	  if (sa_size == 0 && frame_size > probed - 4096)
! 	    emit_insn (gen_probe_stack (GEN_INT (-frame_size)));
  	}
  
        if (frame_size != 0)
--- 7608,7632 ----
  
       Note that we are only allowed to adjust sp once in the prologue.  */
  
!   probed_size = frame_size;
!   if (flag_stack_check)
!     probed_size += STACK_CHECK_PROTECT;
! 
!   if (probed_size <= 32768)
      {
!       if (probed_size > 4096)
  	{
  	  int probed;
  
! 	  for (probed = 4096; probed < probed_size; probed += 8192)
  	    emit_insn (gen_probe_stack (GEN_INT (TARGET_ABI_UNICOSMK
  						 ? -probed + 64
  						 : -probed)));
  
! 	  /* We only have to do this probe if we aren't saving registers or
! 	     if we are probing beyond the frame because of -fstack-check.  */
! 	  if ((probed_size > probed - 4096 && !sa_size) || flag_stack_check)
! 	    emit_insn (gen_probe_stack (GEN_INT (-probed_size)));
  	}
  
        if (frame_size != 0)
*************** alpha_expand_prologue (void)
*** 7620,7629 ****
  	 number of 8192 byte blocks to probe.  We then probe each block
  	 in the loop and then set SP to the proper location.  If the
  	 amount remaining is > 4096, we have to do one more probe if we
! 	 are not saving any registers.  */
  
!       HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;
!       HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;
        rtx ptr = gen_rtx_REG (DImode, 22);
        rtx count = gen_rtx_REG (DImode, 23);
        rtx seq;
--- 7641,7651 ----
  	 number of 8192 byte blocks to probe.  We then probe each block
  	 in the loop and then set SP to the proper location.  If the
  	 amount remaining is > 4096, we have to do one more probe if we
! 	 are not saving any registers or if we are probing beyond the
! 	 frame because of -fstack-check.  */
  
!       HOST_WIDE_INT blocks = (probed_size + 4096) / 8192;
!       HOST_WIDE_INT leftover = probed_size + 4096 - blocks * 8192;
        rtx ptr = gen_rtx_REG (DImode, 22);
        rtx count = gen_rtx_REG (DImode, 23);
        rtx seq;
*************** alpha_expand_prologue (void)
*** 7636,7655 ****
  	 late in the compilation, generate the loop as a single insn.  */
        emit_insn (gen_prologue_stack_probe_loop (count, ptr));
  
!       if (leftover > 4096 && sa_size == 0)
  	{
  	  rtx last = gen_rtx_MEM (DImode, plus_constant (ptr, -leftover));
  	  MEM_VOLATILE_P (last) = 1;
  	  emit_move_insn (last, const0_rtx);
  	}
  
!       if (TARGET_ABI_WINDOWS_NT)
  	{
  	  /* For NT stack unwind (done by 'reverse execution'), it's
  	     not OK to take the result of a loop, even though the value
  	     is already in ptr, so we reload it via a single operation
  	     and subtract it to sp.
  
  	     Yes, that's correct -- we have to reload the whole constant
  	     into a temporary via ldah+lda then subtract from sp.  */
  
--- 7658,7680 ----
  	 late in the compilation, generate the loop as a single insn.  */
        emit_insn (gen_prologue_stack_probe_loop (count, ptr));
  
!       if ((leftover > 4096 && !sa_size) || flag_stack_check)
  	{
  	  rtx last = gen_rtx_MEM (DImode, plus_constant (ptr, -leftover));
  	  MEM_VOLATILE_P (last) = 1;
  	  emit_move_insn (last, const0_rtx);
  	}
  
!       if (TARGET_ABI_WINDOWS_NT || flag_stack_check)
  	{
  	  /* For NT stack unwind (done by 'reverse execution'), it's
  	     not OK to take the result of a loop, even though the value
  	     is already in ptr, so we reload it via a single operation
  	     and subtract it to sp.
  
+ 	     Same if -fstack-check is specified, because the probed stack
+ 	     size is not equal to the frame size.
+ 
  	     Yes, that's correct -- we have to reload the whole constant
  	     into a temporary via ldah+lda then subtract from sp.  */
  
*** gcc/config/i386/i386.c.0	2007-03-01 21:14:27.255698736 +0100
--- gcc/config/i386/i386.c	2007-03-01 21:15:11.691943400 +0100
*************** const struct attribute_spec ix86_attribu
*** 1927,1932 ****
--- 1927,1948 ----
    { NULL,        0, 0, false, false, false, NULL }
  };
  
+ 
+ /* Decide whether we must probe the stack before any space allocation
+    on this target.  It's essentially TARGET_STACK_PROBE except when
+    -fstack-check causes the stack to be already probed differently.  */
+ 
+ bool
+ ix86_target_stack_probe (void)
+ {
+   /* Do not probe the stack twice if static builtin stack checking is
+      enabled and done with probes.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && !stack_check_libfunc)
+     return false;
+ 
+   return TARGET_STACK_PROBE != 0;
+ }
+ 
  /* Decide whether we can make a sibling call to a function.  DECL is the
     declaration of the function being targeted by the call and EXP is the
     CALL_EXPR representing the call.  */
*************** ix86_compute_frame_layout (struct ix86_f
*** 4770,4775 ****
--- 4786,5129 ----
  #endif
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ /* The run-time loop is made up of 8 insns in the generic case while this
+    compile-time loop is made up of n insns for n # of intervals.  */
+ #define SMALL_INTERVAL(size)  ((size) <= 8 * PROBE_INTERVAL)
+ 
+ static void
+ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   /* On the x86 we may have no scratch registers; in this case, we need
+      to save and restore the registers we are going to clobber.  */
+   int regparm = ix86_function_regparm (TREE_TYPE (current_function_decl),
+ 				       current_function_decl)
+ 		  - current_function_args_info.nregs;
+ 
+   gcc_assert (0 <= regparm && regparm <= REGPARM_MAX);
+ 
+   if (stack_check_libfunc)
+     {
+       rtx fnaddr = gen_rtx_MEM (QImode, stack_check_libfunc);
+       rtx real_pic_offset_table_rtx = NULL_RTX, insn;
+ 
+       /* We must end up aligned on PREFERRED_STACK_BOUNDARY immediately
+ 	 before the call:
+                                        __________
+ 	   saved pc                                ^
+ 	   saved static chain pointer              |
+ 	   saved PIC register                      |  n*STACK_SLOT_SIZE bytes
+ 	   padding                                 |
+ 	   allocated space             __________  V
+        */
+ 
+       const int stack_slot_size = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
+       const int pc = 1;
+ 
+       int static_chain = (cfun->static_chain_decl != NULL_TREE);
+       int pic = (pic_offset_table_rtx != NULL_RTX);
+       int n_saved = static_chain + pic;
+       int n_allocated = regparm + !TARGET_64BIT;
+       int used = (pc + n_saved + n_allocated) * UNITS_PER_WORD;
+       int n_slots = (used + stack_slot_size - 1) / stack_slot_size;
+       int padding = n_slots * stack_slot_size - used;
+       int total = padding + (n_saved + n_allocated) * UNITS_PER_WORD;
+ 
+       /* Save the static chain register if necessary.  */
+       if (static_chain)
+         {
+ 	  insn = emit_insn (gen_push (static_chain_rtx));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	}
+ 
+       /* Load the PIC register after saving it if necessary  */
+       if (pic)
+ 	{
+ 	  /* Beware that pic_offset_table_rtx may not be the canonical
+ 	     PIC register under certain circumstances.  */
+ 	  real_pic_offset_table_rtx
+ 	    = gen_raw_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM);
+ 	  insn = emit_insn (gen_push (real_pic_offset_table_rtx));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	  emit_insn (gen_set_got (real_pic_offset_table_rtx));
+ 
+ 	  /* Make sure the call is not scheduled before the above code.  */
+ 	  emit_insn (gen_blockage (real_pic_offset_table_rtx));
+ 	}
+ 
+       /* Allocate space and/or maintain the stack alignment.  */
+       if (n_allocated || padding)
+         {
+ 	  rtx dec = GEN_INT (padding + n_allocated * UNITS_PER_WORD);
+ 	  insn = emit_insn (gen_sub2_insn (stack_pointer_rtx, dec));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	}
+ 
+       /* Perform the call operation.  */
+       if (TARGET_64BIT)
+         {
+ 	  rtx reg, mem, edi = gen_rtx_REG (Pmode, 5);
+ 	  rtx disp, call, use = NULL_RTX;
+ 	  int i;
+ 
+ 	  /* Save parameter registers used by the current function.  */
+ 	  for (i = 0; i < regparm; i++)
+ 	    {
+ 	      reg = gen_rtx_REG (Pmode, x86_64_int_parameter_registers[i]);
+ 	      mem = gen_rtx_MEM (Pmode,
+ 				 plus_constant (stack_pointer_rtx,
+ 					        i * UNITS_PER_WORD));
+ 	      emit_move_insn (mem, reg);
+ 	    }
+ 
+ 	  /* Pass the bottom of the range to the checking function.  */
+ 	  disp = GEN_INT (-(first + size));
+ 	  if (x86_64_immediate_operand (disp, DImode))
+ 	    emit_insn (gen_add3_insn (edi, stack_pointer_rtx, disp));
+ 	  else
+ 	    {
+ 	      emit_move_insn (edi, disp);
+ 	      emit_insn (gen_add2_insn (edi, stack_pointer_rtx));
+ 	    }
+ 
+ 	  call = emit_call_insn (gen_call (fnaddr, const0_rtx, constm1_rtx));
+ 	  use_reg (&use, edi);
+ 	  CALL_INSN_FUNCTION_USAGE (call) = use;
+ 
+ 	  /* Restore parameter registers previously saved.  */
+ 	  for (i = 0; i < regparm; i++)
+ 	    {
+ 	      reg = gen_rtx_REG (Pmode, x86_64_int_parameter_registers[i]);
+ 	      mem = gen_rtx_MEM (Pmode,
+ 				 plus_constant (stack_pointer_rtx,
+ 					        i * UNITS_PER_WORD));
+ 	      insn = emit_move_insn (reg, mem);
+ 	      /* The register may be dead in the end.  */
+ 	      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
+ 						    reg,
+ 						    REG_NOTES (insn));
+ 	    }
+ 	}
+       else
+ 	{
+ 	  rtx reg, mem, eax = gen_rtx_REG (Pmode, 0);
+ 	  int i;
+ 
+ 	  /* Save parameter registers used by the current function.  */
+ 	  for (i = 0; i < regparm; i++)
+ 	    {
+ 	      reg = gen_rtx_REG (Pmode, i);
+ 	      mem = gen_rtx_MEM (Pmode,
+ 				 plus_constant (stack_pointer_rtx,
+ 					        (i + 1) * UNITS_PER_WORD));
+ 	      emit_move_insn (mem, reg);
+ 	    }
+ 
+ 	  /* Pass the bottom of the range to the checking function.  */
+ 	  emit_move_insn (eax,
+ 			  plus_constant (stack_pointer_rtx, -(first + size)));
+ 	  emit_move_insn (gen_rtx_MEM (Pmode, stack_pointer_rtx), eax);
+ 	  emit_call_insn (gen_call (fnaddr, GEN_INT (UNITS_PER_WORD), 0));
+ 
+ 	  /* Restore parameter registers previously saved.  */
+ 	  for (i = 0; i < regparm; i++)
+ 	    {
+ 	      reg = gen_rtx_REG (Pmode, i);
+ 	      mem = gen_rtx_MEM (Pmode,
+ 				 plus_constant (stack_pointer_rtx,
+ 					        (i + 1) * UNITS_PER_WORD));
+ 	      insn = emit_move_insn (reg, mem);
+ 	      /* The register may be dead in the end.  */
+ 	      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
+ 						    reg,
+ 						    REG_NOTES (insn));
+ 	    }
+ 	}
+ 
+       /* Restore the PIC register if necessary.  */
+       if (pic)
+ 	{
+ 	  rtx mem = gen_rtx_MEM (Pmode,
+ 				 plus_constant (stack_pointer_rtx,
+ 					        total - n_saved * UNITS_PER_WORD));
+ 	  insn = emit_move_insn (real_pic_offset_table_rtx, mem);
+ 	  /* The register may be dead in the end.  */
+ 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
+ 						real_pic_offset_table_rtx,
+ 						REG_NOTES (insn));
+ 	}
+ 
+       /* Restore the static chain register if necessary.  */
+       if (static_chain)
+ 	{
+ 	  rtx mem = gen_rtx_MEM (Pmode,
+ 				 plus_constant (stack_pointer_rtx,
+ 					        total - UNITS_PER_WORD));
+ 	  insn = emit_move_insn (static_chain_rtx, mem);
+ 	  /* The register may be dead in the end.  */
+ 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
+ 						static_chain_rtx,
+ 						REG_NOTES (insn));
+ 	}
+ 
+       /* Restore the stack pointer.  Phew!  */
+       insn = emit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (total)));
+       RTX_FRAME_RELATED_P (insn) = 1;
+     }
+ 
+   else if (TARGET_64BIT)
+     ; /* Not yet implemented, but do not assert as we'll get there when
+ 	 compiling C code.  Doing nothing is not worse than emitting
+ 	 useless probes.  */
+ 
+   else
+     {
+       int i, n = SMALL_INTERVAL (size) ? 0 : MIN (regparm, 2);
+ 
+       /* Save eax and edx if they are used as parameter registers by the
+ 	 current function and are clobbered by the probing code.  */
+       for (i = 0; i < n; i++)
+ 	{
+ 	  rtx reg = gen_rtx_REG (Pmode, i);
+ 	  rtx insn = emit_insn (gen_push (reg));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	}
+ 
+       emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ 
+       /* Restore parameter registers previously saved.  Note that we cannot
+ 	 use the pop insn because the RTX_FRAME_RELATED_P mechanism doesn't
+ 	 know how to handle it.  */
+       for (i = 0; i < n; i++)
+ 	{
+ 	  rtx reg = gen_rtx_REG (Pmode, i);
+ 	  rtx mem
+ 	    = gen_rtx_MEM (Pmode,
+ 			   plus_constant (stack_pointer_rtx,
+ 					  (n - 1 - i) * UNITS_PER_WORD));
+ 	  rtx insn = emit_move_insn (reg, mem);
+ 	  /* The register may be dead in the end.  */
+ 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
+ 						reg,
+ 						REG_NOTES (insn));
+ 	}
+ 
+       /* Restore the stack pointer if needed.  */
+       if (n > 0)
+ 	{
+ 	  rtx insn = emit_insn (gen_add2_insn (stack_pointer_rtx,
+ 					       GEN_INT (n * UNITS_PER_WORD)));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	}
+     }
+ 
+   /* Make sure nothing is scheduled before we are done.  */
+   emit_insn (gen_blockage (const0_rtx));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   gcc_assert (!TARGET_64BIT); /* Not yet implemented.  */
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (SMALL_INTERVAL (size))
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	fprintf (asm_out_file, "\torl\t$0, -"HOST_WIDE_INT_PRINT_DEC"(%%esp)\n",
+ 		 first + i);
+ 
+       fprintf (asm_out_file, "\torl\t$0, -"HOST_WIDE_INT_PRINT_DEC"(%%esp)\n",
+ 	       first + size);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+       if (first)
+ 	/* TEST_ADDR = SP + FIRST.  */
+ 	fprintf (asm_out_file, "\tleal\t-"HOST_WIDE_INT_PRINT_DEC"(%%esp), %%eax\n",
+ 		 first);
+       else
+ 	fputs ("\tmovl\t%esp, %eax\n", asm_out_file);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       fprintf (asm_out_file, "\tleal\t-"HOST_WIDE_INT_PRINT_DEC"(%%eax), %%edx\n",
+ 	       rounded_size);
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it exceeds ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fputs ("\tcmpl\t%eax, %edx\n", asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tje\t", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\tsubl\t$%d, %%eax\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fputs ("\torl\t$0, (%eax)\n", asm_out_file);
+       fprintf (asm_out_file, "\tjmp\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at SIZE if we cannot assert at compile-time that
+ 	 it is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\torl\t$0, -"HOST_WIDE_INT_PRINT_DEC"(%%edx)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Emit code to save registers in the prologue.  */
  
  static void
*************** ix86_expand_prologue (void)
*** 4892,4897 ****
--- 5246,5270 ----
  
    ix86_compute_frame_layout (&frame);
  
+   /* The stack has already been decremented by the instruction calling us
+      so we need to probe unconditionally to preserve the protection area.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
+     {
+       HOST_WIDE_INT probed = UNITS_PER_WORD 
+ 			     + (frame_pointer_needed ? UNITS_PER_WORD : 0)
+ 			     + frame.to_allocate
+ 			     + frame.nregs * UNITS_PER_WORD;
+ 
+       /* If CHECK_STACK_LIMIT is positive, the target may expect unconditional
+ 	 probing from the first allocated byte to grow the stack of threads.
+ 	 It's the case on Windows.  If ix86_target_stack_probe returns false,
+ 	 the builtin support has been disabled to avoid probing twice.  */
+       if (CHECK_STACK_LIMIT > 0 && !ix86_target_stack_probe ())
+ 	ix86_emit_probe_stack_range (0, probed + STACK_CHECK_PROTECT);
+       else
+ 	ix86_emit_probe_stack_range (STACK_CHECK_PROTECT, probed);
+     }
+ 
    if (cfun->machine->force_align_arg_pointer)
      {
        rtx x, y;
*************** ix86_expand_prologue (void)
*** 4966,4972 ****
  
    if (allocate == 0)
      ;
!   else if (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)
      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
  			       GEN_INT (-allocate), -1);
    else
--- 5339,5345 ----
  
    if (allocate == 0)
      ;
!   else if (! ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)
      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
  			       GEN_INT (-allocate), -1);
    else
*** gcc/config/i386/i386.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/i386/i386.h	2006-03-16 18:03:59.000000000 +0100
*************** struct machine_function GTY(())
*** 2298,2303 ****
--- 2298,2307 ----
  #define SYMBOL_FLAG_FAR_ADDR		(SYMBOL_FLAG_MACH_DEP << 0)
  #define SYMBOL_REF_FAR_ADDR_P(X)	\
  	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_FAR_ADDR) != 0)
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  /*
  Local variables:
  version-control: t
*** gcc/config/i386/i386.md.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/i386/i386.md	2006-03-16 18:03:59.000000000 +0100
***************
*** 163,168 ****
--- 163,169 ----
     (UNSPECV_CMPXCHG_2		11)
     (UNSPECV_XCHG		12)
     (UNSPECV_LOCK		13)
+    (UNSPECV_STACK_PROBE_INLINE  14)
    ])
  
  ;; Registers by name.
***************
*** 19104,19110 ****
  
  (define_expand "allocate_stack_worker"
    [(match_operand:SI 0 "register_operand" "")]
!   "TARGET_STACK_PROBE"
  {
    if (reload_completed)
      {
--- 19105,19111 ----
  
  (define_expand "allocate_stack_worker"
    [(match_operand:SI 0 "register_operand" "")]
!   "ix86_target_stack_probe ()"
  {
    if (reload_completed)
      {
***************
*** 19129,19135 ****
     (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
     (clobber (match_scratch:SI 1 "=0"))
     (clobber (reg:CC FLAGS_REG))]
!   "!TARGET_64BIT && TARGET_STACK_PROBE"
    "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
--- 19130,19136 ----
     (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))
     (clobber (match_scratch:SI 1 "=0"))
     (clobber (reg:CC FLAGS_REG))]
!   "!TARGET_64BIT && ix86_target_stack_probe ()"
    "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
***************
*** 19149,19155 ****
     (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))
     (clobber (match_scratch:DI 1 "=0"))
     (clobber (reg:CC FLAGS_REG))]
!   "TARGET_64BIT && TARGET_STACK_PROBE"
    "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
--- 19150,19156 ----
     (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))
     (clobber (match_scratch:DI 1 "=0"))
     (clobber (reg:CC FLAGS_REG))]
!   "TARGET_64BIT && ix86_target_stack_probe ()"
    "call\t__alloca"
    [(set_attr "type" "multi")
     (set_attr "length" "5")])
***************
*** 19171,19177 ****
     (parallel [(set (reg:SI SP_REG)
  		   (minus:SI (reg:SI SP_REG) (match_dup 1)))
  	      (clobber (reg:CC FLAGS_REG))])]
!   "TARGET_STACK_PROBE"
  {
  #ifdef CHECK_STACK_LIMIT
    if (GET_CODE (operands[1]) == CONST_INT
--- 19172,19178 ----
     (parallel [(set (reg:SI SP_REG)
  		   (minus:SI (reg:SI SP_REG) (match_dup 1)))
  	      (clobber (reg:CC FLAGS_REG))])]
!   "ix86_target_stack_probe ()"
  {
  #ifdef CHECK_STACK_LIMIT
    if (GET_CODE (operands[1]) == CONST_INT
***************
*** 19187,19192 ****
--- 19188,19204 ----
    DONE;
  })
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:SI 0))
+    (clobber (reg:SI 1))
+    (clobber (reg:CC 17))]
+   "!TARGET_64BIT"
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "builtin_setjmp_receiver"
    [(label_ref (match_operand 0 "" ""))]
    "!TARGET_64BIT && flag_pic"
*** gcc/config/i386/i386-protos.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/i386/i386-protos.h	2006-03-16 18:03:59.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 23,28 ****
--- 23,29 ----
  extern void override_options (void);
  extern void optimization_options (int, int);
  
+ extern bool ix86_target_stack_probe (void);
  extern int ix86_can_use_return_insn_p (void);
  extern int ix86_frame_pointer_required (void);
  extern void ix86_setup_frame_addresses (void);
*************** extern const char *output_387_binary_op 
*** 72,77 ****
--- 73,79 ----
  extern const char *output_387_reg_move (rtx, rtx*);
  extern const char *output_fix_trunc (rtx, rtx*, int);
  extern const char *output_fp_compare (rtx, rtx*, int, int);
+ extern const char *output_probe_stack_range (rtx, rtx);
  
  extern void ix86_expand_clear (rtx);
  extern void ix86_expand_move (enum machine_mode, rtx[]);
*** gcc/config/ia64/ia64.c.0	2006-10-09 22:03:30.000000000 +0200
--- gcc/config/ia64/ia64.c	2006-11-17 00:17:39.000000000 +0100
*************** gen_fr_restore_x (rtx dest, rtx src, rtx
*** 2860,2865 ****
--- 2874,3066 ----
    return gen_fr_restore (dest, src);
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ ia64_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ /* See Table 6.2 of the IA-64 Software Developer Manual, Volume 2.  */
+ #define BACKING_STORE_SIZE(N) ((N) > 0 ? ((N) + (N)/63 + 1) * 8 : 0)
+ #define BACKING_STORE_PROTECT (2 * 1024)
+ #define MAX_STACKED_REGISTERS 96
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT end = first + size;
+   HOST_WIDE_INT rounded_size;
+   int sol, bs_size, bs_end;
+   char loop_lab[32], end_lab[32];
+ 
+   /* On the IA-64 there is a second stack in memory, namely the Backing Store
+      of the Register Stack Engine.  We also need to probe it after checking
+      that the 2 stacks don't overlap.  */
+   sol = current_frame_info.n_input_regs + current_frame_info.n_local_regs;
+   bs_size = BACKING_STORE_SIZE (sol);
+ 
+   /* End of the probed area for the Backing Store.  */
+   bs_end = BACKING_STORE_PROTECT + bs_size;
+ 
+   /* Unlike for the memory stack, it seems that we need to probe every single
+      page above the current BSP.  Since we use only one probe for the Backing
+      Store, the following condition should be false at compile time.  */
+ #if (BACKING_STORE_PROTECT + BACKING_STORE_SIZE (MAX_STACKED_REGISTERS)) > PROBE_INTERVAL
+ #error Cannot use a single probe for the Backing Store
+ #endif
+ 
+   /* Detect collision of the 2 stacks if necessary.  */
+   if (bs_size > 0 || size > 0)
+     {
+       fputs ("\tmov r3 = ar.bsp\n", asm_out_file);
+       fprintf (asm_out_file, "\tmovl r2 = -"HOST_WIDE_INT_PRINT_DEC"\n\t;;\n",
+ 	       end);
+ 
+       /* Compare current value of BSP and SP registers.  */
+       fputs ("\tcmp.ltu p6, p0 = r3, r12\n", asm_out_file);
+ 
+       /* Compute the address of the probe for the Backing Store (which grows
+ 	 towards higher addresses) and that of the last probe for the memory
+ 	 stack (which grows towards lower addresses).  */
+       fprintf (asm_out_file, "\taddl r3 = %d, r3\n", bs_end);
+       fputs ("\tadd r2 = r2, r12\n\t;;\n", asm_out_file);
+ 
+       /* Compare them and raise SEGV if the former has topped the latter.  */
+       fputs ("\t(p6) cmp.ltu p0, p6 = r3, r2\n\t;;\n", asm_out_file);
+       fputs ("\t(p6) break 11\n\t;;\n", asm_out_file);
+     }
+ 
+   /* Probe the Backing Store if necessary.  */
+   if (bs_size > 0)
+     fputs ("\tst8.rel [r3] = r0\n", asm_out_file);
+ 
+   /* Probe the memory stack if necessary.  */
+   if (size == 0)
+     ;
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   else if (size <= PROBE_INTERVAL)
+     fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
+ 
+   /* The run-time loop is made up of 8 insns in the generic case while this
+      compile-time loop is made up of 5+2*(n-2) insns for n # of intervals.  */
+   else if (size <= 4 * PROBE_INTERVAL)
+     {
+       HOST_WIDE_INT i;
+ 
+       fputs ("\tmov r2 = r12\n\t;;\n", asm_out_file);
+       fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 	       first + PROBE_INTERVAL);
+       fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
+ 	 it exceeds SIZE.  If only two probes are needed, this will not
+ 	 generate any code.  Then probe at SIZE.  */
+       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
+ 	  fputs ("\tst8.rel [r2] = r0\n\t;;\n", asm_out_file);
+ 	}
+ 
+       fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 	       size - (i - PROBE_INTERVAL));
+       fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fputs ("\tmov r2 = r12\n\t;;\n", asm_out_file);
+       fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       if (rounded_size > (1 << 21))
+ 	{
+ 	  fprintf (asm_out_file, "\tmovl r3 = -"HOST_WIDE_INT_PRINT_DEC"\n\t;;\n",
+ 		   rounded_size);
+ 	  fputs ("\tadd r3 = r2, r3\n\t;;\n", asm_out_file);
+ 	}
+       else
+ 	{
+ 	  fputs ("\t;;\n", asm_out_file);
+ 	  fprintf (asm_out_file, "\taddl r3 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 		   rounded_size);
+ 	}
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it exceeds ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tcmp.eq p6, p0 = r2, r3\n", asm_out_file);
+       fputs ("\t(p6) br.cond.dpnt ", asm_out_file);
+       assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
+       fprintf (asm_out_file, "\tbr "); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at SIZE if we cannot assert at compile-time that
+ 	 it is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+         {
+ 	  fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
+ 		   size - rounded_size);
+ 	  fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
+ 	}
+     }
+ 
+   return "";
+ }
+ 
  /* Called after register allocation to add any instructions needed for the
     prologue.  Using a prologue insn is favored compared to putting all of the
     instructions in output_function_prologue(), since it allows the scheduler
*************** ia64_expand_prologue (void)
*** 2892,2897 ****
--- 3093,3102 ----
    ia64_compute_frame_size (get_frame_size ());
    last_scratch_gr_reg = 15;
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
+     ia64_emit_probe_stack_range (STACK_CHECK_PROTECT,
+ 				 current_frame_info.total_size);
+ 
    /* If there is no epilogue, then we don't need some prologue insns.
       We need to avoid emitting the dead prologue insns, because flow
       will complain about them.  */
*************** ia64_init_machine_status (void)
*** 5171,5176 ****
--- 5376,5382 ----
  
  static enum attr_itanium_class ia64_safe_itanium_class (rtx);
  static enum attr_type ia64_safe_type (rtx);
+ static bool asm_insn_p (rtx);
  
  static enum attr_itanium_class
  ia64_safe_itanium_class (rtx insn)
*************** ia64_safe_type (rtx insn)
*** 5189,5194 ****
--- 5395,5411 ----
    else
      return TYPE_UNKNOWN;
  }
+ 
+ static bool
+ asm_insn_p (rtx insn)
+ {
+   rtx pat = PATTERN (insn);
+   return (GET_CODE (pat) == ASM_INPUT
+           || (GET_CODE (pat) == PARALLEL
+ 	      && GET_CODE (XVECEXP (pat, 0, 0)) == UNSPEC_VOLATILE
+ 	      && XINT (XVECEXP (pat, 0, 0), 1) == UNSPECV_STACK_PROBE_INLINE)
+ 	  || asm_noperands (pat) >= 0);
+ }
  
  /* The following collection of routines emit instruction group stop bits as
     necessary to avoid dependencies.  */
*************** rtx_needs_barrier (rtx x, struct reg_fla
*** 5622,5627 ****
--- 5839,5849 ----
  	    case RETURN:
  	      break;
  
+ 	    case UNSPEC_VOLATILE:
+ 	      if (XINT (pat, 1) == UNSPECV_STACK_PROBE_INLINE)
+ 	        return 1;
+ 	    /* fall through */
+ 
  	    default:
  	      gcc_unreachable ();
  	    }
*************** ia64_dfa_sched_reorder (FILE *dump, int 
*** 6343,6350 ****
  	    enum attr_type t = ia64_safe_type (insn);
  	    if (t == TYPE_UNKNOWN)
  	      {
! 		if (GET_CODE (PATTERN (insn)) == ASM_INPUT
! 		    || asm_noperands (PATTERN (insn)) >= 0)
  		  {
  		    rtx lowest = ready[n_asms];
  		    ready[n_asms] = insn;
--- 6565,6571 ----
  	    enum attr_type t = ia64_safe_type (insn);
  	    if (t == TYPE_UNKNOWN)
  	      {
! 		if (asm_insn_p (insn))
  		  {
  		    rtx lowest = ready[n_asms];
  		    ready[n_asms] = insn;
*************** ia64_dfa_new_cycle (FILE *dump, int verb
*** 6484,6491 ****
    if ((reload_completed && safe_group_barrier_needed (insn))
        || (last_scheduled_insn
  	  && (GET_CODE (last_scheduled_insn) == CALL_INSN
! 	      || GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT
! 	      || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)))
      {
        init_insn_group_barriers ();
        if (verbose && dump)
--- 6705,6711 ----
    if ((reload_completed && safe_group_barrier_needed (insn))
        || (last_scheduled_insn
  	  && (GET_CODE (last_scheduled_insn) == CALL_INSN
! 	      || asm_insn_p (last_scheduled_insn))))
      {
        init_insn_group_barriers ();
        if (verbose && dump)
*************** ia64_dfa_new_cycle (FILE *dump, int verb
*** 6504,6511 ****
  	}
        else if (reload_completed)
  	setup_clocks_p = TRUE;
!       if (GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT
! 	  || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)
  	state_reset (curr_state);
        else
  	{
--- 6724,6730 ----
  	}
        else if (reload_completed)
  	setup_clocks_p = TRUE;
!       if (asm_insn_p (last_scheduled_insn))
  	state_reset (curr_state);
        else
  	{
*************** ia64_dfa_new_cycle (FILE *dump, int verb
*** 6518,6525 ****
    else if (reload_completed)
      setup_clocks_p = TRUE;
    if (setup_clocks_p && ia64_tune == PROCESSOR_ITANIUM
!       && GET_CODE (PATTERN (insn)) != ASM_INPUT
!       && asm_noperands (PATTERN (insn)) < 0)
      {
        enum attr_itanium_class c = ia64_safe_itanium_class (insn);
  
--- 6737,6743 ----
    else if (reload_completed)
      setup_clocks_p = TRUE;
    if (setup_clocks_p && ia64_tune == PROCESSOR_ITANIUM
!       && ! asm_insn_p (insn))
      {
        enum attr_itanium_class c = ia64_safe_itanium_class (insn);
  
*************** issue_nops_and_insn (struct bundle_state
*** 6831,6838 ****
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       gcc_assert (GET_CODE (PATTERN (insn)) != ASM_INPUT
! 		  && asm_noperands (PATTERN (insn)) < 0);
  
        if (ia64_safe_type (insn) == TYPE_L)
  	curr_state->accumulated_insns_num++;
--- 7049,7055 ----
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       gcc_assert (!asm_insn_p (insn));
  
        if (ia64_safe_type (insn) == TYPE_L)
  	curr_state->accumulated_insns_num++;
*************** issue_nops_and_insn (struct bundle_state
*** 6858,6865 ****
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       if (GET_CODE (PATTERN (insn)) == ASM_INPUT
! 	  || asm_noperands (PATTERN (insn)) >= 0)
  	{
  	  /* Finish bundle containing asm insn.  */
  	  curr_state->after_nops_num
--- 7075,7081 ----
        if (!try_issue_insn (curr_state, insn))
  	return;
        curr_state->accumulated_insns_num++;
!       if (asm_insn_p (insn))
  	{
  	  /* Finish bundle containing asm insn.  */
  	  curr_state->after_nops_num
*************** bundling (FILE *dump, int verbose, rtx p
*** 7268,7275 ****
         curr_state = curr_state->originator)
      {
        insn = curr_state->insn;
!       asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT
! 	       || asm_noperands (PATTERN (insn)) >= 0);
        insn_num++;
        if (verbose >= 2 && dump)
  	{
--- 7484,7490 ----
         curr_state = curr_state->originator)
      {
        insn = curr_state->insn;
!       asm_p = asm_insn_p (insn);
        insn_num++;
        if (verbose >= 2 && dump)
  	{
*************** bundling (FILE *dump, int verbose, rtx p
*** 7346,7353 ****
        /* Move the position backward in the window.  Group barrier has
  	 no slot.  Asm insn takes all bundle.  */
        if (INSN_CODE (insn) != CODE_FOR_insn_group_barrier
! 	  && GET_CODE (PATTERN (insn)) != ASM_INPUT
! 	  && asm_noperands (PATTERN (insn)) < 0)
  	pos--;
        /* Long insn takes 2 slots.  */
        if (ia64_safe_type (insn) == TYPE_L)
--- 7561,7567 ----
        /* Move the position backward in the window.  Group barrier has
  	 no slot.  Asm insn takes all bundle.  */
        if (INSN_CODE (insn) != CODE_FOR_insn_group_barrier
!           && ! asm_insn_p (insn))
  	pos--;
        /* Long insn takes 2 slots.  */
        if (ia64_safe_type (insn) == TYPE_L)
*************** bundling (FILE *dump, int verbose, rtx p
*** 7355,7362 ****
        gcc_assert (pos >= 0);
        if (pos % 3 == 0
  	  && INSN_CODE (insn) != CODE_FOR_insn_group_barrier
! 	  && GET_CODE (PATTERN (insn)) != ASM_INPUT
! 	  && asm_noperands (PATTERN (insn)) < 0)
  	{
  	  /* The current insn is at the bundle start: emit the
  	     template.  */
--- 7569,7575 ----
        gcc_assert (pos >= 0);
        if (pos % 3 == 0
  	  && INSN_CODE (insn) != CODE_FOR_insn_group_barrier
! 	  && ! asm_insn_p (insn))
  	{
  	  /* The current insn is at the bundle start: emit the
  	     template.  */
*************** final_emit_insn_group_barriers (FILE *du
*** 7595,7602 ****
  	  else if (recog_memoized (insn) >= 0)
  	    prev_insn = insn;
  	  need_barrier_p = (GET_CODE (insn) == CALL_INSN
! 			    || GET_CODE (PATTERN (insn)) == ASM_INPUT
! 			    || asm_noperands (PATTERN (insn)) >= 0);
  	}
      }
  }
--- 7808,7814 ----
  	  else if (recog_memoized (insn) >= 0)
  	    prev_insn = insn;
  	  need_barrier_p = (GET_CODE (insn) == CALL_INSN
! 			    || asm_insn_p (insn));
  	}
      }
  }
*** gcc/config/ia64/ia64.md.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/ia64/ia64.md	2006-03-16 18:03:59.000000000 +0100
***************
*** 92,97 ****
--- 92,98 ----
     (UNSPECV_PSAC_ALL		5)	; pred.safe_across_calls
     (UNSPECV_PSAC_NORMAL		6)
     (UNSPECV_SETJMP_RECEIVER	7)
+    (UNSPECV_STACK_PROBE_INLINE  8)
    ])
  
  (include "predicates.md")
***************
*** 5837,5842 ****
--- 5838,5853 ----
  ;; ::
  ;; ::::::::::::::::::::
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:DI 0 "const_int_operand" "")
+ 			(match_operand:DI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:DI 2))
+    (clobber (reg:DI 3))]
+   ""
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "predicable" "no")])
+ 
  (define_expand "prologue"
    [(const_int 1)]
    ""
*** gcc/config/ia64/ia64-protos.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/ia64/ia64-protos.h	2006-03-16 18:03:59.000000000 +0100
*************** extern enum reg_class ia64_secondary_rel
*** 73,78 ****
--- 73,79 ----
  						   enum machine_mode, rtx);
  extern void process_for_unwind_directive (FILE *, rtx);
  extern const char *get_bundle_name (int);
+ extern const char *output_probe_stack_range (rtx, rtx);
  #endif /* RTX_CODE */
  
  #ifdef TREE_CODE
*** gcc/config/ia64/linux.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/ia64/linux.h	2006-03-16 18:03:59.000000000 +0100
*************** do {						\
*** 56,59 ****
--- 56,62 ----
  #undef LINK_EH_SPEC
  #define LINK_EH_SPEC ""
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #define MD_UNWIND_SUPPORT "config/ia64/linux-unwind.h"
*** gcc/config/ia64/hpux.h.0	2006-10-28 20:09:23.000000000 +0200
--- gcc/config/ia64/hpux.h	2006-11-17 00:17:39.000000000 +0100
*************** do {								\
*** 220,222 ****
--- 230,239 ----
  
  #undef NO_PROFILE_COUNTERS
  #define NO_PROFILE_COUNTERS 0
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Minimum amount of stack required to recover from an anticipated stack
+    overflow detection.  */
+ #define STACK_CHECK_PROTECT (24 * 1024)
*** gcc/config/mips/iris6.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/mips/iris6.h	2006-03-16 18:03:59.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 112,114 ****
--- 114,119 ----
         %{!mips4:/usr/lib64/mips3/crtn.o%s}}}"
  
  #define MIPS_TFMODE_FORMAT mips_extended_format
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/mips/mips.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/mips/mips.c	2006-03-16 18:03:59.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 40,45 ****
--- 40,46 ----
  #include "output.h"
  #include "tree.h"
  #include "function.h"
+ #include "except.h"
  #include "expr.h"
  #include "optabs.h"
  #include "flags.h"
*************** mips_emit_loadgp (void)
*** 6539,6544 ****
--- 6540,6670 ----
      }
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ mips_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL > 32768
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ const char *
+ mips_output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (first + size <= 32768)
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	fprintf (asm_out_file, "\tsd\t$0,-"HOST_WIDE_INT_PRINT_DEC"($sp)\n",
+ 		 first + i);
+ 
+       fprintf (asm_out_file, "\tsd\t$0,-"HOST_WIDE_INT_PRINT_DEC"($sp)\n",
+ 	       first + size);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Sanity check for the addressing mode we're going to use.  */
+       gcc_assert (first <= 32768);
+ 
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fprintf (asm_out_file, "\taddiu\t$3,$sp,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       if (rounded_size > 32768)
+ 	{
+ 	  int high = (-rounded_size) & ~0xffff;
+ 	  int low = (-rounded_size) & 0xffff;
+ 
+ 	  if (high)
+ 	    fprintf (asm_out_file, "\tli\t$12,%d\n", high);
+ 	  if (low)
+ 	    fprintf (asm_out_file, "\tori\t$12,$12,0x%x\n", low);
+ 	  fputs ("\taddu\t$12,$3,$12\n", asm_out_file);
+ 	}
+       else
+ 	fprintf (asm_out_file, "\taddiu\t$12,$3,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 		 rounded_size);
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it exceeds ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tbeq\t$3,$12,", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\t addiu\t$3,$3,-%d\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fprintf (asm_out_file, "\tb\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+       fputs ("\t sd\t$0,0($3)\n", asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at SIZE if we cannot assert at compile-time that
+ 	 it is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tsd\t$0,-"HOST_WIDE_INT_PRINT_DEC"($12)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Set up the stack and frame (if desired) for the function.  */
  
  static void
*************** mips_expand_prologue (void)
*** 6720,6725 ****
--- 6846,6854 ----
  
    size = compute_frame_size (get_frame_size ());
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)
+     mips_emit_probe_stack_range (STACK_CHECK_PROTECT, size);
+ 
    /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP
       bytes beforehand; this is enough to cover the register save area
       without going out of range.  */
*** gcc/config/mips/mips.md.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/mips/mips.md	2006-03-16 18:03:59.000000000 +0100
***************
*** 145,150 ****
--- 145,153 ----
    ]
  )
  
+ (define_constants
+   [(UNSPECV_STACK_PROBE_INLINE  0)])
+ 
  (include "predicates.md")
  
  ;; ....................
***************
*** 4857,4862 ****
--- 4860,4875 ----
  ;;  ....................
  ;;
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:SI 3))
+    (clobber (reg:SI 12))]
+   ""
+   "* return mips_output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "prologue"
    [(const_int 1)]
    ""
*** gcc/config/mips/mips-protos.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/mips/mips-protos.h	2006-03-16 18:03:59.000000000 +0100
*************** extern const char *mips_output_load_labe
*** 216,221 ****
--- 216,222 ----
  extern const char *mips_output_conditional_branch (rtx, rtx *, int, int,
  						   int, int);
  extern const char *mips_output_division (const char *, rtx *);
+ extern const char *mips_output_probe_stack_range (rtx, rtx);
  extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);
  extern bool mips_linked_madd_p (rtx, rtx);
  extern rtx mips_prefetch_cookie (rtx, rtx);
*** gcc/config/pa/pa.c.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/pa/pa.c	2006-03-16 18:03:59.000000000 +0100
*************** pa_output_function_prologue (FILE *file,
*** 3567,3572 ****
--- 3567,3707 ----
    remove_useless_addtr_insns (0);
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ pa_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc && !TARGET_64BIT); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL >= 8192
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ #if PROBE_INTERVAL & 0x7ff
+ #error Cannot use addil instruction for stack probing
+ #endif
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* Sanity check for addil instruction.  */
+   gcc_assert ((first & 0x7ff) == 0);
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (size <= PROBE_INTERVAL)
+     {
+       fprintf (asm_out_file, "\taddil L'"HOST_WIDE_INT_PRINT_DEC",%%r30\n",
+ 	       first);
+       fprintf (asm_out_file, "\tstw %%r0,"HOST_WIDE_INT_PRINT_DEC"(%%r1)\n",
+ 	       size);
+     }
+ 
+   /* The run-time loop is made up of 8 insns in the generic case while this
+      compile-time loop is made up of 3+2*(n-2) insns for n # of intervals.  */
+   else if (size <= 4 * PROBE_INTERVAL)
+     {
+       HOST_WIDE_INT i;
+ 
+       fprintf (asm_out_file, "\taddil L'"HOST_WIDE_INT_PRINT_DEC",%%r30\n",
+ 	       first + PROBE_INTERVAL);
+       fputs ("\tstw %r0,0(%r1)\n", asm_out_file);
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
+ 	 it exceeds SIZE.  If only two probes are needed, this will not
+ 	 generate any code.  Then probe at SIZE.  */
+       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  fprintf (asm_out_file, "\taddil L'%d,%%r1\n", PROBE_INTERVAL);
+ 	  fputs ("\tstw %r0,0(%r1)\n", asm_out_file);
+ 	}
+ 
+       fprintf (asm_out_file, "\tstw %%r0,"HOST_WIDE_INT_PRINT_DEC"(%%r1)\n",
+ 	       size - (i - PROBE_INTERVAL));
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fprintf (asm_out_file, "\taddil L'"HOST_WIDE_INT_PRINT_DEC",%%r30\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       fprintf (asm_out_file, "\tldil L'"HOST_WIDE_INT_PRINT_DEC",%%r20\n",
+ 	       rounded_size);
+       fputs ("\taddl %r1,%r20,%r20\n", asm_out_file);
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it exceeds ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tcomb,= %r1,%r20,", asm_out_file);
+       assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\t addil L'%d,%%r1\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fprintf (asm_out_file, "\tb "); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+       fputs ("\t stw %r0,0(%r1)\n", asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at SIZE if we cannot assert at compile-time that
+ 	 it is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tstw %%r0,"HOST_WIDE_INT_PRINT_DEC"(%%r20)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  void
  hppa_expand_prologue (void)
  {
*************** hppa_expand_prologue (void)
*** 3589,3594 ****
--- 3724,3732 ----
  
    actual_fsize = compute_frame_size (size, &save_fregs);
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
+     pa_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);
+ 
    /* Compute a few things we will use often.  */
    tmpreg = gen_rtx_REG (word_mode, 1);
  
*** gcc/config/pa/pa-hpux.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/pa/pa-hpux.h	2006-03-16 18:03:59.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 125,128 ****
--- 125,131 ----
  #undef HANDLE_PRAGMA_PACK_PUSH_POP
  #define HANDLE_PRAGMA_PACK_PUSH_POP
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #define MD_UNWIND_SUPPORT "config/pa/hpux-unwind.h"
*** gcc/config/pa/pa.md.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/pa/pa.md	2006-03-16 18:03:59.000000000 +0100
***************
*** 6904,6909 ****
--- 6904,6919 ----
    [(set_attr "type" "branch")
     (set_attr "length" "12")])
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     10)
+    (clobber (reg:SI 1))
+    (clobber (reg:SI 20))]
+   "!TARGET_64BIT"
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "prologue"
    [(const_int 0)]
    ""
*** gcc/config/pa/pa-protos.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/pa/pa-protos.h	2006-03-16 18:03:59.000000000 +0100
*************** extern const char *output_mul_insn (int,
*** 57,62 ****
--- 57,63 ----
  extern const char *output_div_insn (rtx *, int, rtx);
  extern const char *output_mod_insn (int, rtx);
  extern const char *singlemove_string (rtx *);
+ extern const char *output_probe_stack_range (rtx, rtx);
  extern void output_arg_descriptor (rtx);
  extern void output_global_address (FILE *, rtx, int);
  extern void print_operand (FILE *, rtx, int);
*** gcc/config/rs6000/aix.h.0	2006-03-16 18:02:56.000000000 +0100
--- gcc/config/rs6000/aix.h	2006-03-16 18:03:59.000000000 +0100
***************
*** 254,256 ****
--- 254,259 ----
  
  /* WINT_TYPE */
  #define WINT_TYPE "int"
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/rs6000/rs6000.c.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/rs6000/rs6000.c	2006-03-16 18:03:59.000000000 +0100
*************** rs6000_emit_allocate_stack (HOST_WIDE_IN
*** 13775,13780 ****
--- 13775,13906 ----
  		       REG_NOTES (insn));
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc && !TARGET_64BIT); /* Not implemented.  */
+   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL > 32768
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (first + size <= 32768)
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	fprintf (asm_out_file, "\tstw 0,-"HOST_WIDE_INT_PRINT_DEC"(1)\n",
+ 		 first + i);
+ 
+       fprintf (asm_out_file, "\tstw 0,-"HOST_WIDE_INT_PRINT_DEC"(1)\n",
+ 	       first + size);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Sanity check for the addressing mode we're going to use.  */
+       gcc_assert (first <= 32768);
+ 
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       fprintf (asm_out_file, "\taddi 12,1,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 	       first);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       if (rounded_size > 32768)
+ 	{
+ 	  int high = (-rounded_size) >> 16;
+ 	  int low = (-rounded_size) & 0xffff;
+ 
+ 	  if (high)
+ 	    fprintf (asm_out_file, "\tlis 0,%d\n", high);
+ 	  if (low)
+ 	    fprintf (asm_out_file, "\tori 0,0,%d\n", low);
+ 	  fputs ("\tadd 0,12,0\n", asm_out_file);
+ 	}
+       else
+ 	fprintf (asm_out_file, "\taddi 0,12,-"HOST_WIDE_INT_PRINT_DEC"\n",
+ 		 rounded_size);
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it exceeds ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fputs ("\tcmpw 0,12,0\n", asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tbeq 0,", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+  
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\taddi 12,12,-%d\n", PROBE_INTERVAL);
+   
+       /* Probe at TEST_ADDR and branch.  */
+       fputs ("\tstw 0,0(12)\n", asm_out_file);
+       fprintf (asm_out_file, "\tb "); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at SIZE if we cannot assert at compile-time that
+ 	 it is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tstw 0,-"HOST_WIDE_INT_PRINT_DEC"(12)\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced
     with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2
     is not NULL.  It would be nice if dwarf2out_frame_debug_expr could
*************** rs6000_emit_prologue (void)
*** 14082,14087 ****
--- 14208,14216 ----
    int using_store_multiple;
    HOST_WIDE_INT sp_offset = 0;
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)
+     rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, info->total_size);
+ 
    if (TARGET_FIX_AND_CONTINUE)
      {
        /* gdb on darwin arranges to forward a function from the old
*** gcc/config/rs6000/rs6000.md.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/rs6000/rs6000.md	2006-03-16 18:03:59.000000000 +0100
***************
*** 80,85 ****
--- 80,86 ----
     (UNSPECV_LL			1)	; load-locked
     (UNSPECV_SC			2)	; store-conditional
     (UNSPECV_EH_RR		9)	; eh_reg_restore
+    (UNSPECV_STACK_PROBE_INLINE  10)
    ])
  
  ;; Define an insn type attribute.  This is used in function unit delay
***************
*** 13478,13483 ****
--- 13479,13495 ----
  
  ;; Insns related to generating the function prologue and epilogue.
  
+ (define_insn "probe_stack_range"
+   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
+ 			(match_operand:SI 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:SI 0))
+    (clobber (reg:SI 12))
+    (clobber (reg:CC 68))]
+   "TARGET_32BIT"
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "three")])
+ 
  (define_expand "prologue"
    [(use (const_int 0))]
    "TARGET_SCHED_PROLOG"
*** gcc/config/rs6000/rs6000-protos.h.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/rs6000/rs6000-protos.h	2006-03-16 18:03:59.000000000 +0100
*************** extern void rs6000_split_lock_test_and_s
*** 90,95 ****
--- 90,96 ----
  extern void rs6000_emit_swdivsf (rtx, rtx, rtx);
  extern void rs6000_emit_swdivdf (rtx, rtx, rtx);
  extern void output_toc (FILE *, rtx, int, enum machine_mode);
+ extern const char *output_probe_stack_range (rtx, rtx);
  extern void rs6000_initialize_trampoline (rtx, rtx, rtx);
  extern rtx rs6000_longcall_ref (rtx);
  extern void rs6000_fatal_bad_address (rtx);
*** gcc/config/rs6000/vxworksae.h.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/rs6000/vxworksae.h	2006-03-16 18:03:59.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 22,24 ****
--- 22,32 ----
  #undef TARGET_VERSION
  #define TARGET_VERSION fprintf (stderr, " (PowerPC VxWorks AE)");
  
+ /* Target overrides for VxWorks AE653 platform.  */
+ 
+ /* This platform supports the probing method of stack checking and
+    requires 4K of space for executing a possible last chance handler.  */
+ #define STACK_CHECK_PROTECT 4096
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/sparc/sol2.h.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/sparc/sol2.h	2006-03-16 18:03:59.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 165,167 ****
--- 167,172 ----
        fprintf (FILE, "\n\tnop\n");				\
      }								\
    while (0)
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/sparc/sparc.c.0	2006-05-01 18:19:11.517368728 +0200
--- gcc/config/sparc/sparc.c	2006-05-01 18:21:48.242542880 +0200
*************** Boston, MA 02110-1301, USA.  */
*** 38,43 ****
--- 38,44 ----
  #include "insn-attr.h"
  #include "flags.h"
  #include "function.h"
+ #include "except.h"
  #include "expr.h"
  #include "optabs.h"
  #include "recog.h"
*************** sparc_output_scratch_registers (FILE *fi
*** 3716,3721 ****
--- 3717,3957 ----
  #endif
  }
  
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ sparc_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+ 
+   if (TARGET_ARCH64)
+     emit_insn (gen_probe_stack_rangedi (GEN_INT (first), GEN_INT (size)));
+   else
+     emit_insn (gen_probe_stack_rangesi (GEN_INT (first), GEN_INT (size)));
+ }
+ 
+ /* Build big number NUM in register REG and output the result to FILE.
+    REG is guaranteed to be the only clobbered register.  The function
+    will very likely emit several instructions, so it must not be called
+    from within a delay slot.  */
+ 
+ static void
+ build_big_number (FILE *file, HOST_WIDE_INT num, const char *reg)
+ {
+ #if HOST_BITS_PER_WIDE_INT == 64
+   HOST_WIDE_INT high_bits = (num >> 32) & 0xffffffff;
+ 
+   if (high_bits == 0
+ #else
+   if (num >= 0
+ #endif
+       || TARGET_ARCH32)
+     {
+       /* We don't use the 'set' macro because it appears to be broken
+ 	 in the Solaris 7 assembler.  */
+       fprintf (file, "\tsethi\t%%hi("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 	       num, reg);
+       if ((num & 0x3ff) != 0)
+ 	fprintf (file, "\tor\t%s, %%lo("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 		 reg, num, reg);
+     }
+ #if HOST_BITS_PER_WIDE_INT == 64
+   else if (high_bits == 0xffffffff) /* && TARGET_ARCH64 */
+ #else
+   else /* num < 0 && TARGET_ARCH64 */
+ #endif
+     {
+       /* Sethi does not sign extend, so we must use a little trickery
+ 	 to use it for negative numbers.  Invert the constant before
+ 	 loading it in, then use xor immediate to invert the loaded bits
+ 	 (along with the upper 32 bits) to the desired constant.  This
+ 	 works because the sethi and immediate fields overlap.  */
+       HOST_WIDE_INT inv = ~num;
+       HOST_WIDE_INT low = -0x400 + (num & 0x3ff);
+ 	  
+       fprintf (file, "\tsethi\t%%hi("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 	       inv, reg);
+       fprintf (file, "\txor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 	       reg, low, reg);
+     }
+ #if HOST_BITS_PER_WIDE_INT == 64
+   else /* TARGET_ARCH64 */
+     {
+       /* We don't use the 'setx' macro because if requires a scratch register.
+          This is the translation of sparc_emit_set_const64_longway.  */
+       HOST_WIDE_INT low1 = (num >> (32 - 12))          & 0xfff;
+       HOST_WIDE_INT low2 = (num >> (32 - 12 - 12))     & 0xfff;
+       HOST_WIDE_INT low3 = (num >> (32 - 12 - 12 - 8)) & 0x0ff;
+       int to_shift = 12;
+ 
+       /* We don't use the 'set' macro because it appears to be broken
+ 	 in the Solaris 7 assembler.  */
+       fprintf (file, "\tsethi\t%%hi("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 	       high_bits, reg);
+       if ((high_bits & 0x3ff) != 0)
+ 	fprintf (file, "\tor\t%s, %%lo("HOST_WIDE_INT_PRINT_DEC"), %s\n",
+ 		 reg, high_bits, reg);
+ 
+       if (low1 != 0)
+ 	{
+ 	  fprintf (file, "\tsllx\t%s, %d, %s\n", reg, to_shift, reg);
+ 	  fprintf (file, "\tor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 		   reg, low1, reg);
+ 	  to_shift = 12;
+ 	}
+       else
+ 	{
+ 	  to_shift += 12;
+ 	}
+       if (low2 != 0)
+ 	{
+ 	  fprintf (file, "\tsllx\t%s, %d, %s\n", reg, to_shift, reg);
+ 	  fprintf (file, "\tor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 		   reg, low2, reg);
+ 	  to_shift = 8;
+ 	}
+       else
+ 	{
+ 	  to_shift += 8;
+ 	}
+       fprintf (file, "\tsllx\t%s, %d, %s\n", reg, to_shift, reg);
+       if (low3 != 0)
+ 	fprintf (file, "\tor\t%s, "HOST_WIDE_INT_PRINT_DEC", %s\n",
+ 		 reg, low3, reg);
+     }
+ #endif
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ 
+ #if PROBE_INTERVAL > 4096
+ #error Cannot use indexed addressing mode for stack probing
+ #endif
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* The probe offsets are counted negatively whereas the stack bias is
+      counted positively.  */
+   first -= SPARC_STACK_BIAS;
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (size <= PROBE_INTERVAL)
+     {
+       build_big_number (asm_out_file, first, "%g1");
+       fputs ("\tsub\t%sp, %g1, %g1\n", asm_out_file);
+       fprintf (asm_out_file, "\tst\t%%g0, [%%g1-"HOST_WIDE_INT_PRINT_DEC"]\n",
+ 	       size);
+     }
+ 
+   /* The run-time loop is made up of 10 insns in the generic case while this
+      compile-time loop is made up of 4+2*(n-2) insns for n # of intervals.  */
+   else if (size <= 5 * PROBE_INTERVAL)
+     {
+       HOST_WIDE_INT i;
+ 
+       build_big_number (asm_out_file, first + PROBE_INTERVAL, "%g1");
+       fputs ("\tsub\t%sp, %g1, %g1\n", asm_out_file);
+       fputs ("\tst\t%g0, [%g1]\n", asm_out_file);
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
+ 	 it exceeds SIZE.  If only two probes are needed, this will not
+ 	 generate any code.  Then probe at SIZE.  */
+       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  fprintf (asm_out_file, "\tadd\t%%g1, -%d, %%g1\n", PROBE_INTERVAL);
+ 	  fputs ("\tst\t%g0, [%g1]\n", asm_out_file);
+ 	}
+ 
+       fprintf (asm_out_file, "\tst\t%%g0, [%%g1-"HOST_WIDE_INT_PRINT_DEC"]\n",
+ 	       size - (i - PROBE_INTERVAL));
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+ 
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_ADDR = SP + FIRST.  */
+       build_big_number (asm_out_file, first, "%g1");
+       fputs ("\tsub\t%sp, %g1, %g1\n", asm_out_file);
+ 
+       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
+       build_big_number (asm_out_file, rounded_size, "%g4");
+       fputs ("\tsub\t%g1, %g4, %g4\n", asm_out_file);
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_ADDR != LAST_ADDR)
+ 	  {
+ 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+ 	    probe at TEST_ADDR
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it exceeds ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fputs ("\tcmp\t%g1, %g4\n", asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       if (TARGET_ARCH64)
+ 	fputs ("\tbe,pn\t%xcc,", asm_out_file);
+       else
+ 	fputs ("\tbe\t", asm_out_file);
+       assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+ 
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\t add\t%%g1, -%d, %%g1\n", PROBE_INTERVAL);
+ 
+       /* Probe at TEST_ADDR and branch.  */
+       if (TARGET_ARCH64)
+ 	fputs ("\tba,pt\t%xcc,", asm_out_file);
+       else
+ 	fputs ("\tba\t", asm_out_file);
+       assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+       fputs ("\t st\t%g0, [%g1]\n", asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at SIZE if we cannot assert at compile-time that
+ 	 it is equal to ROUNDED_SIZE.  */
+ 
+       /* TEMP = SIZE - ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	fprintf (asm_out_file, "\tst\t%%g0, [%%g4-"HOST_WIDE_INT_PRINT_DEC"]\n",
+ 		 size - rounded_size);
+     }
+ 
+   return "";
+ }
+ 
  /* Save/restore call-saved registers from LOW to HIGH at BASE+OFFSET
     as needed.  LOW should be double-word aligned for 32-bit registers.
     Return the new OFFSET.  */
*************** sparc_expand_prologue (void)
*** 3904,3909 ****
--- 4140,4148 ----
    /* Advertise that the data calculated just above are now valid.  */
    sparc_prologue_data_valid_p = true;
  
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)
+     sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);
+ 
    if (sparc_leaf_function_p)
      {
        frame_base_reg = stack_pointer_rtx;
*** gcc/config/sparc/sparc.md.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/sparc/sparc.md	2006-03-16 18:03:59.000000000 +0100
***************
*** 69,74 ****
--- 69,75 ----
     (UNSPECV_FLUSH		4)
     (UNSPECV_SETJMP		5)
     (UNSPECV_SAVEW		6)
+    (UNSPECV_STACK_PROBE_INLINE  7)
    ])
  
  ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this
***************
*** 7014,7019 ****
--- 7015,7030 ----
  
  ;; Special instructions.
  
+ (define_insn "probe_stack_range<P:mode>"
+   [(unspec_volatile:SI [(match_operand:P 0 "const_int_operand" "")
+ 			(match_operand:P 1 "const_int_operand" "")]
+     UNSPECV_STACK_PROBE_INLINE)
+    (clobber (reg:P 1))
+    (clobber (reg:P 4))]
+   ""
+   "* return output_probe_stack_range (operands[0], operands[1]);"
+   [(set_attr "type" "multi")])
+ 
  (define_expand "prologue"
    [(const_int 0)]
    ""
*** gcc/config/sparc/sparc-protos.h.0	2006-03-16 18:02:57.000000000 +0100
--- gcc/config/sparc/sparc-protos.h	2006-03-16 18:03:59.000000000 +0100
*************** extern const char *output_return (rtx);
*** 86,91 ****
--- 86,92 ----
  extern const char *output_sibcall (rtx, rtx);
  extern const char *output_v8plus_shift (rtx *, rtx, const char *);
  extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);
+ extern const char *output_probe_stack_range (rtx, rtx);
  extern void emit_v9_brxx_insn (enum rtx_code, rtx, rtx);
  extern void print_operand (FILE *, rtx, int);
  extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);
*** gcc/config/alpha/alpha.h.0	2006-03-14 11:01:55.815132032 +0100
--- gcc/config/alpha/alpha.h	2006-03-14 11:03:15.651994984 +0100
*************** do {						\
*** 1000,1005 ****
--- 1000,1011 ----
  
  #define RETURN_ADDR_RTX  alpha_return_addr
  
+ /* Provide a definition of DWARF_FRAME_REGNUM here so that fallback unwinders
+    can use DWARF_ALT_FRAME_RETURN_COLUMN defined below.  This is just the same
+    as the default definition in dwarf2out.c.  */
+ #undef DWARF_FRAME_REGNUM
+ #define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)
+ 
  /* Before the prologue, RA lives in $26.  */
  #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)
  #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (26)
*** gcc/config/alpha/osf5.h.0	2006-03-14 08:44:05.528406720 +0100
--- gcc/config/alpha/osf5.h	2006-03-14 08:44:12.617329040 +0100
***************
*** 51,53 ****
--- 51,54 ----
  #undef TARGET_C99_FUNCTIONS
  #define TARGET_C99_FUNCTIONS  1
  
+ #define MD_UNWIND_SUPPORT "config/alpha/osf5-unwind.h"
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/alpha/osf5-unwind.h	2006-03-14 10:56:47.294034368 +0100
***************
*** 0 ****
--- 1,403 ----
+ /* DWARF2 EH unwinding support for Alpha Tru64 5.
+    Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ /* This file implements the MD_FALLBACK_FRAME_STATE_FOR macro, triggered when
+    the GCC table based unwinding process hits a frame for which no unwind info
+    has been registered. This typically occurs when raising an exception from a
+    signal handler, because the handler is actually called from the OS kernel.
+ 
+    The basic idea is to detect that we are indeed trying to unwind past a
+    signal handler and to fill out the GCC internal unwinding structures for
+    the OS kernel frame as if it had been directly called from the interrupted
+    context.
+ 
+    This is all assuming that the code to set the handler asked the kernel to
+    pass a pointer to such context information.  */
+ 
+ /* --------------------------------------------------------------------------
+    -- Basic principles of operation:
+    --------------------------------------------------------------------------
+ 
+    1/ We first need a way to detect if we are trying to unwind past a signal
+       handler.
+ 
+    The typical method that is used on most platforms is to look at the code
+    around the return address we have and check if it matches the OS code
+    calling a handler.  To determine what this code is expected to be, get a
+    breakpoint into a real signal handler and look at the code around the
+    return address.  Depending on the library versions the pattern of the
+    signal handler is different; this is the reason why we check against more
+    than one pattern.
+ 
+    On this target, the return address is right after the call and every
+    instruction is 4 bytes long.  For the simple case of a null dereference in
+    a single-threaded app, it went like:
+ 
+    # Check that we indeed have something we expect: the instruction right
+    # before the return address is within a __sigtramp function and is a call.
+ 
+    [... run gdb and break at the signal handler entry ...]
+ 
+    (gdb) x /i $ra-4
+    <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>
+ 
+    # Look at the code around that return address, and eventually observe a
+    # significantly large chunk of *constant* code right before the call:
+ 
+    (gdb) x /10i  $ra-44
+    <__sigtramp+120>: lda     gp,-27988(gp)
+    <__sigtramp+124>: ldq     at,-18968(gp)
+    <__sigtramp+128>: lda     t0,-1
+    <__sigtramp+132>: stq     t0,0(at)
+    <__sigtramp+136>: ldq     at,-18960(gp)
+    <__sigtramp+140>: ldl     t1,8(at)
+    <__sigtramp+144>: ldq     at,-18960(gp)
+    <__sigtramp+148>: stl     t1,12(at)
+    <__sigtramp+152>: ldq     at,-18960(gp)
+    <__sigtramp+156>: stl     t0,8(at)
+    
+    # The hexadecimal equivalent that we will have to match is:
+ 
+    (gdb) x /10x  $ra-44
+    <__sigtramp+120>: 0x23bd92ac    0xa79db5e8    0x203fffff   0xb43c0000
+    <__sigtramp+136>: 0xa79db5f0    0xa05c0008    0xa79db5f0   0xb05c000c
+    <__sigtramp+152>: 0xa79db5f0    0xb03c0008
+    
+    The problem observed on this target with this approach is that although
+    we found a constant set of instruction patterns there were some
+    gp-related offsets that made the machine code to differ from one
+    installation to another.  This problem could have been overcome by masking
+    these offsets, but we found that it would be simpler and more efficient to
+    check whether the return address was part of a signal handler, by comparing
+    it against some expected code offset from __sigtramp.
+ 
+    # Check that we indeed have something we expect: the instruction
+    # right before the return address is within a __sigtramp
+    # function and is a call. We also need to obtain the offset
+    # between the return address and the start address of __sigtramp.
+ 
+    [... run gdb and break at the signal handler entry ...]
+ 
+    (gdb) x /2i $ra-4
+    <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>
+    <__sigtramp+164>: ldah    gp,16381(ra)
+ 
+    (gdb) p (long)$ra - (long)&__sigtramp
+    $2 = 164
+ 
+    --------------------------------------------------------------------------
+ 
+    2/ Once we know we are going through a signal handler, we need a way to
+       retrieve information about the interrupted run-time context.
+ 
+    On this platform, the third handler's argument is a pointer to a structure
+    describing this context (struct sigcontext *). We unfortunately have no
+    direct way to transfer this value here, so a couple of tricks are required
+    to compute it.
+ 
+    As documented at least in some header files (e.g. sys/machine/context.h),
+    the structure the handler gets a pointer to is located on the stack.  As of
+    today, while writing this macro, we have unfortunately not been able to
+    find a detailed description of the full stack layout at handler entry time,
+    so we'll have to resort to empirism :)
+ 
+    When unwinding here, we have the handler's CFA at hand, as part of the
+    current unwinding context which is one of our arguments.  We presume that
+    for each call to a signal handler by the same kernel routine, the context's
+    structure location on the stack is always at the same offset from the
+    handler's CFA, and we compute that offset from bare observation:
+    
+    For the simple case of a bare null dereference in a single-threaded app,
+    computing the offset was done using GNAT like this:
+ 
+    # Break on the first handler's instruction, before the prologue to have the
+    # CFA in $sp, and get there:
+ 
+    (gdb) b *&__gnat_error_handler
+    Breakpoint 1 at 0x120016090: file init.c, line 378.
+ 
+    (gdb) r
+    Program received signal SIGSEGV, Segmentation fault.
+ 
+    (gdb) c
+    Breakpoint 1, __gnat_error_handler (sig=..., sip=..., context=...)
+ 
+    # The displayed argument value are meaningless because we stopped before
+    # their final "homing". We know they are passed through $a0, $a1 and $a2
+    # from the ABI, though, so ...
+ 
+    # Observe that $sp and the context pointer are in the same (stack) area,
+    # and compute the offset:
+ 
+    (gdb) p /x $sp
+    $2 = 0x11fffbc80
+ 
+    (gdb) p /x $a2
+    $3 = 0x11fffbcf8
+ 
+    (gdb) p /x (long)$a2 - (long)$sp
+    $4 = 0x78
+    
+    --------------------------------------------------------------------------
+ 
+    3/ Once we know we are unwinding through a signal handler and have the
+       address of the structure describing the interrupted context at hand, we
+       have to fill the internal frame-state/unwind-context structures properly
+       to allow the unwinding process to proceed.
+ 
+    Roughly, we are provided with an *unwinding* CONTEXT, describing the state
+    of some point P in the call chain we are unwinding through.  The macro we
+    implement has to fill a "frame state" structure FS that describe the P's
+    caller state, by way of *rules* to compute its CFA, return address, and
+    **saved** registers *locations*. 
+ 
+    For the case we are going to deal with, the caller is some kernel code
+    calling a signal handler, and:
+ 
+    o The saved registers are all in the interrupted run-time context,
+ 
+    o The CFA is the stack pointer value when the kernel code is entered, that
+      is, the stack pointer value at the interruption point, also part of the
+      interrupted run-time context.
+ 
+    o We want the return address to appear as the address of the active
+      instruction at the interruption point, so that the unwinder proceeds as
+      if the interruption had been a regular call.  This address is also part
+      of the interrupted run-time context.
+ 
+    --
+ 
+    Despite the apparent simplicity of the rules above, a trick is played to
+    deal with the kernel frame "return address", because what we typically get
+    in a signal context is not really a return address but some of functions in
+    the general unwinder think it is.
+ 
+    The basic issue is that...
+ 
+    o The generic unwinding engine is expecting to deal with a call return
+      address, because that is the nominal case. It is however actually
+      interested in what region the call itself pertains to, so it substracts 1
+      to the frame_state's "return address" and uses that to search the unwind
+      table (see e.g. uw_frame_state_for).
+    
+    o The address we get for a signal context is not a return address but the
+      address of a faulting instruction, which we want to use *untouched* to
+      search the tables.
+ 
+    o There is currently no provision in the generic unwinder to allow
+      differentiating the two cases.
+ 
+    What we do here is we cheat by adjusting the faulting address *value* by 1
+    at the place where it is saved in the sigcontext structure to compensate.
+    Note that we must account for the fact that we may be called more than once
+    for the same context and ensure the adjustment remains constant. We exploit
+    the fact that instruction address are normally always multiple of 4 here,
+    and only adjust if it (still) the case.
+ 
+    Something that needs to be taken into account is that floating point traps
+    are imprecise in the Alpha architecture.  Hence, software assistance
+    is needed for determining the exact location that caused the floating point
+    trap, so that the return address that is stored in the sigcontext structure
+    is *exactly* the faulting address.  It can be achieved by using the
+    "-mtrap-precision=i" GCC command option, so that the trap handler can
+    determine the exact instruction that caused the floating point exception,
+    and then the unwinding mechanism works appropriately.  Not specifying this
+    command option results in the unwinder not using the address of the
+    instruction that triggered the trap but the one where the trap was
+    delivered, that can be placed an arbitrary number of instructions after the
+    trigger instruction, so that we may indeed unwind to the wrong place. Note
+    that, in the case of programs that may cause floating point exceptions, it
+    could be more efficient to use the "-mieee" GCC command option so that
+    the generated code is able to correctly support denormalized numbers and
+    exceptional IEEE values without generating traps.
+ 
+    --
+ 
+    Also, note that there is an important difference between the return address
+    we need to claim for the kernel frame and the value of the return address
+    register at the interruption point.
+ 
+    The latter might be required to be able to unwind past the interrupted
+    routine, for instance if it is interrupted before saving the incoming
+    register value in its own frame, which may typically happen during stack
+    probes for stack-checking purposes.
+ 
+    It is then essential that the rules stated to locate the kernel frame
+    return address don't clobber the rules describing where is saved the return
+    address register at the interruption point, so some scratch register state
+    entry should be used for the former. We have DWARF_ALT_FRAME_RETURN_COLUMN
+    at hand exactly for that purpose.
+ 
+    --------------------------------------------------------------------------
+ 
+    4/ Depending on the context (single-threaded or multi-threaded app, ...),
+    the code calling the handler and the handler-cfa to interrupted-context
+    offset might change, so we use a simple generic data structure to track
+    the possible variants.  */
+ 
+ /* This is the structure to wrap information about each possible sighandler
+    caller we may have to identify.  */
+ 
+ typedef struct {
+   /* Expected return address when being called from a sighandler.  */
+   void *ra_value;
+ 
+   /* Offset to get to the sigcontext structure from the handler's CFA
+      when the pattern matches.  */
+   int cfa_to_context_offset;
+ 
+ } sighandler_call_t;
+ 
+ /* Helper macro for MD_FALLBACK_FRAME_STATE_FOR below.
+ 
+    Look at RA to see if it matches within a sighandler caller.
+    Set SIGCTX to the corresponding sigcontext structure (computed from
+    CFA) if it does, or to 0 otherwise.  */
+ 
+ #define COMPUTE_SIGCONTEXT_FOR(RA,CFA,SIGCTX)				    \
+ do {									    \
+   /* Define and register the applicable patterns.  */			    \
+   extern void __sigtramp (void);					    \
+ 									    \
+   sighandler_call_t sighandler_calls [] = {				    \
+     {__sigtramp + 164, 0x78}						    \
+   };									    \
+ 									    \
+   int n_patterns_to_match						    \
+     = sizeof (sighandler_calls) / sizeof (sighandler_call_t);		    \
+ 									    \
+   int pn;  /* pattern number  */					    \
+ 									    \
+   int match = 0;  /* Did last pattern match ?  */			    \
+ 									    \
+   /* Try to match each pattern in turn.  */				    \
+   for (pn = 0; !match && pn < n_patterns_to_match; pn ++)		    \
+     match = ((RA) == sighandler_calls[pn].ra_value);			    \
+ 									    \
+   (SIGCTX) = (struct sigcontext *)					    \
+     (match ? ((CFA) + sighandler_calls[pn - 1].cfa_to_context_offset) : 0); \
+ } while (0);
+ 
+ #include <sys/context_t.h>
+ 
+ #define REG_SP  30  /* hard reg for stack pointer */
+ #define REG_RA  26  /* hard reg for return address */
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ alpha_fallback_frame_state (struct _Unwind_Context *context,
+ 			    _Unwind_FrameState *fs)
+ {
+   char *eh_debug_env = getenv ("EH_DEBUG");
+   int eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+ 
+   /* Return address and CFA of the frame we're attempting to unwind through,
+      possibly a signal handler.  */
+   void *ctx_ra  = (void *)context->ra;
+   void *ctx_cfa = (void *)context->cfa;
+ 
+   /* CFA of the intermediate abstract kernel frame between the interrupted
+      code and the signal handler, if we're indeed unwinding through a signal
+      handler.  */
+   void *k_cfa;
+ 
+   /* Pointer to the sigcontext structure pushed by the kernel when we're
+      unwinding through a signal handler.  */
+   struct sigcontext *sigctx;
+   int i;
+ 
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n", ctx_cfa, ctx_ra);
+ 
+   COMPUTE_SIGCONTEXT_FOR (ctx_ra, ctx_cfa, sigctx);
+ 
+   if (sigctx == 0)
+     return _URC_END_OF_STACK;
+ 
+   /* The kernel frame's CFA is exactly the stack pointer value at the
+      interruption point.  */
+   k_cfa = (void *) sigctx->sc_regs [REG_SP];
+ 
+   if (eh_debug)
+     printf ("Match for K_CFA = 0x%p, SIGCTX @ 0x%p\n", k_cfa, sigctx);
+ 
+   /* State the rules to compute the CFA we have the value of: use the
+      previous CFA and offset by the difference between the two.  See
+      uw_update_context_1 for the supporting details.  */
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = __builtin_dwarf_sp_column ();
+   fs->cfa_offset = k_cfa - ctx_cfa;
+ 
+   /* Fill the internal frame_state structure with information stating
+      where each register of interest in the saved context can be found
+      from the CFA.  */
+ 
+   /* The general registers are in sigctx->sc_regs.  Leave out r31, which
+      is read-as-zero. It makes no sense restoring it, and we are going to
+      use the state entry for the kernel return address rule below.
+ 
+      This loop must cover at least all the callee-saved registers, and
+      we just don't bother specializing the set here.  */
+   for (i = 0; i <= 30; i ++)
+     {
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset
+ 	= (void *) &sigctx->sc_regs[i] - (void *) k_cfa;
+     }
+ 
+   /* Ditto for the floating point registers in sigctx->sc_fpregs.  */
+   for (i = 0; i <= 31; i ++)
+     {
+       fs->regs.reg[32+i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[32+i].loc.offset
+ 	= (void *) &sigctx->sc_fpregs[i] - (void *) k_cfa;
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which
+      is the address of the active instruction when the signal was caught,
+      in sigctx->sc_pc. Use DWARF_ALT_FRAME_RETURN_COLUMN since the return
+      address register is a general register and should be left alone.  */
+   fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
+   fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;
+   fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset
+     = (void *) &sigctx->sc_pc - (void *) k_cfa;
+ 
+   /* Trick its value to compensate for later adjustments from the generic
+      unwinding circuitry, which thinks it is a real return address. We
+      may be called more than once for the same context, so take care not
+      to perform the adjustment multiple times. We exploit the fact that
+      instruction addresses are normally always multiple of 4 here.  */
+   if ((sigctx->sc_pc & 0x3) == 0)
+     sigctx->sc_pc +=1;
+ 
+   return _URC_NO_REASON;
+ }
*** gcc/config/mips/iris6.h.0	2006-03-14 08:01:27.096347512 +0100
--- gcc/config/mips/iris6.h	2006-03-14 08:02:08.002128888 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 85,90 ****
--- 85,92 ----
  #define SUBTARGET_WARN_UNUSED_SPEC "-warn_unused"
  #endif
  
+ #define MD_UNWIND_SUPPORT "config/mips/iris6-unwind.h"
+ 
  #undef LIB_SPEC
  #define LIB_SPEC \
    "%{mabi=n32: %{mips4:-L/usr/lib32/mips4} %{!mips4:-L/usr/lib32/mips3} \
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/mips/iris6-unwind.h	2006-03-14 10:51:23.181306992 +0100
***************
*** 0 ****
--- 1,150 ----
+ /* DWARF2 EH unwinding support for MIPS Irix 6.
+    Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #include <signal.h>
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR mips_fallback_frame_state
+ 
+ #define UINT_AT(ADDR) (*(unsigned int *)(ADDR))
+ 
+ /* Look at the code around RA to see if it matches a sighandler caller with a
+    sigcontext_t * argument (SA_SIGINFO cleared).  Return that pointer argument
+    if it does match, or 0 otherwise.  */
+ 
+ static sigcontext_t *
+ sigcontext_for (void *ra, void *cfa)
+ {
+   /* IRIX 6.5, mono-threaded application.  */
+   if (UINT_AT (ra - 40) == 0x00e0c825
+       && UINT_AT (ra - 36) == 0x658cd38c
+       && UINT_AT (ra - 32) == 0x019f602d
+       && UINT_AT (ra - 28) == 0x0300f825
+       && UINT_AT (ra - 24) == 0x8d8c9744
+       && UINT_AT (ra - 20) == 0x8d8c0000
+       && UINT_AT (ra - 16) == 0x8d8d0000
+       && UINT_AT (ra - 12) == 0xffac0008
+       && UINT_AT (ra - 8)  == 0x0320f809
+       && UINT_AT (ra - 4)  == 0xffad0010)
+     return (sigcontext_t *)(cfa + 0x30);
+ 
+   /* IRIX 6.5, multi-threaded application, pthreads.  */
+   if (UINT_AT (ra - 40) == 0xffb00000
+       && UINT_AT (ra - 36) == 0x0004f880
+       && UINT_AT (ra - 32) == 0x27399058
+       && UINT_AT (ra - 28) == 0x8c300edc
+       && UINT_AT (ra - 24) == 0x033fc821
+       && UINT_AT (ra - 20) == 0x8f390000
+       && UINT_AT (ra - 16) == 0xdc210e70
+       && UINT_AT (ra - 12) == 0xde120058
+       && UINT_AT (ra - 8)  == 0x0320f809
+       && UINT_AT (ra - 4)  == 0xfe010058)
+     return (sigcontext_t *)(cfa + 0x60);
+ 
+   return 0;
+ }
+ 
+ #define SIGCTX_GREG_ADDR(REGNO,SIGCTX) \
+   ((void *) &(SIGCTX)->sc_regs[REGNO])
+ 
+ #define SIGCTX_FPREG_ADDR(REGNO,SIGCTX) \
+   ((void *) &(SIGCTX)->sc_fpregs[REGNO])
+ 
+ static _Unwind_Reason_Code
+ mips_fallback_frame_state (struct _Unwind_Context *context,
+ 			   _Unwind_FrameState *fs)
+ {
+   char *eh_debug_env = getenv ("EH_DEBUG");
+   int eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+ 
+   /* Return address and CFA of the frame we're attempting to unwind through,
+      possibly a signal handler.  */
+   void *ctx_ra  = (void *)context->ra;
+   void *ctx_cfa = (void *)context->cfa;
+ 
+   /* CFA of the intermediate abstract kernel frame between the interrupted
+      code and the signal handler, if we're indeed unwinding through a signal
+      handler.  */
+   void *k_cfa;
+ 
+   /* Pointer to the sigcontext_t structure pushed by the kernel when we're
+      unwinding through a signal handler setup with SA_SIGINFO cleared.  */
+   sigcontext_t *sigctx;
+   int i;
+ 
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n", ctx_cfa, ctx_ra);
+ 
+   sigctx = sigcontext_for (ctx_ra, ctx_cfa);
+ 
+   if (sigctx == 0)
+     return _URC_END_OF_STACK;
+ 
+   /* The abstract kernel frame's CFA is extactly the stack pointer
+      value at the interruption point.  */
+   k_cfa = *(void **)SIGCTX_GREG_ADDR (CTX_SP, sigctx);
+ 
+   if (eh_debug)
+     printf ("Match for K_CFA = 0x%p, SIGCTX @ 0x%p\n", k_cfa, sigctx);
+ 
+   /* State the rules to compute the CFA we have the value of: use the
+      previous CFA and offset by the difference between the two.  See
+      uw_update_context_1 for the supporting details.  */
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = __builtin_dwarf_sp_column ();
+   fs->cfa_offset = k_cfa - ctx_cfa;
+ 
+   /* Fill the internal frame_state structure with information stating where
+      each register of interest can be found from the CFA.  */
+   for (i = 0; i <= 31; i ++)
+     {
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset = SIGCTX_GREG_ADDR (i, sigctx) - k_cfa;
+     }
+ 
+   for (i = 0; i <= 31; i ++)
+     {
+       fs->regs.reg[32+i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[32+i].loc.offset = SIGCTX_FPREG_ADDR (i, sigctx) - k_cfa;
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which is the
+      address of the active instruction when the signal was caught.  Cheat two
+      call clobbered register slots (that we don't care restoring properly) to
+      account for the unwinder's adjustments caused by it expecting to have a
+      call return address at hand.  */
+   sigctx->sc_regs [CTX_T0] = sigctx->sc_pc + 4;
+ 
+   fs->retaddr_column = CTX_T1;
+   fs->regs.reg[CTX_T1].how = REG_SAVED_OFFSET;
+   fs->regs.reg[CTX_T1].loc.offset = SIGCTX_GREG_ADDR (CTX_T0, sigctx) - k_cfa;
+    
+   return _URC_NO_REASON;
+ }
*** gcc/config/ia64/unwind-ia64.c.0	2006-03-14 09:17:36.579680456 +0100
--- gcc/config/ia64/unwind-ia64.c	2006-03-14 09:17:58.150401208 +0100
*************** struct _Unwind_Context
*** 208,213 ****
--- 208,216 ----
    unsigned long *pfs_loc;	/* Save location for pfs in current
    				   (corr. to sp) frame.  Target
    				   contains cfm for caller.	*/
+   unsigned long *signal_pfs_loc;/* Save location for pfs in current
+ 				   signal frame.  Target contains
+ 				   pfs for caller.  */
    unsigned long *pri_unat_loc;
    unsigned long *unat_loc;
    unsigned long *lc_loc;
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1783,1788 ****
--- 1786,1792 ----
  #ifdef MD_FALLBACK_FRAME_STATE_FOR
        if (MD_FALLBACK_FRAME_STATE_FOR (context, fs) == _URC_NO_REASON)
  	return _URC_NO_REASON;
+ #endif
  
        /* [SCRA 11.4.1] A leaf function with no memory stack, no exception
  	 handlers, and which keeps the return value in B0 does not need
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1791,1805 ****
  	 This can only happen in the frame after unwinding through a signal
  	 handler.  Avoid infinite looping by requiring that B0 != RP.
  	 RP == 0 terminates the chain.  */
!       if (context->br_loc[0] && *context->br_loc[0] != context->rp
  	  && context->rp != 0)
! 	{
! 	  fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
! 	  fs->curr.reg[UNW_REG_RP].when = -1;
! 	  fs->curr.reg[UNW_REG_RP].val = 0;
! 	  return _URC_NO_REASON;
! 	}
! #endif
        return _URC_END_OF_STACK;
      }
  
--- 1795,1805 ----
  	 This can only happen in the frame after unwinding through a signal
  	 handler.  Avoid infinite looping by requiring that B0 != RP.
  	 RP == 0 terminates the chain.  */
!       if (context->br_loc[0]
! 	  && *context->br_loc[0] != context->rp
  	  && context->rp != 0)
! 	goto skip_unwind_info;
! 
        return _URC_END_OF_STACK;
      }
  
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1847,1853 ****
  	  r->where = UNW_WHERE_NONE;
      }
  
!   /* If RP did't get saved, generate entry for the return link register.  */
    if (fs->curr.reg[UNW_REG_RP].when >= fs->when_target)
      {
        fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
--- 1847,1854 ----
  	  r->where = UNW_WHERE_NONE;
      }
  
! skip_unwind_info:
!   /* If RP didn't get saved, generate entry for the return link register.  */
    if (fs->curr.reg[UNW_REG_RP].when >= fs->when_target)
      {
        fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
*************** uw_frame_state_for (struct _Unwind_Conte
*** 1855,1860 ****
--- 1856,1882 ----
        fs->curr.reg[UNW_REG_RP].val = fs->return_link_reg;
      }
  
+   /* There is a subtlety for the frame after unwinding through a signal
+      handler: should we restore the cfm as usual or the pfs?  We can't
+      restore both because we use br.ret to resume execution of user code.
+      For other frames the procedure is by definition non-leaf so the pfs
+      is saved and restored and thus effectively dead in the body; only
+      the cfm need therefore be restored.
+      
+      Here we have 2 cases:
+        - either the pfs is saved and restored and thus effectively dead
+ 	 like in regular frames; then we do nothing special and restore
+ 	 the cfm.
+        - or the pfs is not saved and thus live; but in that case the
+ 	 procedure is necessarily leaf so the cfm is effectively dead
+ 	 and we restore the pfs.  */
+   if (context->signal_pfs_loc)
+     {
+       if (fs->curr.reg[UNW_REG_PFS].when >= fs->when_target)
+ 	context->pfs_loc = context->signal_pfs_loc;
+       context->signal_pfs_loc = NULL;
+     }
+ 
    return _URC_NO_REASON;
  }
  
*** gcc/config/ia64/linux-unwind.h.0	2006-03-14 09:17:25.809317800 +0100
--- gcc/config/ia64/linux-unwind.h	2006-03-14 09:17:58.150401208 +0100
***************
*** 1,4 ****
! /* DWARF2 EH unwinding support for IA64 Linux.
     Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
     This file is part of GCC.
--- 1,4 ----
! /* EH unwinding support for IA-64/Linux.
     Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
     This file is part of GCC.
***************
*** 27,33 ****
     MA 02110-1301, USA.  */
  
  /* Do code reading to identify a signal frame, and set the frame
!    state data appropriately.  See unwind-dw2.c for the structs.  */
  
  /* This works only for glibc-2.3 and later, because sigcontext is different
     in glibc-2.2.4.  */
--- 27,33 ----
     MA 02110-1301, USA.  */
  
  /* Do code reading to identify a signal frame, and set the frame
!    state data appropriately.  See unwind-ia64.c for the structs.  */
  
  /* This works only for glibc-2.3 and later, because sigcontext is different
     in glibc-2.2.4.  */
*************** ia64_fallback_frame_state (struct _Unwin
*** 70,76 ****
        }
  
        context->fpsr_loc = &(sc->sc_ar_fpsr);
!       context->pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
--- 70,76 ----
        }
  
        context->fpsr_loc = &(sc->sc_ar_fpsr);
!       context->signal_pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
*************** ia64_fallback_frame_state (struct _Unwin
*** 109,119 ****
--- 109,125 ----
  	  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);
        }
  
+       /* Account for use of br.ret to resume execution of user code. */
        fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_SPREL;
        fs->curr.reg[UNW_REG_RP].val
  	= (unsigned long)&(sc->sc_ip) - context->psp;
        fs->curr.reg[UNW_REG_RP].when = -1;
  
+       fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_SPREL;
+       fs->curr.reg[UNW_REG_PFS].val
+ 	= (unsigned long)&(sc->sc_cfm) - context->psp;
+       fs ->curr.reg[UNW_REG_PFS].when = -1;
+ 
        return _URC_NO_REASON;
      }
    return _URC_END_OF_STACK;
*************** ia64_fallback_frame_state (struct _Unwin
*** 121,131 ****
  
  #define MD_HANDLE_UNWABI ia64_handle_unwabi
  
  static void
  ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)
  {
!   if (fs->unwabi == ((3 << 8) | 's')
!       || fs->unwabi == ((0 << 8) | 's'))
      {
        struct sigframe {
  	char scratch[16];
--- 127,142 ----
  
  #define MD_HANDLE_UNWABI ia64_handle_unwabi
  
+ #define ABI_MARKER_OLD_LINUX_SIGTRAMP	((0 << 8) | 's')
+ #define ABI_MARKER_OLD_LINUX_INTERRUPT	((0 << 8) | 'i')
+ #define ABI_MARKER_LINUX_SIGTRAMP	((3 << 8) | 's')
+ #define ABI_MARKER_LINUX_INTERRUPT	((3 << 8) | 'i')
+ 
  static void
  ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)
  {
!   if (fs->unwabi == ABI_MARKER_LINUX_SIGTRAMP
!       || fs->unwabi == ABI_MARKER_OLD_LINUX_SIGTRAMP)
      {
        struct sigframe {
  	char scratch[16];
*************** ia64_handle_unwabi (struct _Unwind_Conte
*** 148,154 ****
  	  context->ireg[i - 2].loc = &sc->sc_gr[i];
        }
  
!       context->pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
--- 159,165 ----
  	  context->ireg[i - 2].loc = &sc->sc_gr[i];
        }
  
!       context->signal_pfs_loc = &(sc->sc_ar_pfs);
        context->lc_loc = &(sc->sc_ar_lc);
        context->unat_loc = &(sc->sc_ar_unat);
        context->br_loc[0] = &(sc->sc_br[0]);
*************** ia64_handle_unwabi (struct _Unwind_Conte
*** 185,193 ****
  	  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);
        }
  
!       /* pfs_loc already set above.  Without this pfs_loc would point
! 	 incorrectly to sc_cfm instead of sc_ar_pfs.  */
!       fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_NONE;
      }
  }
  #endif /* glibc-2.3 or better */
--- 196,203 ----
  	  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);
        }
  
!       /* The use of br.ret to resume execution of user code is already
! 	 accounted for in the unwind ABI.  */
      }
  }
  #endif /* glibc-2.3 or better */
*** gcc/except.h.0	2006-03-20 10:13:31.000000000 +0100
--- gcc/except.h	2006-03-20 19:58:38.121445688 +0100
*************** extern void convert_from_eh_region_range
*** 68,74 ****
  extern void convert_to_eh_region_ranges (void);
  extern void find_exception_handler_labels (void);
  extern bool current_function_has_exception_handlers (void);
! extern void output_function_exception_table (void);
  
  extern void expand_builtin_unwind_init (void);
  extern rtx expand_builtin_eh_return_data_regno (tree);
--- 68,74 ----
  extern void convert_to_eh_region_ranges (void);
  extern void find_exception_handler_labels (void);
  extern bool current_function_has_exception_handlers (void);
! extern void output_function_exception_table (const char *);
  
  extern void expand_builtin_unwind_init (void);
  extern rtx expand_builtin_eh_return_data_regno (tree);
*** gcc/output.h.0	2006-03-20 10:14:19.000000000 +0100
--- gcc/output.h	2006-03-20 19:58:38.122445536 +0100
*************** extern const char *user_label_prefix;
*** 477,483 ****
  extern void default_function_pro_epilogue (FILE *, HOST_WIDE_INT);
  
  /* Tell assembler to switch to the section for the exception table.  */
! extern void default_exception_section (void);
  
  /* Tell assembler to switch to the section for the EH frames.  */
  extern void named_section_eh_frame_section (void);
--- 477,483 ----
  extern void default_function_pro_epilogue (FILE *, HOST_WIDE_INT);
  
  /* Tell assembler to switch to the section for the exception table.  */
! extern void default_exception_section (const char *);
  
  /* Tell assembler to switch to the section for the EH frames.  */
  extern void named_section_eh_frame_section (void);
*** gcc/target.h.0	2006-03-20 10:15:09.000000000 +0100
--- gcc/target.h	2006-03-20 19:58:38.124445232 +0100
*************** struct gcc_target
*** 118,124 ****
      void (* named_section) (const char *name, unsigned int flags, tree decl);
  
      /* Switch to the section that holds the exception table.  */
!     void (* exception_section) (void);
  
      /* Switch to the section that holds the exception frames.  */
      void (* eh_frame_section) (void);
--- 118,124 ----
      void (* named_section) (const char *name, unsigned int flags, tree decl);
  
      /* Switch to the section that holds the exception table.  */
!     void (* exception_section) (const char *);
  
      /* Switch to the section that holds the exception frames.  */
      void (* eh_frame_section) (void);
*** gcc/except.c.0	2006-03-20 10:09:58.000000000 +0100
--- gcc/except.c	2006-03-20 19:58:38.128444624 +0100
*************** sjlj_output_call_site_table (void)
*** 3435,3441 ****
     table.  */
  
  void
! default_exception_section (void)
  {
    if (targetm.have_named_sections)
      {
--- 3435,3441 ----
     table.  */
  
  void
! default_exception_section (const char *fnname ATTRIBUTE_UNUSED)
  {
    if (targetm.have_named_sections)
      {
*************** default_exception_section (void)
*** 3452,3458 ****
  	}
        else
  	flags = SECTION_WRITE;
!       named_section_flags (".gcc_except_table", flags);
      }
    else if (flag_pic)
      data_section ();
--- 3452,3468 ----
  	}
        else
  	flags = SECTION_WRITE;
! #ifdef HAVE_LD_EH_GC_SECTIONS
!       if (flag_function_sections)
! 	{
! 	  char *section_name = xmalloc (strlen (fnname) + 32);
! 	  sprintf (section_name, ".gcc_except_table.%s", fnname);
! 	  named_section_flags (section_name, flags);
! 	  free (section_name);
! 	}
!       else
! #endif
! 	named_section_flags (".gcc_except_table", flags);
      }
    else if (flag_pic)
      data_section ();
*************** output_ttype (tree type, int tt_format, 
*** 3511,3517 ****
  }
  
  void
! output_function_exception_table (void)
  {
    int tt_format, cs_format, lp_format, i, n;
  #ifdef HAVE_AS_LEB128
--- 3521,3527 ----
  }
  
  void
! output_function_exception_table (const char *fnname ATTRIBUTE_UNUSED)
  {
    int tt_format, cs_format, lp_format, i, n;
  #ifdef HAVE_AS_LEB128
*************** output_function_exception_table (void)
*** 3539,3545 ****
    /* Note that varasm still thinks we're in the function's code section.
       The ".endp" directive that will immediately follow will take us back.  */
  #else
!   targetm.asm_out.exception_section ();
  #endif
  
    have_tt_data = (VEC_length (tree, cfun->eh->ttype_data) > 0
--- 3549,3555 ----
    /* Note that varasm still thinks we're in the function's code section.
       The ".endp" directive that will immediately follow will take us back.  */
  #else
!   targetm.asm_out.exception_section (fnname);
  #endif
  
    have_tt_data = (VEC_length (tree, cfun->eh->ttype_data) > 0
*** gcc/final.c.0	2006-03-20 10:16:48.000000000 +0100
--- gcc/final.c	2006-03-20 19:58:38.132444016 +0100
*************** rest_of_handle_final (void)
*** 3950,3963 ****
  #ifdef TARGET_UNWIND_INFO
    /* ??? The IA-64 ".handlerdata" directive must be issued before
       the ".endp" directive that closes the procedure descriptor.  */
!   output_function_exception_table ();
  #endif
  
    assemble_end_function (current_function_decl, fnname);
  
  #ifndef TARGET_UNWIND_INFO
    /* Otherwise, it feels unclean to switch sections in the middle.  */
!   output_function_exception_table ();
  #endif
  
    user_defined_section_attribute = false;
--- 3950,3963 ----
  #ifdef TARGET_UNWIND_INFO
    /* ??? The IA-64 ".handlerdata" directive must be issued before
       the ".endp" directive that closes the procedure descriptor.  */
!   output_function_exception_table (fnname);
  #endif
  
    assemble_end_function (current_function_decl, fnname);
  
  #ifndef TARGET_UNWIND_INFO
    /* Otherwise, it feels unclean to switch sections in the middle.  */
!   output_function_exception_table (fnname);
  #endif
  
    user_defined_section_attribute = false;
*** gcc/configure.ac.0	2006-03-20 10:17:39.000000000 +0100
--- gcc/configure.ac	2006-03-20 20:01:14.239712104 +0100
*************** if test x"$gcc_cv_ld_pie" = xyes; then
*** 3001,3006 ****
--- 3001,3049 ----
  fi
  AC_MSG_RESULT($gcc_cv_ld_pie)
  
+ AC_MSG_CHECKING(linker EH-compatible garbage collection of sections)
+ gcc_cv_ld_eh_gc_sections=no
+ if test $in_tree_ld = yes ; then
+   if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge 17 -o "$gcc_cv_gld_major_version" -gt 2 \
+      && test $in_tree_ld_is_elf = yes; then
+     gcc_cv_ld_eh_gc_sections=yes
+   fi
+ elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then
+   cat > conftest.s <<EOF
+ 	.section	.text
+ .globl _start
+         .type _start, @function
+ _start:
+ 	.long foo
+ 	.size _start, .-_start
+ 	.section	.text.foo,"ax",@progbits
+ 	.type foo, @function
+ foo:
+ 	.long 0
+ 	.size foo, .-foo
+ 	.section	.gcc_except_table.foo,"a",@progbits
+ .L0:
+ 	.long 0
+ 	.section	.eh_frame,"a",@progbits
+ 	.long .L0
+ EOF
+   if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then
+     if $gcc_cv_ld -o conftest conftest.o --entry=_start --gc-sections 2>&1 \
+ 	 | grep "gc-sections option ignored" > /dev/null; then
+       gcc_cv_ld_eh_gc_sections=no
+     elif $gcc_cv_objdump -h conftest | grep gcc_except_table > /dev/null; then
+       gcc_cv_ld_eh_gc_sections=yes
+     fi
+   fi
+   rm -f conftest.s conftest.o conftest
+ fi
+ if test x$gcc_cv_ld_eh_gc_sections = xyes; then
+ 	AC_DEFINE(HAVE_LD_EH_GC_SECTIONS, 1,
+   [Define if your linker supports garbage collection of
+    sections in presence of EH frames.])
+ fi
+ AC_MSG_RESULT($gcc_cv_ld_eh_gc_sections)
+ 
  # --------
  # UNSORTED
  # --------
*** gcc/config.in.0	2006-03-20 10:17:44.000000000 +0100
--- gcc/config.in	2006-03-20 19:58:38.138443104 +0100
***************
*** 855,860 ****
--- 855,867 ----
  /* Define if your linker supports --eh-frame-hdr option. */
  #undef HAVE_LD_EH_FRAME_HDR
  
+ /* Define if your linker supports garbage collection of sections in presence
+    of EH frames. */
+ #ifndef USED_FOR_TARGET
+ #undef HAVE_LD_EH_GC_SECTIONS
+ #endif
+ 
+ 
  /* Define if your PowerPC64 linker only needs function descriptor syms. */
  #ifndef USED_FOR_TARGET
  #undef HAVE_LD_NO_DOT_SYMS
*** gcc/configure.0	2006-03-20 10:17:50.000000000 +0100
--- gcc/configure	2006-03-20 20:01:21.378626824 +0100
*************** fi
*** 16045,16050 ****
--- 16045,16097 ----
  echo "$as_me:$LINENO: result: $gcc_cv_ld_pie" >&5
  echo "${ECHO_T}$gcc_cv_ld_pie" >&6
  
+ echo "$as_me:$LINENO: checking linker EH-compatible garbage collection of sections" >&5
+ echo $ECHO_N "checking linker EH-compatible garbage collection of sections... $ECHO_C" >&6
+ gcc_cv_ld_eh_gc_sections=no
+ if test $in_tree_ld = yes ; then
+   if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge 17 -o "$gcc_cv_gld_major_version" -gt 2 \
+      && test $in_tree_ld_is_elf = yes; then
+     gcc_cv_ld_eh_gc_sections=yes
+   fi
+ elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then
+   cat > conftest.s <<EOF
+ 	.section	.text
+ .globl _start
+         .type _start, @function
+ _start:
+ 	.long foo
+ 	.size _start, .-_start
+ 	.section	.text.foo,"ax",@progbits
+ 	.type foo, @function
+ foo:
+ 	.long 0
+ 	.size foo, .-foo
+ 	.section	.gcc_except_table.foo,"a",@progbits
+ .L0:
+ 	.long 0
+ 	.section	.eh_frame,"a",@progbits
+ 	.long .L0
+ EOF
+   if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then
+     if $gcc_cv_ld -o conftest conftest.o --entry=_start --gc-sections 2>&1 \
+ 	 | grep "gc-sections option ignored" > /dev/null; then
+       gcc_cv_ld_eh_gc_sections=no
+     elif $gcc_cv_objdump -h conftest | grep gcc_except_table > /dev/null; then
+       gcc_cv_ld_eh_gc_sections=yes
+     fi
+   fi
+   rm -f conftest.s conftest.o conftest
+ fi
+ if test x$gcc_cv_ld_eh_gc_sections = xyes; then
+ 
+ cat >>confdefs.h <<\_ACEOF
+ #define HAVE_LD_EH_GC_SECTIONS 1
+ _ACEOF
+ 
+ fi
+ echo "$as_me:$LINENO: result: $gcc_cv_ld_eh_gc_sections" >&5
+ echo "${ECHO_T}$gcc_cv_ld_eh_gc_sections" >&6
+ 
  # --------
  # UNSORTED
  # --------
*** gcc/tree.c.0	2006-03-19 17:05:45.332145840 +0100
--- gcc/tree.c	2006-03-19 17:08:42.367232416 +0100
*************** walk_type_fields (tree type, walk_tree_f
*** 7083,7097 ****
        WALK_SUBTREE (TYPE_DOMAIN (type));
        break;
  
-     case BOOLEAN_TYPE:
-     case ENUMERAL_TYPE:
-     case INTEGER_TYPE:
-     case CHAR_TYPE:
-     case REAL_TYPE:
-       WALK_SUBTREE (TYPE_MIN_VALUE (type));
-       WALK_SUBTREE (TYPE_MAX_VALUE (type));
-       break;
- 
      case OFFSET_TYPE:
        WALK_SUBTREE (TREE_TYPE (type));
        WALK_SUBTREE (TYPE_OFFSET_BASETYPE (type));
--- 7323,7328 ----
*************** walk_tree (tree *tp, walk_tree_fn func, 
*** 7158,7185 ****
  
    result = lang_hooks.tree_inlining.walk_subtrees (tp, &walk_subtrees, func,
  						   data, pset);
!   if (result || ! walk_subtrees)
      return result;
  
!   /* If this is a DECL_EXPR, walk into various fields of the type that it's
       defining.  We only want to walk into these fields of a type in this
!      case.  Note that decls get walked as part of the processing of a
!      BIND_EXPR.
  
!      ??? Precisely which fields of types that we are supposed to walk in
!      this case vs. the normal case aren't well defined.  */
!   if (code == DECL_EXPR
!       && TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL
!       && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)
      {
        tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));
  
        /* Call the function for the type.  See if it returns anything or
  	 doesn't want us to continue.  If we are to continue, walk both
  	 the normal fields and those for the declaration case.  */
        result = (*func) (type_p, &walk_subtrees, data);
        if (result || !walk_subtrees)
! 	return NULL_TREE;
  
        result = walk_type_fields (*type_p, func, data, pset);
        if (result)
--- 7389,7420 ----
  
    result = lang_hooks.tree_inlining.walk_subtrees (tp, &walk_subtrees, func,
  						   data, pset);
!   if (result || !walk_subtrees)
      return result;
  
!   /* If this is a TYPE_DECL, walk into the fields of the type that it's
       defining.  We only want to walk into these fields of a type in this
!      case and not in the general case of a mere reference to the type.
  
!      The criterion is as follows: if the field can be an expression, it
!      must be walked only here.  That should be in keeping with the fields
!      that are directly gimplified in gimplify_type_sizes in order for the
!      mark/copy-if-shared/unmark machinery of the gimplifier to work with
!      variable-sized types.
! 
!      Note that DECLs get walked as part of processing the BIND_EXPR.  */
!   if (code == DECL_EXPR && TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL)
      {
        tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));
+       if (TREE_CODE (*type_p) == ERROR_MARK)
+ 	return NULL_TREE;
  
        /* Call the function for the type.  See if it returns anything or
  	 doesn't want us to continue.  If we are to continue, walk both
  	 the normal fields and those for the declaration case.  */
        result = (*func) (type_p, &walk_subtrees, data);
        if (result || !walk_subtrees)
! 	return result;
  
        result = walk_type_fields (*type_p, func, data, pset);
        if (result)
*************** walk_tree (tree *tp, walk_tree_fn func, 
*** 7211,7216 ****
--- 7206,7222 ----
  		WALK_SUBTREE (DECL_QUALIFIER (field));
  	    }
  	}
+ 
+       /* Same for scalar types.  */
+       else if (TREE_CODE (*type_p) == BOOLEAN_TYPE
+ 	       || TREE_CODE (*type_p) == ENUMERAL_TYPE
+ 	       || TREE_CODE (*type_p) == INTEGER_TYPE
+ 	       || TREE_CODE (*type_p) == CHAR_TYPE
+ 	       || TREE_CODE (*type_p) == REAL_TYPE)
+ 	{
+ 	  WALK_SUBTREE (TYPE_MIN_VALUE (*type_p));
+ 	  WALK_SUBTREE (TYPE_MAX_VALUE (*type_p));
+ 	}
      }
  
    else if (code != SAVE_EXPR
*** gcc/cp/pt.c.0	2006-03-19 18:42:17.881544480 +0100
--- gcc/cp/pt.c	2006-03-19 18:43:14.857882760 +0100
*************** for_each_template_parm_r (tree *tp, int 
*** 4867,4872 ****
--- 4867,4880 ----
  	return error_mark_node;
        break;
  
+     case INTEGER_TYPE:
+       if (for_each_template_parm (TYPE_MIN_VALUE (t),
+ 				  fn, data, pfd->visited)
+ 	  || for_each_template_parm (TYPE_MAX_VALUE (t),
+ 				     fn, data, pfd->visited))
+ 	return error_mark_node;
+       break;
+ 
      case METHOD_TYPE:
        /* Since we're not going to walk subtrees, we have to do this
  	 explicitly here.  */
*** gcc/config/rs6000/rs6000-protos.h.0	2006-03-23 23:55:09.000000000 +0100
--- gcc/config/rs6000/rs6000-protos.h	2006-03-24 10:59:21.258136752 +0100
*************** extern bool invalid_e500_subreg (rtx, en
*** 42,49 ****
  extern void validate_condition_mode (enum rtx_code, enum machine_mode);
  extern bool legitimate_constant_pool_address_p (rtx);
  extern bool legitimate_indirect_address_p (rtx, int);
- extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);
- extern bool rs6000_legitimate_small_data_p (enum machine_mode, rtx);
  
  extern rtx rs6000_got_register (rtx);
  extern rtx find_addr_reg (rtx);
--- 42,47 ----
*************** extern rtx rs6000_legitimize_address (rt
*** 101,107 ****
--- 99,107 ----
  extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,
  					     int, int, int, int *);
  extern int rs6000_legitimate_address (enum machine_mode, rtx, int);
+ extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);
  extern bool rs6000_mode_dependent_address (rtx);
+ extern bool rs6000_offsettable_memref_p (rtx);
  extern rtx rs6000_return_addr (int, rtx);
  extern void rs6000_output_symbol_ref (FILE*, rtx);
  extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);
*** gcc/config/rs6000/rs6000.c.0	2006-03-23 23:55:09.000000000 +0100
--- gcc/config/rs6000/rs6000.c	2006-03-24 10:59:21.221142376 +0100
*************** static unsigned toc_hash_function (const
*** 590,595 ****
--- 590,596 ----
  static int toc_hash_eq (const void *, const void *);
  static int constant_pool_expr_1 (rtx, int *, int *);
  static bool constant_pool_expr_p (rtx);
+ static bool legitimate_small_data_p (enum machine_mode, rtx);
  static bool legitimate_indexed_address_p (rtx, int);
  static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);
  static struct machine_function * rs6000_init_machine_status (void);
*************** legitimate_constant_pool_address_p (rtx 
*** 2699,2706 ****
  	  && constant_pool_expr_p (XEXP (x, 1)));
  }
  
! bool
! rs6000_legitimate_small_data_p (enum machine_mode mode, rtx x)
  {
    return (DEFAULT_ABI == ABI_V4
  	  && !flag_pic && !TARGET_TOC
--- 2700,2707 ----
  	  && constant_pool_expr_p (XEXP (x, 1)));
  }
  
! static bool
! legitimate_small_data_p (enum machine_mode mode, rtx x)
  {
    return (DEFAULT_ABI == ABI_V4
  	  && !flag_pic && !TARGET_TOC
*************** rs6000_legitimate_address (enum machine_
*** 3490,3496 ****
        && TARGET_UPDATE
        && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))
      return 1;
!   if (rs6000_legitimate_small_data_p (mode, x))
      return 1;
    if (legitimate_constant_pool_address_p (x))
      return 1;
--- 3491,3497 ----
        && TARGET_UPDATE
        && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))
      return 1;
!   if (legitimate_small_data_p (mode, x))
      return 1;
    if (legitimate_constant_pool_address_p (x))
      return 1;
*************** rs6000_mode_dependent_address (rtx addr)
*** 3555,3560 ****
--- 3556,3588 ----
    return false;
  }
  
+ /* More elaborate version of recog's offsettable_memref_p predicate
+    that works around the ??? note of rs6000_mode_dependent_address.
+    In particular it accepts
+ 
+      (mem:DI (plus:SI (reg/f:SI 31 31) (const_int 32760 [0x7ff8])))
+ 
+    in 32-bit mode, that the recog predicate rejects.  */
+ 
+ bool
+ rs6000_offsettable_memref_p (rtx op)
+ {
+   if (!MEM_P (op))
+     return false;
+ 
+   /* First mimic offsettable_memref_p.  */
+   if (offsettable_address_p (1, GET_MODE (op), XEXP (op, 0)))
+     return true;
+ 
+   /* offsettable_address_p invokes rs6000_mode_dependent_address, but
+      the latter predicate knows nothing about the mode of the memory
+      reference and, therefore, assumes that it is the largest supported
+      mode (TFmode).  As a consequence, legitimate offsettable memory
+      references are rejected.  rs6000_legitimate_offset_address_p contains
+      the correct logic for the PLUS case of rs6000_mode_dependent_address.  */
+   return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0), 1);
+ }
+ 
  /* Return number of consecutive hard regs needed starting at reg REGNO
     to hold something of mode MODE.
     This is ordinarily the length in words of a value of mode MODE
*************** rs6000_split_multireg_move (rtx dst, rtx
*** 12445,12451 ****
  			 : gen_adddi3 (breg, breg, delta_rtx));
  	      src = replace_equiv_address (src, breg);
  	    }
! 	  else if (! offsettable_memref_p (src))
  	    {
  	      rtx basereg;
  	      basereg = gen_rtx_REG (Pmode, reg);
--- 12473,12479 ----
  			 : gen_adddi3 (breg, breg, delta_rtx));
  	      src = replace_equiv_address (src, breg);
  	    }
! 	  else if (! rs6000_offsettable_memref_p (src))
  	    {
  	      rtx basereg;
  	      basereg = gen_rtx_REG (Pmode, reg);
*************** rs6000_split_multireg_move (rtx dst, rtx
*** 12498,12504 ****
  	      dst = replace_equiv_address (dst, breg);
  	    }
  	  else
! 	    gcc_assert (offsettable_memref_p (dst));
  	}
  
        for (i = 0; i < nregs; i++)
--- 12526,12532 ----
  	      dst = replace_equiv_address (dst, breg);
  	    }
  	  else
! 	    gcc_assert (rs6000_offsettable_memref_p (dst));
  	}
  
        for (i = 0; i < nregs; i++)
*** gcc/config/rs6000/rs6000.md.0	2006-03-23 23:55:09.000000000 +0100
--- gcc/config/rs6000/rs6000.md	2006-03-24 10:59:21.256137056 +0100
***************
*** 7625,7638 ****
        else
  	return \"mr %0,%1\;mr %L0,%L1\";
      case 1:
!       if (GET_CODE (operands[1]) == MEM
! 	  && (rs6000_legitimate_offset_address_p (DFmode, XEXP (operands[1], 0),
! 			reload_completed || reload_in_progress)
! 	      || rs6000_legitimate_small_data_p (DFmode, XEXP (operands[1], 0))
! 	      || GET_CODE (XEXP (operands[1], 0)) == REG
! 	      || GET_CODE (XEXP (operands[1], 0)) == LO_SUM
! 	      || GET_CODE (XEXP (operands[1], 0)) == PRE_INC
! 	      || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC))
  	{
  	  /* If the low-address word is used in the address, we must load
  	     it last.  Otherwise, load it first.  Note that we cannot have
--- 7625,7635 ----
        else
  	return \"mr %0,%1\;mr %L0,%L1\";
      case 1:
!       if (rs6000_offsettable_memref_p (operands[1])
! 	  || (GET_CODE (operands[1]) == MEM
! 	      && (GET_CODE (XEXP (operands[1], 0)) == LO_SUM
! 		  || GET_CODE (XEXP (operands[1], 0)) == PRE_INC
! 		  || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)))
  	{
  	  /* If the low-address word is used in the address, we must load
  	     it last.  Otherwise, load it first.  Note that we cannot have
***************
*** 7668,7681 ****
  	    }
  	}
      case 2:
!       if (GET_CODE (operands[0]) == MEM
!           && (rs6000_legitimate_offset_address_p (DFmode, XEXP (operands[0], 0),
! 		    reload_completed || reload_in_progress)
! 	      || rs6000_legitimate_small_data_p (DFmode, XEXP (operands[0], 0))
! 	      || GET_CODE (XEXP (operands[0], 0)) == REG
!     	      || GET_CODE (XEXP (operands[0], 0)) == LO_SUM
! 	      || GET_CODE (XEXP (operands[0], 0)) == PRE_INC
! 	      || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC))
  	return \"{st%U0|stw%U0} %1,%0\;{st|stw} %L1,%L0\";
        else
  	{
--- 7665,7675 ----
  	    }
  	}
      case 2:
!       if (rs6000_offsettable_memref_p (operands[0])
! 	  || (GET_CODE (operands[0]) == MEM
! 	      && (GET_CODE (XEXP (operands[0], 0)) == LO_SUM
! 		  || GET_CODE (XEXP (operands[0], 0)) == PRE_INC
! 		  || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)))
  	return \"{st%U0|stw%U0} %1,%0\;{st|stw} %L1,%L0\";
        else
  	{
*** gcc/config/sparc/sparc.c.0	2006-04-09 10:46:51.000000000 +0200
--- gcc/config/sparc/sparc.c	2006-04-09 21:15:42.700851816 +0200
*************** function_arg_slotno (const struct sparc_
*** 4758,4764 ****
  
        gcc_assert (mode == BLKmode);
  
!       if (TARGET_ARCH32 || !type || (TREE_CODE (type) == UNION_TYPE))
  	{
  	  if (slotno >= SPARC_INT_ARG_MAX)
  	    return -1;
--- 4758,4767 ----
  
        gcc_assert (mode == BLKmode);
  
!       if (TARGET_ARCH32
! 	  || !type
! 	  || (TREE_CODE (type) != VECTOR_TYPE
! 	      && TREE_CODE (type) != RECORD_TYPE))
  	{
  	  if (slotno >= SPARC_INT_ARG_MAX)
  	    return -1;
*************** function_arg (const struct sparc_args *c
*** 5272,5333 ****
  		 : SPARC_OUTGOING_INT_ARG_FIRST);
    int slotno, regno, padding;
    enum mode_class mclass = GET_MODE_CLASS (mode);
-   rtx reg;
  
    slotno = function_arg_slotno (cum, mode, type, named, incoming_p,
  				&regno, &padding);
- 
    if (slotno == -1)
      return 0;
  
!   if (TARGET_ARCH32)
      {
!       reg = gen_rtx_REG (mode, regno);
!       return reg;
      }
-     
-   if (type && TREE_CODE (type) == RECORD_TYPE)
-     {
-       /* Structures up to 16 bytes in size are passed in arg slots on the
- 	 stack and are promoted to registers where possible.  */
  
!       gcc_assert (int_size_in_bytes (type) <= 16);
  
!       return function_arg_record_value (type, mode, slotno, named, regbase);
!     }
!   else if (type && TREE_CODE (type) == UNION_TYPE)
      {
        HOST_WIDE_INT size = int_size_in_bytes (type);
- 
        gcc_assert (size <= 16);
  
!       return function_arg_union_value (size, mode, slotno, regno);
      }
!   else if (type && TREE_CODE (type) == VECTOR_TYPE)
      {
-       /* Vector types deserve special treatment because they are
- 	 polymorphic wrt their mode, depending upon whether VIS
- 	 instructions are enabled.  */
        HOST_WIDE_INT size = int_size_in_bytes (type);
- 
        gcc_assert (size <= 16);
  
!       if (mode == BLKmode)
! 	return function_arg_vector_value (size,
! 					  TYPE_MODE (TREE_TYPE (type)),
! 					  SPARC_FP_ARG_FIRST + 2*slotno);
!       else
! 	mclass = MODE_FLOAT;
      }
  
    /* v9 fp args in reg slots beyond the int reg slots get passed in regs
       but also have the slot allocated for them.
       If no prototype is in scope fp values in register slots get passed
       in two places, either fp regs and int regs or fp regs and memory.  */
!   if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)
!       && SPARC_FP_REG_P (regno))
      {
!       reg = gen_rtx_REG (mode, regno);
        if (cum->prototype_p || cum->libcall_p)
  	{
  	  /* "* 2" because fp reg numbers are recorded in 4 byte
--- 5275,5332 ----
  		 : SPARC_OUTGOING_INT_ARG_FIRST);
    int slotno, regno, padding;
    enum mode_class mclass = GET_MODE_CLASS (mode);
  
    slotno = function_arg_slotno (cum, mode, type, named, incoming_p,
  				&regno, &padding);
    if (slotno == -1)
      return 0;
  
!   /* Vector types deserve special treatment because they are polymorphic wrt
!      their mode, depending upon whether VIS instructions are enabled.  */
!   if (type && TREE_CODE (type) == VECTOR_TYPE)
      {
!       HOST_WIDE_INT size = int_size_in_bytes (type);
!       gcc_assert ((TARGET_ARCH32 && size <= 8)
! 		  || (TARGET_ARCH64 && size <= 16));
! 
!       if (mode == BLKmode)
! 	return function_arg_vector_value (size,
! 					  TYPE_MODE (TREE_TYPE (type)),
! 					  SPARC_FP_ARG_FIRST + 2*slotno);
!       else
! 	mclass = MODE_FLOAT;
      }
  
!   if (TARGET_ARCH32)
!     return gen_rtx_REG (mode, regno);
  
!   /* Structures up to 16 bytes in size are passed in arg slots on the stack
!      and are promoted to registers if possible.  */
!   if (type && TREE_CODE (type) == RECORD_TYPE)
      {
        HOST_WIDE_INT size = int_size_in_bytes (type);
        gcc_assert (size <= 16);
  
!       return function_arg_record_value (type, mode, slotno, named, regbase);
      }
! 
!   /* Unions up to 16 bytes in size are passed in integer registers.  */
!   else if (type && TREE_CODE (type) == UNION_TYPE)
      {
        HOST_WIDE_INT size = int_size_in_bytes (type);
        gcc_assert (size <= 16);
  
!       return function_arg_union_value (size, mode, slotno, regno);
      }
  
    /* v9 fp args in reg slots beyond the int reg slots get passed in regs
       but also have the slot allocated for them.
       If no prototype is in scope fp values in register slots get passed
       in two places, either fp regs and int regs or fp regs and memory.  */
!   else if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)
! 	   && SPARC_FP_REG_P (regno))
      {
!       rtx reg = gen_rtx_REG (mode, regno);
        if (cum->prototype_p || cum->libcall_p)
  	{
  	  /* "* 2" because fp reg numbers are recorded in 4 byte
*************** function_arg (const struct sparc_args *c
*** 5388,5400 ****
  	    }
  	}
      }
!   else
      {
!       /* Scalar or complex int.  */
!       reg = gen_rtx_REG (mode, regno);
      }
  
!   return reg;
  }
  
  /* For an arg passed partly in registers and partly in memory,
--- 5387,5404 ----
  	    }
  	}
      }
! 
!   /* All other aggregate types are passed in an integer register in a mode
!      corresponding to the size of the type.  */
!   else if (type && AGGREGATE_TYPE_P (type))
      {
!       HOST_WIDE_INT size = int_size_in_bytes (type);
!       gcc_assert (size <= 16);
! 
!       mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);
      }
  
!   return gen_rtx_REG (mode, regno);
  }
  
  /* For an arg passed partly in registers and partly in memory,
*************** sparc_pass_by_reference (CUMULATIVE_ARGS
*** 5470,5476 ****
  			 bool named ATTRIBUTE_UNUSED)
  {
    if (TARGET_ARCH32)
-     {
      /* Original SPARC 32-bit ABI says that structures and unions,
         and quad-precision floats are passed by reference.  For Pascal,
         also pass arrays by reference.  All other base types are passed
--- 5474,5479 ----
*************** sparc_pass_by_reference (CUMULATIVE_ARGS
*** 5485,5503 ****
         integers are passed like floats of the same size, that is in
         registers up to 8 bytes.  Pass all vector floats by reference
         like structure and unions.  */
!       return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))
! 	      || mode == SCmode
! 	      /* Catch CDImode, TFmode, DCmode and TCmode.  */
! 	      || GET_MODE_SIZE (mode) > 8
! 	      || (type
! 		  && TREE_CODE (type) == VECTOR_TYPE
! 		  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));
!     }
    else
-     {
      /* Original SPARC 64-bit ABI says that structures and unions
         smaller than 16 bytes are passed in registers, as well as
!        all other base types.  For Pascal, pass arrays by reference.
         
         Extended ABI (as implemented by the Sun compiler) says that
         complex floats are passed in registers up to 16 bytes.  Pass
--- 5488,5504 ----
         integers are passed like floats of the same size, that is in
         registers up to 8 bytes.  Pass all vector floats by reference
         like structure and unions.  */
!     return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))
! 	    || mode == SCmode
! 	    /* Catch CDImode, TFmode, DCmode and TCmode.  */
! 	    || GET_MODE_SIZE (mode) > 8
! 	    || (type
! 		&& TREE_CODE (type) == VECTOR_TYPE
! 		&& (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));
    else
      /* Original SPARC 64-bit ABI says that structures and unions
         smaller than 16 bytes are passed in registers, as well as
!        all other base types.
         
         Extended ABI (as implemented by the Sun compiler) says that
         complex floats are passed in registers up to 16 bytes.  Pass
*************** sparc_pass_by_reference (CUMULATIVE_ARGS
*** 5508,5520 ****
         integers are passed like floats of the same size, that is in
         registers (up to 16 bytes).  Pass all vector floats like structure
         and unions.  */
!       return ((type && TREE_CODE (type) == ARRAY_TYPE)
! 	      || (type
! 		  && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE)
! 		  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)
! 	      /* Catch CTImode and TCmode.  */
! 	      || GET_MODE_SIZE (mode) > 16);
!     }
  }
  
  /* Handle the FUNCTION_ARG_ADVANCE macro.
--- 5509,5519 ----
         integers are passed like floats of the same size, that is in
         registers (up to 16 bytes).  Pass all vector floats like structure
         and unions.  */
!     return ((type
! 	     && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE)
! 	     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)
! 	    /* Catch CTImode and TCmode.  */
! 	    || GET_MODE_SIZE (mode) > 16);
  }
  
  /* Handle the FUNCTION_ARG_ADVANCE macro.
*************** function_value (tree type, enum machine_
*** 5658,5670 ****
    enum mode_class mclass = GET_MODE_CLASS (mode);
    int regno;
  
    if (type && TREE_CODE (type) == VECTOR_TYPE)
      {
-       /* Vector types deserve special treatment because they are
- 	 polymorphic wrt their mode, depending upon whether VIS
- 	 instructions are enabled.  */
        HOST_WIDE_INT size = int_size_in_bytes (type);
- 
        gcc_assert ((TARGET_ARCH32 && size <= 8)
  		  || (TARGET_ARCH64 && size <= 32));
  
--- 5657,5667 ----
    enum mode_class mclass = GET_MODE_CLASS (mode);
    int regno;
  
+   /* Vector types deserve special treatment because they are polymorphic wrt
+      their mode, depending upon whether VIS instructions are enabled.  */
    if (type && TREE_CODE (type) == VECTOR_TYPE)
      {
        HOST_WIDE_INT size = int_size_in_bytes (type);
        gcc_assert ((TARGET_ARCH32 && size <= 8)
  		  || (TARGET_ARCH64 && size <= 32));
  
*************** function_value (tree type, enum machine_
*** 5675,5708 ****
        else
  	mclass = MODE_FLOAT;
      }
!   else if (type && TARGET_ARCH64)
      {
        if (TREE_CODE (type) == RECORD_TYPE)
  	{
! 	  /* Structures up to 32 bytes in size are passed in registers,
! 	     promoted to fp registers where possible.  */
! 
! 	  gcc_assert (int_size_in_bytes (type) <= 32);
  
  	  return function_arg_record_value (type, mode, 0, 1, regbase);
  	}
        else if (TREE_CODE (type) == UNION_TYPE)
  	{
  	  HOST_WIDE_INT size = int_size_in_bytes (type);
- 
  	  gcc_assert (size <= 32);
  
  	  return function_arg_union_value (size, mode, 0, regbase);
  	}
        else if (AGGREGATE_TYPE_P (type))
  	{
  	  /* All other aggregate types are passed in an integer register
  	     in a mode corresponding to the size of the type.  */
! 	  HOST_WIDE_INT bytes = int_size_in_bytes (type);
! 
! 	  gcc_assert (bytes <= 32);
  
! 	  mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);
  
  	  /* ??? We probably should have made the same ABI change in
  	     3.4.0 as the one we made for unions.   The latter was
--- 5672,5712 ----
        else
  	mclass = MODE_FLOAT;
      }
! 
!   if (TARGET_ARCH64 && type)
      {
+       /* Structures up to 32 bytes in size are returned in registers.  */
        if (TREE_CODE (type) == RECORD_TYPE)
  	{
! 	  HOST_WIDE_INT size = int_size_in_bytes (type);
! 	  gcc_assert (size <= 32);
  
  	  return function_arg_record_value (type, mode, 0, 1, regbase);
  	}
+ 
+       /* Unions up to 32 bytes in size are returned in integer registers.  */
        else if (TREE_CODE (type) == UNION_TYPE)
  	{
  	  HOST_WIDE_INT size = int_size_in_bytes (type);
  	  gcc_assert (size <= 32);
  
  	  return function_arg_union_value (size, mode, 0, regbase);
  	}
+ 
+       /* Objects that require it are returned in FP registers.  */
+       else if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)
+ 	;
+ 
+       /* All other aggregate types are returned in an integer register in a
+ 	 mode corresponding to the size of the type.  */
        else if (AGGREGATE_TYPE_P (type))
  	{
  	  /* All other aggregate types are passed in an integer register
  	     in a mode corresponding to the size of the type.  */
! 	  HOST_WIDE_INT size = int_size_in_bytes (type);
! 	  gcc_assert (size <= 32);
  
! 	  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);
  
  	  /* ??? We probably should have made the same ABI change in
  	     3.4.0 as the one we made for unions.   The latter was
*************** function_value (tree type, enum machine_
*** 5714,5730 ****
  	     try to be unduly clever, and simply follow the ABI
  	     for unions in that case.  */
  	  if (mode == BLKmode)
! 	    return function_arg_union_value (bytes, mode, 0, regbase);
  	  else
  	    mclass = MODE_INT;
  	}
!       else if (mclass == MODE_INT
! 	       && GET_MODE_SIZE (mode) < UNITS_PER_WORD)
  	mode = word_mode;
      }
  
!   if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)
!       && TARGET_FPU)
      regno = SPARC_FP_ARG_FIRST;
    else
      regno = regbase;
--- 5718,5734 ----
  	     try to be unduly clever, and simply follow the ABI
  	     for unions in that case.  */
  	  if (mode == BLKmode)
! 	    return function_arg_union_value (size, mode, 0, regbase);
  	  else
  	    mclass = MODE_INT;
  	}
! 
!       /* This must match PROMOTE_FUNCTION_MODE.  */
!       else if (mclass == MODE_INT && GET_MODE_SIZE (mode) < UNITS_PER_WORD)
  	mode = word_mode;
      }
  
!   if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT) && TARGET_FPU)
      regno = SPARC_FP_ARG_FIRST;
    else
      regno = regbase;
*** gcc/Makefile.in.orig	Mon Mar 20 14:07:09 2006
--- gcc/Makefile.in	Mon Mar 20 14:08:09 2006
***************
*** 1258,1264 ****
  stamp-collect-ld: $(ORIGINAL_LD_FOR_TARGET)
  	@echo creating collect-ld; \
  	case "$(ORIGINAL_LD_FOR_TARGET)" in \
! 	  ./collect-ld) ;; \
  	  ../*) \
  	     rm -f collect-ld$(exeext); \
  	     echo $(LN) $< collect-ld$(exeext); \
--- 1258,1264 ----
  stamp-collect-ld: $(ORIGINAL_LD_FOR_TARGET)
  	@echo creating collect-ld; \
  	case "$(ORIGINAL_LD_FOR_TARGET)" in \
! 	  ./collect-ld|./collect-ld$(exeext)) ;; \
  	  ../*) \
  	     rm -f collect-ld$(exeext); \
  	     echo $(LN) $< collect-ld$(exeext); \
*** gcc/config/i386/cygming.h.orig	Mon Mar 20 14:19:17 2006
--- gcc/config/i386/cygming.h	Mon Mar 20 14:19:35 2006
***************
*** 304,310 ****
  /* DWARF2 Unwinding doesn't work with exception handling yet.  To make
     it work, we need to build a libgcc_s.dll, and dcrt0.o should be
     changed to call __register_frame_info/__deregister_frame_info.  */
! #define DWARF2_UNWIND_INFO 0
  
  /* Don't assume anything about the header files.  */
  #define NO_IMPLICIT_EXTERN_C
--- 304,310 ----
  /* DWARF2 Unwinding doesn't work with exception handling yet.  To make
     it work, we need to build a libgcc_s.dll, and dcrt0.o should be
     changed to call __register_frame_info/__deregister_frame_info.  */
! #define DWARF2_UNWIND_INFO 1 
  
  /* Don't assume anything about the header files.  */
  #define NO_IMPLICIT_EXTERN_C
*** gcc/config/i386/mingw32.h.orig	Mon Mar 20 17:05:10 2006
--- gcc/config/i386/mingw32.h	Mon Mar 20 17:06:24 2006
***************
*** 58,64 ****
    %{shared: %{mdll: %eshared and mdll are not compatible}} \
    %{shared: --shared} %{mdll:--dll} \
    %{static:-Bstatic} %{!static:-Bdynamic} \
!   %{shared|mdll: -e _DllMainCRTStartup@12}"
  
  /* Include in the mingw32 libraries with libgcc */
  #undef LIBGCC_SPEC
--- 58,65 ----
    %{shared: %{mdll: %eshared and mdll are not compatible}} \
    %{shared: --shared} %{mdll:--dll} \
    %{static:-Bstatic} %{!static:-Bdynamic} \
!   %{shared|mdll: -e _DllMainCRTStartup@12} \
!   --enable-auto-import --enable-runtime-pseudo-reloc"
  
  /* Include in the mingw32 libraries with libgcc */
  #undef LIBGCC_SPEC
*** gcc/config/i386/t-mingw32.orig	Sat Nov 19 19:37:59 2005
--- gcc/config/i386/t-mingw32	Tue Mar 21 16:15:17 2006
***************
*** 3,5 ****
--- 3,23 ----
  
  # Match SYSTEM_INCLUDE_DIR
  NATIVE_SYSTEM_HEADER_DIR = /mingw/include
+ 
+ # Build a shared libgcc library with the GNU linker.
+ 
+ SHLIB_EXT = .dll
+ SHLIB_SONAME = @shlib_base_name@.dll
+ SHLIB_OBJS = @shlib_objs@
+ SHLIB_DIR = @multilib_dir@
+ SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
+ 
+ SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+ 	-o $(SHLIB_DIR)/$(SHLIB_SONAME) \
+ 	@multilib_flags@ $(SHLIB_OBJS) -lmingw32 -lshell32 -lmoldname -lmingwex -lmsvcrt -lkernel32 -luser32 -ladvapi32 
+ # $(slibdir) double quoted to protect it from expansion while building
+ # libgcc.mk.  We want this delayed until actual install time.
+ SHLIB_INSTALL = \
+ 	$$(mkinstalldirs) $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL); \
+ 	$(INSTALL_PROGRAM) $(SHLIB_DIR)/$(SHLIB_SONAME) \
+ 	 $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SONAME); 
*** gcc/config.gcc	Tue Feb  7 03:09:33 2006
--- gcc/config.gcc	Thu Mar 23 14:41:15 2006
***************
*** 1237,1242 ****
--- 1237,1243 ----
  	target_gtfiles="\$(srcdir)/config/i386/winnt.c"
  	extra_options="${extra_options} i386/cygming.opt"
  	extra_objs="winnt.o winnt-stubs.o"
+ 	extra_parts="crtbegin.o crtend.o"
  	cxx_target_objs=winnt-cxx.o
  	case ${enable_threads} in
  	  "" | yes | win32) thread_file='win32' ;;
*** gcc/crtstuff.c	Sat Nov 19 19:38:37 2005
--- gcc/crtstuff.c	Thu Mar 23 14:38:38 2006
***************
*** 154,159 ****
--- 154,161 ----
  
  #endif /* OBJECT_FORMAT_ELF */
  
+ #ifndef __MINGW32__
+ 
  #ifdef CRT_BEGIN
  
  /* NOTE:  In order to be able to support SVR4 shared libraries, we arrange
***************
*** 581,583 ****
--- 583,666 ----
  #else /* ! CRT_BEGIN && ! CRT_END */
  #error "One of CRT_BEGIN or CRT_END must be defined."
  #endif
+ 
+ #else /*__MINGW32__ */
+ 
+ /* Use  __main to run ctors and dtors. This code generates a
+ label for beginning of .eh_frame section in crtbegin.o and terminates
+ the section in crtend.o. Registration and deregistration is done by
+ installing ctor and dtor functions to do the job.  */
+ 
+ 
+ #ifdef CRT_BEGIN
+ /* Stick a label at the beginning of the frame unwind info so we can
+    register/deregister it with the exception handling library code.  */
+ 
+ char __EH_FRAME_BEGIN__[]
+      __attribute__((section(EH_FRAME_SECTION_NAME), aligned(4)))
+      = { };
+ 
+ static struct object obj;
+ 
+ /* These will pull in references from libgcc.a(unwind-dw2-fde.o) */
+ 
+ void __do_frame_init (void);
+ void __do_frame_fini (void);
+ 
+ void
+ __do_frame_init (void)
+ {
+   __register_frame_info (__EH_FRAME_BEGIN__, &obj);
+ }
+ 
+ void
+ __do_frame_fini (void)
+ {
+   __deregister_frame_info (__EH_FRAME_BEGIN__);
+ }
+ 
+ 
+ #elif defined CRT_END
+ 
+ /* Terminate the frame unwind info section with a 0 as a sentinel;
+    this would be the 'length' field in a real FDE.  */
+ static int __EH_FRAME_END__[]
+      __attribute__ ((unused, section(EH_FRAME_SECTION_NAME), aligned(4)))
+      = { 0 };
+ 
+ /* Register the eh_frame. This has to be the first ctor to
+    be invoked so we put it in last. Since we're last, we can't
+    reference __register_frame_info in libgcc.a directly (if eh_frame
+    code has been referenced than it will have been pulled in but
+    we can't count on it) so we  call a stub in crtbegin.o.  */
+ 
+ extern void __do_frame_init (void);
+ static void __reg_frame_ctor (void) __attribute__ ((constructor));
+ 
+ static void
+ __reg_frame_ctor (void)
+ {
+   __do_frame_init ();
+ }
+ 
+ 
+ /* Deregister the eh_frame. This has to be the last dtor. The
+    call to __register_frame_info in crtbegin.o will have pulled in
+    libgcc.a(unwind-dw2-fde.o) if libgcc.a is static lib but not if
+    dll, so we use a stub again to be sure.  */
+ 
+ extern void __do_frame_fini (void);
+ static void __dereg_frame_dtor (void) __attribute__ ((destructor));
+ 
+ static void
+ __dereg_frame_dtor (void)
+ {
+   __do_frame_fini ();
+ }
+ 
+ #else /* ! CRT_BEGIN && ! CRT_END */
+ #error "One of CRT_BEGIN or CRT_END must be defined."
+ #endif
+ 
+ #endif /* __MINGW32__ || __CYGWIN__ */
+ 
*** gcc/config/i386/mingw32.h	Sat Nov 19 19:37:59 2005
--- gcc/config/i386/mingw32.h	Thu Mar 23 14:43:17 2006
***************
*** 68,74 ****
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
!   %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s}"
  
  /* Override startfile prefix defaults.  */
  #ifndef STANDARD_STARTFILE_PREFIX_1
--- 68,78 ----
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
!   %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s} \
!   %{!fno-exceptions:crtbegin%O%s}"
! 
! #undef ENDFILE_SPEC
! #define ENDFILE_SPEC "%{!fno-exceptions:crtend%O%s}"
  
  /* Override startfile prefix defaults.  */
  #ifndef STANDARD_STARTFILE_PREFIX_1
*** gcc/config/i386/cygming.h.orig	Thu Mar 23 17:31:48 2006
--- gcc/config/i386/cygming.h	Thu Mar 23 17:32:39 2006
***************
*** 380,397 ****
        ASM_OUTPUT_DEF (STREAM, alias, IDENTIFIER_POINTER (TARGET));	\
      } while (0)
  
- /* GNU as supports weak symbols on PECOFF. */
- #ifdef HAVE_GAS_WEAK
- #define ASM_WEAKEN_LABEL(FILE, NAME)  \
-   do                                  \
-     {                                 \
-       fputs ("\t.weak\t", (FILE));    \
-       assemble_name ((FILE), (NAME)); \
-       fputc ('\n', (FILE));           \
-     }                                 \
-   while (0)
- #endif /* HAVE_GAS_WEAK */
- 
  /* FIXME: SUPPORTS_WEAK && TARGET_HAVE_NAMED_SECTIONS is true,
     but for .jcr section to work we also need crtbegin and crtend
     objects.  */
--- 380,385 ----
*** gcc/cfgexpand.c.sav	2006-03-12 17:02:48.000000000 +0100
--- gcc/cfgexpand.c	2006-05-12 00:43:36.293020864 +0200
*************** tree_expand_cfg (void)
*** 1608,1617 ****
    /* Set up parameters and prepare for return, for the function.  */
    expand_function_start (current_function_decl);
  
!   /* If this function is `main', emit a call to `__main'
!      to run global initializers, etc.  */
!   if (DECL_NAME (current_function_decl)
!       && MAIN_NAME_P (DECL_NAME (current_function_decl))
        && DECL_FILE_SCOPE_P (current_function_decl))
      expand_main_function ();
  
--- 1611,1621 ----
    /* Set up parameters and prepare for return, for the function.  */
    expand_function_start (current_function_decl);
  
!   /* If this function is `main', emit a call to `__main' to run global
!      initializers, etc.  Note that using DECL_NAME does not work on
!      Windows as the main function is not called main but _main.  */
!   if (DECL_ASSEMBLER_NAME (current_function_decl)
!       && MAIN_NAME_P (DECL_ASSEMBLER_NAME (current_function_decl))
        && DECL_FILE_SCOPE_P (current_function_decl))
      expand_main_function ();
  
*** gcc/tree-vrp.c.0	2006-05-06 20:05:37.799255016 +0200
--- gcc/tree-vrp.c	2006-05-06 20:06:01.183700040 +0200
*************** extract_range_from_assert (value_range_t
*** 708,773 ****
  	  || symbolic_range_p (limit_vr)))
      limit_vr = NULL;
  
-   /* Special handling for integral types with super-types.  Some FEs
-      construct integral types derived from other types and restrict
-      the range of values these new types may take.
- 
-      It may happen that LIMIT is actually smaller than TYPE's minimum
-      value.  For instance, the Ada FE is generating code like this
-      during bootstrap:
- 
- 	    D.1480_32 = nam_30 - 300000361;
- 	    if (D.1480_32 <= 1) goto <L112>; else goto <L52>;
- 	    <L112>:;
- 	    D.1480_94 = ASSERT_EXPR <D.1480_32, D.1480_32 <= 1>;
- 
-      All the names are of type types__name_id___XDLU_300000000__399999999
-      which has min == 300000000 and max == 399999999.  This means that
-      the ASSERT_EXPR would try to create the range [3000000, 1] which
-      is invalid.
- 
-      The fact that the type specifies MIN and MAX values does not
-      automatically mean that every variable of that type will always
-      be within that range, so the predicate may well be true at run
-      time.  If we had symbolic -INF and +INF values, we could
-      represent this range, but we currently represent -INF and +INF
-      using the type's min and max values.
- 	 
-      So, the only sensible thing we can do for now is set the
-      resulting range to VR_VARYING.  TODO, would having symbolic -INF
-      and +INF values be worth the trouble?  */
-   if (TREE_CODE (limit) != SSA_NAME
-       && INTEGRAL_TYPE_P (type)
-       && TREE_TYPE (type))
-     {
-       if (cond_code == LE_EXPR || cond_code == LT_EXPR)
- 	{
- 	  tree type_min = TYPE_MIN_VALUE (type);
- 	  int cmp = compare_values (limit, type_min);
- 
- 	  /* For < or <= comparisons, if LIMIT is smaller than
- 	     TYPE_MIN, set the range to VR_VARYING.  */
- 	  if (cmp == -1 || cmp == 0)
- 	    {
- 	      set_value_range_to_varying (vr_p);
- 	      return;
- 	    }
- 	}
-       else if (cond_code == GE_EXPR || cond_code == GT_EXPR)
- 	{
- 	  tree type_max = TYPE_MIN_VALUE (type);
- 	  int cmp = compare_values (limit, type_max);
- 
- 	  /* For > or >= comparisons, if LIMIT is bigger than
- 	     TYPE_MAX, set the range to VR_VARYING.  */
- 	  if (cmp == 1 || cmp == 0)
- 	    {
- 	      set_value_range_to_varying (vr_p);
- 	      return;
- 	    }
- 	}
-     }
- 
    /* Initially, the new range has the same set of equivalences of
       VAR's range.  This will be revised before returning the final
       value.  Since assertions may be chained via mutually exclusive
--- 708,713 ----
*************** extract_range_from_assert (value_range_t
*** 870,883 ****
  	  max = limit_vr->max;
  	}
  
!       /* For LT_EXPR, we create the range [MIN, MAX - 1].  */
!       if (cond_code == LT_EXPR)
  	{
! 	  tree one = build_int_cst (type, 1);
! 	  max = fold_build2 (MINUS_EXPR, type, max, one);
! 	}
  
!       set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);
      }
    else if (cond_code == GE_EXPR || cond_code == GT_EXPR)
      {
--- 810,831 ----
  	  max = limit_vr->max;
  	}
  
!       /* If the maximum value forces us to be out of bounds, simply punt.
! 	 It would be pointless to try and do anything more since this
! 	 all should be optimized away above us.  */
!       if (cond_code == LT_EXPR && compare_values (max, min) == 0)
! 	set_value_range_to_varying (vr_p);
!       else
  	{
! 	  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */
! 	  if (cond_code == LT_EXPR)
! 	    {
! 	      tree one = build_int_cst (type, 1);
! 	      max = fold_build2 (MINUS_EXPR, type, max, one);
! 	    }
  
! 	  set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);
! 	}
      }
    else if (cond_code == GE_EXPR || cond_code == GT_EXPR)
      {
*************** extract_range_from_assert (value_range_t
*** 893,906 ****
  	  min = limit_vr->min;
  	}
  
!       /* For GT_EXPR, we create the range [MIN + 1, MAX].  */
!       if (cond_code == GT_EXPR)
  	{
! 	  tree one = build_int_cst (type, 1);
! 	  min = fold_build2 (PLUS_EXPR, type, min, one);
! 	}
  
!       set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);
      }
    else
      gcc_unreachable ();
--- 841,862 ----
  	  min = limit_vr->min;
  	}
  
!       /* If the minimum value forces us to be out of bounds, simply punt.
! 	 It would be pointless to try and do anything more since this
! 	 all should be optimized away above us.  */
!       if (cond_code == GT_EXPR && compare_values (min, max) == 0)
! 	set_value_range_to_varying (vr_p);
!       else
  	{
! 	  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */
! 	  if (cond_code == GT_EXPR)
! 	    {
! 	      tree one = build_int_cst (type, 1);
! 	      min = fold_build2 (PLUS_EXPR, type, min, one);
! 	    }
  
! 	  set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);
! 	}
      }
    else
      gcc_unreachable ();
*** gcc/tree-ssa-dom.c.0	2006-05-07 09:13:05.488321584 +0200
--- gcc/tree-ssa-dom.c	2006-05-07 09:14:47.445821688 +0200
*************** simplify_cond_and_lookup_avail_expr (tre
*** 2108,2114 ****
  		 in the range.  */
  	      if (! extract_range_from_cond (element->cond, &tmp_high,
  					     &tmp_low, &dummy))
! 		gcc_unreachable ();
  	      else
  		gcc_assert (dummy == 0);
  
--- 2108,2118 ----
  		 in the range.  */
  	      if (! extract_range_from_cond (element->cond, &tmp_high,
  					     &tmp_low, &dummy))
! 		{
! 		  tree type = TREE_TYPE (TREE_OPERAND (element->cond, 1));
! 		  tmp_low = TYPE_MIN_VALUE (type);
! 		  tmp_high = TYPE_MAX_VALUE (type);
! 		}
  	      else
  		gcc_assert (dummy == 0);
  
*** gcc/common.opt.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/common.opt	2006-11-20 16:33:43.000000000 +0100
*************** fstack-protector-all
*** 826,831 ****
--- 826,835 ----
  Common Report RejectNegative Var(flag_stack_protect, 2) VarExists
  Use a stack protection method for every function
  
+ fstack-usage
+ Common RejectNegative Var(flag_stack_usage)
+ Output stack usage information on a per-function basis
+ 
  fstrength-reduce
  Common Report Var(flag_strength_reduce)
  Perform strength reduction optimizations
*** gcc/doc/invoke.texi.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/doc/invoke.texi	2006-11-20 16:34:16.000000000 +0100
*************** Objective-C and Objective-C++ Dialects}.
*** 285,291 ****
  -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
! -ftest-coverage  -ftime-report -fvar-tracking @gol
  -g  -g@var{level}  -gcoff -gdwarf-2 @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
  -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol
--- 285,291 ----
  -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
! -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
  -g  -g@var{level}  -gcoff -gdwarf-2 @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
  -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol
*************** pass when it finishes.
*** 3587,3592 ****
--- 3587,3625 ----
  Makes the compiler print some statistics about permanent memory
  allocation when it finishes.
  
+ @item -fstack-usage
+ @opindex fstack-usage
+ Makes the compiler output stack usage information for the program, on a
+ per-function basis.  The filename for the dump is made by appending
+ @file{.su} to the AUXNAME.  AUXNAME is generated from the name of
+ the output file, if explicitly specified and it is not an executable,
+ otherwise it is the basename of the source file.  An entry is made up
+ of three fields:
+ 
+ @itemize
+ @item
+ The name of the function.
+ @item
+ A number of bytes.
+ @item
+ One or more qualifiers: @code{static}, @code{dynamic}, @code{bounded}.
+ @end itemize
+ 
+ The qualifier @code{static} means that the function manipulates the stack
+ statically: a fixed number of bytes are allocated for the frame on function
+ entry and released on function exit; no stack adjustments are otherwise made
+ in the function.  The second field is this fixed number of bytes.
+ 
+ The qualifier @code{dynamic} means that the function manipulates the stack
+ dynamically: in addition to the static allocation described above, stack
+ adjustments are made in the body of the function, for example to push/pop
+ arguments around function calls.  If the qualifier @code{bounded} is also
+ present, the amount of these adjustments is bounded at compile-time and
+ the second field is an upper bound of the total amount of stack used by
+ the function.  If it is not present, the amount of these adjustments is
+ not bounded at compile-time and the second field only represents the
+ bounded part.
+ 
  @item -fprofile-arcs
  @opindex fprofile-arcs
  Add code so that program flow @dfn{arcs} are instrumented.  During
*** gcc/doc/tm.texi.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/doc/tm.texi	2006-11-20 16:33:43.000000000 +0100
*************** of @code{FRAME_POINTER_CFA_OFFSET} and @
*** 2968,2973 ****
--- 2968,2979 ----
  should be defined.
  @end defmac
  
+ @deftypefn {Target Hook} HOST_WIDE_INT TARGET_GET_STATIC_STACK_USAGE (void)
+ This target hook should return the maximum static stack usage for the
+ current function.  It is invoked just before prologue and epilogue are
+ emitted for the function.
+ @end deftypefn
+ 
  @node Exception Handling
  @subsection Exception Handling Support
  @cindex exception handling
*** gcc/builtins.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/builtins.c	2006-11-20 16:40:45.000000000 +0100
*************** static rtx expand_builtin_strstr (tree, 
*** 126,132 ****
  static rtx expand_builtin_strpbrk (tree, tree, rtx, enum machine_mode);
  static rtx expand_builtin_strchr (tree, tree, rtx, enum machine_mode);
  static rtx expand_builtin_strrchr (tree, tree, rtx, enum machine_mode);
! static rtx expand_builtin_alloca (tree, rtx);
  static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);
  static rtx expand_builtin_frame_address (tree, tree);
  static rtx expand_builtin_fputs (tree, rtx, bool);
--- 126,132 ----
  static rtx expand_builtin_strpbrk (tree, tree, rtx, enum machine_mode);
  static rtx expand_builtin_strchr (tree, tree, rtx, enum machine_mode);
  static rtx expand_builtin_strrchr (tree, tree, rtx, enum machine_mode);
! static rtx expand_builtin_alloca (tree, rtx, bool);
  static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);
  static rtx expand_builtin_frame_address (tree, tree);
  static rtx expand_builtin_fputs (tree, rtx, bool);
*************** expand_builtin_apply (rtx function, rtx 
*** 1467,1474 ****
      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);
  
    /* Allocate a block of memory onto the stack and copy the memory
!      arguments to the outgoing arguments address.  */
!   allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT);
    dest = virtual_outgoing_args_rtx;
  #ifndef STACK_GROWS_DOWNWARD
    if (GET_CODE (argsize) == CONST_INT)
--- 1467,1476 ----
      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);
  
    /* Allocate a block of memory onto the stack and copy the memory
!      arguments to the outgoing arguments address.  We can pass TRUE
!      as the 4th argument because we just saved the stack pointer
!      and will restore it right after the call.  */
!   allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT, TRUE);
    dest = virtual_outgoing_args_rtx;
  #ifndef STACK_GROWS_DOWNWARD
    if (GET_CODE (argsize) == CONST_INT)
*************** expand_builtin_frame_address (tree fndec
*** 4613,4622 ****
  
  /* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if
     we failed and the caller should emit a normal call, otherwise try to get
!    the result in TARGET, if convenient.  */
  
  static rtx
! expand_builtin_alloca (tree arglist, rtx target)
  {
    rtx op0;
    rtx result;
--- 4615,4625 ----
  
  /* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if
     we failed and the caller should emit a normal call, otherwise try to get
!    the result in TARGET, if convenient.  CANNOT_ACCUMULATE is the same as
!    for allocate_dynamic_stack_space.  */
  
  static rtx
! expand_builtin_alloca (tree arglist, rtx target, bool cannot_accumulate)
  {
    rtx op0;
    rtx result;
*************** expand_builtin_alloca (tree arglist, rtx
*** 4634,4640 ****
    op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
  
    /* Allocate the desired space.  */
!   result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);
    result = convert_memory_address (ptr_mode, result);
  
    return result;
--- 4637,4644 ----
    op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
  
    /* Allocate the desired space.  */
!   result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT,
! 					 cannot_accumulate);
    result = convert_memory_address (ptr_mode, result);
  
    return result;
*************** expand_builtin (tree exp, rtx target, rt
*** 5968,5974 ****
  	return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);
  
      case BUILT_IN_ALLOCA:
!       target = expand_builtin_alloca (arglist, target);
        if (target)
  	return target;
        break;
--- 5972,5980 ----
  	return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);
  
      case BUILT_IN_ALLOCA:
!       /* If the allocation stems from the declaration of a variable-sized
! 	 object, it cannot accumulate.  */
!       target = expand_builtin_alloca (arglist, target, ALLOCA_FOR_VAR_P (exp));
        if (target)
  	return target;
        break;
*** gcc/calls.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/calls.c	2006-11-20 17:31:59.000000000 +0100
*************** initialize_argument_information (int num
*** 1041,1049 ****
  		      pending_stack_adjust = 0;
  		    }
  
  		  copy = gen_rtx_MEM (BLKmode,
  				      allocate_dynamic_stack_space
! 				      (size_rtx, NULL_RTX, TYPE_ALIGN (type)));
  		  set_mem_attributes (copy, type, 1);
  		}
  	      else
--- 1041,1053 ----
  		      pending_stack_adjust = 0;
  		    }
  
+ 		  /* We can pass TRUE as the 4th argument because we just
+ 		     saved the stack pointer and will restore it right after
+ 		     the call.  */
  		  copy = gen_rtx_MEM (BLKmode,
  				      allocate_dynamic_stack_space
! 				      (size_rtx, NULL_RTX,
! 				       TYPE_ALIGN (type), TRUE));
  		  set_mem_attributes (copy, type, 1);
  		}
  	      else
*************** expand_call (tree exp, rtx target, int i
*** 2360,2365 ****
--- 2364,2371 ----
  	      stack_arg_under_construction = 0;
  	    }
  	  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);
+ 	  if (flag_stack_usage)
+ 	    current_function_has_unbounded_dynamic_stack_size = 1;
  	}
        else
  	{
*************** expand_call (tree exp, rtx target, int i
*** 2524,2531 ****
  		  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);
  		  highest_outgoing_arg_in_use = 0;
  		}
  	      allocate_dynamic_stack_space (push_size, NULL_RTX,
! 					    BITS_PER_UNIT);
  	    }
  
  	  /* If argument evaluation might modify the stack pointer,
--- 2530,2540 ----
  		  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);
  		  highest_outgoing_arg_in_use = 0;
  		}
+ 	      /* We can pass TRUE as the 4th argument because we just
+ 		 saved the stack pointer and will restore it right after
+ 		 the call.  */
  	      allocate_dynamic_stack_space (push_size, NULL_RTX,
! 					    BITS_PER_UNIT, TRUE);
  	    }
  
  	  /* If argument evaluation might modify the stack pointer,
*************** expand_call (tree exp, rtx target, int i
*** 2566,2571 ****
--- 2575,2593 ----
  	 be deferred during the evaluation of the arguments.  */
        NO_DEFER_POP;
  
+       if (flag_stack_usage
+ 	  && !ACCUMULATE_OUTGOING_ARGS && pass && adjusted_args_size.var == 0)
+ 	{
+ 	  int pushed = adjusted_args_size.constant + pending_stack_adjust;
+ 
+ 	  /* Record the maximum pushed stack space size.  We need to
+ 	     delay it this far to take into account the optimization
+ 	     done by combine_pending_stack_adjustment_and_call.  */
+ 
+ 	  if (pushed > current_function_pushed_stack_size)
+ 	    current_function_pushed_stack_size = pushed;
+ 	}
+ 
        funexp = rtx_for_function_call (fndecl, addr);
  
        /* Figure out the register where the value, if any, will come back.  */
*************** emit_library_call_value_1 (int retval, r
*** 3555,3560 ****
--- 3577,3589 ----
    if (args_size.constant > current_function_outgoing_args_size)
      current_function_outgoing_args_size = args_size.constant;
  
+   if (flag_stack_usage && !ACCUMULATE_OUTGOING_ARGS)
+     {
+       int pushed = args_size.constant + pending_stack_adjust;
+       if (pushed > current_function_pushed_stack_size)
+ 	current_function_pushed_stack_size = pushed;
+     }
+ 
    if (ACCUMULATE_OUTGOING_ARGS)
      {
        /* Since the stack pointer will never be pushed, it is possible for
*** gcc/explow.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/explow.c	2006-11-20 16:33:43.000000000 +0100
*************** update_nonlocal_goto_save_area (void)
*** 1023,1033 ****
     SIZE is an rtx representing the size of the area.
     TARGET is a place in which the address can be placed.
  
!    KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.  */
  
  rtx
! allocate_dynamic_stack_space (rtx size, rtx target, int known_align)
  {
    /* If we're asking for zero bytes, it doesn't matter what we point
       to since we can't dereference it.  But return a reasonable
       address anyway.  */
--- 1023,1045 ----
     SIZE is an rtx representing the size of the area.
     TARGET is a place in which the address can be placed.
  
!    KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.
! 
!    If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the
!    stack space allocated by the generated code cannot be added with itself
!    in the course of the execution of the function.  It is always safe to
!    pass FALSE here and the following criterion is sufficient in order to
!    pass TRUE: every path in the CFG that starts at the allocation point and
!    loops to it executes the associated deallocation code (that always exists
!    if the function does not use the depressed stack pointer mechanism).  */
  
  rtx
! allocate_dynamic_stack_space (rtx size, rtx target, int known_align,
! 			      bool cannot_accumulate)
  {
+   HOST_WIDE_INT stack_usage_size = -1;
+   bool known_align_valid = true;
+ 
    /* If we're asking for zero bytes, it doesn't matter what we point
       to since we can't dereference it.  But return a reasonable
       address anyway.  */
*************** allocate_dynamic_stack_space (rtx size, 
*** 1037,1042 ****
--- 1049,1086 ----
    /* Otherwise, show we're calling alloca or equivalent.  */
    current_function_calls_alloca = 1;
  
+   /* If stack usage info is requested, look into the size we are passed.
+      We need to do so this early to avoid the obfuscation that may be
+      introduced later by the various alignment operations.  */
+   if (flag_stack_usage)
+     {
+       if (GET_CODE (size) == CONST_INT)
+ 	stack_usage_size = INTVAL (size);
+       else if (GET_CODE (size) == REG)
+         {
+ 	  /* Look into the last emitted insn and see if we can deduce
+ 	     something for the register.  */
+ 	  rtx insn, set, note;
+ 	  insn = get_last_insn ();
+ 	  if ((set = single_set (insn))
+ 	      && rtx_equal_p (SET_DEST (set), size))
+ 	    {
+ 	      if (GET_CODE (SET_SRC (set)) == CONST_INT)
+ 		stack_usage_size = INTVAL (SET_SRC (set));
+ 	      else if ((note = find_reg_equal_equiv_note (insn))
+ 		       && GET_CODE (XEXP (note, 0)) == CONST_INT)
+ 		stack_usage_size = INTVAL (XEXP (note, 0));
+ 	    }
+ 	}
+ 
+       /* If the size is not constant, we can't say anything.  */
+       if (stack_usage_size == -1)
+ 	{
+ 	  current_function_has_unbounded_dynamic_stack_size = 1;
+ 	  stack_usage_size = 0;
+ 	}
+     }
+ 
    /* Ensure the size is in the proper mode.  */
    if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
      size = convert_to_mode (Pmode, size, 1);
*************** allocate_dynamic_stack_space (rtx size, 
*** 1066,1075 ****
  #endif
  
    if (MUST_ALIGN)
!     size
!       = force_operand (plus_constant (size,
! 				      BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
! 		       NULL_RTX);
  
  #ifdef SETJMP_VIA_SAVE_AREA
    /* If setjmp restores regs from a save area in the stack frame,
--- 1110,1126 ----
  #endif
  
    if (MUST_ALIGN)
!     {
!       size
!         = force_operand (plus_constant (size,
! 					BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
! 			 NULL_RTX);
! 
!       if (flag_stack_usage)
! 	stack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;
! 
!       known_align_valid = false;
!     }
  
  #ifdef SETJMP_VIA_SAVE_AREA
    /* If setjmp restores regs from a save area in the stack frame,
*************** allocate_dynamic_stack_space (rtx size, 
*** 1083,1114 ****
       would use reg notes to store the "optimized" size and fix things
       up later.  These days we know this information before we ever
       start building RTL so the reg notes are unnecessary.  */
!   if (!current_function_calls_setjmp)
!     {
!       int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
! 
!       /* ??? Code below assumes that the save area needs maximal
! 	 alignment.  This constraint may be too strong.  */
!       gcc_assert (PREFERRED_STACK_BOUNDARY == BIGGEST_ALIGNMENT);
! 
!       if (GET_CODE (size) == CONST_INT)
! 	{
! 	  HOST_WIDE_INT new = INTVAL (size) / align * align;
! 
! 	  if (INTVAL (size) != new)
! 	    size = GEN_INT (new);
! 	}
!       else
! 	{
! 	  /* Since we know overflow is not possible, we avoid using
! 	     CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */
! 	  size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size,
! 				GEN_INT (align), NULL_RTX, 1);
! 	  size = expand_mult (Pmode, size,
! 			      GEN_INT (align), NULL_RTX, 1);
! 	}
!     }
!   else
      {
        rtx dynamic_offset
  	= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,
--- 1134,1140 ----
       would use reg notes to store the "optimized" size and fix things
       up later.  These days we know this information before we ever
       start building RTL so the reg notes are unnecessary.  */
!   if (current_function_calls_setjmp)
      {
        rtx dynamic_offset
  	= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,
*************** allocate_dynamic_stack_space (rtx size, 
*** 1116,1121 ****
--- 1142,1155 ----
  
        size = expand_binop (Pmode, add_optab, size, dynamic_offset,
  			   NULL_RTX, 1, OPTAB_LIB_WIDEN);
+ 
+       /* The above dynamic offset cannot be computed statically at this
+ 	 point, but it will be possible to do so after RTL expansion is
+ 	 done.  Record how many times we will need to add it.  */
+       if (flag_stack_usage)
+ 	current_function_dynamic_alloc_count++;
+ 
+       known_align_valid = false;
      }
  #endif /* SETJMP_VIA_SAVE_AREA */
  
*************** allocate_dynamic_stack_space (rtx size, 
*** 1132,1144 ****
       insns.  Since this is an extremely rare event, we have no reliable
       way of knowing which systems have this problem.  So we avoid even
       momentarily mis-aligning the stack.  */
  
!   /* If we added a variable amount to SIZE,
!      we can no longer assume it is aligned.  */
! #if !defined (SETJMP_VIA_SAVE_AREA)
!   if (MUST_ALIGN || known_align % PREFERRED_STACK_BOUNDARY != 0)
! #endif
!     size = round_push (size);
  
    do_pending_stack_adjust ();
  
--- 1166,1193 ----
       insns.  Since this is an extremely rare event, we have no reliable
       way of knowing which systems have this problem.  So we avoid even
       momentarily mis-aligning the stack.  */
+   if (!known_align_valid || known_align % PREFERRED_STACK_BOUNDARY != 0)
+     {
+       size = round_push (size);
  
!       if (flag_stack_usage)
! 	{
! 	  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
! 	  stack_usage_size = (stack_usage_size + align - 1) / align * align;
! 	}
!     }
! 
!   /* The size is supposed to be fully adjusted at this point so record it
!      if stack usage info is requested.  */
!   if (flag_stack_usage)
!     {
!       current_function_dynamic_stack_size += stack_usage_size;
! 
!       /* ??? This is gross but the only safe stance in the absence
! 	 of stack usage oriented flow analysis.  */
!       if (!cannot_accumulate)
! 	current_function_has_unbounded_dynamic_stack_size = 1;
!     }
  
    do_pending_stack_adjust ();
  
*** gcc/expr.h.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/expr.h	2006-11-20 16:33:43.000000000 +0100
*************** extern void emit_stack_restore (enum sav
*** 714,722 ****
  /* Invoke emit_stack_save for the nonlocal_goto_save_area.  */
  extern void update_nonlocal_goto_save_area (void);
  
! /* Allocate some space on the stack dynamically and return its address.  An rtx
!    says how many bytes.  */
! extern rtx allocate_dynamic_stack_space (rtx, rtx, int);
  
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
     FIRST is a constant and size is a Pmode RTX.  These are offsets from the
--- 714,721 ----
  /* Invoke emit_stack_save for the nonlocal_goto_save_area.  */
  extern void update_nonlocal_goto_save_area (void);
  
! /* Allocate some space on the stack dynamically and return its address.  */
! extern rtx allocate_dynamic_stack_space (rtx, rtx, int, bool);
  
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
     FIRST is a constant and size is a Pmode RTX.  These are offsets from the
*** gcc/flow.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/flow.c	2006-11-20 16:33:43.000000000 +0100
*************** rest_of_handle_flow2 (void)
*** 4656,4661 ****
--- 4656,4665 ----
    if (optimize)
      cleanup_cfg (CLEANUP_EXPENSIVE);
  
+   /* The IA-64 port invalidates its static stack usage info right after.  */
+   if (flag_stack_usage)
+     output_stack_usage ();
+ 
    /* On some machines, the prologue and epilogue code, or parts thereof,
       can be represented as RTL.  Doing so lets us schedule insns between
       it and the rest of the code and also allows delayed branch
*** gcc/function.h.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/function.h	2006-11-20 16:54:15.000000000 +0100
*************** struct expr_status GTY(())
*** 156,161 ****
--- 156,188 ----
  #define forced_labels (cfun->expr->x_forced_labels)
  #define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)
  
+ struct stack_usage GTY(())
+ {
+   /* # of bytes of space pushed onto the stack after the prologue.  If
+      !ACCUMULATE_OUTGOING_ARGS, it contains the outgoing arguments.  */
+   int pushed_stack_size;
+ 
+   /* # of dynamic allocations in the function.  */
+   unsigned int dynamic_alloc_count;
+ 
+   /* # of bytes of dynamic stack space allocated by the function.  This is
+      meaningful only if has_unbounded_dynamic_stack_size is zero.  */
+   HOST_WIDE_INT dynamic_stack_size;
+ 
+   /* Nonzero if the amount of stack space allocated dynamically cannot
+      be bounded at compile-time.  */
+   unsigned int has_unbounded_dynamic_stack_size : 1;
+ };
+ 
+ #define current_function_pushed_stack_size (cfun->su->pushed_stack_size)
+ #define current_function_dynamic_alloc_count (cfun->su->dynamic_alloc_count)
+ #define current_function_dynamic_stack_size (cfun->su->dynamic_stack_size)
+ #define current_function_has_unbounded_dynamic_stack_size \
+   (cfun->su->has_unbounded_dynamic_stack_size)
+ #define current_function_allocates_dynamic_stack_space    \
+   (current_function_dynamic_stack_size != 0               \
+    || current_function_has_unbounded_dynamic_stack_size)
+ 
  /* This structure can save all the important global and static variables
     describing the status of the current function.  */
  
*************** struct function GTY(())
*** 166,171 ****
--- 193,199 ----
    struct expr_status *expr;
    struct emit_status *emit;
    struct varasm_status *varasm;
+   struct stack_usage *su;
  
    /* The control flow graph for this function.  */
    struct control_flow_graph *cfg;
*** gcc/function.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/function.c	2006-11-20 18:07:21.702923752 +0100
*************** instantiate_virtual_regs (void)
*** 1725,1730 ****
--- 1725,1741 ----
    /* Indicate that, from now on, assign_stack_local should use
       frame_pointer_rtx.  */
    virtuals_instantiated = 1;
+ 
+   /* See allocate_dynamic_stack_space for the rationale.  */
+ #ifdef SETJMP_VIA_SAVE_AREA
+   if (flag_stack_usage && current_function_calls_setjmp)
+     {
+       int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
+       dynamic_offset = (dynamic_offset + align - 1) / align * align;
+       current_function_dynamic_stack_size
+ 	+= current_function_dynamic_alloc_count * dynamic_offset;
+     }
+ #endif
  }
  
  struct tree_opt_pass pass_instantiate_virtual_regs =
***************  (tree fndecl)
*** 3886,3891 ****
--- 3897,3904 ----
    init_emit ();
    init_varasm_status (cfun);
    init_expr ();
+   if (flag_stack_usage)
+     cfun->su = ggc_alloc_cleared (sizeof (struct stack_usage));
  
    cse_not_expected = ! optimize;
  
*** gcc/gimplify.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/gimplify.c	2006-11-20 16:41:08.000000000 +0100
*************** gimplify_decl_expr (tree *stmt_p)
*** 1096,1101 ****
--- 1096,1103 ----
  	  args = tree_cons (NULL, DECL_SIZE_UNIT (decl), NULL);
  	  t = built_in_decls[BUILT_IN_ALLOCA];
  	  t = build_function_call_expr (t, args);
+ 	  /* The call has been built for a variable-sized object.  */
+ 	  ALLOCA_FOR_VAR_P (t) = 1;
  	  t = fold_convert (ptr_type, t);
  	  t = build2 (MODIFY_EXPR, void_type_node, addr, t);
  
*** gcc/target-def.h.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/target-def.h	2006-11-20 16:33:43.000000000 +0100
*************** Foundation, 51 Franklin Street, Fifth Fl
*** 422,427 ****
--- 422,429 ----
  #define TARGET_STACK_PROTECT_GUARD  default_stack_protect_guard
  #define TARGET_STACK_PROTECT_FAIL   default_external_stack_protect_fail
  
+ #define TARGET_GET_STATIC_STACK_USAGE 0
+ 
  #define TARGET_ARM_EABI_UNWINDER false
  
  #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_false
*************** Foundation, 51 Franklin Street, Fifth Fl
*** 608,613 ****
--- 610,616 ----
    TARGET_STDARG_OPTIMIZE_HOOK,			\
    TARGET_STACK_PROTECT_GUARD,			\
    TARGET_STACK_PROTECT_FAIL,			\
+   TARGET_GET_STATIC_STACK_USAGE,		\
    TARGET_INVALID_WITHIN_DOLOOP,			\
    TARGET_VALID_DLLIMPORT_ATTRIBUTE_P,		\
    TARGET_CALLS,					\
*** gcc/target.h.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/target.h	2006-11-20 16:33:43.000000000 +0100
*************** struct gcc_target
*** 552,557 ****
--- 552,560 ----
       that is invoked when a check vs the guard variable fails.  */
    tree (* stack_protect_fail) (void);
  
+   /* Return the maximum static stack usage for the current function.  */
+   HOST_WIDE_INT (* get_static_stack_usage) (void);
+ 
    /* Returns NULL if target supports the insn within a doloop block,
       otherwise it returns an error message.  */
    const char * (*invalid_within_doloop) (rtx);
*** gcc/toplev.h.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/toplev.h	2006-11-20 16:33:43.000000000 +0100
*************** extern void check_global_declarations (t
*** 100,105 ****
--- 100,108 ----
  extern void emit_debug_global_declarations (tree *, int);
  extern void write_global_declarations (void);
  
+ /* Output stack usage information.  */
+ extern void output_stack_usage (void);
+ 
  /* A unique local time stamp, might be zero if none is available.  */
  extern unsigned local_tick;
  
*** gcc/toplev.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/toplev.c	2006-11-20 16:33:43.000000000 +0100
*************** static const param_info lang_independent
*** 391,396 ****
--- 391,397 ----
  
  FILE *asm_out_file;
  FILE *aux_info_file;
+ FILE *stack_usage_file = NULL;
  FILE *dump_file = NULL;
  const char *dump_file_name;
  
*************** default_tree_printer (pretty_printer * p
*** 1423,1428 ****
--- 1424,1514 ----
    return true;
  }
  
+ /* Output stack usage information.  */
+ void
+ output_stack_usage (void)
+ {
+   static bool warning_issued = false;
+   enum stack_usage_kind_type { STATIC = 0, DYNAMIC, DYNAMIC_BOUNDED };
+   const char *stack_usage_kind_str[] = {
+     "static",
+     "dynamic",
+     "dynamic,bounded"
+   };
+   HOST_WIDE_INT stack_usage = -1;
+   enum stack_usage_kind_type stack_usage_kind;
+   const char *raw_id, *id;
+ 
+   /* Rely on the back-end to compute the maximum static stack usage.
+      The back-end needs this information at one point or another to
+      reserve storage for the frame.  */
+   if (targetm.get_static_stack_usage)
+     stack_usage = targetm.get_static_stack_usage ();
+ 
+   if (stack_usage == -1)
+     {
+       if (!warning_issued)
+ 	{
+ 	  warning (OPT_fstack_usage,
+ 		   "-fstack-usage not supported for this target");
+ 	  warning_issued = true;
+ 	}
+       return;
+     }
+ 
+   stack_usage_kind = STATIC;
+ 
+   /* Add the maximum amount of space pushed onto the stack.  */
+   if (current_function_pushed_stack_size > 0)
+     {
+       stack_usage += current_function_pushed_stack_size;
+       stack_usage_kind = DYNAMIC_BOUNDED;
+     }
+ 
+   /* Now on to the tricky part: dynamic stack allocation.  */
+   if (current_function_allocates_dynamic_stack_space)
+     {
+       if (current_function_has_unbounded_dynamic_stack_size)
+ 	stack_usage_kind = DYNAMIC;
+       else
+ 	stack_usage_kind = DYNAMIC_BOUNDED;
+ 
+       /* Add the size even in the unbounded case, this can't hurt.  */
+       stack_usage += current_function_dynamic_stack_size;
+     }
+ 
+   /* Strip the scope prefix if any.  */
+   raw_id = lang_hooks.decl_printable_name (current_function_decl, 2);
+   id = strrchr (raw_id, '.');
+   if (id)
+     id++;
+   else
+     id = raw_id;
+ 
+   fprintf (stack_usage_file,
+ 	   "%s:%d:%s\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
+ 	   basename (DECL_SOURCE_FILE (current_function_decl)),
+ 	   DECL_SOURCE_LINE (current_function_decl),
+ 	   id,
+ 	   stack_usage,
+ 	   stack_usage_kind_str[stack_usage_kind]);
+ }
+ 
+ /* Open an auxiliary output file.  */
+ static FILE *
+ open_auxiliary_file (const char *ext)
+ {
+   char *filename;
+   FILE *file;
+ 
+   filename = concat (aux_base_name, ".", ext, NULL);
+   file = fopen (filename, "w");
+   if (!file)
+     fatal_error ("can't open %s for writing: %m", filename);
+   free (filename);
+   return file;
+ }
+ 
  /* Initialization of the front end environment, before command line
     options are parsed.  Signal handlers, internationalization etc.
     ARGV0 is main's argv[0].  */
*************** lang_dependent_init (const char *name)
*** 1849,1854 ****
--- 1935,1944 ----
  
    init_asm_output (name);
  
+   /* If stack usage information is desired, open the output file.  */
+   if (flag_stack_usage)
+     stack_usage_file = open_auxiliary_file ("su");
+ 
    /* These create various _DECL nodes, so need to be called after the
       front end is initialized.  */
    init_eh ();
*************** finalize (void)
*** 1903,1908 ****
--- 1993,2001 ----
  	fatal_error ("error closing %s: %m", asm_file_name);
      }
  
+   if (stack_usage_file)
+     fclose (stack_usage_file);
+ 
    finish_optimization_passes ();
  
    if (mem_report)
*** gcc/tree.h.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/tree.h	2006-11-20 16:33:00.000000000 +0100
*************** struct tree_common GTY(())
*** 356,362 ****
         TREE_PROTECTED in
             BLOCK
  	   ..._DECL
!        CALL_FROM_THUNK_P in
             CALL_EXPR
  
     side_effects_flag:
--- 356,363 ----
         TREE_PROTECTED in
             BLOCK
  	   ..._DECL
!        CALL_FROM_THUNK_P and
!        ALLOCA_FOR_VAR_P in
             CALL_EXPR
  
     side_effects_flag:
*************** extern void tree_operand_check_failed (i
*** 1028,1033 ****
--- 1029,1038 ----
     thunked-to function.  */
  #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->common.protected_flag)
  
+ /* In a CALL_EXPR, if the function being called is BUILT_IN_ALLOCA, means that
+    it has been built for the declaration of a variable-sized object.  */
+ #define ALLOCA_FOR_VAR_P(NODE) (CALL_EXPR_CHECK (NODE)->common.protected_flag)
+ 
  /* In a type, nonzero means that all objects of the type are guaranteed by the
     language or front-end to be properly aligned, so we can indicate that a MEM
     of this type is aligned at least to the alignment of the type, even if it
*** gcc/config/alpha/alpha.c.0	2006-11-20 16:32:38.000000000 +0100
--- gcc/config/alpha/alpha.c	2006-11-20 16:33:43.000000000 +0100
*************** emit_frame_store (unsigned int regno, rt
*** 7506,7511 ****
--- 7506,7543 ----
    emit_frame_store_1 (reg, base_reg, frame_bias, base_ofs, reg);
  }
  
+ /* Compute the frame size.  SIZE is the size of the "naked" frame
+    and SA_SIZE is the size of the register save area.  */
+ 
+ static HOST_WIDE_INT
+ compute_frame_size (HOST_WIDE_INT size, HOST_WIDE_INT sa_size)
+ {
+   if (TARGET_ABI_OPEN_VMS)
+     return ALPHA_ROUND (sa_size 
+ 			+ (alpha_procedure_type == PT_STACK ? 8 : 0)
+ 			+ size
+ 			+ current_function_pretend_args_size);
+   else if (TARGET_ABI_UNICOSMK)
+     /* We have to allocate space for the DSIB if we generate a frame.  */
+     return ALPHA_ROUND (sa_size
+ 			+ (alpha_procedure_type == PT_STACK ? 48 : 0))
+ 	   + ALPHA_ROUND (size
+ 			  + current_function_outgoing_args_size);
+   else
+     return ALPHA_ROUND (current_function_outgoing_args_size)
+ 	   + sa_size
+ 	   + ALPHA_ROUND (size
+ 			  + current_function_pretend_args_size);
+ }
+ 
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ alpha_get_static_stack_usage (void)
+ {
+   return compute_frame_size (get_frame_size (), alpha_sa_size ());
+ }
+ 
  /* Write function prologue.  */
  
  /* On vms we have two kinds of functions:
*************** alpha_expand_prologue (void)
*** 7542,7565 ****
    int i;
  
    sa_size = alpha_sa_size ();
! 
!   frame_size = get_frame_size ();
!   if (TARGET_ABI_OPEN_VMS)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 8 : 0)
! 			      + frame_size
! 			      + current_function_pretend_args_size);
!   else if (TARGET_ABI_UNICOSMK)
!     /* We have to allocate space for the DSIB if we generate a frame.  */
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 48 : 0))
! 		 + ALPHA_ROUND (frame_size
! 				+ current_function_outgoing_args_size);
!   else
!     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)
! 		  + sa_size
! 		  + ALPHA_ROUND (frame_size
! 				 + current_function_pretend_args_size));
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
--- 7574,7580 ----
    int i;
  
    sa_size = alpha_sa_size ();
!   frame_size = compute_frame_size (get_frame_size (), sa_size);
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
*************** alpha_start_function (FILE *file, const 
*** 7873,7895 ****
  
    alpha_fnname = fnname;
    sa_size = alpha_sa_size ();
! 
!   frame_size = get_frame_size ();
!   if (TARGET_ABI_OPEN_VMS)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 8 : 0)
! 			      + frame_size
! 			      + current_function_pretend_args_size);
!   else if (TARGET_ABI_UNICOSMK)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 48 : 0))
! 		 + ALPHA_ROUND (frame_size
! 			      + current_function_outgoing_args_size);
!   else
!     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)
! 		  + sa_size
! 		  + ALPHA_ROUND (frame_size
! 				 + current_function_pretend_args_size));
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
--- 7888,7894 ----
  
    alpha_fnname = fnname;
    sa_size = alpha_sa_size ();
!   frame_size = compute_frame_size (get_frame_size (), sa_size);
  
    if (TARGET_ABI_OPEN_VMS)
      reg_offset = 8;
*************** alpha_expand_epilogue (void)
*** 8072,8094 ****
    int i;
  
    sa_size = alpha_sa_size ();
! 
!   frame_size = get_frame_size ();
!   if (TARGET_ABI_OPEN_VMS)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 8 : 0)
! 			      + frame_size
! 			      + current_function_pretend_args_size);
!   else if (TARGET_ABI_UNICOSMK)
!     frame_size = ALPHA_ROUND (sa_size
! 			      + (alpha_procedure_type == PT_STACK ? 48 : 0))
! 		 + ALPHA_ROUND (frame_size
! 			      + current_function_outgoing_args_size);
!   else
!     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)
! 		  + sa_size
! 		  + ALPHA_ROUND (frame_size
! 				 + current_function_pretend_args_size));
  
    if (TARGET_ABI_OPEN_VMS)
      {
--- 8071,8077 ----
    int i;
  
    sa_size = alpha_sa_size ();
!   frame_size = compute_frame_size (get_frame_size (), sa_size);
  
    if (TARGET_ABI_OPEN_VMS)
      {
*************** alpha_init_libfuncs (void)
*** 10795,10800 ****
--- 10778,10786 ----
  #define TARGET_MANGLE_FUNDAMENTAL_TYPE alpha_mangle_fundamental_type
  #endif
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE alpha_get_static_stack_usage
+ 
  struct gcc_target targetm = TARGET_INITIALIZER;
  
  
*** gcc/config/i386/i386.c.0	2006-11-20 16:32:39.000000000 +0100
--- gcc/config/i386/i386.c	2006-11-20 16:33:43.000000000 +0100
*************** static int ix86_fp_comparison_cost (enum
*** 892,897 ****
--- 892,898 ----
  static unsigned int ix86_select_alt_pic_regnum (void);
  static int ix86_save_reg (unsigned int, int);
  static void ix86_compute_frame_layout (struct ix86_frame *);
+ static HOST_WIDE_INT ix86_get_static_stack_usage (void);
  static int ix86_comp_type_attributes (tree, tree);
  static int ix86_function_regparm (tree, tree);
  const struct attribute_spec ix86_attribute_table[];
*************** static void x86_64_elf_select_section (t
*** 1113,1118 ****
--- 1114,1122 ----
  #undef TARGET_FUNCTION_VALUE
  #define TARGET_FUNCTION_VALUE ix86_function_value
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE ix86_get_static_stack_usage
+ 
  struct gcc_target targetm = TARGET_INITIALIZER;
  
  
*************** output_probe_stack_range (rtx first_rtx,
*** 5124,5129 ****
--- 5128,5149 ----
    return "";
  }
  
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ ix86_get_static_stack_usage (void)
+ {
+   struct ix86_frame frame;
+ 
+   ix86_compute_frame_layout (&frame);
+ 
+   /* We start at the ARG_POINTER register's address.  */
+   return (UNITS_PER_WORD /* return address */
+ 	  + (frame_pointer_needed ? UNITS_PER_WORD : 0) /* saved fp */
+ 	  + frame.nregs * UNITS_PER_WORD /* saved regs */
+ 	  + frame.to_allocate); /* static frame */
+ }
+ 
  /* Emit code to save registers in the prologue.  */
  
  static void
*** gcc/config/ia64/ia64.c.0	2006-11-20 16:32:39.000000000 +0100
--- gcc/config/ia64/ia64.c	2006-11-20 16:33:43.000000000 +0100
*************** static void process_epilogue (FILE *, rt
*** 195,200 ****
--- 195,201 ----
  static int process_set (FILE *, rtx, rtx, bool, bool);
  
  static bool ia64_assemble_integer (rtx, unsigned int, int);
+ static HOST_WIDE_INT ia64_get_static_stack_usage (void);
  static void ia64_output_function_prologue (FILE *, HOST_WIDE_INT);
  static void ia64_output_function_epilogue (FILE *, HOST_WIDE_INT);
  static void ia64_output_function_end_prologue (FILE *);
*************** static const struct attribute_spec ia64_
*** 359,364 ****
--- 360,368 ----
  #undef TARGET_ASM_FILE_START
  #define TARGET_ASM_FILE_START ia64_file_start
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE ia64_get_static_stack_usage
+ 
  #undef TARGET_RTX_COSTS
  #define TARGET_RTX_COSTS ia64_rtx_costs
  #undef TARGET_ADDRESS_COST
*************** ia64_compute_frame_size (HOST_WIDE_INT s
*** 2555,2560 ****
--- 2559,2574 ----
    current_frame_info.initialized = reload_completed;
  }
  
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ ia64_get_static_stack_usage (void)
+ {
+   ia64_compute_frame_size (get_frame_size ());
+   gcc_assert (current_frame_info.initialized);
+   return current_frame_info.total_size;
+ }
+ 
  /* Compute the initial difference between the specified pair of registers.  */
  
  HOST_WIDE_INT
*** gcc/config/mips/mips.c.0	2006-11-20 16:32:39.000000000 +0100
--- gcc/config/mips/mips.c	2006-11-20 16:33:43.000000000 +0100
*************** static void mips_save_restore_reg (enum 
*** 320,325 ****
--- 320,326 ----
  static void mips_for_each_saved_reg (HOST_WIDE_INT, mips_save_restore_fn);
  static void mips_output_cplocal (void);
  static void mips_emit_loadgp (void);
+ static HOST_WIDE_INT mips_get_static_stack_usage (void);
  static void mips_output_function_prologue (FILE *, HOST_WIDE_INT);
  static void mips_set_frame_expr (rtx);
  static rtx mips_frame_set (rtx, rtx);
*************** static struct mips_rtx_cost_data const m
*** 1123,1128 ****
--- 1124,1132 ----
  #undef TARGET_RETURN_IN_MSB
  #define TARGET_RETURN_IN_MSB mips_return_in_msb
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE mips_get_static_stack_usage
+ 
  #undef TARGET_ASM_OUTPUT_MI_THUNK
  #define TARGET_ASM_OUTPUT_MI_THUNK mips_output_mi_thunk
  #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
*************** compute_frame_size (HOST_WIDE_INT size)
*** 6407,6412 ****
--- 6411,6424 ----
    /* Ok, we're done.  */
    return total_size;
  }
+ 
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ mips_get_static_stack_usage (void)
+ {
+   return compute_frame_size (get_frame_size ());
+ }
  
  /* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame
     pointer or argument pointer.  TO is either the stack pointer or
*** gcc/config/pa/pa.c.0	2006-11-20 16:32:39.000000000 +0100
--- gcc/config/pa/pa.c	2006-11-20 16:33:43.000000000 +0100
*************** static void store_reg (int, HOST_WIDE_IN
*** 101,106 ****
--- 101,107 ----
  static void store_reg_modify (int, int, HOST_WIDE_INT);
  static void load_reg (int, HOST_WIDE_INT, int);
  static void set_reg_plus_d (int, int, HOST_WIDE_INT, int);
+ static HOST_WIDE_INT pa_get_static_stack_usage (void);
  static void pa_output_function_prologue (FILE *, HOST_WIDE_INT);
  static void update_total_code_bytes (int);
  static void pa_output_function_epilogue (FILE *, HOST_WIDE_INT);
*************** static size_t n_deferred_plabels = 0;
*** 257,262 ****
--- 258,266 ----
  #undef TARGET_INIT_BUILTINS
  #define TARGET_INIT_BUILTINS pa_init_builtins
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE pa_get_static_stack_usage
+ 
  #undef TARGET_RTX_COSTS
  #define TARGET_RTX_COSTS hppa_rtx_costs
  #undef TARGET_ADDRESS_COST
*************** compute_frame_size (HOST_WIDE_INT size, 
*** 3501,3506 ****
--- 3505,3519 ----
  	  & ~(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1));
  }
  
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ pa_get_static_stack_usage (void)
+ {
+   int fregs_live;
+   return compute_frame_size (get_frame_size (), &fregs_live);
+ }
+ 
  /* Generate the assembly code for function entry.  FILE is a stdio
     stream to output the code to.  SIZE is an int: how many units of
     temporary storage to allocate.
*** gcc/config/rs6000/rs6000.c.0	2006-11-20 16:32:39.000000000 +0100
--- gcc/config/rs6000/rs6000.c	2006-11-20 16:33:43.000000000 +0100
*************** static rtx spe_expand_predicate_builtin 
*** 679,684 ****
--- 679,685 ----
  static rtx spe_expand_evsel_builtin (enum insn_code, tree, rtx);
  static int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);
  static rs6000_stack_t *rs6000_stack_info (void);
+ static HOST_WIDE_INT rs6000_get_static_stack_usage (void);
  static void debug_stack_info (rs6000_stack_t *);
  
  static rtx altivec_expand_builtin (tree, rtx, bool *);
*************** static const char alt_reg_names[][8] =
*** 1018,1023 ****
--- 1019,1027 ----
  #define TARGET_ASM_OUTPUT_DWARF_DTPREL rs6000_output_dwarf_dtprel
  #endif
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE rs6000_get_static_stack_usage
+ 
  struct gcc_target targetm = TARGET_INITIALIZER;
  
  
*************** rs6000_stack_info (void)
*** 13118,13123 ****
--- 13122,13136 ----
    return info_ptr;
  }
  
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ rs6000_get_static_stack_usage (void)
+ {
+   rs6000_stack_t *info = rs6000_stack_info ();
+   return info->total_size;
+ }
+ 
  /* Return true if the current function uses any GPRs in 64-bit SIMD
     mode.  */
  
*** gcc/config/sparc/sparc.c.0	2006-11-20 16:32:39.000000000 +0100
--- gcc/config/sparc/sparc.c	2006-11-20 16:33:43.000000000 +0100
*************** static void emit_pic_helper (void);
*** 320,325 ****
--- 320,326 ----
  static void load_pic_register (bool);
  static int save_or_restore_regs (int, int, rtx, int, int);
  static void emit_save_or_restore_regs (int);
+ static HOST_WIDE_INT sparc_get_static_stack_usage (void);
  static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);
  static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);
  #ifdef OBJECT_FORMAT_ELF
*************** static bool fpu_option_set = false;
*** 460,465 ****
--- 461,469 ----
  #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
  #define TARGET_ASM_CAN_OUTPUT_MI_THUNK sparc_can_output_mi_thunk
  
+ #undef TARGET_GET_STATIC_STACK_USAGE
+ #define TARGET_GET_STATIC_STACK_USAGE sparc_get_static_stack_usage
+ 
  #undef TARGET_RTX_COSTS
  #define TARGET_RTX_COSTS sparc_rtx_costs
  #undef TARGET_ADDRESS_COST
*************** sparc_compute_frame_size (HOST_WIDE_INT 
*** 3691,3696 ****
--- 3696,3712 ----
    return SPARC_STACK_ALIGN (actual_fsize);
  }
  
+ /* Return the maximum static stack usage for the current function.  */
+ 
+ static HOST_WIDE_INT
+ sparc_get_static_stack_usage (void)
+ {
+   /* See sparc_expand_prologue for the rationale.  */
+   bool my_leaf_function_p
+     = optimize > 0 && leaf_function_p () && only_leaf_regs_used ();
+   return sparc_compute_frame_size (get_frame_size (), my_leaf_function_p);
+ }
+ 
  /* Output any necessary .register pseudo-ops.  */
  
  void
*** gcc/tree.h.ori	2006-07-18 09:51:15.000000000 +0200
--- gcc/tree.h	2006-07-18 09:30:58.000000000 +0200
*************** extern int fields_length (tree);
*** 3593,3600 ****
  
  extern bool initializer_zerop (tree);
  
! extern void categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,
! 				      HOST_WIDE_INT *, bool *);
  extern HOST_WIDE_INT count_type_elements (tree, bool);
  
  /* add_var_to_bind_expr (bind_expr, var) binds var to bind_expr.  */
--- 3593,3612 ----
  
  extern bool initializer_zerop (tree);
  
! /* Examine CTOR to discover:
!    * how many scalar fields are set to nonzero values,
!      and place it in *P_NZ_ELTS;
!    * how many scalar fields in total are in CTOR,
!      and place it in *P_ELT_COUNT.
!    * if a type is a union, and the initializer from the constructor
!      is not the largest element in the union, then set *p_must_clear.
! 
!    Return whether or not CTOR is a valid static constant initializer, the same
!    as "initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0".  */
! 
! extern bool categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,
! 				      bool *);
! 
  extern HOST_WIDE_INT count_type_elements (tree, bool);
  
  /* add_var_to_bind_expr (bind_expr, var) binds var to bind_expr.  */
*** gcc/expr.c.ori	2006-07-11 18:31:14.000000000 +0200
--- gcc/expr.c	2006-07-18 09:35:01.000000000 +0200
*************** store_expr (tree exp, rtx target, int ca
*** 4409,4436 ****
    return NULL_RTX;
  }
  
! /* Examine CTOR to discover:
!    * how many scalar fields are set to nonzero values,
!      and place it in *P_NZ_ELTS;
!    * how many scalar fields are set to non-constant values,
!      and place it in  *P_NC_ELTS; and
!    * how many scalar fields in total are in CTOR,
!      and place it in *P_ELT_COUNT.
!    * if a type is a union, and the initializer from the constructor
!      is not the largest element in the union, then set *p_must_clear.  */
  
! static void
  categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,
- 			    HOST_WIDE_INT *p_nc_elts,
  			    HOST_WIDE_INT *p_elt_count,
  			    bool *p_must_clear)
  {
    unsigned HOST_WIDE_INT idx;
!   HOST_WIDE_INT nz_elts, nc_elts, elt_count;
    tree value, purpose;
  
    nz_elts = 0;
-   nc_elts = 0;
    elt_count = 0;
  
    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), idx, purpose, value)
--- 4409,4432 ----
    return NULL_RTX;
  }
  
! /* Helper for categorize_ctor_elements.  Identical interface.  */
  
! static bool
  categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,
  			    HOST_WIDE_INT *p_elt_count,
  			    bool *p_must_clear)
  {
    unsigned HOST_WIDE_INT idx;
!   HOST_WIDE_INT nz_elts, elt_count;
    tree value, purpose;
  
+   /* Whether CTOR is a valid constant initializer, in accordance with what
+      initializer_constant_valid_p does.  If inferred from the constructor
+      elements, true until proven otherwise.  */
+   bool const_from_elts_p = constructor_static_from_elts_p (ctor);
+   bool const_p = const_from_elts_p ? true : TREE_STATIC (ctor);
+ 
    nz_elts = 0;
    elt_count = 0;
  
    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), idx, purpose, value)
*************** categorize_ctor_elements_1 (tree ctor, H
*** 4452,4462 ****
  	{
  	case CONSTRUCTOR:
  	  {
! 	    HOST_WIDE_INT nz = 0, nc = 0, ic = 0;
! 	    categorize_ctor_elements_1 (value, &nz, &nc, &ic, p_must_clear);
  	    nz_elts += mult * nz;
! 	    nc_elts += mult * nc;
! 	    elt_count += mult * ic;
  	  }
  	  break;
  
--- 4448,4463 ----
  	{
  	case CONSTRUCTOR:
  	  {
! 	    HOST_WIDE_INT nz = 0, ic = 0;
! 	    
! 	    bool const_elt_p
! 	      = categorize_ctor_elements_1 (value, &nz, &ic, p_must_clear);
! 
  	    nz_elts += mult * nz;
!  	    elt_count += mult * ic;
! 
! 	    if (const_from_elts_p && const_p)
! 	      const_p = const_elt_p;
  	  }
  	  break;
  
*************** categorize_ctor_elements_1 (tree ctor, H
*** 4495,4502 ****
  	default:
  	  nz_elts += mult;
  	  elt_count += mult;
! 	  if (!initializer_constant_valid_p (value, TREE_TYPE (value)))
! 	    nc_elts += mult;
  	  break;
  	}
      }
--- 4496,4505 ----
  	default:
  	  nz_elts += mult;
  	  elt_count += mult;
! 
! 	  if (const_from_elts_p && const_p)
! 	    const_p = initializer_constant_valid_p (value, TREE_TYPE (value))
! 		      != NULL_TREE;
  	  break;
  	}
      }
*************** categorize_ctor_elements_1 (tree ctor, H
*** 4538,4559 ****
      }
  
    *p_nz_elts += nz_elts;
-   *p_nc_elts += nc_elts;
    *p_elt_count += elt_count;
  }
  
! void
  categorize_ctor_elements (tree ctor, HOST_WIDE_INT *p_nz_elts,
- 			  HOST_WIDE_INT *p_nc_elts,
  			  HOST_WIDE_INT *p_elt_count,
  			  bool *p_must_clear)
  {
    *p_nz_elts = 0;
-   *p_nc_elts = 0;
    *p_elt_count = 0;
    *p_must_clear = false;
!   categorize_ctor_elements_1 (ctor, p_nz_elts, p_nc_elts, p_elt_count,
! 			      p_must_clear);
  }
  
  /* Count the number of scalars in TYPE.  Return -1 on overflow or
--- 4541,4573 ----
      }
  
    *p_nz_elts += nz_elts;
    *p_elt_count += elt_count;
+ 
+   return const_p;
  }
  
! /* Examine CTOR to discover:
!    * how many scalar fields are set to nonzero values,
!      and place it in *P_NZ_ELTS;
!    * how many scalar fields in total are in CTOR,
!      and place it in *P_ELT_COUNT.
!    * if a type is a union, and the initializer from the constructor
!      is not the largest element in the union, then set *p_must_clear.
! 
!    Return whether or not CTOR is a valid static constant initializer, the same
!    as "initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0".  */
! 
! bool
  categorize_ctor_elements (tree ctor, HOST_WIDE_INT *p_nz_elts,
  			  HOST_WIDE_INT *p_elt_count,
  			  bool *p_must_clear)
  {
    *p_nz_elts = 0;
    *p_elt_count = 0;
    *p_must_clear = false;
! 
!   return
!     categorize_ctor_elements_1 (ctor, p_nz_elts, p_elt_count, p_must_clear);
  }
  
  /* Count the number of scalars in TYPE.  Return -1 on overflow or
*************** mostly_zeros_p (tree exp)
*** 4649,4658 ****
    if (TREE_CODE (exp) == CONSTRUCTOR)
  
      {
!       HOST_WIDE_INT nz_elts, nc_elts, count, elts;
        bool must_clear;
  
!       categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count, &must_clear);
        if (must_clear)
  	return 1;
  
--- 4663,4672 ----
    if (TREE_CODE (exp) == CONSTRUCTOR)
  
      {
!       HOST_WIDE_INT nz_elts, count, elts;
        bool must_clear;
  
!       categorize_ctor_elements (exp, &nz_elts, &count, &must_clear);
        if (must_clear)
  	return 1;
  
*************** all_zeros_p (tree exp)
*** 4672,4681 ****
    if (TREE_CODE (exp) == CONSTRUCTOR)
  
      {
!       HOST_WIDE_INT nz_elts, nc_elts, count;
        bool must_clear;
  
!       categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count, &must_clear);
        return nz_elts == 0;
      }
  
--- 4686,4695 ----
    if (TREE_CODE (exp) == CONSTRUCTOR)
  
      {
!       HOST_WIDE_INT nz_elts, count;
        bool must_clear;
  
!       categorize_ctor_elements (exp, &nz_elts, &count, &must_clear);
        return nz_elts == 0;
      }
  
*** gcc/output.h.ori	2006-07-18 09:44:42.000000000 +0200
--- gcc/output.h	2006-07-18 09:34:10.000000000 +0200
*************** extern rtx peephole (rtx);
*** 349,354 ****
--- 349,361 ----
  /* Write all the constants in the constant pool.  */
  extern void output_constant_pool (const char *, tree);
  
+ /* Whether a constructor CTOR is a valid static constant initializer if all
+    its elements are.  This used to be internal to initializer_constant_valid_p
+    and has been exposed to let other functions like categorize_ctor_elements
+    evaluate the property while walking a constructor for other purposes.  */
+ 
+ extern bool constructor_static_from_elts_p (tree);
+ 
  /* Return nonzero if VALUE is a valid constant-valued expression
     for use in initializing a static variable; one that can be an
     element of a "constant" initializer.
*** gcc/varasm.c.ori	2006-07-18 09:54:26.000000000 +0200
--- gcc/varasm.c	2006-07-18 09:34:06.000000000 +0200
*************** output_addressed_constants (tree exp)
*** 3614,3619 ****
--- 3614,3633 ----
      }
  }
  
+ /* Whether a constructor CTOR is a valid static constant initializer if all
+    its elements are.  This used to be internal to initializer_constant_valid_p
+    and has been exposed to let other functions like categorize_ctor_elements
+    evaluate the property while walking a constructor for other purposes.  */
+ 
+ bool
+ constructor_static_from_elts_p (tree ctor)
+ {
+   return (TREE_CONSTANT (ctor)
+ 	  && (TREE_CODE (TREE_TYPE (ctor)) == UNION_TYPE
+ 	      || TREE_CODE (TREE_TYPE (ctor)) == RECORD_TYPE)
+ 	  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)));
+ }
+ 
  /* Return nonzero if VALUE is a valid constant-valued expression
     for use in initializing a static variable; one that can be an
     element of a "constant" initializer.
*************** initializer_constant_valid_p (tree value
*** 3634,3643 ****
    switch (TREE_CODE (value))
      {
      case CONSTRUCTOR:
!       if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE
! 	   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)
! 	  && TREE_CONSTANT (value)
! 	  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (value)))
  	{
  	  unsigned HOST_WIDE_INT idx;
  	  tree elt;
--- 3648,3654 ----
    switch (TREE_CODE (value))
      {
      case CONSTRUCTOR:
!       if (constructor_static_from_elts_p (value))
  	{
  	  unsigned HOST_WIDE_INT idx;
  	  tree elt;
*** gcc/gimplify.c.ori	2006-07-11 15:35:45.000000000 +0200
--- gcc/gimplify.c	2006-07-10 17:16:13.000000000 +0200
*************** gimplify_init_constructor (tree *expr_p,
*** 2773,2780 ****
        {
  	struct gimplify_init_ctor_preeval_data preeval_data;
  	HOST_WIDE_INT num_type_elements, num_ctor_elements;
! 	HOST_WIDE_INT num_nonzero_elements, num_nonconstant_elements;
! 	bool cleared;
  
  	/* Aggregate types must lower constructors to initialization of
  	   individual elements.  The exception is that a CONSTRUCTOR node
--- 2773,2780 ----
        {
  	struct gimplify_init_ctor_preeval_data preeval_data;
  	HOST_WIDE_INT num_type_elements, num_ctor_elements;
! 	HOST_WIDE_INT num_nonzero_elements;
! 	bool cleared, valid_const_initializer;
  
  	/* Aggregate types must lower constructors to initialization of
  	   individual elements.  The exception is that a CONSTRUCTOR node
*************** gimplify_init_constructor (tree *expr_p,
*** 2782,2794 ****
  	if (VEC_empty (constructor_elt, elts))
  	  break;
  
! 	categorize_ctor_elements (ctor, &num_nonzero_elements,
! 				  &num_nonconstant_elements,
! 				  &num_ctor_elements, &cleared);
  
  	/* If a const aggregate variable is being initialized, then it
  	   should never be a lose to promote the variable to be static.  */
! 	if (num_nonconstant_elements == 0
  	    && num_nonzero_elements > 1
  	    && TREE_READONLY (object)
  	    && TREE_CODE (object) == VAR_DECL)
--- 2782,2797 ----
  	if (VEC_empty (constructor_elt, elts))
  	  break;
  
! 	/* Fetch information about the constructor to direct later processing.
! 	   We might want to make static versions of it in various cases, and
! 	   can only do so if it known to be a valid constant initializer.  */
! 	valid_const_initializer
! 	  = categorize_ctor_elements (ctor, &num_nonzero_elements,
! 				      &num_ctor_elements, &cleared);
  
  	/* If a const aggregate variable is being initialized, then it
  	   should never be a lose to promote the variable to be static.  */
! 	if (valid_const_initializer
  	    && num_nonzero_elements > 1
  	    && TREE_READONLY (object)
  	    && TREE_CODE (object) == VAR_DECL)
*************** gimplify_init_constructor (tree *expr_p,
*** 2845,2851 ****
  	   for sparse arrays, though, as it's more efficient to follow
  	   the standard CONSTRUCTOR behavior of memset followed by
  	   individual element initialization.  */
! 	if (num_nonconstant_elements == 0 && !cleared)
  	  {
  	    HOST_WIDE_INT size = int_size_in_bytes (type);
  	    unsigned int align;
--- 2848,2854 ----
  	   for sparse arrays, though, as it's more efficient to follow
  	   the standard CONSTRUCTOR behavior of memset followed by
  	   individual element initialization.  */
! 	if (valid_const_initializer && !cleared)
  	  {
  	    HOST_WIDE_INT size = int_size_in_bytes (type);
  	    unsigned int align;
*** gcc/tree.h.original	Thu May 11 11:52:57 2006
--- gcc/tree.h	Thu May 11 11:53:59 2006
*************** struct tree_block GTY(())
*** 1758,1764 ****
  
  /* If set in an ARRAY_TYPE, indicates a string type (for languages
     that distinguish string from array of char).
!    If set in a SET_TYPE, indicates a bitstring type.  */
  #define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type.string_flag)
  
  /* If non-NULL, this is an upper bound of the size (in bytes) of an
--- 1758,1764 ----
  
  /* If set in an ARRAY_TYPE, indicates a string type (for languages
     that distinguish string from array of char).
!    If set in an INTEGER_TYPE, indicates a character type.  */
  #define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type.string_flag)
  
  /* If non-NULL, this is an upper bound of the size (in bytes) of an
*** gcc/tree.c.original	Thu May 11 11:52:51 2006
--- gcc/tree.c	Thu May 11 11:54:43 2006
*************** build_common_tree_nodes (bool signed_cha
*** 6215,6221 ****
--- 6215,6223 ----
  
    /* Define both `signed char' and `unsigned char'.  */
    signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);
+   TYPE_STRING_FLAG (signed_char_type_node) = 1;
    unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);
+   TYPE_STRING_FLAG (unsigned_char_type_node) = 1;
  
    /* Define `char', which is like either `signed char' or `unsigned char'
       but not the same as either.  */
*************** build_common_tree_nodes (bool signed_cha
*** 6223,6228 ****
--- 6264,6270 ----
      = (signed_char
         ? make_signed_type (CHAR_TYPE_SIZE)
         : make_unsigned_type (CHAR_TYPE_SIZE));
+   TYPE_STRING_FLAG (char_type_node) = 1;
  
    short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);
    short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);
*** gcc/dwarf2out.c.original	Thu May 11 11:53:19 2006
--- gcc/dwarf2out.c	Thu May 11 12:03:29 2006
*************** base_type_die (tree type)
*** 8111,8140 ****
  
    switch (TREE_CODE (type))
      {
      case INTEGER_TYPE:
!       /* Carefully distinguish the C character types, without messing
! 	 up if the language is not C. Note that we check only for the names
! 	 that contain spaces; other names might occur by coincidence in other
! 	 languages.  */
!       if (! (TYPE_PRECISION (type) == CHAR_TYPE_SIZE
! 	     && (TYPE_MAIN_VARIANT (type) == char_type_node
! 		 || ! strcmp (type_name, "signed char")
! 		 || ! strcmp (type_name, "unsigned char"))))
  	{
  	  if (TYPE_UNSIGNED (type))
! 	    encoding = DW_ATE_unsigned;
  	  else
! 	    encoding = DW_ATE_signed;
! 	  break;
  	}
!       /* else fall through.  */
! 
!     case CHAR_TYPE:
!       /* GNU Pascal/Ada CHAR type.  Not used in C.  */
!       if (TYPE_UNSIGNED (type))
! 	encoding = DW_ATE_unsigned_char;
        else
! 	encoding = DW_ATE_signed_char;
        break;
  
      case REAL_TYPE:
--- 8111,8129 ----
  
    switch (TREE_CODE (type))
      {
+     case CHAR_TYPE:
      case INTEGER_TYPE:
!       if (TYPE_STRING_FLAG (type))
  	{
  	  if (TYPE_UNSIGNED (type))
! 	    encoding = DW_ATE_unsigned_char;
  	  else
! 	    encoding = DW_ATE_signed_char;
  	}
!       else if (TYPE_UNSIGNED (type))
! 	encoding = DW_ATE_unsigned;
        else
! 	encoding = DW_ATE_signed;
        break;
  
      case REAL_TYPE:
*** gcc/common.opt.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/common.opt	2006-12-17 00:31:44.000000000 +0100
*************** fcaller-saves
*** 305,310 ****
--- 305,318 ----
  Common Report Var(flag_caller_saves)
  Save registers around function calls
  
+ fcallgraph-info
+ Common RejectNegative
+ Output callgraph information on a per-file basis
+ 
+ fcallgraph-info=
+ Common RejectNegative Joined
+ Output callgraph information on a per-file basis with decorations
+ 
  fcommon
  Common Report Var(flag_no_common,0)
  Do not put uninitialized globals in the common section
*** gcc/doc/invoke.texi.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/doc/invoke.texi	2006-12-17 08:23:24.151231992 +0100
*************** Objective-C and Objective-C++ Dialects}.
*** 282,287 ****
--- 282,288 ----
  -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol
  -ftree-vectorizer-verbose=@var{n} @gol
  -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol
+ -fcallgraph-info@r{[}=su@r{]} @gol
  -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
*************** the function.  If it is not present, the
*** 3620,3625 ****
--- 3621,3636 ----
  not bounded at compile-time and the second field only represents the
  bounded part.
  
+ @item -fcallgraph-info
+ @itemx -fcallgraph-info=@var{MARKERS}
+ @opindex fcallgraph-info
+ Makes the compiler output callgraph information for the program, on a
+ per-file basis.  The information is generated in the common VCG format.
+ It can be decorated with additional, per-node and/or per-edge information,
+ if a list of comma-separated markers is additionally specified; only
+ @code{su} is supported for the time being and is equivalent to
+ @option{-fstack-usage}.
+ 
  @item -fprofile-arcs
  @opindex fprofile-arcs
  Add code so that program flow @dfn{arcs} are instrumented.  During
*** gcc/flags.h.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/flags.h	2006-12-17 08:23:24.179227736 +0100
*************** enum stack_check_type
*** 271,276 ****
--- 271,284 ----
  };
  extern enum stack_check_type flag_stack_check;
  
+ /* Compute stack usage information on a per-function basis.  */
+ extern int flag_stack_usage_info;
+ 
+ /* Output callgraph information on a per-file basis.  */
+ #define CALLGRAPH_INFO_NAKED        0x1
+ #define CALLGRAPH_INFO_STACK_USAGE  0x2
+ extern int flag_callgraph_info;
+ 
  /* A string that's used when a random name is required.  NULL means
     to make it really random.  */
  
*** gcc/opts.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/opts.c	2006-12-17 08:23:24.178227888 +0100
*************** common_handle_option (size_t scode, cons
*** 837,842 ****
--- 837,856 ----
        fix_register (arg, 0, 0);
        break;
  
+     case OPT_fcallgraph_info:
+       flag_callgraph_info = CALLGRAPH_INFO_NAKED;
+       break;
+ 
+     case OPT_fcallgraph_info_:
+       if (strcmp (arg, "su") == 0)
+ 	{
+ 	  flag_callgraph_info |= CALLGRAPH_INFO_STACK_USAGE;
+ 	  flag_stack_usage_info = 1;
+ 	}
+       else
+ 	return 0;
+       break;
+ 
      case OPT_fdiagnostics_show_location_:
        if (!strcmp (arg, "once"))
  	diagnostic_prefixing_rule (global_dc) = DIAGNOSTICS_SHOW_PREFIX_ONCE;
*************** common_handle_option (size_t scode, cons
*** 1012,1017 ****
--- 1026,1037 ----
        stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (arg));
        break;
  
+     case OPT_fstack_usage:
+       flag_stack_usage = value;
+       if (value)
+ 	flag_stack_usage_info = 1;
+       break;
+ 
      case OPT_ftree_vectorizer_verbose_:
        vect_set_verbosity_level (arg);
        break;
*** gcc/calls.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/calls.c	2006-12-17 00:31:43.000000000 +0100
*************** expand_call (tree exp, rtx target, int i
*** 2050,2055 ****
--- 2050,2058 ----
  	preferred_stack_boundary = i->preferred_incoming_stack_boundary;
      }
  
+   if (flag_callgraph_info)
+     cgraph_final_record_call (current_function_decl, fndecl, exp);
+ 
    /* Operand 0 is a pointer-to-function; get the type of the function.  */
    funtype = TREE_TYPE (addr);
    gcc_assert (POINTER_TYPE_P (funtype));
*************** expand_call (tree exp, rtx target, int i
*** 2364,2370 ****
  	      stack_arg_under_construction = 0;
  	    }
  	  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);
! 	  if (flag_stack_usage)
  	    current_function_has_unbounded_dynamic_stack_size = 1;
  	}
        else
--- 2367,2373 ----
  	      stack_arg_under_construction = 0;
  	    }
  	  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);
! 	  if (flag_stack_usage_info)
  	    current_function_has_unbounded_dynamic_stack_size = 1;
  	}
        else
*************** expand_call (tree exp, rtx target, int i
*** 2575,2581 ****
  	 be deferred during the evaluation of the arguments.  */
        NO_DEFER_POP;
  
!       if (flag_stack_usage
  	  && !ACCUMULATE_OUTGOING_ARGS && pass && adjusted_args_size.var == 0)
  	{
  	  int pushed = adjusted_args_size.constant + pending_stack_adjust;
--- 2578,2584 ----
  	 be deferred during the evaluation of the arguments.  */
        NO_DEFER_POP;
  
!       if (flag_stack_usage_info
  	  && !ACCUMULATE_OUTGOING_ARGS && pass && adjusted_args_size.var == 0)
  	{
  	  int pushed = adjusted_args_size.constant + pending_stack_adjust;
*************** emit_library_call_value_1 (int retval, r
*** 3577,3583 ****
    if (args_size.constant > current_function_outgoing_args_size)
      current_function_outgoing_args_size = args_size.constant;
  
!   if (flag_stack_usage && !ACCUMULATE_OUTGOING_ARGS)
      {
        int pushed = args_size.constant + pending_stack_adjust;
        if (pushed > current_function_pushed_stack_size)
--- 3580,3586 ----
    if (args_size.constant > current_function_outgoing_args_size)
      current_function_outgoing_args_size = args_size.constant;
  
!   if (flag_stack_usage_info && !ACCUMULATE_OUTGOING_ARGS)
      {
        int pushed = args_size.constant + pending_stack_adjust;
        if (pushed > current_function_pushed_stack_size)
*** gcc/cgraph.h.0	2006-12-18 08:24:44.831646648 +0100
--- gcc/cgraph.h	2006-12-18 08:41:47.859122832 +0100
*************** struct cgraph_rtl_info GTY(())
*** 109,114 ****
--- 109,134 ----
     int preferred_incoming_stack_boundary;
  };
  
+ /* Information about the function that is computed by various parts of
+    the compiler.  Available only for functions that have been already
+    assembled and if -fcallgraph-info was specified.  */
+ 
+ struct cgraph_final_edge GTY((chain_next ("%h.next")))
+ {
+   location_t location;
+   struct cgraph_node *caller;
+   struct cgraph_node *callee;
+   struct cgraph_final_edge *next;
+ };
+ 
+ struct cgraph_final_info GTY(())
+ {
+   struct cgraph_final_edge *calls;
+   int stack_usage_kind;
+   HOST_WIDE_INT stack_usage;
+   bool called;
+ };
+ 
  /* The cgraph data structure.
     Each function decl has assigned cgraph_node listing callees and callers.  */
  
*************** struct cgraph_node GTY((chain_next ("%h.
*** 139,145 ****
    struct cgraph_local_info local;
    struct cgraph_global_info global;
    struct cgraph_rtl_info rtl;
!   
    /* Expected number of executions: calculated in profile.c.  */
    gcov_type count;
    /* Unique id of the node.  */
--- 159,167 ----
    struct cgraph_local_info local;
    struct cgraph_global_info global;
    struct cgraph_rtl_info rtl;
! 
!   struct cgraph_final_info *final;
! 
    /* Expected number of executions: calculated in profile.c.  */
    gcov_type count;
    /* Unique id of the node.  */
*************** extern GTY(()) struct cgraph_varpool_nod
*** 225,230 ****
--- 247,253 ----
  
  /* In cgraph.c  */
  void dump_cgraph (FILE *);
+ void dump_cgraph_final_vcg (FILE *);
  void dump_cgraph_node (FILE *, struct cgraph_node *);
  void dump_varpool (FILE *);
  void dump_cgraph_varpool_node (FILE *, struct cgraph_varpool_node *);
*************** struct cgraph_edge *cgraph_create_edge (
*** 237,245 ****
--- 260,270 ----
  struct cgraph_node *cgraph_node (tree);
  struct cgraph_node *cgraph_node_for_asm (tree asmname);
  struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);
+ void cgraph_final_record_call (tree, tree, tree);
  struct cgraph_local_info *cgraph_local_info (tree);
  struct cgraph_global_info *cgraph_global_info (tree);
  struct cgraph_rtl_info *cgraph_rtl_info (tree);
+ struct cgraph_final_info *cgraph_final_info (tree);
  const char * cgraph_node_name (struct cgraph_node *);
  struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,
  				        struct cgraph_node *,
*** gcc/cgraph.c.0	2006-12-18 08:24:44.832646496 +0100
--- gcc/cgraph.c	2006-12-18 08:42:14.016146360 +0100
*************** cgraph_node (tree decl)
*** 202,207 ****
--- 202,209 ----
  
    node = cgraph_create_node ();
    node->decl = decl;
+   if (flag_callgraph_info)
+     node->final = ggc_alloc_cleared (sizeof (struct cgraph_final_info));
    *slot = node;
    if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)
      {
*************** cgraph_mark_needed_node (struct cgraph_n
*** 515,520 ****
--- 517,555 ----
    cgraph_mark_reachable_node (node);
  }
  
+ /* Create edge from CALLER to CALLEE in the final cgraph.  */
+ 
+ static struct cgraph_final_edge *
+ final_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,
+ 		   tree stmt)
+ {
+   struct cgraph_final_edge *e = ggc_alloc (sizeof (struct cgraph_final_edge));
+   e->location = EXPR_LOCATION (stmt);
+   e->caller = caller;
+   e->callee = callee;
+   e->next = caller->final->calls;
+   caller->final->calls = e;
+   return e;
+ }
+ 
+ /* Record call from SOURCE to DEST in the final cgraph.  */
+ 
+ void
+ cgraph_final_record_call (tree source, tree dest, tree stmt)
+ {
+   struct cgraph_node *callee;
+ 
+   if (dest)
+     {
+       callee = cgraph_node (dest);
+       callee->final->called = true;
+     }
+   else
+     callee = NULL;
+ 
+   (void) final_create_edge (cgraph_node (source), callee, stmt);
+ }
+ 
  /* Return local info for the compiled function.  */
  
  struct cgraph_local_info *
*************** cgraph_rtl_info (tree decl)
*** 554,559 ****
--- 589,608 ----
    return &node->rtl;
  }
  
+ /* Return final info for the compiled function.  */
+ 
+ struct cgraph_final_info *
+ cgraph_final_info (tree decl)
+ {
+   struct cgraph_node *node;
+   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);
+   node = cgraph_node (decl);
+   if (decl != current_function_decl
+       && !TREE_ASM_WRITTEN (node->decl))
+     return NULL;
+   return node->final;
+ }
+ 
  /* Return name of the node used in debug output.  */
  const char *
  cgraph_node_name (struct cgraph_node *node)
*************** dump_varpool (FILE *f)
*** 692,697 ****
--- 741,886 ----
      dump_cgraph_varpool_node (f, node);
  }
  
+ /* Dump placeholder node for indirect calls in VCG format.  */
+ 
+ #define INDIRECT_CALL_NAME  "__indirect_call"
+ 
+ static void
+ dump_cgraph_final_indirect_call_node_vcg (FILE *f)
+ {
+   static bool emitted = false;
+   if (emitted)
+     return;
+ 
+   fputs ("node: { title: \"", f);
+   fputs (INDIRECT_CALL_NAME, f);
+   fputs ("\" label: \"", f);
+   fputs ("Indirect Call Placeholder", f);
+   fputs ("\" shape : ellipse }\n", f);
+   emitted = true;
+ }
+ 
+ /* Dump final cgraph edge in VCG format.  */
+ 
+ static void
+ dump_cgraph_final_edge_vcg (FILE *f, struct cgraph_final_edge *edge)
+ {
+   expanded_location s;
+ 
+   fputs ("edge: { sourcename: \"", f);
+   print_decl_identifier (f, edge->caller->decl, PRINT_DECL_UNIQUE_NAME);
+   fputs ("\" targetname: \"", f);
+   if (edge->callee)
+     print_decl_identifier (f, edge->callee->decl, PRINT_DECL_UNIQUE_NAME);
+   else
+     fputs (INDIRECT_CALL_NAME, f);
+   fputs ("\" label: \"", f);
+   s = expand_location (edge->location);
+ #ifdef USE_MAPPED_LOCATION
+   if (flag_show_column && s.column != 0)
+     fprintf (f, "%s:%d:%d", s.file, s.line, s.column);
+   else
+ #endif
+     fprintf (f, "%s:%d", s.file, s.line);
+   fputs ("\" }\n", f);
+ 
+   if (!edge->callee)
+     dump_cgraph_final_indirect_call_node_vcg (f);
+ }
+ 
+ /* Dump final cgraph node in VCG format.  */
+ 
+ static void
+ dump_cgraph_final_node_vcg (FILE *f, struct cgraph_node *node)
+ {
+   struct cgraph_final_edge *edge;
+ 
+   fputs ("node: { title: \"", f);
+   print_decl_identifier (f, node->decl, PRINT_DECL_UNIQUE_NAME);
+   fputs ("\" label: \"", f);
+   print_decl_identifier (f, node->decl, PRINT_DECL_NAME);
+   fputs ("\\n", f);
+   print_decl_identifier (f, node->decl, PRINT_DECL_ORIGIN);
+ 
+   if (DECL_EXTERNAL (node->decl))
+     {
+       fputs ("\" shape : ellipse }\n", f);
+       return;
+     }
+ 
+   if (flag_callgraph_info & CALLGRAPH_INFO_STACK_USAGE)
+     {
+       if (node->final->stack_usage)
+ 	fprintf (f, "\\n"HOST_WIDE_INT_PRINT_DEC" bytes (%s)",
+ 		 node->final->stack_usage,
+ 		 stack_usage_qual[node->final->stack_usage_kind]);
+       else
+ 	fputs ("\\n0 bytes", f);
+     }
+ 
+   fputs ("\" }\n", f);
+ 
+   for (edge = node->final->calls; edge; edge = edge->next)
+     dump_cgraph_final_edge_vcg (f, edge);
+ }
+ 
+ /* Return true if NODE is needed in the final callgraph.  */
+ 
+ static inline bool
+ external_node_needed_p (struct cgraph_node *node)
+ {
+   static bool memcpy_node_seen = false;
+   static bool memset_node_seen = false;
+ 
+   /* External node that are eventually not called are not needed.  */
+   if (!node->final->called)
+     return false;
+ 
+   /* Take care of not emitting the MEMCPY node twice because of the
+      late creation of a clone by the RTL expander.  */
+   if ((DECL_BUILT_IN_CLASS (node->decl) == BUILT_IN_NORMAL
+        && DECL_FUNCTION_CODE (node->decl) == BUILT_IN_MEMCPY)
+       || node->decl == block_move_fn)
+     {
+       if (memcpy_node_seen)
+ 	return false;
+       else
+ 	memcpy_node_seen = true;
+     }
+ 
+   /* Likewise for the MEMSET node.  */
+   if ((DECL_BUILT_IN_CLASS (node->decl) == BUILT_IN_NORMAL
+        && DECL_FUNCTION_CODE (node->decl) == BUILT_IN_MEMSET)
+       || node->decl == block_clear_fn)
+     {
+       if (memset_node_seen)
+ 	return false;
+       else
+ 	memset_node_seen = true;
+     }
+ 
+   return true;
+ }
+ 
+ /* Dump the final cgraph in VCG format.  */
+ 
+ void
+ dump_cgraph_final_vcg (FILE *f)
+ {
+   struct cgraph_node *node;
+ 
+   /* Write the file header.  */
+   fprintf (f, "graph: { title: \"%s\"\n", main_input_filename);
+ 
+   /* Output only nodes that have been written in the final code.  */
+   for (node = cgraph_nodes; node; node = node->next)
+     if ((DECL_EXTERNAL (node->decl) && external_node_needed_p (node))
+ 	|| TREE_ASM_WRITTEN (node->decl))
+       dump_cgraph_final_node_vcg (f, node);
+ 
+   fputs ("}\n", f);
+ }
+ 
  /* Returns a hash code for P.  */
  
  static hashval_t
*** gcc/explow.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/explow.c	2006-12-17 00:31:43.000000000 +0100
*************** allocate_dynamic_stack_space (rtx size, 
*** 1052,1058 ****
    /* If stack usage info is requested, look into the size we are passed.
       We need to do so this early to avoid the obfuscation that may be
       introduced later by the various alignment operations.  */
!   if (flag_stack_usage)
      {
        if (GET_CODE (size) == CONST_INT)
  	stack_usage_size = INTVAL (size);
--- 1052,1058 ----
    /* If stack usage info is requested, look into the size we are passed.
       We need to do so this early to avoid the obfuscation that may be
       introduced later by the various alignment operations.  */
!   if (flag_stack_usage_info)
      {
        if (GET_CODE (size) == CONST_INT)
  	stack_usage_size = INTVAL (size);
*************** allocate_dynamic_stack_space (rtx size, 
*** 1116,1122 ****
  					BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
  			 NULL_RTX);
  
!       if (flag_stack_usage)
  	stack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;
  
        known_align_valid = false;
--- 1116,1122 ----
  					BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),
  			 NULL_RTX);
  
!       if (flag_stack_usage_info)
  	stack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;
  
        known_align_valid = false;
*************** allocate_dynamic_stack_space (rtx size, 
*** 1146,1152 ****
        /* The above dynamic offset cannot be computed statically at this
  	 point, but it will be possible to do so after RTL expansion is
  	 done.  Record how many times we will need to add it.  */
!       if (flag_stack_usage)
  	current_function_dynamic_alloc_count++;
  
        known_align_valid = false;
--- 1146,1152 ----
        /* The above dynamic offset cannot be computed statically at this
  	 point, but it will be possible to do so after RTL expansion is
  	 done.  Record how many times we will need to add it.  */
!       if (flag_stack_usage_info)
  	current_function_dynamic_alloc_count++;
  
        known_align_valid = false;
*************** allocate_dynamic_stack_space (rtx size, 
*** 1170,1176 ****
      {
        size = round_push (size);
  
!       if (flag_stack_usage)
  	{
  	  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
  	  stack_usage_size = (stack_usage_size + align - 1) / align * align;
--- 1170,1176 ----
      {
        size = round_push (size);
  
!       if (flag_stack_usage_info)
  	{
  	  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
  	  stack_usage_size = (stack_usage_size + align - 1) / align * align;
*************** allocate_dynamic_stack_space (rtx size, 
*** 1179,1185 ****
  
    /* The size is supposed to be fully adjusted at this point so record it
       if stack usage info is requested.  */
!   if (flag_stack_usage)
      {
        current_function_dynamic_stack_size += stack_usage_size;
  
--- 1179,1185 ----
  
    /* The size is supposed to be fully adjusted at this point so record it
       if stack usage info is requested.  */
!   if (flag_stack_usage_info)
      {
        current_function_dynamic_stack_size += stack_usage_size;
  
*** gcc/expr.c.0	2006-12-18 08:24:44.852643456 +0100
--- gcc/expr.c	2006-12-18 09:14:11.290676328 +0100
*************** emit_block_move_via_libcall (rtx dst, rt
*** 1374,1379 ****
--- 1374,1380 ----
    call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),
  		      call_expr, arg_list, NULL_TREE);
    CALL_EXPR_TAILCALL (call_expr) = tailcall;
+   SET_EXPR_LOCATION (call_expr, input_location);
  
    retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);
  
*************** emit_block_move_via_libcall (rtx dst, rt
*** 1384,1390 ****
     for the function we use for block copies.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! static GTY(()) tree block_move_fn;
  
  void
  init_block_move_fn (const char *asmspec)
--- 1384,1390 ----
     for the function we use for block copies.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! tree block_move_fn;
  
  void
  init_block_move_fn (const char *asmspec)
*************** clear_storage_via_libcall (rtx object, r
*** 2523,2528 ****
--- 2524,2530 ----
    call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),
  		      call_expr, arg_list, NULL_TREE);
    CALL_EXPR_TAILCALL (call_expr) = tailcall;
+   SET_EXPR_LOCATION (call_expr, input_location);
  
    retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);
  
*************** clear_storage_via_libcall (rtx object, r
*** 2533,2539 ****
     for the function we use for block clears.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! static GTY(()) tree block_clear_fn;
  
  void
  init_block_clear_fn (const char *asmspec)
--- 2533,2539 ----
     for the function we use for block clears.  The first time FOR_CALL
     is true, we call assemble_external.  */
  
! tree block_clear_fn;
  
  void
  init_block_clear_fn (const char *asmspec)
*************** const_vector_from_tree (tree exp)
*** 9262,9265 ****
  
    return gen_rtx_CONST_VECTOR (mode, v);
  }
- #include "gt-expr.h"
--- 9262,9264 ----
*** gcc/function.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/function.c	2006-12-17 00:31:44.000000000 +0100
*************** instantiate_virtual_regs (void)
*** 1728,1734 ****
  
    /* See allocate_dynamic_stack_space for the rationale.  */
  #ifdef SETJMP_VIA_SAVE_AREA
!   if (flag_stack_usage && current_function_calls_setjmp)
      {
        int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
        dynamic_offset = (dynamic_offset + align - 1) / align * align;
--- 1728,1734 ----
  
    /* See allocate_dynamic_stack_space for the rationale.  */
  #ifdef SETJMP_VIA_SAVE_AREA
!   if (flag_stack_usage_info && current_function_calls_setjmp)
      {
        int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
        dynamic_offset = (dynamic_offset + align - 1) / align * align;
*************** prepare_function_start (tree fndecl)
*** 3897,3903 ****
    init_emit ();
    init_varasm_status (cfun);
    init_expr ();
!   if (flag_stack_usage)
      cfun->su = ggc_alloc_cleared (sizeof (struct stack_usage));
  
    cse_not_expected = ! optimize;
--- 3897,3903 ----
    init_emit ();
    init_varasm_status (cfun);
    init_expr ();
!   if (flag_stack_usage_info)
      cfun->su = ggc_alloc_cleared (sizeof (struct stack_usage));
  
    cse_not_expected = ! optimize;
*** gcc/flow.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/flow.c	2006-12-17 00:31:43.000000000 +0100
*************** rest_of_handle_flow2 (void)
*** 4657,4663 ****
      cleanup_cfg (CLEANUP_EXPENSIVE);
  
    /* The IA-64 port invalidates its static stack usage info right after.  */
!   if (flag_stack_usage)
      output_stack_usage ();
  
    /* On some machines, the prologue and epilogue code, or parts thereof,
--- 4657,4663 ----
      cleanup_cfg (CLEANUP_EXPENSIVE);
  
    /* The IA-64 port invalidates its static stack usage info right after.  */
!   if (flag_stack_usage_info)
      output_stack_usage ();
  
    /* On some machines, the prologue and epilogue code, or parts thereof,
*** gcc/langhooks.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/langhooks.c	2006-12-17 00:31:43.000000000 +0100
*************** lhd_print_tree_nothing (FILE * ARG_UNUSE
*** 116,121 ****
--- 116,134 ----
  {
  }
  
+ void
+ lhd_print_decl_source_location (FILE *file, tree decl, int indent)
+ {
+   expanded_location xloc = expand_location (DECL_SOURCE_LOCATION (decl));
+   indent_to (file, indent);
+ #ifdef USE_MAPPED_LOCATION
+   if (flag_show_column && xloc.column != 0)
+     fprintf (file, "%s:%d:%d", xloc.file, xloc.line, xloc.column)
+   else
+ #endif
+   fprintf (file, "%s:%d", xloc.file, xloc.line);
+ }
+ 
  /* Called from safe_from_p.  */
  
  int
*** gcc/langhooks.h.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/langhooks.h	2006-12-17 00:31:43.000000000 +0100
*************** struct lang_hooks
*** 339,344 ****
--- 339,345 ----
    /* Called to print language-dependent parts of tcc_decl, tcc_type,
       and IDENTIFIER_NODE nodes.  */
    lang_print_tree_hook print_decl;
+   lang_print_tree_hook print_decl_source_location;
    lang_print_tree_hook print_type;
    lang_print_tree_hook print_identifier;
  
*** gcc/langhooks-def.h.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/langhooks-def.h	2006-12-17 00:31:43.000000000 +0100
*************** extern tree lhd_do_nothing_iii_return_nu
*** 52,57 ****
--- 52,58 ----
  extern int lhd_safe_from_p (rtx, tree);
  extern tree lhd_staticp (tree);
  extern void lhd_print_tree_nothing (FILE *, tree, int);
+ extern void lhd_print_decl_source_location (FILE *, tree, int);
  extern const char *lhd_decl_printable_name (tree, int);
  extern int lhd_types_compatible_p (tree, tree);
  extern rtx lhd_expand_expr (tree, rtx, enum machine_mode, int, rtx *);
*************** extern int lhd_gimplify_expr (tree *, tr
*** 115,120 ****
--- 116,122 ----
  #define LANG_HOOKS_PRINT_STATISTICS	lhd_do_nothing
  #define LANG_HOOKS_PRINT_XNODE		lhd_print_tree_nothing
  #define LANG_HOOKS_PRINT_DECL		lhd_print_tree_nothing
+ #define LANG_HOOKS_PRINT_DECL_SOURCE_LOCATION lhd_print_decl_source_location
  #define LANG_HOOKS_PRINT_TYPE		lhd_print_tree_nothing
  #define LANG_HOOKS_PRINT_IDENTIFIER	lhd_print_tree_nothing
  #define LANG_HOOKS_PRINT_ERROR_FUNCTION lhd_print_error_function
*************** extern tree lhd_make_node (enum tree_cod
*** 284,289 ****
--- 286,292 ----
    LANG_HOOKS_PRINT_STATISTICS, \
    LANG_HOOKS_PRINT_XNODE, \
    LANG_HOOKS_PRINT_DECL, \
+   LANG_HOOKS_PRINT_DECL_SOURCE_LOCATION, \
    LANG_HOOKS_PRINT_TYPE, \
    LANG_HOOKS_PRINT_IDENTIFIER, \
    LANG_HOOKS_DECL_PRINTABLE_NAME, \
*** gcc/print-tree.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/print-tree.c	2006-12-17 00:31:43.000000000 +0100
*************** print_node (FILE *file, const char *pref
*** 829,831 ****
--- 829,890 ----
  
    fprintf (file, ">");
  }
+ 
+ /* Print the identifier for DECL according to FLAGS.  */
+ 
+ void
+ print_decl_identifier (FILE *file, tree decl, int flags)
+ {
+   bool needs_colon = false;
+   const char *name;
+   char *malloced_name = NULL;
+   char p;
+ 
+   if (flags & PRINT_DECL_ORIGIN)
+     {
+       lang_hooks.print_decl_source_location (file, decl, 0);
+       needs_colon = true;
+     }
+ 
+   if (flags & PRINT_DECL_UNIQUE_NAME)
+     {
+       name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+       if (! TREE_PUBLIC (decl)
+ 	  || (DECL_WEAK (decl) && ! DECL_EXTERNAL (decl)))
+         /* The symbol has internal or weak linkage so its assembler name
+ 	   is not necessarily unique among the compilation units of the
+ 	   program.  We therefore have to further mangle it.  But we can't
+ 	   simply use DECL_SOURCE_FILE because it contains the name of the
+ 	   file the symbol originates from so, e.g. for function templates
+ 	   in C++ where the templates are defined in a header file, we can
+ 	   have symbols with the same assembler name and DECL_SOURCE_FILE.
+ 	   That's why we use the name of the top-level source file of the
+ 	   compilation unit.  ??? Unnecessary for Ada.  */
+ 	name = malloced_name = concat (main_input_filename, ":", name, NULL);
+     }
+   else if (flags & PRINT_DECL_NAME)
+     {
+       const char *dot;
+ 
+       name = lang_hooks.decl_printable_name (decl, 2);
+       dot = strrchr (name, '.');
+       if (dot)
+ 	name = dot + 1;
+     }
+   else
+     return;
+ 
+   if (needs_colon)
+     fputc (':', file);
+ 
+   while ((p = *name++) != 0)
+     {
+       /* Strip double-quotes because of VCG.  */
+       if (p == '"')
+ 	continue;
+       fputc (p, file);
+     }
+ 
+   if (malloced_name)
+     free (malloced_name);
+ }
*** gcc/toplev.h.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/toplev.h	2006-12-17 00:31:43.000000000 +0100
*************** extern void check_global_declarations (t
*** 100,106 ****
  extern void emit_debug_global_declarations (tree *, int);
  extern void write_global_declarations (void);
  
! /* Output stack usage information.  */
  extern void output_stack_usage (void);
  
  /* A unique local time stamp, might be zero if none is available.  */
--- 100,108 ----
  extern void emit_debug_global_declarations (tree *, int);
  extern void write_global_declarations (void);
  
! /* Stack usage.  */
! enum { SU_STATIC = 0, SU_DYNAMIC, SU_DYNAMIC_BOUNDED };
! extern const char *stack_usage_qual[];
  extern void output_stack_usage (void);
  
  /* A unique local time stamp, might be zero if none is available.  */
*** gcc/toplev.c.0	2006-12-17 00:12:14.000000000 +0100
--- gcc/toplev.c	2006-12-17 00:31:43.000000000 +0100
*************** int flag_var_tracking = AUTODETECT_VALUE
*** 342,347 ****
--- 342,353 ----
  /* Type of stack check.  */
  enum stack_check_type flag_stack_check = NO_STACK_CHECK;
  
+ /* Output callgraph information on a per-file basis.  */
+ int flag_callgraph_info;
+ 
+ /* Compute stack usage information on a per-function basis.  */
+ int flag_stack_usage_info;
+ 
  /* True if the user has tagged the function with the 'section'
     attribute.  */
  
*************** default_tree_printer (pretty_printer * p
*** 1424,1443 ****
    return true;
  }
  
  /* Output stack usage information.  */
  void
  output_stack_usage (void)
  {
    static bool warning_issued = false;
-   enum stack_usage_kind_type { STATIC = 0, DYNAMIC, DYNAMIC_BOUNDED };
-   const char *stack_usage_kind_str[] = {
-     "static",
-     "dynamic",
-     "dynamic,bounded"
-   };
    HOST_WIDE_INT stack_usage = -1;
!   enum stack_usage_kind_type stack_usage_kind;
!   const char *raw_id, *id;
  
    /* Rely on the back-end to compute the maximum static stack usage.
       The back-end needs this information at one point or another to
--- 1430,1444 ----
    return true;
  }
  
+ const char *stack_usage_qual[] = { "static", "dynamic", "dynamic,bounded" };
+ 
  /* Output stack usage information.  */
  void
  output_stack_usage (void)
  {
    static bool warning_issued = false;
    HOST_WIDE_INT stack_usage = -1;
!   int stack_usage_kind;
  
    /* Rely on the back-end to compute the maximum static stack usage.
       The back-end needs this information at one point or another to
*************** output_stack_usage (void)
*** 1456,1497 ****
        return;
      }
  
!   stack_usage_kind = STATIC;
  
    /* Add the maximum amount of space pushed onto the stack.  */
    if (current_function_pushed_stack_size > 0)
      {
        stack_usage += current_function_pushed_stack_size;
!       stack_usage_kind = DYNAMIC_BOUNDED;
      }
  
    /* Now on to the tricky part: dynamic stack allocation.  */
    if (current_function_allocates_dynamic_stack_space)
      {
        if (current_function_has_unbounded_dynamic_stack_size)
! 	stack_usage_kind = DYNAMIC;
        else
! 	stack_usage_kind = DYNAMIC_BOUNDED;
  
        /* Add the size even in the unbounded case, this can't hurt.  */
        stack_usage += current_function_dynamic_stack_size;
      }
  
!   /* Strip the scope prefix if any.  */
!   raw_id = lang_hooks.decl_printable_name (current_function_decl, 2);
!   id = strrchr (raw_id, '.');
!   if (id)
!     id++;
!   else
!     id = raw_id;
  
!   fprintf (stack_usage_file,
! 	   "%s:%d:%s\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
! 	   basename (DECL_SOURCE_FILE (current_function_decl)),
! 	   DECL_SOURCE_LINE (current_function_decl),
! 	   id,
! 	   stack_usage,
! 	   stack_usage_kind_str[stack_usage_kind]);
  }
  
  /* Open an auxiliary output file.  */
--- 1457,1498 ----
        return;
      }
  
!   stack_usage_kind = SU_STATIC;
  
    /* Add the maximum amount of space pushed onto the stack.  */
    if (current_function_pushed_stack_size > 0)
      {
        stack_usage += current_function_pushed_stack_size;
!       stack_usage_kind = SU_DYNAMIC_BOUNDED;
      }
  
    /* Now on to the tricky part: dynamic stack allocation.  */
    if (current_function_allocates_dynamic_stack_space)
      {
        if (current_function_has_unbounded_dynamic_stack_size)
! 	stack_usage_kind = SU_DYNAMIC;
        else
! 	stack_usage_kind = SU_DYNAMIC_BOUNDED;
  
        /* Add the size even in the unbounded case, this can't hurt.  */
        stack_usage += current_function_dynamic_stack_size;
      }
  
!   if (flag_callgraph_info & CALLGRAPH_INFO_STACK_USAGE)
!     {
!       struct cgraph_final_info *cfi
! 	= cgraph_final_info (current_function_decl);
!       cfi->stack_usage = stack_usage;
!       cfi->stack_usage_kind = stack_usage_kind;
!     }
  
!   if (flag_stack_usage)
!     {
!       print_decl_identifier (stack_usage_file, current_function_decl,
! 			     PRINT_DECL_ORIGIN | PRINT_DECL_NAME);
!       fprintf (stack_usage_file, "\t"HOST_WIDE_INT_PRINT_DEC"\t%s\n",
! 	       stack_usage, stack_usage_qual[stack_usage_kind]);
!     }
  }
  
  /* Open an auxiliary output file.  */
*************** finalize (void)
*** 1996,2001 ****
--- 1997,2009 ----
    if (stack_usage_file)
      fclose (stack_usage_file);
  
+   if (flag_callgraph_info)
+     {
+       FILE *file = open_auxiliary_file ("ci");
+       dump_cgraph_final_vcg (file);
+       fclose (file);
+     }
+ 
    finish_optimization_passes ();
  
    if (mem_report)
*** gcc/tree.h.0	2006-12-18 08:24:44.875639960 +0100
--- gcc/tree.h	2006-12-18 09:02:35.716419688 +0100
*************** extern void print_node (FILE *, const ch
*** 4028,4033 ****
--- 4028,4037 ----
  extern void print_node_brief (FILE *, const char *, tree, int);
  extern void indent_to (FILE *, int);
  #endif
+ #define PRINT_DECL_ORIGIN       0x1
+ #define PRINT_DECL_NAME         0x2
+ #define PRINT_DECL_UNIQUE_NAME  0x4
+ extern void print_decl_identifier (FILE *, tree, int flags);
  
  /* In tree-inline.c:  */
  extern bool debug_find_tree (tree, tree);
*************** extern void fini_object_sizes (void);
*** 4252,4257 ****
--- 4256,4263 ----
  extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);
  
  /* In expr.c.  */
+ extern GTY(()) tree block_move_fn;
+ extern GTY(()) tree block_clear_fn;
  extern unsigned HOST_WIDE_INT highest_pow2_factor (tree);
  
  #endif  /* GCC_TREE_H  */
*** gcc/Makefile.in.0	2006-12-18 10:05:26.864118096 +0100
--- gcc/Makefile.in	2006-12-18 10:05:33.701078720 +0100
*************** expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) 
*** 2099,2105 ****
     libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \
     typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h reload.h \
     $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H) \
!    tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \
     tree-pass.h
  dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
--- 2099,2105 ----
     libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \
     typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h reload.h \
     $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H) \
!    tree-iterator.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \
     tree-pass.h
  dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
     $(FLAGS_H) function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
*************** gt-cgraph.h gt-coverage.h gtype-desc.h g
*** 2779,2785 ****
  gt-function.h gt-integrate.h gt-tree.h gt-varasm.h \
  gt-emit-rtl.h gt-stor-layout.h gt-regclass.h \
  gt-lists.h gt-alias.h gt-cselib.h gt-gcse.h \
! gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \
  gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \
  gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parser.h \
  gt-c-pragma.h gtype-c.h gt-cfglayout.h \
--- 2779,2785 ----
  gt-function.h gt-integrate.h gt-tree.h gt-varasm.h \
  gt-emit-rtl.h gt-stor-layout.h gt-regclass.h \
  gt-lists.h gt-alias.h gt-cselib.h gt-gcse.h \
! gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \
  gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \
  gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parser.h \
  gt-c-pragma.h gtype-c.h gt-cfglayout.h \
*** gcc/tree-nested.c.0	2006-03-17 13:23:14.000000000 +0100
--- gcc/tree-nested.c	2006-03-19 07:34:35.000000000 +0100
*************** struct nesting_info GTY ((chain_next ("%
*** 88,94 ****
    struct nesting_info *outer;
    struct nesting_info *inner;
    struct nesting_info *next;
!   
    htab_t GTY ((param_is (struct var_map_elt))) var_map;
    tree context;
    tree new_local_var_chain;
--- 88,95 ----
    struct nesting_info *outer;
    struct nesting_info *inner;
    struct nesting_info *next;
!   struct nesting_info *next_reachable;
! 
    htab_t GTY ((param_is (struct var_map_elt))) var_map;
    tree context;
    tree new_local_var_chain;
*************** struct nesting_info GTY ((chain_next ("%
*** 100,107 ****
--- 101,140 ----
  
    bool any_parm_remapped;
    bool any_tramp_created;
+   bool reachable;
  };
  
+ /* Whether to discard unreachable nested functions during this pass.
+    If this is set to false, the pass will not differentiate objects
+    referenced by a reachable inner function from objects referenced
+    by an unreachable inner function: both will end up being members
+    of the "nonlocal frame struct" after the pass and not standalone
+    objects anymore.  That means they will be allocated in memory
+    since the "nonlocal frame struct" is always addressable.  */
+ 
+ static bool discard_unreachable;
+ 
+ #define IS_UNREACHABLE(ni) (discard_unreachable && !(ni)->reachable)
+ 
+ /* Hash table used to look up nesting_info from nesting_info->context.  */
+ 
+ static htab_t ni_map;
+ 
+ /* Hashing and equality functions for ni_map.  */
+ 
+ static hashval_t
+ ni_hash (const void *p)
+ {
+   const struct nesting_info *i = p;
+   return (hashval_t) DECL_UID (i->context);
+ }
+ 
+ static int
+ ni_eq (const void *p1, const void *p2)
+ {
+   const struct nesting_info *i1 = p1, *i2 = p2;
+   return DECL_UID (i1->context) == DECL_UID (i2->context);
+ }
  
  /* Hashing and equality functions for nesting_info->var_map.  */
  
*************** get_frame_type (struct nesting_info *inf
*** 224,235 ****
        info->frame_type = type;
        info->frame_decl = create_tmp_var_for (info, type, "FRAME");
  
!       /* ??? Always make it addressable for now, since it is meant to
! 	 be pointed to by the static chain pointer.  This pessimizes
! 	 when it turns out that no static chains are needed because
! 	 the nested functions referencing non-local variables are not
! 	 reachable, but the true pessimization is to create the non-
! 	 local frame structure in the first place.  */
        TREE_ADDRESSABLE (info->frame_decl) = 1;
      }
    return type;
--- 257,264 ----
        info->frame_type = type;
        info->frame_decl = create_tmp_var_for (info, type, "FRAME");
  
!       /* It is always addressable since it will be pointed to
! 	 by the static chain pointer.  */
        TREE_ADDRESSABLE (info->frame_decl) = 1;
      }
    return type;
*************** walk_function (walk_tree_fn callback, st
*** 651,664 ****
  static void
  walk_all_functions (walk_tree_fn callback, struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
  	walk_all_functions (callback, root->inner);
        walk_function (callback, root);
-       root = root->next;
      }
-   while (root);
  }
  
  /* We have to check for a fairly pathological case.  The operands of function
--- 680,694 ----
  static void
  walk_all_functions (walk_tree_fn callback, struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
+       if (IS_UNREACHABLE (root))
+ 	continue;
+ 
        if (root->inner)
  	walk_all_functions (callback, root->inner);
        walk_function (callback, root);
      }
  }
  
  /* We have to check for a fairly pathological case.  The operands of function
*************** check_for_nested_with_variably_modified 
*** 709,718 ****
--- 739,753 ----
  static struct nesting_info *
  create_nesting_tree (struct cgraph_node *cgn)
  {
+   struct nesting_info **slot;
    struct nesting_info *info = ggc_calloc (1, sizeof (*info));
    info->var_map = htab_create_ggc (7, var_map_hash, var_map_eq, ggc_free);
    info->context = cgn->decl;
  
+   slot = (struct nesting_info **) htab_find_slot (ni_map, info, INSERT);
+   gcc_assert (*slot == NULL);
+   *slot = info;
+ 
    for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)
      {
        struct nesting_info *sub = create_nesting_tree (cgn);
*************** create_nesting_tree (struct cgraph_node 
*** 729,734 ****
--- 764,847 ----
    return info;
  }
  
+ /* Queue of reachable nested functions to be analyzed.  */
+ 
+ static struct nesting_info *reachable_queue;
+ 
+ /* Mark FNDECL as reachable if it is not already and add it to the queue.  */
+ 
+ static void
+ mark_reachable_function_1 (tree fndecl)
+ {
+   struct nesting_info dummy;
+   struct nesting_info *info;
+   struct nesting_info **slot;
+ 
+   dummy.context = fndecl;
+   slot = (struct nesting_info **) htab_find_slot (ni_map, &dummy, NO_INSERT);
+   gcc_assert (slot != NULL);
+   info = *slot;
+ 
+   if (!info->reachable)
+     {
+       info->reachable = true;
+       info->next_reachable = reachable_queue;
+       reachable_queue = info;
+     }
+ }
+ 
+ /* Called via walk_function+walk_tree, mark the nested functions
+    that are reachable from TP.  */
+ 
+ static tree
+ mark_reachable_functions_1 (tree *tp, int *walk_subtrees, void *data)
+ {
+   struct walk_stmt_info *wi = data;
+   tree t = *tp, decl;
+ 
+   *walk_subtrees = 0;
+   switch (TREE_CODE (t))
+     {
+     case FDESC_EXPR:
+     case ADDR_EXPR:
+       decl = TREE_OPERAND (t, 0);
+       if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))
+ 	mark_reachable_function_1 (decl);
+       break;
+ 
+     case CALL_EXPR:
+       decl = get_callee_fndecl (t);
+       if (decl && decl_function_context (decl))
+ 	mark_reachable_function_1 (decl);
+ 
+       walk_tree (&TREE_OPERAND (t, 1), mark_reachable_functions_1, wi, NULL);
+       break;
+ 
+     default:
+       if (!IS_TYPE_OR_DECL_P (t))
+ 	*walk_subtrees = 1;
+       break;
+     }
+ 
+   return NULL_TREE;
+ }
+ 
+ /* Find out which nested functions are reachable from ROOT.  */
+ 
+ static void
+ mark_reachable_functions (struct nesting_info *root)
+ {
+   root->reachable = true;
+   reachable_queue = root;
+ 
+   while (reachable_queue)
+     {
+       struct nesting_info *i = reachable_queue;
+       reachable_queue = reachable_queue->next_reachable;
+       walk_function (mark_reachable_functions_1, i);
+     }
+ }
+   
  /* Return an expression computing the static chain for TARGET_CONTEXT
     from INFO->CONTEXT.  Insert any necessary computations before TSI.  */
  
*************** convert_call_expr (tree *tp, int *walk_s
*** 1309,1316 ****
  static void
  convert_all_function_calls (struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
  	convert_all_function_calls (root->inner);
  
--- 1422,1432 ----
  static void
  convert_all_function_calls (struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
+       if (IS_UNREACHABLE (root))
+ 	continue;
+ 
        if (root->inner)
  	convert_all_function_calls (root->inner);
  
*************** convert_all_function_calls (struct nesti
*** 1322,1331 ****
  	DECL_NO_STATIC_CHAIN (root->context) = 1;
        else
  	gcc_assert (!DECL_NO_STATIC_CHAIN (root->context));
- 
-       root = root->next;
      }
-   while (root);
  }
  
  /* Do "everything else" to clean up or complete state collected by the
--- 1438,1444 ----
*************** finalize_nesting_tree_1 (struct nesting_
*** 1339,1345 ****
    tree stmt_list = NULL;
    tree context = root->context;
    struct function *sf;
-   struct cgraph_node *node;
  
    /* If we created a non-local frame type or decl, we need to lay them
       out at this time.  */
--- 1452,1457 ----
*************** finalize_nesting_tree_1 (struct nesting_
*** 1455,1482 ****
  
    /* Dump the translated tree function.  */
    dump_function (TDI_nested, root->context);
!   node = cgraph_node (root->context);
  
    /* For nested functions update the cgraph to reflect unnesting.
       We also delay finalizing of these functions up to this point.  */
    if (node->origin)
      {
!        cgraph_unnest_node (cgraph_node (root->context));
!        cgraph_finalize_function (root->context, true);
      }
  }
  
  static void
! finalize_nesting_tree (struct nesting_info *root)
  {
!   do
      {
        if (root->inner)
! 	finalize_nesting_tree (root->inner);
!       finalize_nesting_tree_1 (root);
!       root = root->next;
      }
-   while (root);
  }
  
  /* Free the data structures allocated during this pass.  */
--- 1567,1618 ----
  
    /* Dump the translated tree function.  */
    dump_function (TDI_nested, root->context);
! }
! 
! static void
! finalize_nesting_tree (struct nesting_info *root)
! {
!   for (; root; root = root->next)
!     {
!       if (IS_UNREACHABLE (root))
! 	continue;
! 
!       if (root->inner)
! 	finalize_nesting_tree (root->inner);
!       finalize_nesting_tree_1 (root);
!     }
! }
! 
! /* Unnest the nodes and pass them to cgraph.  */
! 
! static void
! unnest_nesting_tree_1 (struct nesting_info *root)
! {
!   struct cgraph_node *node = cgraph_node (root->context);
  
    /* For nested functions update the cgraph to reflect unnesting.
       We also delay finalizing of these functions up to this point.  */
    if (node->origin)
      {
!       if (IS_UNREACHABLE (root))
! 	cgraph_remove_node (node);
!       else
! 	{
! 	  cgraph_unnest_node (node);
! 	  cgraph_finalize_function (root->context, true);
! 	}
      }
  }
  
  static void
! unnest_nesting_tree (struct nesting_info *root)
  {
!   for (; root; root = root->next)
      {
        if (root->inner)
! 	unnest_nesting_tree (root->inner);
!       unnest_nesting_tree_1 (root);
      }
  }
  
  /* Free the data structures allocated during this pass.  */
*************** static void
*** 1485,1500 ****
  free_nesting_tree (struct nesting_info *root)
  {
    struct nesting_info *next;
!   do
      {
        if (root->inner)
  	free_nesting_tree (root->inner);
        htab_delete (root->var_map);
        next = root->next;
        ggc_free (root);
-       root = next;
      }
-   while (root);
  }
  
  static GTY(()) struct nesting_info *root;
--- 1621,1635 ----
  free_nesting_tree (struct nesting_info *root)
  {
    struct nesting_info *next;
! 
!   for (; root; root = next)
      {
        if (root->inner)
  	free_nesting_tree (root->inner);
        htab_delete (root->var_map);
        next = root->next;
        ggc_free (root);
      }
  }
  
  static GTY(()) struct nesting_info *root;
*************** lower_nested_functions (tree fndecl)
*** 1512,1526 ****
--- 1647,1669 ----
    if (!cgn->nested)
      return;
  
+   /* Do not discard unreachable nested functions at -O0.  */
+   discard_unreachable = (optimize > 0);
+ 
+   ni_map = htab_create (11, ni_hash, ni_eq, NULL);
    root = create_nesting_tree (cgn);
+   if (discard_unreachable)
+     mark_reachable_functions (root);
    walk_all_functions (convert_nonlocal_reference, root);
    walk_all_functions (convert_local_reference, root);
    walk_all_functions (convert_nl_goto_reference, root);
    walk_all_functions (convert_nl_goto_receiver, root);
    convert_all_function_calls (root);
    finalize_nesting_tree (root);
+   unnest_nesting_tree (root);
    free_nesting_tree (root);
    root = NULL;
+   htab_delete (ni_map);
  }
  
  #include "gt-tree-nested.h"
*** gcc/tree.c.0	2006-05-15 09:26:51.000000000 +0200
--- gcc/tree.c	2006-05-15 09:36:41.321720768 +0200
*************** variably_modified_type_p (tree type, tre
*** 5625,5637 ****
       When a representation is chosen, this function should be modified
       to test for that case as well.  */
    RETURN_TRUE_IF_VAR (TYPE_SIZE (type));
!   RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT(type));
  
    switch (TREE_CODE (type))
      {
      case POINTER_TYPE:
      case REFERENCE_TYPE:
-     case ARRAY_TYPE:
      case VECTOR_TYPE:
        if (variably_modified_type_p (TREE_TYPE (type), fn))
  	return true;
--- 5625,5636 ----
       When a representation is chosen, this function should be modified
       to test for that case as well.  */
    RETURN_TRUE_IF_VAR (TYPE_SIZE (type));
!   RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT (type));
  
    switch (TREE_CODE (type))
      {
      case POINTER_TYPE:
      case REFERENCE_TYPE:
      case VECTOR_TYPE:
        if (variably_modified_type_p (TREE_TYPE (type), fn))
  	return true;
*************** variably_modified_type_p (tree type, tre
*** 5681,5686 ****
--- 5680,5692 ----
  	  }
  	break;
  
+     case ARRAY_TYPE:
+       /* Do not call ourselves to avoid infinite recursion.  This is
+ 	 variably modified if the element type is.  */
+       RETURN_TRUE_IF_VAR (TYPE_SIZE (TREE_TYPE (type)));
+       RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT (TREE_TYPE (type)));
+       break;
+ 
      default:
        break;
      }
*** gcc/gimplify.c.ori	2006-03-22 14:24:11.000000000 +0100
--- gcc/gimplify.c	2006-05-15 14:05:30.000000000 +0200
*************** gimplify_variable_sized_compare (tree *e
*** 3418,3423 ****
--- 3423,3449 ----
    return GS_OK;
  }
  
+ /*  Gimplify a comparison between two aggregate objects of integral scalar
+     mode as a comparison between the bitwise equivalent scalar values.  */
+ 
+ static enum gimplify_status
+ gimplify_scalar_mode_aggregate_compare (tree *expr_p)
+ {
+   tree op0 = TREE_OPERAND (*expr_p, 0);
+   tree op1 = TREE_OPERAND (*expr_p, 1);
+ 
+   tree type = TREE_TYPE (op0);
+   tree scalar_type = lang_hooks.types.type_for_mode (TYPE_MODE (type), 1);
+ 
+   op0 = fold_build1 (VIEW_CONVERT_EXPR, scalar_type, op0);
+   op1 = fold_build1 (VIEW_CONVERT_EXPR, scalar_type, op1);
+ 
+   *expr_p
+     = fold_build2 (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), op0, op1);
+ 
+   return GS_OK;
+ }
+ 
  /*  Gimplify TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR expressions.  EXPR_P
      points to the expression to gimplify.
  
*************** gimplify_expr (tree *expr_p, tree *pre_p
*** 4498,4513 ****
  	  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))
  	    {
  	    case tcc_comparison:
! 	      /* If this is a comparison of objects of aggregate type,
! 	     	 handle it specially (by converting to a call to
! 	     	 memcmp).  It would be nice to only have to do this
! 	     	 for variable-sized objects, but then we'd have to
! 	     	 allow the same nest of reference nodes we allow for
! 	     	 MODIFY_EXPR and that's too complex.  */
! 	      if (!AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 1))))
! 		goto expr_2;
! 	      ret = gimplify_variable_sized_compare (expr_p);
! 	      break;
  
  	    /* If *EXPR_P does not need to be special-cased, handle it
  	       according to its class.  */
--- 4524,4551 ----
  	  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))
  	    {
  	    case tcc_comparison:
! 	      /* Handle comparison of objects of non scalar mode aggregates
! 	     	 with a call to memcmp.  It would be nice to only have to do
! 	     	 this for variable-sized objects, but then we'd have to allow
! 	     	 the same nest of reference nodes we allow for MODIFY_EXPR and
! 	     	 that's too complex.
! 
! 		 Compare scalar mode aggregates as scalar mode values.  Using
! 		 memcmp for them would be very inefficient at best, and is
! 		 plain wrong if bitfields are involved.  */
! 
! 	      {
! 		tree type = TREE_TYPE (TREE_OPERAND (*expr_p, 1));
! 
! 		if (!AGGREGATE_TYPE_P (type))
! 		  goto expr_2;
! 		else if (TYPE_MODE (type) != BLKmode)
! 		  ret = gimplify_scalar_mode_aggregate_compare (expr_p);
! 		else
! 		  ret = gimplify_variable_sized_compare (expr_p);
! 
! 		break;
! 		}
  
  	    /* If *EXPR_P does not need to be special-cased, handle it
  	       according to its class.  */
*** gcc/tree-ssa-loop-ivopts.c.0	2006-05-18 11:13:35.000000000 +0200
--- gcc/tree-ssa-loop-ivopts.c	2006-05-18 14:33:48.011036688 +0200
*************** may_be_unaligned_p (tree ref)
*** 1510,1515 ****
--- 1510,1552 ----
    return false;
  }
  
+ /* Return true if EXPR may be non-addressable.   */
+ 
+ static bool
+ may_be_nonaddressable_p (tree expr)
+ {
+   while (1)
+     {
+       switch (TREE_CODE (expr))
+ 	{
+ 	case COMPONENT_REF:
+ 	  /* If bit field or otherwise nonaddressable, stop.  */
+ 	  if (DECL_BIT_FIELD (TREE_OPERAND (expr, 1))
+ 	      || DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1)))
+ 	    return true;
+ 
+ 	  /* ... otherwise fall through and check our operand ... */
+ 	case ARRAY_REF:
+ 	case ARRAY_RANGE_REF:
+ 	case VIEW_CONVERT_EXPR:
+ 	  expr = TREE_OPERAND (expr, 0);
+ 	  break;
+ 
+ 	  /* TARGET_MEM_REFs are translated directly to valid MEMs on the
+ 	     target, thus they are always addressable.  */
+ 	case TARGET_MEM_REF:
+ 	case VAR_DECL:
+ 	case PARM_DECL:
+ 	case RESULT_DECL:
+ 	  return false;
+ 
+ 	  /* Everything else is something we can't take the address of.  */
+ 	default:
+ 	  return true;
+ 	}
+     }
+ }
+ 
  /* Finds addresses in *OP_P inside STMT.  */
  
  static void
*************** find_interesting_uses_address (struct iv
*** 1524,1534 ****
    if (stmt_ann (stmt)->has_volatile_ops)
      goto fail;
  
!   /* Ignore bitfields for now.  Not really something terribly complicated
!      to handle.  TODO.  */
!   if (TREE_CODE (base) == BIT_FIELD_REF
!       || (TREE_CODE (base) == COMPONENT_REF
! 	  && DECL_NONADDRESSABLE_P (TREE_OPERAND (base, 1))))
      goto fail;
  
    if (STRICT_ALIGNMENT
--- 1561,1570 ----
    if (stmt_ann (stmt)->has_volatile_ops)
      goto fail;
  
!   /* We're going to take the address of this thing, so we need to make
!      sure that it's addressable.  For example, bit fields aren't and
!      neither are VIEW_CONVERT_EXPRs whose operands aren't addressable.  */
!   if (may_be_nonaddressable_p (base))
      goto fail;
  
    if (STRICT_ALIGNMENT
*** gcc/dwarf2out.c.0	Thu May 11 16:35:25 2006
--- gcc/dwarf2out.c	Thu May 11 17:03:02 2006
*************** output_comp_unit (dw_die_ref die, int ou
*** 7234,7247 ****
      }
  }
  
! /* The DWARF2 pubname for a nested thingy looks like "A::f".  The
!    output of lang_hooks.decl_printable_name for C++ looks like
!    "A::f(int)".  Let's drop the argument list, and maybe the scope.  */
  
  static const char *
  dwarf2_name (tree decl, int scope)
  {
!   return lang_hooks.decl_printable_name (decl, scope ? 1 : 0);
  }
  
  /* Add a new entry to .debug_pubnames if appropriate.  */
--- 7234,7245 ----
      }
  }
  
! /* Return the DWARF2/3 name associated with a decl.  */
  
  static const char *
  dwarf2_name (tree decl, int scope)
  {
!   return lang_hooks.dwarf_name (decl, scope ? 1 : 0);
  }
  
  /* Add a new entry to .debug_pubnames if appropriate.  */
*** gcc/langhooks-def.h.0	Thu May 11 16:35:25 2006
--- gcc/langhooks-def.h	Thu May 11 16:44:27 2006
*************** extern int lhd_safe_from_p (rtx, tree);
*** 54,59 ****
--- 54,60 ----
  extern void lhd_print_tree_nothing (FILE *, tree, int);
  extern void lhd_print_decl_source_location (FILE *, tree, int);
  extern const char *lhd_decl_printable_name (tree, int);
+ extern const char *lhd_dwarf_name (tree, int);
  extern int lhd_types_compatible_p (tree, tree);
  extern rtx lhd_expand_expr (tree, rtx, enum machine_mode, int, rtx *);
  extern int lhd_expand_decl (tree);
*************** extern int lhd_gimplify_expr (tree *, tr
*** 121,126 ****
--- 121,127 ----
  #define LANG_HOOKS_PRINT_IDENTIFIER	lhd_print_tree_nothing
  #define LANG_HOOKS_PRINT_ERROR_FUNCTION lhd_print_error_function
  #define LANG_HOOKS_DECL_PRINTABLE_NAME	lhd_decl_printable_name
+ #define LANG_HOOKS_DWARF_NAME		lhd_dwarf_name
  #define LANG_HOOKS_GET_CALLEE_FNDECL	lhd_return_null_tree
  #define LANG_HOOKS_EXPR_SIZE		lhd_expr_size
  #define LANG_HOOKS_TREE_SIZE		lhd_tree_size
*************** extern tree lhd_make_node (enum tree_cod
*** 290,295 ****
--- 291,297 ----
    LANG_HOOKS_PRINT_TYPE, \
    LANG_HOOKS_PRINT_IDENTIFIER, \
    LANG_HOOKS_DECL_PRINTABLE_NAME, \
+   LANG_HOOKS_DWARF_NAME, \
    LANG_HOOKS_TYPES_COMPATIBLE_P, \
    LANG_HOOKS_GET_CALLEE_FNDECL, \
    LANG_HOOKS_PRINT_ERROR_FUNCTION, \
*** gcc/langhooks.h.0	Thu May 11 16:35:25 2006
--- gcc/langhooks.h	Thu May 11 16:43:19 2006
*************** struct lang_hooks
*** 351,356 ****
--- 351,363 ----
       types in C++.  */
    const char *(*decl_printable_name) (tree decl, int verbosity);
  
+   /* Computes the dwarf-2/3 name for a tree.  VERBOSITY determines what
+      information will be printed: 0: DECL_NAME, demangled as
+      necessary.  1: and scope information.  2: and any other
+      information that might be interesting, such as function parameter
+      types in C++.  */
+   const char *(*dwarf_name) (tree, int verbosity);
+ 
    /* This compares two types for equivalence ("compatible" in C-based languages).
       This routine should only return 1 if it is sure.  It should not be used
       in contexts where erroneously returning 0 causes problems.  */
*** gcc/langhooks.c.0	Thu May 11 16:35:25 2006
--- gcc/langhooks.c	Fri May 19 14:42:44 2006
***************
*** 268,273 ****
--- 268,282 ----
    return 0;
  }
  
+ /* This is the default dwarf_name function.  */
+ 
+ const char *
+ lhd_dwarf_name (tree t, int verbosity)
+ {
+   gcc_assert (DECL_P (t));
+   return lang_hooks.decl_printable_name (t, verbosity);
+ }
+ 
  /* This is the default decl_printable_name function.  */
  
  const char *
*** gcc/doc/invoke.texi.0	2006-05-20 18:21:22.548676488 +0200
--- gcc/doc/invoke.texi	2006-05-20 18:21:44.028411072 +0200
*************** compilation time.
*** 4435,4444 ****
  @option{-O} also turns on @option{-fomit-frame-pointer} on machines
  where doing so does not interfere with debugging.
  
- @option{-O} doesn't turn on @option{-ftree-sra} for the Ada compiler.
- This option must be explicitly specified on the command line to be
- enabled for the Ada compiler.
- 
  @item -O2
  @opindex O2
  Optimize even more.  GCC performs nearly all supported optimizations
--- 4435,4440 ----
*** gcc/tree.c.ori	2006-05-23 08:45:59.000000000 +0200
--- gcc/tree.c	2006-05-23 08:46:57.000000000 +0200
*************** int_size_in_bytes (tree type)
*** 1671,1676 ****
--- 1671,1709 ----
  
    return TREE_INT_CST_LOW (t);
  }
+ 
+ /* Return the maximum size of TYPE (in bytes) as a wide integer
+    or return -1 if the size can vary or is larger than an integer.  */
+ 
+ HOST_WIDE_INT
+ max_int_size_in_bytes (tree type)
+ {
+   HOST_WIDE_INT size = -1;
+   tree size_tree;
+ 
+   /* If this is an array type, check for a possible MAX_SIZE attached.  */
+ 
+   if (TREE_CODE (type) == ARRAY_TYPE)
+     {
+       size_tree = TYPE_ARRAY_MAX_SIZE (type);
+ 
+       if (size_tree && host_integerp (size_tree, 1))
+ 	size = tree_low_cst (size_tree, 1);
+     }
+ 
+   /* If we still haven't been able to get a size, see if the language
+      can compute a maximum size.  */
+ 
+   if (size == -1)
+     {
+       size_tree = lang_hooks.types.max_size (type);
+ 
+       if (size_tree && host_integerp (size_tree, 1))
+ 	size = tree_low_cst (size_tree, 1);
+     }
+ 
+   return size;
+ }
  
  /* Return the bit position of FIELD, in bits from the start of the record.
     This is a tree of type bitsizetype.  */
*** gcc/tree.h.ori	2006-05-23 08:45:52.000000000 +0200
--- gcc/tree.h	2006-05-23 08:46:57.000000000 +0200
*************** extern tree expr_last (tree);
*** 3510,3515 ****
--- 3510,3516 ----
  extern tree expr_only (tree);
  extern tree size_in_bytes (tree);
  extern HOST_WIDE_INT int_size_in_bytes (tree);
+ extern HOST_WIDE_INT max_int_size_in_bytes (tree);
  extern tree bit_position (tree);
  extern HOST_WIDE_INT int_bit_position (tree);
  extern tree byte_position (tree);
*** gcc/function.c.ori	2006-05-23 08:45:36.000000000 +0200
--- gcc/function.c	2006-05-23 08:46:57.000000000 +0200
*************** assign_temp (tree type_or_decl, int keep
*** 813,819 ****
    if (mode == BLKmode || memory_required)
      {
        HOST_WIDE_INT size = int_size_in_bytes (type);
-       tree size_tree;
        rtx tmp;
  
        /* Zero sized arrays are GNU C extension.  Set size to 1 to avoid
--- 813,818 ----
*************** assign_temp (tree type_or_decl, int keep
*** 822,841 ****
  	size = 1;
  
        /* Unfortunately, we don't yet know how to allocate variable-sized
! 	 temporaries.  However, sometimes we have a fixed upper limit on
! 	 the size (which is stored in TYPE_ARRAY_MAX_SIZE) and can use that
! 	 instead.  This is the case for Chill variable-sized strings.  */
!       if (size == -1 && TREE_CODE (type) == ARRAY_TYPE
! 	  && TYPE_ARRAY_MAX_SIZE (type) != NULL_TREE
! 	  && host_integerp (TYPE_ARRAY_MAX_SIZE (type), 1))
! 	size = tree_low_cst (TYPE_ARRAY_MAX_SIZE (type), 1);
! 
!       /* If we still haven't been able to get a size, see if the language
! 	 can compute a maximum size.  */
!       if (size == -1
! 	  && (size_tree = lang_hooks.types.max_size (type)) != 0
! 	  && host_integerp (size_tree, 1))
! 	size = tree_low_cst (size_tree, 1);
  
        /* The size of the temporary may be too large to fit into an integer.  */
        /* ??? Not sure this should happen except for user silliness, so limit
--- 821,830 ----
  	size = 1;
  
        /* Unfortunately, we don't yet know how to allocate variable-sized
! 	 temporaries.  However, sometimes we can find a fixed upper limit on
! 	 the size, so try that instead.  */
!       else if (size == -1)
! 	size = max_int_size_in_bytes (type);
  
        /* The size of the temporary may be too large to fit into an integer.  */
        /* ??? Not sure this should happen except for user silliness, so limit
*** gcc/gimplify.c.ori	2006-05-23 08:45:46.000000000 +0200
--- gcc/gimplify.c	2006-05-23 11:19:33.000000000 +0200
*************** create_tmp_var (tree type, const char *p
*** 404,413 ****
    tree tmp_var;
  
    /* We don't allow types that are addressable (meaning we can't make copies),
!      incomplete, or of variable size.  */
!   gcc_assert (!TREE_ADDRESSABLE (type)
! 	      && COMPLETE_TYPE_P (type)
! 	      && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST);
  
    tmp_var = create_tmp_var_raw (type, prefix);
    gimple_add_tmp_var (tmp_var);
--- 404,415 ----
    tree tmp_var;
  
    /* We don't allow types that are addressable (meaning we can't make copies),
!      or incomplete.  We also used to reject every variable size objects here,
!      but now support those for which a constant upper bound can be obtained.
!      The processing for variable sizes is performed in gimple_add_tmp_var,
!      point at which it really matters and possibly reached via paths not going
!      through this function, e.g. after direct calls to create_tmp_var_raw.  */
!   gcc_assert (!TREE_ADDRESSABLE (type) && COMPLETE_TYPE_P (type));
  
    tmp_var = create_tmp_var_raw (type, prefix);
    gimple_add_tmp_var (tmp_var);
*************** declare_tmp_vars (tree vars, tree scope)
*** 589,599 ****
--- 591,631 ----
      }
  }
  
+ /* For VAR a VAR_DECL of variable size, try to find a constant upper bound
+    for the size and adjust DECL_SIZE/DECL_SIZE_UNIT accordingly.  Abort if
+    no such upper bound can be obtained.  */
+ 
+ static void
+ force_constant_size (tree var)
+ {
+   /* The only attempt we make is by querying the maximum size of objects
+      of the variable's type.  */
+ 
+   HOST_WIDE_INT max_size;
+ 
+   gcc_assert (TREE_CODE (var) == VAR_DECL);
+ 
+   max_size = max_int_size_in_bytes (TREE_TYPE (var));
+ 
+   gcc_assert (max_size >= 0);
+ 
+   DECL_SIZE_UNIT (var)
+     = build_int_cst (TREE_TYPE (DECL_SIZE_UNIT (var)), max_size);
+   DECL_SIZE (var)
+     = build_int_cst (TREE_TYPE (DECL_SIZE (var)), max_size * BITS_PER_UNIT);
+ }
+ 
  void
  gimple_add_tmp_var (tree tmp)
  {
    gcc_assert (!TREE_CHAIN (tmp) && !DECL_SEEN_IN_BIND_EXPR_P (tmp));
  
+   /* Later processing assumes that the object size is constant, which might
+      not be true at this point.  Force the use of a constant upper bound in
+      this case.  */
+   if (!host_integerp (DECL_SIZE_UNIT (tmp), 1))
+     force_constant_size (tmp);
+ 
    DECL_CONTEXT (tmp) = current_function_decl;
    DECL_SEEN_IN_BIND_EXPR_P (tmp) = 1;
  
*** gcc/tree-ssa-structalias.h.0	2006-05-24 20:16:40.000000000 +0200
--- gcc/tree-ssa-structalias.h	2006-05-24 20:20:51.289388128 +0200
*************** Foundation, Inc., 51 Franklin Street, Fi
*** 22,27 ****
--- 22,30 ----
  #ifndef TREE_SSA_STRUCTALIAS_H
  #define TREE_SSA_STRUCTALIAS_H
  
+ /* True if the data pointed to by PTR can alias anything.  */
+ #define PTR_IS_REF_ALL(PTR) TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (PTR))
+ 
  struct constraint;
  typedef struct constraint *constraint_t;
  
*************** struct alias_info
*** 69,74 ****
--- 72,80 ----
  
    /* Pointers that have been used in an indirect load operation.  */
    bitmap dereferenced_ptrs_load;
+ 
+   /* Memory tag for all the PTR_IS_REF_ALL pointers.  */
+   tree ref_all_type_mem_tag;
  };
  
  /* Keep track of how many times each pointer has been dereferenced in
*** gcc/tree-ssa-alias.c.0	2006-05-24 10:20:21.000000000 +0200
--- gcc/tree-ssa-alias.c	2006-05-24 20:21:58.234210968 +0200
*************** static struct alias_stats_d alias_stats;
*** 98,103 ****
--- 98,104 ----
  
  /* Local functions.  */
  static void compute_flow_insensitive_aliasing (struct alias_info *);
+ static void finalize_ref_all_pointers (struct alias_info *);
  static void dump_alias_stats (FILE *);
  static bool may_alias_p (tree, HOST_WIDE_INT, tree, HOST_WIDE_INT, bool);
  static tree create_memory_tag (tree type, bool is_type_tag);
*************** compute_may_aliases (void)
*** 285,290 ****
--- 286,297 ----
       aliasing precision.  */
    maybe_create_global_var (ai);
  
+   /* If the program contains ref-all pointers, finalize may-alias information
+      for them.  This pass needs to be run after call-clobbering information
+      has been computed.  */
+   if (ai->ref_all_type_mem_tag)
+     finalize_ref_all_pointers (ai);
+ 
    /* Debugging dumps.  */
    if (dump_file)
      {
*************** compute_flow_insensitive_aliasing (struc
*** 769,774 ****
--- 776,785 ----
        var_ann_t tag_ann = var_ann (tag);
        tree var;
  
+       /* Call-clobbering information is not finalized yet at this point.  */
+       if (PTR_IS_REF_ALL (p_map->var))
+ 	continue;
+ 
        p_map->total_alias_vops = 0;
        p_map->may_aliases = BITMAP_ALLOC (&alias_obstack);
  
*************** compute_flow_insensitive_aliasing (struc
*** 865,876 ****
--- 876,893 ----
        tree tag1 = var_ann (p_map1->var)->type_mem_tag;
        bitmap may_aliases1 = p_map1->may_aliases;
  
+       if (PTR_IS_REF_ALL (p_map1->var))
+ 	continue;
+ 
        for (j = i + 1; j < ai->num_pointers; j++)
  	{
  	  struct alias_map_d *p_map2 = ai->pointers[j];
  	  tree tag2 = var_ann (p_map2->var)->type_mem_tag;
  	  bitmap may_aliases2 = p_map2->may_aliases;
  
+ 	  if (PTR_IS_REF_ALL (p_map2->var))
+ 	    continue;
+ 
  	  /* If the pointers may not point to each other, do nothing.  */
  	  if (!may_alias_p (p_map1->var, p_map1->set, tag2, p_map2->set, true))
  	    continue;
*************** compute_flow_insensitive_aliasing (struc
*** 912,917 ****
--- 923,969 ----
  }
  
  
+ /* Finalize may-alias information for ref-all pointers.  Traverse all
+    the addressable variables found in setup_pointers_and_addressables.
+ 
+    If flow-sensitive alias analysis has attached a name memory tag to
+    a ref-all pointer, we will use it for the dereferences because that
+    will have more precise aliasing information.  But if there is no
+    name tag, we will use a special symbol tag that aliases all the
+    call-clobbered addressable variables.  */
+ 
+ static void
+ finalize_ref_all_pointers (struct alias_info *ai)
+ {
+   size_t i;
+ 
+   if (global_var)
+     add_may_alias (ai->ref_all_type_mem_tag, global_var);
+   else
+     {
+       /* First add the real call-clobbered variables.  */
+       for (i = 0; i < ai->num_addressable_vars; i++)
+ 	{
+ 	  tree var = ai->addressable_vars[i]->var;
+ 	  if (is_call_clobbered (var))
+ 	    add_may_alias (ai->ref_all_type_mem_tag, var);
+         }
+ 
+       /* Then add the call-clobbered pointer memory tags.  See
+ 	 compute_flow_insensitive_aliasing for the rationale.  */
+       for (i = 0; i < ai->num_pointers; i++)
+ 	{
+ 	  tree ptr = ai->pointers[i]->var, tag;
+ 	  if (PTR_IS_REF_ALL (ptr))
+ 	    continue;
+ 	  tag = var_ann (ptr)->type_mem_tag;
+ 	  if (is_call_clobbered (tag))
+ 	    add_may_alias (ai->ref_all_type_mem_tag, tag);
+ 	}
+     }
+ }
+ 
+ 
  /* Comparison function for qsort used in group_aliases.  */
  
  static int
*************** is_escape_site (tree stmt, struct alias_
*** 1705,1719 ****
        if (lhs == NULL_TREE)
  	return true;
  
!       /* If the RHS is a conversion between a pointer and an integer, the
! 	 pointer escapes since we can't track the integer.  */
!       if ((TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR
! 	   || TREE_CODE (TREE_OPERAND (stmt, 1)) == CONVERT_EXPR
! 	   || TREE_CODE (TREE_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)
! 	  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND
! 					(TREE_OPERAND (stmt, 1), 0)))
! 	  && !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 1))))
! 	return true;
  
        /* If the LHS is an SSA name, it can't possibly represent a non-local
  	 memory store.  */
--- 1757,1780 ----
        if (lhs == NULL_TREE)
  	return true;
  
!       if (TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR
! 	  || TREE_CODE (TREE_OPERAND (stmt, 1)) == CONVERT_EXPR
! 	  || TREE_CODE (TREE_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)
! 	{
! 	  tree from = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (stmt, 1), 0));
! 	  tree to = TREE_TYPE (TREE_OPERAND (stmt, 1));
! 
! 	  /* If the RHS is a conversion between a pointer and an integer, the
! 	     pointer escapes since we can't track the integer.  */
! 	  if (POINTER_TYPE_P (from) && !POINTER_TYPE_P (to))
! 	    return true;
! 
! 	  /* Same if the RHS is a conversion between a regular pointer and a
! 	     ref-all pointer since we can't track the TMT of the former.  */
! 	  if (POINTER_TYPE_P (from) && !TYPE_REF_CAN_ALIAS_ALL (from)
! 	      && POINTER_TYPE_P (to) && TYPE_REF_CAN_ALIAS_ALL (to))
! 	    return true;
! 	}
  
        /* If the LHS is an SSA name, it can't possibly represent a non-local
  	 memory store.  */
*************** get_tmt_for (tree ptr, struct alias_info
*** 1807,1812 ****
--- 1868,1881 ----
    tree tag_type = TREE_TYPE (TREE_TYPE (ptr));
    HOST_WIDE_INT tag_set = get_alias_set (tag_type);
  
+   /* We use a unique memory tag for all the ref-all pointers.  */
+   if (PTR_IS_REF_ALL (ptr))
+     {
+       if (!ai->ref_all_type_mem_tag)
+ 	ai->ref_all_type_mem_tag = create_memory_tag (void_type_node, true);
+       return ai->ref_all_type_mem_tag;
+     }
+ 
    /* To avoid creating unnecessary memory tags, only create one memory tag
       per alias set class.  Note that it may be tempting to group
       memory tags based on conflicting alias sets instead of
*** gcc/config/sparc/sol2.h.0	2006-03-13 21:17:00.439944688 +0100
--- gcc/config/sparc/sol2.h	2006-03-13 21:19:29.720250632 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 156,161 ****
--- 156,163 ----
  #define SUBTARGET_INSERT_ATTRIBUTES solaris_insert_attributes
  #define SUBTARGET_ATTRIBUTE_TABLE SOLARIS_ATTRIBUTE_TABLE
  
+ #define MD_UNWIND_SUPPORT "config/sparc/sol2-unwind.h"
+ 
  /* Output a simple call for .init/.fini.  */
  #define ASM_OUTPUT_CALL(FILE, FN)			        \
    do								\
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/sparc/sol2-unwind.h	2008-07-04 12:15:56.794193064 +0200
***************
*** 0 ****
--- 1,460 ----
+ /* DWARF2 EH unwinding support for SPARC Solaris.
+    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #include <ucontext.h>
+ 
+ /* Handle multilib correctly.  */
+ #if defined(__arch64__)
+ 
+ /* 64-bit SPARC version */
+ #define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state
+ #define MD_FROB_UPDATE_CONTEXT sparc64_frob_update_context
+ 
+ static _Unwind_Reason_Code
+ sparc64_fallback_frame_state (struct _Unwind_Context *context,
+ 			      _Unwind_FrameState *fs)
+ {
+   void *pc = context->ra;
+   void *this_cfa = context->cfa;
+   void *new_cfa;
+   int regs_off;
+   int fpu_save_off;
+   void **ra_location;
+   unsigned char fpu_save;
+   int i;
+ 
+   /* This is the observed pattern for the sigacthandler in Solaris 8.  */
+   unsigned int sigacthandler_sol8_pattern []
+     = {0x9401400f, 0xca5aafa0, 0x913e2000, 0x892a3003,
+        0xe0590005, 0x9fc40000, 0x9410001a, 0x80a6e008};
+ 
+   /* This is the observed pattern for the sigacthandler in Solaris 9.  */ 
+   unsigned int sigacthandler_sol9_pattern []
+     = {0xa33e2000, 0x00000000, 0x892c7003, 0x90100011,
+        0xe0590005, 0x9fc40000, 0x9410001a, 0x80a46008};
+ 
+   /* This is the observed pattern for the __sighndlr.  */
+   unsigned int sighndlr_pattern []
+     = {0x9de3bf50, 0x90100018, 0x92100019, 0x9fc6c000,
+        0x9410001a, 0x81c7e008, 0x81e80000};
+ 
+   if ((unsigned long)pc & 3)
+     {
+       /* Ugh.  The PC is not a multiple of 4 as it should be on SPARC,
+ 	 so the pattern matching code just below will make unaligned
+ 	 loads, possibly throwing us in an infinite loop from there.
+ 	 Hope for the best and pretend that we are responsible for
+ 	 having done that as part of the adjustment of the context in
+ 	 the signal handler.  Which means that we are in the context
+ 	 of a frame-less function from which a signal was raised.  */
+ 
+       /* The CFA is by definition unmodified in this case.  */
+       fs->cfa_how = CFA_REG_OFFSET;
+       fs->cfa_reg = __builtin_dwarf_sp_column ();
+       fs->cfa_offset = 0;
+ 
+       /* This is the canonical RA column.  */
+       fs->retaddr_column = 15;
+ 
+       return _URC_NO_REASON;
+     }
+ 
+   /* Look for the sigacthandler pattern.  The pattern changes slightly
+      in different versions of the operating system, so we skip the
+      comparison against pc-(4*6) for Solaris 9.  */
+   if ((    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol8_pattern[0]
+ 	&& *(unsigned int *)(pc-(4*6)) == sigacthandler_sol8_pattern[1]
+ 	&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol8_pattern[2]
+ 	&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol8_pattern[3]
+ 	&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol8_pattern[4]
+ 	&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol8_pattern[5]
+ 	&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol8_pattern[6]
+ 	&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol8_pattern[7] ) ||
+       (    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol9_pattern[0]
+ 	/* skip pc-(4*6) */
+ 	&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol9_pattern[2]
+ 	&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol9_pattern[3]
+ 	&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol9_pattern[4]
+ 	&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol9_pattern[5]
+ 	&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol9_pattern[6]
+ 	&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol9_pattern[7] ) )
+     /* We need to move up two frames (the kernel frame and the handler
+        frame).  Minimum stack frame size is 176 bytes (128 + 48): 128
+        bytes for spilling register window (16 extended words for in
+        and local registers), and 6 extended words to store at least
+        6 arguments to callees, The kernel frame and the sigacthandler
+        both have this minimal stack.  The ucontext_t structure is after
+        this offset.  */
+     regs_off = 176 + 176;
+   /* Look for the __sighndlr pattern.  */
+   else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
+ 	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
+ 	    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]
+ 	    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]
+ 	    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]
+ 	    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]
+ 	    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )
+     {
+       /* We have observed different calling frames among different
+ 	 versions of the operating system, so that we need to
+ 	 discriminate using the upper frame.  We look for the return
+ 	 address of the caller frame (there is an offset of 15 double
+ 	 words between the frame address and the place where this return
+ 	 address is stored) in order to do some more pattern matching.  */
+       if (*(unsigned int *)(*(unsigned long *)(this_cfa + 15*8) - 4)
+ 	    == 0x9410001a)
+ 	/* In Solaris 9 we need to move up four frames (the kernel frame,
+ 	   the sigacthandler frame, the call_user_handler, and the
+ 	   __sighndlr frame).  The kernel frame has a stack frame size of
+ 	   176, the __sighndlr frames of 304 bytes, 176 bytes for the
+ 	   call_user_handler frame, and another 176 bytes for the
+ 	   sigacthandler frame.  The ucontext_t structure is after this
+ 	   offset.  */
+ 	regs_off = 176 + 304 + 176 + 176;
+       else
+ 	/* We need to move up three frames (the kernel frame, the
+ 	   sigacthandler frame, and the __sighndlr frame).  The kernel
+ 	   frame has a stack frame size of 176, the __sighndlr frames of
+ 	   304 bytes, and there is a stack frame of 176 bytes for the
+ 	   sigacthandler frame.  The ucontext_t structure is after this
+ 	   offset.  */
+ 	regs_off = 176 + 304 + 176;
+     }  
+   else
+     /* Exit if the pattern at the return address does not match the
+        previous three patterns.  */
+     return _URC_END_OF_STACK;
+ 
+   /* FPU information can be extracted from the ucontext_t structure 
+      that is the third argument for the signal handler, that is saved
+      in the stack.  There are 64 bytes between the beginning of the
+      ucontext_t argument of the signal handler and the uc_mcontext
+      field.  There are 176 bytes between the beginning of uc_mcontext
+      and the beginning of the fpregs field.  */
+   fpu_save_off = regs_off + (8*10) + 176;
+ 
+   /* The fpregs field contains 32 extended words at the beginning that
+      contain the fpu state.  Then there are 2 extended words and two
+      bytes.  */
+   fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (8*32) + (2*8) + 2);
+ 
+   /* We need to get the frame pointer for the kernel frame that
+      executes when the signal is raised.  This frame is just the
+      following to the application code that generated the signal, so
+      that the later's stack pointer is the former's frame pointer.
+      The stack pointer for the interrupted application code can be
+      calculated from the ucontext_t structure (third argument for the
+      signal handler) that is saved in the stack.  There are 10 words
+      between the beginning of the  ucontext_t argument  of the signal
+      handler and the uc_mcontext.gregs field that contains the
+      registers saved by the signal handler.  */
+   new_cfa = *(void **)(this_cfa + regs_off + (8*10) + (REG_SP*8));
+   /* The frame address is %sp + STACK_BIAS in 64-bit mode. */
+   new_cfa += 2047;
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = __builtin_dwarf_sp_column ();
+   fs->cfa_offset = new_cfa - this_cfa;
+ 
+   /* Restore global and out registers (in this order) from the
+      ucontext_t structure, uc_mcontext.gregs field.  */
+   for (i = 1; i < 16; i++)
+     {
+       /* We never restore %sp as everything is purely CFA-based.  */
+       if ((unsigned int) i == __builtin_dwarf_sp_column ())
+ 	continue;
+ 
+       /* First the global registers and then the out registers.  */
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset
+ 	= this_cfa + regs_off + (8*10) + ((REG_Y+i)*8) - new_cfa;
+     }
+ 
+   /* Just above the stack pointer there are 16 extended words in which
+      the register window (in and local registers) was saved.  */
+   for (i = 0; i < 16; i++)
+     {
+       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i + 16].loc.offset = i*8;
+     }
+ 
+   /* Check whether we need to restore fpu registers.  */
+   if (fpu_save)
+     {
+       for (i = 0; i < 64; i++)
+ 	{
+ 	  if (i > 32 && (i & 1))
+ 	    continue;
+ 
+ 	  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;
+ 	  fs->regs.reg[i + 32].loc.offset
+ 	    = this_cfa + fpu_save_off + (i*4) - new_cfa;
+ 	}
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which is
+      the address of the active instruction when the signal was caught.  */
+   ra_location = this_cfa + regs_off + (8*10) + (REG_PC*8);
+   fs->retaddr_column = 0;
+   fs->regs.reg[0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[0].loc.offset = (void *)ra_location - new_cfa;
+ 
+   return _URC_NO_REASON;
+ }
+ 
+ static void
+ sparc64_frob_update_context (struct _Unwind_Context *context,
+ 			     _Unwind_FrameState *fs)
+ {
+   /* The column of %sp contains the old CFA, not the old value of %sp.
+      The CFA offset already comprises the stack bias so, when %sp is the
+      CFA register, we must avoid counting the stack bias twice.  Do not
+      do that for signal frames as the offset is artificial for them.  */
+   if (fs->cfa_reg == __builtin_dwarf_sp_column ()
+       && fs->cfa_how == CFA_REG_OFFSET
+       && fs->cfa_offset != 0
+       && fs->retaddr_column != 0)
+     context->cfa -= 2047;
+ }
+ 
+ #else
+ 
+ /* 32-bit SPARC version */
+ #define MD_FALLBACK_FRAME_STATE_FOR sparc_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ sparc_fallback_frame_state (struct _Unwind_Context *context,
+ 			    _Unwind_FrameState *fs)
+ {
+   void *pc = context->ra;
+   void *this_cfa = context->cfa;
+   void *new_cfa;
+   int regs_off;
+   int fpu_save_off;
+   void **ra_location;
+   unsigned char fpu_save;
+   int i;
+ 
+   /* This is the observed pattern for the sigacthandler.  */
+   unsigned int sigacthandler_pattern []
+     = {0x9602400f, 0x92100019, 0x00000000, 0x912e2002,
+        0xe002000a, 0x90100018, 0x9fc40000, 0x9410001a,
+        0x80a62008};
+ 
+   /* This is the observed pattern for the __libthread_segvhdlr.  */
+   unsigned int segvhdlr_pattern []
+     = {0x94102000, 0xe007bfe4, 0x9010001c, 0x92100019,
+        0x9fc40000, 0x9410001a, 0x81c7e008, 0x81e80000,
+        0x80a26000};
+ 
+   /* This is the observed pattern for the __sighndlr.  */
+   unsigned int sighndlr_pattern []
+     = {0x9de3bfa0, 0x90100018, 0x92100019, 0x9fc6c000,
+        0x9410001a, 0x81c7e008, 0x81e80000};
+ 
+   if ((unsigned long)pc & 3)
+     {
+       /* Ugh.  The PC is not a multiple of 4 as it should be on SPARC,
+ 	 so the pattern matching code just below will make unaligned
+ 	 loads, possibly throwing us in an infinite loop from there.
+ 	 Hope for the best and pretend that we are responsible for
+ 	 having done that as part of the adjustment of the context in
+ 	 the signal handler.  Which means that we are in the context
+ 	 of a frame-less function from which a signal was raised.  */
+ 
+       /* The CFA is by definition unmodified in this case.  */
+       fs->cfa_how = CFA_REG_OFFSET;
+       fs->cfa_reg = __builtin_dwarf_sp_column ();
+       fs->cfa_offset = 0;
+ 
+       /* This is the canonical RA column.  */
+       fs->retaddr_column = 15;
+ 
+       return _URC_NO_REASON;
+     }
+ 
+   /* Look for the sigacthandler pattern.  The pattern changes slightly
+      in different versions of the operating system, so we skip the
+      comparison against pc-(4*6).  */
+   if (    *(unsigned int *)(pc-(4*8)) == sigacthandler_pattern[0]
+        && *(unsigned int *)(pc-(4*7)) == sigacthandler_pattern[1]
+        /* skip pc-(4*6) */
+        && *(unsigned int *)(pc-(4*5)) == sigacthandler_pattern[3]
+        && *(unsigned int *)(pc-(4*4)) == sigacthandler_pattern[4]
+        && *(unsigned int *)(pc-(4*3)) == sigacthandler_pattern[5]
+        && *(unsigned int *)(pc-(4*2)) == sigacthandler_pattern[6]
+        && *(unsigned int *)(pc-(4*1)) == sigacthandler_pattern[7]
+        && *(unsigned int *)(pc-(4*0)) == sigacthandler_pattern[8] )
+     /* We need to move up two frames (the kernel frame and the handler
+        frame).  Minimum stack frame size is 96 bytes (64 + 4 + 24): 64
+        bytes for spilling register window (16 words for in and local
+        registers), 4 bytes for a pointer to space for callees
+        returning structs, and 24 bytes to store at least six argument
+        to callees.  The ucontext_t structure is after this offset.  */
+     regs_off = 96 + 96;
+   /* Look for the __libthread_segvhdlr pattern.  */
+   else if (    *(unsigned int *)(pc-(4*6)) == segvhdlr_pattern[0]
+ 	    && *(unsigned int *)(pc-(4*5)) == segvhdlr_pattern[1]
+ 	    && *(unsigned int *)(pc-(4*4)) == segvhdlr_pattern[2]
+ 	    && *(unsigned int *)(pc-(4*3)) == segvhdlr_pattern[3]
+ 	    && *(unsigned int *)(pc-(4*2)) == segvhdlr_pattern[4]
+ 	    && *(unsigned int *)(pc-(4*1)) == segvhdlr_pattern[5]
+ 	    && *(unsigned int *)(pc-(4*0)) == segvhdlr_pattern[6]
+ 	    && *(unsigned int *)(pc+(4*1)) == segvhdlr_pattern[7]
+ 	    && *(unsigned int *)(pc+(4*2)) == segvhdlr_pattern[8] )
+     /* We need to move up four frames (the kernel frame, the
+        sigacthandler frame, the __sighndlr frame, and the
+        __libthread_segvhdlr).  Two of them have the minimum
+        stack frame size (kernel and __sighndlr frames) of 96 bytes,
+        other has a stack frame of 216 bytes (the sigacthandler frame),
+        and there is another with a stack frame of 128 bytes (the
+        __libthread_segvhdlr).  The ucontext_t structure is after this
+        offset.  */
+     regs_off = 96 + 96 + 128 + 216;
+     /* Look for the __sighndlr pattern.  */
+   else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
+ 	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
+ 	    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]
+ 	    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]
+ 	    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]
+ 	    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]
+ 	    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )
+     {
+       /* We have observed different calling frames among different
+ 	 versions of the operating system, so that we need to
+ 	 discriminate using the upper frame.  We look for the return
+ 	 address of the caller frame (there is an offset of 15 words
+ 	 between the frame address and the place where this return
+ 	 address is stored) in order to do some more pattern matching.  */
+       if (*(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4)
+ 	    == 0xd407a04c)
+ 	/* This matches the call_user_handler pattern for Solaris 10.
+ 	   We need to move up three frames (the kernel frame, the
+ 	   call_user_handler frame, the __sighndlr frame).  Two of them
+ 	   have the minimum stack frame size (kernel and __sighndlr
+ 	   frames) of 96 bytes, and there is another with a stack frame
+ 	   of 160 bytes (the call_user_handler frame).  The ucontext_t
+ 	  structure is after this offset.  */
+ 	regs_off = 96 + 96 + 160;
+       else if (*(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4)
+ 		==  0x9410001a)
+ 	/* This matches the call_user_handler pattern for Solaris 9.
+ 	   We need to move up four frames (the kernel frame, the signal
+ 	   frame, the call_user_handler frame, the __sighndlr frame).
+ 	   Three of them have the minimum stack frame size (kernel,
+ 	   signal, and __sighndlr frames) of 96 bytes, and there is
+ 	   another with a stack frame of 160 bytes (the call_user_handler
+ 	   frame).  The ucontext_t structure is after this offset.  */
+ 	regs_off = 96 + 96 + 96 + 160;
+       else
+ 	/* We need to move up three frames (the kernel frame, the
+ 	   sigacthandler frame, and the __sighndlr frame).  Two of them
+ 	   have the minimum stack frame size (kernel and __sighndlr
+ 	   frames) of 96 bytes, and there is another with a stack frame
+ 	   of 216 bytes (the sigacthandler frame).  The ucontext_t 
+ 	   structure is after this offset.  */
+ 	regs_off = 96 + 96 + 216;
+     }
+   else
+     /* Exit if the pattern at the return address does not match the
+        previous three patterns.  */
+     return _URC_END_OF_STACK;
+ 
+   /* FPU information can be extracted from the ucontext_t structure
+      that is the third argument for the signal handler, that is saved
+      in the stack.  There are 10 words between the beginning of the
+      ucontext_t argument of the signal handler and the uc_mcontext
+      field.  There are 80 bytes between the beginning of uc_mcontext
+      and the beginning of the fpregs field.  */
+   fpu_save_off = regs_off + (4*10) + (4*20);
+ 
+   /* The fpregs field contains 32 words at the beginning that contain
+      the fpu state.  Then there are 2 words and two bytes.  */
+   fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (4*32) + (2*4) + 2);
+ 
+   /* We need to get the frame pointer for the kernel frame that
+      executes when the signal is raised.  This frame is just the
+      following to the application code that generated the signal, so
+      that the later's stack pointer is the former's frame pointer.
+      The stack pointer for the interrupted application code can be
+      calculated from the ucontext_t structure (third argument for the
+      signal handler) that is saved in the stack.  There are 10 words
+      between the beginning of the  ucontext_t argument  of the signal
+      handler and the uc_mcontext.gregs field that contains the
+      registers saved by the signal handler.  */
+   new_cfa = *(void **)(this_cfa + regs_off + (4*10) + (REG_SP*4));
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = __builtin_dwarf_sp_column ();
+   fs->cfa_offset = new_cfa - this_cfa;
+ 
+   /* Restore global and out registers (in this order) from the
+      ucontext_t structure, uc_mcontext.gregs field.  */
+   for (i = 1; i < 16; i++)
+     {
+       /* We never restore %sp as everything is purely CFA-based.  */
+       if ((unsigned int) i == __builtin_dwarf_sp_column ())
+ 	continue;
+ 
+       /* First the global registers and then the out registers */
+       fs->regs.reg[i].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i].loc.offset
+ 	= this_cfa + regs_off + (4*10) + ((REG_Y+i)*4) - new_cfa;
+     }
+ 
+   /* Just above the stack pointer there are 16 words in which the
+      register window (in and local registers) was saved.  */
+   for (i = 0; i < 16; i++)
+     {
+       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;
+       fs->regs.reg[i + 16].loc.offset = i*4;
+     }
+ 
+   /* Check whether we need to restore fpu registers.  */
+   if (fpu_save)
+     {
+       for (i = 0; i < 32; i++)
+ 	{
+ 	  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;
+ 	  fs->regs.reg[i + 32].loc.offset
+ 	    = this_cfa + fpu_save_off + (i*4) - new_cfa;
+         }
+     }
+ 
+   /* State the rules to find the kernel's code "return address", which is
+      the address of the active instruction when the signal was caught.  */
+   ra_location = this_cfa + regs_off + (4*10) + (REG_PC*4);
+   fs->retaddr_column = 0;
+   fs->regs.reg[0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[0].loc.offset = (void *)ra_location - new_cfa;
+ 
+   return _URC_NO_REASON;
+ };
+ 
+ #endif
*** gcc/gimplify.c.0	2006-06-09 12:05:54.409957896 +0200
--- gcc/gimplify.c	2006-06-09 12:06:40.969879712 +0200
*************** gimplify_expr (tree *expr_p, tree *pre_p
*** 4646,4652 ****
  	  switch (code)
  	    {
  	    case COMPONENT_REF:
! 	    case REALPART_EXPR: case IMAGPART_EXPR:
  	      gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,
  			     gimple_test_f, fallback);
  	      break;
--- 4646,4654 ----
  	  switch (code)
  	    {
  	    case COMPONENT_REF:
! 	    case REALPART_EXPR:
! 	    case IMAGPART_EXPR:
! 	    case VIEW_CONVERT_EXPR:
  	      gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,
  			     gimple_test_f, fallback);
  	      break;
*** gcc/config/alpha/osf5.h.0	2006-06-13 07:09:19.877328448 +0200
--- gcc/config/alpha/osf5.h	2006-06-13 07:09:34.701074896 +0200
***************
*** 22,27 ****
--- 22,47 ----
  #undef TARGET_DEFAULT
  #define TARGET_DEFAULT	(MASK_FPREGS | MASK_LONG_DOUBLE_128)
  
+ /* This says how to output assembler code to declare an uninitialized
+    internal linkage data object.  */
+ #undef ASM_OUTPUT_ALIGNED_LOCAL
+ #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
+ do { 									\
+   fputs ("\t.lcomm ", (FILE));						\
+   assemble_name ((FILE), (NAME));					\
+   fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED, (SIZE));		\
+   fprintf ((FILE), ",%d\n", exact_log2 ((ALIGN) / BITS_PER_UNIT));	\
+ } while (0)
+ 
+ /* This says how to output assembler code to declare an uninitialized
+    external linkage data object.  According to the Tru64 5.1 assembler
+    manual, .lcomm works for global objects too.  */
+ #undef ASM_OUTPUT_ALIGNED_BSS
+ #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)		\
+ do {									\
+   ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);			\
+ } while (0)
+ 
  /* In Tru64 UNIX V5.1, Compaq introduced a new assembler
     (/usr/lib/cmplrs/cc/adu) which currently (versions between 3.04.29 and
     3.04.32) breaks mips-tfile.  Passing the undocumented -oldas flag reverts
*** gcc/gcse.c.ori	Thu Jun 15 18:08:07 2006
--- gcc/gcse.c	Thu Jun 15 18:08:40 2006
*************** try_replace_reg (rtx from, rtx to, rtx i
*** 2677,2688 ****
  	  && validate_change (insn, &SET_SRC (set), src, 0))
  	success = 1;
  
!       /* If we've failed to do replacement, have a single SET, don't already
! 	 have a note, and have no special SET, add a REG_EQUAL note to not
! 	 lose information.  */
!       if (!success && note == 0 && set != 0
! 	  && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT
! 	  && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)
  	note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));
      }
  
--- 2677,2686 ----
  	  && validate_change (insn, &SET_SRC (set), src, 0))
  	success = 1;
  
!        /* If we've failed to do replacement, have a single SET to a register
! 	  destination, and don't already have a note, add a REG_EQUAL note to
! 	  not lose information.  */
!       if (!success && note == 0 && set != 0 && REG_P (XEXP (set, 0)))
  	note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));
      }
  
*** gcc/tree.c.0	2006-06-16 20:16:35.000000000 +0200
--- gcc/tree.c	2006-06-16 20:33:29.000000000 +0200
*************** in_array_bounds_p (tree ref)
*** 6747,6752 ****
--- 6747,6785 ----
    return true;
  }
  
+ /* Returns true if it is possible to prove that the range of
+    an array access REF (an ARRAY_RANGE_REF expression) falls
+    into the array bounds.  */
+ 
+ bool
+ range_in_array_bounds_p (tree ref)
+ {
+   tree domain_type = TYPE_DOMAIN (TREE_TYPE (ref));
+   tree range_min, range_max, min, max;
+ 
+   range_min = TYPE_MIN_VALUE (domain_type);
+   range_max = TYPE_MAX_VALUE (domain_type);
+   if (!range_min
+       || !range_max
+       || TREE_CODE (range_min) != INTEGER_CST
+       || TREE_CODE (range_max) != INTEGER_CST)
+     return false;
+ 
+   min = array_ref_low_bound (ref);
+   max = array_ref_up_bound (ref);
+   if (!min
+       || !max
+       || TREE_CODE (min) != INTEGER_CST
+       || TREE_CODE (max) != INTEGER_CST)
+     return false;
+ 
+   if (tree_int_cst_lt (range_min, min)
+       || tree_int_cst_lt (max, range_max))
+     return false;
+ 
+   return true;
+ }
+ 
  /* Return true if T (assumed to be a DECL) is a global variable.  */
  
  bool
*** gcc/tree-eh.c.0	2006-06-16 20:16:24.000000000 +0200
--- gcc/tree-eh.c	2006-06-16 20:17:03.000000000 +0200
*************** tree_could_trap_p (tree expr)
*** 1886,1898 ****
        goto restart;
  
      case ARRAY_RANGE_REF:
!       /* Let us be conservative here for now.  We might be checking bounds of
! 	 the access similarly to the case below.  */
!       if (!TREE_THIS_NOTRAP (expr))
  	return true;
  
!       base = TREE_OPERAND (expr, 0);
!       return tree_could_trap_p (base);
  
      case ARRAY_REF:
        base = TREE_OPERAND (expr, 0);
--- 1886,1899 ----
        goto restart;
  
      case ARRAY_RANGE_REF:
!       base = TREE_OPERAND (expr, 0);
!       if (tree_could_trap_p (base))
  	return true;
  
!       if (TREE_THIS_NOTRAP (expr))
! 	return false;
! 
!       return !range_in_array_bounds_p (expr);
  
      case ARRAY_REF:
        base = TREE_OPERAND (expr, 0);
*** gcc/tree.h.0	2006-06-16 20:33:48.000000000 +0200
--- gcc/tree.h	2006-06-13 11:24:00.000000000 +0200
*************** extern tree build_complex_type (tree);
*** 3245,3250 ****
--- 3245,3251 ----
  extern tree build_resx (int);
  extern tree array_type_nelts (tree);
  extern bool in_array_bounds_p (tree);
+ extern bool range_in_array_bounds_p (tree);
  
  extern tree value_member (tree, tree);
  extern tree purpose_member (tree, tree);
*** gcc/tree-sra.c.0	2006-06-15 07:38:16.000000000 +0200
--- gcc/tree-sra.c	2006-06-17 17:36:35.461538992 +0200
*************** static bitmap needs_copy_in;
*** 86,105 ****
  static bitmap sra_type_decomp_cache;
  static bitmap sra_type_inst_cache;
  
! /* One of these structures is created for each candidate aggregate
!    and each (accessed) member of such an aggregate.  */
  struct sra_elt
  {
    /* A tree of the elements.  Used when we want to traverse everything.  */
    struct sra_elt *parent;
    struct sra_elt *children;
    struct sra_elt *sibling;
  
    /* If this element is a root, then this is the VAR_DECL.  If this is
       a sub-element, this is some token used to identify the reference.
       In the case of COMPONENT_REF, this is the FIELD_DECL.  In the case
!      of an ARRAY_REF, this is the (constant) index.  In the case of a
!      complex number, this is a zero or one.  */
    tree element;
  
    /* The type of the element.  */
--- 86,107 ----
  static bitmap sra_type_decomp_cache;
  static bitmap sra_type_inst_cache;
  
! /* One of these structures is created for each candidate aggregate and
!    each (accessed) member or group of members of such an aggregate.  */
  struct sra_elt
  {
    /* A tree of the elements.  Used when we want to traverse everything.  */
    struct sra_elt *parent;
+   struct sra_elt *groups;
    struct sra_elt *children;
    struct sra_elt *sibling;
  
    /* If this element is a root, then this is the VAR_DECL.  If this is
       a sub-element, this is some token used to identify the reference.
       In the case of COMPONENT_REF, this is the FIELD_DECL.  In the case
!      of an ARRAY_REF, this is the (constant) index.  In the case of an
!      ARRAY_RANGE_REF, this is the (constant) RANGE_EXPR.  In the case
!      of a complex number, this is a zero or one.  */
    tree element;
  
    /* The type of the element.  */
*************** struct sra_elt
*** 119,124 ****
--- 121,129 ----
    /* True if TYPE is scalar.  */
    bool is_scalar;
  
+   /* True if this element is a group of members of its parent.  */
+   bool is_group;
+ 
    /* True if we saw something about this element that prevents scalarization,
       such as non-constant indexing.  */
    bool cannot_scalarize;
*************** struct sra_elt
*** 134,139 ****
--- 139,185 ----
    bool visited;
  };
  
+ #define IS_ELEMENT_FOR_GROUP(ELEMENT) (TREE_CODE (ELEMENT) == RANGE_EXPR)
+ 
+ #define FOR_EACH_ACTUAL_CHILD(CHILD, ELT)			\
+   for ((CHILD) = (ELT)->is_group				\
+ 		 ? next_child_for_group (NULL, (ELT))		\
+ 		 : (ELT)->children;				\
+        (CHILD);							\
+        (CHILD) = (ELT)->is_group				\
+ 		 ? next_child_for_group ((CHILD), (ELT))	\
+ 		 : (CHILD)->sibling)
+ 
+ static struct sra_elt *
+ next_child_for_group (struct sra_elt *child, struct sra_elt *group)
+ {
+   gcc_assert (group->is_group);
+ 
+   /* Find the next child in the parent.  */
+   if (child)
+     child = child->sibling;
+   else
+     child = group->parent->children;
+ 
+   /* Skip siblings that do not belong to the group.  */
+   while (child)
+     {
+       tree g_elt = group->element;
+       if (TREE_CODE (g_elt) == RANGE_EXPR)
+ 	{
+ 	  if (!tree_int_cst_lt (child->element, TREE_OPERAND (g_elt, 0))
+ 	      && !tree_int_cst_lt (TREE_OPERAND (g_elt, 1), child->element))
+ 	    break;
+ 	}
+       else
+ 	gcc_unreachable ();
+ 
+       child = child->sibling;
+     }
+ 
+   return child;
+ }
+ 
  /* Random access to the child of a parent is performed by hashing.
     This prevents quadratic behavior, and allows SRA to function
     reasonably on larger records.  */
*************** can_completely_scalarize_p (struct sra_e
*** 349,355 ****
    if (elt->cannot_scalarize)
      return false;
  
!   for (c = elt->children; c ; c = c->sibling)
      if (!can_completely_scalarize_p (c))
        return false;
  
--- 395,405 ----
    if (elt->cannot_scalarize)
      return false;
  
!   for (c = elt->children; c; c = c->sibling)
!     if (!can_completely_scalarize_p (c))
!       return false;
! 
!   for (c = elt->groups; c; c = c->sibling)
      if (!can_completely_scalarize_p (c))
        return false;
  
*************** sra_hash_tree (tree t)
*** 377,382 ****
--- 427,437 ----
        h = TREE_INT_CST_LOW (t) ^ TREE_INT_CST_HIGH (t);
        break;
  
+     case RANGE_EXPR:
+       h = iterative_hash_expr (TREE_OPERAND (t, 0), 0);
+       h = iterative_hash_expr (TREE_OPERAND (t, 1), h);
+       break;
+ 
      case FIELD_DECL:
        /* We can have types that are compatible, but have different member
  	 lists, so we can't hash fields by ID.  Use offsets instead.  */
*************** sra_elt_eq (const void *x, const void *y
*** 444,449 ****
--- 499,509 ----
        /* Integers are not pointer unique, so compare their values.  */
        return tree_int_cst_equal (ae, be);
  
+     case RANGE_EXPR:
+       return
+ 	tree_int_cst_equal (TREE_OPERAND (ae, 0), TREE_OPERAND (be, 0))
+ 	&& tree_int_cst_equal (TREE_OPERAND (ae, 1), TREE_OPERAND (be, 1));
+ 
      case FIELD_DECL:
        /* Fields are unique within a record, but not between
  	 compatible records.  */
*************** lookup_element (struct sra_elt *parent, 
*** 467,473 ****
    struct sra_elt **slot;
    struct sra_elt *elt;
  
!   dummy.parent = parent;
    dummy.element = child;
  
    slot = (struct sra_elt **) htab_find_slot (sra_map, &dummy, insert);
--- 527,536 ----
    struct sra_elt **slot;
    struct sra_elt *elt;
  
!   if (parent)
!     dummy.parent = parent->is_group ? parent->parent : parent;
!   else
!     dummy.parent = NULL;
    dummy.element = child;
  
    slot = (struct sra_elt **) htab_find_slot (sra_map, &dummy, insert);
*************** lookup_element (struct sra_elt *parent, 
*** 487,494 ****
  
        if (parent)
  	{
! 	  elt->sibling = parent->children;
! 	  parent->children = elt;
  	}
  
        /* If this is a parameter, then if we want to scalarize, we have
--- 550,566 ----
  
        if (parent)
  	{
! 	  if (IS_ELEMENT_FOR_GROUP (elt->element))
! 	    {
! 	      elt->is_group = true;
! 	      elt->sibling = parent->groups;
! 	      parent->groups = elt;
! 	    }
! 	  else
! 	    {
! 	      elt->sibling = parent->children;
! 	      parent->children = elt;
! 	    }
  	}
  
        /* If this is a parameter, then if we want to scalarize, we have
*************** lookup_element (struct sra_elt *parent, 
*** 503,544 ****
    return elt;
  }
  
- /* Return true if the ARRAY_REF in EXPR is a constant, in bounds access.  */
- 
- static bool
- is_valid_const_index (tree expr)
- {
-   tree dom, t, index = TREE_OPERAND (expr, 1);
- 
-   if (TREE_CODE (index) != INTEGER_CST)
-     return false;
- 
-   /* Watch out for stupid user tricks, indexing outside the array.
- 
-      Careful, we're not called only on scalarizable types, so do not
-      assume constant array bounds.  We needn't do anything with such
-      cases, since they'll be referring to objects that we should have
-      already rejected for scalarization, so returning false is fine.  */
- 
-   dom = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (expr, 0)));
-   if (dom == NULL)
-     return false;
- 
-   t = TYPE_MIN_VALUE (dom);
-   if (!t || TREE_CODE (t) != INTEGER_CST)
-     return false;
-   if (tree_int_cst_lt (index, t))
-     return false;
- 
-   t = TYPE_MAX_VALUE (dom);
-   if (!t || TREE_CODE (t) != INTEGER_CST)
-     return false;
-   if (tree_int_cst_lt (t, index))
-     return false;
- 
-   return true;
- }
- 
  /* Create or return the SRA_ELT structure for EXPR if the expression
     refers to a scalarizable variable.  */
  
--- 575,580 ----
*************** maybe_lookup_element_for_expr (tree expr
*** 559,570 ****
  
      case ARRAY_REF:
        /* We can't scalarize variable array indicies.  */
!       if (is_valid_const_index (expr))
          child = TREE_OPERAND (expr, 1);
        else
  	return NULL;
        break;
  
      case COMPONENT_REF:
        /* Don't look through unions.  */
        if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) != RECORD_TYPE)
--- 595,618 ----
  
      case ARRAY_REF:
        /* We can't scalarize variable array indicies.  */
!       if (in_array_bounds_p (expr))
          child = TREE_OPERAND (expr, 1);
        else
  	return NULL;
        break;
  
+     case ARRAY_RANGE_REF:
+       /* We can't scalarize variable array indicies.  */
+       if (range_in_array_bounds_p (expr))
+ 	{
+ 	  tree domain = TYPE_DOMAIN (TREE_TYPE (expr));
+ 	  child = build2 (RANGE_EXPR, integer_type_node,
+ 			  TYPE_MIN_VALUE (domain), TYPE_MAX_VALUE (domain));
+ 	}
+       else
+ 	return NULL;
+       break;
+ 
      case COMPONENT_REF:
        /* Don't look through unions.  */
        if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) != RECORD_TYPE)
*************** sra_walk_expr (tree *expr_p, block_stmt_
*** 694,700 ****
  	   the effort.  */
  	/* ??? Hack.  Figure out how to push this into the scan routines
  	   without duplicating too much code.  */
! 	if (!is_valid_const_index (inner))
  	  {
  	    disable_scalarization = true;
  	    goto use_all;
--- 742,748 ----
  	   the effort.  */
  	/* ??? Hack.  Figure out how to push this into the scan routines
  	   without duplicating too much code.  */
! 	if (!in_array_bounds_p (inner))
  	  {
  	    disable_scalarization = true;
  	    goto use_all;
*************** sra_walk_expr (tree *expr_p, block_stmt_
*** 706,711 ****
--- 754,771 ----
  	inner = TREE_OPERAND (inner, 0);
  	break;
  
+       case ARRAY_RANGE_REF:
+ 	if (!range_in_array_bounds_p (inner))
+ 	  {
+ 	    disable_scalarization = true;
+ 	    goto use_all;
+ 	  }
+ 	/* ??? See above non-constant bounds and stride .  */
+ 	if (TREE_OPERAND (inner, 2) || TREE_OPERAND (inner, 3))
+ 	  goto use_all;
+ 	inner = TREE_OPERAND (inner, 0);
+ 	break;
+ 
        case COMPONENT_REF:
  	/* A reference to a union member constitutes a reference to the
  	   entire union.  */
*************** sra_walk_expr (tree *expr_p, block_stmt_
*** 728,738 ****
  	   complete outer element, to which walk_tree will bring us next.  */
  	goto use_all;
  
-       case ARRAY_RANGE_REF:
- 	/* Similarly, a subrange reference is used to modify indexing.  Which
- 	   means that the canonical element names that we have won't work.  */
- 	goto use_all;
- 
        case VIEW_CONVERT_EXPR:
        case NOP_EXPR:
  	/* Similarly, a view/nop explicitly wants to look at an object in a
--- 788,793 ----
*************** scan_dump (struct sra_elt *elt)
*** 1013,1018 ****
--- 1068,1076 ----
  
    for (c = elt->children; c ; c = c->sibling)
      scan_dump (c);
+ 
+   for (c = elt->groups; c ; c = c->sibling)
+     scan_dump (c);
  }
  
  /* Entry point to phase 2.  Scan the entire function, building up
*************** decide_instantiation_1 (struct sra_elt *
*** 1183,1192 ****
      }
    else
      {
!       struct sra_elt *c;
        unsigned int this_uses = elt->n_uses + parent_uses;
        unsigned int this_copies = elt->n_copies + parent_copies;
  
        for (c = elt->children; c ; c = c->sibling)
  	decide_instantiation_1 (c, this_uses, this_copies);
      }
--- 1241,1259 ----
      }
    else
      {
!       struct sra_elt *c, *group;
        unsigned int this_uses = elt->n_uses + parent_uses;
        unsigned int this_copies = elt->n_copies + parent_copies;
  
+       /* Consider groups of sub-elements as weighing in favour of
+ 	 instantiation whatever their size.  */
+       for (group = elt->groups; group ; group = group->sibling)
+ 	FOR_EACH_ACTUAL_CHILD (c, group)
+ 	  {
+ 	    c->n_uses += group->n_uses;
+ 	    c->n_copies += group->n_copies;
+ 	  }
+ 
        for (c = elt->children; c ; c = c->sibling)
  	decide_instantiation_1 (c, this_uses, this_copies);
      }
*************** decide_block_copy (struct sra_elt *elt)
*** 1306,1311 ****
--- 1373,1382 ----
    struct sra_elt *c;
    bool any_inst;
  
+   /* We shouldn't be invoked on groups of sub-elements as they must
+      behave like their parent as far as block copy is concerned.  */
+   gcc_assert (!elt->is_group);
+ 
    /* If scalarization is disabled, respect it.  */
    if (elt->cannot_scalarize)
      {
*************** decide_block_copy (struct sra_elt *elt)
*** 1324,1329 ****
--- 1395,1408 ----
  	  c->cannot_scalarize = 1;
  	  decide_block_copy (c);
  	}
+ 
+       /* Groups behave like their parent.  */
+       for (c = elt->groups; c; c = c->sibling)
+ 	{
+ 	  c->cannot_scalarize = 1;
+ 	  c->use_block_copy = 1;
+ 	}
+ 
        return false;
      }
  
*************** decide_block_copy (struct sra_elt *elt)
*** 1385,1392 ****
--- 1464,1476 ----
  		  || !type_can_instantiate_all_elements (elt->type)))
  	    use_block_copy = true;
  	}
+ 
        elt->use_block_copy = use_block_copy;
  
+       /* Groups behave like their parent.  */
+       for (c = elt->groups; c; c = c->sibling)
+ 	c->use_block_copy = use_block_copy;
+ 
        if (dump_file)
  	{
  	  fprintf (dump_file, "Using %s for ",
*************** mark_no_warning (struct sra_elt *elt)
*** 1506,1514 ****
        else
  	{
  	  struct sra_elt *c;
! 	  for (c = elt->children; c ; c = c->sibling)
  	    mark_no_warning (c);
  	}
      }
  }
  
--- 1590,1599 ----
        else
  	{
  	  struct sra_elt *c;
! 	  FOR_EACH_ACTUAL_CHILD (c, elt)
  	    mark_no_warning (c);
  	}
+       elt->all_no_warning = true;
      }
  }
  
*************** generate_one_element_ref (struct sra_elt
*** 1531,1537 ****
        }
  
      case ARRAY_TYPE:
!       return build (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);
  
      case COMPLEX_TYPE:
        if (elt->element == integer_zero_node)
--- 1616,1626 ----
        }
  
      case ARRAY_TYPE:
!       if (TREE_CODE (elt->element) == RANGE_EXPR)
! 	return build (ARRAY_RANGE_REF, elt->type, base,
! 		      TREE_OPERAND (elt->element, 0), NULL, NULL);
!       else
! 	return build (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);
  
      case COMPLEX_TYPE:
        if (elt->element == integer_zero_node)
*************** generate_copy_inout (struct sra_elt *elt
*** 1600,1606 ****
      }
    else
      {
!       for (c = elt->children; c ; c = c->sibling)
  	{
  	  t = generate_one_element_ref (c, unshare_expr (expr));
  	  generate_copy_inout (c, copy_out, t, list_p);
--- 1689,1695 ----
      }
    else
      {
!       FOR_EACH_ACTUAL_CHILD (c, elt)
  	{
  	  t = generate_one_element_ref (c, unshare_expr (expr));
  	  generate_copy_inout (c, copy_out, t, list_p);
*************** generate_element_copy (struct sra_elt *d
*** 1617,1623 ****
  {
    struct sra_elt *dc, *sc;
  
!   for (dc = dst->children; dc ; dc = dc->sibling)
      {
        sc = lookup_element (src, dc->element, NULL, NO_INSERT);
        gcc_assert (sc);
--- 1706,1712 ----
  {
    struct sra_elt *dc, *sc;
  
!   FOR_EACH_ACTUAL_CHILD (dc, dst)
      {
        sc = lookup_element (src, dc->element, NULL, NO_INSERT);
        gcc_assert (sc);
*************** generate_element_zero (struct sra_elt *e
*** 1651,1657 ****
        return;
      }
  
!   for (c = elt->children; c ; c = c->sibling)
      generate_element_zero (c, list_p);
  
    if (elt->replacement)
--- 1740,1746 ----
        return;
      }
  
!   FOR_EACH_ACTUAL_CHILD (c, elt)
      generate_element_zero (c, list_p);
  
    if (elt->replacement)
*************** generate_element_init_1 (struct sra_elt 
*** 1714,1720 ****
      {
      case COMPLEX_CST:
      case COMPLEX_EXPR:
!       for (sub = elt->children; sub ; sub = sub->sibling)
  	{
  	  if (sub->element == integer_zero_node)
  	    t = (init_code == COMPLEX_EXPR
--- 1803,1809 ----
      {
      case COMPLEX_CST:
      case COMPLEX_EXPR:
!       FOR_EACH_ACTUAL_CHILD (sub, elt)
  	{
  	  if (sub->element == integer_zero_node)
  	    t = (init_code == COMPLEX_EXPR
*************** dump_sra_elt_name (FILE *f, struct sra_e
*** 2176,2181 ****
--- 2265,2274 ----
  	    fputc ('.', f);
  	  print_generic_expr (f, elt->element, dump_flags);
  	}
+       else if (TREE_CODE (elt->element) == RANGE_EXPR)
+ 	fprintf (f, "["HOST_WIDE_INT_PRINT_DEC".."HOST_WIDE_INT_PRINT_DEC"]",
+ 		 TREE_INT_CST_LOW (TREE_OPERAND (elt->element, 0)),
+ 		 TREE_INT_CST_LOW (TREE_OPERAND (elt->element, 1)));
        else
  	fprintf (f, "[" HOST_WIDE_INT_PRINT_DEC "]",
  		 TREE_INT_CST_LOW (elt->element));
*** gcc/config/i386/cygming.h.0	2006-06-18 20:49:57.444679512 +0200
--- gcc/config/i386/cygming.h	2006-06-18 20:50:53.928092728 +0200
*************** extern int i386_pe_dllimport_name_p (con
*** 401,406 ****
--- 401,408 ----
  #define TARGET_VALID_DLLIMPORT_ATTRIBUTE_P i386_pe_valid_dllimport_attribute_p
  #define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION i386_pe_adjust_class_at_definition
  
+ #define MD_UNWIND_SUPPORT "config/i386/win32-unwind.h"
+ 
  #undef TREE
  
  #ifndef BUFSIZ
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/i386/win32-unwind.h	2006-06-18 21:09:24.831209784 +0200
***************
*** 0 ****
--- 1,210 ----
+ /* DWARF2 EH unwinding support for x86 Windows.
+    Copyright (C) 2006 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.
+ 
+    The basic idea is to detect that we are indeed trying to unwind past a
+    signal handler and to fill out the GCC internal unwinding structures for
+    the OS kernel frame as if it had been directly called from the interrupted
+    context.
+ 
+    This is all assuming that the code to set the handler asked the kernel to
+    pass a pointer to such context information.
+ 
+    There is three main parts.
+ 
+    1) The first thing to do is to check if we are in a signal context. If not
+       we can just return as there is nothing to do.  We are probably on some
+       foreign code for which no unwind frame can be found.  If this is a call
+       from the Windows signal handler, then:
+ 
+    2) We must get the signal context information. 
+ 
+       * With the standard exception filter:
+ 
+       This is on Windows pointed to by an EXCEPTION_POINTERS.  We know that the
+       signal handle will call an UnhandledExceptionFilter with this
+       parameter.  The spec for this routine is:
+ 
+          LONG WINAPI UnhandledExceptionFilter(struct _EXCEPTION_POINTERS*);
+ 
+       So the pointer to struct _EXCEPTION_POINTERS must be somewhere on the
+       stack.
+ 
+       This was found experimentally to always be at offset 0 of the context
+       frame in all cases handled by this implementation.
+ 
+       * With the SEH exception handler:
+ 
+       In this case the signal context is directly on the stack as the SEH
+       exception handler has the following prototype:
+ 
+          DWORD
+          SEH_error_handler (PEXCEPTION_RECORD ExceptionRecord,
+                             PVOID EstablisherFrame,
+                             PCONTEXT ContextRecord,
+                             PVOID DispatcherContext)
+ 
+       This was found experimentally to always be at offset 56 of the context
+       frame in all cases handled by this implementation.
+ 
+    3) When we have the signal context we just have to save some registers and
+       set the return address based on the program counter (Eip).
+ 
+    Note that this implementation follows closely the same principles as the
+    GNU/Linux and OSF ones.  */
+ 
+ 
+ /* Patterns found experimentally to be in a Windows signal handler.  */
+ 
+ /* In a standard exception filter.  */
+ 
+ #define SIG_PAT1 \
+   (pc[-2] == 0xff && pc[-1] == 0xd0     /* call %eax           */ \
+    && pc[0] == 0x83 && pc[1] == 0xf8)   /* cmp 0xdepl,%eax     */
+ 
+ #define SIG_PAT2 \
+   (pc[-5] == 0xe8 && pc[-4] == 0x68   /* call (depl16)       */ \
+    && pc[0] == 0xc3)                  /* ret                 */
+ 
+ /* In a Win32 SEH handler.  */
+ 
+ #define SIG_SEH1 \
+   (pc[-5] == 0xe8                     /* call addr           */ \
+    && pc[0] == 0x83 && pc[1] == 0xc4  /* add 0xval,%esp      */ \
+    && pc[3] == 0xb8)                  /* mov 0xval,%eax      */
+ 
+ #define SIG_SEH2 \
+   (pc[-5] == 0x8b && pc[-4] == 0x4d   /* mov depl(%ebp),%ecx */ \
+    && pc[0] == 0x64 && pc[1] == 0x8b) /* mov %fs:(0),<reg>   */ \
+ 
+ /* In the GCC alloca (stack probing).  */
+ 
+ #define SIG_ALLOCA \
+   (pc[-1] == 0x83                    /* orl $0x0,(%ecx)     */ \
+    && pc[0] == 0x9 && pc[1] == 0                               \
+    && pc[2] == 0x2d && pc[3] == 0    /* subl $0x1000,%eax   */ \
+    && pc[4] == 0x10 && pc[5] == 0)
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR x86_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ x86_fallback_frame_state (struct _Unwind_Context *context,
+ 			  _Unwind_FrameState *fs)
+ {
+   char *eh_debug_env = getenv ("EH_DEBUG");
+   int eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+  
+   void *ctx_ra  = (void *)(context->ra);  /* return address */
+   void *ctx_cfa = (void *)(context->cfa); /* context frame address */
+   unsigned char *pc = (unsigned char *) ctx_ra;
+ 
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n", ctx_cfa, ctx_ra);
+ 
+   /* In the test below we look for two specific patterns found
+      experimentally to be in the Windows signal handler.  */
+   if (SIG_PAT1 || SIG_PAT2 || SIG_SEH1 || SIG_SEH2)
+     {
+       PEXCEPTION_POINTERS weinfo;
+       PCONTEXT proc_ctx;
+       long new_cfa;
+ 
+       if (SIG_SEH1) 
+ 	proc_ctx = (PCONTEXT) (*(int*)(ctx_cfa + 56));
+       else if (SIG_SEH2)
+ 	proc_ctx = (PCONTEXT) (*(int*)(ctx_cfa + 8));
+       else
+ 	{
+ 	  weinfo = (PEXCEPTION_POINTERS) (*(int*)ctx_cfa);
+ 	  proc_ctx = weinfo->ContextRecord;
+ 	}
+ 
+       /* The new context frame address is the stack pointer.  */
+       new_cfa = proc_ctx->Esp;
+       fs->cfa_how = CFA_REG_OFFSET;
+       fs->cfa_reg = __builtin_dwarf_sp_column();
+       fs->cfa_offset = new_cfa- (long) ctx_cfa;
+ 
+       /* Save some registers.  */
+       fs->regs.reg[0].how = REG_SAVED_OFFSET;
+       fs->regs.reg[0].loc.offset = (long)&proc_ctx->Eax - new_cfa;
+       fs->regs.reg[3].how = REG_SAVED_OFFSET;
+       fs->regs.reg[3].loc.offset = (long)&proc_ctx->Ebx - new_cfa;
+       fs->regs.reg[1].how = REG_SAVED_OFFSET;
+       fs->regs.reg[1].loc.offset = (long)&proc_ctx->Ecx - new_cfa;
+       fs->regs.reg[2].how = REG_SAVED_OFFSET;
+       fs->regs.reg[2].loc.offset = (long)&proc_ctx->Edx - new_cfa;
+       fs->regs.reg[6].how = REG_SAVED_OFFSET;
+       fs->regs.reg[6].loc.offset = (long)&proc_ctx->Esi - new_cfa;
+       fs->regs.reg[7].how = REG_SAVED_OFFSET;
+       fs->regs.reg[7].loc.offset = (long)&proc_ctx->Edi - new_cfa;
+       fs->regs.reg[9].how = REG_SAVED_OFFSET;
+       fs->regs.reg[9].loc.offset = (long)&proc_ctx->Eip - new_cfa;
+       fs->regs.reg[4].how = REG_SAVED_OFFSET;
+       fs->regs.reg[4].loc.offset = (long)&proc_ctx->Ebp - new_cfa;
+ 
+       /* Set the return address to Eip + 1.  As we can be called multiple
+ 	 times we use another register for this.  */
+       proc_ctx->Dr0 = proc_ctx->Eip + 1;
+       fs->regs.reg[8].how = REG_SAVED_OFFSET;
+       fs->regs.reg[8].loc.offset = (long)&proc_ctx->Dr0 - new_cfa;
+       fs->retaddr_column = 8;
+ 
+       return _URC_NO_REASON;
+     }
+ 
+   /* Unwinding through _alloca, propagating from a trap triggered by
+      one of it's probes prior to the real SP adjustment.  The only
+      operations of interest performed is "pushl %ecx", followed by
+      ecx clobbering.  */
+   else if (SIG_ALLOCA) 
+     {
+       /* Only one push between entry in _alloca and the probe trap.  */ 
+       long new_cfa = (long) ctx_cfa + 4;
+ 
+       fs->cfa_how = CFA_REG_OFFSET;
+       fs->cfa_reg = __builtin_dwarf_sp_column();
+       fs->cfa_offset = new_cfa - (long) ctx_cfa;
+ 
+       /* The saved value of %ecx is at CFA - 4 */
+       fs->regs.reg[1].how = REG_SAVED_OFFSET;
+       fs->regs.reg[1].loc.offset = -4;
+ 
+       /* And what is stored at the CFA is the return address.  */
+       fs->regs.reg[8].how = REG_SAVED_OFFSET;
+       fs->regs.reg[8].loc.offset = 0;
+       fs->retaddr_column = 8;
+ 
+       return _URC_NO_REASON;
+     }
+ 
+   else
+     return _URC_END_OF_STACK;  
+ }
*** gcc/function.c.ori	Fri Jun  9 11:13:45 2006
--- gcc/function.c	Tue Jun 13 16:42:43 2006
*************** aggregate_value_p (tree exp, tree fntype
*** 1758,1772 ****
  
    tree type = (TYPE_P (exp)) ? exp : TREE_TYPE (exp);
  
    if (fntype)
      switch (TREE_CODE (fntype))
        {
        case CALL_EXPR:
! 	fntype = get_callee_fndecl (fntype);
! 	fntype = fntype ? TREE_TYPE (fntype) : 0;
  	break;
        case FUNCTION_DECL:
! 	fntype = TREE_TYPE (fntype);
  	break;
        case FUNCTION_TYPE:
        case METHOD_TYPE:
--- 1758,1775 ----
  
    tree type = (TYPE_P (exp)) ? exp : TREE_TYPE (exp);
  
+   tree fndecl = NULL_TREE;
+   
    if (fntype)
      switch (TREE_CODE (fntype))
        {
        case CALL_EXPR:
! 	fndecl = get_callee_fndecl (fntype);
! 	fntype = fndecl ? TREE_TYPE (fndecl) : 0;
  	break;
        case FUNCTION_DECL:
! 	fndecl = fntype;
! 	fntype = TREE_TYPE (fndecl);
  	break;
        case FUNCTION_TYPE:
        case METHOD_TYPE:
*************** aggregate_value_p (tree exp, tree fntype
*** 1786,1791 ****
--- 1789,1798 ----
    if ((TREE_CODE (exp) == PARM_DECL || TREE_CODE (exp) == RESULT_DECL)
        && DECL_BY_REFERENCE (exp))
      return 1;
+   if (TREE_CODE (exp) == CALL_EXPR && fndecl && DECL_RESULT (fndecl)
+       && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))
+     return 1;
+       
    if (targetm.calls.return_in_memory (type, fntype))
      return 1;
    /* Types that are TREE_ADDRESSABLE must be constructed in memory,
*** gcc/Makefile.in.0	2006-06-19 09:02:50.639633784 +0200
--- gcc/Makefile.in	2006-06-19 09:03:15.637833480 +0200
*************** gcc-vers.texi: $(BASEVER) $(DEVPHASE)
*** 3331,3336 ****
--- 3331,3337 ----
  	 then echo "@set DEVELOPMENT"; \
  	 else echo "@clear DEVELOPMENT"; \
  	 fi) > $@T
+ 	echo "@set srcdir $(srcdir)" >> $@T
  	mv -f $@T $@
  
  
*** gcc/doc/invoke.texi.0	2006-06-19 08:53:41.000000000 +0200
--- gcc/doc/invoke.texi	2006-06-19 09:03:27.469034864 +0200
***************
*** 4,9 ****
--- 4,13 ----
  @c For copying conditions, see the file gcc.texi.
  
  @ignore
+ @c man begin INCLUDE
+ @include gcc-vers.texi
+ @c man end
+ 
  @c man begin COPYRIGHT
  Copyright @copyright{} 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
  1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
*************** gcc [@option{-c}|@option{-S}|@option{-E}
*** 36,42 ****
      [@option{-I}@var{dir}@dots{}] [@option{-L}@var{dir}@dots{}]
      [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
      [@option{-f}@var{option}@dots{}] [@option{-m}@var{machine-option}@dots{}]
!     [@option{-o} @var{outfile}] @var{infile}@dots{}
  
  Only the most useful options are listed here; see below for the
  remainder.  @samp{g++} accepts mostly the same options as @samp{gcc}.
--- 40,46 ----
      [@option{-I}@var{dir}@dots{}] [@option{-L}@var{dir}@dots{}]
      [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
      [@option{-f}@var{option}@dots{}] [@option{-m}@var{machine-option}@dots{}]
!     [@option{-o} @var{outfile}] [@@@var{file}] @var{infile}@dots{}
  
  Only the most useful options are listed here; see below for the
  remainder.  @samp{g++} accepts mostly the same options as @samp{gcc}.
*************** in the following sections.
*** 156,162 ****
  @item Overall Options
  @xref{Overall Options,,Options Controlling the Kind of Output}.
  @gccoptlist{-c  -S  -E  -o @var{file}  -combine -pipe  -pass-exit-codes  @gol
! -x @var{language}  -v  -###  --help  --target-help  --version}
  
  @item C Language Options
  @xref{C Dialect Options,,Options Controlling C Dialect}.
--- 160,166 ----
  @item Overall Options
  @xref{Overall Options,,Options Controlling the Kind of Output}.
  @gccoptlist{-c  -S  -E  -o @var{file}  -combine -pipe  -pass-exit-codes  @gol
! -x @var{language}  -v  -###  --help  --target-help  --version @@@var{file}}
  
  @item C Language Options
  @xref{C Dialect Options,,Options Controlling C Dialect}.
*************** line options for each tool.
*** 1052,1057 ****
--- 1056,1063 ----
  @item --version
  @opindex version
  Display the version number and copyrights of the invoked GCC@.
+ 
+ @include @value{srcdir}/../libiberty/at-file.texi
  @end table
  
  @node Invoking G++
*** gcc/gcc.c.0	2006-06-19 08:53:51.000000000 +0200
--- gcc/gcc.c	2006-06-19 09:03:36.000000000 +0200
*************** fatal_error (int signum)
*** 6013,6022 ****
    kill (getpid (), signum);
  }
  
! extern int main (int, const char **);
  
  int
! main (int argc, const char **argv)
  {
    size_t i;
    int value;
--- 6013,6022 ----
    kill (getpid (), signum);
  }
  
! extern int main (int, char **);
  
  int
! main (int argc, char **argv)
  {
    size_t i;
    int value;
*************** main (int argc, const char **argv)
*** 6035,6040 ****
--- 6035,6042 ----
  
    xmalloc_set_program_name (programname);
  
+   expandargv (&argc, &argv);
+ 
  #ifdef GCC_DRIVER_HOST_INITIALIZATION
    /* Perform host dependent initialization when needed.  */
    GCC_DRIVER_HOST_INITIALIZATION;
*************** main (int argc, const char **argv)
*** 6127,6133 ****
       Make a table of specified input files (infiles, n_infiles).
       Decode switches that are handled locally.  */
  
!   process_command (argc, argv);
  
    /* Initialize the vector of specs to just the default.
       This means one element containing 0s, as a terminator.  */
--- 6129,6135 ----
       Make a table of specified input files (infiles, n_infiles).
       Decode switches that are handled locally.  */
  
!   process_command (argc, (const char **) argv);
  
    /* Initialize the vector of specs to just the default.
       This means one element containing 0s, as a terminator.  */
*** gcc/tree-ssa-loop-im.c.ori	2006-06-24 14:55:37.000000000 +0200
--- gcc/tree-ssa-loop-im.c	2006-06-24 14:55:48.000000000 +0200
*************** for_each_index (tree *addr_p, bool (*cbc
*** 174,180 ****
  
  	case BIT_FIELD_REF:
  	case VIEW_CONVERT_EXPR:
- 	case ARRAY_RANGE_REF:
  	case REALPART_EXPR:
  	case IMAGPART_EXPR:
  	  nxt = &TREE_OPERAND (*addr_p, 0);
--- 174,179 ----
*************** for_each_index (tree *addr_p, bool (*cbc
*** 192,197 ****
--- 191,197 ----
  	  break;
  
  	case ARRAY_REF:
+ 	case ARRAY_RANGE_REF:
  	  nxt = &TREE_OPERAND (*addr_p, 0);
  	  if (!cbck (*addr_p, &TREE_OPERAND (*addr_p, 1), data))
  	    return false;
*** gcc/optabs.c.0	2006-07-15 12:18:16.000000000 +0200
--- gcc/optabs.c	2006-07-15 12:27:47.000000000 +0200
*************** no_conflict_move_test (rtx dest, rtx set
*** 3041,3046 ****
--- 3041,3078 ----
      p->must_stay = true;
  }
  
+ /* Encapsulate the block starting at FIRST and ending with LAST, which is
+    logically equivalent to EQUIV, so it gets manipulated as a unit if it
+    is possible to do so.  */
+ 
+ static void
+ maybe_encapsulate_block (rtx first, rtx last, rtx equiv)
+ {
+   if (!flag_non_call_exceptions || !may_trap_p (equiv))
+     {
+       /* We can't attach the REG_LIBCALL and REG_RETVAL notes when the
+ 	 encapsulated region would not be in one basic block, i.e. when
+ 	 there is a control_flow_insn_p insn between FIRST and LAST.  */
+       bool attach_libcall_retval_notes = true;
+       rtx insn, next = NEXT_INSN (last);
+ 
+       for (insn = first; insn != next; insn = NEXT_INSN (insn))
+ 	if (control_flow_insn_p (insn))
+ 	  {
+ 	    attach_libcall_retval_notes = false;
+ 	    break;
+ 	  }
+ 
+       if (attach_libcall_retval_notes)
+ 	{
+ 	  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,
+ 						 REG_NOTES (first));
+ 	  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,
+ 						REG_NOTES (last));
+ 	}
+     }
+ }
+ 
  /* Emit code to perform a series of operations on a multi-word quantity, one
     word at a time.
  
*************** emit_no_conflict_block (rtx insns, rtx t
*** 3162,3171 ****
    else
      first = NEXT_INSN (prev);
  
!   /* Encapsulate the block so it gets manipulated as a unit.  */
!   REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,
! 					 REG_NOTES (first));
!   REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));
  
    return last;
  }
--- 3194,3200 ----
    else
      first = NEXT_INSN (prev);
  
!   maybe_encapsulate_block (first, last, equiv);
  
    return last;
  }
*************** emit_libcall_block (rtx insns, rtx targe
*** 3319,3348 ****
    else
      first = NEXT_INSN (prev);
  
!   /* Encapsulate the block so it gets manipulated as a unit.  */
!   if (!flag_non_call_exceptions || !may_trap_p (equiv))
!     {
!       /* We can't attach the REG_LIBCALL and REG_RETVAL notes
! 	 when the encapsulated region would not be in one basic block,
! 	 i.e. when there is a control_flow_insn_p insn between FIRST and LAST.
!        */
!       bool attach_libcall_retval_notes = true;
!       next = NEXT_INSN (last);
!       for (insn = first; insn != next; insn = NEXT_INSN (insn))
! 	if (control_flow_insn_p (insn))
! 	  {
! 	    attach_libcall_retval_notes = false;
! 	    break;
! 	  }
! 
!       if (attach_libcall_retval_notes)
! 	{
! 	  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,
! 						 REG_NOTES (first));
! 	  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,
! 						REG_NOTES (last));
! 	}
!     }
  }
  
  /* Nonzero if we can perform a comparison of mode MODE straightforwardly.
--- 3348,3354 ----
    else
      first = NEXT_INSN (prev);
  
!   maybe_encapsulate_block (first, last, equiv);
  }
  
  /* Nonzero if we can perform a comparison of mode MODE straightforwardly.
*** gcc/gimplify.c.ori	Mon Jul 24 10:40:27 2006
--- gcc/gimplify.c	Mon Jul 24 10:37:27 2006
*************** gimplify_init_constructor (tree *expr_p,
*** 2926,2931 ****
--- 2951,2970 ----
  	      }
  	  }
  
+ 	/* If there are nonzero elements, pre-evaluate to capture elements
+ 	   overlapping with the lhs into temporaries.  We must do this before
+ 	   clearing to get the values before they are zeroed out.  */
+ 	if (num_nonzero_elements > 0)
+ 	  {
+ 	    preeval_data.lhs_base_decl = get_base_address (object);
+ 	    if (!DECL_P (preeval_data.lhs_base_decl))
+ 	      preeval_data.lhs_base_decl = NULL;
+ 	    preeval_data.lhs_alias_set = get_alias_set (object);
+ 
+ 	    gimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),
+ 					pre_p, post_p, &preeval_data);
+ 	  }
+ 
  	if (cleared)
  	  {
  	    /* Zap the CONSTRUCTOR element list, which simplifies this case.
*************** gimplify_init_constructor (tree *expr_p,
*** 2941,2956 ****
  	   elements in the constructor, add assignments to the individual
  	   scalar fields of the object.  */
  	if (!cleared || num_nonzero_elements > 0)
! 	  {
! 	    preeval_data.lhs_base_decl = get_base_address (object);
! 	    if (!DECL_P (preeval_data.lhs_base_decl))
! 	      preeval_data.lhs_base_decl = NULL;
! 	    preeval_data.lhs_alias_set = get_alias_set (object);
! 
! 	    gimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),
! 					pre_p, post_p, &preeval_data);
! 	    gimplify_init_ctor_eval (object, elts, pre_p, cleared);
! 	  }
  
  	*expr_p = NULL_TREE;
        }
--- 2980,2986 ----
  	   elements in the constructor, add assignments to the individual
  	   scalar fields of the object.  */
  	if (!cleared || num_nonzero_elements > 0)
! 	  gimplify_init_ctor_eval (object, elts, pre_p, cleared);
  
  	*expr_p = NULL_TREE;
        }
*** configure.old	Thu Jul 27 17:51:20 2006
--- configure	Thu Jul 27 18:11:03 2006
*************** case "${target}" in
*** 1574,1579 ****
--- 1574,1582 ----
      ;;
    sparc-*-solaris* | sparc64-*-solaris* | sparcv9-*-solaris*)
      ;;
+   erc32-elf-* | leon-elf-*)
+     noconfigdirs="$noconfigdirs ${libgcj}"
+     ;;
    v810-*-*)
      noconfigdirs="$noconfigdirs bfd binutils gas gcc gdb ld target-libstdc++-v3 opcodes target-libgloss ${libgcj}"
      ;;
*** config.sub.old	Thu Jul 27 17:52:03 2006
--- config.sub	Fri Jul 28 12:09:36 2006
*************** case $basic_machine in
*** 243,248 ****
--- 243,249 ----
  	| bfin \
  	| c4x | clipper \
  	| d10v | d30v | dlx | dsp16xx \
+ 	| erc32 | leon \
  	| fr30 | frv \
  	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
  	| i370 | i860 | i960 | ia64 \
*** gcc/config.gcc.old	Fri Jul 28 18:19:44 2006
--- gcc/config.gcc	Mon Jul 31 10:23:36 2006
*************** sparc64*-*-*)
*** 311,316 ****
--- 311,319 ----
  sparc*-*-*)
  	cpu_type=sparc
  	;;
+ erc32-*-* | leon-*-*)
+ 	cpu_type=sparc
+ 	;;
  s390*-*-*)
  	cpu_type=s390
  	need_64bit_hwint=yes
*************** sparc64-*-netbsd*)
*** 2188,2193 ****
--- 2191,2208 ----
  	extra_options="${extra_options} sparc/long-double-switch.opt"
  	tmake_file="${tmake_file} sparc/t-netbsd64"
  	;;
+ erc32-*-elf*)
+ 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/erc32.h"
+ 	tmake_file="sparc/t-elf sparc/t-crtfm"
+ 	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+ 	use_fixproto=yes	
+ 	;;
+ leon-*-elf*)
+ 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/leon.h"
+ 	tmake_file="sparc/t-elf sparc/t-crtfm"
+ 	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+ 	use_fixproto=yes	
+ 	;;
  strongarm-*-elf*)
  	tm_file="arm/strongarm-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
  	tmake_file="arm/t-arm arm/t-strongarm-elf"
*************** if test x$with_cpu = x ; then
*** 2372,2377 ****
--- 2387,2395 ----
        # A Cirrus ARM variant.
        with_cpu="ep9312"
        ;;
+     erc32-*-*)
+       with_cpu=v7
+       ;;
      i486-*-*)
        with_cpu=i486
        ;;
*************** if test x$with_cpu = x ; then
*** 2452,2457 ****
--- 2470,2478 ----
      frv550-*-*linux*)
        with_cpu=fr550
        ;;
+     leon-*-*)
+       with_cpu=v8
+       ;;
      sparc*-*-*)
        with_cpu="`echo ${target} | sed 's/-.*$//'`"
        if [ x$with_cpu = xsparc64 ]; then
*************** case "${target}" in
*** 2580,2585 ****
--- 2601,2633 ----
  		fi
  		;;
  
+ 	erc32-*-*)
+ 		supported_defaults="cpu float tune"
+ 
+ 		for which in cpu tune; do
+ 			eval "val=\$with_$which"
+ 			case ${val} in
+ 			"" | sparc | v7 | cypress)
+ 				# OK
+ 				;;
+ 			*)
+ 				echo "Unknown cpu used in --with-$which=$val" 1>&2
+ 				exit 1
+ 				;;
+ 			esac
+ 		done
+ 
+ 		case ${with_float} in
+ 		"" | soft | hard)
+ 			# OK
+ 			;;
+ 		*)
+ 			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+ 			exit 1
+ 			;;
+ 		esac
+ 		;;
+ 
  	fr*-*-*linux*)
  		supported_defaults=cpu
  		case "$with_cpu" in
*************** case "${target}" in
*** 2592,2597 ****
--- 2640,2672 ----
  		esac
  		;;
  
+ 	leon-*-*)
+ 		supported_defaults="cpu float tune"
+ 
+ 		for which in cpu tune; do
+ 			eval "val=\$with_$which"
+ 			case ${val} in
+ 			"" | sparc | v7 | cypress | v8)
+ 				# OK
+ 				;;
+ 			*)
+ 				echo "Unknown cpu used in --with-$which=$val" 1>&2
+ 				exit 1
+ 				;;
+ 			esac
+ 		done
+ 
+ 		case ${with_float} in
+ 		"" | soft | hard)
+ 			# OK
+ 			;;
+ 		*)
+ 			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+ 			exit 1
+ 			;;
+ 		esac
+ 		;;
+ 
  	m68k*-linux*)
  		supported_defaults="cpu"
  		case "$with_cpu" in
*************** case ${target} in
*** 2825,2830 ****
--- 2900,2919 ----
  		fi
  		;;
  
+         erc32-*-*)
+                 with_cpu=cypress
+ 
+                 # The SPARC port checks this value at compile-time.
+                 target_cpu_default2="TARGET_CPU_$with_cpu"
+                 ;;
+ 
+         leon-*-*)
+                 with_cpu=v8
+ 
+                 # The SPARC port checks this value at compile-time.
+                 target_cpu_default2="TARGET_CPU_$with_cpu"
+                 ;;
+ 
  	m68k*-linux*)
  		case "x$with_cpu" in
  		x)
*** /dev/null	Mon Jul 31 11:17:51 2006
--- gcc/config/sparc/erc32.h	Mon Jul 31 11:47:29 2006
***************
*** 0 ****
--- 1,40 ----
+ /* Definitions for an ERC32 machine running in a bare board
+    configuration using the ELF object format.
+    Copyright (C) 2004-2006 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Use the required linker script file */
+ 
+ #undef LINK_SPEC
+ #define LINK_SPEC "-T erc32.ld%s"
+ 
+ /* Make the BSP and the C library available */
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC "-lerc32 %{!g:-lc} %{g:-lg}"
+ 
+ /* This target does not have MMU so that nothing needs to be done in
+    order to enable the execution of code on the stack. */
+ 
+ #undef ENABLE_EXECUTE_STACK
+ 
+ /* Force the use of dwarf-2 by default */
+ 
+ #undef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
*** /dev/null	Mon Jul 31 11:17:51 2006
--- gcc/config/sparc/leon.h	Mon Jul 31 11:47:40 2006
***************
*** 0 ****
--- 1,40 ----
+ /* Definitions for a LEON machine running in a bare board
+    configuration using the ELF object format.
+    Copyright (C) 2004-2006 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Use the required linker script file */
+ 
+ #undef LINK_SPEC
+ #define LINK_SPEC "-T leon.ld%s"
+ 
+ /* Make the BSP and the C library available */
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC "-lleon %{!g:-lc} %{g:-lg}"
+ 
+ /* This target does not have MMU so that nothing needs to be done in
+    order to enable the execution of code on the stack. */
+ 
+ #undef ENABLE_EXECUTE_STACK
+ 
+ /* Force the use of dwarf-2 by default */
+ 
+ #undef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
*** gcc/tree.c.0	2006-08-06 19:46:26.000000000 +0200
--- gcc/tree.c	2006-08-06 20:27:36.521807688 +0200
*************** build1_stat (enum tree_code code, tree t
*** 2817,2827 ****
        break;
  
      default:
!       if (TREE_CODE_CLASS (code) == tcc_unary
  	  && node && !TYPE_P (node)
  	  && TREE_CONSTANT (node))
  	TREE_CONSTANT (t) = 1;
!       if (TREE_CODE_CLASS (code) == tcc_unary
  	  && node && TREE_INVARIANT (node))
  	TREE_INVARIANT (t) = 1;
        if (TREE_CODE_CLASS (code) == tcc_reference
--- 2817,2827 ----
        break;
  
      default:
!       if ((TREE_CODE_CLASS (code) == tcc_unary || code == VIEW_CONVERT_EXPR)
  	  && node && !TYPE_P (node)
  	  && TREE_CONSTANT (node))
  	TREE_CONSTANT (t) = 1;
!       if ((TREE_CODE_CLASS (code) == tcc_unary || code == VIEW_CONVERT_EXPR)
  	  && node && TREE_INVARIANT (node))
  	TREE_INVARIANT (t) = 1;
        if (TREE_CODE_CLASS (code) == tcc_reference
*** gcc/config/i386/winnt.c.0	2006-08-08 18:13:12.614752368 +0200
--- gcc/config/i386/winnt.c	2006-08-08 18:21:14.151547648 +0200
*************** i386_pe_encode_section_info (tree decl, 
*** 354,364 ****
  	  if (GET_CODE (rtlname) == MEM)
  	    rtlname = XEXP (rtlname, 0);
  	  XSTR (rtlname, 0) = IDENTIFIER_POINTER (newid);
! 	  /* These attributes must be present on first declaration,
! 	     change_decl_assembler_name will warn if they are added
! 	     later and the decl has been referenced, but duplicate_decls
! 	     should catch the mismatch before this is called.  */ 
! 	  change_decl_assembler_name (decl, newid);
  	}
      }
  
--- 354,364 ----
  	  if (GET_CODE (rtlname) == MEM)
  	    rtlname = XEXP (rtlname, 0);
  	  XSTR (rtlname, 0) = IDENTIFIER_POINTER (newid);
! 	  /* Do not call change_decl_assembler_name as it will warn if
! 	     the suffix is added for different DECLs sharing the same
! 	     DECL_ASSEMBLER_NAME, which can happen if they represent
! 	     the same function imported multiple times in Ada.  */
! 	  SET_DECL_ASSEMBLER_NAME (decl, newid);
  	}
      }
  
*** gcc/config/rs6000/rs6000.c.0	2006-08-09 12:36:14.547255088 +0200
--- gcc/config/rs6000/rs6000.c	2006-08-09 12:36:44.982628208 +0200
*************** print_operand (FILE *file, rtx x, int co
*** 10274,10286 ****
        return;
  
      case 'D':
!       /* Like 'J' but get to the EQ bit.  */
        gcc_assert (GET_CODE (x) == REG);
  
!       /* Bit 1 is EQ bit.  */
!       i = 4 * (REGNO (x) - CR0_REGNO) + 2;
  
!       fprintf (file, "%d", i);
        return;
  
      case 'E':
--- 10274,10287 ----
        return;
  
      case 'D':
!       /* Like 'J' but get to the GT bit only.  */
        gcc_assert (GET_CODE (x) == REG);
  
!       /* Bit 1 is GT bit.  */
!       i = 4 * (REGNO (x) - CR0_REGNO) + 1;
  
!       /* Add one for shift count in rlinm for scc.  */
!       fprintf (file, "%d", i + 1);
        return;
  
      case 'E':
*************** rs6000_generate_compare (enum rtx_code c
*** 11079,11085 ****
    /* First, the compare.  */
    compare_result = gen_reg_rtx (comp_mode);
  
!   /* SPE FP compare instructions on the GPRs.  Yuck!  */
    if ((TARGET_E500 && !TARGET_FPRS && TARGET_HARD_FLOAT)
        && rs6000_compare_fp_p)
      {
--- 11080,11086 ----
    /* First, the compare.  */
    compare_result = gen_reg_rtx (comp_mode);
  
!   /* E500 FP compare instructions on the GPRs.  Yuck!  */
    if ((TARGET_E500 && !TARGET_FPRS && TARGET_HARD_FLOAT)
        && rs6000_compare_fp_p)
      {
*************** rs6000_generate_compare (enum rtx_code c
*** 11089,11096 ****
        if (op_mode == VOIDmode)
  	op_mode = GET_MODE (rs6000_compare_op1);
  
!       /* Note: The E500 comparison instructions set the GT bit (x +
! 	 1), on success.  This explains the mess.  */
  
        switch (code)
  	{
--- 11090,11097 ----
        if (op_mode == VOIDmode)
  	op_mode = GET_MODE (rs6000_compare_op1);
  
!       /* The E500 FP compare instructions toggle the GT bit (CR bit 1) only.
! 	 This explains the following mess.  */
  
        switch (code)
  	{
*** gcc/config/rs6000/rs6000.md.0	2006-08-09 12:36:17.962735856 +0200
--- gcc/config/rs6000/rs6000.md	2006-08-09 12:36:45.035620152 +0200
***************
*** 55,61 ****
     (UNSPEC_TLSGOTTPREL		28)
     (UNSPEC_TLSTLS		29)
     (UNSPEC_FIX_TRUNC_TF		30)	; fadd, rounding towards zero
!    (UNSPEC_MV_CR_GT		31)	; move_from_CR_eq_bit
     (UNSPEC_STFIWX		32)
     (UNSPEC_POPCNTB		33)
     (UNSPEC_FRES			34)
--- 55,61 ----
     (UNSPEC_TLSGOTTPREL		28)
     (UNSPEC_TLSTLS		29)
     (UNSPEC_FIX_TRUNC_TF		30)	; fadd, rounding towards zero
!    (UNSPEC_MV_CR_GT		31)	; move_from_CR_gt_bit
     (UNSPEC_STFIWX		32)
     (UNSPEC_POPCNTB		33)
     (UNSPEC_FRES			34)
*** gcc/gimplify.c.41	Fri Oct  6 11:29:51 2006
--- gcc/gimplify.c	Fri Oct  6 11:29:59 2006
*************** gimplify_type_sizes (tree type, tree *li
*** 4854,4860 ****
  
      case POINTER_TYPE:
      case REFERENCE_TYPE:
!       gimplify_type_sizes (TREE_TYPE (type), list_p);
        break;
  
      default:
--- 4854,4871 ----
  
      case POINTER_TYPE:
      case REFERENCE_TYPE:
! 	/* We used to recurse on the pointed-to type here, which turned out to
! 	   be incorrect because its definition might refer to variables not
! 	   yet initialized at this point if a forward declaration is involved.
! 
! 	   It was actually useful for anonymous pointed-to types to ensure
! 	   that the sizes evaluation dominates every possible later use of the
! 	   values.  Restricting to such types here would be safe since there
! 	   is no possible forward declaration around, but would introduce a
! 	   undesireable middle-end semantic to anonymity.  We then defer to
! 	   front-ends the responsibilty of ensuring that the sizes are
! 	   evaluated both early and late enough, e.g. by attaching artifical
! 	   type declarations to the tree.  */
        break;
  
      default:
*** gcc/config/i386/cygming.h.ori	Fri Sep  1 15:50:39 2006
--- gcc/config/i386/cygming.h	Fri Sep  1 15:51:59 2006
*************** Boston, MA 02110-1301, USA.  */
*** 29,34 ****
--- 29,37 ----
  #ifdef HAVE_GAS_PE_SECREL32_RELOC
  #define DWARF2_DEBUGGING_INFO 1
  
+ #undef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+ 
  #undef DBX_REGISTER_NUMBER
  #define DBX_REGISTER_NUMBER(n) (write_symbols == DWARF2_DEBUG   \
                                  ? svr4_dbx_register_map[n]      \
*** gcc/configure.ac.0	2006-12-21 09:04:36.104632520 +0100
--- gcc/configure.ac	2006-12-21 09:20:17.356540480 +0100
*************** fi
*** 2141,2154 ****
  
  gcc_GAS_CHECK_FEATURE(section merging support, gcc_cv_as_shf_merge,
   [elf,2,12,0], [--fatal-warnings],
!  [.section .rodata.str, "aMS", @progbits, 1])
! if test $gcc_cv_as_shf_merge = no; then
!   gcc_GAS_CHECK_FEATURE(section merging support, gcc_cv_as_shf_merge,
      [elf,2,12,0], [--fatal-warnings],
!     [.section .rodata.str, "aMS", %progbits, 1])
  fi
  AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_MERGE,
!   [`if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`],
  [Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.])
  
  gcc_GAS_CHECK_FEATURE(COMDAT group support, gcc_cv_as_comdat_group,
--- 2140,2185 ----
  
  gcc_GAS_CHECK_FEATURE(section merging support, gcc_cv_as_shf_merge,
   [elf,2,12,0], [--fatal-warnings],
!  [.section .rodata.str, "aMS", @progbits, 1],
!  [gcc_cv_as_shf_merge=no
!  if test $in_tree_ld = yes ; then
!    gcc_cv_as_shf_merge=yes
!  elif test x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then
!    # Check that the linker can merge marked and non-marked sections.
!    echo '.section .my_str, "aMS", @progbits, 1' > conftest1.s
!    echo '.string "dummy"' >> conftest1.s
!    echo '.section .my_str, "a", @progbits' > conftest2.s
!    echo '.string "dummy"' >> conftest2.s
!    if $gcc_cv_as -o conftest1.o conftest1.s > /dev/null 2>&1 \
!       && $gcc_cv_as -o conftest2.o conftest2.s > /dev/null 2>&1 \
!       && $gcc_cv_ld -o conftest conftest1.o conftest2.o > /dev/null 2>&1 \
!       && $gcc_cv_objdump -h conftest | grep my_str | wc -l | grep 1 > /dev/null; then
!      gcc_cv_as_shf_merge=yes
!    fi
!  fi])
! if test $gcc_cv_as_shf_merge != yes; then
!   gcc_GAS_CHECK_FEATURE(section merging support, gcc_cv_as_shf_merge_percent,
      [elf,2,12,0], [--fatal-warnings],
!     [.section .rodata.str, "aMS", %progbits, 1],
!     [gcc_cv_as_shf_merge_percent=no
!     if test $in_tree_ld = yes ; then
!       gcc_cv_as_shf_merge_percent=yes
!     elif test x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then
!       # Check that the linker can merge marked and non-marked sections.
!       echo '.section .my_str, "aMS", %progbits, 1' > conftest1.s
!       echo '.string "dummy"' >> conftest1.s
!       echo '.section .my_str, "a", %progbits' > conftest2.s
!       echo '.string "dummy"' >> conftest2.s
!       if $gcc_cv_as -o conftest1.o conftest1.s > /dev/null 2>&1 \
!          && $gcc_cv_as -o conftest2.o conftest2.s > /dev/null 2>&1 \
!          && $gcc_cv_ld -o conftest conftest1.o conftest2.o > /dev/null 2>&1 \
!          && $gcc_cv_objdump -h conftest | grep my_str | wc -l | grep 1 > /dev/null; then
!         gcc_cv_as_shf_merge_percent=yes
!       fi
!     fi])
  fi
  AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_MERGE,
!   [`if test $gcc_cv_as_shf_merge = yes || test $gcc_cv_as_shf_merge_percent = yes; then echo 1; else echo 0; fi`],
  [Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.])
  
  gcc_GAS_CHECK_FEATURE(COMDAT group support, gcc_cv_as_comdat_group,
*** gcc/configure.0	2006-12-21 09:07:40.932534408 +0100
--- gcc/configure	2006-12-21 09:20:27.192045256 +0100
*************** fi
*** 14371,14377 ****
    echo "$as_me:$LINENO: \$? = $ac_status" >&5
    (exit $ac_status); }; }
      then
! 	gcc_cv_as_shf_merge=yes
      else
        echo "configure: failed program was" >&5
        cat conftest.s >&5
--- 14371,14392 ----
    echo "$as_me:$LINENO: \$? = $ac_status" >&5
    (exit $ac_status); }; }
      then
! 	gcc_cv_as_shf_merge=no
!  if test $in_tree_ld = yes ; then
!    gcc_cv_as_shf_merge=yes
!  elif test x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then
!    # Check that the linker can merge marked and non-marked sections.
!    echo '.section .my_str, "aMS", @progbits, 1' > conftest1.s
!    echo '.string "dummy"' >> conftest1.s
!    echo '.section .my_str, "a", @progbits' > conftest2.s
!    echo '.string "dummy"' >> conftest2.s
!    if $gcc_cv_as -o conftest1.o conftest1.s > /dev/null 2>&1 \
!       && $gcc_cv_as -o conftest2.o conftest2.s > /dev/null 2>&1 \
!       && $gcc_cv_ld -o conftest conftest1.o conftest2.o > /dev/null 2>&1 \
!       && $gcc_cv_objdump -h conftest | grep my_str | wc -l | grep 1 > /dev/null; then
!      gcc_cv_as_shf_merge=yes
!    fi
!  fi
      else
        echo "configure: failed program was" >&5
        cat conftest.s >&5
*************** fi
*** 14382,14398 ****
  echo "$as_me:$LINENO: result: $gcc_cv_as_shf_merge" >&5
  echo "${ECHO_T}$gcc_cv_as_shf_merge" >&6
  
! if test $gcc_cv_as_shf_merge = no; then
    echo "$as_me:$LINENO: checking assembler for section merging support" >&5
  echo $ECHO_N "checking assembler for section merging support... $ECHO_C" >&6
! if test "${gcc_cv_as_shf_merge+set}" = set; then
    echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   gcc_cv_as_shf_merge=no
      if test $in_tree_gas = yes; then
      if test $in_tree_gas_is_elf = yes \
    && test $gcc_cv_gas_vers -ge `expr \( \( 2 \* 1000 \) + 12 \) \* 1000 + 0`
!   then gcc_cv_as_shf_merge=yes
  fi
    elif test x$gcc_cv_as != x; then
      echo '.section .rodata.str, "aMS", %progbits, 1' > conftest.s
--- 14397,14413 ----
  echo "$as_me:$LINENO: result: $gcc_cv_as_shf_merge" >&5
  echo "${ECHO_T}$gcc_cv_as_shf_merge" >&6
  
! if test $gcc_cv_as_shf_merge != yes; then
    echo "$as_me:$LINENO: checking assembler for section merging support" >&5
  echo $ECHO_N "checking assembler for section merging support... $ECHO_C" >&6
! if test "${gcc_cv_as_shf_merge_percent+set}" = set; then
    echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   gcc_cv_as_shf_merge_percent=no
      if test $in_tree_gas = yes; then
      if test $in_tree_gas_is_elf = yes \
    && test $gcc_cv_gas_vers -ge `expr \( \( 2 \* 1000 \) + 12 \) \* 1000 + 0`
!   then gcc_cv_as_shf_merge_percent=yes
  fi
    elif test x$gcc_cv_as != x; then
      echo '.section .rodata.str, "aMS", %progbits, 1' > conftest.s
*************** fi
*** 14403,14409 ****
    echo "$as_me:$LINENO: \$? = $ac_status" >&5
    (exit $ac_status); }; }
      then
! 	gcc_cv_as_shf_merge=yes
      else
        echo "configure: failed program was" >&5
        cat conftest.s >&5
--- 14418,14439 ----
    echo "$as_me:$LINENO: \$? = $ac_status" >&5
    (exit $ac_status); }; }
      then
! 	gcc_cv_as_shf_merge_percent=no
!     if test $in_tree_ld = yes ; then
!       gcc_cv_as_shf_merge_percent=yes
!     elif test x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then
!       # Check that the linker can merge marked and non-marked sections.
!       echo '.section .my_str, "aMS", %progbits, 1' > conftest1.s
!       echo '.string "dummy"' >> conftest1.s
!       echo '.section .my_str, "a", %progbits' > conftest2.s
!       echo '.string "dummy"' >> conftest2.s
!       if $gcc_cv_as -o conftest1.o conftest1.s > /dev/null 2>&1 \
!          && $gcc_cv_as -o conftest2.o conftest2.s > /dev/null 2>&1 \
!          && $gcc_cv_ld -o conftest conftest1.o conftest2.o > /dev/null 2>&1 \
!          && $gcc_cv_objdump -h conftest | grep my_str | wc -l | grep 1 > /dev/null; then
!         gcc_cv_as_shf_merge_percent=yes
!       fi
!     fi
      else
        echo "configure: failed program was" >&5
        cat conftest.s >&5
*************** fi
*** 14411,14423 ****
      rm -f conftest.o conftest.s
    fi
  fi
! echo "$as_me:$LINENO: result: $gcc_cv_as_shf_merge" >&5
! echo "${ECHO_T}$gcc_cv_as_shf_merge" >&6
  
  fi
  
  cat >>confdefs.h <<_ACEOF
! #define HAVE_GAS_SHF_MERGE `if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`
  _ACEOF
  
  
--- 14441,14453 ----
      rm -f conftest.o conftest.s
    fi
  fi
! echo "$as_me:$LINENO: result: $gcc_cv_as_shf_merge_percent" >&5
! echo "${ECHO_T}$gcc_cv_as_shf_merge_percent" >&6
  
  fi
  
  cat >>confdefs.h <<_ACEOF
! #define HAVE_GAS_SHF_MERGE `if test $gcc_cv_as_shf_merge = yes || test $gcc_cv_as_shf_merge_percent = yes; then echo 1; else echo 0; fi`
  _ACEOF
  
  
*** gcc/config/i386/win32-unwind.h.ori	Mon Sep 11 16:08:22 2006
--- gcc/config/i386/win32-unwind.h	Mon Sep 11 17:00:41 2006
*************** Boston, MA 02110-1301, USA.  */
*** 114,119 ****
--- 114,144 ----
  
  #define MD_FALLBACK_FRAME_STATE_FOR x86_fallback_frame_state
  
+ /* GCC hard register numbers and mapping to DW2 column numbers.  We
+    unfortunately can't reuse the back-end definitions because they're not
+    linked into libgcc.  */
+ 
+ #define GCC_EAX 0
+ #define GCC_EBX 3
+ #define GCC_ECX 2
+ #define GCC_EDX 1
+ #define GCC_ESI 4
+ #define GCC_EDI 5
+ #define GCC_EBP 6
+ #define GCC_ESP 7
+ 
+ /* Map in accordance with what a DWARF2 debug info writer would do,
+    that is, a-la svr4_dbx_register_map.  */
+ 
+ static int const libgcc_dbx_register_map[] =
+ {
+   0, 2, 1, 3, 6, 7, 5, 4		/* general regs */
+ };
+ 
+ #define DWFR(REGNO) libgcc_dbx_register_map[REGNO]
+ 
+ #define DW_EIP 8  /* retaddr column */
+ 
  static _Unwind_Reason_Code
  x86_fallback_frame_state (struct _Unwind_Context *context,
  			  _Unwind_FrameState *fs)
*************** x86_fallback_frame_state (struct _Unwind
*** 153,181 ****
        fs->cfa_offset = new_cfa- (long) ctx_cfa;
  
        /* Save some registers.  */
!       fs->regs.reg[0].how = REG_SAVED_OFFSET;
!       fs->regs.reg[0].loc.offset = (long)&proc_ctx->Eax - new_cfa;
!       fs->regs.reg[3].how = REG_SAVED_OFFSET;
!       fs->regs.reg[3].loc.offset = (long)&proc_ctx->Ebx - new_cfa;
!       fs->regs.reg[1].how = REG_SAVED_OFFSET;
!       fs->regs.reg[1].loc.offset = (long)&proc_ctx->Ecx - new_cfa;
!       fs->regs.reg[2].how = REG_SAVED_OFFSET;
!       fs->regs.reg[2].loc.offset = (long)&proc_ctx->Edx - new_cfa;
!       fs->regs.reg[6].how = REG_SAVED_OFFSET;
!       fs->regs.reg[6].loc.offset = (long)&proc_ctx->Esi - new_cfa;
!       fs->regs.reg[7].how = REG_SAVED_OFFSET;
!       fs->regs.reg[7].loc.offset = (long)&proc_ctx->Edi - new_cfa;
        fs->regs.reg[9].how = REG_SAVED_OFFSET;
        fs->regs.reg[9].loc.offset = (long)&proc_ctx->Eip - new_cfa;
-       fs->regs.reg[4].how = REG_SAVED_OFFSET;
-       fs->regs.reg[4].loc.offset = (long)&proc_ctx->Ebp - new_cfa;
  
        /* Set the return address to Eip + 1.  As we can be called multiple
  	 times we use another register for this.  */
        proc_ctx->Dr0 = proc_ctx->Eip + 1;
!       fs->regs.reg[8].how = REG_SAVED_OFFSET;
!       fs->regs.reg[8].loc.offset = (long)&proc_ctx->Dr0 - new_cfa;
!       fs->retaddr_column = 8;
  
        return _URC_NO_REASON;
      }
--- 178,207 ----
        fs->cfa_offset = new_cfa- (long) ctx_cfa;
  
        /* Save some registers.  */
!       fs->regs.reg[DWFR(GCC_EAX)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_EAX)].loc.offset = (long)&proc_ctx->Eax - new_cfa;
!       fs->regs.reg[DWFR(GCC_EBX)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_EBX)].loc.offset = (long)&proc_ctx->Ebx - new_cfa;
!       fs->regs.reg[DWFR(GCC_ECX)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_ECX)].loc.offset = (long)&proc_ctx->Ecx - new_cfa;
!       fs->regs.reg[DWFR(GCC_EDX)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_EDX)].loc.offset = (long)&proc_ctx->Edx - new_cfa;
!       fs->regs.reg[DWFR(GCC_ESI)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_ESI)].loc.offset = (long)&proc_ctx->Esi - new_cfa;
!       fs->regs.reg[DWFR(GCC_EDI)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_EDI)].loc.offset = (long)&proc_ctx->Edi - new_cfa;
!       fs->regs.reg[DWFR(GCC_EBP)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_EBP)].loc.offset = (long)&proc_ctx->Ebp - new_cfa;
! 
        fs->regs.reg[9].how = REG_SAVED_OFFSET;
        fs->regs.reg[9].loc.offset = (long)&proc_ctx->Eip - new_cfa;
  
        /* Set the return address to Eip + 1.  As we can be called multiple
  	 times we use another register for this.  */
        proc_ctx->Dr0 = proc_ctx->Eip + 1;
!       fs->regs.reg[DW_EIP].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DW_EIP].loc.offset = (long)&proc_ctx->Dr0 - new_cfa;
!       fs->retaddr_column = DW_EIP;
  
        return _URC_NO_REASON;
      }
*************** x86_fallback_frame_state (struct _Unwind
*** 194,206 ****
        fs->cfa_offset = new_cfa - (long) ctx_cfa;
  
        /* The saved value of %ecx is at CFA - 4 */
!       fs->regs.reg[1].how = REG_SAVED_OFFSET;
!       fs->regs.reg[1].loc.offset = -4;
  
        /* And what is stored at the CFA is the return address.  */
!       fs->regs.reg[8].how = REG_SAVED_OFFSET;
!       fs->regs.reg[8].loc.offset = 0;
!       fs->retaddr_column = 8;
  
        return _URC_NO_REASON;
      }
--- 220,232 ----
        fs->cfa_offset = new_cfa - (long) ctx_cfa;
  
        /* The saved value of %ecx is at CFA - 4 */
!       fs->regs.reg[DWFR(GCC_ECX)].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DWFR(GCC_ECX)].loc.offset = -4;
  
        /* And what is stored at the CFA is the return address.  */
!       fs->regs.reg[DW_EIP].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DW_EIP].loc.offset = 0;
!       fs->retaddr_column = DW_EIP;
  
        return _URC_NO_REASON;
      }
*** gcc/params.def.0	2006-09-11 18:03:26.143282328 +0200
--- gcc/params.def	2006-09-11 18:03:39.297282616 +0200
*************** DEFPARAM(PARAM_VECT_MAX_VERSION_CHECKS,
*** 435,441 ****
  DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,
  	"global-var-threshold",
  	"Given N calls and V call-clobbered vars in a function.  Use .GLOBAL_VAR if NxV is larger than this limit",
! 	500000, 0, 0)
  
  DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,
  	 "max-cselib-memory-locations",
--- 435,441 ----
  DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,
  	"global-var-threshold",
  	"Given N calls and V call-clobbered vars in a function.  Use .GLOBAL_VAR if NxV is larger than this limit",
! 	100000, 0, 0)
  
  DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,
  	 "max-cselib-memory-locations",
*** gcc/config/rs6000/t-aix43.ori	Thu Sep 14 18:56:26 2006
--- gcc/config/rs6000/t-aix43	Thu Sep 14 18:57:07 2006
*************** AR_FLAGS_FOR_TARGET = -X32_64
*** 80,83 ****
  # compiler with -mminimal-toc does not cause any harm.
  T_ADAFLAGS = -mminimal-toc
  BOOT_LDFLAGS = -Wl,-bbigtoc
! LDFLAGS = `case $(CC) in *gcc*) echo -Wl,-bbigtoc ;; esac;`
--- 80,83 ----
  # compiler with -mminimal-toc does not cause any harm.
  T_ADAFLAGS = -mminimal-toc
  BOOT_LDFLAGS = -Wl,-bbigtoc
! LDFLAGS = `case '$(CC)' in *gcc*) echo -Wl,-bbigtoc ;; esac;`
*** gcc/config/rs6000/t-aix52.ori	Thu Sep 14 18:56:33 2006
--- gcc/config/rs6000/t-aix52	Thu Sep 14 18:57:19 2006
*************** AR_FLAGS_FOR_TARGET = -X32_64
*** 61,64 ****
  # compiler with -mminimal-toc does not cause any harm.
  T_ADAFLAGS = -mminimal-toc
  BOOT_LDFLAGS = -Wl,-bbigtoc
! LDFLAGS = `case $(CC) in *gcc*) echo -Wl,-bbigtoc ;; esac;`
--- 61,64 ----
  # compiler with -mminimal-toc does not cause any harm.
  T_ADAFLAGS = -mminimal-toc
  BOOT_LDFLAGS = -Wl,-bbigtoc
! LDFLAGS = `case '$(CC)' in *gcc*) echo -Wl,-bbigtoc ;; esac;`
*** gcc/builtins.c.0	2006-09-21 08:37:37.826929304 +0200
--- gcc/builtins.c	2006-09-20 21:23:00.000000000 +0200
*************** static int apply_result_size (void);
*** 82,88 ****
  #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)
  static rtx result_vector (int, rtx);
  #endif
- static rtx expand_builtin_setjmp (tree, rtx);
  static void expand_builtin_update_setjmp_buf (rtx);
  static void expand_builtin_prefetch (tree);
  static rtx expand_builtin_apply_args (void);
--- 82,87 ----
*************** expand_builtin_setjmp_receiver (rtx rece
*** 728,792 ****
    emit_insn (gen_rtx_ASM_INPUT (VOIDmode, ""));
  }
  
- /* __builtin_setjmp is passed a pointer to an array of five words (not
-    all will be used on all machines).  It operates similarly to the C
-    library function of the same name, but is more efficient.  Much of
-    the code below (and for longjmp) is copied from the handling of
-    non-local gotos.
- 
-    NOTE: This is intended for use by GNAT and the exception handling
-    scheme in the compiler and will only work in the method used by
-    them.  */
- 
- static rtx
- expand_builtin_setjmp (tree arglist, rtx target)
- {
-   rtx buf_addr, next_lab, cont_lab;
- 
-   if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
-     return NULL_RTX;
- 
-   if (target == 0 || !REG_P (target)
-       || REGNO (target) < FIRST_PSEUDO_REGISTER)
-     target = gen_reg_rtx (TYPE_MODE (integer_type_node));
- 
-   buf_addr = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
- 
-   next_lab = gen_label_rtx ();
-   cont_lab = gen_label_rtx ();
- 
-   expand_builtin_setjmp_setup (buf_addr, next_lab);
- 
-   /* Set TARGET to zero and branch to the continue label.  Use emit_jump to
-      ensure that pending stack adjustments are flushed.  */
-   emit_move_insn (target, const0_rtx);
-   emit_jump (cont_lab);
- 
-   emit_label (next_lab);
- 
-   /* Because setjmp and longjmp are not represented in the CFG, a cfgcleanup
-      may find that the basic block starting with NEXT_LAB is unreachable.
-      The whole block, along with NEXT_LAB, would be removed (see PR26983).
-      Make sure that never happens.  */
-   LABEL_PRESERVE_P (next_lab) = 1;
-      
-   expand_builtin_setjmp_receiver (next_lab);
- 
-   /* Set TARGET to one.  */
-   emit_move_insn (target, const1_rtx);
-   emit_label (cont_lab);
- 
-   /* Tell flow about the strange goings on.  Putting `next_lab' on
-      `nonlocal_goto_handler_labels' to indicates that function
-      calls may traverse the arc back to this label.  */
- 
-   current_function_has_nonlocal_label = 1;
-   nonlocal_goto_handler_labels
-     = gen_rtx_EXPR_LIST (VOIDmode, next_lab, nonlocal_goto_handler_labels);
- 
-   return target;
- }
- 
  /* __builtin_longjmp is passed a pointer to an array of five words (not
     all will be used on all machines).  It operates similarly to the C
     library function of the same name, but is more efficient.  Much of
--- 727,732 ----
*************** expand_builtin (tree exp, rtx target, rt
*** 6167,6184 ****
        break;
  
      case BUILT_IN_SETJMP:
!       target = expand_builtin_setjmp (arglist, target);
!       if (target)
! 	return target;
        break;
  
        /* __builtin_longjmp is passed a pointer to an array of five words.
  	 It's similar to the C library longjmp function but works with
  	 __builtin_setjmp above.  */
      case BUILT_IN_LONGJMP:
!       if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
! 	break;
!       else
  	{
  	  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
  				      VOIDmode, 0);
--- 6121,6181 ----
        break;
  
      case BUILT_IN_SETJMP:
!       /* This should have been lowered to the builtins below.  */
!       gcc_unreachable ();
! 
!     case BUILT_IN_SETJMP_SETUP:
!       /* __builtin_setjmp_setup is passed a pointer to an array of five words
!           and the receiver label.  */
!       if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
! 	{
! 	  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
! 				      VOIDmode, 0);
! 	  tree label = TREE_OPERAND (TREE_VALUE (TREE_CHAIN (arglist)), 0);
! 	  rtx label_r = label_rtx (label);
! 
! 	  /* This is copied from the handling of non-local gotos.  */
! 	  expand_builtin_setjmp_setup (buf_addr, label_r);
! 	  nonlocal_goto_handler_labels
! 	    = gen_rtx_EXPR_LIST (VOIDmode, label_r,
! 				 nonlocal_goto_handler_labels);
! 	  /* ??? Do not let expand_label treat us as such.  */
! 	  FORCED_LABEL (label) = 0;
! 	  return const0_rtx;
! 	}
!       break;
! 
!     case BUILT_IN_SETJMP_DISPATCHER:
!        /* __builtin_setjmp_dispatcher is passed the dispatcher label.  */
!       if (validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
! 	{
! 	  tree label = TREE_OPERAND (TREE_VALUE (arglist), 0);
! 	  rtx label_r = label_rtx (label);
! 
! 	  /* Remove the dispatcher label from the list of non-local labels
! 	     since the receiver labels have been added to it above.  */
! 	  remove_node_from_expr_list (label_r, &nonlocal_goto_handler_labels);
! 	  return const0_rtx;
! 	}
!       break;
! 
!     case BUILT_IN_SETJMP_RECEIVER:
!        /* __builtin_setjmp_receiver is passed the receiver label.  */
!       if (validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
! 	{
! 	  tree label = TREE_OPERAND (TREE_VALUE (arglist), 0);
! 	  rtx label_r = label_rtx (label);
! 
! 	  expand_builtin_setjmp_receiver (label_r);
! 	  return const0_rtx;
! 	}
        break;
  
        /* __builtin_longjmp is passed a pointer to an array of five words.
  	 It's similar to the C library longjmp function but works with
  	 __builtin_setjmp above.  */
      case BUILT_IN_LONGJMP:
!       if (validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
  	{
  	  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
  				      VOIDmode, 0);
*************** expand_builtin (tree exp, rtx target, rt
*** 6194,6199 ****
--- 6191,6197 ----
  	  expand_builtin_longjmp (buf_addr, value);
  	  return const0_rtx;
  	}
+       break;
  
      case BUILT_IN_NONLOCAL_GOTO:
        target = expand_builtin_nonlocal_goto (arglist);
*** gcc/builtins.def.0	2006-09-15 10:04:30.000000000 +0200
--- gcc/builtins.def	2006-09-20 21:23:57.000000000 +0200
*************** DEF_BUILTIN_STUB (BUILT_IN_INIT_TRAMPOLI
*** 664,669 ****
--- 664,674 ----
  DEF_BUILTIN_STUB (BUILT_IN_ADJUST_TRAMPOLINE, "__builtin_adjust_trampoline")
  DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, "__builtin_nonlocal_goto")
  
+ /* Implementing __builtin_setjmp.  */
+ DEF_BUILTIN_STUB (BUILT_IN_SETJMP_SETUP, "__builtin_setjmp_setup")
+ DEF_BUILTIN_STUB (BUILT_IN_SETJMP_DISPATCHER, "__builtin_setjmp_dispatcher")
+ DEF_BUILTIN_STUB (BUILT_IN_SETJMP_RECEIVER, "__builtin_setjmp_receiver")
+ 
  /* Implementing variable sized local variables.  */
  DEF_BUILTIN_STUB (BUILT_IN_STACK_SAVE, "__builtin_stack_save")
  DEF_BUILTIN_STUB (BUILT_IN_STACK_RESTORE, "__builtin_stack_restore")
*** gcc/gimple-low.c.0	2006-09-15 09:38:38.000000000 +0200
--- gcc/gimple-low.c	2006-09-20 21:23:57.000000000 +0200
*************** struct lower_data
*** 49,63 ****
    /* A TREE_LIST of label and return statements to be moved to the end
       of the function.  */
    tree return_statements;
  };
  
  static void lower_stmt (tree_stmt_iterator *, struct lower_data *);
  static void lower_bind_expr (tree_stmt_iterator *, struct lower_data *);
  static void lower_cond_expr (tree_stmt_iterator *, struct lower_data *);
  static void lower_return_expr (tree_stmt_iterator *, struct lower_data *);
  static bool expand_var_p (tree);
  
! /* Lowers the body of current_function_decl.  */
  
  static void
  lower_function_body (void)
--- 49,67 ----
    /* A TREE_LIST of label and return statements to be moved to the end
       of the function.  */
    tree return_statements;
+ 
+   /* True if the function calls __builtin_setjmp.  */
+   bool calls_builtin_setjmp;
  };
  
  static void lower_stmt (tree_stmt_iterator *, struct lower_data *);
  static void lower_bind_expr (tree_stmt_iterator *, struct lower_data *);
  static void lower_cond_expr (tree_stmt_iterator *, struct lower_data *);
  static void lower_return_expr (tree_stmt_iterator *, struct lower_data *);
+ static void lower_builtin_setjmp (tree_stmt_iterator *);
  static bool expand_var_p (tree);
  
! /* Lower the body of current_function_decl.  */
  
  static void
  lower_function_body (void)
*************** lower_function_body (void)
*** 76,81 ****
--- 80,86 ----
    TREE_ASM_WRITTEN (data.block) = 1;
  
    data.return_statements = NULL_TREE;
+   data.calls_builtin_setjmp = false;
  
    *body_p = alloc_stmt_list ();
    i = tsi_start (*body_p);
*************** lower_function_body (void)
*** 115,120 ****
--- 120,154 ----
        tsi_link_after (&i, x, TSI_CONTINUE_LINKING);
      }
  
+   /* If the function calls __builtin_setjmp, we need to emit the computed
+      goto that will serve as the unique dispatcher for all the receivers.  */
+   if (data.calls_builtin_setjmp)
+     {
+       tree disp_label, disp_var, arg;
+ 
+       /* Build 'DISP_LABEL:' and insert.  */
+       disp_label = create_artificial_label ();
+       /* This mark will create forward edges from every call site.  */
+       DECL_NONLOCAL (disp_label) = 1;
+       current_function_has_nonlocal_label = 1;
+       x = build1 (LABEL_EXPR, void_type_node, disp_label);
+       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);
+ 
+       /* Build 'DISP_VAR = __builtin_setjmp_dispatcher (DISP_LABEL);'
+ 	 and insert.  */
+       disp_var = create_tmp_var (ptr_type_node, "setjmpvar");
+       t = build_addr (disp_label, current_function_decl);
+       arg = tree_cons (NULL, t, NULL);
+       t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];
+       t = build_function_call_expr (t,arg);
+       x = build2 (MODIFY_EXPR, void_type_node, disp_var, t);
+ 
+       /* Build 'goto DISP_VAR;' and insert.  */
+       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);
+       x = build1 (GOTO_EXPR, void_type_node, disp_var);
+       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);
+     }
+ 
    gcc_assert (data.block == DECL_INITIAL (current_function_decl));
    BLOCK_SUBBLOCKS (data.block)
      = blocks_nreverse (BLOCK_SUBBLOCKS (data.block));
*************** struct tree_opt_pass pass_lower_cf = 
*** 140,146 ****
  };
  
  
! /* Lowers the EXPR.  Unlike gimplification the statements are not relowered
     when they are changed -- if this has to be done, the lowering routine must
     do it explicitly.  DATA is passed through the recursion.  */
  
--- 174,180 ----
  };
  
  
! /* Lower the EXPR.  Unlike gimplification the statements are not relowered
     when they are changed -- if this has to be done, the lowering routine must
     do it explicitly.  DATA is passed through the recursion.  */
  
*************** lower_stmt_body (tree expr, struct lower
*** 153,159 ****
      lower_stmt (&tsi, data);
  }
  
! /* Lowers statement TSI.  DATA is passed through the recursion.  */
  
  static void
  lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)
--- 187,193 ----
      lower_stmt (&tsi, data);
  }
  
! /* Lower statement TSI.  DATA is passed through the recursion.  */
  
  static void
  lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)
*************** lower_stmt (tree_stmt_iterator *tsi, str
*** 189,201 ****
        
      case NOP_EXPR:
      case ASM_EXPR:
-     case MODIFY_EXPR:
-     case CALL_EXPR:
      case GOTO_EXPR:
      case LABEL_EXPR:
      case SWITCH_EXPR:
        break;
  
      default:
  #ifdef ENABLE_CHECKING
        print_node_brief (stderr, "", stmt, 0);
--- 223,254 ----
        
      case NOP_EXPR:
      case ASM_EXPR:
      case GOTO_EXPR:
      case LABEL_EXPR:
      case SWITCH_EXPR:
        break;
  
+     case MODIFY_EXPR:
+       if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)
+ 	stmt = TREE_OPERAND (stmt, 1);
+       else
+ 	break;
+       /* FALLTHRU */
+ 
+     case CALL_EXPR:
+       {
+ 	tree decl = get_callee_fndecl (stmt);
+ 	if (decl
+ 	    && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL
+ 	    && DECL_FUNCTION_CODE (decl) == BUILT_IN_SETJMP)
+ 	  {
+ 	    data->calls_builtin_setjmp = true;
+ 	    lower_builtin_setjmp (tsi);
+ 	    return;
+ 	  }
+       }
+       break;
+ 
      default:
  #ifdef ENABLE_CHECKING
        print_node_brief (stderr, "", stmt, 0);
*************** lower_stmt (tree_stmt_iterator *tsi, str
*** 208,214 ****
    tsi_next (tsi);
  }
  
! /* Lowers a bind_expr TSI.  DATA is passed through the recursion.  */
  
  static void
  lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)
--- 261,267 ----
    tsi_next (tsi);
  }
  
! /* Lower a bind_expr TSI.  DATA is passed through the recursion.  */
  
  static void
  lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)
*************** block_may_fallthru (tree block)
*** 377,383 ****
      }
  }
  
! /* Lowers a cond_expr TSI.  DATA is passed through the recursion.  */
  
  static void
  lower_cond_expr (tree_stmt_iterator *tsi, struct lower_data *data)
--- 430,436 ----
      }
  }
  
! /* Lower a cond_expr TSI.  DATA is passed through the recursion.  */
  
  static void
  lower_cond_expr (tree_stmt_iterator *tsi, struct lower_data *data)
*************** lower_cond_expr (tree_stmt_iterator *tsi
*** 472,477 ****
--- 525,532 ----
    tsi_next (tsi);
  }
  
+ /* Lower a return_expr TSI.  DATA is passed through the recursion.  */
+ 
  static void
  lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)
  {
*************** lower_return_expr (tree_stmt_iterator *t
*** 508,513 ****
--- 563,691 ----
    tsi_link_before (tsi, t, TSI_SAME_STMT);
    tsi_delink (tsi);
  }
+ 
+ /* Lower a __builtin_setjmp TSI.
+ 
+    __builtin_setjmp is passed a pointer to an array of five words (not
+    all will be used on all machines).  It operates similarly to the C
+    library function of the same name, but is more efficient.
+ 
+    It is lowered into 3 other builtins, namely __builtin_setjmp_setup,
+    __builtin_setjmp_dispatcher and __builtin_setjmp_receiver, but with
+    __builtin_setjmp_dispatcher shared among all the instances; that's
+    why it is only emitted at the end by lower_function_body.
+ 
+    After full lowering, the body of the function should look like:
+ 
+     {
+       void * setjmpvar.0;
+       int D.1844;
+       int D.2844;
+ 
+       [...]
+ 
+       __builtin_setjmp_setup (&buf, &<D1847>);
+       D.1844 = 0;
+       goto <D1846>;
+       <D1847>:;
+       __builtin_setjmp_receiver (&<D1847>);
+       D.1844 = 1;
+       <D1846>:;
+       if (D.1844 == 0) goto <D1848>; else goto <D1849>;
+ 
+       [...]
+ 
+       __builtin_setjmp_setup (&buf, &<D2847>);
+       D.2844 = 0;
+       goto <D2846>;
+       <D2847>:;
+       __builtin_setjmp_receiver (&<D2847>);
+       D.2844 = 1;
+       <D2846>:;
+       if (D.2844 == 0) goto <D2848>; else goto <D2849>;
+ 
+       [...]
+ 
+       <D3850>:;
+       return;
+       <D3853>: [non-local];
+       setjmpvar.0 = __builtin_setjmp_dispatcher (&<D3853>);
+       goto setjmpvar.0;
+     }
+ 
+    NOTE: This is intended for use by GNAT and the exception handling
+    scheme in the compiler and will only work in the method used by
+    them.  */
+ 
+ static void
+ lower_builtin_setjmp (tree_stmt_iterator *tsi)
+ {
+   tree stmt = tsi_stmt (*tsi);
+   tree cont_label = create_artificial_label ();
+   tree next_label = create_artificial_label ();
+   tree dest, t, arg;
+ 
+   /* NEXT_LABEL is the label __builtin_longjmp will jump to.  Its address is
+      passed to both __builtin_setjmp_setup and __builtin_setjmp_receiver.  */
+   FORCED_LABEL (next_label) = 1;
+ 
+   if (TREE_CODE (stmt) == MODIFY_EXPR)
+     {
+       dest = TREE_OPERAND (stmt, 0);
+       stmt = TREE_OPERAND (stmt, 1);
+     }
+   else
+     dest = NULL_TREE;
+ 
+   /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */
+   t = build_addr (next_label, current_function_decl);
+   arg = tree_cons (NULL, t, NULL);
+   t = TREE_VALUE (TREE_OPERAND (stmt, 1));
+   arg = tree_cons (NULL, t, arg);
+   t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];
+   t = build_function_call_expr (t, arg);
+   SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+   tsi_link_before (tsi, t, TSI_SAME_STMT);
+ 
+   /* Build 'DEST = 0' and insert.  */
+   if (dest)
+     {
+       t = build2 (MODIFY_EXPR, void_type_node, dest, integer_zero_node);
+       SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+       tsi_link_before (tsi, t, TSI_SAME_STMT);
+     }
+ 
+   /* Build 'goto CONT_LABEL' and insert.  */
+   t = build1 (GOTO_EXPR, void_type_node, cont_label);
+   tsi_link_before (tsi, t, TSI_SAME_STMT);
+ 
+   /* Build 'NEXT_LABEL:' and insert.  */
+   t = build1 (LABEL_EXPR, void_type_node, next_label);
+   tsi_link_before (tsi, t, TSI_SAME_STMT);
+ 
+   /* Build '__builtin_setjmp_receiver (NEXT_LABEL)' and insert.  */
+   t = build_addr (next_label, current_function_decl);
+   arg = tree_cons (NULL, t, NULL);
+   t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];
+   t = build_function_call_expr (t, arg);
+   SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+   tsi_link_before (tsi, t, TSI_SAME_STMT);
+ 
+   /* Build 'DEST = 1' and insert.  */
+   if (dest)
+     {
+       t = build2 (MODIFY_EXPR, void_type_node, dest, integer_one_node);
+       SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));
+       tsi_link_before (tsi, t, TSI_SAME_STMT);
+     }
+ 
+   /* Build 'CONT_LABEL:' and insert.  */
+   t = build1 (LABEL_EXPR, void_type_node, cont_label);
+   tsi_link_before (tsi, t, TSI_SAME_STMT);
+ 
+   /* Remove the call to __builtin_setjmp.  */
+   tsi_delink (tsi);
+ }
  
  
  /* Record the variables in VARS.  */
*** gcc/tree.c.0	2006-09-15 13:05:57.000000000 +0200
--- gcc/tree.c	2006-09-20 21:23:57.000000000 +0200
*************** build_common_builtin_nodes (void)
*** 6492,6497 ****
--- 6492,6517 ----
  			"__builtin_nonlocal_goto",
  			ECF_NORETURN | ECF_NOTHROW);
  
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
+   ftype = build_function_type (void_type_node, tmp);
+   local_define_builtin ("__builtin_setjmp_setup", ftype,
+ 			BUILT_IN_SETJMP_SETUP,
+ 			"__builtin_setjmp_setup", ECF_NOTHROW);
+ 
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   ftype = build_function_type (ptr_type_node, tmp);
+   local_define_builtin ("__builtin_setjmp_dispatcher", ftype,
+ 			BUILT_IN_SETJMP_DISPATCHER,
+ 			"__builtin_setjmp_dispatcher",
+ 			ECF_PURE | ECF_NOTHROW);
+ 
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   ftype = build_function_type (void_type_node, tmp);
+   local_define_builtin ("__builtin_setjmp_receiver", ftype,
+ 			BUILT_IN_SETJMP_RECEIVER,
+ 			"__builtin_setjmp_receiver", ECF_NOTHROW);
+ 
    ftype = build_function_type (ptr_type_node, void_list_node);
    local_define_builtin ("__builtin_stack_save", ftype, BUILT_IN_STACK_SAVE,
  			"__builtin_stack_save", ECF_NOTHROW);
*** gcc/tree-cfg.c.0	2006-09-17 18:58:16.000000000 +0200
--- gcc/tree-cfg.c	2006-09-20 21:23:57.000000000 +0200
*************** make_ctrl_stmt_edges (basic_block bb)
*** 513,532 ****
  static void
  make_exit_edges (basic_block bb)
  {
!   tree last = last_stmt (bb), op;
! 
    gcc_assert (last);
    switch (TREE_CODE (last))
      {
      case RESX_EXPR:
        break;
      case CALL_EXPR:
        /* If this function receives a nonlocal goto, then we need to
  	 make edges from this call site to all the nonlocal goto
  	 handlers.  */
!       if (TREE_SIDE_EFFECTS (last)
! 	  && current_function_has_nonlocal_label)
! 	make_goto_expr_edges (bb);
  
        /* If this statement has reachable exception handlers, then
  	 create abnormal edges to them.  */
--- 513,533 ----
  static void
  make_exit_edges (basic_block bb)
  {
!   tree last = last_stmt (bb);
    gcc_assert (last);
+ 
    switch (TREE_CODE (last))
      {
      case RESX_EXPR:
        break;
+ 
      case CALL_EXPR:
+     case MODIFY_EXPR:
        /* If this function receives a nonlocal goto, then we need to
  	 make edges from this call site to all the nonlocal goto
  	 handlers.  */
!       if (tree_can_make_abnormal_goto (last))
! 	make_abnormal_goto_edges (bb, true);
  
        /* If this statement has reachable exception handlers, then
  	 create abnormal edges to them.  */
*************** make_exit_edges (basic_block bb)
*** 539,545 ****
  	 such a bloody pain to avoid creating edges for this case since
  	 all we do is remove these edges when we're done building the
  	 CFG.  */
!       if (call_expr_flags (last) & ECF_NORETURN)
  	{
  	  make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);
  	  return;
--- 540,547 ----
  	 such a bloody pain to avoid creating edges for this case since
  	 all we do is remove these edges when we're done building the
  	 CFG.  */
!       if (TREE_CODE (last) == CALL_EXPR
! 	  && call_expr_flags (last) & ECF_NORETURN)
  	{
  	  make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);
  	  return;
*************** make_exit_edges (basic_block bb)
*** 549,567 ****
        make_edge (bb, bb->next_bb, EDGE_FALLTHRU);
        break;
  
-     case MODIFY_EXPR:
-       /* A MODIFY_EXPR may have a CALL_EXPR on its RHS and the CALL_EXPR
- 	 may have an abnormal edge.  Search the RHS for this case and
- 	 create any required edges.  */
-       op = get_call_expr_in (last);
-       if (op && TREE_SIDE_EFFECTS (op)
- 	  && current_function_has_nonlocal_label)
- 	make_goto_expr_edges (bb);
- 
-       make_eh_edges (last);
-       make_edge (bb, bb->next_bb, EDGE_FALLTHRU);
-       break;
- 
      default:
        gcc_unreachable ();
      }
--- 551,556 ----
*************** label_to_block_fn (struct function *ifun
*** 806,885 ****
    return VARRAY_BB (ifun->cfg->x_label_to_block_map, uid);
  }
  
  /* Create edges for a goto statement at block BB.  */
  
  static void
  make_goto_expr_edges (basic_block bb)
  {
-   tree goto_t;
-   basic_block target_bb;
-   int for_call;
    block_stmt_iterator last = bsi_last (bb);
  
!   goto_t = bsi_stmt (last);
! 
!   /* If the last statement is not a GOTO (i.e., it is a RETURN_EXPR,
!      CALL_EXPR or MODIFY_EXPR), then the edge is an abnormal edge resulting
!      from a nonlocal goto.  */
!   if (TREE_CODE (goto_t) != GOTO_EXPR)
!     for_call = 1;
!   else
      {
        tree dest = GOTO_DESTINATION (goto_t);
!       for_call = 0;
! 
!       /* A GOTO to a local label creates normal edges.  */
!       if (simple_goto_p (goto_t))
! 	{
! 	  edge e = make_edge (bb, label_to_block (dest), EDGE_FALLTHRU);
  #ifdef USE_MAPPED_LOCATION
! 	  e->goto_locus = EXPR_LOCATION (goto_t);
  #else
! 	  e->goto_locus = EXPR_LOCUS (goto_t);
  #endif
! 	  bsi_remove (&last);
! 	  return;
! 	}
! 
!       /* Nothing more to do for nonlocal gotos.  */
!       if (TREE_CODE (dest) == LABEL_DECL)
! 	return;
! 
!       /* Computed gotos remain.  */
!     }
! 
!   /* Look for the block starting with the destination label.  In the
!      case of a computed goto, make an edge to any label block we find
!      in the CFG.  */
!   FOR_EACH_BB (target_bb)
!     {
!       block_stmt_iterator bsi;
! 
!       for (bsi = bsi_start (target_bb); !bsi_end_p (bsi); bsi_next (&bsi))
! 	{
! 	  tree target = bsi_stmt (bsi);
! 
! 	  if (TREE_CODE (target) != LABEL_EXPR)
! 	    break;
! 
! 	  if (
! 	      /* Computed GOTOs.  Make an edge to every label block that has
! 		 been marked as a potential target for a computed goto.  */
! 	      (FORCED_LABEL (LABEL_EXPR_LABEL (target)) && for_call == 0)
! 	      /* Nonlocal GOTO target.  Make an edge to every label block
! 		 that has been marked as a potential target for a nonlocal
! 		 goto.  */
! 	      || (DECL_NONLOCAL (LABEL_EXPR_LABEL (target)) && for_call == 1))
! 	    {
! 	      make_edge (bb, target_bb, EDGE_ABNORMAL);
! 	      break;
! 	    }
! 	}
      }
  
!   /* Degenerate case of computed goto with no labels.  */
!   if (!for_call && EDGE_COUNT (bb->succs) == 0)
!     make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);
  }
  
  
--- 795,858 ----
    return VARRAY_BB (ifun->cfg->x_label_to_block_map, uid);
  }
  
+ /* Create edges for an abnormal goto statement at block BB.  If FOR_CALL
+    is true, the source statement is a CALL_EXPR instead of a GOTO_EXPR.  */
+ 
+ void
+ make_abnormal_goto_edges (basic_block bb, bool for_call)
+ {
+   basic_block target_bb;
+   block_stmt_iterator bsi;
+ 
+   FOR_EACH_BB (target_bb)
+     for (bsi = bsi_start (target_bb); !bsi_end_p (bsi); bsi_next (&bsi))
+       {
+ 	tree target = bsi_stmt (bsi);
+ 
+ 	if (TREE_CODE (target) != LABEL_EXPR)
+ 	  break;
+ 
+ 	target = LABEL_EXPR_LABEL (target);
+ 
+ 	/* Make an edge to every label block that has been marked as a
+ 	   potential target for a computed goto or a non-local goto.  */
+ 	if ((FORCED_LABEL (target) && !for_call)
+ 	    || (DECL_NONLOCAL (target) && for_call))
+ 	  {
+ 	    make_edge (bb, target_bb, EDGE_ABNORMAL);
+ 	    break;
+ 	  }
+       }
+ 
+   /* Degenerate case of computed goto with no labels.  */
+   if (!for_call && EDGE_COUNT (bb->succs) == 0)
+     make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);
+ }
+ 
  /* Create edges for a goto statement at block BB.  */
  
  static void
  make_goto_expr_edges (basic_block bb)
  {
    block_stmt_iterator last = bsi_last (bb);
+   tree goto_t = bsi_stmt (last);
  
!   /* A simple GOTO creates normal edges.  */
!   if (simple_goto_p (goto_t))
      {
        tree dest = GOTO_DESTINATION (goto_t);
!       edge e = make_edge (bb, label_to_block (dest), EDGE_FALLTHRU);
  #ifdef USE_MAPPED_LOCATION
!       e->goto_locus = EXPR_LOCATION (goto_t);
  #else
!       e->goto_locus = EXPR_LOCUS (goto_t);
  #endif
!       bsi_remove (&last);
!       return;
      }
  
!   /* A computed GOTO creates abnormal edges.  */
!   make_abnormal_goto_edges (bb, false);
  }
  
  
*************** computed_goto_p (tree t)
*** 2507,2519 ****
  }
  
  
! /* Checks whether EXPR is a simple local goto.  */
  
  bool
! simple_goto_p (tree expr)
  {
!   return (TREE_CODE (expr) == GOTO_EXPR
! 	  && TREE_CODE (GOTO_DESTINATION (expr)) == LABEL_DECL);
  }
  
  
--- 2480,2510 ----
  }
  
  
! /* Return true if T is a simple local goto.  */
! 
! bool
! simple_goto_p (tree t)
! {
!   return (TREE_CODE (t) == GOTO_EXPR
! 	  && TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL);
! }
! 
! 
! /* Return true if T can make an abnormal transfer of control flow.
!    Transfers of control flow associated with EH are excluded.  */
  
  bool
! tree_can_make_abnormal_goto (tree t)
  {
!   if (computed_goto_p (t))
!     return true;
!   if (TREE_CODE (t) == MODIFY_EXPR)
!     t = TREE_OPERAND (t, 1);
!   if (TREE_CODE (t) == WITH_SIZE_EXPR)
!     t = TREE_OPERAND (t, 0);
!   if (TREE_CODE (t) == CALL_EXPR)
!     return TREE_SIDE_EFFECTS (t) && current_function_has_nonlocal_label;
!   return false;
  }
  
  
*************** tree_redirect_edge_and_branch (edge e, b
*** 4017,4023 ****
    edge ret;
    tree label, stmt;
  
!   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))
      return NULL;
  
    if (e->src != ENTRY_BLOCK_PTR 
--- 4008,4014 ----
    edge ret;
    tree label, stmt;
  
!   if (e->flags & EDGE_ABNORMAL)
      return NULL;
  
    if (e->src != ENTRY_BLOCK_PTR 
*************** tree_flow_call_edges_add (sbitmap blocks
*** 4834,4839 ****
--- 4825,4865 ----
    return blocks_split;
  }
  
+ /* Purge dead abnormal call edges from basic block BB.  */
+ 
+ bool
+ tree_purge_dead_abnormal_call_edges (basic_block bb)
+ {
+   bool changed = tree_purge_dead_eh_edges (bb);
+ 
+   if (current_function_has_nonlocal_label)
+     {
+       tree stmt = last_stmt (bb);
+       edge_iterator ei;
+       edge e;
+ 
+       if (!(stmt && tree_can_make_abnormal_goto (stmt)))
+ 	for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )
+ 	  {
+ 	    if (e->flags & EDGE_ABNORMAL)
+ 	      {
+ 		remove_edge (e);
+ 		changed = true;
+ 	      }
+ 	    else
+ 	      ei_next (&ei);
+ 	  }
+ 
+       /* See tree_purge_dead_eh_edges below.  */
+       if (changed)
+ 	free_dominance_info (CDI_DOMINATORS);
+     }
+ 
+   return changed;
+ }
+ 
+ /* Purge dead EH edges from basic block BB.  */
+ 
  bool
  tree_purge_dead_eh_edges (basic_block bb)
  {
*** gcc/tree-flow.h.0	2006-09-17 22:18:30.000000000 +0200
--- gcc/tree-flow.h	2006-09-20 21:23:57.000000000 +0200
*************** extern bool is_ctrl_stmt (tree);
*** 514,519 ****
--- 514,520 ----
  extern bool is_ctrl_altering_stmt (tree);
  extern bool computed_goto_p (tree);
  extern bool simple_goto_p (tree);
+ extern bool tree_can_make_abnormal_goto (tree);
  extern basic_block single_noncomplex_succ (basic_block bb);
  extern void tree_dump_bb (basic_block, FILE *, int);
  extern void debug_tree_bb (basic_block);
*************** extern bool tree_duplicate_sese_region (
*** 546,551 ****
--- 547,553 ----
  					basic_block *);
  extern void add_phi_args_after_copy_bb (basic_block);
  extern void add_phi_args_after_copy (basic_block *, unsigned);
+ extern bool tree_purge_dead_abnormal_call_edges (basic_block);
  extern bool tree_purge_dead_eh_edges (basic_block);
  extern bool tree_purge_all_dead_eh_edges (bitmap);
  extern tree gimplify_val (block_stmt_iterator *, tree, tree);
*************** extern tree gimplify_build3 (block_stmt_
*** 557,562 ****
--- 559,565 ----
  			     tree, tree, tree, tree);
  extern void init_empty_tree_cfg (void);
  extern void fold_cond_expr_cond (void);
+ extern void make_abnormal_goto_edges (basic_block, bool);
  extern void replace_uses_by (tree, tree);
  extern void start_recording_case_labels (void);
  extern void end_recording_case_labels (void);
*** gcc/tree-inline.c.0	2006-09-17 20:56:09.000000000 +0200
--- gcc/tree-inline.c	2006-09-20 21:23:57.000000000 +0200
*************** expand_call_inline (basic_block bb, tree
*** 1984,1989 ****
--- 1984,1990 ----
    edge e;
    block_stmt_iterator bsi, stmt_bsi;
    bool successfully_inlined = FALSE;
+   bool purge_dead_abnormal_edges;
    tree t_step;
    tree var;
    struct cgraph_node *old_node;
*************** expand_call_inline (basic_block bb, tree
*** 2079,2108 ****
  #endif
  
    /* We will be inlining this callee.  */
- 
    id->eh_region = lookup_stmt_eh_region (stmt);
  
    /* Split the block holding the CALL_EXPR.  */
- 
    e = split_block (bb, stmt);
    bb = e->src;
    return_block = e->dest;
    remove_edge (e);
  
!   /* split_block splits before the statement, work around this by moving
!      the call into the first half_bb.  Not pretty, but seems easier than
!      doing the CFG manipulation by hand when the CALL_EXPR is in the last
!      statement in BB.  */
    stmt_bsi = bsi_last (bb);
    bsi = bsi_start (return_block);
!   if (!bsi_end_p (bsi))
!     bsi_move_before (&stmt_bsi, &bsi);
!   else
      {
-       tree stmt = bsi_stmt (stmt_bsi);
-       bsi_remove (&stmt_bsi);
        bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);
      }
    stmt_bsi = bsi_start (return_block);
  
    /* Build a block containing code to initialize the arguments, the
--- 2080,2115 ----
  #endif
  
    /* We will be inlining this callee.  */
    id->eh_region = lookup_stmt_eh_region (stmt);
  
    /* Split the block holding the CALL_EXPR.  */
    e = split_block (bb, stmt);
    bb = e->src;
    return_block = e->dest;
    remove_edge (e);
  
!   /* split_block splits after the statement; work around this by
!      moving the call into the second block manually.  Not pretty,
!      but seems easier than doing the CFG manipulation by hand
!      when the CALL_EXPR is in the last statement of BB.  */
    stmt_bsi = bsi_last (bb);
+   bsi_remove (&stmt_bsi);
+ 
+   /* If the CALL_EXPR was in the last statement of BB, it may have
+      been the source of abnormal edges.  In this case, schedule
+      the removal of dead abnormal edges.  */
    bsi = bsi_start (return_block);
!   if (bsi_end_p (bsi))
      {
        bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);
+       purge_dead_abnormal_edges = true;
      }
+   else
+     {
+       bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);
+       purge_dead_abnormal_edges = false;
+     }
+ 
    stmt_bsi = bsi_start (return_block);
  
    /* Build a block containing code to initialize the arguments, the
*************** expand_call_inline (basic_block bb, tree
*** 2218,2226 ****
         tsi_delink() will leave the iterator in a sane state.  */
      bsi_remove (&stmt_bsi);
  
!   bsi_next (&bsi);
!   if (bsi_end_p (bsi))
!     tree_purge_dead_eh_edges (return_block);
  
    /* If the value of the new expression is ignored, that's OK.  We
       don't warn about this for CALL_EXPRs, so we shouldn't warn about
--- 2225,2232 ----
         tsi_delink() will leave the iterator in a sane state.  */
      bsi_remove (&stmt_bsi);
  
!   if (purge_dead_abnormal_edges)
!     tree_purge_dead_abnormal_call_edges (return_block);
  
    /* If the value of the new expression is ignored, that's OK.  We
       don't warn about this for CALL_EXPRs, so we shouldn't warn about
*** gcc/tree-optimize.c.0	2006-09-17 15:56:51.000000000 +0200
--- gcc/tree-optimize.c	2006-09-20 21:23:57.000000000 +0200
*************** struct tree_opt_pass pass_free_cfg_annot
*** 227,235 ****
    0,					/* todo_flags_finish */
    0					/* letter */
  };
! /* Pass: fixup_cfg - IPA passes or compilation of earlier functions might've
!    changed some properties - such as marked functions nothrow.  Remove now
!    redundant edges and basic blocks.  */
  
  static void
  execute_fixup_cfg (void)
--- 227,252 ----
    0,					/* todo_flags_finish */
    0					/* letter */
  };
! 
! /* Return true if BB has at least one abnormal outgoing edge.  */
! 
! static inline bool
! has_abnormal_outgoing_edge_p (basic_block bb)
! {
!   edge e;
!   edge_iterator ei;
! 
!   FOR_EACH_EDGE (e, ei, bb->succs)
!     if (e->flags & EDGE_ABNORMAL)
!       return true;
! 
!   return false;
! }
! 
! /* Pass: fixup_cfg.  IPA passes, compilation of earlier functions or inlining
!    might have changed some properties, such as marked functions nothrow or
!    added calls that can potentially go to non-local labels.  Remove redundant
!    edges and basic blocks, and create new ones if necessary.  */
  
  static void
  execute_fixup_cfg (void)
*************** execute_fixup_cfg (void)
*** 252,259 ****
  	  }
  	tree_purge_dead_eh_edges (bb);
        }
!     
    cleanup_tree_cfg ();
  }
  
  struct tree_opt_pass pass_fixup_cfg =
--- 269,304 ----
  	  }
  	tree_purge_dead_eh_edges (bb);
        }
! 
!   if (current_function_has_nonlocal_label)
!     FOR_EACH_BB (bb)
!       {
! 	for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))
! 	  {
! 	    tree stmt = bsi_stmt (bsi);
! 	    if (tree_can_make_abnormal_goto (stmt))
! 	      {
! 		if (stmt == bsi_stmt (bsi_last (bb)))
! 		  {
! 		    if (!has_abnormal_outgoing_edge_p (bb))
! 		      make_abnormal_goto_edges (bb, true);
! 		  }
! 		else
! 		  {
! 		    edge e = split_block (bb, stmt);
! 		    bb = e->src;
! 		    make_abnormal_goto_edges (bb, true);
! 		  }
! 		break;
! 	      }
! 	  }
!       }
! 
    cleanup_tree_cfg ();
+ 
+   /* Dump a textual representation of the flowgraph.  */
+   if (dump_file)
+     dump_tree_cfg (dump_file, dump_flags);
  }
  
  struct tree_opt_pass pass_fixup_cfg =
*************** struct tree_opt_pass pass_fixup_cfg =
*** 269,275 ****
    0,					/* properties_provided */
    0,					/* properties_destroyed */
    0,					/* todo_flags_start */
!   TODO_dump_func,			/* todo_flags_finish */
    0					/* letter */
  };
  
--- 314,320 ----
    0,					/* properties_provided */
    0,					/* properties_destroyed */
    0,					/* todo_flags_start */
!   0,					/* todo_flags_finish */
    0					/* letter */
  };
  
*** gcc/config/i386/cygming.h.ori	Fri Sep 22 15:06:28 2006
--- gcc/config/i386/cygming.h	Fri Sep 22 15:06:34 2006
*************** extern int i386_pe_dllimport_name_p (con
*** 352,357 ****
--- 352,367 ----
  #undef	BIGGEST_ALIGNMENT
  #define BIGGEST_ALIGNMENT 128
  
+ /* Biggest alignment supported by the object file format of this
+    machine.  Use this macro to limit the alignment which can be
+    specified using the `__attribute__ ((aligned (N)))' construct.  If
+    not defined, the default value is `BIGGEST_ALIGNMENT'.  */
+ #undef MAX_OFILE_ALIGNMENT
+ /* IMAGE_SCN_ALIGN_8192BYTES is the largest section alignment flag
+    specified in the PECOFF60 spec.  Native MS compiler also limits
+    user-specified alignment to 8192 bytes.  */
+ #define MAX_OFILE_ALIGNMENT (8192 * 8)
+ 
  /* Native complier aligns internal doubles in structures on dword boundaries.  */
  #undef	BIGGEST_FIELD_ALIGNMENT
  #define BIGGEST_FIELD_ALIGNMENT 64
*** gcc/config/i386/cygming.h.ori	Fri Sep 22 15:06:28 2006
--- gcc/config/i386/cygming.h	Fri Sep 22 18:31:14 2006
*************** extern void i386_pe_unique_section (TREE
*** 309,314 ****
--- 306,317 ----
     changed to call __register_frame_info/__deregister_frame_info.  */
  #define DWARF2_UNWIND_INFO 1 
  
+ /* Stick to the default register mapping for frame unwind info, to not be
+    influenced by whether Dwarf-2 debug info is produced, which would happen
+    otherwise as this defaults to DBX_REGISTER_NUMBER if not defined.  */
+ #undef DWARF_FRAME_REGNUM
+ #define DWARF_FRAME_REGNUM(n) (dbx_register_map[n])
+ 
  /* Don't assume anything about the header files.  */
  #define NO_IMPLICIT_EXTERN_C
  
*** gcc/config/i386/win32-unwind.h.ori	Fri Sep 22 18:27:59 2006
--- gcc/config/i386/win32-unwind.h	Fri Sep 22 18:30:10 2006
*************** Boston, MA 02110-1301, USA.  */
*** 127,138 ****
  #define GCC_EBP 6
  #define GCC_ESP 7
  
! /* Map in accordance with what a DWARF2 debug info writer would do,
!    that is, a-la svr4_dbx_register_map.  */
  
  static int const libgcc_dbx_register_map[] =
  {
!   0, 2, 1, 3, 6, 7, 5, 4		/* general regs */
  };
  
  #define DWFR(REGNO) libgcc_dbx_register_map[REGNO]
--- 127,137 ----
  #define GCC_EBP 6
  #define GCC_ESP 7
  
! /* Map in accordance with how DWARF_FRAME_REGNUM is defined.  */
  
  static int const libgcc_dbx_register_map[] =
  {
!   0, 2, 1, 3, 6, 7, 4, 5		/* general regs */
  };
  
  #define DWFR(REGNO) libgcc_dbx_register_map[REGNO]
*** gcc/gimplify.c.0	2006-09-21 11:34:32.000000000 +0200
--- gcc/gimplify.c	2006-09-26 22:14:10.804944008 +0200
*************** gimplify_init_ctor_preeval (tree *expr_p
*** 2535,2543 ****
        return;
      }
  
!   /* We can't preevaluate if the type contains a placeholder.  */
!   if (type_contains_placeholder_p (TREE_TYPE (*expr_p)))
!     return;
  
    /* Gimplify the constructor element to something appropriate for the rhs
       of a MODIFY_EXPR.  Given that we know the lhs is an aggregate, we know
--- 2535,2542 ----
        return;
      }
  
!   /* If this is a variable sized type, we must remember the size.  */
!   maybe_with_size_expr (expr_p);
  
    /* Gimplify the constructor element to something appropriate for the rhs
       of a MODIFY_EXPR.  Given that we know the lhs is an aggregate, we know
*** gcc/config/i386/cygming.h.ori	Wed Sep 27 22:46:00 2006
--- gcc/config/i386/cygming.h	Wed Sep 27 23:16:35 2006
*************** extern void i386_pe_unique_section (TREE
*** 309,319 ****
     changed to call __register_frame_info/__deregister_frame_info.  */
  #define DWARF2_UNWIND_INFO 1 
  
! /* Stick to the default register mapping for frame unwind info, to not be
!    influenced by whether Dwarf-2 debug info is produced, which would happen
!    otherwise as this defaults to DBX_REGISTER_NUMBER if not defined.  */
  #undef DWARF_FRAME_REGNUM
! #define DWARF_FRAME_REGNUM(n) (dbx_register_map[n])
  
  /* Don't assume anything about the header files.  */
  #define NO_IMPLICIT_EXTERN_C
--- 309,332 ----
     changed to call __register_frame_info/__deregister_frame_info.  */
  #define DWARF2_UNWIND_INFO 1 
  
! /* Enforce dwarf values to the dw2 DBX mapping whatever write_symbols says,
!    which might be NO_DEBUG when called for call frame info and debug info
!    generation is off.  */
  #undef DWARF2_FRAME_REGNUM
! #define DWARF_FRAME_REGNUM(n) (svr4_dbx_register_map[n])
! 
! /* Stick to the default base register mapping for .eh_frame unwind info, 
!    still, to preserve binary compatibility.  */
! 
! #define SVR4_TO_DBX_REGISTER_NUMBER(n)	\
!   (  (n) == 5 ? 4			\
!    : (n) == 4 ? 5			\
!    : (n) >= 11 && (n) <= 18 ? (n) + 1	\
!    : (n))
! 
! #undef DWARF_FRAME_REG_OUT
! #define DWARF2_FRAME_REG_OUT(n, for_eh)	\
!   ((for_eh) ? SVR4_TO_DBX_REGISTER_NUMBER (n) : (n))
  
  /* Don't assume anything about the header files.  */
  #define NO_IMPLICIT_EXTERN_C
*** fixincludes/mkfixinc.sh	Sat Nov 19 13:47:21 2005
--- fixincludes/mkfixinc.sh	Thu Sep 28 10:20:58 2006
***************
*** 26,31 ****
--- 26,32 ----
      powerpc-*-eabiaix* | \
      powerpc-*-eabisim* | \
      powerpc-*-eabi*    | \
+     *-*-vxworks | \
      powerpc-*-rtems*   | \
      powerpcle-*-eabisim* | \
      powerpcle-*-eabi* )
*** gcc/dwarf2out.c.ori	2006-10-01 14:54:18.000000000 +0200
--- gcc/dwarf2out.c	2006-10-01 14:54:25.000000000 +0200
*************** static void dwarf2out_source_line (unsig
*** 99,104 ****
--- 99,111 ----
  # endif
  #endif
  
+ /* Map register numbers held in the call frame info that gcc has
+    collected using DWARF_FRAME_REGNUM to those that should be output in
+    .debug_frame and .eh_frame.  */
+ #ifndef DWARF2_FRAME_REG_OUT
+ #define DWARF2_FRAME_REG_OUT(REGNO, FOR_EH) (REGNO)
+ #endif
+ 
  /* Decide whether we want to emit frame unwind information for the current
     translation unit.  */
  
*************** static void def_cfa_1 (const char *, dw_
*** 453,459 ****
  rtx
  expand_builtin_dwarf_sp_column (void)
  {
!   return GEN_INT (DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));
  }
  
  /* Return a pointer to a copy of the section string name S with all
--- 460,467 ----
  rtx
  expand_builtin_dwarf_sp_column (void)
  {
!   int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);
!   return GEN_INT (DWARF2_FRAME_REG_OUT (dwarf_regnum, 1));
  }
  
  /* Return a pointer to a copy of the section string name S with all
*************** expand_builtin_init_dwarf_reg_sizes (tre
*** 486,512 ****
    bool wrote_return_column = false;
  
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
!     if (DWARF_FRAME_REGNUM (i) < DWARF_FRAME_REGISTERS)
!       {
! 	HOST_WIDE_INT offset = DWARF_FRAME_REGNUM (i) * GET_MODE_SIZE (mode);
! 	enum machine_mode save_mode = reg_raw_mode[i];
! 	HOST_WIDE_INT size;
! 
! 	if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))
! 	  save_mode = choose_hard_reg_mode (i, 1, true);
! 	if (DWARF_FRAME_REGNUM (i) == DWARF_FRAME_RETURN_COLUMN)
! 	  {
! 	    if (save_mode == VOIDmode)
! 	      continue;
! 	    wrote_return_column = true;
! 	  }
! 	size = GET_MODE_SIZE (save_mode);
! 	if (offset < 0)
! 	  continue;
! 
! 	emit_move_insn (adjust_address (mem, mode, offset),
! 			gen_int_mode (size, mode));
!       }
  
  #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
    gcc_assert (wrote_return_column);
--- 494,524 ----
    bool wrote_return_column = false;
  
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
!     {
!       int rnum = DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), 1);
!       
!       if (rnum < DWARF_FRAME_REGISTERS)
! 	{
! 	  HOST_WIDE_INT offset = rnum * GET_MODE_SIZE (mode);
! 	  enum machine_mode save_mode = reg_raw_mode[i];
! 	  HOST_WIDE_INT size;
! 	  
! 	  if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))
! 	    save_mode = choose_hard_reg_mode (i, 1, true);
! 	  if (DWARF_FRAME_REGNUM (i) == DWARF_FRAME_RETURN_COLUMN)
! 	    {
! 	      if (save_mode == VOIDmode)
! 		continue;
! 	      wrote_return_column = true;
! 	    }
! 	  size = GET_MODE_SIZE (save_mode);
! 	  if (offset < 0)
! 	    continue;
! 	  
! 	  emit_move_insn (adjust_address (mem, mode, offset),
! 			  gen_int_mode (size, mode));
! 	}
!     }
  
  #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
    gcc_assert (wrote_return_column);
*************** dw_cfi_oprnd2_desc (enum dwarf_call_fram
*** 2009,2021 ****
  
  #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)
  
- /* Map register numbers held in the call frame info that gcc has
-    collected using DWARF_FRAME_REGNUM to those that should be output in
-    .debug_frame and .eh_frame.  */
- #ifndef DWARF2_FRAME_REG_OUT
- #define DWARF2_FRAME_REG_OUT(REGNO, FOR_EH) (REGNO)
- #endif
- 
  /* Output a Call Frame Information opcode and its operand(s).  */
  
  static void
--- 2021,2026 ----
*** gcc/config/i386/win32-unwind.h.ori	2006-10-01 16:11:50.000000000 +0200
--- gcc/config/i386/win32-unwind.h	2006-10-01 16:16:53.000000000 +0200
***************
*** 115,122 ****
  #define MD_FALLBACK_FRAME_STATE_FOR x86_fallback_frame_state
  
  /* GCC hard register numbers and mapping to DW2 column numbers.  We
!    unfortunately can't reuse the back-end definitions because they're not
!    linked into libgcc.  */
  
  #define GCC_EAX 0
  #define GCC_EBX 3
--- 115,123 ----
  #define MD_FALLBACK_FRAME_STATE_FOR x86_fallback_frame_state
  
  /* GCC hard register numbers and mapping to DW2 column numbers.  We
!    unfortunately can't reuse the back-end definitions because they
!    might refer to symbols (e.g. register map tables) not linked into
!    libgcc.  */
  
  #define GCC_EAX 0
  #define GCC_EBX 3
***************
*** 127,137 ****
  #define GCC_EBP 6
  #define GCC_ESP 7
  
! /* Map in accordance with how DWARF_FRAME_REGNUM is defined.  */
  
  static int const libgcc_dbx_register_map[] =
  {
!   0, 2, 1, 3, 6, 7, 4, 5		/* general regs */
  };
  
  #define DWFR(REGNO) libgcc_dbx_register_map[REGNO]
--- 128,142 ----
  #define GCC_EBP 6
  #define GCC_ESP 7
  
! /* Partial .eh_frame mapping for the GCC registers above, in accordance with
!    DWARF_FRAME_REGNUM+DWARF2_FRAME_REG_OUT definitions.  */
  
  static int const libgcc_dbx_register_map[] =
  {
!   /* Indexed by GCC REGNO ...
!                 0   1   2   3   4   5   6   7    */
!   /* GCC */ /*  EAX EDX ECX EBX ESI EDI EBP ESP  */
!   /* DW  */     0,  2,  1,  3,  6,  7,  4,  5
  };
  
  #define DWFR(REGNO) libgcc_dbx_register_map[REGNO]
*** gcc/dwarf2out.c.orig	Mon Oct  2 16:29:14 2006
--- gcc/dwarf2out.c	Mon Oct  2 17:12:10 2006
*************** add_type_attribute (dw_die_ref object_di
*** 10992,11003 ****
    enum tree_code code  = TREE_CODE (type);
    dw_die_ref type_die  = NULL;
  
!   /* ??? If this type is an unnamed subrange type of an integral or
!      floating-point type, use the inner type.  This is because we have no
!      support for unnamed types in base_type_die.  This can happen if this is
!      an Ada subrange type.  Correct solution is emit a subrange type die.  */
!   if ((code == INTEGER_TYPE || code == REAL_TYPE)
!       && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)
      type = TREE_TYPE (type), code = TREE_CODE (type);
  
    if (code == ERROR_MARK
--- 10992,11002 ----
    enum tree_code code  = TREE_CODE (type);
    dw_die_ref type_die  = NULL;
  
!   /* ??? If this type is an unnamed subrange type of a floating-point type, 
!      use the inner type.  This is because we have no support for unnamed types
!      in base_type_die.  This can happen if this is an Ada subrange type.
!      Correct solution is emit a subrange type die.  */
!   if (code == REAL_TYPE && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)
      type = TREE_TYPE (type), code = TREE_CODE (type);
  
    if (code == ERROR_MARK
*** gcc/config/rs6000/aix.h.ori	Fri Sep 29 16:11:04 2006
--- gcc/config/rs6000/aix.h	Tue Oct  3 16:30:52 2006
***************
*** 33,38 ****
--- 33,43 ----
  /* AIX allows r13 to be used in 32-bit mode.  */
  #define FIXED_R13 0
  
+ 
+ /* 32-bit and 64-bit AIX stack boundary is 128.  */
+ #undef  STACK_BOUNDARY
+ #define STACK_BOUNDARY 128
+ 
  /* AIX does not support Altivec.  */
  #undef  TARGET_ALTIVEC
  #define TARGET_ALTIVEC 0
*** gcc/config/rs6000/xcoff.h.ori	Tue Oct  3 16:18:07 2006
--- gcc/config/rs6000/xcoff.h	Tue Oct  3 16:19:33 2006
***************
*** 65,72 ****
  #define EXTRA_SECTIONS \
     read_only_data, private_data, read_only_private_data, toc, bss
  
! /* Define the routines to implement these extra sections.
!    BIGGEST_ALIGNMENT is 64, so align the sections that much.  */
  
  #define EXTRA_SECTION_FUNCTIONS				\
    READ_ONLY_DATA_SECTION_FUNCTION			\
--- 65,72 ----
  #define EXTRA_SECTIONS \
     read_only_data, private_data, read_only_private_data, toc, bss
  
! /* Define the routines to implement these extra sections, aligned
!    in accordance with BIGGEST_ALIGNMENT's expectations.  */
  
  #define EXTRA_SECTION_FUNCTIONS				\
    READ_ONLY_DATA_SECTION_FUNCTION			\
*************** read_only_data_section (void)				\
*** 80,86 ****
  {							\
    if (in_section != read_only_data)			\
      {							\
!       fprintf (asm_out_file, "\t.csect %s[RO],3\n",	\
  	       xcoff_read_only_section_name);		\
        in_section = read_only_data;			\
      }							\
--- 80,86 ----
  {							\
    if (in_section != read_only_data)			\
      {							\
!       fprintf (asm_out_file, "\t.csect %s[RO],4\n",	\
  	       xcoff_read_only_section_name);		\
        in_section = read_only_data;			\
      }							\
*************** private_data_section (void)				\
*** 92,98 ****
  {							\
    if (in_section != private_data)			\
      {							\
!       fprintf (asm_out_file, "\t.csect %s[RW],3\n",	\
  	       xcoff_private_data_section_name);	\
        in_section = private_data;			\
      }							\
--- 92,98 ----
  {							\
    if (in_section != private_data)			\
      {							\
!       fprintf (asm_out_file, "\t.csect %s[RW],4\n",	\
  	       xcoff_private_data_section_name);	\
        in_section = private_data;			\
      }							\
*************** read_only_private_data_section (void)			
*** 104,110 ****
  {							\
    if (in_section != read_only_private_data)		\
      {							\
!       fprintf (asm_out_file, "\t.csect %s[RO],3\n",	\
  	       xcoff_private_data_section_name);	\
        in_section = read_only_private_data;		\
      }							\
--- 104,110 ----
  {							\
    if (in_section != read_only_private_data)		\
      {							\
!       fprintf (asm_out_file, "\t.csect %s[RO],4\n",	\
  	       xcoff_private_data_section_name);	\
        in_section = read_only_private_data;		\
      }							\
*************** toc_section (void)					\
*** 129,135 ****
  							\
        if (in_section != toc)				\
  	fprintf (asm_out_file, "\t.csect toc_table[RW]%s\n",	\
! 		 (TARGET_32BIT ? "" : ",3"));		\
      }							\
    else							\
      {							\
--- 129,135 ----
  							\
        if (in_section != toc)				\
  	fprintf (asm_out_file, "\t.csect toc_table[RW]%s\n",	\
! 		 (TARGET_32BIT ? "" : ",4"));		\
      }							\
    else							\
      {							\
*************** toc_section (void)					\
*** 360,366 ****
  
  /* Output before writable data.
     Align entire section to BIGGEST_ALIGNMENT.  */
! #define DATA_SECTION_ASM_OP "\t.csect .data[RW],3"
  
  /* Define the name of the section to use for the EH language specific
     data areas (.gcc_except_table on most other systems).  */
--- 360,366 ----
  
  /* Output before writable data.
     Align entire section to BIGGEST_ALIGNMENT.  */
! #define DATA_SECTION_ASM_OP "\t.csect .data[RW],4"
  
  /* Define the name of the section to use for the EH language specific
     data areas (.gcc_except_table on most other systems).  */
*** gcc/except.c.0	2006-10-04 10:34:15.726481592 +0200
--- gcc/except.c	2006-10-04 10:49:28.000000000 +0200
*************** finish_eh_generation (void)
*** 2018,2024 ****
    /* We've totally changed the CFG.  Start over.  */
    find_exception_handler_labels ();
    break_superblocks ();
!   if (USING_SJLJ_EXCEPTIONS)
      commit_edge_insertions ();
    FOR_EACH_BB (bb)
      {
--- 2018,2026 ----
    /* We've totally changed the CFG.  Start over.  */
    find_exception_handler_labels ();
    break_superblocks ();
!   if (USING_SJLJ_EXCEPTIONS
!       /* Kludge for Alpha/Tru64 (see alpha_gp_save_rtx).  */
!       || EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->insns.r)
      commit_edge_insertions ();
    FOR_EACH_BB (bb)
      {
*** gcc/config/alpha/alpha.c.0	2006-10-04 10:36:47.997332904 +0200
--- gcc/config/alpha/alpha.c	2006-10-04 10:49:55.000000000 +0200
*************** alpha_gp_save_rtx (void)
*** 4881,4887 ****
  
        seq = get_insns ();
        end_sequence ();
!       emit_insn_after (seq, entry_of_function ());
  
        cfun->machine->gp_save_rtx = m;
      }
--- 4881,4894 ----
  
        seq = get_insns ();
        end_sequence ();
! 
!       /* We used to simply emit the sequence after entry_of_function.
! 	 However this breaks the CFG if the first instruction in the
! 	 first block is not the NOTE_INSN_BASIC_BLOCK, for example a
! 	 label.  Emit the sequence properly on the edge.  We are only
! 	 invoked from dw2_build_landing_pads and finish_eh_generation
! 	 will call commit_edge_insertions thanks to a kludge.  */
!       insert_insn_on_edge (seq, EDGE_SUCC (ENTRY_BLOCK_PTR, 0));
  
        cfun->machine->gp_save_rtx = m;
      }
*** gcc/mklibgcc.in.orig	Fri Oct  6 11:40:03 2006
--- gcc/mklibgcc.in	Fri Oct  6 11:41:30 2006
***************
*** 46,51 ****
--- 46,52 ----
  # Make needs VPATH to be literal.
  echo 'srcdir = @srcdir@'
  echo 'VPATH = @srcdir@'
+ echo 'SHELL = @SHELL@'
  echo 'EQ = ='
  echo 'objects = $(filter %'$objext',$^)'
  echo
*** gcc/config/rs6000/t-ppccomm.ori	Sat Oct  7 23:38:57 2006
--- gcc/config/rs6000/t-ppccomm	Sat Oct  7 23:39:04 2006
***************
*** 1,6 ****
  # Common support for PowerPC ELF targets (both EABI and SVR4).
  
! LIB2FUNCS_EXTRA = tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c
  
  # This one can't end up in shared libgcc
  LIB2FUNCS_STATIC_EXTRA = eabi.S
--- 1,6 ----
  # Common support for PowerPC ELF targets (both EABI and SVR4).
  
! LIB2FUNCS_EXTRA += tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c
  
  # This one can't end up in shared libgcc
  LIB2FUNCS_STATIC_EXTRA = eabi.S
*** gcc/config/rs6000/t-vxworks.ori	Sat Oct  7 21:54:21 2006
--- gcc/config/rs6000/t-vxworks	Sat Oct  7 22:48:19 2006
*************** MULTILIB_DIRNAMES =
*** 6,11 ****
  MULTILIB_MATCHES = fPIC=fpic
  MULTILIB_EXCEPTIONS = fPIC*
  
! # Restore some variables from t-vxworks clobbered by t-ppccomm.
  EXTRA_MULTILIB_PARTS = 
! LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c
--- 6,16 ----
  MULTILIB_MATCHES = fPIC=fpic
  MULTILIB_EXCEPTIONS = fPIC*
  
! # This is set from the common config/t-vxworks but clobbered by t-ppccomm
! # on this target.
  EXTRA_MULTILIB_PARTS = 
! 
! # Similarily, LIB2FUNCS_EXTRA is set from config/t-vxworks and
! # t-ppccomm *adds* to it, but the common contents are useful to us.
! # In particular the base trampoline_setup bits are expected to be
! # provided there.
*** gcc/config/t-vxworks.ori	Sat Oct  7 14:00:11 2006
--- gcc/config/t-vxworks	Sun Oct  8 11:35:25 2006
*************** TARGET_LIBGCC2_CFLAGS =
*** 11,18 ****
  # Don't build libgcc.a with debug info
  LIBGCC2_DEBUG_CFLAGS =
  
! # Extra libgcc2 module used by gthr-vxworks.h functions
! LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c
  
  # Some runtime modules need these.  Can't set extra_headers in config.gcc
  # because the paths are always made absolute to the cpu config dir.
--- 11,18 ----
  # Don't build libgcc.a with debug info
  LIBGCC2_DEBUG_CFLAGS =
  
! # Extra libgcc2 modules used by gthr-vxworks.h functions
! LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c $(srcdir)/config/vxlib-tls.c
  
  # Some runtime modules need these.  Can't set extra_headers in config.gcc
  # because the paths are always made absolute to the cpu config dir.
*** gcc/config/vxlib.c.ori	Sun Oct  8 10:37:33 2006
--- gcc/config/vxlib.c	Sun Oct  8 15:43:00 2006
*************** __gthread_once (__gthread_once_t *guard,
*** 87,386 ****
    return 0;
  }
  
- /* Thread-local storage.
- 
-    We reserve a field in the TCB to point to a dynamically allocated
-    array which is used to store TLS values.  A TLS key is simply an
-    offset in this array.  The exact location of the TCB field is not
-    known to this code nor to vxlib.c -- all access to it indirects
-    through the routines __gthread_get_tls_data and
-    __gthread_set_tls_data, which are provided by the VxWorks kernel.
- 
-    There is also a global array which records which keys are valid and
-    which have destructors.
- 
-    A task delete hook is installed to execute key destructors.  The
-    routines __gthread_enter_tls_dtor_context and
-    __gthread_leave_tls_dtor_context, which are also provided by the
-    kernel, ensure that it is safe to call free() on memory allocated
-    by the task being deleted.  (This is a no-op on VxWorks 5, but
-    a major undertaking on AE.)
- 
-    The task delete hook is only installed when at least one thread
-    has TLS data.  This is a necessary precaution, to allow this module
-    to be unloaded - a module with a hook can not be removed.
- 
-    Since this interface is used to allocate only a small number of
-    keys, the table size is small and static, which simplifies the
-    code quite a bit.  Revisit this if and when it becomes necessary.  */
- 
- #define MAX_KEYS 4
- 
- /* This is the structure pointed to by the pointer returned
-    by __gthread_get_tls_data.  */
- struct tls_data
- {
-   int *owner;
-   void *values[MAX_KEYS];
-   unsigned int generation[MAX_KEYS];
- };
- 
- /* To make sure we only delete TLS data associated with this object,
-    include a pointer to a local variable in the TLS data object.  */
- static int self_owner;
- 
- /* The number of threads for this module which have active TLS data.
-    This is protected by tls_lock.  */
- static int active_tls_threads;
- 
- /* kernel provided routines */
- extern void *__gthread_get_tls_data (void);
- extern void __gthread_set_tls_data (void *data);
- 
- extern void __gthread_enter_tls_dtor_context (void);
- extern void __gthread_leave_tls_dtor_context (void);
- 
- 
- /* This is a global structure which records all of the active keys.
- 
-    A key is potentially valid (i.e. has been handed out by
-    __gthread_key_create) iff its generation count in this structure is
-    even.  In that case, the matching entry in the dtors array is a
-    routine to be called when a thread terminates with a valid,
-    non-NULL specific value for that key.
- 
-    A key is actually valid in a thread T iff the generation count
-    stored in this structure is equal to the generation count stored in
-    T's specific-value structure.  */
- 
- typedef void (*tls_dtor) (void *);
- 
- struct tls_keys
- {
-   tls_dtor dtor[MAX_KEYS];
-   unsigned int generation[MAX_KEYS];
- };
- 
- #define KEY_VALID_P(key) !(tls_keys.generation[key] & 1)
- 
- /* Note: if MAX_KEYS is increased, this initializer must be updated
-    to match.  All the generation counts begin at 1, which means no
-    key is valid.  */
- static struct tls_keys tls_keys =
- {
-   { 0, 0, 0, 0 },
-   { 1, 1, 1, 1 }
- };
- 
- /* This lock protects the tls_keys structure.  */
- static __gthread_mutex_t tls_lock;
- 
- static __gthread_once_t tls_init_guard = __GTHREAD_ONCE_INIT;
- 
- /* Internal routines.  */
- 
- /* The task TCB has just been deleted.  Call the destructor
-    function for each TLS key that has both a destructor and
-    a non-NULL specific value in this thread.
- 
-    This routine does not need to take tls_lock; the generation
-    count protects us from calling a stale destructor.  It does
-    need to read tls_keys.dtor[key] atomically.  */
- 
- static void
- tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)
- {
-   struct tls_data *data = __gthread_get_tls_data ();
-   __gthread_key_t key;
- 
-   if (data && data->owner == &self_owner)
-     {
-       __gthread_enter_tls_dtor_context ();
-       for (key = 0; key < MAX_KEYS; key++)
- 	{
- 	  if (data->generation[key] == tls_keys.generation[key])
- 	    {
- 	      tls_dtor dtor = tls_keys.dtor[key];
- 
- 	      if (dtor)
- 		dtor (data->values[key]);
- 	    }
- 	}
-       free (data);
- 
-       /* We can't handle an error here, so just leave the thread
- 	 marked as loaded if one occurs.  */
-       if (__gthread_mutex_lock (&tls_lock) != ERROR)
- 	{
- 	  active_tls_threads--;
- 	  if (active_tls_threads == 0)
- 	    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);
- 	  __gthread_mutex_unlock (&tls_lock);
- 	}
- 
-       __gthread_set_tls_data (0);
-       __gthread_leave_tls_dtor_context ();
-     }
- } 
- 
- /* Initialize global data used by the TLS system.  */
- static void
- tls_init (void)
- {
-   __GTHREAD_MUTEX_INIT_FUNCTION (&tls_lock);
- }
- 
- static void tls_destructor (void) __attribute__ ((destructor));
- static void
- tls_destructor (void)
- {
- #ifdef __RTP__
-   /* All threads but this one should have exited by now.  */
-   tls_delete_hook (NULL);
- #else
-   /* Unregister the hook forcibly.  The counter of active threads may
-      be incorrect, because constructors (like the C++ library's) and
-      destructors (like this one) run in the context of the shell rather
-      than in a task spawned from this module.  */
-   taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);
- #endif
- 
-   if (tls_init_guard.done && __gthread_mutex_lock (&tls_lock) != ERROR)
-     semDelete (tls_lock);
- }
- 
- /* External interface */
- 
- /* Store in KEYP a value which can be passed to __gthread_setspecific/
-    __gthread_getspecific to store and retrieve a value which is
-    specific to each calling thread.  If DTOR is not NULL, it will be
-    called when a thread terminates with a non-NULL specific value for
-    this key, with the value as its sole argument.  */
- 
- int
- __gthread_key_create (__gthread_key_t *keyp, tls_dtor dtor)
- {
-   __gthread_key_t key;
- 
-   __gthread_once (&tls_init_guard, tls_init);
- 
-   if (__gthread_mutex_lock (&tls_lock) == ERROR)
-     return errno;
- 
-   for (key = 0; key < MAX_KEYS; key++)
-     if (!KEY_VALID_P (key))
-       goto found_slot;
- 
-   /* no room */
-   __gthread_mutex_unlock (&tls_lock);
-   return EAGAIN;
- 
-  found_slot:
-   tls_keys.generation[key]++;  /* making it even */
-   tls_keys.dtor[key] = dtor;
-   *keyp = key;
-   __gthread_mutex_unlock (&tls_lock);
-   return 0;
- }
- 
- /* Invalidate KEY; it can no longer be used as an argument to
-    setspecific/getspecific.  Note that this does NOT call destructor
-    functions for any live values for this key.  */
- int
- __gthread_key_delete (__gthread_key_t key)
- {
-   if (key >= MAX_KEYS)
-     return EINVAL;
- 
-   __gthread_once (&tls_init_guard, tls_init);
- 
-   if (__gthread_mutex_lock (&tls_lock) == ERROR)
-     return errno;
- 
-   if (!KEY_VALID_P (key))
-     {
-       __gthread_mutex_unlock (&tls_lock);
-       return EINVAL;
-     }
- 
-   tls_keys.generation[key]++;  /* making it odd */
-   tls_keys.dtor[key] = 0;
- 
-   __gthread_mutex_unlock (&tls_lock);
-   return 0;
- }
- 
- /* Retrieve the thread-specific value for KEY.  If it has never been
-    set in this thread, or KEY is invalid, returns NULL.
- 
-    It does not matter if this function races with key_create or
-    key_delete; the worst that can happen is you get a value other than
-    the one that a serialized implementation would have provided.  */
- 
- void *
- __gthread_getspecific (__gthread_key_t key)
- {
-   struct tls_data *data;
- 
-   if (key >= MAX_KEYS)
-     return 0;
- 
-   data = __gthread_get_tls_data ();
- 
-   if (!data)
-     return 0;
- 
-   if (data->generation[key] != tls_keys.generation[key])
-     return 0;
- 
-   return data->values[key];
- }
- 
- /* Set the thread-specific value for KEY.  If KEY is invalid, or
-    memory allocation fails, returns -1, otherwise 0.
- 
-    The generation count protects this function against races with
-    key_create/key_delete; the worst thing that can happen is that a
-    value is successfully stored into a dead generation (and then
-    immediately becomes invalid).  However, we do have to make sure
-    to read tls_keys.generation[key] atomically.  */
- 
- int
- __gthread_setspecific (__gthread_key_t key, void *value)
- {
-   struct tls_data *data;
-   unsigned int generation;
- 
-   if (key >= MAX_KEYS)
-     return EINVAL;
- 
-   data = __gthread_get_tls_data ();
-   if (!data)
-     {
-       if (__gthread_mutex_lock (&tls_lock) == ERROR)
- 	return ENOMEM;
-       if (active_tls_threads == 0)
- 	taskDeleteHookAdd ((FUNCPTR)tls_delete_hook);
-       active_tls_threads++;
-       __gthread_mutex_unlock (&tls_lock);
- 
-       data = malloc (sizeof (struct tls_data));
-       if (!data)
- 	return ENOMEM;
- 
-       memset (data, 0, sizeof (struct tls_data));
-       data->owner = &self_owner;
-       __gthread_set_tls_data (data);
-     }
- 
-   generation = tls_keys.generation[key];
- 
-   if (generation & 1)
-     return EINVAL;
- 
-   data->generation[key] = generation;
-   data->values[key] = value;
- 
-   return 0;
- }
  #endif /* __GTHREADS */
--- 87,90 ----
*** gcc/config/vxlib-tls.c.ori	Sun Oct  8 10:38:12 2006
--- gcc/config/vxlib-tls.c	Sun Oct  8 11:20:33 2006
***************
*** 0 ****
--- 1,351 ----
+ /* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+    Contributed by Zack Weinberg <zack@codesourcery.com>
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 2, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to the Free
+ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301, USA.  */
+ 
+ /* As a special exception, if you link this library with other files,
+    some of which are compiled with GCC, to produce an executable,
+    this library does not by itself cause the resulting executable
+    to be covered by the GNU General Public License.
+    This exception does not however invalidate any other reasons why
+    the executable file might be covered by the GNU General Public License.  */
+ 
+ /* Threads compatibility routines for libgcc2 for VxWorks.
+    These are out-of-line routines called from gthr-vxworks.h. 
+ 
+    This file provides the TLS related support routines, calling specific
+    VxWorks kernel entry points for this purpose.  The base VxWorks 5.x kernels
+    don't feature these entry points, and we provide gthr_supp_vxw_5x.c as an
+    option to fill this gap.  Asking users to rebuild a kernel is not to be
+    taken lightly, still, so we have isolated these routines from the rest of
+    vxlib to ensure that the kernel dependencies are only dragged when really
+    necessary.  */
+ 
+ #include "tconfig.h"
+ #include "tsystem.h"
+ #include "gthr.h"
+ 
+ #if defined(__GTHREADS)
+ #include <vxWorks.h>
+ #ifndef __RTP__
+ #include <vxLib.h>
+ #endif
+ #include <taskLib.h>
+ #ifndef __RTP__
+ #include <taskHookLib.h>
+ #else
+ # include <errno.h>
+ #endif
+ 
+ /* Thread-local storage.
+ 
+    We reserve a field in the TCB to point to a dynamically allocated
+    array which is used to store TLS values.  A TLS key is simply an
+    offset in this array.  The exact location of the TCB field is not
+    known to this code nor to vxlib.c -- all access to it indirects
+    through the routines __gthread_get_tls_data and
+    __gthread_set_tls_data, which are provided by the VxWorks kernel.
+ 
+    There is also a global array which records which keys are valid and
+    which have destructors.
+ 
+    A task delete hook is installed to execute key destructors.  The
+    routines __gthread_enter_tls_dtor_context and
+    __gthread_leave_tls_dtor_context, which are also provided by the
+    kernel, ensure that it is safe to call free() on memory allocated
+    by the task being deleted.  (This is a no-op on VxWorks 5, but
+    a major undertaking on AE.)
+ 
+    The task delete hook is only installed when at least one thread
+    has TLS data.  This is a necessary precaution, to allow this module
+    to be unloaded - a module with a hook can not be removed.
+ 
+    Since this interface is used to allocate only a small number of
+    keys, the table size is small and static, which simplifies the
+    code quite a bit.  Revisit this if and when it becomes necessary.  */
+ 
+ #define MAX_KEYS 4
+ 
+ /* This is the structure pointed to by the pointer returned
+    by __gthread_get_tls_data.  */
+ struct tls_data
+ {
+   int *owner;
+   void *values[MAX_KEYS];
+   unsigned int generation[MAX_KEYS];
+ };
+ 
+ /* To make sure we only delete TLS data associated with this object,
+    include a pointer to a local variable in the TLS data object.  */
+ static int self_owner;
+ 
+ /* The number of threads for this module which have active TLS data.
+    This is protected by tls_lock.  */
+ static int active_tls_threads;
+ 
+ /* kernel provided routines */
+ extern void *__gthread_get_tls_data (void);
+ extern void __gthread_set_tls_data (void *data);
+ 
+ extern void __gthread_enter_tls_dtor_context (void);
+ extern void __gthread_leave_tls_dtor_context (void);
+ 
+ 
+ /* This is a global structure which records all of the active keys.
+ 
+    A key is potentially valid (i.e. has been handed out by
+    __gthread_key_create) iff its generation count in this structure is
+    even.  In that case, the matching entry in the dtors array is a
+    routine to be called when a thread terminates with a valid,
+    non-NULL specific value for that key.
+ 
+    A key is actually valid in a thread T iff the generation count
+    stored in this structure is equal to the generation count stored in
+    T's specific-value structure.  */
+ 
+ typedef void (*tls_dtor) (void *);
+ 
+ struct tls_keys
+ {
+   tls_dtor dtor[MAX_KEYS];
+   unsigned int generation[MAX_KEYS];
+ };
+ 
+ #define KEY_VALID_P(key) !(tls_keys.generation[key] & 1)
+ 
+ /* Note: if MAX_KEYS is increased, this initializer must be updated
+    to match.  All the generation counts begin at 1, which means no
+    key is valid.  */
+ static struct tls_keys tls_keys =
+ {
+   { 0, 0, 0, 0 },
+   { 1, 1, 1, 1 }
+ };
+ 
+ /* This lock protects the tls_keys structure.  */
+ static __gthread_mutex_t tls_lock;
+ 
+ static __gthread_once_t tls_init_guard = __GTHREAD_ONCE_INIT;
+ 
+ /* Internal routines.  */
+ 
+ /* The task TCB has just been deleted.  Call the destructor
+    function for each TLS key that has both a destructor and
+    a non-NULL specific value in this thread.
+ 
+    This routine does not need to take tls_lock; the generation
+    count protects us from calling a stale destructor.  It does
+    need to read tls_keys.dtor[key] atomically.  */
+ 
+ static void
+ tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)
+ {
+   struct tls_data *data = __gthread_get_tls_data ();
+   __gthread_key_t key;
+ 
+   if (data && data->owner == &self_owner)
+     {
+       __gthread_enter_tls_dtor_context ();
+       for (key = 0; key < MAX_KEYS; key++)
+ 	{
+ 	  if (data->generation[key] == tls_keys.generation[key])
+ 	    {
+ 	      tls_dtor dtor = tls_keys.dtor[key];
+ 
+ 	      if (dtor)
+ 		dtor (data->values[key]);
+ 	    }
+ 	}
+       free (data);
+ 
+       /* We can't handle an error here, so just leave the thread
+ 	 marked as loaded if one occurs.  */
+       if (__gthread_mutex_lock (&tls_lock) != ERROR)
+ 	{
+ 	  active_tls_threads--;
+ 	  if (active_tls_threads == 0)
+ 	    taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);
+ 	  __gthread_mutex_unlock (&tls_lock);
+ 	}
+ 
+       __gthread_set_tls_data (0);
+       __gthread_leave_tls_dtor_context ();
+     }
+ } 
+ 
+ /* Initialize global data used by the TLS system.  */
+ static void
+ tls_init (void)
+ {
+   __GTHREAD_MUTEX_INIT_FUNCTION (&tls_lock);
+ }
+ 
+ static void tls_destructor (void) __attribute__ ((destructor));
+ static void
+ tls_destructor (void)
+ {
+ #ifdef __RTP__
+   /* All threads but this one should have exited by now.  */
+   tls_delete_hook (NULL);
+ #else
+   /* Unregister the hook forcibly.  The counter of active threads may
+      be incorrect, because constructors (like the C++ library's) and
+      destructors (like this one) run in the context of the shell rather
+      than in a task spawned from this module.  */
+   taskDeleteHookDelete ((FUNCPTR)tls_delete_hook);
+ #endif
+ 
+   if (tls_init_guard.done && __gthread_mutex_lock (&tls_lock) != ERROR)
+     semDelete (tls_lock);
+ }
+ 
+ /* External interface */
+ 
+ /* Store in KEYP a value which can be passed to __gthread_setspecific/
+    __gthread_getspecific to store and retrieve a value which is
+    specific to each calling thread.  If DTOR is not NULL, it will be
+    called when a thread terminates with a non-NULL specific value for
+    this key, with the value as its sole argument.  */
+ 
+ int
+ __gthread_key_create (__gthread_key_t *keyp, tls_dtor dtor)
+ {
+   __gthread_key_t key;
+ 
+   __gthread_once (&tls_init_guard, tls_init);
+ 
+   if (__gthread_mutex_lock (&tls_lock) == ERROR)
+     return errno;
+ 
+   for (key = 0; key < MAX_KEYS; key++)
+     if (!KEY_VALID_P (key))
+       goto found_slot;
+ 
+   /* no room */
+   __gthread_mutex_unlock (&tls_lock);
+   return EAGAIN;
+ 
+  found_slot:
+   tls_keys.generation[key]++;  /* making it even */
+   tls_keys.dtor[key] = dtor;
+   *keyp = key;
+   __gthread_mutex_unlock (&tls_lock);
+   return 0;
+ }
+ 
+ /* Invalidate KEY; it can no longer be used as an argument to
+    setspecific/getspecific.  Note that this does NOT call destructor
+    functions for any live values for this key.  */
+ int
+ __gthread_key_delete (__gthread_key_t key)
+ {
+   if (key >= MAX_KEYS)
+     return EINVAL;
+ 
+   __gthread_once (&tls_init_guard, tls_init);
+ 
+   if (__gthread_mutex_lock (&tls_lock) == ERROR)
+     return errno;
+ 
+   if (!KEY_VALID_P (key))
+     {
+       __gthread_mutex_unlock (&tls_lock);
+       return EINVAL;
+     }
+ 
+   tls_keys.generation[key]++;  /* making it odd */
+   tls_keys.dtor[key] = 0;
+ 
+   __gthread_mutex_unlock (&tls_lock);
+   return 0;
+ }
+ 
+ /* Retrieve the thread-specific value for KEY.  If it has never been
+    set in this thread, or KEY is invalid, returns NULL.
+ 
+    It does not matter if this function races with key_create or
+    key_delete; the worst that can happen is you get a value other than
+    the one that a serialized implementation would have provided.  */
+ 
+ void *
+ __gthread_getspecific (__gthread_key_t key)
+ {
+   struct tls_data *data;
+ 
+   if (key >= MAX_KEYS)
+     return 0;
+ 
+   data = __gthread_get_tls_data ();
+ 
+   if (!data)
+     return 0;
+ 
+   if (data->generation[key] != tls_keys.generation[key])
+     return 0;
+ 
+   return data->values[key];
+ }
+ 
+ /* Set the thread-specific value for KEY.  If KEY is invalid, or
+    memory allocation fails, returns -1, otherwise 0.
+ 
+    The generation count protects this function against races with
+    key_create/key_delete; the worst thing that can happen is that a
+    value is successfully stored into a dead generation (and then
+    immediately becomes invalid).  However, we do have to make sure
+    to read tls_keys.generation[key] atomically.  */
+ 
+ int
+ __gthread_setspecific (__gthread_key_t key, void *value)
+ {
+   struct tls_data *data;
+   unsigned int generation;
+ 
+   if (key >= MAX_KEYS)
+     return EINVAL;
+ 
+   data = __gthread_get_tls_data ();
+   if (!data)
+     {
+       if (__gthread_mutex_lock (&tls_lock) == ERROR)
+ 	return ENOMEM;
+       if (active_tls_threads == 0)
+ 	taskDeleteHookAdd ((FUNCPTR)tls_delete_hook);
+       active_tls_threads++;
+       __gthread_mutex_unlock (&tls_lock);
+ 
+       data = malloc (sizeof (struct tls_data));
+       if (!data)
+ 	return ENOMEM;
+ 
+       memset (data, 0, sizeof (struct tls_data));
+       data->owner = &self_owner;
+       __gthread_set_tls_data (data);
+     }
+ 
+   generation = tls_keys.generation[key];
+ 
+   if (generation & 1)
+     return EINVAL;
+ 
+   data->generation[key] = generation;
+   data->values[key] = value;
+ 
+   return 0;
+ }
+ #endif /* __GTHREADS */
*** gcc/expr.c.0	2006-10-09 12:02:03.000000000 +0200
--- gcc/expr.c	2006-10-09 12:53:25.000000000 +0200
*************** expand_expr_real_1 (tree exp, rtx target
*** 7436,7444 ****
  	       necessarily be constant.  */
  	    if (mode == BLKmode)
  	      {
! 		rtx new
! 		  = assign_stack_temp_for_type
! 		    (ext_mode, GET_MODE_BITSIZE (ext_mode), 0, type);
  
  		emit_move_insn (new, op0);
  		op0 = copy_rtx (new);
--- 7436,7453 ----
  	       necessarily be constant.  */
  	    if (mode == BLKmode)
  	      {
! 		HOST_WIDE_INT size = GET_MODE_BITSIZE (ext_mode);
! 		rtx new;
! 
! 		/* If the reference doesn't use the alias set of its type,
! 		   we cannot create the temporary using that type.  */
! 		if (component_uses_parent_alias_set (exp))
! 		  {
! 		    new = assign_stack_local (ext_mode, size, 0);
! 		    set_mem_alias_set (new, get_alias_set (exp));
! 		  }
! 		else
! 		  new = assign_stack_temp_for_type (ext_mode, size, 0, type);
  
  		emit_move_insn (new, op0);
  		op0 = copy_rtx (new);
*** gcc/c-decl.c.0	2006-09-04 18:27:08.000000000 +0200
--- gcc/c-decl.c	2006-10-10 22:24:26.987985480 +0200
*************** grokdeclarator (const struct c_declarato
*** 4428,4433 ****
--- 4428,4467 ----
  	      type = c_build_qualified_type (type, type_quals);
  	    size_varies = 0;
  
+ 	    /* When the pointed-to type involves components of variable size,
+ 	       care must be taken to ensure that the size evaluation code is
+ 	       emitted early enough to dominate all the possible later uses
+ 	       and late enough for the variables on which it depends to have
+ 	       been assigned.
+ 
+ 	       This is expected to happen automatically when the pointed-to
+ 	       type has a name/declaration of it's own, but special attention
+ 	       is required if the type is anonymous.
+ 
+ 	       We handle the NORMAL and FIELD contexts here by attaching an
+ 	       artificial TYPE_DECL to such pointed-to type.  This forces the
+ 	       sizes evaluation at a safe point and ensures it is not deferred
+ 	       until e.g. within a deeper conditional context.
+ 
+ 	       We expect nothing to be needed here for PARM or TYPENAME.
+ 	       Pushing a TYPE_DECL at this point for TYPENAME would actually
+ 	       be incorrect, as we might be in the middle of an expression
+ 	       with side effects on the pointed-to type size "arguments" prior
+ 	       to the pointer declaration point and the fake TYPE_DECL in the
+ 	       enclosing context would force the size evaluation prior to the
+ 	       side effects.  */
+ 
+ 	    if (!TYPE_NAME (type)
+ 		&& (decl_context == NORMAL || decl_context == FIELD)
+ 		&& variably_modified_type_p (type, NULL_TREE))
+ 	      {
+ 		tree decl = build_decl (TYPE_DECL, NULL_TREE, type);
+ 		DECL_ARTIFICIAL (decl) = 1;
+ 		pushdecl (decl);
+ 		finish_decl (decl, NULL_TREE, NULL_TREE);
+ 		TYPE_NAME (type) = decl;
+ 	      }
+ 
  	    type = build_pointer_type (type);
  	    
  	    /* Process type qualifiers (such as const or volatile)
*** Makefile.def.ori	Fri Oct 13 16:46:57 2006
--- Makefile.def	Fri Oct 13 16:48:18 2006
*************** flags_to_pass = { flag= YACC ; };
*** 205,210 ****
--- 205,212 ----
  
  // Host tools
  flags_to_pass = { flag= AR_FLAGS ; };
+ flags_to_pass = { flag= BOOT_CFLAGS ; };
+ flags_to_pass = { flag= BOOT_LDFLAGS ; };
  flags_to_pass = { flag= CFLAGS ; };
  flags_to_pass = { flag= CXXFLAGS ; };
  flags_to_pass = { flag= LDFLAGS ; };
*** Makefile.in.ori	Fri Oct 13 16:46:57 2006
--- Makefile.in	Fri Oct 13 16:48:18 2006
*************** BUILD_PREFIX_1 = @BUILD_PREFIX_1@
*** 252,257 ****
--- 252,258 ----
  # Flags to pass to stage2 and later makes.  They are defined
  # here so that they can be overridden by Makefile fragments.
  BOOT_CFLAGS= -g -O2
+ BOOT_LDFLAGS=
  
  BISON = @BISON@
  YACC = @YACC@
*************** BASE_FLAGS_TO_PASS = \
*** 432,437 ****
--- 433,440 ----
  	"SHELL=$(SHELL)" \
  	"YACC=$(YACC)" \
  	"AR_FLAGS=$(AR_FLAGS)" \
+ 	"BOOT_CFLAGS=$(BOOT_CFLAGS)" \
+ 	"BOOT_LDFLAGS=$(BOOT_LDFLAGS)" \
  	"CFLAGS=$(CFLAGS)" \
  	"CXXFLAGS=$(CXXFLAGS)" \
  	"LDFLAGS=$(LDFLAGS)" \
*************** stage = :
*** 34869,34875 ****
  
  @if gcc-bootstrap
  unstage = [ -f stage_current ] || $(MAKE) `cat stage_last`-start
! stage = [ -f stage_current ] && $(MAKE) `cat stage_current`-end || :
  @endif gcc-bootstrap
  
  .PHONY: unstage stage
--- 34872,34878 ----
  
  @if gcc-bootstrap
  unstage = [ -f stage_current ] || $(MAKE) `cat stage_last`-start
! stage = if [ -f stage_current ]; then $(MAKE) `cat stage_current`-end || exit 1; else :; fi
  @endif gcc-bootstrap
  
  .PHONY: unstage stage
*************** POSTSTAGE1_FLAGS_TO_PASS = \
*** 34909,34914 ****
--- 34912,34918 ----
  	CC="$${CC}" CC_FOR_BUILD="$${CC_FOR_BUILD}" \
  	STAGE_PREFIX=$$r/prev-gcc/ \
  	CFLAGS="$(BOOT_CFLAGS)" \
+ 	LDFLAGS="$(BOOT_LDFLAGS)" \
  	ADAC="\$$(CC)"
  
  # For stage 1:
*************** stage3-bubble:: stage2-bubble
*** 35430,35436 ****
  	  $(MAKE) stage3-start; \
  	  $(MAKE) $(RECURSE_FLAGS_TO_PASS) all-stage3; \
  	fi
! 	$(MAKE) compare
  
  .PHONY: all-stage3 clean-stage3
  do-clean: clean-stage3
--- 35434,35440 ----
  	  $(MAKE) stage3-start; \
  	  $(MAKE) $(RECURSE_FLAGS_TO_PASS) all-stage3; \
  	fi
! 	$(MAKE) $(RECURSE_FLAGS_TO_PASS) compare
  
  .PHONY: all-stage3 clean-stage3
  do-clean: clean-stage3
*************** stage4-bubble:: stage3-bubble
*** 35667,35673 ****
  	  $(MAKE) stage4-start; \
  	  $(MAKE) $(RECURSE_FLAGS_TO_PASS) all-stage4; \
  	fi
! 	$(MAKE) compare3
  
  .PHONY: all-stage4 clean-stage4
  do-clean: clean-stage4
--- 35671,35677 ----
  	  $(MAKE) stage4-start; \
  	  $(MAKE) $(RECURSE_FLAGS_TO_PASS) all-stage4; \
  	fi
! 	$(MAKE) $(RECURSE_FLAGS_TO_PASS) compare3
  
  .PHONY: all-stage4 clean-stage4
  do-clean: clean-stage4
*** Makefile.tpl.ori	Fri Oct 13 16:46:57 2006
--- Makefile.tpl	Fri Oct 13 16:48:18 2006
*************** BUILD_PREFIX_1 = @BUILD_PREFIX_1@
*** 255,260 ****
--- 255,261 ----
  # Flags to pass to stage2 and later makes.  They are defined
  # here so that they can be overridden by Makefile fragments.
  BOOT_CFLAGS= -g -O2
+ BOOT_LDFLAGS=
  
  BISON = @BISON@
  YACC = @YACC@
*************** stage = :
*** 1194,1200 ****
  
  @if gcc-bootstrap
  unstage = [ -f stage_current ] || $(MAKE) `cat stage_last`-start
! stage = [ -f stage_current ] && $(MAKE) `cat stage_current`-end || :
  @endif gcc-bootstrap
  
  .PHONY: unstage stage
--- 1195,1201 ----
  
  @if gcc-bootstrap
  unstage = [ -f stage_current ] || $(MAKE) `cat stage_last`-start
! stage = if [ -f stage_current ]; then $(MAKE) `cat stage_current`-end || exit 1; else :; fi
  @endif gcc-bootstrap
  
  .PHONY: unstage stage
*************** POSTSTAGE1_FLAGS_TO_PASS = \
*** 1234,1239 ****
--- 1235,1241 ----
  	CC="$${CC}" CC_FOR_BUILD="$${CC_FOR_BUILD}" \
  	STAGE_PREFIX=$$r/prev-gcc/ \
  	CFLAGS="$(BOOT_CFLAGS)" \
+ 	LDFLAGS="$(BOOT_LDFLAGS)" \
  	ADAC="\$$(CC)"
  
  # For stage 1:
*************** stage[+id+]-bubble:: [+ IF prev +]stage[
*** 1303,1309 ****
  	  $(MAKE) stage[+id+]-start; \
  	  $(MAKE) $(RECURSE_FLAGS_TO_PASS) all-stage[+id+]; \
  	fi[+ IF compare-target +]
! 	$(MAKE) [+compare-target+][+ ENDIF compare-target +]
  
  .PHONY: all-stage[+id+] clean-stage[+id+]
  do-clean: clean-stage[+id+]
--- 1305,1311 ----
  	  $(MAKE) stage[+id+]-start; \
  	  $(MAKE) $(RECURSE_FLAGS_TO_PASS) all-stage[+id+]; \
  	fi[+ IF compare-target +]
! 	$(MAKE) $(RECURSE_FLAGS_TO_PASS) [+compare-target+][+ ENDIF compare-target +]
  
  .PHONY: all-stage[+id+] clean-stage[+id+]
  do-clean: clean-stage[+id+]
*** gcc/config/rs6000/t-vxworks.ori	Wed Oct 18 16:38:22 2006
--- gcc/config/rs6000/t-vxworks	Wed Oct 18 18:47:06 2006
*************** EXTRA_MULTILIB_PARTS = 
*** 14,16 ****
--- 14,22 ----
  # t-ppccomm *adds* to it, but the common contents are useful to us.
  # In particular the base trampoline_setup bits are expected to be
  # provided there.
+ 
+ # Parts of libgcc reference VxWorks kernel entry points and might be included
+ # in modules loaded very far away from the kernel text.  Force longcalls to
+ # ensure we don't hit problems with relocation requests too large to fit in
+ # short calls.
+ TARGET_LIBGCC2_CFLAGS += -mlongcall
*** gcc/config/rs6000/tramp.asm.ori	Wed Oct 18 17:03:26 2006
--- gcc/config/rs6000/tramp.asm	Sat Oct  7 11:59:26 2006
*************** FUNC_START(__trampoline_setup)
*** 111,117 ****
  	addis	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@ha
  	addi	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@l
  #endif
! 	bl	JUMP_TARGET(abort)
  FUNC_END(__trampoline_setup)
  
  #endif
--- 111,129 ----
  	addis	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@ha
  	addi	r30,r30,_GLOBAL_OFFSET_TABLE_-1b@l
  #endif
! /* Use a longcall sequence in the simple non PIC case.  This allows the
!    non-pic code to be mlongcall compliant, which is useful on e.g. VxWorks
!    targets because this can be part of a module loaded very far away from
!    the 'abort' entry point.  The PIC+longcall case would be much harder to
!    handle, and there is no real need as of today.  */
! #if defined __PIC__ || defined __pic__
! 	bl JUMP_TARGET(abort)
! #else
! 	addis 11, 0,JUMP_TARGET(abort)@ha
! 	addi  12,11,JUMP_TARGET(abort)@l
! 	mtlr  12
! 	blrl
! #endif
  FUNC_END(__trampoline_setup)
  
  #endif
*** gcc/cgraphunit.c.0	2009-03-10 10:06:14.000000000 +0100
--- gcc/cgraphunit.c	2009-03-10 10:06:18.000000000 +0100
*************** cgraph_finalize_compilation_unit (void)
*** 971,976 ****
--- 971,977 ----
    if (errorcount || sorrycount)
      return;
  
+   finalize_size_functions ();
    finish_aliases_1 ();
  
    if (!flag_unit_at_a_time)
*** gcc/stor-layout.c.0	2009-03-10 10:06:14.000000000 +0100
--- gcc/stor-layout.c	2009-03-10 10:06:22.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 37,42 ****
--- 37,45 ----
  #include "langhooks.h"
  #include "regs.h"
  #include "params.h"
+ #include "cgraph.h"
+ #include "tree-inline.h"
+ #include "tree-dump.h"
  
  /* Data type for the expressions representing sizes of data types.
     It is the first integer type laid out.  */
*************** unsigned int initial_max_fld_align = TAR
*** 53,58 ****
--- 56,62 ----
     called only by a front end.  */
  static int reference_types_internal = 0;
  
+ static tree self_referential_size (tree);
  static void finalize_record_size (record_layout_info);
  static void finalize_type_size (tree);
  static void place_union_field (record_layout_info, tree);
*************** variable_size (tree size)
*** 117,129 ****
  {
    tree save;
  
    /* If the language-processor is to take responsibility for variable-sized
       items (e.g., languages which have elaboration procedures like Ada),
!      just return SIZE unchanged.  Likewise for self-referential sizes and
!      constant sizes.  */
!   if (TREE_CONSTANT (size)
!       || lang_hooks.decls.global_bindings_p () < 0
!       || CONTAINS_PLACEHOLDER_P (size))
      return size;
  
    size = save_expr (size);
--- 121,139 ----
  {
    tree save;
  
+   /* Obviously.  */
+   if (TREE_CONSTANT (size))
+     return size;
+ 
+   /* If the size is self-referential, we can't make a SAVE_EXPR (see
+      save_expr for the rationale).  But we can do something else.  */
+   if (CONTAINS_PLACEHOLDER_P (size))
+     return self_referential_size (size);
+ 
    /* If the language-processor is to take responsibility for variable-sized
       items (e.g., languages which have elaboration procedures like Ada),
!      just return SIZE unchanged.  */
!   if (lang_hooks.decls.global_bindings_p () < 0)
      return size;
  
    size = save_expr (size);
*************** variable_size (tree size)
*** 157,162 ****
--- 167,377 ----
  
    return size;
  }
+ 
+ /* An array of functions used for self-referential size computation.  */
+ static GTY(()) VEC (tree, gc) *size_functions;
+ 
+ /* Similar to copy_tree_r but do not copy component references involving
+    PLACEHOLDER_EXPRs.  These nodes are spotted in find_substitute_in_expr
+    and substituted in substitute_in_expr.  */
+ 
+ static tree
+ copy_self_referential_tree_r (tree *tp, int *walk_subtrees, void *data)
+ {
+   enum tree_code code = TREE_CODE (*tp);
+ 
+   /* Stop at types, decls, constants like copy_tree_r.  */
+   if (TREE_CODE_CLASS (code) == tcc_type
+       || TREE_CODE_CLASS (code) == tcc_declaration
+       || TREE_CODE_CLASS (code) == tcc_constant)
+     {
+       *walk_subtrees = 0;
+       return NULL_TREE;
+     }
+ 
+   /* This is the pattern built in ada/make_aligning_type.  */
+   else if (code == ADDR_EXPR
+ 	   && TREE_CODE (TREE_OPERAND (*tp, 0)) == PLACEHOLDER_EXPR)
+     {
+       *walk_subtrees = 0;
+       return NULL_TREE;
+     }
+ 
+   /* Default case: the component reference.  */
+   else if (code == COMPONENT_REF)
+     {
+       tree inner;
+       for (inner = TREE_OPERAND (*tp, 0);
+ 	   REFERENCE_CLASS_P (inner);
+ 	   inner = TREE_OPERAND (inner, 0))
+ 	;
+ 
+       if (TREE_CODE (inner) == PLACEHOLDER_EXPR)
+ 	{
+ 	  *walk_subtrees = 0;
+ 	  return NULL_TREE;
+ 	}
+     }
+ 
+   /* We're not supposed to have them in self-referential size trees
+      because we wouldn't properly control when they are evaluated.
+      However, not creating superfluous SAVE_EXPRs requires accurate
+      tracking of readonly-ness all the way down to here, which we
+      cannot always guarantee in practice.  So punt in this case.  */
+   else if (code == SAVE_EXPR)
+     return error_mark_node;
+ 
+   return copy_tree_r (tp, walk_subtrees, data);
+ }
+ 
+ /* Given a SIZE expression that is self-referential, return an equivalent
+    expression to serve as the actual size expression for a type.  */
+ 
+ static tree
+ self_referential_size (tree size)
+ {
+   static unsigned HOST_WIDE_INT fnno = 0;
+   VEC (tree, heap) *self_refs = NULL;
+   tree param_type_list = NULL, param_decl_list = NULL, arg_list = NULL;
+   tree t, ref, return_type, fntype, fnname, fndecl;
+   unsigned int i;
+   char buf[128];
+ 
+   /* Do not factor out simple operations.  */
+   t = skip_simple_arithmetic (size);
+   if (TREE_CODE (t) == CALL_EXPR)
+     return size;
+ 
+   /* Collect the list of self-references in the expression.  */
+   find_substitute_in_expr (size, &self_refs);
+   gcc_assert (VEC_length (tree, self_refs) > 0);
+ 
+   /* Obtain a private copy of the expression.  */
+   t = size;
+   if (walk_tree (&t, copy_self_referential_tree_r, NULL, NULL))
+     return size;
+   size = t;
+ 
+   /* Build the parameter and argument lists in parallel; also
+      substitute the former for the latter in the expression.  */
+   for (i = 0; VEC_iterate (tree, self_refs, i, ref); i++)
+     {
+       tree subst, param_name, param_type, param_decl;
+ 
+       if (DECL_P (ref))
+ 	{
+ 	  /* We shouldn't have true variables here.  */
+ 	  gcc_assert (TREE_READONLY (ref));
+ 	  subst = ref;
+ 	}
+       /* This is the pattern built in ada/make_aligning_type.  */
+       else if (TREE_CODE (ref) == ADDR_EXPR)
+         subst = ref;
+       /* Default case: the component reference.  */
+       else
+ 	subst = TREE_OPERAND (ref, 1);
+ 
+       sprintf (buf, "p%d", i);
+       param_name = get_identifier (buf);
+       param_type = TREE_TYPE (ref);
+       param_decl = build_decl (PARM_DECL, param_name, param_type);
+       if (targetm.calls.promote_prototypes (NULL_TREE)
+ 	  && INTEGRAL_TYPE_P (param_type)
+ 	  && TYPE_PRECISION (param_type) < TYPE_PRECISION (integer_type_node))
+ 	DECL_ARG_TYPE (param_decl) = integer_type_node;
+       else
+ 	DECL_ARG_TYPE (param_decl) = param_type;
+       DECL_ARTIFICIAL (param_decl) = 1;
+       TREE_READONLY (param_decl) = 1;
+ 
+       size = substitute_in_expr (size, subst, param_decl);
+ 
+       param_type_list = tree_cons (NULL_TREE, param_type, param_type_list);
+       param_decl_list = chainon (param_decl, param_decl_list);
+       arg_list = tree_cons (NULL_TREE, ref, arg_list);
+     }
+ 
+   VEC_free (tree, heap, self_refs);
+ 
+   /* Append 'void' to indicate that the number of parameters is fixed.  */
+   param_type_list = tree_cons (NULL_TREE, void_type_node, param_type_list);
+ 
+   /* The 3 lists have been created in reverse order.  */
+   param_type_list = nreverse (param_type_list);
+   param_decl_list = nreverse (param_decl_list);
+   arg_list = nreverse (arg_list);
+ 
+   /* Build the function type.  */
+   return_type = TREE_TYPE (size);
+   fntype = build_function_type (return_type, param_type_list);
+ 
+   /* Build the function declaration.  */
+   sprintf (buf, "SZ"HOST_WIDE_INT_PRINT_UNSIGNED, fnno++);
+   fnname = get_file_function_name_long (buf);
+   fndecl = build_decl (FUNCTION_DECL, fnname, fntype);
+   for (t = param_decl_list; t; t = TREE_CHAIN (t))
+     DECL_CONTEXT (t) = fndecl;
+   DECL_ARGUMENTS (fndecl) = param_decl_list;
+   DECL_RESULT (fndecl) = build_decl (RESULT_DECL, 0, return_type);
+   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;
+ 
+   /* The function has been created by the compiler and we don't
+      want to emit debug info for it.  */
+   DECL_ARTIFICIAL (fndecl) = 1;
+   DECL_IGNORED_P (fndecl) = 1;
+ 
+   /* It is supposed to be "const" and never throw.  */
+   TREE_READONLY (fndecl) = 1;
+   TREE_NOTHROW (fndecl) = 1;
+ 
+   /* We want it to be inlined when this is deemed profitable, as
+      well as discarded if every call has been integrated.  */
+   DECL_INLINE (fndecl) = 1;
+   DECL_DECLARED_INLINE_P (fndecl) = 1;
+ 
+   /* It is made up of a unique return statement.  */
+   DECL_INITIAL (fndecl) = make_node (BLOCK);
+   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;
+   t = build2 (MODIFY_EXPR, return_type, DECL_RESULT (fndecl), size);
+   DECL_SAVED_TREE (fndecl) = build1 (RETURN_EXPR, void_type_node, t);
+   TREE_STATIC (fndecl) = 1;
+ 
+   /* Put it onto the list of size functions.  */
+   VEC_safe_push (tree, gc, size_functions, fndecl);
+ 
+   /* Replace the original expression with a call to the size function.  */
+   size = build3 (CALL_EXPR,
+ 		 return_type,
+ 		 build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl),
+ 		 arg_list,
+ 		 NULL_TREE);
+ 
+   return size;
+ }
+ 
+ /* Take, queue and compile all the size functions.  It is essential that
+    the size functions be gimplified at the very end of the compilation
+    in order to guarantee transparent handling of self-referential sizes.
+    Otherwise the GENERIC inliner would not be able to inline them back
+    at each of their call sites, thus creating artificial non-constant
+    size expressions which would trigger nasty problems later on.  */
+ 
+ void
+ finalize_size_functions (void)
+ {
+   unsigned int i;
+   tree fndecl;
+ 
+   for (i = 0; VEC_iterate(tree, size_functions, i, fndecl); i++)
+     {
+       dump_function (TDI_original, fndecl);
+       gimplify_function_tree (fndecl);
+       dump_function (TDI_generic, fndecl);
+       cgraph_finalize_function (fndecl, false);
+     }
+ 
+   VEC_free (tree, gc, size_functions);
+ }
  
  #ifndef MAX_FIXED_MODE_SIZE
  #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)
*** gcc/tree.c.0	2009-03-10 10:06:14.000000000 +0100
--- gcc/tree.c	2009-03-10 10:06:18.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 45,50 ****
--- 45,51 ----
  #include "output.h"
  #include "target.h"
  #include "langhooks.h"
+ #include "tree-inline.h"
  #include "tree-iterator.h"
  #include "basic-block.h"
  #include "tree-flow.h"
*************** type_contains_placeholder_p (tree type)
*** 2213,2223 ****
    return result;
  }
  
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP
!    contains only arithmetic expressions or a CALL_EXPR with a
!    PLACEHOLDER_EXPR occurring only in its arglist.  */
  
  tree
  substitute_in_expr (tree exp, tree f, tree r)
--- 2214,2310 ----
    return result;
  }
  
+ /* Push tree EXP onto vector QUEUE if it is not already present.  */
+ 
+ static void
+ push_without_duplicate (tree exp, VEC (tree, heap) **queue)
+ {
+   unsigned int i;
+   tree iter;
+ 
+   for (i = 0; VEC_iterate (tree, *queue, i, iter); i++)
+     if (simple_cst_equal (iter, exp) == 1)
+       break;
+ 
+   if (!iter)
+     VEC_safe_push (tree, heap, *queue, exp);
+ }
+ 
+ /* Given a tree EXP, find all occurences of references to fields
+    in a PLACEHOLDER_EXPR and place them in vector SUBSTS without
+    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that
+    we assume here that EXP contains only arithmetic expressions
+    or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their
+    argument list.  */
+ 
+ void
+ find_substitute_in_expr (tree exp, VEC (tree, heap) **substs)
+ {
+   enum tree_code code = TREE_CODE (exp);
+   unsigned int i;
+   tree inner;
+ 
+   /* We handle TREE_LIST and COMPONENT_REF separately.  */
+   if (code == TREE_LIST)
+     {
+       FIND_SUBSTITUTE_IN_EXPR (TREE_CHAIN (exp), substs);
+       FIND_SUBSTITUTE_IN_EXPR (TREE_VALUE (exp), substs);
+     }
+   else if (code == COMPONENT_REF)
+     {
+       for (inner = TREE_OPERAND (exp, 0);
+ 	   REFERENCE_CLASS_P (inner);
+ 	   inner = TREE_OPERAND (inner, 0))
+ 	;
+ 
+       if (TREE_CODE (inner) == PLACEHOLDER_EXPR)
+ 	push_without_duplicate (exp, substs);
+       else
+ 	FIND_SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), substs);
+    }
+   else
+     switch (TREE_CODE_CLASS (code))
+       {
+       case tcc_constant:
+ 	break;
+ 
+       case tcc_declaration:
+ 	/* Variables allocated to static storage can stay.  */
+         if (!TREE_STATIC (exp))
+ 	  push_without_duplicate (exp, substs);
+ 	break;
+ 
+       case tcc_expression:
+ 	/* This is the pattern built in ada/make_aligning_type.  */
+ 	if (code == ADDR_EXPR
+ 	    && TREE_CODE (TREE_OPERAND (exp, 0)) == PLACEHOLDER_EXPR)
+ 	  {
+ 	    push_without_duplicate (exp, substs);
+ 	    break;
+ 	  }
+ 
+         /* Fall through...  */
+ 
+       case tcc_exceptional:
+       case tcc_unary:
+       case tcc_binary:
+       case tcc_comparison:
+       case tcc_reference:
+ 	for (i = 0; i < TREE_CODE_LENGTH (code); i++)
+ 	  FIND_SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, i), substs);
+ 	break;
+ 
+       default:
+ 	gcc_unreachable ();
+       }
+ }
+ 
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and
!    CONST_DECLs.  Note that we assume here that EXP contains only
!    arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs
!    occurring only in their argument list.  */
  
  tree
  substitute_in_expr (tree exp, tree f, tree r)
*************** substitute_in_expr (tree exp, tree f, tr
*** 2238,2277 ****
        return tree_cons (TREE_PURPOSE (exp), op1, op0);
      }
    else if (code == COMPONENT_REF)
!    {
!      /* If this expression is getting a value from a PLACEHOLDER_EXPR
! 	and it is the right field, replace it with R.  */
!      for (inner = TREE_OPERAND (exp, 0);
! 	  REFERENCE_CLASS_P (inner);
! 	  inner = TREE_OPERAND (inner, 0))
!        ;
!      if (TREE_CODE (inner) == PLACEHOLDER_EXPR
! 	 && TREE_OPERAND (exp, 1) == f)
!        return r;
! 
!      /* If this expression hasn't been completed let, leave it alone.  */
!      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && TREE_TYPE (inner) == 0)
!        return exp;
! 
!      op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);
!      if (op0 == TREE_OPERAND (exp, 0))
!        return exp;
  
!      new = fold_build3 (COMPONENT_REF, TREE_TYPE (exp),
! 			op0, TREE_OPERAND (exp, 1), NULL_TREE);
     }
    else
      switch (TREE_CODE_CLASS (code))
        {
        case tcc_constant:
-       case tcc_declaration:
  	return exp;
  
        case tcc_exceptional:
        case tcc_unary:
        case tcc_binary:
        case tcc_comparison:
-       case tcc_expression:
        case tcc_reference:
  	switch (TREE_CODE_LENGTH (code))
  	  {
--- 2325,2376 ----
        return tree_cons (TREE_PURPOSE (exp), op1, op0);
      }
    else if (code == COMPONENT_REF)
!     {
!       /* If this expression is getting a value from a PLACEHOLDER_EXPR
! 	 and it is the right field, replace it with R.  */
!       for (inner = TREE_OPERAND (exp, 0);
! 	   REFERENCE_CLASS_P (inner);
! 	   inner = TREE_OPERAND (inner, 0))
! 	;
! 
!       /* The field.  */
!       op1 = TREE_OPERAND (exp, 1);
! 
!       if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)
! 	return r;
! 
!       /* If this expression hasn't been completed yet, leave it alone.  */
!       if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))
! 	return exp;
! 
!       op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);
!       if (op0 == TREE_OPERAND (exp, 0))
! 	return exp;
  
!       new = fold_build3 (code, TREE_TYPE (exp), op0, op1, NULL_TREE);
     }
    else
      switch (TREE_CODE_CLASS (code))
        {
        case tcc_constant:
  	return exp;
  
+       case tcc_declaration:
+ 	if (exp == f)
+ 	  return r;
+ 	else
+ 	  return exp;
+ 
+       case tcc_expression:
+ 	if (exp == f)
+ 	  return r;
+ 
+         /* Fall through...  */
+ 
        case tcc_exceptional:
        case tcc_unary:
        case tcc_binary:
        case tcc_comparison:
        case tcc_reference:
  	switch (TREE_CODE_LENGTH (code))
  	  {
*************** substitute_in_expr (tree exp, tree f, tr
*** 2297,2302 ****
--- 2396,2412 ----
  	    break;
  
  	  case 3:
+ 	    /* If we are trying to replace F with a constant, inline back
+ 	       functions which do nothing else than computing a value from
+ 	       the arguments they are passed.  This makes it possible to
+ 	       fold partially or entirely the replacement expression.  */
+ 	    if (CONSTANT_CLASS_P (r) && code == CALL_EXPR)
+ 	      {
+ 		tree t = maybe_inline_call_in_expr (exp);
+ 		if (t)
+ 		  return SUBSTITUTE_IN_EXPR (t, f, r);
+ 	      }
+ 
  	    op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);
  	    op1 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 1), f, r);
  	    op2 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 2), f, r);
*************** substitute_in_expr (tree exp, tree f, tr
*** 2331,2337 ****
  	gcc_unreachable ();
        }
  
!   TREE_READONLY (new) = TREE_READONLY (exp);
    return new;
  }
  
--- 2441,2447 ----
  	gcc_unreachable ();
        }
  
!   TREE_READONLY (new) |= TREE_READONLY (exp);
    return new;
  }
  
*************** substitute_placeholder_in_expr (tree exp
*** 2343,2348 ****
--- 2453,2459 ----
  {
    enum tree_code code = TREE_CODE (exp);
    tree op0, op1, op2, op3;
+   tree new;
  
    /* If this is a PLACEHOLDER_EXPR, see if we find a corresponding type
       in the chain of OBJ.  */
*************** substitute_placeholder_in_expr (tree exp
*** 2416,2423 ****
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
  	    if (op0 == TREE_OPERAND (exp, 0))
  	      return exp;
! 	    else
! 	      return fold_build1 (code, TREE_TYPE (exp), op0);
  
  	  case 2:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
--- 2527,2535 ----
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
  	    if (op0 == TREE_OPERAND (exp, 0))
  	      return exp;
! 
! 	    new = fold_build1 (code, TREE_TYPE (exp), op0);
! 	    break;
  
  	  case 2:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
*************** substitute_placeholder_in_expr (tree exp
*** 2425,2432 ****
  
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))
  	      return exp;
! 	    else
! 	      return fold_build2 (code, TREE_TYPE (exp), op0, op1);
  
  	  case 3:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
--- 2537,2545 ----
  
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))
  	      return exp;
! 
! 	    new = fold_build2 (code, TREE_TYPE (exp), op0, op1);
! 	    break;
  
  	  case 3:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
*************** substitute_placeholder_in_expr (tree exp
*** 2436,2443 ****
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)
  		&& op2 == TREE_OPERAND (exp, 2))
  	      return exp;
! 	    else
! 	      return fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);
  
  	  case 4:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
--- 2549,2557 ----
  	    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)
  		&& op2 == TREE_OPERAND (exp, 2))
  	      return exp;
! 
! 	    new = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);
! 	    break;
  
  	  case 4:
  	    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);
*************** substitute_placeholder_in_expr (tree exp
*** 2449,2456 ****
  		&& op2 == TREE_OPERAND (exp, 2)
  		&& op3 == TREE_OPERAND (exp, 3))
  	      return exp;
! 	    else
! 	      return fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));
  
  	  default:
  	    gcc_unreachable ();
--- 2563,2571 ----
  		&& op2 == TREE_OPERAND (exp, 2)
  		&& op3 == TREE_OPERAND (exp, 3))
  	      return exp;
! 
! 	    new = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));
! 	    break;
  
  	  default:
  	    gcc_unreachable ();
*************** substitute_placeholder_in_expr (tree exp
*** 2460,2465 ****
--- 2575,2583 ----
        default:
  	gcc_unreachable ();
        }
+ 
+   TREE_READONLY (new) |= TREE_READONLY (exp);
+   return new;
  }
  
  /* Stabilize a reference so that we can use it any number of times
*************** build1_stat (enum tree_code code, tree t
*** 2833,2852 ****
    return t;
  }
  
! #define PROCESS_ARG(N)			\
!   do {					\
!     TREE_OPERAND (t, N) = arg##N;	\
!     if (arg##N &&!TYPE_P (arg##N))	\
!       {					\
!         if (TREE_SIDE_EFFECTS (arg##N))	\
! 	  side_effects = 1;		\
!         if (!TREE_READONLY (arg##N))	\
! 	  read_only = 0;		\
!         if (!TREE_CONSTANT (arg##N))	\
! 	  constant = 0;			\
! 	if (!TREE_INVARIANT (arg##N))	\
! 	  invariant = 0;		\
!       }					\
    } while (0)
  
  tree
--- 2951,2971 ----
    return t;
  }
  
! #define PROCESS_ARG(N)				\
!   do {						\
!     TREE_OPERAND (t, N) = arg##N;		\
!     if (arg##N &&!TYPE_P (arg##N))		\
!       {						\
!         if (TREE_SIDE_EFFECTS (arg##N))		\
! 	  side_effects = 1;			\
!         if (!TREE_READONLY (arg##N)		\
! 	    && !CONSTANT_CLASS_P (arg##N))	\
! 	  read_only = 0;			\
!         if (!TREE_CONSTANT (arg##N))		\
! 	  constant = 0;				\
! 	if (!TREE_INVARIANT (arg##N))		\
! 	  invariant = 0;			\
!       }						\
    } while (0)
  
  tree
*************** build3_stat (enum tree_code code, tree t
*** 2899,2904 ****
--- 3018,3024 ----
    t = make_node_stat (code PASS_MEM_STAT);
    TREE_TYPE (t) = tt;
  
+   read_only = 1;
    side_effects = TREE_SIDE_EFFECTS (t);
  
    PROCESS_ARG(0);
*************** build3_stat (enum tree_code code, tree t
*** 2910,2930 ****
        tree node;
        int i;
  
!       /* Calls have side-effects, except those to const or
  	 pure functions.  */
        i = call_expr_flags (t);
        if (!(i & (ECF_CONST | ECF_PURE)))
  	side_effects = 1;
  
!       /* And even those have side-effects if their arguments do.  */
!       else for (node = arg1; node; node = TREE_CHAIN (node))
! 	if (TREE_SIDE_EFFECTS (TREE_VALUE (node)))
! 	  {
  	    side_effects = 1;
! 	    break;
! 	  }
      }
  
    TREE_SIDE_EFFECTS (t) = side_effects;
    TREE_THIS_VOLATILE (t)
      = (TREE_CODE_CLASS (code) == tcc_reference
--- 3030,3060 ----
        tree node;
        int i;
  
!       /* Calls have side-effects, except maybe those to const or
  	 pure functions.  */
        i = call_expr_flags (t);
        if (!(i & (ECF_CONST | ECF_PURE)))
  	side_effects = 1;
  
!       /* Propagate TREE_READONLY of arguments for const functions.  */
!       read_only = (i & ECF_CONST) != 0;
!       
!       for (node = arg1; node; node = TREE_CHAIN (node))
! 	{
! 	  tree carg = TREE_VALUE (node);
!           /* Calls have side-effects if their arguments do.  */
! 	  if (TREE_SIDE_EFFECTS (carg))
  	    side_effects = 1;
! 	  if (!TREE_READONLY (carg) && !CONSTANT_CLASS_P (carg))
! 	    read_only = 0;
! 	}
! 
!       TREE_READONLY (t) = read_only;
      }
  
+   else if (code == COND_EXPR)
+     TREE_READONLY (t) = read_only;
+ 
    TREE_SIDE_EFFECTS (t) = side_effects;
    TREE_THIS_VOLATILE (t)
      = (TREE_CODE_CLASS (code) == tcc_reference
*** gcc/tree.h.0	2009-03-10 10:06:14.000000000 +0100
--- gcc/tree.h	2009-03-06 12:39:00.000000000 +0100
*************** extern tree round_down (tree, int);
*** 3549,3554 ****
--- 3549,3555 ----
  extern tree get_pending_sizes (void);
  extern void put_pending_size (tree);
  extern void put_pending_sizes (tree);
+ extern void finalize_size_functions (void);
  
  /* Type for sizes of data-type.  */
  
*************** extern bool contains_placeholder_p (tree
*** 3682,3691 ****
  
  extern bool type_contains_placeholder_p (tree);
  
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP
!    contains only arithmetic expressions.  */
  
  extern tree substitute_in_expr (tree, tree, tree);
  
--- 3683,3712 ----
  
  extern bool type_contains_placeholder_p (tree);
  
+ /* Given a tree EXP, find all occurences of references to fields
+    in a PLACEHOLDER_EXPR and place them in vector SUBSTS without
+    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that
+    we assume here that EXP contains only arithmetic expressions
+    or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their
+    argument list.  */
+ 
+ extern void find_substitute_in_expr (tree, VEC (tree, heap) **);
+ 
+ /* This macro calls the above function but short-circuits the common
+    case of a constant to save time and also checks for NULL.  */
+ 
+ #define FIND_SUBSTITUTE_IN_EXPR(EXP, V)	\
+ do {					\
+   if((EXP) && !TREE_CONSTANT (EXP))	\
+     find_substitute_in_expr (EXP, V);	\
+ } while (0)
+ 
  /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
     return a tree with all occurrences of references to F in a
!    PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and
!    CONST_DECLs.  Note that we assume here that EXP contains only
!    arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs
!    occurring only in their argument list.  */
  
  extern tree substitute_in_expr (tree, tree, tree);
  
*** gcc/tree-inline.c.0	2009-03-10 10:06:14.000000000 +0100
--- gcc/tree-inline.c	2009-03-10 10:06:19.000000000 +0100
*************** typedef struct inline_data
*** 129,134 ****
--- 129,136 ----
    bool saving_p;
    /* Versioning function is slightly different from inlining. */
    bool versioning_p;
+   /* True if trees should not be unshared.  */
+   bool do_not_unshare;
    /* Callgraph node of function we are inlining into.  */
    struct cgraph_node *node;
    /* Callgraph node of currently inlined function.  */
*************** remap_decl (tree decl, inline_data *id)
*** 253,259 ****
        return t;
      }
  
!   return unshare_expr ((tree) n->value);
  }
  
  static tree
--- 255,264 ----
        return t;
      }
  
!   if (id->do_not_unshare)
!     return (tree) n->value;
!   else
!     return unshare_expr ((tree) n->value);
  }
  
  static tree
*************** copy_body_r (tree *tp, int *walk_subtree
*** 648,654 ****
  		 but we absolutely rely on that.  As fold_indirect_ref
  	         does other useful transformations, try that first, though.  */
  	      tree type = TREE_TYPE (TREE_TYPE ((tree)n->value));
! 	      new = unshare_expr ((tree)n->value);
  	      old = *tp;
  	      *tp = fold_indirect_ref_1 (type, new);
  	      if (! *tp)
--- 653,662 ----
  		 but we absolutely rely on that.  As fold_indirect_ref
  	         does other useful transformations, try that first, though.  */
  	      tree type = TREE_TYPE (TREE_TYPE ((tree)n->value));
! 	      if (id->do_not_unshare)
! 		new = (tree)n->value;
! 	      else
! 		new = unshare_expr ((tree)n->value);
  	      old = *tp;
  	      *tp = fold_indirect_ref_1 (type, new);
  	      if (! *tp)
*************** optimize_inline_calls (tree fn)
*** 2343,2348 ****
--- 2351,2404 ----
    fold_cond_expr_cond ();
  }
  
+ /* EXP is CALL_EXPR present in a GENERIC expression tree.  Try
+    to integrate it and return the inlined body on success.  */
+ 
+ tree
+ maybe_inline_call_in_expr (tree exp)
+ {
+   tree fn = get_callee_fndecl (exp);
+ 
+   /* We can only try to inline "const" functions.  */
+   if (fn && TREE_READONLY (fn) && DECL_SAVED_TREE (fn))
+     {
+       inline_data id;
+       splay_tree decl_map;
+       tree param, arg, t;
+ 
+       /* Remap the parameters.  */
+       decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);
+       for (param = DECL_ARGUMENTS (fn), arg = TREE_OPERAND (exp, 1);
+ 	   param;
+ 	   param = TREE_CHAIN (param), arg = TREE_CHAIN (arg))
+ 	splay_tree_insert (decl_map,
+ 			   (splay_tree_key) param,
+ 			   (splay_tree_value) TREE_VALUE (arg));
+ 
+       memset (&id, 0, sizeof (id));
+       id.callee = fn;
+       id.callee_cfun = DECL_STRUCT_FUNCTION (fn);
+       id.decl_map = decl_map;
+ 
+       /* Make sure not to unshare trees behind the front-end's back
+ 	 since front-end specific mechanisms may rely on sharing.  */
+       id.do_not_unshare = true;
+ 
+       /* We're not inside any EH region.  */
+       id.eh_region = -1;
+ 
+       t = copy_generic_body (&id);
+       splay_tree_delete (decl_map);
+ 
+       /* We can only return something suitable for use
+ 	 in a GENERIC expression tree.  */
+       if (TREE_CODE (t) == MODIFY_EXPR)
+ 	return TREE_OPERAND (t, 1);
+     }
+ 
+   return NULL_TREE;
+ }
+ 
  /* FN is a function that has a complete body, and CLONE is a function whose
     body is to be set to a copy of FN, mapping argument declarations according
     to the ARG_MAP splay_tree.  */
*** gcc/tree-inline.h.0	2009-03-10 10:06:14.000000000 +0100
--- gcc/tree-inline.h	2009-03-06 12:39:00.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 26,31 ****
--- 26,32 ----
  /* Function prototypes.  */
  
  void optimize_inline_calls (tree);
+ tree maybe_inline_call_in_expr (tree);
  bool tree_inlinable_function_p (tree);
  tree copy_tree_r (tree *, int *, void *);
  void clone_body (tree, tree, void *);
*** gcc/fold-const.c.0	2006-10-24 00:40:11.000000000 +0200
--- gcc/fold-const.c	2006-10-24 12:13:59.339887208 +0200
*************** fold_binary (enum tree_code code, tree t
*** 9383,9397 ****
  	}
  
        /* Comparisons with the highest or lowest possible integer of
! 	 the specified size will have known values.  */
        {
! 	int width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));
  
  	if (TREE_CODE (arg1) == INTEGER_CST
  	    && ! TREE_CONSTANT_OVERFLOW (arg1)
  	    && width <= 2 * HOST_BITS_PER_WIDE_INT
! 	    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))
! 		|| POINTER_TYPE_P (TREE_TYPE (arg1))))
  	  {
  	    HOST_WIDE_INT signed_max_hi;
  	    unsigned HOST_WIDE_INT signed_max_lo;
--- 9383,9397 ----
  	}
  
        /* Comparisons with the highest or lowest possible integer of
! 	 the specified precision will have known values.  */
        {
! 	tree arg1_type = TREE_TYPE (arg1);
! 	unsigned int width = TYPE_PRECISION (arg1_type);
  
  	if (TREE_CODE (arg1) == INTEGER_CST
  	    && ! TREE_CONSTANT_OVERFLOW (arg1)
  	    && width <= 2 * HOST_BITS_PER_WIDE_INT
! 	    && (INTEGRAL_TYPE_P (arg1_type) || POINTER_TYPE_P (arg1_type)))
  	  {
  	    HOST_WIDE_INT signed_max_hi;
  	    unsigned HOST_WIDE_INT signed_max_lo;
*************** fold_binary (enum tree_code code, tree t
*** 9404,9410 ****
  		signed_max_hi = 0;
  		max_hi = 0;
  
! 		if (TYPE_UNSIGNED (TREE_TYPE (arg1)))
  		  {
  		    max_lo = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;
  		    min_lo = 0;
--- 9404,9410 ----
  		signed_max_hi = 0;
  		max_hi = 0;
  
! 		if (TYPE_UNSIGNED (arg1_type))
  		  {
  		    max_lo = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;
  		    min_lo = 0;
*************** fold_binary (enum tree_code code, tree t
*** 9426,9432 ****
  		max_lo = -1;
  		min_lo = 0;
  
! 		if (TYPE_UNSIGNED (TREE_TYPE (arg1)))
  		  {
  		    max_hi = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;
  		    min_hi = 0;
--- 9426,9432 ----
  		max_lo = -1;
  		min_lo = 0;
  
! 		if (TYPE_UNSIGNED (arg1_type))
  		  {
  		    max_hi = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;
  		    min_hi = 0;
*************** fold_binary (enum tree_code code, tree t
*** 9520,9528 ****
  	    else if (!in_gimple_form
  		     && TREE_INT_CST_HIGH (arg1) == signed_max_hi
  		     && TREE_INT_CST_LOW (arg1) == signed_max_lo
! 		     && TYPE_UNSIGNED (TREE_TYPE (arg1))
  		     /* signed_type does not work on pointer types.  */
! 		     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))
  	      {
  		/* The following case also applies to X < signed_max+1
  		   and X >= signed_max+1 because previous transformations.  */
--- 9520,9530 ----
  	    else if (!in_gimple_form
  		     && TREE_INT_CST_HIGH (arg1) == signed_max_hi
  		     && TREE_INT_CST_LOW (arg1) == signed_max_lo
! 		     && TYPE_UNSIGNED (arg1_type)
! 		     /* The sign bit is under the control of the mode.  */
! 		     && width == GET_MODE_BITSIZE (TYPE_MODE (arg1_type))
  		     /* signed_type does not work on pointer types.  */
! 		     && INTEGRAL_TYPE_P (arg1_type))
  	      {
  		/* The following case also applies to X < signed_max+1
  		   and X >= signed_max+1 because previous transformations.  */
*** gcc/config/i386/i386.c.0	2006-10-29 08:26:47.000000000 +0100
--- gcc/config/i386/i386.c	2006-10-29 08:27:58.000000000 +0100
*************** override_options (void)
*** 1690,1695 ****
--- 1690,1700 ----
       so it won't slow down the compilation and make x87 code slower.  */
    if (!TARGET_SCHEDULE)
      flag_schedule_insns_after_reload = flag_schedule_insns = 0;
+ 
+   /* Lest we mix MMX and x87 code.  */
+   if ((ix86_fpmath & FPMATH_387)
+       && !(target_flags_explicit & (MASK_MMX | MASK_3DNOW | MASK_3DNOW_A)))
+     target_flags &= ~MASK_MMX;
  }
  
  /* switch to the appropriate section for output of DECL.
*************** static const struct builtin_description 
*** 14714,14726 ****
  static void
  ix86_init_builtins (void)
  {
!   if (TARGET_MMX)
      ix86_init_mmx_sse_builtins ();
  }
  
! /* Set up all the MMX/SSE builtins.  This is not called if TARGET_MMX
!    is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX
!    builtins.  */
  static void
  ix86_init_mmx_sse_builtins (void)
  {
--- 14719,14730 ----
  static void
  ix86_init_builtins (void)
  {
!   if (TARGET_MMX || TARGET_SSE)
      ix86_init_mmx_sse_builtins ();
  }
  
! /* Set up all the MMX/SSE builtins.  */
! 
  static void
  ix86_init_mmx_sse_builtins (void)
  {
*** gcc/config/rs6000/rs6000.h.ori	Thu Nov  2 12:52:03 2006
--- gcc/config/rs6000/rs6000.h	Thu Nov  2 14:39:48 2006
***************
*** 191,196 ****
--- 191,199 ----
  
  #define TARGET_DEFAULT (MASK_POWER | MASK_MULTIPLE | MASK_STRING)
  
+ /* Extra default flags to be overriden on a per subtarget basis.  */
+ #define SUBTARGET_DEFAULT 0
+ 
  /* Processor type.  Order must match cpu attribute in MD file.  */
  enum processor_type
   {
*** gcc/config/rs6000/rs6000.c.ori	Thu Nov  2 12:47:38 2006
--- gcc/config/rs6000/rs6000.c	Thu Nov  2 12:56:15 2006
*************** static const char alt_reg_names[][8] =
*** 998,1004 ****
  
  #undef TARGET_DEFAULT_TARGET_FLAGS
  #define TARGET_DEFAULT_TARGET_FLAGS \
!   (TARGET_DEFAULT | MASK_SCHED_PROLOG)
  
  #undef TARGET_STACK_PROTECT_FAIL
  #define TARGET_STACK_PROTECT_FAIL rs6000_stack_protect_fail
--- 998,1004 ----
  
  #undef TARGET_DEFAULT_TARGET_FLAGS
  #define TARGET_DEFAULT_TARGET_FLAGS \
!   (TARGET_DEFAULT | SUBTARGET_DEFAULT | MASK_SCHED_PROLOG)
  
  #undef TARGET_STACK_PROTECT_FAIL
  #define TARGET_STACK_PROTECT_FAIL rs6000_stack_protect_fail
*** gcc/config/rs6000/strict-align.h.ori	Thu Nov  2 14:41:53 2006
--- gcc/config/rs6000/strict-align.h	Thu Nov  2 14:43:42 2006
***************
*** 0 ****
--- 1,26 ----
+ /* Definitions of target machine for GNU compiler, for IBM RS/6000.
+    Copyright (C) 2006
+    Free Software Foundation, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the
+    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301, USA.  */
+ 
+ /* Default to -mstrict-align.  */
+ 
+ #undef  SUBTARGET_DEFAULT
+ #define SUBTARGET_DEFAULT (MASK_STRICT_ALIGN)
+ 
*** gcc/config.gcc.ori	Tue Oct 31 19:04:41 2006
--- gcc/config.gcc	Thu Nov  2 16:50:39 2006
*************** powerpc-*-chorusos*)
*** 1687,1692 ****
--- 1687,1694 ----
  	;;
  powerpc-*-eabispe*)
  	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabispe.h"
+ 	# Default to -mstrict-align
+ 	tm_file="${tm_file} rs6000/strict-align.h"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	tmake_file="rs6000/t-spe rs6000/t-ppccomm"
  	;;
*************** powerpc-*-eabisim*)
*** 1702,1707 ****
--- 1704,1711 ----
  	;;
  powerpc-*-elf*)
  	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+ 	# Default to -mstrict-align
+ 	tm_file="${tm_file} rs6000/strict-align.h"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
  	use_fixproto=yes
*************** powerpc-*-eabialtivec*)
*** 1713,1718 ****
--- 1717,1724 ----
  	;;
  powerpc-*-eabi*)
  	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h"
+ 	# Default to -mstrict-align
+ 	tm_file="${tm_file} rs6000/strict-align.h"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
  	;;
*** gcc/builtins.c.0	2006-11-03 18:17:09.000000000 +0100
--- gcc/builtins.c	2006-11-03 19:03:56.651223664 +0100
*************** expand_builtin_return_addr (enum built_i
*** 540,551 ****
  #else
    rtx tem;
  
!   /* For a zero count, we don't care what frame address we return, so frame
!      pointer elimination is OK, and using the soft frame pointer is OK.
!      For a non-zero count, we require a stable offset from the current frame
!      pointer to the previous one, so we must use the hard frame pointer, and
       we must disable frame pointer elimination.  */
!   if (count == 0)
      tem = frame_pointer_rtx;
    else 
      {
--- 540,555 ----
  #else
    rtx tem;
  
!   /* For a zero count with __builtin_return_address, we don't care what
!      frame address we return, because target-specific definitions will
!      override us.  Therefore frame pointer elimination is OK, and using
!      the soft frame pointer is OK.
! 
!      For a non-zero count, or a zero count with __builtin_frame_address,
!      we require a stable offset from the current frame pointer to the
!      previous one, so we must use the hard frame pointer, and
       we must disable frame pointer elimination.  */
!   if (count == 0 && fndecl_code == BUILT_IN_RETURN_ADDRESS)
      tem = frame_pointer_rtx;
    else 
      {
*************** expand_builtin_return_addr (enum built_i
*** 557,570 ****
  #endif
  
    /* Some machines need special handling before we can access
!      arbitrary frames.  For example, on the sparc, we must first flush
       all register windows to the stack.  */
  #ifdef SETUP_FRAME_ADDRESSES
    if (count > 0)
      SETUP_FRAME_ADDRESSES ();
  #endif
  
!   /* On the sparc, the return address is not in the frame, it is in a
       register.  There is no way to access it off of the current frame
       pointer, but it can be accessed off the previous frame pointer by
       reading the value from the register window save area.  */
--- 561,574 ----
  #endif
  
    /* Some machines need special handling before we can access
!      arbitrary frames.  For example, on the SPARC, we must first flush
       all register windows to the stack.  */
  #ifdef SETUP_FRAME_ADDRESSES
    if (count > 0)
      SETUP_FRAME_ADDRESSES ();
  #endif
  
!   /* On the SPARC, the return address is not in the frame, it is in a
       register.  There is no way to access it off of the current frame
       pointer, but it can be accessed off the previous frame pointer by
       reading the value from the register window save area.  */
*************** expand_builtin_return_addr (enum built_i
*** 586,597 ****
        tem = copy_to_reg (tem);
      }
  
!   /* For __builtin_frame_address, return what we've got.  */
    if (fndecl_code == BUILT_IN_FRAME_ADDRESS)
      return tem;
  
!   /* For __builtin_return_address, Get the return address from that
!      frame.  */
  #ifdef RETURN_ADDR_RTX
    tem = RETURN_ADDR_RTX (count, tem);
  #else
--- 590,605 ----
        tem = copy_to_reg (tem);
      }
  
!   /* For __builtin_frame_address, return what we've got.  But, on
!      the SPARC for example, we may have to add a bias.  */
    if (fndecl_code == BUILT_IN_FRAME_ADDRESS)
+ #ifdef FRAME_ADDR_RTX
+     return FRAME_ADDR_RTX (tem);
+ #else
      return tem;
+ #endif
  
!   /* For __builtin_return_address, get the return address from that frame.  */
  #ifdef RETURN_ADDR_RTX
    tem = RETURN_ADDR_RTX (count, tem);
  #else
*** gcc/doc/tm.texi.0	2006-11-03 19:03:43.923158624 +0100
--- gcc/doc/tm.texi	2006-11-03 19:03:56.686218344 +0100
*************** machines.  One reason you may need to de
*** 2861,2866 ****
--- 2861,2872 ----
  @code{hard_frame_pointer_rtx} is the appropriate value on your machine.
  @end deftypefn
  
+ @defmac FRAME_ADDR_RTX (@var{frameaddr})
+ A C expression whose value is RTL representing the value of the frame
+ address for the current frame.  @var{frameaddr} is the frame pointer
+ of the current frame.
+ @end defmac
+ 
  @defmac RETURN_ADDR_RTX (@var{count}, @var{frameaddr})
  A C expression whose value is RTL representing the value of the return
  address for the frame @var{count} steps up from the current frame, after
*** gcc/config/sparc/sparc.h.0	2006-11-03 19:03:36.285319752 +0100
--- gcc/config/sparc/sparc.h	2006-11-03 19:03:56.655223056 +0100
*************** do {									\
*** 1692,1697 ****
--- 1692,1701 ----
  #define DYNAMIC_CHAIN_ADDRESS(frame)	\
    plus_constant (frame, 14 * UNITS_PER_WORD + SPARC_STACK_BIAS)
  
+ /* Given an rtx for the frame pointer,
+    return an rtx for the address of the frame.  */
+ #define FRAME_ADDR_RTX(frame) plus_constant (frame, SPARC_STACK_BIAS)
+ 
  /* The return address isn't on the stack, it is in a register, so we can't
     access it from the current frame pointer.  We can access it from the
     previous frame pointer though by reading a value from the register window
*** gcc/mklibgcc.in.old	Mon Sep 11 03:10:13 2006
--- gcc/mklibgcc.in	Mon Nov  6 12:43:55 2006
***************
*** 876,882 ****
      echo '	$(RANLIB_FOR_TARGET)' ${ldir}/libgcc_eh.a
  
      shlib_slibdir_qual=
!     os_multilib_dir=`$GCC_FOR_TARGET $flags --print-multi-os-directory`
      if [ "$os_multilib_dir" != . ]; then
        shlib_slibdir_qual="/$os_multilib_dir"
      fi
--- 877,883 ----
      echo '	$(RANLIB_FOR_TARGET)' ${ldir}/libgcc_eh.a
  
      shlib_slibdir_qual=
!     os_multilib_dir=`$GCC_FOR_TARGET $flags --print-multi-os-directory | tr -d '\r'`
      if [ "$os_multilib_dir" != . ]; then
        shlib_slibdir_qual="/$os_multilib_dir"
      fi
*** gcc/config/ia64/hpux.h.0	Tue Nov  7 18:21:05 2006
--- gcc/config/ia64/hpux.h	Tue Nov  7 18:25:09 2006
***************
*** 66,80 ****
     affect only aCC's C++ library (Rogue Wave-derived) which we do not
     use, and they violate the user's name space.  */
  
  #undef  ASM_EXTRA_SPEC
! #define ASM_EXTRA_SPEC "%{milp32:-milp32} %{mlp64:-mlp64}"
  
  #undef ENDFILE_SPEC
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{!shared:%{static:crt0%O%s} \
! 			  %{mlp64:/usr/lib/hpux64/unix98%O%s} \
! 			  %{!mlp64:/usr/lib/hpux32/unix98%O%s}}"
  
  #undef LINK_SPEC
  #define LINK_SPEC \
--- 66,86 ----
     affect only aCC's C++ library (Rogue Wave-derived) which we do not
     use, and they violate the user's name space.  */
  
+ #undef CC1_SPEC
+ #define CC1_SPEC "%{!milp32:-mlp64} %{G*}"
+ 
+ #undef ASM_SPEC
+ #define ASM_SPEC "-W -x %{mconstant-gp} %{mauto-pic} %(asm_extra)"
+ 
  #undef  ASM_EXTRA_SPEC
! #define ASM_EXTRA_SPEC "%{milp32:-milp32} %{!milp32:-mlp64}"
  
  #undef ENDFILE_SPEC
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{!shared:%{static:crt0%O%s} \
! 			  %{!milp32:/usr/lib/hpux64/unix98%O%s} \
! 			  %{milp32:/usr/lib/hpux32/unix98%O%s}}"
  
  #undef LINK_SPEC
  #define LINK_SPEC \
*** gcc/config/ia64/hpux.h.orig	2006-11-07 16:02:58 -0500
--- gcc/config/ia64/hpux.h	2006-11-07 16:07:41 -0500
*************** Boston, MA 02110-1301, USA.  */
*** 36,41 ****
--- 36,45 ----
  #undef WCHAR_TYPE_SIZE
  #define WCHAR_TYPE_SIZE 32
  
+ /* Widest floating-point type efficiently supported by hardware and OS.  */
+ #undef WIDEST_HARDWARE_FP_SIZE
+ #define WIDEST_HARDWARE_FP_SIZE 64
+ 
  /* Target OS builtins.  */
  #define TARGET_OS_CPP_BUILTINS()			\
  do {							\
*** gcc/varasm.c.ori	Mon Jun 13 18:13:24 2005
--- gcc/varasm.c	Mon Jun 13 18:17:30 2005
*************** default_section_type_flags_1 (tree decl,
*** 5112,5117 ****
--- 5112,5118 ----
  
    if (strcmp (name, ".bss") == 0
        || strncmp (name, ".bss.", 5) == 0
+       || strcmp (name, ".persistent.bss") == 0
        || strncmp (name, ".gnu.linkonce.b.", 16) == 0
        || strcmp (name, ".sbss") == 0
        || strncmp (name, ".sbss.", 6) == 0
*** gcc/gimplify.c.0	2006-11-22 10:20:39.078482632 +0100
--- gcc/gimplify.c	2006-11-22 10:52:48.531161240 +0100
*************** gimplify_init_ctor_preeval_1 (tree *tp, 
*** 2497,2502 ****
--- 2497,2517 ----
        && alias_sets_conflict_p (data->lhs_alias_set, get_alias_set (t)))
      return t;
  
+   /* If the constructor component is a call, determine if it can hide a
+      potential overlap with the lhs through an INDIRECT_REF like above.  */
+   if (TREE_CODE (t) == CALL_EXPR)
+     {
+       tree type, fntype = TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 0)));
+ 
+       for (type = TYPE_ARG_TYPES (fntype); type; type = TREE_CHAIN (type))
+ 	if (POINTER_TYPE_P (TREE_VALUE (type))
+ 	    && (!data->lhs_base_decl || TREE_ADDRESSABLE (data->lhs_base_decl))
+ 	    && alias_sets_conflict_p (data->lhs_alias_set,
+ 				      get_alias_set
+ 				        (TREE_TYPE (TREE_VALUE (type)))))
+ 	  return t;
+     }
+ 
    if (IS_TYPE_OR_DECL_P (t))
      *walk_subtrees = 0;
    return NULL;
*** gcc/config/vx-common.h.ori	Tue Nov 28 09:46:17 2006
--- gcc/config/vx-common.h	Tue Nov 28 11:01:23 2006
*************** void vxworks_exception_section (void);
*** 97,99 ****
--- 97,106 ----
  /* We occasionally need to distinguish between the VxWorks variants.  */
  #define VXWORKS_KIND_NORMAL  1
  #define VXWORKS_KIND_AE      2
+ 
+ /* Default executable suffix is .out for VxWorks, ??? Should be .vxe for RTPs,
+    but this would depend on runtime values, hence would not be a valid static
+    initializer.  */
+ #undef TARGET_EXECUTABLE_SUFFIX
+ #define TARGET_EXECUTABLE_SUFFIX ".out"
+ 
*** Makefile.in.orig	Mon Nov 27 12:29:57 2006
--- Makefile.in	Tue Nov 28 15:18:45 2006
***************
*** 34843,34850 ****
  	  mv gcc/include gcc/tmp-include 2>/dev/null; \
  	  mkdir gcc/include; \
  	  cp $(srcdir)/gcc/gsyslimits.h gcc/include/syslimits.h; \
  	  touch gcc/stmp-fixinc gcc/include/fixed; \
! 	  rm -f gcc/stmp-headers gcc/stmp-int-hdrs; \
  	  r=`${PWD_COMMAND}`; export r; \
  	  s=`cd $(srcdir); ${PWD_COMMAND}` ; export s; \
  	  $(HOST_EXPORTS) \
--- 34843,34863 ----
  	  mv gcc/include gcc/tmp-include 2>/dev/null; \
  	  mkdir gcc/include; \
  	  cp $(srcdir)/gcc/gsyslimits.h gcc/include/syslimits.h; \
+ 	  mv gcc/stmp-fixinc gcc/stmp-fixinc-orig; \
  	  touch gcc/stmp-fixinc gcc/include/fixed; \
! 	  mv gcc/stmp-int-hdrs gcc/stmp-int-hdrs-orig; \
!           mv gcc/stmp-headers gcc/stmp-headers-orig; \
!           r=`${PWD_COMMAND}`; export r; \
!           s=`cd $(srcdir); ${PWD_COMMAND}` ; export s; \
!           $(HOST_EXPORTS) \
!           (cd ./gcc && \
!            $(MAKE) $(GCC_FLAGS_TO_PASS) stmp-int-hdrs); \
!           mv gcc/stmp-fixinc-orig gcc/stmp-fixinc; \
!           mv gcc/stmp-int-hdrs-orig gcc/stmp-int-hdrs; \
!           mv gcc/stmp-headers-orig gcc/stmp-headers; \
!           true; \
!         else true; fi
! 	@if [ -f ./gcc/Makefile ]; then \
  	  r=`${PWD_COMMAND}`; export r; \
  	  s=`cd $(srcdir); ${PWD_COMMAND}` ; export s; \
  	  $(HOST_EXPORTS) \
*** gcc/expr.c.ori	Thu Nov 23 15:42:51 2006
--- gcc/expr.c	Tue Nov 28 11:40:31 2006
*************** expand_expr_real_1 (tree exp, rtx target
*** 7248,7260 ****
  	/* If this is a constant, put it into a register if it is a legitimate
  	   constant, OFFSET is 0, and we won't try to extract outside the
  	   register (in case we were passed a partially uninitialized object
! 	   or a view_conversion to a larger size).  Force the constant to
! 	   memory otherwise.  */
  	if (CONSTANT_P (op0))
  	  {
  	    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));
  	    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)
  		&& offset == 0
  		&& bitpos + bitsize <= GET_MODE_BITSIZE (mode))
  	      op0 = force_reg (mode, op0);
  	    else
--- 7248,7262 ----
  	/* If this is a constant, put it into a register if it is a legitimate
  	   constant, OFFSET is 0, and we won't try to extract outside the
  	   register (in case we were passed a partially uninitialized object
! 	   or a view_conversion to a larger size) or a BLKmode piece of it
! 	   (e.g. if it is unchecked-converted to a record type in Ada).  Force
! 	   the constant to memory otherwise.  */
  	if (CONSTANT_P (op0))
  	  {
  	    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));
  	    if (mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)
  		&& offset == 0
+ 		&& mode1 != BLKmode
  		&& bitpos + bitsize <= GET_MODE_BITSIZE (mode))
  	      op0 = force_reg (mode, op0);
  	    else
*************** expand_expr_real_1 (tree exp, rtx target
*** 7268,7275 ****
  	   for an ARRAY_RANGE_REF whose type is BLKmode.  */
  	else if (!MEM_P (op0)
  		 && (offset != 0
! 		     || (bitpos + bitsize > GET_MODE_BITSIZE (GET_MODE (op0)))
! 		     || (code == ARRAY_RANGE_REF && mode == BLKmode)))
  	  {
  	    tree nt = build_qualified_type (TREE_TYPE (tem),
  					    (TYPE_QUALS (TREE_TYPE (tem))
--- 7270,7278 ----
  	   for an ARRAY_RANGE_REF whose type is BLKmode.  */
  	else if (!MEM_P (op0)
  		 && (offset != 0
! 		     || mode1 == BLKmode
! 		     || (bitpos + bitsize
! 			 > GET_MODE_BITSIZE (GET_MODE (op0)))))
  	  {
  	    tree nt = build_qualified_type (TREE_TYPE (tem),
  					    (TYPE_QUALS (TREE_TYPE (tem))
*** fixincludes/fixinc.in.old	Thu Nov 30 01:38:35 2006
--- fixincludes/fixinc.in	Thu Nov 30 01:39:45 2006
***************
*** 75,81 ****
  #
  if test -z "${target_canonical}" ; then
    if test -x ./config.guess ; then
!     target_canonical="`config.guess`" ; fi
    test -z "${target_canonical}" && target_canonical=unknown
  fi
  export target_canonical
--- 75,81 ----
  #
  if test -z "${target_canonical}" ; then
    if test -x ./config.guess ; then
!     target_canonical="`./config.guess`" ; fi
    test -z "${target_canonical}" && target_canonical=unknown
  fi
  export target_canonical
*** gcc/gcov.c.old	Sun Aug 15 22:20:30 2004
--- gcc/gcov.c	Sun Aug 15 23:01:25 2004
*************** static int output_branch_count (FILE *, 
*** 340,345 ****
--- 340,347 ----
  static void output_lines (FILE *, const source_t *);
  static char *make_gcov_file_name (const char *, const char *);
  static void release_structures (void);
+ static char *l_strchr (const char *);
+ static char *l_strrchr (const char *);
  extern int main (int, char **);
  
  int
*************** main (int argc, char **argv)
*** 366,371 ****
--- 368,402 ----
    return 0;
  }
  
+ static char *
+ l_strchr (const char *file_name)
+ {
+   char *p = (char *)file_name;
+ 
+   while (!IS_DIR_SEPARATOR (*p))
+     {
+       if (*p == '\0')
+ 	return NULL;
+       p++;
+     }
+   return p;
+ }
+ 
+ static char *
+ l_strrchr (const char *file_name)
+ {
+   char *p = (char *)&file_name [strlen (file_name) - 1];
+ 
+   while (!IS_DIR_SEPARATOR (*p))
+     {
+       p--;
+ 
+       if (p < file_name)
+ 	return NULL;
+     }
+   return p;
+ }
+ 
  static void
  fnotice (FILE *file, const char *cmsgid, ...)
  {
*************** create_file_names (const char *file_name
*** 626,632 ****
  
        base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);
        strcat (name, object_directory);
!       if (base && name[strlen (name) - 1] != '/')
  	strcat (name, "/");
      }
    else
--- 657,663 ----
  
        base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);
        strcat (name, object_directory);
!       if (base && (! IS_DIR_SEPARATOR (name[strlen (name) - 1])))
  	strcat (name, "/");
      }
    else
*************** create_file_names (const char *file_name
*** 639,645 ****
    if (base)
      {
        /* Append source file name.  */
!       cptr = strrchr (file_name, '/');
        strcat (name, cptr ? cptr + 1 : file_name);
      }
  
--- 670,676 ----
    if (base)
      {
        /* Append source file name.  */
!       cptr = l_strrchr (file_name);
        strcat (name, cptr ? cptr + 1 : file_name);
      }
  
*************** make_gcov_file_name (const char *input_n
*** 1423,1435 ****
    if (flag_long_names && strcmp (src_name, input_name))
      {
        /* Generate the input filename part.  */
!       cptr = flag_preserve_paths ? NULL : strrchr (input_name, '/');
        strcat (name, cptr ? cptr + 1 : input_name);
        strcat (name, "##");
      }
  
    /* Generate the source filename part.  */
!   cptr = flag_preserve_paths ? NULL : strrchr (src_name, '/');
    strcat (name, cptr ? cptr + 1 : src_name);
  
    if (flag_preserve_paths)
--- 1454,1466 ----
    if (flag_long_names && strcmp (src_name, input_name))
      {
        /* Generate the input filename part.  */
!       cptr = flag_preserve_paths ? NULL : l_strrchr (input_name);
        strcat (name, cptr ? cptr + 1 : input_name);
        strcat (name, "##");
      }
  
    /* Generate the source filename part.  */
!   cptr = flag_preserve_paths ? NULL : l_strrchr (src_name);
    strcat (name, cptr ? cptr + 1 : src_name);
  
    if (flag_preserve_paths)
*************** make_gcov_file_name (const char *input_n
*** 1437,1443 ****
        /* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */
        char *prev;
  
!       for (cptr = name; (cptr = strchr ((prev = cptr), '/'));)
  	{
  	  unsigned shift = 0;
  
--- 1468,1474 ----
        /* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */
        char *prev;
  
!       for (cptr = name; (cptr = l_strchr ((prev = cptr)));)
  	{
  	  unsigned shift = 0;
  
*** gcc/config.gcc.ori	Sat Dec  2 17:56:59 2006
--- gcc/config.gcc	Sun Dec  3 15:53:28 2006
*************** powerpc-wrs-vxworks|powerpc-wrs-vxworksa
*** 1781,1786 ****
--- 1781,1787 ----
  	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-ppccomm rs6000/t-vxworks"
  	extra_options="${extra_options} rs6000/sysv4.opt"
  	extra_headers=ppc-asm.h
+ 	extra_parts="crtbegin.o crtbeginT.o crtend.o"
  	case ${target} in
  	  *-vxworksae*)
  	    tm_file="${tm_file} vx-common.h vxworksae.h rs6000/vxworks.h rs6000/vxworksae.h"
*** gcc/config/rs6000/vxworks.h.ori	Sat Dec  2 17:57:23 2006
--- gcc/config/rs6000/vxworks.h	Sun Dec  3 18:18:51 2006
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 161,163 ****
--- 161,223 ----
  /* No _mcount profiling on VxWorks.  */
  #undef FUNCTION_PROFILER
  #define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)
+ 
+ /* Support for table based unwinding and exception propagation:
+ 
+    o let the compiler generate the DWARF info into the .eh_frame section,
+ 
+    o rely on the VxWorks default linker script to drag the .eh_frame sections
+      of the individual objects into the .data section of each module,
+ 
+    o resort to the crtstuff machinery to...
+ 
+      - provide the __EH_FRAME_BEGIN__ symbol at the beginning of this section
+        in the "final" binary (we have EH_FRAME_SECTION_NAME defined),
+ 
+      - provide a __do_global_ctors function to trigger the static constructors
+        and register the frame info (for which we define HAS_INIT_SECTION and
+        USE_EH_FRAME_REGISTRY here, and undefine INIT/FINI_SECTION_ASM_OP to
+        avoid relying on the .init/.fini regular elf behavior which does not
+        apply to VxWorks),
+ 
+      - define the _ctors/_dtors arrays for application modules, that VxWorks
+        recognizes as constructors and destructors tables, to trigger an
+        automatic call to __do_global_ctors/__do_global_dtors at dynamic
+        load/unload time.  Doing that is not always appropriate (e.g. when
+        linking against the VxWorks kernel), so we actually use one set of crt
+        objects with those definitions and one without.  The latter is dragged
+        when "-static" is on the link command line, and the former is dragged
+        when "-dynamic" is on the link command line.  See the SPECs below.
+        When -static is used, and so is the set of crt objects without the
+        definitions, another circuitry should be used to trigger the calls.
+ */
+ 
+ /* State we're using the crtstuff objects in addition to the common bits. */
+ 
+ #undef  STARTFILE_SPEC
+ #define STARTFILE_SPEC VXWORKS_STARTFILE_SPEC \
+ 	"%{static:crtbeginT.o%s} %{dynamic:crtbegin.o%s}"
+ 
+ #undef  ENDFILE_SPEC
+ #define ENDFILE_SPEC VXWORKS_ENDFILE_SPEC \
+ 	"%{static|dynamic:crtend.o%s}"
+ 
+ /* Set things up for them to include just what we want.  Merely undefining
+    INIT/FINI_SECTION_ASM_OP triggers undefined references to symbols of those
+    names indirectly from EXTRA_SECTION_FUNCTIONS, which we drag from svr4.h
+    but actually don't care about, so we work-around that. */
+ 
+ #define HAS_INIT_SECTION
+ #define USE_EH_FRAME_REGISTRY
+ 
+ #undef  INIT_SECTION_ASM_OP
+ #undef  INIT_SECTION_FUNCTION
+ #define INIT_SECTION_FUNCTION
+ 
+ #undef  FINI_SECTION_ASM_OP
+ #undef  FINI_SECTION_FUNCTION
+ #define FINI_SECTION_FUNCTION
+ 
+ #undef  DWARF2_UNWIND_INFO
+ #define DWARF2_UNWIND_INFO 1
+ 
*** gcc/crtstuff.c.ori	Sat Dec  2 17:58:07 2006
--- gcc/crtstuff.c	Sun Dec  3 18:18:17 2006
*************** call_ ## FUNC (void)					\
*** 104,109 ****
--- 104,118 ----
  # define EH_FRAME_SECTION_CONST
  #endif
  
+ /* For VxWorks, this (crtstuff) is used to help provide table based unwinding
+    capabilities.  This has not been exercised for Java at this stage and we
+    need to avoid references to Jv regitration routines from here as they would
+    remain unresolved for dynamically loaded modules.  */
+ 
+ #ifdef __vxworks
+ #undef JCR_SECTION_NAME
+ #endif
+ 
  /* We do not want to add the weak attribute to the declarations of these
     routines in unwind-dw2-fde.h because that will cause the definition of
     these symbols to be weak as well.
*************** __do_global_dtors (void)
*** 413,418 ****
--- 422,448 ----
  #endif
  }
  
+ /* We also use this case for VxWorks table based eh.  We arrange for
+    the dynamic loader to hook into __do_global_c/dtors for application
+    modules and leave an indication stating whether we have done that
+    or not.  */
+ #if defined (__vxworks)
+ 
+ #if !defined (CRTSTUFFT_O)
+ 
+ extern void __do_global_dtors (void);
+ func_ptr _dtors [] = {__do_global_dtors, 0};
+ 
+ extern void __do_global_ctors (void);
+ func_ptr _ctors [] = {__do_global_ctors, 0};
+ 
+ const int __module_has_ctors = 1;
+ #else
+ const int __module_has_ctors = 0;
+ #endif
+ 
+ #endif
+ 
  #if defined(USE_EH_FRAME_REGISTRY) || defined(JCR_SECTION_NAME)
  /* A helper function for __do_global_ctors, which is in crtend.o.  Here
     in crtbegin.o, we can reference a couple of symbols not visible there.
*** gcc/config/sparc/erc32.h.orig	Mon Dec  4 15:10:39 2006
--- gcc/config/sparc/erc32.h	Mon Dec  4 15:14:58 2006
*************** Boston, MA 02110-1301, USA.  */
*** 29,34 ****
--- 29,44 ----
  #undef LIB_SPEC
  #define LIB_SPEC "-lerc32 %{!g:-lc} %{g:-lg}"
  
+ /* This target does not need support for either table based unwinding or
+    C++ constructors/destructors, so that there is no need for the
+    crtbegin/crtend and crti/crtn machinery. */
+ 
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC "crt0.o%s"
+ 
+ #undef ENDFILE_SPEC
+ #define ENDFILE_SPEC ""
+ 
  /* This target does not have MMU so that nothing needs to be done in
     order to enable the execution of code on the stack. */
  
*** gcc/config/sparc/leon.h.orig	Mon Dec  4 15:10:45 2006
--- gcc/config/sparc/leon.h	Mon Dec  4 15:14:47 2006
*************** Boston, MA 02110-1301, USA.  */
*** 29,34 ****
--- 29,44 ----
  #undef LIB_SPEC
  #define LIB_SPEC "-lleon %{!g:-lc} %{g:-lg}"
  
+ /* This target does not need support for either table based unwinding or
+    C++ constructors/destructors, so that there is no need for the
+    crtbegin/crtend and crti/crtn machinery. */
+ 
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC "crt0.o%s"
+ 
+ #undef ENDFILE_SPEC
+ #define ENDFILE_SPEC ""
+ 
  /* This target does not have MMU so that nothing needs to be done in
     order to enable the execution of code on the stack. */
  
*** gcc/config/rs6000/rs6000.c.ori	Mon Dec  4 16:31:32 2006
--- gcc/config/rs6000/rs6000.c	Mon Dec  4 16:58:32 2006
*************** char toc_label_name[10];
*** 241,246 ****
--- 241,265 ----
  /* Alias set for saves and restores from the rs6000 stack.  */
  static GTY(()) int rs6000_sr_alias_set;
  
+ /* Define a default value for INTERRUPTS_ON_CURRENT_STACK.
+ 
+    This only applies to ABI_V4 or functions with eh_return. Define to 1 if
+    interrupt handlers may not run on a separate stack, so may clobber any word
+    below sp.  Define to 0 otherwise.
+ 
+    Stack ties are used to prevent mem accesses from beeing scheduled across
+    the prologue/epilogue stack pointer adjustments.  This macro controls
+    whether we may only tie "register saves/restores" (value 0), or if we have
+    to tie any mem access so that no stack access is ever scheduled prior/past
+    the stack frame allocation/deallocation.
+ 
+    Note that this support has not been accepted in the FSF tree, who
+    considered this kind of interrupt handler behavior as an OS bug.  */
+ 
+ #ifndef INTERRUPTS_ON_CURRENT_STACK
+ #define INTERRUPTS_ON_CURRENT_STACK 0
+ #endif
+ 
  /* Control alignment for fields within structures.  */
  /* String from -malign-XXXXX.  */
  int rs6000_alignment_flags;
*************** static bool rs6000_function_ok_for_sibca
*** 577,583 ****
  static const char *rs6000_invalid_within_doloop (rtx);
  static rtx rs6000_generate_compare (enum rtx_code);
  static void rs6000_maybe_dead (rtx);
! static void rs6000_emit_stack_tie (void);
  static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);
  static rtx spe_synthesize_frame_save (rtx);
  static bool spe_func_has_64bit_regs_p (void);
--- 596,602 ----
  static const char *rs6000_invalid_within_doloop (rtx);
  static rtx rs6000_generate_compare (enum rtx_code);
  static void rs6000_maybe_dead (rtx);
! static void rs6000_emit_stack_tie (int);
  static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);
  static rtx spe_synthesize_frame_save (rtx);
  static bool spe_func_has_64bit_regs_p (void);
*************** rs6000_aix_emit_builtin_unwind_init (voi
*** 13712,13726 ****
    emit_label (no_toc_save_needed);
  }
  
! /* This ties together stack memory (MEM with an alias set of
!    rs6000_sr_alias_set) and the change to the stack pointer.  */
  
  static void
! rs6000_emit_stack_tie (void)
  {
    rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));
  
!   set_mem_alias_set (mem, rs6000_sr_alias_set);
    emit_insn (gen_stack_tie (mem));
  }
  
--- 13731,13746 ----
    emit_label (no_toc_save_needed);
  }
  
! /* Emit a stack_tie memory reference for ALIAS_SET, typically used to
!    to prevent scheduling of some memory accesses across the prologue/epilogue
!    stack pointer adjustments.  */
  
  static void
! rs6000_emit_stack_tie (int alias_set)
  {
    rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));
  
!   set_mem_alias_set (mem, alias_set);
    emit_insn (gen_stack_tie (mem));
  }
  
*************** rs6000_emit_prologue (void)
*** 14299,14306 ****
  				       || info->first_fp_reg_save < 64
  				       || info->first_gp_reg_save < 32
  				       )));
!       if (frame_reg_rtx != sp_reg_rtx)
! 	rs6000_emit_stack_tie ();
      }
  
    /* Handle world saves specially here.  */
--- 14319,14327 ----
  				       || info->first_fp_reg_save < 64
  				       || info->first_gp_reg_save < 32
  				       )));
!       if (frame_reg_rtx != sp_reg_rtx || INTERRUPTS_ON_CURRENT_STACK)
! 	rs6000_emit_stack_tie
! 	  (INTERRUPTS_ON_CURRENT_STACK ? 0 : rs6000_sr_alias_set);
      }
  
    /* Handle world saves specially here.  */
*************** rs6000_emit_epilogue (int sibcall)
*** 15280,15287 ****
    if (DEFAULT_ABI == ABI_V4
        || current_function_calls_eh_return)
      {
!       if (frame_reg_rtx != sp_reg_rtx)
! 	rs6000_emit_stack_tie ();
  
        if (use_backchain_to_restore_sp)
  	{
--- 15301,15309 ----
    if (DEFAULT_ABI == ABI_V4
        || current_function_calls_eh_return)
      {
!       if (frame_reg_rtx != sp_reg_rtx || INTERRUPTS_ON_CURRENT_STACK)
! 	rs6000_emit_stack_tie
! 	  (INTERRUPTS_ON_CURRENT_STACK ? 0 : rs6000_sr_alias_set);
  
        if (use_backchain_to_restore_sp)
  	{
*** gcc/config/rs6000/vxworks.h.ori	Mon Dec  4 16:31:47 2006
--- gcc/config/rs6000/vxworks.h	Mon Dec  4 16:50:44 2006
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 221,223 ****
--- 221,226 ----
  #undef  DWARF2_UNWIND_INFO
  #define DWARF2_UNWIND_INFO 1
  
+ /* Despite what the documentation says, experiments indicate ...  */
+ #define INTERRUPTS_ON_CURRENT_STACK 1
+ 
*** gcc/config/sparc/erc32.h.orig	Wed Dec  6 21:30:30 2006
--- gcc/config/sparc/erc32.h	Wed Dec  6 21:28:32 2006
*************** Boston, MA 02110-1301, USA.  */
*** 39,44 ****
--- 39,51 ----
  #undef ENDFILE_SPEC
  #define ENDFILE_SPEC ""
  
+ /* This platform supports software stack checking, and we will reserve
+    75 words of space for either propagating the exception (sjlj) or
+    executing a possible last chance handler. */
+ 
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 300
+ 
  /* This target does not have MMU so that nothing needs to be done in
     order to enable the execution of code on the stack. */
  
*** gcc/config/sparc/leon.h.orig	Wed Dec  6 21:30:42 2006
--- gcc/config/sparc/leon.h	Wed Dec  6 21:28:20 2006
*************** Boston, MA 02110-1301, USA.  */
*** 39,44 ****
--- 39,51 ----
  #undef ENDFILE_SPEC
  #define ENDFILE_SPEC ""
  
+ /* This platform supports software stack checking, and we will reserve
+    75 words of space for either propagating the exception (sjlj) or
+    executing a possible last chance handler. */
+ 
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 300
+ 
  /* This target does not have MMU so that nothing needs to be done in
     order to enable the execution of code on the stack. */
  
*** gcc/tree-nested.c.ori	Tue Dec  5 10:22:05 2006
--- gcc/tree-nested.c	Wed Dec  6 15:41:13 2006
*************** convert_nonlocal_reference (tree *tp, in
*** 1051,1056 ****
--- 1051,1063 ----
        walk_tree (tp, convert_nonlocal_reference, wi, NULL);
        break;
  
+     case VIEW_CONVERT_EXPR:
+       /* Just request to look at the subtrees, leaving val_only and lhs
+ 	 untouched.  This might actually be for !val_only + lhs, in which
+ 	 case we don't want to force a replacement by a temporary.  */
+       *walk_subtrees = 1;
+       break;
+ 
      default:
        if (!IS_TYPE_OR_DECL_P (t))
  	{
*************** convert_local_reference (tree *tp, int *
*** 1182,1187 ****
--- 1189,1201 ----
        wi->val_only = save_val_only;
        break;
  
+     case VIEW_CONVERT_EXPR:
+       /* Just request to look at the subtrees, leaving val_only and lhs
+ 	 untouched.  This might actually be for !val_only + lhs, in which
+ 	 case we don't want to force a replacement by a temporary.  */
+       *walk_subtrees = 1;
+       break;
+ 
      default:
        if (!IS_TYPE_OR_DECL_P (t))
  	{
*** gcc/Makefile.in.ori	Fri Dec  8 15:41:28 2006
--- gcc/Makefile.in	Fri Dec  8 15:41:56 2006
*************** stmp-multilib: $(LIBGCC_DEPS)
*** 1414,1419 ****
--- 1414,1420 ----
  	$(MAKE) \
  	  CFLAGS="$(CFLAGS) $(WARN_CFLAGS)" \
  	  CONFIG_H="$(CONFIG_H)" \
+ 	  INCLUDES="$(INCLUDES)" \
  	  MAKEOVERRIDES= \
  	  -f libgcc.mk all
  	$(STAMP) stmp-multilib
*** gcc/config/i386/i386.opt.ori	Fri Dec  8 15:00:48 2006
--- gcc/config/i386/i386.opt	Fri Dec  8 15:02:30 2006
*************** msseregparm
*** 201,206 ****
--- 201,210 ----
  Target RejectNegative Mask(SSEREGPARM)
  Use SSE register passing conventions for SF and DF mode
  
+ mstackrealign
+ Target Report Var(ix86_force_align_arg_pointer)
+ Realign stack in prologue
+ 
  msvr3-shlib
  Target Report Mask(SVR3_SHLIB)
  Uninitialized locals in .bss
*** gcc/config/i386/i386.c.ori	Tue Dec  5 14:10:15 2006
--- gcc/config/i386/i386.c	Fri Dec  8 14:59:56 2006
*************** int x86_prefetch_sse;
*** 807,812 ****
--- 807,815 ----
  /* ix86_regparm_string as a number */
  static int ix86_regparm;
  
+ static const char
+ ix86_force_align_arg_pointer_string[] = "force_align_arg_pointer";
+ 
  /* Preferred alignment for stack boundary in bits.  */
  unsigned int ix86_preferred_stack_boundary;
  
*************** const struct attribute_spec ix86_attribu
*** 1923,1928 ****
--- 1926,1935 ----
    /* Sseregparm attribute says we are using x86_64 calling conventions
       for FP arguments.  */
    { "sseregparm", 0, 0, false, true, true, ix86_handle_cconv_attribute },
+   /* force_align_arg_pointer says this function realigns the stack on
+      entry.  */
+   { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,
+     false, true,  true, ix86_handle_cconv_attribute },
  #if TARGET_DLLIMPORT_DECL_ATTRIBUTES
    { "dllimport", 0, 0, false, false, false, handle_dll_attribute },
    { "dllexport", 0, 0, false, false, false, handle_dll_attribute },
*************** ix86_handle_cconv_attribute (tree *node,
*** 2081,2086 ****
--- 2088,2102 ----
  	  *no_add_attrs = true;
  	}
  
+       if (!TARGET_64BIT
+ 	  && lookup_attribute (ix86_force_align_arg_pointer_string,
+ 			       TYPE_ATTRIBUTES (*node))
+ 	  && compare_tree_int (cst, REGPARM_MAX-1))
+ 	{
+ 	  error ("%s functions limited to %d register parameters",
+ 		 ix86_force_align_arg_pointer_string, REGPARM_MAX-1);
+ 	}
+ 
        return NULL_TREE;
      }
  
*************** ix86_function_regparm (tree type, tree d
*** 2220,2225 ****
--- 2236,2254 ----
  		  && decl_function_context (decl)
  		  && !DECL_NO_STATIC_CHAIN (decl))
  		local_regparm = 2;
+ 	      /* If the function realigns its stackpointer, the
+ 		 prologue will clobber %ecx.  If we've already
+ 		 generated code for the callee, the callee
+ 		 DECL_STRUCT_FUNCTION is gone, so we fall back to
+ 		 scanning the attributes for the self-realigning
+ 		 property.  */
+ 	      if ((DECL_STRUCT_FUNCTION (decl)
+ 		   && DECL_STRUCT_FUNCTION (decl)->machine->force_align_arg_pointer)
+ 		  || (!DECL_STRUCT_FUNCTION (decl)
+ 		      && lookup_attribute (ix86_force_align_arg_pointer_string,
+ 					   TYPE_ATTRIBUTES (TREE_TYPE (decl)))))
+ 		local_regparm = 2;
+ 
  	      /* Each global register variable increases register preassure,
  		 so the more global reg vars there are, the smaller regparm
  		 optimization use, unless requested by the user explicitly.  */
*************** pro_epilogue_adjust_stack (rtx dest, rtx
*** 5223,5233 ****
  static rtx
  ix86_internal_arg_pointer (void)
  {
!   if (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
!       && DECL_NAME (current_function_decl)
!       && MAIN_NAME_P (DECL_NAME (current_function_decl))
!       && DECL_FILE_SCOPE_P (current_function_decl))
!     {
        cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, 2);
        return copy_to_reg (cfun->machine->force_align_arg_pointer);
      }
--- 5252,5279 ----
  static rtx
  ix86_internal_arg_pointer (void)
  {
!   bool has_force_align_arg_pointer =
!     (0 != lookup_attribute (ix86_force_align_arg_pointer_string,
! 			    TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))));
!   if ((FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
!        && DECL_NAME (current_function_decl)
!        && MAIN_NAME_P (DECL_NAME (current_function_decl))
!        && DECL_FILE_SCOPE_P (current_function_decl))
!       || ix86_force_align_arg_pointer
!       || has_force_align_arg_pointer)
!     {
!       /* Nested functions can't realign the stack due to a register
! 	 conflict.  */
!       if (DECL_CONTEXT (current_function_decl)
! 	  && TREE_CODE (DECL_CONTEXT (current_function_decl)) == FUNCTION_DECL)
! 	{
! 	  if (ix86_force_align_arg_pointer)
! 	    warning (0, "-mstackrealign ignored for nested functions");
! 	  if (has_force_align_arg_pointer)
! 	    error ("%s not supported for nested functions",
! 		   ix86_force_align_arg_pointer_string);
! 	  return virtual_incoming_args_rtx;
! 	}
        cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, 2);
        return copy_to_reg (cfun->machine->force_align_arg_pointer);
      }
*** gcc/config/i386/i386.c.ori	Fri Dec  8 16:12:11 2006
--- gcc/config/i386/i386.c	Tue Dec 12 09:43:37 2006
*************** ix86_comp_type_attributes (tree type1, t
*** 2190,2195 ****
--- 2190,2241 ----
    return 1;
  }
  
+ 
+ /* The possible stack realignment needs for a function.  */
+ 
+ enum
+   { STK_REALIGN_NONEED = 0,     /* None.  */
+     STK_REALIGN_REQUESTED = 1,  /* Requested, warning on failure.  */
+     STK_REALIGN_REQUIRED  = 2   /* Required, error on failure.  */
+   };
+ 
+ /* The actual stack realignment needs for a function DECL.
+ 
+    REQUIRED for 'main' and FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN,
+             or explicit request from function specific attribute.
+ 
+    otherwise, REQUESTED if command line option for the whole unit,
+ 
+    otherwise NONEED. */
+ 
+ static int
+ ix86_stack_realignment_for (tree decl)
+ {
+   bool has_force_align_arg_pointer
+     = (0 != lookup_attribute (ix86_force_align_arg_pointer_string,
+ 			      TYPE_ATTRIBUTES (TREE_TYPE (decl))));
+   
+   if (has_force_align_arg_pointer
+       || (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
+ 	  && DECL_NAME (decl) && MAIN_NAME_P (DECL_NAME (decl))
+ 	  && DECL_FILE_SCOPE_P (decl)))
+     return STK_REALIGN_REQUIRED;
+ 
+   else if (ix86_force_align_arg_pointer)
+     return STK_REALIGN_REQUESTED;
+ 
+   else
+     return STK_REALIGN_NONEED;
+ }
+ 
+ /* Whether a function denoted by DECL needs a static chain.  */
+ 
+ static bool
+ needs_static_chain_p (tree decl)
+ {
+   return decl_function_context (decl) && !DECL_NO_STATIC_CHAIN (decl);
+ }
+ 
  /* Return the regparm value for a function with the indicated TYPE and DECL.
     DECL may be NULL when calling function indirectly
     or considering a libcall.  */
*************** ix86_function_regparm (tree type, tree d
*** 2230,2253 ****
  	      for (local_regparm = 0; local_regparm < 3; local_regparm++)
  		if (global_regs[local_regparm])
  		  break;
  	      /* We can't use regparm(3) for nested functions as these use
  		 static chain pointer in third argument.  */
  	      if (local_regparm == 3
! 		  && decl_function_context (decl)
! 		  && !DECL_NO_STATIC_CHAIN (decl))
! 		local_regparm = 2;
! 	      /* If the function realigns its stackpointer, the
! 		 prologue will clobber %ecx.  If we've already
! 		 generated code for the callee, the callee
! 		 DECL_STRUCT_FUNCTION is gone, so we fall back to
! 		 scanning the attributes for the self-realigning
! 		 property.  */
! 	      if ((DECL_STRUCT_FUNCTION (decl)
! 		   && DECL_STRUCT_FUNCTION (decl)->machine->force_align_arg_pointer)
! 		  || (!DECL_STRUCT_FUNCTION (decl)
! 		      && lookup_attribute (ix86_force_align_arg_pointer_string,
! 					   TYPE_ATTRIBUTES (TREE_TYPE (decl)))))
  		local_regparm = 2;
  
  	      /* Each global register variable increases register preassure,
  		 so the more global reg vars there are, the smaller regparm
--- 2276,2294 ----
  	      for (local_regparm = 0; local_regparm < 3; local_regparm++)
  		if (global_regs[local_regparm])
  		  break;
+ 
  	      /* We can't use regparm(3) for nested functions as these use
  		 static chain pointer in third argument.  */
  	      if (local_regparm == 3
! 		  && needs_static_chain_p (decl))
  		local_regparm = 2;
+ 	      
+ 	      /* Don't risk interfering with stack pointer realignment needs.
+ 		 We could probably do better, but it appears unlikely to be
+ 		 worth the effort.  */
+ 	      if (local_regparm > 0
+ 		  && ix86_stack_realignment_for (decl) != STK_REALIGN_NONEED)
+ 		local_regparm = 0;
  
  	      /* Each global register variable increases register preassure,
  		 so the more global reg vars there are, the smaller regparm
*************** pro_epilogue_adjust_stack (rtx dest, rtx
*** 5247,5284 ****
      RTX_FRAME_RELATED_P (insn) = 1;
  }
  
  /* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */
  
  static rtx
  ix86_internal_arg_pointer (void)
  {
!   bool has_force_align_arg_pointer =
!     (0 != lookup_attribute (ix86_force_align_arg_pointer_string,
! 			    TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))));
!   if ((FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
!        && DECL_NAME (current_function_decl)
!        && MAIN_NAME_P (DECL_NAME (current_function_decl))
!        && DECL_FILE_SCOPE_P (current_function_decl))
!       || ix86_force_align_arg_pointer
!       || has_force_align_arg_pointer)
!     {
!       /* Nested functions can't realign the stack due to a register
! 	 conflict.  */
!       if (DECL_CONTEXT (current_function_decl)
! 	  && TREE_CODE (DECL_CONTEXT (current_function_decl)) == FUNCTION_DECL)
! 	{
! 	  if (ix86_force_align_arg_pointer)
! 	    warning (0, "-mstackrealign ignored for nested functions");
! 	  if (has_force_align_arg_pointer)
! 	    error ("%s not supported for nested functions",
! 		   ix86_force_align_arg_pointer_string);
! 	  return virtual_incoming_args_rtx;
  	}
-       cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, 2);
-       return copy_to_reg (cfun->machine->force_align_arg_pointer);
      }
!   else
!     return virtual_incoming_args_rtx;
  }
  
  /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.
--- 5288,5446 ----
      RTX_FRAME_RELATED_P (insn) = 1;
  }
  
+ /* The stack realignment handling uses a scratch register to act as
+    the internal argument pointer.  This register is
+ 
+    o loaded with the argument pointer value (sp+4), as the very first
+      operation emitted by the prologue expander just before the actual
+      stack pointer realignment (see ix86_expand_prologue).
+ 
+    o included in the set of registers to be saved/restored, then used by
+      the epilogue expander past its restoration to recompute the entry stack
+      pointer value (see ix86_save_reg and ix86_expand_epilogue).
+ 
+    o used to load the arguments to their local home within the function
+      at the very start of it (via expansions from assign_parms).
+ 
+   Bottom line, a given function may use any register dead both on entry and on
+   exit for this purpose.
+ 
+   As call-clobbered registers in the base ABI, EAX, ECX and EDX are natural
+   candidates.  None of them can be used blindly, however, considering possible
+   static chains or other calling conventions constraints.
+ 
+   We have a dedicated predicate for each candidate below, intended to be
+   conservative.  For instance, they might decide to answer 'no, this reg may
+   not be used' based on the 'regparm' value but not looking at the actual
+   number of arguments the function expects.
+ 
+   This is all 32bit ABI centric as of now.  We expect not to have the need
+   in the 64bit case anyway.  */
+ 
+ /* Whether EAX (regno 0) is live on function DECL entry or exit.  */
+ 
+ static bool
+ ix86_eax_maybe_live_in_or_out (tree decl ATTRIBUTE_UNUSED, bool fastcall_p,
+ 			       int regparm, int regret)
+ {
+   return
+     (/* Maybe needed for argument passing ...
+ 	('fastcall' sets regparm to 2 and might use ecx+edx  */
+      (regparm >= 1 && !fastcall_p)
+        
+      /* or for value returning.  */
+      || regret >= 1);
+ }
+ 
+ /* Whether EDX (regno 1) is live on function DECL entry or exit.  */
+ 
+ static bool
+ ix86_edx_maybe_live_in_or_out (tree decl ATTRIBUTE_UNUSED, bool fastcall_p,
+ 			       int regparm, int regret)
+ {
+   return
+     (/* Maybe needed for argument passing ... */
+      fastcall_p || regparm >= 2
+        
+      /* or for value returning.  */
+      || regret >= 2);
+ }
+ 
+ /* Whether ECX (regno 2) is live on function DECL entry or exit.  */
+ 
+ static bool
+ ix86_ecx_maybe_live_in_or_out (tree decl, bool fastcall_p,
+ 			       int regparm, int regret ATTRIBUTE_UNUSED)
+ {
+   return
+     (/* Maybe needed for argument passing ...  */
+      fastcall_p || regparm >= 3
+      
+      /* or as the static chain register.  */
+      || needs_static_chain_p (decl));
+ }
+ 
+ /* A REGNO available for use as the internal arg pointer for stack realignment
+    purposes in function DECL, if any, -1 otherwise.  */
+ 
+ static int
+ ix86_stack_realign_arg_pointer_regno_for (tree decl)
+ {
+   tree fntype = TREE_TYPE (decl);
+ 
+   /* Precompute the info needed by the predicates ...  */
+ 
+   /* Whether the 'fastcall' convention applies.  */
+   bool fast_p 
+     = lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fntype)) != 0;
+   
+   /* How many integer registers used for argument passing.  */
+   int regparm = ix86_function_regparm (fntype, decl);
+   
+   /* How many integer registers used for value returning.  */
+   tree restype
+     = DECL_RESULT (decl) ? TREE_TYPE (DECL_RESULT (decl)) : 0;
+   
+   rtx resrtx
+     = (restype) ? ix86_function_value (restype, decl, true) : 0;
+   
+   int regret
+     = ((resrtx && REGNO (resrtx) == 0)
+        ? hard_regno_nregs[REGNO (resrtx)][GET_MODE (resrtx)] : 0);
+   
+   /* And check them all in turn. Ordering chosen from success likeliness
+      and expected cost considerations.  */
+   
+   gcc_assert (!TARGET_64BIT);
+   
+   if (!ix86_ecx_maybe_live_in_or_out (decl, fast_p, regparm, regret))
+     return 2;
+   else if (!ix86_edx_maybe_live_in_or_out (decl, fast_p, regparm, regret))
+     return 1;
+   else if (!ix86_eax_maybe_live_in_or_out (decl, fast_p, regparm, regret))
+     return 0;
+   else
+     return -1;
+ }
+ 
+ 
  /* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */
  
  static rtx
  ix86_internal_arg_pointer (void)
  {
!   /* If the current function needs to have its stack realigned, see if we can
!      find a scratch register to use as an alternate arg pointer.  */
!   int stack_realign = ix86_stack_realignment_for (current_function_decl);
! 
!   if (stack_realign != STK_REALIGN_NONEED)
!     {
!       int regno
! 	= ix86_stack_realign_arg_pointer_regno_for (current_function_decl);
! 
!       /* If we have one, assign it.  */
!       if (regno >= 0)
! 	{
! 	  cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, regno);
! 	  return copy_to_reg (cfun->machine->force_align_arg_pointer);
! 	}
!       
!       /* Otherwise, emit warning or error, depending on how hard the
! 	 realignment request is.  */
!       else 
! 	{
! 	  if (stack_realign == STK_REALIGN_REQUESTED)
! 	    warning (0, "couldn't realign stack of %q+D",
! 		     current_function_decl);
! 	  else if (stack_realign == STK_REALIGN_REQUIRED)
! 	    error ("couldn't force stack realignment of %q+D",
! 		   current_function_decl);
  	}
      }
! 
!   /* If no stack realignment was required, or if we couldn't get a suitable
!      scratch register to honor it, return the regular virtual.  */
!   return virtual_incoming_args_rtx;
  }
  
  /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.
*************** ix86_expand_prologue (void)
*** 5417,5423 ****
      {
        /* Only valid for Win32.  */
        rtx eax = gen_rtx_REG (SImode, 0);
!       bool eax_live = ix86_eax_live_at_start_p ();
        rtx t;
  
        gcc_assert (!TARGET_64BIT);
--- 5417,5427 ----
      {
        /* Only valid for Win32.  */
        rtx eax = gen_rtx_REG (SImode, 0);
!       bool eax_live
! 	= (ix86_eax_live_at_start_p ()
! 	   || (cfun->machine->force_align_arg_pointer
! 	       && REGNO (cfun->machine->force_align_arg_pointer) == 0));
!       
        rtx t;
  
        gcc_assert (!TARGET_64BIT);
*** gcc/tree-sra.c.0	2006-12-10 11:24:34.891831072 +0100
--- gcc/tree-sra.c	2006-12-10 11:39:54.327055672 +0100
*************** struct sra_walk_fns
*** 663,670 ****
    void (*init) (struct sra_elt *elt, tree value, block_stmt_iterator *bsi);
  
    /* Invoked when we have a copy between one scalarizable reference ELT
!      and one non-scalarizable reference OTHER.  IS_OUTPUT is true if ELT
!      is on the left-hand side.  */
    void (*ldst) (struct sra_elt *elt, tree other,
  		block_stmt_iterator *bsi, bool is_output);
  
--- 663,670 ----
    void (*init) (struct sra_elt *elt, tree value, block_stmt_iterator *bsi);
  
    /* Invoked when we have a copy between one scalarizable reference ELT
!      and one non-scalarizable reference OTHER without side-effects. 
!      IS_OUTPUT is true if ELT is on the left-hand side.  */
    void (*ldst) (struct sra_elt *elt, tree other,
  		block_stmt_iterator *bsi, bool is_output);
  
*************** sra_walk_modify_expr (tree expr, block_s
*** 871,877 ****
    /* If the RHS is scalarizable, handle it.  There are only two cases.  */
    if (rhs_elt)
      {
!       if (!rhs_elt->is_scalar)
  	fns->ldst (rhs_elt, lhs, bsi, false);
        else
  	fns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false, false);
--- 871,877 ----
    /* If the RHS is scalarizable, handle it.  There are only two cases.  */
    if (rhs_elt)
      {
!       if (!rhs_elt->is_scalar && !TREE_SIDE_EFFECTS (lhs))
  	fns->ldst (rhs_elt, lhs, bsi, false);
        else
  	fns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false, false);
*************** sra_walk_modify_expr (tree expr, block_s
*** 914,920 ****
  	 The lvalue requirement prevents us from trying to directly scalarize
  	 the result of a function call.  Which would result in trying to call
  	 the function multiple times, and other evil things.  */
!       else if (!lhs_elt->is_scalar && is_gimple_addressable (rhs))
  	fns->ldst (lhs_elt, rhs, bsi, true);
  
        /* Otherwise we're being used in some context that requires the
--- 914,921 ----
  	 The lvalue requirement prevents us from trying to directly scalarize
  	 the result of a function call.  Which would result in trying to call
  	 the function multiple times, and other evil things.  */
!       else if (!lhs_elt->is_scalar
! 	       && !TREE_SIDE_EFFECTS (rhs) && is_gimple_addressable (rhs))
  	fns->ldst (lhs_elt, rhs, bsi, true);
  
        /* Otherwise we're being used in some context that requires the
*** gcc/doc/invoke.texi.0	2006-12-17 10:40:53.510138816 +0100
--- gcc/doc/invoke.texi	2006-12-17 10:41:02.492773248 +0100
*************** Objective-C and Objective-C++ Dialects}.
*** 286,292 ****
  -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol
  -ftree-vectorizer-verbose=@var{n} @gol
  -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol
! -fcallgraph-info@r{[}=su@r{]} @gol
  -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
--- 286,292 ----
  -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol
  -ftree-vectorizer-verbose=@var{n} @gol
  -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol
! -fcallgraph-info@r{[}=su,da@r{]} @gol
  -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
*************** bounded part.
*** 3633,3641 ****
  Makes the compiler output callgraph information for the program, on a
  per-file basis.  The information is generated in the common VCG format.
  It can be decorated with additional, per-node and/or per-edge information,
! if a list of comma-separated markers is additionally specified; only
! @code{su} is supported for the time being and is equivalent to
! @option{-fstack-usage}.
  
  @item -fprofile-arcs
  @opindex fprofile-arcs
--- 3633,3643 ----
  Makes the compiler output callgraph information for the program, on a
  per-file basis.  The information is generated in the common VCG format.
  It can be decorated with additional, per-node and/or per-edge information,
! if a list of comma-separated markers is additionally specified.  When the
! @code{su} marker is specified, the callgraph is decorated with stack usage
! information; it is equivalent to @option{-fstack-usage}.  When the @code{da}
! marker is specified, the callgraph is decorated with information about
! dynamically allocated objects.
  
  @item -fprofile-arcs
  @opindex fprofile-arcs
*** gcc/opts.c.0	2006-12-17 10:40:53.511138664 +0100
--- gcc/opts.c	2006-12-17 10:41:02.494772944 +0100
*************** common_handle_option (size_t scode, cons
*** 842,854 ****
        break;
  
      case OPT_fcallgraph_info_:
!       if (strcmp (arg, "su") == 0)
! 	{
! 	  flag_callgraph_info |= CALLGRAPH_INFO_STACK_USAGE;
! 	  flag_stack_usage_info = 1;
! 	}
!       else
! 	return 0;
        break;
  
      case OPT_fdiagnostics_show_location_:
--- 842,866 ----
        break;
  
      case OPT_fcallgraph_info_:
!       {
! 	char *my_arg, *p;
! 	my_arg = xstrdup (arg);
! 	p = strtok (my_arg, ",");
! 	while (p)
! 	  {
! 	    if (strcmp (p, "su") == 0)
! 	      {
! 		flag_callgraph_info |= CALLGRAPH_INFO_STACK_USAGE;
! 		flag_stack_usage_info = 1;
! 	      }
! 	    else if (strcmp (p, "da") == 0)
! 	      flag_callgraph_info |= CALLGRAPH_INFO_DYNAMIC_ALLOC;
! 	    else
! 	      return 0;
! 	    p = strtok (NULL, ",");
! 	  }
! 	free (my_arg);
!       }
        break;
  
      case OPT_fdiagnostics_show_location_:
*** gcc/flags.h.0	2006-12-17 10:40:53.512138512 +0100
--- gcc/flags.h	2006-12-17 10:41:02.494772944 +0100
*************** extern enum stack_check_type flag_stack_
*** 275,282 ****
  extern int flag_stack_usage_info;
  
  /* Output callgraph information on a per-file basis.  */
! #define CALLGRAPH_INFO_NAKED        0x1
! #define CALLGRAPH_INFO_STACK_USAGE  0x2
  extern int flag_callgraph_info;
  
  /* A string that's used when a random name is required.  NULL means
--- 275,283 ----
  extern int flag_stack_usage_info;
  
  /* Output callgraph information on a per-file basis.  */
! #define CALLGRAPH_INFO_NAKED         0x1
! #define CALLGRAPH_INFO_STACK_USAGE   0x2
! #define CALLGRAPH_INFO_DYNAMIC_ALLOC 0x4
  extern int flag_callgraph_info;
  
  /* A string that's used when a random name is required.  NULL means
*** gcc/cgraph.h.0	2006-12-17 10:40:53.513138360 +0100
--- gcc/cgraph.h	2006-12-17 10:41:37.665426192 +0100
*************** struct cgraph_final_edge GTY((chain_next
*** 121,131 ****
--- 121,139 ----
    struct cgraph_final_edge *next;
  };
  
+ struct cgraph_dynamic_alloc GTY((chain_next ("%h.next")))
+ {
+   location_t location;
+   const char *name;
+   struct cgraph_dynamic_alloc *next;
+ };
+ 
  struct cgraph_final_info GTY(())
  {
    struct cgraph_final_edge *calls;
    int stack_usage_kind;
    HOST_WIDE_INT stack_usage;
+   struct cgraph_dynamic_alloc *dynamic_allocs;
    bool called;
  };
  
*************** struct cgraph_node *cgraph_node (tree);
*** 261,266 ****
--- 269,275 ----
  struct cgraph_node *cgraph_node_for_asm (tree asmname);
  struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);
  void cgraph_final_record_call (tree, tree, tree);
+ void cgraph_final_record_dynamic_alloc (tree, tree);
  struct cgraph_local_info *cgraph_local_info (tree);
  struct cgraph_global_info *cgraph_global_info (tree);
  struct cgraph_rtl_info *cgraph_rtl_info (tree);
*** gcc/cgraph.c.0	2006-12-17 10:40:53.514138208 +0100
--- gcc/cgraph.c	2006-12-17 10:41:02.496772640 +0100
*************** cgraph_final_record_call (tree source, t
*** 550,555 ****
--- 550,574 ----
    (void) final_create_edge (cgraph_node (source), callee, stmt);
  }
  
+ /* Record a dynamically-allocated DECL in the final cgraph of FNDECL.  */
+ 
+ void
+ cgraph_final_record_dynamic_alloc (tree fndecl, tree decl)
+ {
+   const char *dot;
+   struct cgraph_final_info *cfi = cgraph_final_info (fndecl);
+   struct cgraph_dynamic_alloc *cda
+     = ggc_alloc (sizeof (struct cgraph_dynamic_alloc));
+   cda->location = DECL_SOURCE_LOCATION (decl);
+   cda->name = lang_hooks.decl_printable_name (decl, 2);
+   dot = strrchr (cda->name, '.');
+   if (dot)
+     cda->name = dot + 1;
+   cda->name = ggc_strdup (cda->name);
+   cda->next = cfi->dynamic_allocs;
+   cfi->dynamic_allocs = cda;
+ }
+ 
  /* Return local info for the compiled function.  */
  
  struct cgraph_local_info *
*************** dump_cgraph_final_node_vcg (FILE *f, str
*** 818,823 ****
--- 837,881 ----
  	fputs ("\\n0 bytes", f);
      }
  
+   if (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC)
+     {
+       if (node->final->dynamic_allocs)
+ 	{
+ 	  struct cgraph_dynamic_alloc *cda, *next;
+ 	  unsigned int count = 1;
+ 
+ 	  /* Reverse the linked list and count members.  */
+ 	  cda = node->final->dynamic_allocs;
+ 	  next = cda->next;
+ 	  cda->next = NULL;
+ 	  while (next)
+ 	    {
+ 	      struct cgraph_dynamic_alloc *tmp = next;
+ 	      next = next->next;
+ 	      tmp->next = cda;
+ 	      cda = tmp;
+ 	      count++;
+ 	    }
+ 	  node->final->dynamic_allocs = cda;
+ 
+ 	  fprintf (f, "\\n%d dynamic objects", count);
+ 
+ 	  for (cda = node->final->dynamic_allocs; cda; cda = cda->next)
+ 	    {
+ 	      expanded_location s = expand_location (cda->location);
+ 	      fprintf (f, "\\n %s", cda->name);
+ #ifdef USE_MAPPED_LOCATION
+ 	      if (flag_show_column && s.column != 0)
+ 		fprintf (f, " %s:%d:%d", s.file, s.line, s.column);
+ 	      else
+ #endif
+ 		fprintf (f, " %s:%d", s.file, s.line);
+ 	    }
+ 	}
+       else
+ 	fputs ("\\n0 dynamic objects", f);
+     }
+ 
    fputs ("\" }\n", f);
  
    for (edge = node->final->calls; edge; edge = edge->next)
*** gcc/gimplify.c.0	2006-12-17 10:40:53.518137600 +0100
--- gcc/gimplify.c	2006-12-17 10:41:02.500772032 +0100
*************** gimplify_decl_expr (tree *stmt_p)
*** 1138,1143 ****
--- 1138,1146 ----
  	  /* Indicate that we need to restore the stack level when the
  	     enclosing BIND_EXPR is exited.  */
  	  gimplify_ctxp->save_stack = true;
+ 
+ 	  if (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC)
+ 	    cgraph_final_record_dynamic_alloc (current_function_decl, decl);
  	}
  
        if (init && init != error_mark_node)
*** gcc/config/i386/freebsd.h	Sat Nov 19 19:37:59 2005
--- gcc/config/i386/freebsd.h	Mon Dec 18 14:53:36 2006
***************
*** 135,141 ****
  #undef  DEFAULT_PCC_STRUCT_RETURN
  #define DEFAULT_PCC_STRUCT_RETURN 0
  
! /* FreeBSD sets the rounding precision of the FPU to 53 bits.  Let the
!    compiler get the contents of <float.h> and std::numeric_limits correct.  */
! #undef TARGET_96_ROUND_53_LONG_DOUBLE
! #define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)
--- 135,142 ----
  #undef  DEFAULT_PCC_STRUCT_RETURN
  #define DEFAULT_PCC_STRUCT_RETURN 0
  
! /* FreeBSD sets the rounding precision of the FPU to 53 bits, but GNAT
!    resets it to full precision. */
! #define TARGET_96_ROUND_53_LONG_DOUBLE 0
! 
! #define MD_UNWIND_SUPPORT "config/i386/freebsd-unwind.h"
*** gcc/config/i386/freebsd-unwind.h	Mon Dec 18 15:44:59 2006
--- gcc/config/i386/freebsd-unwind.h	Mon Dec 18 14:52:30 2006
***************
*** 0 ****
--- 1,91 ----
+ /* DWARF2 EH unwinding support for x86-freebsd
+    Copyright (C) 2004, 2005, 2006, Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs. */
+ 
+ #include <signal.h>
+ #include <sys/ucontext.h>
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR x86_freebsd_fallback_frame_state
+ 
+ static _Unwind_Reason_Code
+ x86_freebsd_fallback_frame_state
+ (struct _Unwind_Context *CONTEXT, _Unwind_FrameState *FS)
+ {
+     unsigned char *pc_ = (CONTEXT)->ra;
+     struct sigcontext *sc_;
+     long new_cfa_;
+ 
+     /* Standard sigcode */
+     /*  movl $SYS_sigreturn, %eax; pushl %eax; int $0x80 */
+     if (*(unsigned int *)(pc_+17) == 0x0001a1b8
+ 	&& *(unsigned char *)(pc_+22) == 0x50
+ 	&& *(unsigned short *)(pc_+23) == 0x80cd) {
+       sc_ = (CONTEXT)->cfa + 32;
+ 
+     /* libpthread _thr_sig_handler */
+     /* if ((sa_flags & SA_SIGINFO) != 0 || ... )
+                         (*(sigfunc))(sig, info, ucp); */
+ 
+     } else if (*(unsigned int *)(pc_-26) == 0x400446f6
+       && *(unsigned short *)(pc_-2) == 0x16ff
+       && *(unsigned short *)(pc_) == 0xc483
+       && *(unsigned char *)(pc_+2) == 0x10) {
+       sc_ = (CONTEXT)->cfa + 544;
+ 
+     /* No match */
+     } else {
+       return _URC_END_OF_STACK;
+     }
+ 
+     new_cfa_ = sc_->sc_esp;
+     (FS)->cfa_how = CFA_REG_OFFSET;
+     (FS)->cfa_reg = __builtin_dwarf_sp_column ();
+     (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;
+ 
+     /* The SVR4 register numbering macros aren't usable in libgcc.  */
+     (FS)->regs.reg[0].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[0].loc.offset = (long)&sc_->sc_eax - new_cfa_;
+     (FS)->regs.reg[3].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[3].loc.offset = (long)&sc_->sc_ebx - new_cfa_;
+     (FS)->regs.reg[1].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[1].loc.offset = (long)&sc_->sc_ecx - new_cfa_;
+     (FS)->regs.reg[2].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[2].loc.offset = (long)&sc_->sc_edx - new_cfa_;
+     (FS)->regs.reg[6].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[6].loc.offset = (long)&sc_->sc_esi - new_cfa_;
+     (FS)->regs.reg[7].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[7].loc.offset = (long)&sc_->sc_edi - new_cfa_;
+     (FS)->regs.reg[5].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[5].loc.offset = (long)&sc_->sc_ebp - new_cfa_;
+     (FS)->regs.reg[8].how = REG_SAVED_OFFSET;
+     (FS)->regs.reg[8].loc.offset = (long)&sc_->sc_eip - new_cfa_;
+     (FS)->retaddr_column = 8;
+     return _URC_NO_REASON;
+ }
*** gcc/gcc.c.old	Mon Dec 18 16:53:40 2006
--- gcc/gcc.c	Mon Dec 18 16:58:04 2006
***************
*** 2876,2883 ****
  #endif
  	      fatal ("\
  Internal error: %s (program %s)\n\
! Please submit a full bug report.\n\
! See %s for instructions.",
  		     strsignal (WTERMSIG (status)), commands[i].prog,
  		     bug_report_url);
  	    signal_count++;
--- 2876,2884 ----
  #endif
  	      fatal ("\
  Internal error: %s (program %s)\n\
! Please submit a full bug report to\n\
! %s\n\
! with preprocessed source if appropriate.",
  		     strsignal (WTERMSIG (status)), commands[i].prog,
  		     bug_report_url);
  	    signal_count++;
***************
*** 6367,6373 ****
  
        if (! verbose_flag)
  	{
! 	  printf (_("\nFor bug reporting instructions, please see:\n"));
  	  printf ("%s.\n", bug_report_url);
  
  	  return (0);
--- 6368,6376 ----
  
        if (! verbose_flag)
  	{
! 	  printf (_("\nPlease submit a full bug report,\n\
! with preprocessed source if appropriate, \n\
! to:\n"));
  	  printf ("%s.\n", bug_report_url);
  
  	  return (0);
***************
*** 6659,6665 ****
  
    if (print_help_list)
      {
!       printf (("\nFor bug reporting instructions, please see:\n"));
        printf ("%s\n", bug_report_url);
      }
  
--- 6662,6670 ----
  
    if (print_help_list)
      {
!       printf (("\nPlease submit a full bug report,\n\
! with preprocessed source if appropriate, \n\
! to:\n"));
        printf ("%s\n", bug_report_url);
      }
  
*** gcc/version.c.old	Mon Dec 18 16:53:35 2006
--- gcc/version.c	Mon Dec 18 16:55:35 2006
***************
*** 17,23 ****
     forward us bugs reported to you, if you determine that they are
     not bugs in your modifications.)  */
  
! const char bug_report_url[] = "<URL:http://gcc.gnu.org/bugs.html>";
  
  /* The complete version string, assembled from several pieces.
     BASEVER, DATESTAMP, and DEVPHASE are defined by the Makefile.  */
--- 17,23 ----
     forward us bugs reported to you, if you determine that they are
     not bugs in your modifications.)  */
  
! const char bug_report_url[] = "<URL:mailto:report@adacore.com>";
  
  /* The complete version string, assembled from several pieces.
     BASEVER, DATESTAMP, and DEVPHASE are defined by the Makefile.  */
*** gcc/gcov.c.old	Mon Dec 18 16:53:48 2006
--- gcc/gcov.c	Mon Dec 18 16:58:51 2006
***************
*** 431,437 ****
    fnotice (file, "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n");
    fnotice (file, "  -p, --preserve-paths            Preserve all pathname components\n");
    fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
!   fnotice (file, "\nFor bug reporting instructions, please see:\n%s.\n",
  	   bug_report_url);
    exit (status);
  }
--- 431,437 ----
    fnotice (file, "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n");
    fnotice (file, "  -p, --preserve-paths            Preserve all pathname components\n");
    fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
!   fnotice (file, "\nFor bug reporting instructions, please contact:\n%s.\n",
  	   bug_report_url);
    exit (status);
  }
*** gcc/doc/tm.texi.ori	Thu Dec 21 17:52:34 2006
--- gcc/doc/tm.texi	Thu Dec 21 22:29:56 2006
*************** Dwarf 2 frame information.  If @code{DWA
*** 8217,8222 ****
--- 8217,8230 ----
  information not matter how you define @code{DWARF2_FRAME_INFO}.
  @end defmac
  
+ @defmac DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET
+ Define this macro to evaluate to a nonzero value if GCC should refrain
+ from generating location lists in DWARF2 debug information, for instance
+ if your target is stuck with an old version of GDB that is unable to
+ process them properly. This automatically disables variable tracking, with
+ a warning if it has been requested explicitly.
+ @end defmac
+ 
  @defmac DWARF2_ASM_LINE_DEBUG_INFO
  Define this macro to be a nonzero value if the assembler can generate Dwarf 2
  line debug info sections.  This will result in much more compact line number
*** gcc/dwarf2out.c.ori	Thu Dec 14 11:11:00 2006
--- gcc/dwarf2out.c	Thu Dec 21 22:29:10 2006
*************** add_location_or_const_value_attribute (d
*** 10239,10245 ****
    gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL
  	      || TREE_CODE (decl) == RESULT_DECL);
  	     
!   /* See if we possibly have multiple locations for this variable.  */
    loc_list = lookup_decl_loc (decl);
  
    /* If it truly has multiple locations, the first and last node will
--- 10239,10247 ----
    gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL
  	      || TREE_CODE (decl) == RESULT_DECL);
  	     
!   /* See if we possibly have multiple locations for this variable.  We expect
!      the call to always return 0 when var-tracking is disabled and the latter
!      to be enforced if DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET.  */
    loc_list = lookup_decl_loc (decl);
  
    /* If it truly has multiple locations, the first and last node will
*************** gen_subprogram_die (tree decl, dw_die_re
*** 11698,11729 ****
        add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);
  #endif
  
!       /* We define the "frame base" as the function's CFA.  This is more
! 	 convenient for several reasons: (1) It's stable across the prologue
! 	 and epilogue, which makes it better than just a frame pointer,
! 	 (2) With dwarf3, there exists a one-byte encoding that allows us
! 	 to reference the .debug_frame data by proxy, but failing that,
! 	 (3) We can at least reuse the code inspection and interpretation
! 	 code that determines the CFA position at various points in the
! 	 function.  */
!       /* ??? Use some command-line or configury switch to enable the use
! 	 of dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf
! 	 consumers that understand it; fall back to "pure" dwarf2 and
! 	 convert the CFA data into a location list.  */
!       {
! 	dw_loc_list_ref list = convert_cfa_to_loc_list ();
! 	if (list->dw_loc_next)
! 	  add_AT_loc_list (subr_die, DW_AT_frame_base, list);
! 	else
! 	  add_AT_loc (subr_die, DW_AT_frame_base, list->expr);
!       }
  
!       /* Compute a displacement from the "steady-state frame pointer" to
! 	 the CFA.  The former is what all stack slots and argument slots
! 	 will reference in the rtl; the later is what we've told the 
! 	 debugger about.  We'll need to adjust all frame_base references
! 	 by this displacement.  */
!       compute_frame_pointer_to_cfa_displacement ();
  
        if (cfun->static_chain_decl)
  	add_AT_location_description (subr_die, DW_AT_static_link,
--- 11700,11752 ----
        add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);
  #endif
  
!       /* On targets where there is proper support for DWARF2 locations list,
! 	 convert the CFA data into this form and define this as the function's
! 	 "frame base".
! 
! 	 Having the function's CFA as the "frame base" is more convenient for
! 	 several reasons: (1) It's stable across the prologue and epilogue,
! 	 which makes it better than just a frame pointer, (2) With dwarf3,
! 	 there exists a one-byte encoding that allows us to reference the
! 	 .debug_frame data by proxy, but failing that, (3) We can at least
! 	 reuse the code inspection and interpretation code that determines the
! 	 CFA position at various points in the function.
!       
! 	 ??? Use some command-line or configury switch to enable the use of
! 	 dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf consumers
! 	 that understand it;  */
!       if (!DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET)
! 	{
! 	  dw_loc_list_ref list = convert_cfa_to_loc_list ();
! 	  if (list->dw_loc_next)
! 	    add_AT_loc_list (subr_die, DW_AT_frame_base, list);
! 	  else
! 	    add_AT_loc (subr_die, DW_AT_frame_base, list->expr);
  
! 	  /* Compute a displacement from the "steady-state frame pointer" to
! 	     the CFA.  The former is what all stack slots and argument slots
! 	     will reference in the rtl; the later is what we've told the 
! 	     debugger about.  We'll need to adjust all frame_base references
! 	     by this displacement.  */
! 	  compute_frame_pointer_to_cfa_displacement ();
! 	}
!       
!       /* On other targets, use the frame pointer or stack pointer registers,
! 	 since the RTL for local variables is relative to one of them.  This
! 	 yields inaccurate debug info for prologue instructions but there is
! 	 not much we can do about this on such targets.  */
!       else
! 	{
! 	  rtx fp_reg
! 	    = (frame_pointer_needed
! 	       ? hard_frame_pointer_rtx : stack_pointer_rtx);
! 
! 	  add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));
! 
! 	  /* Since "frame base" is not the CFA, neutralize the corresponding
! 	     fbreg relative adjustments.  */
! 	  frame_pointer_cfa_offset = 0;
! 	}
  
        if (cfun->static_chain_decl)
  	add_AT_location_description (subr_die, DW_AT_static_link,
*** gcc/defaults.h.ori	Thu Dec 21 18:03:40 2006
--- gcc/defaults.h	Thu Dec 21 21:47:47 2006
*************** Software Foundation, 51 Franklin Street,
*** 595,600 ****
--- 595,607 ----
  #define PREFERRED_DEBUGGING_TYPE NO_DEBUG
  #endif
  
+ /* For DWARF2, assume there is proper support for location lists on the
+    target by default.  */
+ #if defined (DWARF2_DEBUGGING_INFO) \
+     && !defined (DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET)
+ #define DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET 0
+ #endif
+ 
  /* Define codes for all the float formats that we know of.  */
  #define UNKNOWN_FLOAT_FORMAT 0
  #define IEEE_FLOAT_FORMAT 1
*** gcc/toplev.c.ori	Thu Dec 21 21:57:36 2006
--- gcc/toplev.c	Thu Dec 21 22:29:32 2006
*************** process_options (void)
*** 1776,1781 ****
--- 1776,1796 ----
    /* Now we know which debug output will be used so we can set
       flag_var_tracking, flag_rename_registers if the user has
       not specified them.  */
+ 
+   /* var_tracking relies on location lists support for DWARF2, for which a
+      target might not have full support.  Honor this.  */
+ #ifdef DWARF2_DEBUGGING_INFO
+   if (write_symbols == DWARF2_DEBUG
+       && DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET)
+     {
+       if (flag_var_tracking == 1)
+ 	warning (0, "variable tracking requested, but not supported "
+ 		 "in this configuration");
+ 
+       flag_var_tracking = 0;
+     }
+ #endif
+   
    if (debug_info_level < DINFO_LEVEL_NORMAL
        || debug_hooks->var_location == do_nothing_debug_hooks.var_location)
      {
*** gcc/gcc.c.old	Thu Jan  4 12:41:45 2007
--- gcc/gcc.c	Thu Jan  4 12:45:40 2007
***************
*** 3423,3430 ****
  	  printf (_("%s (GCC) %s\n"), programname, version_string);
  	  printf ("Copyright %s 2006 Free Software Foundation, Inc.\n",
  		  _("(C)"));
! 	  fputs (_("This is free software; see the source for copying conditions.  There is NO\n\
! warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"),
  		 stdout);
  	  exit (0);
  	}
--- 3423,3433 ----
  	  printf (_("%s (GCC) %s\n"), programname, version_string);
  	  printf ("Copyright %s 2006 Free Software Foundation, Inc.\n",
  		  _("(C)"));
! 	  fputs (_("This is free software; see the source for copying conditions.\n\
! See your AdaCore support agreement for details of warranty and support.\n\
! If you do not have a current support agreement, then there is absolutely\n\
! no warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR\n\
! PURPOSE.\n\n"),
  		 stdout);
  	  exit (0);
  	}
*** gcc/config/i386/i386.h.ori	Wed Jan 10 14:55:59 2007
--- gcc/config/i386/i386.h	Wed Jan 10 14:56:45 2007
*************** typedef struct ix86_args {
*** 1532,1539 ****
  #define FUNCTION_PROFILER(FILE, LABELNO) x86_function_profiler (FILE, LABELNO)
  
  #define MCOUNT_NAME "_mcount"
  
! #define PROFILE_COUNT_REGISTER "edx"
  
  /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
     the stack pointer does not matter.  The value is tested only in
--- 1532,1541 ----
  #define FUNCTION_PROFILER(FILE, LABELNO) x86_function_profiler (FILE, LABELNO)
  
  #define MCOUNT_NAME "_mcount"
+ #define PROFILE_COUNT_REGNUM 1  /* edx */
  
! /* Assume mcount preserves all regs by default.  */
! #define MCOUNT_PRESERVES_ALL_REGS 1
  
  /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
     the stack pointer does not matter.  The value is tested only in
*** gcc/config/i386/i386.c.ori	Wed Dec 13 11:09:03 2006
--- gcc/config/i386/i386.c	Wed Jan 10 14:50:28 2007
*************** x86_field_alignment (tree field, int com
*** 17722,17763 ****
    return computed;
  }
  
! /* Output assembler code to FILE to increment profiler label # LABELNO
!    for profiling a function entry.  */
! void
! x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
  {
!   if (TARGET_64BIT)
!     if (flag_pic)
!       {
! #ifndef NO_PROFILE_COUNTERS
  	fprintf (file, "\tleaq\t%sP%d@(%%rip),%%r11\n", LPREFIX, labelno);
! #endif
! 	fprintf (file, "\tcall\t*%s@GOTPCREL(%%rip)\n", MCOUNT_NAME);
!       }
!     else
!       {
! #ifndef NO_PROFILE_COUNTERS
  	fprintf (file, "\tmovq\t$%sP%d,%%r11\n", LPREFIX, labelno);
! #endif
! 	fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
!       }
!   else if (flag_pic)
      {
! #ifndef NO_PROFILE_COUNTERS
!       fprintf (file, "\tleal\t%sP%d@GOTOFF(%%ebx),%%%s\n",
! 	       LPREFIX, labelno, PROFILE_COUNT_REGISTER);
! #endif
        fprintf (file, "\tcall\t*%s@GOT(%%ebx)\n", MCOUNT_NAME);
      }
    else
      {
! #ifndef NO_PROFILE_COUNTERS
!       fprintf (file, "\tmovl\t$%sP%d,%%%s\n", LPREFIX, labelno,
! 	       PROFILE_COUNT_REGISTER);
! #endif
        fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
      }
  }
  
  /* We don't have exact information about the insn sizes, but we may assume
--- 17722,17820 ----
    return computed;
  }
  
! /* Variants of x86_function_profiler for the 32/64bit ABIs.  Output assembler
!    code to FILE to increment profiler label # LABELNO for profiling a function
!    entry.  */
! 
! /* We'll need to check several times if NO_PROFILE_COUNTERS is #defined and
!    using preprocessor directives everywhere really impairs readability.  */
! #ifdef NO_PROFILE_COUNTERS
! #define X86_SET_PROFILE_COUNTERS 0
! #else
! #define X86_SET_PROFILE_COUNTERS 1
! #endif
! 
! /* 64bit ABI implementation.  */
! static void
! x86_64_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
  {
!   if (flag_pic)
!     {
!       if (X86_SET_PROFILE_COUNTERS)
  	fprintf (file, "\tleaq\t%sP%d@(%%rip),%%r11\n", LPREFIX, labelno);
!       fprintf (file, "\tcall\t*%s@GOTPCREL(%%rip)\n", MCOUNT_NAME);
!     }
!   else
!     {
!       if (X86_SET_PROFILE_COUNTERS)
  	fprintf (file, "\tmovq\t$%sP%d,%%r11\n", LPREFIX, labelno);
!       fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
!     }
! }
! 
! /* 32bit ABI implementation.  */
! static void
! x86_32_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
! {
!   /* We must be careful not to clobber the internal arg pointer used for stack
!      realignment purposes, if any.  This could happen in two different ways
!      from the code we emit below:  calling a careless 'mcount', which doesn't
!      save/restore the ABI caller-saved registers, or moving a value into the
!      PROFILE_COUNT register.  */
! 
!   /* Register to be preserved, set to the proper number if there is a forced
!      internal arg pointer for the current function and we need to push/pop it
!      around the profiling code per se.  */
!   unsigned int reg_to_preserve = INVALID_REGNUM;
! 
!   if (cfun->machine->force_align_arg_pointer)
!     reg_to_preserve = REGNO (cfun->machine->force_align_arg_pointer);
!   
!   /* No action is actually needed if mcount is safe and we're not going
!      to clobber ourselves.  */
!   if (reg_to_preserve != INVALID_REGNUM
!       && MCOUNT_PRESERVES_ALL_REGS
!       && (! X86_SET_PROFILE_COUNTERS
! 	  || reg_to_preserve != PROFILE_COUNT_REGNUM))
!     reg_to_preserve = INVALID_REGNUM;
! 
!   /* Push reg we need to preserve, if any.  */
!   if (reg_to_preserve != INVALID_REGNUM)
!     ASM_OUTPUT_REG_PUSH (file, reg_to_preserve);
! 
!   /* Emit the profiling code per se.  */
!   if (flag_pic)
      {
!       if (X86_SET_PROFILE_COUNTERS)
! 	fprintf (file, "\tleal\t%sP%d@GOTOFF(%%ebx),%%e%s\n",
! 		 LPREFIX, labelno, reg_names [PROFILE_COUNT_REGNUM]);
! 
        fprintf (file, "\tcall\t*%s@GOT(%%ebx)\n", MCOUNT_NAME);
      }
    else
      {
!       if (X86_SET_PROFILE_COUNTERS)
! 	fprintf (file, "\tmovl\t$%sP%d,%%e%s\n",
! 		 LPREFIX, labelno, reg_names [PROFILE_COUNT_REGNUM]);
! 
        fprintf (file, "\tcall\t%s\n", MCOUNT_NAME);
      }
+ 
+   /* Pop reg we need to preserve, if any.  */
+   if (reg_to_preserve != INVALID_REGNUM)
+     ASM_OUTPUT_REG_POP (file, reg_to_preserve);
+ }
+ 
+ /* Output assembler code to FILE to increment profiler label # LABELNO for
+    profiling a function entry.  FUNCTION_PROFILER gate to either the 64bit or
+    the 32bit helper above.  */
+ void
+ x86_function_profiler (FILE *file, int labelno)
+ {
+   if (TARGET_64BIT)
+     x86_64_function_profiler (file, labelno);
+   else
+     x86_32_function_profiler (file, labelno);
  }
  
  /* We don't have exact information about the insn sizes, but we may assume
*** gcc/config/i386/sol2.h.ori	Wed Jan 10 12:01:05 2007
--- gcc/config/i386/sol2.h	Wed Jan 10 12:03:18 2007
*************** Boston, MA 02110-1301, USA.  */
*** 111,113 ****
--- 111,118 ----
  /* We do not need NT_VERSION notes.  */
  #undef X86_FILE_START_VERSION_DIRECTIVE
  #define X86_FILE_START_VERSION_DIRECTIVE false
+ 
+ /* mcount may clobber caller-saved registers, so ...  */
+ #undef  MCOUNT_PRESERVES_ALL_REGS
+ #define MCOUNT_PRESERVES_ALL_REGS 0
+ 
*** gcc/config/i386/freebsd.h.ori	Wed Jan 10 23:10:46 2007
--- gcc/config/i386/freebsd.h	Wed Jan 10 23:12:45 2007
*************** Boston, MA 02110-1301, USA.  */
*** 47,52 ****
--- 47,56 ----
  #undef  MCOUNT_NAME
  #define MCOUNT_NAME ".mcount"
  
+ /* mcount may clobber caller-saved registers, so ...  */
+ #undef  MCOUNT_PRESERVES_ALL_REGS
+ #define MCOUNT_PRESERVES_ALL_REGS 0
+ 
  /* Make gcc agree with <machine/ansi.h>.  */
  
  #undef  SIZE_TYPE
*** gcc/dwarf2out.c.0	2007-01-11 11:54:00.362921136 +0100
--- gcc/dwarf2out.c	2007-01-11 12:48:53.545281320 +0100
*************** simple_field_decl_align_in_bits (tree fi
*** 9505,9510 ****
--- 9505,9528 ----
    return (TREE_CODE (decl) != ERROR_MARK) ? DECL_ALIGN (decl) : BITS_PER_WORD;
  }
  
+ /* Return the result of rounding T up to ALIGN.  */
+ 
+ static inline HOST_WIDE_INT
+ round_up_to_align (HOST_WIDE_INT t, unsigned int align)
+ {
+   /* We must be careful if T is negative because HOST_WIDE_INT can be
+      either "above" or "below" unsigned int as per the C promotion
+      rules, depending on the host, thus making the signedness of the
+      direct multiplication and division unpredictable.  */
+   unsigned HOST_WIDE_INT u = (unsigned HOST_WIDE_INT) t;
+ 
+   u += align - 1;
+   u /= align;
+   u *= align;
+ 
+   return (HOST_WIDE_INT) u;
+ }
+ 
  /* Given a pointer to a FIELD_DECL, compute and return the byte offset of the
     lowest addressed byte of the "containing object" for the given FIELD_DECL,
     or return 0 if we are unable to determine what that offset is, either
*************** field_byte_offset (tree decl)
*** 9604,9612 ****
    object_offset_in_bits = deepest_bitpos - type_size_in_bits;
  
    /* Round up to type_align by default.  This works best for bitfields.  */
!   object_offset_in_bits += type_align_in_bits - 1;
!   object_offset_in_bits /= type_align_in_bits;
!   object_offset_in_bits *= type_align_in_bits;
  
    if (object_offset_in_bits > bitpos_int)
      {
--- 9622,9629 ----
    object_offset_in_bits = deepest_bitpos - type_size_in_bits;
  
    /* Round up to type_align by default.  This works best for bitfields.  */
!   object_offset_in_bits
!     = round_up_to_align (object_offset_in_bits, type_align_in_bits);
  
    if (object_offset_in_bits > bitpos_int)
      {
*************** field_byte_offset (tree decl)
*** 9614,9622 ****
        object_offset_in_bits = deepest_bitpos - type_size_in_bits;
  
        /* Round up to decl_align instead.  */
!       object_offset_in_bits += decl_align_in_bits - 1;
!       object_offset_in_bits /= decl_align_in_bits;
!       object_offset_in_bits *= decl_align_in_bits;
      }
  
    return object_offset_in_bits / BITS_PER_UNIT;
--- 9631,9638 ----
        object_offset_in_bits = deepest_bitpos - type_size_in_bits;
  
        /* Round up to decl_align instead.  */
!       object_offset_in_bits
! 	= round_up_to_align (object_offset_in_bits, decl_align_in_bits);
      }
  
    return object_offset_in_bits / BITS_PER_UNIT;
*** configure.in.old	Fri Jan 12 12:06:25 2007
--- configure.in	Fri Jan 12 12:06:20 2007
***************
*** 706,711 ****
--- 706,714 ----
    powerpc-*-eabi)
      noconfigdirs="$noconfigdirs ${libgcj}"
      ;;
+   powerpc-*-eabispe)
+     noconfigdirs="$noconfigdirs ${libgcj}"
+     ;;
    powerpc-*-eabi* | powerpcle-*-eabi* | powerpc-*-rtems* )
      ;;
    rs6000-*-lynxos*)
*** configure.old	Fri Jan 12 13:24:00 2007
--- configure	Fri Jan 12 13:23:54 2007
***************
*** 1498,1503 ****
--- 1498,1506 ----
    powerpc-*-eabi)
      noconfigdirs="$noconfigdirs ${libgcj}"
      ;;
+   powerpc-*-eabispe)
+     noconfigdirs="$noconfigdirs ${libgcj}"
+     ;;
    powerpc-*-eabi* | powerpcle-*-eabi* | powerpc-*-rtems* )
      ;;
    rs6000-*-lynxos*)
*** gcc/config/i386/vxworks.h.orig	Tue Dec 19 09:44:24 2006
--- gcc/config/i386/vxworks.h	Tue Jan 16 11:01:04 2007
*************** Boston, MA 02110-1301, USA.  */
*** 24,29 ****
--- 24,34 ----
  #undef  TARGET_VERSION
  #define TARGET_VERSION fprintf (stderr, " (80586, VxWorks syntax)");
  
+ #undef  CC1_SPEC
+ #define CC1_SPEC					\
+ "%(cc1_cpu)"						\
+ VXWORKS_STACK_CHECK_SPEC
+ 
  #undef  ASM_SPEC
  #define ASM_SPEC "%{v:-v} %{Qy:} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}"
  
*************** Boston, MA 02110-1301, USA.  */
*** 83,85 ****
--- 88,98 ----
  /* No _mcount profiling on VxWorks.  */
  #undef FUNCTION_PROFILER
  #define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)
+ 
+ /* This platform supports the probing method of stack checking (RTP mode)
+    and the ZCX mechanism. 8K is reserved in the stack to propagate
+    exceptions reliably in case of stack overflow. */
+ #define STACK_CHECK_PROTECT 8192
+ 
+ /* Static stack checking is supported only in RTP mode */
+ #define VXWORKS_STACK_CHECK_SPEC "%{fstack-check:%{!mrtp:-fold-stack-check}}"
*** gcc/config/i386/vxworksae.h.orig	Tue Jan 16 12:00:16 2007
--- gcc/config/i386/vxworksae.h	Tue Jan 16 12:00:49 2007
*************** Boston, MA 02110-1301, USA.  */
*** 25,27 ****
--- 25,36 ----
    do						\
      builtin_define ("CPU=SIMNT");		\
    while (0)
+ 
+ /* This platform supports the probing method of stack checking and
+    requires 4K of space for executing a possible last chance handler.  */
+ #undef STACK_CHECK_PROTECT
+ #define STACK_CHECK_PROTECT 4096
+ 
+ /* Static stack checking is supported unconditionally.  */
+ #undef VXWORKS_STACK_CHECK_SPEC
+ #define VXWORKS_STACK_CHECK_SPEC
*** gcc/config/rs6000/vxworks.h.orig	Tue Dec 19 09:44:37 2006
--- gcc/config/rs6000/vxworks.h	Tue Jan 16 11:00:19 2007
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 90,96 ****
  "%{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}	\
   %{mlittle|mlittle-endian:-mstrict-align}			\
   %{profile: -p}		\
!  %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}"
  
  #define ASM_SPEC \
  "%(asm_cpu) \
--- 90,97 ----
  "%{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}	\
   %{mlittle|mlittle-endian:-mstrict-align}			\
   %{profile: -p}		\
!  %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}"	\
! VXWORKS_STACK_CHECK_SPEC
  
  #define ASM_SPEC \
  "%(asm_cpu) \
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 224,226 ****
--- 225,235 ----
  /* Despite what the documentation says, experiments indicate ...  */
  #define INTERRUPTS_ON_CURRENT_STACK 1
  
+ /* This platform supports the probing method of stack checking (RTP mode)
+    and the ZCX mechanism. 8K is reserved in the stack to propagate
+    exceptions reliably in case of stack overflow. */
+ #define STACK_CHECK_PROTECT 8192
+ 
+ /* Static stack checking is supported only in RTP mode.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ #define VXWORKS_STACK_CHECK_SPEC "%{fstack-check:%{!mrtp:-fold-stack-check}}"
*** gcc/config/rs6000/vxworksae.h.orig	Tue Dec 19 09:44:35 2006
--- gcc/config/rs6000/vxworksae.h	Tue Jan 16 11:59:31 2007
*************** Software Foundation, 51 Franklin Street,
*** 26,32 ****
  
  /* This platform supports the probing method of stack checking and
     requires 4K of space for executing a possible last chance handler.  */
  #define STACK_CHECK_PROTECT 4096
  
! /* Define this to be nonzero if static stack checking is supported.  */
! #define STACK_CHECK_STATIC_BUILTIN 1
--- 26,34 ----
  
  /* This platform supports the probing method of stack checking and
     requires 4K of space for executing a possible last chance handler.  */
+ #undef STACK_CHECK_PROTECT
  #define STACK_CHECK_PROTECT 4096
  
! /* Static stack checking is supported unconditionally.  */
! #undef VXWORKS_STACK_CHECK_SPEC
! #define VXWORKS_STACK_CHECK_SPEC
*** gcc/gimplify.c.0	2007-01-26 09:33:06.000000000 +0100
--- gcc/gimplify.c	2007-01-26 12:35:42.317323424 +0100
*************** gimplify_modify_expr (tree *expr_p, tree
*** 3436,3441 ****
--- 3436,3454 ----
        *to_p = make_ssa_name (*to_p, *expr_p);
      }
  
+   /* Try to alleviate the effects of the gimplification creating artificial
+      temporaries (see for example is_gimple_reg_rhs) on the debug info.  */
+   if (!gimplify_ctxp->into_ssa
+       && DECL_P (*from_p) && DECL_IGNORED_P (*from_p)
+       && DECL_P (*to_p) && !DECL_IGNORED_P (*to_p))
+     {
+       if (!DECL_NAME (*from_p) && DECL_NAME (*to_p))
+ 	DECL_NAME (*from_p)
+ 	  = create_tmp_var_name (IDENTIFIER_POINTER (DECL_NAME (*to_p)));
+       DECL_DEBUG_EXPR_IS_FROM (*from_p) = 1;
+       SET_DECL_DEBUG_EXPR (*from_p, *to_p);
+     }
+ 
    if (want_value)
      {
        append_to_statement_list (*expr_p, pre_p);
*** gcc/tree-eh.c.0	2007-02-03 17:34:03.099292016 +0100
--- gcc/tree-eh.c	2007-02-03 17:34:17.987028736 +0100
*************** tree_could_trap_p (tree expr)
*** 1880,1885 ****
--- 1880,1886 ----
      case REALPART_EXPR:
      case IMAGPART_EXPR:
      case BIT_FIELD_REF:
+     case VIEW_CONVERT_EXPR:
      case WITH_SIZE_EXPR:
        expr = TREE_OPERAND (expr, 0);
        code = TREE_CODE (expr);
*** gcc/calls.c.0	2007-02-08 22:24:34.721064632 +0100
--- gcc/calls.c	2007-02-08 22:36:47.666639968 +0100
*************** mem_overlaps_already_clobbered_arg_p (rt
*** 1497,1506 ****
    if (addr == current_function_internal_arg_pointer)
      i = 0;
    else if (GET_CODE (addr) == PLUS
! 	   && (XEXP (addr, 0)
! 	       == current_function_internal_arg_pointer)
  	   && GET_CODE (XEXP (addr, 1)) == CONST_INT)
      i = INTVAL (XEXP (addr, 1));
    else
      return false;
  
--- 1497,1510 ----
    if (addr == current_function_internal_arg_pointer)
      i = 0;
    else if (GET_CODE (addr) == PLUS
! 	   && XEXP (addr, 0) == current_function_internal_arg_pointer
  	   && GET_CODE (XEXP (addr, 1)) == CONST_INT)
      i = INTVAL (XEXP (addr, 1));
+   /* Return true for arg pointer based indexed addressing.  */
+   else if (GET_CODE (addr) == PLUS
+ 	   && (XEXP (addr, 0) == current_function_internal_arg_pointer
+ 	       || XEXP (addr, 1) == current_function_internal_arg_pointer))
+     return true;
    else
      return false;
  
*** gcc/config/rs6000/vxworks.h.ori	Wed Feb 14 10:57:40 2007
--- gcc/config/rs6000/vxworks.h	Wed Feb 14 11:32:37 2007
*************** Software Foundation, 51 Franklin Street,
*** 86,94 ****
--- 86,98 ----
                : -DCPU=PPC604  }}" \
  VXWORKS_ADDITIONAL_CPP_SPEC
  
+  /* Force -mlongcall to prevent possible reloc errors for implicit refs to
+     support routines like memcpy in dynamically loaded modules.  */
+ 
  #define CC1_SPEC						\
  "%{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}	\
   %{mlittle|mlittle-endian:-mstrict-align}			\
+  %{!mlongcall: %{!mno-longcall: -mlongcall}}			\
   %{profile: -p}		\
   %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}"	\
  VXWORKS_STACK_CHECK_SPEC
*** gcc/config/i386/t-mingw32.0	2007-02-18 16:16:25.098681024 +0100
--- gcc/config/i386/t-mingw32	2007-02-18 16:17:58.563472216 +0100
*************** SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual
*** 14,20 ****
  
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
  	-o $(SHLIB_DIR)/$(SHLIB_SONAME) \
! 	@multilib_flags@ $(SHLIB_OBJS) -lmingw32 -lshell32 -lmoldname -lmingwex -lmsvcrt -lkernel32 -luser32 -ladvapi32 
  # $(slibdir) double quoted to protect it from expansion while building
  # libgcc.mk.  We want this delayed until actual install time.
  SHLIB_INSTALL = \
--- 14,20 ----
  
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
  	-o $(SHLIB_DIR)/$(SHLIB_SONAME) \
! 	@multilib_flags@ $(SHLIB_OBJS) -lmingwthrd -lmingw32 -lshell32 -lmoldname -lmingwex -lmsvcrt -lkernel32 -luser32 -ladvapi32 
  # $(slibdir) double quoted to protect it from expansion while building
  # libgcc.mk.  We want this delayed until actual install time.
  SHLIB_INSTALL = \
*** gcc/tree-cfg.c.0	2007-02-18 19:29:50.531387080 +0100
--- gcc/tree-cfg.c	2007-02-18 19:29:53.876878488 +0100
*************** void
*** 4466,4471 ****
--- 4466,4472 ----
  dump_function_to_file (tree fn, FILE *file, int flags)
  {
    tree arg, vars, var;
+   struct function *dsf;
    bool ignore_topmost_bind = false, any_var = false;
    basic_block bb;
    tree chain;
*************** dump_function_to_file (tree fn, FILE *fi
*** 4482,4489 ****
      }
    fprintf (file, ")\n");
  
!   if (flags & TDF_DETAILS)
!     dump_eh_tree (file, DECL_STRUCT_FUNCTION (fn));
    if (flags & TDF_RAW)
      {
        dump_node (fn, TDF_SLIM | flags, file);
--- 4483,4492 ----
      }
    fprintf (file, ")\n");
  
!   dsf = DECL_STRUCT_FUNCTION (fn);
!   if (dsf && (flags & TDF_DETAILS))
!     dump_eh_tree (file, dsf);
! 
    if (flags & TDF_RAW)
      {
        dump_node (fn, TDF_SLIM | flags, file);
*** gcc/tree-vrp.c.ori	Fri Feb 16 09:50:37 2007
--- gcc/tree-vrp.c	Fri Feb 16 09:56:01 2007
*************** extract_range_from_binary_expr (value_ra
*** 1283,1294 ****
        max = val[0];
        for (i = 1; i < 4; i++)
  	{
! 	  if (TREE_OVERFLOW (min) || TREE_OVERFLOW (max))
  	    break;
  
  	  if (val[i])
  	    {
! 	      if (TREE_OVERFLOW (val[i]))
  		{
  		  /* If we found an overflowed value, set MIN and MAX
  		     to it so that we set the resulting range to
--- 1283,1295 ----
        max = val[0];
        for (i = 1; i < 4; i++)
  	{
! 	  if (!is_gimple_min_invariant (min) || TREE_OVERFLOW (min)
! 	      || !is_gimple_min_invariant (max) || TREE_OVERFLOW (max))
  	    break;
  
  	  if (val[i])
  	    {
! 	      if (!is_gimple_min_invariant (val[i]) || TREE_OVERFLOW (val[i]))
  		{
  		  /* If we found an overflowed value, set MIN and MAX
  		     to it so that we set the resulting range to
*************** extract_range_from_binary_expr (value_ra
*** 1330,1336 ****
  
    /* If either MIN or MAX overflowed, then set the resulting range to
       VARYING.  */
!   if (TREE_OVERFLOW (min) || TREE_OVERFLOW (max))
      {
        set_value_range_to_varying (vr);
        return;
--- 1331,1338 ----
  
    /* If either MIN or MAX overflowed, then set the resulting range to
       VARYING.  */
!   if (!is_gimple_min_invariant (min) || TREE_OVERFLOW (min)
!       || !is_gimple_min_invariant (max) || TREE_OVERFLOW (max))
      {
        set_value_range_to_varying (vr);
        return;
*** gcc/coverage.c.0	2007-04-15 14:22:47.458698808 +0200
--- gcc/coverage.c	2007-04-15 14:22:54.210672352 +0200
*************** coverage_checksum_string (unsigned chksu
*** 457,486 ****
         to be no better chance then walk all possible offsets looking
         for magicnuber.  */
        if (offset)
!         for (;string[offset]; offset++)
!         for (i = i + offset; string[i]; i++)
!           if (string[i]=='_')
!             {
!               int y;
! 
!               for (y = 1; y < 9; y++)
!                 if (!(string[i + y] >= '0' && string[i + y] <= '9')
!                     && !(string[i + y] >= 'A' && string[i + y] <= 'F'))
!                   break;
!               if (y != 9 || string[i + 9] != '_')
!                 continue;
!               for (y = 10; y < 18; y++)
!                 if (!(string[i + y] >= '0' && string[i + y] <= '9')
!                     && !(string[i + y] >= 'A' && string[i + y] <= 'F'))
!                   break;
!               if (y != 18)
!                 continue;
!               if (!dup)
!                 string = dup = xstrdup (string);
!               for (y = 10; y < 18; y++)
!                 dup[i + y] = '0';
!             }
!         break;
      }
  
    chksum = crc32_string (chksum, string);
--- 457,487 ----
         to be no better chance then walk all possible offsets looking
         for magicnuber.  */
        if (offset)
! 	{
! 	  for (i = i + offset; string[i]; i++)
! 	    if (string[i]=='_')
! 	      {
! 		int y;
! 
! 		for (y = 1; y < 9; y++)
! 		  if (!(string[i + y] >= '0' && string[i + y] <= '9')
! 		      && !(string[i + y] >= 'A' && string[i + y] <= 'F'))
! 		    break;
! 		if (y != 9 || string[i + 9] != '_')
! 		  continue;
! 		for (y = 10; y < 18; y++)
! 		  if (!(string[i + y] >= '0' && string[i + y] <= '9')
! 		      && !(string[i + y] >= 'A' && string[i + y] <= 'F'))
! 		    break;
! 		if (y != 18)
! 		  continue;
! 		if (!dup)
! 		  string = dup = xstrdup (string);
! 		for (y = 10; y < 18; y++)
! 		  dup[i + y] = '0';
! 	      }
! 	  break;
! 	}
      }
  
    chksum = crc32_string (chksum, string);
*** gcc/dwarf2out.c.0	2007-03-03 18:47:50.000000000 +0100
--- gcc/dwarf2out.c	2007-03-03 19:25:42.000000000 +0100
*************** dwarf2out_frame_init (void)
*** 2602,2608 ****
    dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);
  
  #ifdef DWARF2_UNWIND_INFO
!   if (DWARF2_UNWIND_INFO)
      initial_return_save (INCOMING_RETURN_ADDR_RTX);
  #endif
  }
--- 2602,2608 ----
    dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);
  
  #ifdef DWARF2_UNWIND_INFO
!   if (DWARF2_UNWIND_INFO || DWARF2_FRAME_INFO)
      initial_return_save (INCOMING_RETURN_ADDR_RTX);
  #endif
  }
*** gcc/common.opt.0	2007-03-16 08:18:01.000000000 +0100
--- gcc/common.opt	2007-03-16 08:52:54.480068112 +0100
*************** gdwarf-2
*** 1071,1076 ****
--- 1071,1080 ----
  Common JoinedOrMissing
  Generate debug information in DWARF v2 format
  
+ gdwarf+
+ Common JoinedOrMissing
+ Generate debug information in DWARF v2 format with GNAT extensions
+ 
  ggdb
  Common JoinedOrMissing
  Generate debug information in default extended format
*** gcc/flags.h.0	2007-03-16 08:20:59.000000000 +0100
--- gcc/flags.h	2007-03-16 08:41:06.684669368 +0100
*************** extern enum debug_info_level debug_info_
*** 58,63 ****
--- 58,67 ----
     debugging information.  */
  extern bool use_gnu_debug_info_extensions;
  
+ /* Nonzero means use GNAT-only extensions in the generated symbolic
+    debugging information.  */
+ extern int flag_gnat_dwarf_extensions;
+ 
  /* Enumerate visibility settings.  */
  #ifndef SYMBOL_VISIBILITY_DEFINED
  #define SYMBOL_VISIBILITY_DEFINED
*** gcc/opts.c.0	2007-03-16 08:18:01.000000000 +0100
--- gcc/opts.c	2007-03-16 08:39:31.525135816 +0100
*************** enum debug_info_level debug_info_level =
*** 78,83 ****
--- 78,88 ----
     write_symbols is set to DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
  bool use_gnu_debug_info_extensions;
  
+ /* Nonzero means use GNAT-only extensions in the generated symbolic
+    debugging information.  Currently, this only has an effect when
+    write_symbols is set to DWARF_DEBUG.  */
+ int flag_gnat_dwarf_extensions;
+ 
  /* The default visibility for all symbols (unless overridden) */
  enum symbol_visibility default_visibility = VISIBILITY_DEFAULT;
  
*************** common_handle_option (size_t scode, cons
*** 1077,1082 ****
--- 1082,1092 ----
        set_debug_level (SDB_DEBUG, false, arg);
        break;
  
+     case OPT_gdwarf_:
+       flag_gnat_dwarf_extensions = 1;
+ 
+       /* Fall through...  */
+ 
      case OPT_gdwarf_2:
        set_debug_level (DWARF2_DEBUG, false, arg);
        break;
*** gcc/doc/invoke.texi.0	2007-03-06 21:45:21.076522440 +0100
--- gcc/doc/invoke.texi	2007-03-06 21:45:26.288730064 +0100
*************** Objective-C and Objective-C++ Dialects}.
*** 291,297 ****
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
  -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
! -g  -g@var{level}  -gcoff -gdwarf-2 @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
  -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol
  -print-multi-directory  -print-multi-lib @gol
--- 291,297 ----
  -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol
  -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
  -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
! -g  -g@var{level}  -gcoff -gdwarf-2 -gdwarf+ @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
  -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol
  -print-multi-directory  -print-multi-lib @gol
*************** option, GCC uses features of DWARF versi
*** 3526,3531 ****
--- 3526,3536 ----
  version 3 is upward compatible with version 2, but may still cause
  problems for older debuggers.
  
+ @item -gdwarf+
+ @opindex gdwarf+
+ Produce debugging information in DWARF version 2 format, including the
+ GNAT vendors extensions (if that is supported).
+ 
  @item -gvms
  @opindex gvms
  Produce debugging information in VMS debug format (if that is
*************** debug level for DWARF2.
*** 3561,3567 ****
  @opindex feliminate-dwarf2-dups
  Compress DWARF2 debugging information by eliminating duplicated
  information about each symbol.  This option only makes sense when
! generating DWARF2 debugging information with @option{-gdwarf-2}.
  
  @cindex @command{prof}
  @item -p
--- 3566,3573 ----
  @opindex feliminate-dwarf2-dups
  Compress DWARF2 debugging information by eliminating duplicated
  information about each symbol.  This option only makes sense when
! generating DWARF2 debugging information with @option{-gdwarf-2} or
! @option{-gdwarf+}.
  
  @cindex @command{prof}
  @item -p
*** gcc/dwarf2.h.0	2007-03-06 21:45:21.077522288 +0100
--- gcc/dwarf2.h	2007-03-06 21:45:26.288730064 +0100
*************** enum dwarf_attribute
*** 354,359 ****
--- 354,362 ----
      DW_AT_GNU_vector = 0x2107,
      /* VMS extensions.  */
      DW_AT_VMS_rtnbeg_pd_address = 0x2201,
+     /* GNAT Extensions.  */
+     DW_AT_GNAT_encoding = 0x2301,
+     DW_AT_GNAT_descriptive_type = 0x2302,
      /* UPC extension.  */
      DW_AT_upc_threads_scaled = 0x3210,
      /* PGI (STMicroelectronics) extensions.  */
*** gcc/dwarf2out.h.0	2007-03-06 21:45:21.078522136 +0100
--- gcc/dwarf2out.h	2007-03-06 21:45:26.290729760 +0100
*************** extern void debug_dwarf (void);
*** 26,29 ****
--- 26,31 ----
  struct die_struct;
  extern void debug_dwarf_die (struct die_struct *);
  extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));
+ extern void dwarf2out_set_gnat_encoding_func (const char *(*) (const char *));
+ extern void dwarf2out_set_gnat_descriptive_type_func (tree (*) (tree));
  extern void dwarf2out_add_library_unit_info (const char *, const char *);
*** gcc/dwarf2out.c.0	2007-03-06 21:45:21.081521680 +0100
--- gcc/dwarf2out.c	2007-03-06 21:52:04.880134960 +0100
*************** static void add_location_or_const_value_
*** 4127,4132 ****
--- 4127,4134 ----
  						   enum dwarf_attribute);
  static void tree_add_const_value_attribute (dw_die_ref, tree);
  static void add_name_attribute (dw_die_ref, const char *);
+ static void add_artificial_attribute_for_type (dw_die_ref, tree);
+ static void add_descriptive_attribute_for_type (dw_die_ref, tree, dw_die_ref);
  static void add_comp_dir_attribute (dw_die_ref);
  static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);
  static void add_subscript_info (dw_die_ref, tree);
*************** static char ranges_section_label[2 * MAX
*** 4316,4321 ****
--- 4318,4325 ----
     called to "demangle" any name before it is put into a DIE.  */
  
  static const char *(*demangle_name_func) (const char *);
+ static const char *(*gnat_encoding_func) (const char *);
+ static tree (*gnat_descriptive_type_func) (tree);
  
  void
  dwarf2out_set_demangle_name_func (const char *(*func) (const char *))
*************** dwarf2out_set_demangle_name_func (const 
*** 4323,4328 ****
--- 4327,4344 ----
    demangle_name_func = func;
  }
  
+ void
+ dwarf2out_set_gnat_encoding_func (const char *(*func) (const char *))
+ {
+   gnat_encoding_func = func;
+ }
+ 
+ void
+ dwarf2out_set_gnat_descriptive_type_func (tree (*func) (tree))
+ {
+   gnat_descriptive_type_func = func;
+ }
+ 
  /* Test if rtl node points to a pseudo register.  */
  
  static inline int
*************** dwarf_attr_name (unsigned int attr)
*** 4686,4691 ****
--- 4702,4712 ----
      case DW_AT_VMS_rtnbeg_pd_address:
        return "DW_AT_VMS_rtnbeg_pd_address";
  
+     case DW_AT_GNAT_encoding:
+       return "DW_AT_GNAT_encoding";
+     case DW_AT_GNAT_descriptive_type:
+       return "DW_AT_GNAT_descriptive_type";
+ 
      default:
        return "DW_AT_<unknown>";
      }
*************** base_type_die (tree type)
*** 8153,8162 ****
      }
  
    base_type_result = new_die (DW_TAG_base_type, comp_unit_die, type);
-   if (demangle_name_func)
-     type_name = (*demangle_name_func) (type_name);
  
!   add_AT_string (base_type_result, DW_AT_name, type_name);
    add_AT_unsigned (base_type_result, DW_AT_byte_size,
  		   int_size_in_bytes (type));
    add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);
--- 8174,8181 ----
      }
  
    base_type_result = new_die (DW_TAG_base_type, comp_unit_die, type);
  
!   add_name_attribute (base_type_result, type_name);
    add_AT_unsigned (base_type_result, DW_AT_byte_size,
  		   int_size_in_bytes (type));
    add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);
*************** subrange_type_die (tree type, dw_die_ref
*** 8332,8337 ****
--- 8351,8358 ----
        if (TREE_CODE (name) == TYPE_DECL)
          name = DECL_NAME (name);
        add_name_attribute (subrange_die, IDENTIFIER_POINTER (name));
+       add_artificial_attribute_for_type (subrange_die, type);
+       add_descriptive_attribute_for_type (subrange_die, type, context_die);
      }
  
    if (int_size_in_bytes (subtype) != size_in_bytes)
*************** add_name_attribute (dw_die_ref die, cons
*** 10492,10504 ****
--- 10513,10574 ----
  {
    if (name_string != NULL && *name_string != 0)
      {
+       const char *orig_string = name_string;
+ 
        if (demangle_name_func)
  	name_string = (*demangle_name_func) (name_string);
  
        add_AT_string (die, DW_AT_name, name_string);
+ 
+       if (gnat_encoding_func)
+ 	{
+ 	  const char *encoding = (*gnat_encoding_func) (orig_string);
+ 
+ 	  if (*encoding != 0)
+ 	    add_AT_string (die, DW_AT_GNAT_encoding, encoding);
+ 	}
      }
  }
  
+ /* Generate a DW_AT_artificial_flag for TYPE, if it is needed.  */
+ 
+ static void 
+ add_artificial_attribute_for_type (dw_die_ref die, tree type)
+ {
+   if (TYPE_NAME (type)
+       && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
+       && DECL_ARTIFICIAL (TYPE_NAME (type))
+       && !get_AT_flag (die, DW_AT_artificial))
+     add_AT_flag (die, DW_AT_artificial, 1);
+ }
+ 
+ /* Generate a DW_AT_gnat_descriptive_type for TYPE, if it is needed.  */
+ 
+ static void 
+ add_descriptive_attribute_for_type (dw_die_ref die, tree type,
+ 				    dw_die_ref context_die)
+ {
+   tree descriptive_type;
+   dw_die_ref type_die;
+ 
+   if (!gnat_descriptive_type_func)
+     return;
+ 
+   descriptive_type = gnat_descriptive_type_func (type);
+   if (!descriptive_type)
+     return;
+ 
+   type_die = lookup_type_die (descriptive_type);
+   if (!type_die)
+     {
+       gen_type_die (descriptive_type, context_die);
+       type_die = lookup_type_die (descriptive_type);
+       gcc_assert (type_die);
+     }
+ 
+   add_AT_die_ref (die, DW_AT_GNAT_descriptive_type, type_die);
+ }
+ 
  /* Generate a DW_AT_comp_dir attribute for DIE.  */
  
  static void
*************** gen_array_type_die (tree type, dw_die_re
*** 11131,11136 ****
--- 11201,11208 ----
  
    array_die = new_die (DW_TAG_array_type, scope_die, type);
    add_name_attribute (array_die, type_tag (type));
+   add_artificial_attribute_for_type (array_die, type);
+   add_descriptive_attribute_for_type (array_die, type, context_die);
    equate_type_number_to_die (type, array_die);
  
    if (TREE_CODE (type) == VECTOR_TYPE)
*************** gen_enumeration_type_die (tree type, dw_
*** 11265,11270 ****
--- 11337,11344 ----
  			  scope_die_for (type, context_die), type);
        equate_type_number_to_die (type, type_die);
        add_name_attribute (type_die, type_tag (type));
+       add_artificial_attribute_for_type (type_die, type);
+       add_descriptive_attribute_for_type (type_die, type, context_die);
      }
    else if (! TYPE_SIZE (type))
      return type_die;
*************** gen_compile_unit_die (const char *filena
*** 12229,12234 ****
--- 12303,12314 ----
      strcat (producer, " -g");
  #endif
  
+   /* ??? We need to find a better way.  */
+   if (flag_gnat_dwarf_extensions)
+     strcat (producer, " -gdwarf+");
+   else
+     strcat (producer, " -gdwarf+-");
+ 
    add_AT_string (die, DW_AT_producer, producer);
  
    if (strcmp (language_string, "GNU C++") == 0)
*************** gen_struct_or_union_type_die (tree type,
*** 12388,12394 ****
        if (old_die)
  	add_AT_specification (type_die, old_die);
        else
! 	add_name_attribute (type_die, type_tag (type));
      }
    else
      remove_AT (type_die, DW_AT_declaration);
--- 12468,12478 ----
        if (old_die)
  	add_AT_specification (type_die, old_die);
        else
! 	{
! 	  add_name_attribute (type_die, type_tag (type));
! 	  add_artificial_attribute_for_type (type_die, type);
! 	  add_descriptive_attribute_for_type (type_die, type, context_die);
! 	}
      }
    else
      remove_AT (type_die, DW_AT_declaration);
*** gcc/config.gcc.old	Mon Mar 12 18:38:13 2007
--- gcc/config.gcc	Mon Mar 12 18:38:45 2007
*************** case ${target} in
*** 2911,2917 ****
                  with_cpu=cypress
  
                  # The SPARC port checks this value at compile-time.
!                 target_cpu_default2="TARGET_CPU_$with_cpu"
                  ;;
  
          leon-*-*)
--- 2911,2917 ----
                  with_cpu=cypress
  
                  # The SPARC port checks this value at compile-time.
!                 target_cpu_default2="TARGET_CPU_sparc"
                  ;;
  
          leon-*-*)
*** gcc/expr.c.ori	Wed Mar 14 10:21:24 2007
--- gcc/expr.c	Wed Mar 14 10:48:21 2007
*************** convert_move (rtx to, rtx from, int unsi
*** 535,544 ****
        /* No special multiword conversion insn; do it by hand.  */
        start_sequence ();
  
!       /* Since we will turn this into a no conflict block, we must ensure
! 	 that the source does not overlap the target.  */
! 
!       if (reg_overlap_mentioned_p (to, from))
  	from = force_reg (from_mode, from);
  
        /* Get a copy of FROM widened to a word, if necessary.  */
--- 535,547 ----
        /* No special multiword conversion insn; do it by hand.  */
        start_sequence ();
  
!       /* Since we will turn this into a no conflict block, we must ensure that
! 	 the source does not overlap the target and force it into a register
! 	 if maybe-so.  Likewise if it is a volatile MEM, since the conversion
! 	 sequence might require several references to the source and we must
! 	 ensure we're getting the same value every time.  */
!       if ((GET_CODE (from) == MEM && MEM_VOLATILE_P (from))
! 	  || reg_overlap_mentioned_p (to, from))
  	from = force_reg (from_mode, from);
  
        /* Get a copy of FROM widened to a word, if necessary.  */
*** gcc/collect2.c.ori	Mon Jan 22 16:25:07 2007
--- gcc/collect2.c	Fri Mar 16 16:19:06 2007
*************** static void write_c_file_stat (FILE *, c
*** 259,265 ****
  #ifndef LD_INIT_SWITCH
  static void write_c_file_glob (FILE *, const char *);
  #endif
! static void scan_prog_file (const char *, enum pass);
  #ifdef SCAN_LIBRARIES
  static void scan_libraries (const char *);
  #endif
--- 259,273 ----
  #ifndef LD_INIT_SWITCH
  static void write_c_file_glob (FILE *, const char *);
  #endif
! 
! enum scan_flags {
!   ORDINARY          = 0x0,
!   SKIP_FRAME_TABLES = 0x1,
!   FRAME_TABLES_ONLY = 0x2
! };
! 
! static void scan_prog_file (const char *, enum pass, enum scan_flags);
! 
  #ifdef SCAN_LIBRARIES
  static void scan_libraries (const char *);
  #endif
*************** main (int argc, char **argv)
*** 1224,1241 ****
      }
  
    /* The AIX linker will discard static constructors in object files if
!      nothing else in the file is referenced, so look at them first.  */
    {
        const char **export_object_lst = (const char **)object_lst;
  
        while (export_object_lst < object)
! 	scan_prog_file (*export_object_lst++, PASS_OBJ);
    }
    {
      struct id *list = libs.first;
  
      for (; list; list = list->next)
!       scan_prog_file (list->name, PASS_FIRST);
    }
  
    if (exports.first)
--- 1232,1253 ----
      }
  
    /* The AIX linker will discard static constructors in object files if
!      nothing else in the file is referenced, so look at them first.  Skip
!      frame tables when doing so, to prevent dragging every object with such
!      tables that would not have been dragged otherwise.  This is a potentially
!      large set of actually useless objects, de-facto making executables larger
!      and possibly adding spurious dependencies to other libraries.  */
    {
        const char **export_object_lst = (const char **)object_lst;
  
        while (export_object_lst < object)
! 	scan_prog_file (*export_object_lst++, PASS_OBJ, SKIP_FRAME_TABLES);
    }
    {
      struct id *list = libs.first;
  
      for (; list; list = list->next)
!       scan_prog_file (list->name, PASS_FIRST, SKIP_FRAME_TABLES);
    }
  
    if (exports.first)
*************** main (int argc, char **argv)
*** 1307,1317 ****
  
    /* Load the program, searching all libraries and attempting to provide
       undefined symbols from repository information.  */
- 
-   /* On AIX we do this later.  */
- #ifndef COLLECT_EXPORT_LIST
    do_tlink (ld1_argv, object_lst);
! #endif
  
    /* If -r or they will be run via some other method, do not build the
       constructor or destructor list, just return now.  */
--- 1319,1334 ----
  
    /* Load the program, searching all libraries and attempting to provide
       undefined symbols from repository information.  */
    do_tlink (ld1_argv, object_lst);
! 
!   /* We used not to tlink here on AIX because we have to do it later in any
!      case and used to have scanned for static constructors and frame tables
!      already.  We now skip frame tables during the static constructor scan,
!      so now link here on AIX as well to allow a frame-tables-only scan below.
! 
!      We expect frame tables associated with needed functions to be included
!      (not garbage collected) in the result of this link, which GCC achieves
!      by forcing a reference to the tables from the functions' CSECTs. */
  
    /* If -r or they will be run via some other method, do not build the
       constructor or destructor list, just return now.  */
*************** main (int argc, char **argv)
*** 1322,1331 ****
        )
      {
  #ifdef COLLECT_EXPORT_LIST
!       /* Do the link we avoided above if we are exiting.  */
!       do_tlink (ld1_argv, object_lst);
! 
!       /* But make sure we delete the export file we may have created.  */
        if (export_file != 0 && export_file[0])
  	maybe_unlink (export_file);
  #endif
--- 1339,1345 ----
        )
      {
  #ifdef COLLECT_EXPORT_LIST
!       /* Make sure we delete the export file we may have created.  */
        if (export_file != 0 && export_file[0])
  	maybe_unlink (export_file);
  #endif
*************** main (int argc, char **argv)
*** 1334,1347 ****
        return 0;
      }
  
!   /* Examine the namelist with nm and search it for static constructors
!      and destructors to call.
!      Write the constructor and destructor tables to a .s file and reload.  */
  
!   /* On AIX we already scanned for global constructors/destructors.  */
! #ifndef COLLECT_EXPORT_LIST
!   scan_prog_file (output_file, PASS_FIRST);
  #endif
  
  #ifdef SCAN_LIBRARIES
    scan_libraries (output_file);
--- 1348,1365 ----
        return 0;
      }
  
!   /* Examine the namelist with nm and search it for static constructors and
!      destructors to call. Write the constructor and destructor tables to a .s
!      file and reload.  On AIX we already scanned for global c/dtors and now
!      need to scan for frame tables.  */
!   {
!     enum scan_flags flags = ORDINARY;
  
! #ifdef COLLECT_EXPORT_LIST
!     flags |= FRAME_TABLES_ONLY;
  #endif
+     scan_prog_file (output_file, PASS_FIRST, flags);
+   }
  
  #ifdef SCAN_LIBRARIES
    scan_libraries (output_file);
*************** main (int argc, char **argv)
*** 1364,1373 ****
  #endif
        )
      {
- #ifdef COLLECT_EXPORT_LIST
-       /* Do tlink without additional code generation.  */
-       do_tlink (ld1_argv, object_lst);
- #endif
        /* Strip now if it was requested on the command line.  */
        if (strip_flag)
  	{
--- 1382,1387 ----
*************** main (int argc, char **argv)
*** 1458,1464 ****
  
    fork_execute ("gcc",  c_argv);
  #ifdef COLLECT_EXPORT_LIST
!   /* On AIX we must call tlink because of possible templates resolution.  */
    do_tlink (ld2_argv, object_lst);
  #else
    /* Otherwise, simply call ld because tlink is already done.  */
--- 1472,1480 ----
  
    fork_execute ("gcc",  c_argv);
  #ifdef COLLECT_EXPORT_LIST
!   /* On AIX we must call tlink because of possible templates resolution.
!      ??? We have already called it once to allow a frame tables scan.  Do
!      we really need it again here ?  */
    do_tlink (ld2_argv, object_lst);
  #else
    /* Otherwise, simply call ld because tlink is already done.  */
*************** main (int argc, char **argv)
*** 1466,1472 ****
  
    /* Let scan_prog_file do any final mods (OSF/rose needs this for
       constructors/destructors in shared libraries.  */
!   scan_prog_file (output_file, PASS_SECOND);
  #endif
  
    maybe_unlink (c_file);
--- 1482,1488 ----
  
    /* Let scan_prog_file do any final mods (OSF/rose needs this for
       constructors/destructors in shared libraries.  */
!   scan_prog_file (output_file, PASS_SECOND, ORDINARY);
  #endif
  
    maybe_unlink (c_file);
*************** write_aix_file (FILE *stream, struct id 
*** 2000,2006 ****
     destructor table has the same format, and begins at __DTOR_LIST__.  */
  
  static void
! scan_prog_file (const char *prog_name, enum pass which_pass)
  {
    void (*int_handler) (int);
  #ifdef SIGQUIT
--- 2016,2023 ----
     destructor table has the same format, and begins at __DTOR_LIST__.  */
  
  static void
! scan_prog_file (const char *prog_name, enum pass which_pass,
! 		enum scan_flags flags)
  {
    void (*int_handler) (int);
  #ifdef SIGQUIT
*************** scan_libraries (const char *prog_name)
*** 2270,2276 ****
    /* Now iterate through the library list adding their symbols to
       the list.  */
    for (list = libraries.first; list; list = list->next)
!     scan_prog_file (list->name, PASS_LIB);
  }
  
  #endif /* LDD_SUFFIX */
--- 2287,2293 ----
    /* Now iterate through the library list adding their symbols to
       the list.  */
    for (list = libraries.first; list; list = list->next)
!     scan_prog_file (list->name, PASS_LIB, ORDINARY);
  }
  
  #endif /* LDD_SUFFIX */
*************** extern char *ldgetname (LDFILE *, GCC_SY
*** 2381,2387 ****
     destructor table has the same format, and begins at __DTOR_LIST__.  */
  
  static void
! scan_prog_file (const char *prog_name, enum pass which_pass)
  {
    LDFILE *ldptr = NULL;
    int sym_index, sym_count;
--- 2398,2405 ----
     destructor table has the same format, and begins at __DTOR_LIST__.  */
  
  static void
! scan_prog_file (const char *prog_name, enum pass which_pass,
! 		enum scan_flags flags)
  {
    LDFILE *ldptr = NULL;
    int sym_index, sym_count;
*************** scan_prog_file (const char *prog_name, e
*** 2445,2450 ****
--- 2463,2471 ----
  		      switch (is_ctor_dtor (name))
  			{
  			case 1:
+ 			  if (flags & FRAME_TABLES_ONLY)
+ 			    break;
+ 
  			  if (! is_shared)
  			    add_to_list (&constructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2454,2459 ****
--- 2475,2483 ----
  			  break;
  
  			case 2:
+ 			  if (flags & FRAME_TABLES_ONLY)
+ 			    break;
+ 
  			  if (! is_shared)
  			    add_to_list (&destructors, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2464,2469 ****
--- 2488,2496 ----
  
  #ifdef COLLECT_EXPORT_LIST
  			case 3:
+ 			  if (flags & FRAME_TABLES_ONLY)
+ 			    break;
+ 
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&constructors, name);
*************** scan_prog_file (const char *prog_name, e
*** 2471,2476 ****
--- 2498,2506 ----
  			  break;
  
  			case 4:
+ 			  if (flags & FRAME_TABLES_ONLY)
+ 			    break;
+ 
  #ifndef LD_INIT_SWITCH
  			  if (is_shared)
  			    add_to_list (&destructors, name);
*************** scan_prog_file (const char *prog_name, e
*** 2479,2484 ****
--- 2509,2517 ----
  #endif
  
  			case 5:
+ 			  if (flags & SKIP_FRAME_TABLES)
+ 			    break;
+ 
  			  if (! is_shared)
  			    add_to_list (&frame_tables, name);
  #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)
*************** scan_prog_file (const char *prog_name, e
*** 2488,2493 ****
--- 2521,2528 ----
  			  break;
  
  			default:	/* not a constructor or destructor */
+ 			  if (flags & FRAME_TABLES_ONLY)
+ 			    break;
  #ifdef COLLECT_EXPORT_LIST
  			  /* Explicitly export all global symbols when
  			     building a shared object on AIX, but do not
*************** scan_prog_file (const char *prog_name, e
*** 2503,2512 ****
  
  		      if (debug)
  #if !defined(EXTENDED_COFF)
! 			fprintf (stderr, "\tsec=%d class=%d type=%s%o %s\n",
! 				 symbol.n_scnum, symbol.n_sclass,
  				 (symbol.n_type ? "0" : ""), symbol.n_type,
! 				 name);
  #else
  			fprintf (stderr,
  				 "\tiss = %5d, value = %5ld, index = %5d, name = %s\n",
--- 2538,2550 ----
  
  		      if (debug)
  #if !defined(EXTENDED_COFF)
! 			fprintf (stderr, "%s\nsec=%d class=%d type=%s%o %-80s"
! 				 "skip_tables=%d tables_only=%d\n",
! 				 prog_name, symbol.n_scnum, symbol.n_sclass,
  				 (symbol.n_type ? "0" : ""), symbol.n_type,
! 				 name,
! 				 flags & SKIP_FRAME_TABLES,
! 				 flags & FRAME_TABLES_ONLY);
  #else
  			fprintf (stderr,
  				 "\tiss = %5d, value = %5ld, index = %5d, name = %s\n",
*** gcc/dwarf2out.c.ori	Mon Jan 22 16:25:07 2007
--- gcc/dwarf2out.c	Mon Jan 22 16:25:25 2007
*************** output_call_frame_info (int for_eh)
*** 2483,2488 ****
--- 2483,2493 ----
    ASM_OUTPUT_ALIGN (asm_out_file, 0);
  #endif
  
+ #ifdef DWARF2_EMIT_FRAME_TABLE_ASM_REF
+   current_function_section (current_function_decl);
+   DWARF2_EMIT_FRAME_TABLE_ASM_REF (section_start_label);
+ #endif
+ 
    /* Turn off app to make assembly quicker.  */
    if (flag_debug_asm)
      app_disable ();
*** gcc/config/rs6000/aix.h.ori	Mon Jan 22 16:25:07 2007
--- gcc/config/rs6000/aix.h	Mon Jan 22 16:25:24 2007
***************
*** 262,264 ****
--- 262,271 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Emit an asm statememt forcing a reference to FRAME_TABLE_LABEL from the
+    current function text section.  This is defined to ensure we drag frame
+    frame tables associated with needed function bodies in a link with garbage
+    collection activated.  */
+ #define DWARF2_EMIT_FRAME_TABLE_ASM_REF rs6000_aix_emit_frame_table_asm_ref
+ 
*** gcc/config/rs6000/rs6000-protos.h.ori	Fri Feb 16 18:26:27 2007
--- gcc/config/rs6000/rs6000-protos.h	Fri Feb 16 18:29:50 2007
*************** extern bool rs6000_tls_referenced_p (rtx
*** 163,168 ****
--- 163,170 ----
  extern int rs6000_hard_regno_nregs (int, enum machine_mode);
  extern void rs6000_conditional_register_usage (void);
  
+ extern void rs6000_aix_emit_frame_table_asm_ref (char * frame_table_label);
+ 
  /* Declare functions in rs6000-c.c */
  
  extern void rs6000_pragma_longcall (struct cpp_reader *);
*** gcc/config/rs6000/rs6000.h.ori	Mon Feb 19 17:55:07 2007
--- gcc/config/rs6000/rs6000.h	Mon Feb 19 18:15:13 2007
*************** typedef struct rs6000_args
*** 1561,1568 ****
    ((reload_completed && (REGNO) == LINK_REGISTER_REGNUM)	\
     || (TARGET_ALTIVEC && (REGNO) == VRSAVE_REGNO)		\
     || (current_function_calls_eh_return				\
!        && TARGET_AIX						\
!        && (REGNO) == 2))
  
  
  /* TRAMPOLINE_TEMPLATE deleted */
--- 1561,1568 ----
    ((reload_completed && (REGNO) == LINK_REGISTER_REGNUM)	\
     || (TARGET_ALTIVEC && (REGNO) == VRSAVE_REGNO)		\
     || (current_function_calls_eh_return				\
!        && ((TARGET_TOC && TARGET_MINIMAL_TOC && (REGNO) == TOC_REGISTER) \
! 	   || (TARGET_AIX && (REGNO) == 2))))
  
  
  /* TRAMPOLINE_TEMPLATE deleted */
*** gcc/config/rs6000/rs6000.c.ori	Mon Jan 22 16:25:07 2007
--- gcc/config/rs6000/rs6000.c	Tue Feb 20 16:57:05 2007
*************** static bool legitimate_lo_sum_address_p 
*** 615,620 ****
--- 615,621 ----
  static struct machine_function * rs6000_init_machine_status (void);
  static bool rs6000_assemble_integer (rtx, unsigned int, int);
  static bool no_global_regs_above (int);
+ static bool rs6000_should_save_restore_gpr (int);
  #ifdef HAVE_GAS_HIDDEN
  static void rs6000_assemble_visibility (tree, int);
  #endif
*************** create_TOC_reference (rtx symbol)
*** 13695,13700 ****
--- 13696,13710 ----
  		 gen_rtx_SYMBOL_REF (Pmode, toc_label_name))));
  }
  
+ /* Emit an asm statememt forcing a reference to FRAME_TABLE_LABEL from the
+    current function text section.  */
+ void
+ rs6000_aix_emit_frame_table_asm_ref (char * frame_table_label)
+ {
+   fprintf (asm_out_file, "\t.ref %s\n",
+ 	   TARGET_STRIP_NAME_ENCODING (frame_table_label));
+ }
+ 
  /* If _Unwind_* has been called from within the same module,
     toc register is not guaranteed to be saved to 40(1) on function
     entry.  Save it there in that case.  */
*************** no_global_regs_above (int first_greg)
*** 14253,14258 ****
--- 14263,14288 ----
  #define TARGET_FIX_AND_CONTINUE 0
  #endif
  
+ /* Whether gpr REGNO should be saved/restored by the current function's
+    prologue/epilogue sequences.  */
+ 
+ static bool
+ rs6000_should_save_restore_gpr (int regno)
+ {
+   if (!call_used_regs[regno] && regs_ever_live[regno])
+     return true;
+ 
+   else if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_DARWIN)
+            && flag_pic && regno == RS6000_PIC_OFFSET_TABLE_REGNUM)
+     return true;
+ 
+   else if (TARGET_TOC && TARGET_MINIMAL_TOC && regno == TOC_REGISTER
+ 	   && (regs_ever_live [regno] || current_function_calls_eh_return))
+     return true;
+ 
+   return false;
+ }
+ 
  /* Emit function prologue as insns.  */
  
  void
*************** rs6000_emit_prologue (void)
*** 14622,14635 ****
      {
        int i;
        for (i = 0; i < 32 - info->first_gp_reg_save; i++)
! 	if ((regs_ever_live[info->first_gp_reg_save + i]
! 	     && (!call_used_regs[info->first_gp_reg_save + i]
! 		 || (i + info->first_gp_reg_save
! 		     == RS6000_PIC_OFFSET_TABLE_REGNUM
! 		     && TARGET_TOC && TARGET_MINIMAL_TOC)))
! 	    || (i + info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM
! 		&& ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)
! 		    || (DEFAULT_ABI == ABI_DARWIN && flag_pic))))
  	  {
  	    rtx addr, reg, mem;
  	    reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);
--- 14649,14655 ----
      {
        int i;
        for (i = 0; i < 32 - info->first_gp_reg_save; i++)
! 	if (rs6000_should_save_restore_gpr (info->first_gp_reg_save + i))
  	  {
  	    rtx addr, reg, mem;
  	    reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);
*************** rs6000_emit_epilogue (int sibcall)
*** 15189,15201 ****
      }
    else
      for (i = 0; i < 32 - info->first_gp_reg_save; i++)
!       if ((regs_ever_live[info->first_gp_reg_save + i]
! 	   && (!call_used_regs[info->first_gp_reg_save + i]
! 	       || (i + info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM
! 		   && TARGET_TOC && TARGET_MINIMAL_TOC)))
! 	  || (i + info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM
! 	      && ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)
! 		  || (DEFAULT_ABI == ABI_DARWIN && flag_pic))))
  	{
  	  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,
  				   GEN_INT (info->gp_save_offset
--- 15209,15215 ----
      }
    else
      for (i = 0; i < 32 - info->first_gp_reg_save; i++)
!       if (rs6000_should_save_restore_gpr (info->first_gp_reg_save + i))
  	{
  	  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,
  				   GEN_INT (info->gp_save_offset
*** gcc/config/rs6000/aix52.h.ori	Mon Jan 22 16:25:07 2007
--- gcc/config/rs6000/aix52.h	Mon Jan 22 16:25:24 2007
*************** do {									\
*** 187,191 ****
--- 187,193 ----
  extern long long int    atoll(const char *);  
  #endif
  
+ #define MD_UNWIND_SUPPORT "config/rs6000/aix-unwind.h"
+ 
  /* This target uses the aix64.opt file.  */
  #define TARGET_USES_AIX64_OPT 1
*** /dev/null	2005-05-11 10:11:50.000000000 +0200
--- gcc/config/rs6000/aix-unwind.h	2008-07-04 11:27:00.233618128 +0200
***************
*** 0 ****
--- 1,234 ----
+ /* DWARF2 EH unwinding support for PowerPC AIX.
+    Copyright (C) 2006 Free Software Foundation, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    In addition to the permissions in the GNU General Public License,
+    the Free Software Foundation gives you unlimited permission to link
+    the compiled version of this file with other programs, and to
+    distribute those programs without any restriction coming from the
+    use of this file.  (The General Public License restrictions do
+    apply in other respects; for example, they cover modification of
+    the file, and distribution when not linked into another program.)
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the
+    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #include <stdlib.h>
+ #include <stddef.h>
+ #include <signal.h>
+ #include <sys/machine.h>
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR ppc_aix_fallback_frame_state
+ 
+ #ifdef __powerpc64__
+ #error "64bit fallback for AIX not yet implemented"
+ typedef struct __context64 mstate_t;
+ #else
+ typedef struct mstsave mstate_t;
+ #endif
+ 
+ /* If we are compiling on AIX < 5.3, the VMX related datastructs are not
+    defined and we take measures to obtain proper runtime behavior if the
+    compiled code happens to run on a later version with VMX enabled.  */
+ 
+ #ifndef MSR_VMX
+ #define MSR_VMX 0x2000000
+ #endif
+ 
+ typedef unsigned int uint;
+ typedef struct { uint v[4]; } vreg_t;
+ typedef struct {
+   vreg_t regs[32];
+   uint   pad1 [3];
+   uint   vscr;
+   uint   vrsave;
+   uint   pad2 [3];
+ } vstate_t;
+ 
+ #define EXT_CONTEXT_MARK 0x45435458
+ #define EXT_CONTEXT_SIZE 4096
+ #define BUMPER_SIZE (EXT_CONTEXT_SIZE - sizeof(vstate_t) - (5 * sizeof(int)))
+ 
+ typedef struct {
+   uint     pad1 [4];
+   vstate_t vstate;
+   char     bumper [BUMPER_SIZE];
+   int      mark; 
+ } extended_context_t;
+ 
+ typedef struct {
+   char bumper [offsetof (ucontext_t, uc_stack) + sizeof (stack_t)];
+   extended_context_t * ectx;
+   int mark;
+ } vmx_ucontext_t;
+ 
+ /* Determine whether CONTEXT designates a signal handler, and return the
+    associated ucontext_t address if so.  Return NULL otherwise.  */
+ 
+ static ucontext_t *
+ ucontext_for (struct _Unwind_Context *context)
+ {
+   const unsigned int * ra = context->ra;
+ 
+   /* AIX 5.2 and 5.3, threaded or not, share a common pattern.  */
+ 
+   if (*(ra - 5) == 0x4c00012c     /* isync             */
+       && *(ra - 4) == 0x80ec0000  /* lwz     r7,0(r12) */
+       && *(ra - 3) == 0x804c0004  /* lwz     r2,4(r12) */
+       && *(ra - 2) == 0x7ce903a6  /* mtctr   r7        */
+       && *(ra - 1) == 0x4e800421  /* bctrl             */
+       && *(ra - 0) == 0x7dc37378) /* mr      r3,r14   <-- context->ra */
+     {
+       /* The layout then depends on the AIX version, which we figure out by
+ 	 looking an instruction further up.  */
+ 
+       /* AIX 5.3 */
+       if (*(ra - 6) == 0x7d000164)  /* mtmsrd  r8 */
+ 	{
+ 	  typedef struct {
+ 	    siginfo_t siginfo;
+ 	    ucontext_t ucontext;
+ 	  } aix53_stack_t;
+ 
+ 	  aix53_stack_t * frame = (aix53_stack_t *) context->cfa;
+ 	  return &frame->ucontext;
+ 	}
+ 
+       /* AIX 5.2 */
+       if (*(ra - 6) == 0x7d000124)  /* mtmsr  r8 */
+ 	{
+ 	  typedef struct {
+ 	    char pad[56];
+ 	    ucontext_t ucontext;
+ 	    siginfo_t siginfo;
+ 	  } aix52_stack_t;
+ 
+ 	  aix52_stack_t * frame = (aix52_stack_t *) context->cfa;
+ 	  return &frame->ucontext;
+ 	}
+     }
+ 
+   return 0;
+ }
+ 
+ /* The fallback proper.  */
+ 
+ #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
+ #define RETURN_COLUMN DWARF_ALT_FRAME_RETURN_COLUMN
+ #else
+ #define RETURN_COLUMN ARG_POINTER_REGNUM
+ #endif
+ 
+ #define LR_REGNO LINK_REGISTER_REGNUM
+ 
+ #define REGISTER_CFA_OFFSET_FOR(FS,REGNO,ADDR,CFA)\
+ do { \
+ (FS)->regs.reg[REGNO].how = REG_SAVED_OFFSET; \
+ (FS)->regs.reg[REGNO].loc.offset = (long) (ADDR) - (CFA); \
+ } while (0);
+ 
+ static _Unwind_Reason_Code
+ ppc_aix_fallback_frame_state (struct _Unwind_Context *context,
+ 			      _Unwind_FrameState *fs)
+ {
+   static int eh_debug = -1;
+ 
+   ucontext_t * uctx = ucontext_for (context);
+   mstate_t * mctx;
+ 
+   long new_cfa;
+   int i;
+ 
+   if (eh_debug == -1)
+     {
+       char *eh_debug_env = getenv ("EH_DEBUG");
+       eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+    }
+   
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = 0x%p, RA = 0x%p\n",
+ 	    context->cfa, context->ra);
+ 
+   if (uctx == NULL)
+     return _URC_END_OF_STACK;
+ 
+   mctx = &uctx->uc_mcontext.jmp_context;
+ 
+   if (eh_debug)
+     printf ("FALLBACK found ucontext @ 0x%p\n", uctx);
+ 
+   /* The "kernel" frame cfa is the stack pointer at the signal occurrence
+      point.  */
+   new_cfa = mctx->gpr[STACK_POINTER_REGNUM];
+ 
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = STACK_POINTER_REGNUM;
+   fs->cfa_offset = new_cfa - (long) context->cfa;
+ 
+   /* And we state how to find the various registers it has saved with
+      relative offset rules from there.  */
+ 
+   for (i = 0; i < 32; i++)
+     if (i != STACK_POINTER_REGNUM)
+       REGISTER_CFA_OFFSET_FOR (fs, i, &mctx->gpr[i], new_cfa);
+ 
+   REGISTER_CFA_OFFSET_FOR (fs, CR2_REGNO, &mctx->cr, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, XER_REGNO, &mctx->xer, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, LR_REGNO, &mctx->lr, new_cfa);
+ 
+   fs->retaddr_column = RETURN_COLUMN;
+   REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->iar, new_cfa);
+ 
+   /* Honor FP Ever Used ...   */
+   if (mctx->fpeu)
+     {
+       if (eh_debug)
+ 	printf ("FALLBACK setting up FPU registers restore\n");
+ 
+       for (i = 0; i < 32; i++)
+ 	REGISTER_CFA_OFFSET_FOR (fs, i+32, &mctx->fpr[i], new_cfa);
+     }
+ 
+   /* Honor VMX context, if any.  We expect the msr bit never to be set in
+      environments where there is no VMX support, e.g. on AIX < 5.3.  */
+   if (mctx->msr & MSR_VMX)
+     {
+       vmx_ucontext_t * uc = (vmx_ucontext_t *) uctx;
+ 
+       if (eh_debug)
+ 	printf ("FALLBACK MSR.VMX is set ...\n");
+ 
+       if (uc->mark == EXT_CONTEXT_MARK && uc->ectx->mark == EXT_CONTEXT_MARK)
+ 	{
+ 	  vstate_t * vstate = &uc->ectx->vstate;
+ 
+ 	  if (eh_debug)
+ 	    printf ("FALLBACK setting up VMX registers restore\n");
+ 
+ 	  for (i = 0; i < 32; i++)
+ 	    REGISTER_CFA_OFFSET_FOR
+ 	    (fs, i+FIRST_ALTIVEC_REGNO, &vstate->regs[i], new_cfa);
+ 	  
+ 	  REGISTER_CFA_OFFSET_FOR (fs, VSCR_REGNO, &vstate->vscr, new_cfa);
+ 	  REGISTER_CFA_OFFSET_FOR (fs, VRSAVE_REGNO, &vstate->vrsave, new_cfa);
+ 	}
+     }
+ 
+   return _URC_NO_REASON;
+ }
*** gcc/fold-const.c.0	2007-03-18 12:20:46.000000000 +0100
--- gcc/fold-const.c	2007-03-18 13:32:34.023707624 +0100
*************** fold_binary (enum tree_code code, tree t
*** 7644,7650 ****
  	     with one variable.  */
  	  if ((POINTER_TYPE_P (type)
  	       || (INTEGRAL_TYPE_P (type)
! 		   && !(TYPE_UNSIGNED (type) || flag_wrapv)))
  	      && var0 && var1)
  	    {
  	      tree tmp0 = var0;
--- 7644,7653 ----
  	     with one variable.  */
  	  if ((POINTER_TYPE_P (type)
  	       || (INTEGRAL_TYPE_P (type)
! 		   && !(TYPE_UNSIGNED (type)
! 			|| (TREE_CODE (type) == INTEGER_TYPE
! 			    && TYPE_IS_SIZETYPE (type))
! 			|| flag_wrapv)))
  	      && var0 && var1)
  	    {
  	      tree tmp0 = var0;
*** gcc/tree-nomudflap.c.0	2007-03-22 09:22:38.000000000 +0100
--- gcc/tree-nomudflap.c	2007-03-22 09:31:00.203876616 +0100
*************** mf_mark (tree t ATTRIBUTE_UNUSED)
*** 85,94 ****
  
  /* The pass structures must exist, but need not do anything.  */
  
  struct tree_opt_pass pass_mudflap_1 = 
  {
    "mudflap1",				/* name */
!   NULL,					/* gate */
    NULL,					/* execute */
    NULL,					/* sub */
    NULL,					/* next */
--- 85,100 ----
  
  /* The pass structures must exist, but need not do anything.  */
  
+ static bool
+ gate_mudflap (void)
+ {
+   return flag_mudflap != 0;
+ }
+ 
  struct tree_opt_pass pass_mudflap_1 = 
  {
    "mudflap1",				/* name */
!   gate_mudflap,				/* gate */
    NULL,					/* execute */
    NULL,					/* sub */
    NULL,					/* next */
*************** struct tree_opt_pass pass_mudflap_1 = 
*** 105,111 ****
  struct tree_opt_pass pass_mudflap_2 = 
  {
    "mudflap2",				/* name */
!   NULL,					/* gate */
    NULL,					/* execute */
    NULL,					/* sub */
    NULL,					/* next */
--- 111,117 ----
  struct tree_opt_pass pass_mudflap_2 = 
  {
    "mudflap2",				/* name */
!   gate_mudflap,				/* gate */
    NULL,					/* execute */
    NULL,					/* sub */
    NULL,					/* next */
*** gcc/common.opt.0	2007-03-26 22:23:20.000000000 +0200
--- gcc/common.opt	2007-03-26 22:34:11.000000000 +0200
*************** fkeep-inline-functions
*** 539,544 ****
--- 539,548 ----
  Common Report Var(flag_keep_inline_functions)
  Generate code for functions even if they are fully inlined
  
+ fkeep-nested-functions
+ Common Report Var(flag_keep_nested_functions)
+ Generate code for nested functions even if they are not used
+ 
  fkeep-static-consts
  Common Report Var(flag_keep_static_consts) Init(1)
  Emit static const variables even if they are not used
*** gcc/doc/invoke.texi.0	2007-03-26 22:23:27.000000000 +0200
--- gcc/doc/invoke.texi	2007-03-27 12:53:21.149609928 +0200
*************** Objective-C and Objective-C++ Dialects}.
*** 315,322 ****
  -floop-optimize -fcrossjumping  -fif-conversion  -fif-conversion2 @gol
  -finline-functions  -finline-functions-called-once @gol
  -finline-limit=@var{n}  -fkeep-inline-functions @gol
! -fkeep-static-consts  -fmerge-constants  -fmerge-all-constants @gol
! -fmodulo-sched -fno-branch-count-reg @gol
  -fno-default-inline  -fno-defer-pop -floop-optimize2 -fmove-loop-invariants @gol
  -fno-function-cse  -fno-guess-branch-probability @gol
  -fno-inline  -fno-math-errno  -fno-peephole  -fno-peephole2 @gol
--- 315,322 ----
  -floop-optimize -fcrossjumping  -fif-conversion  -fif-conversion2 @gol
  -finline-functions  -finline-functions-called-once @gol
  -finline-limit=@var{n}  -fkeep-inline-functions @gol
! -fkeep-nested-functions  -fkeep-static-consts  -fmerge-constants @gol
! -fmerge-all-constants  -fmodulo-sched  -fno-branch-count-reg @gol
  -fno-default-inline  -fno-defer-pop -floop-optimize2 -fmove-loop-invariants @gol
  -fno-function-cse  -fno-guess-branch-probability @gol
  -fno-inline  -fno-math-errno  -fno-peephole  -fno-peephole2 @gol
*************** of its callers.  This switch does not af
*** 4657,4662 ****
--- 4657,4668 ----
  @code{extern inline} extension in GNU C@.  In C++, emit any and all
  inline functions into the object file.
  
+ @item -fkeep-nested-functions
+ @opindex fkeep-nested-functions
+ Emit functions that are nested in other functions into the object file,
+ even if the function is not called or referenced in its parent function.
+ GCC discards these functions by default.
+ 
  @item -fkeep-static-consts
  @opindex fkeep-static-consts
  Emit variables declared @code{static const} when optimization isn't turned
*** gcc/tree-nested.c.0	2007-03-26 20:28:10.000000000 +0200
--- gcc/tree-nested.c	2007-03-27 00:08:12.000000000 +0200
*************** struct nesting_info GTY ((chain_next ("%
*** 104,109 ****
--- 104,112 ----
    bool reachable;
  };
  
+ static FILE *local_dump_file;
+ static int local_dump_flags;
+ 
  /* Whether to discard unreachable nested functions during this pass.
     If this is set to false, the pass will not differentiate objects
     referenced by a reachable inner function from objects referenced
*************** finalize_nesting_tree_1 (struct nesting_
*** 1580,1586 ****
  		      DECL_SAVED_TREE (root->context));
  
    /* Dump the translated tree function.  */
!   dump_function (TDI_nested, root->context);
  }
  
  static void
--- 1583,1590 ----
  		      DECL_SAVED_TREE (root->context));
  
    /* Dump the translated tree function.  */
!   if (local_dump_file)
!     dump_function_to_file (root->context, local_dump_file, local_dump_flags);
  }
  
  static void
*************** unnest_nesting_tree_1 (struct nesting_in
*** 1609,1615 ****
    if (node->origin)
      {
        if (IS_UNREACHABLE (root))
! 	cgraph_remove_node (node);
        else
  	{
  	  cgraph_unnest_node (node);
--- 1613,1624 ----
    if (node->origin)
      {
        if (IS_UNREACHABLE (root))
! 	{
! 	  cgraph_remove_node (node);
! 	  if (local_dump_file)
! 	    fprintf (local_dump_file, "Discarded %s\n",
! 		     lang_hooks.decl_printable_name (root->context, 2));
! 	}
        else
  	{
  	  cgraph_unnest_node (node);
*************** lower_nested_functions (tree fndecl)
*** 1661,1668 ****
    if (!cgn->nested)
      return;
  
!   /* Do not discard unreachable nested functions at -O0.  */
!   discard_unreachable = (optimize > 0);
  
    ni_map = htab_create (11, ni_hash, ni_eq, NULL);
    root = create_nesting_tree (cgn);
--- 1670,1679 ----
    if (!cgn->nested)
      return;
  
!   local_dump_file = dump_begin (TDI_nested, &local_dump_flags);
! 
!   /* Discard unreachable nested functions unless instructed not to.  */
!   discard_unreachable = (flag_keep_nested_functions == 0);
  
    ni_map = htab_create (11, ni_hash, ni_eq, NULL);
    root = create_nesting_tree (cgn);
*************** lower_nested_functions (tree fndecl)
*** 1678,1683 ****
--- 1689,1697 ----
    free_nesting_tree (root);
    root = NULL;
    htab_delete (ni_map);
+ 
+   if (local_dump_file)
+     dump_end (TDI_nested, local_dump_file);
  }
  
  #include "gt-tree-nested.h"
*** gcc/cfgexpand.c.0	2007-03-28 09:03:14.417957072 +0200
--- gcc/cfgexpand.c	2007-03-28 09:20:27.605888632 +0200
*************** tree_expand_cfg (void)
*** 1634,1642 ****
    /* We're done expanding trees to RTL.  */
    currently_expanding_to_rtl = 0;
  
!   /* Convert tree EH labels to RTL EH labels, and clean out any unreachable
!      EH regions.  */
    convert_from_eh_region_ranges ();
  
    rebuild_jump_labels (get_insns ());
    find_exception_handler_labels ();
--- 1634,1643 ----
    /* We're done expanding trees to RTL.  */
    currently_expanding_to_rtl = 0;
  
!   /* Convert tree EH labels to RTL EH labels and zap the tree
!      EH table to avoid dangling references during GC.  */
    convert_from_eh_region_ranges ();
+   set_eh_throw_stmt_table (cfun, NULL);
  
    rebuild_jump_labels (get_insns ());
    find_exception_handler_labels ();
*** gcc/tree-cfg.c.0	2007-03-27 16:29:14.000000000 +0200
--- gcc/tree-cfg.c	2007-03-28 00:23:41.000000000 +0200
*************** bsi_replace (const block_stmt_iterator *
*** 2877,2883 ****
      {
        eh_region = lookup_stmt_eh_region (orig_stmt);
        if (eh_region >= 0)
! 	add_stmt_to_eh_region (stmt, eh_region);
      }
  
    delink_stmt_imm_use (orig_stmt);
--- 2877,2886 ----
      {
        eh_region = lookup_stmt_eh_region (orig_stmt);
        if (eh_region >= 0)
! 	{
! 	  remove_stmt_from_eh_region (stmt);
! 	  add_stmt_to_eh_region (stmt, eh_region);
! 	}
      }
  
    delink_stmt_imm_use (orig_stmt);
*** gcc/function.h.0	2007-04-04 13:44:03.000000000 +0200
--- gcc/function.h	2007-04-04 13:48:56.000000000 +0200
*************** struct function GTY(())
*** 375,380 ****
--- 375,383 ----
    /* UIDs for LABEL_DECLs.  */
    int last_label_uid;
  
+   /* Number of tree constants deferred for this function.  */
+   unsigned int deferred_constants;
+ 
    /* Line number of the end of the function.  */
    location_t function_end_locus;
  
*************** extern int trampolines_created;
*** 546,551 ****
--- 549,555 ----
  #define avail_temp_slots (cfun->x_avail_temp_slots)
  #define temp_slot_level (cfun->x_temp_slot_level)
  #define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)
+ #define n_deferred_constants (cfun->deferred_constants)
  
  /* Given a function decl for a containing function,
     return the `struct function' for it.  */
*** gcc/tree.h.0	2007-04-04 11:45:58.000000000 +0200
--- gcc/tree.h	2007-04-01 07:42:00.000000000 +0200
*************** extern void internal_reference_types (vo
*** 4127,4132 ****
--- 4127,4133 ----
  extern unsigned int update_alignment_for_field (record_layout_info, tree,
                                                  unsigned int);
  /* varasm.c */
+ extern tree tree_output_constant_def (tree);
  extern void make_decl_rtl (tree);
  extern void make_decl_one_only (tree);
  extern int supports_one_only (void);
*** gcc/tree-inline.c.0	2007-04-04 15:03:10.394761464 +0200
--- gcc/tree-inline.c	2007-04-04 15:04:10.092686000 +0200
*************** expand_call_inline (basic_block bb, tree
*** 2217,2222 ****
--- 2217,2225 ----
  					       cfun->unexpanded_var_list);
      }
  
+   /* As well as deferred constants.  */
+   cfun->deferred_constants += id->callee_cfun->deferred_constants;
+ 
    /* Clean up.  */
    splay_tree_delete (id->decl_map);
    id->decl_map = st;
*** gcc/varasm.c.0	2007-04-04 10:43:13.000000000 +0200
--- gcc/varasm.c	2007-04-05 16:58:34.719753456 +0200
*************** struct varasm_status GTY(())
*** 74,87 ****
  {
    /* If we're using a per-function constant pool, this is it.  */
    struct rtx_constant_pool *pool;
- 
-   /* Number of tree-constants deferred during the expansion of this
-      function.  */
-   unsigned int deferred_constants;
  };
  
- #define n_deferred_constants (cfun->varasm->deferred_constants)
- 
  /* Number for making the label on the next
     constant that is stored in memory.  */
  
--- 74,81 ----
*************** struct constant_descriptor_tree GTY(())
*** 2395,2400 ****
--- 2389,2397 ----
    /* A MEM for the constant.  */
    rtx rtl;
  
+   /* A VAR_DECL for the constant.  */
+   tree decl;
+ 
    /* The value of the constant.  */
    tree value;
  
*************** build_constant_desc (tree exp)
*** 2749,2754 ****
--- 2746,2752 ----
  
    desc = ggc_alloc (sizeof (*desc));
    desc->value = copy_constant (exp);
+   desc->decl = NULL_TREE;
  
    /* Propagate marked-ness to copied constant.  */
    if (flag_mudflap && mf_marked_p (exp))
*************** lookup_constant_def (tree exp)
*** 2920,2925 ****
--- 2918,2977 ----
  
    return (desc ? desc->rtl : NULL_RTX);
  }
+ 
+ /* Return a tree representing a reference to constant data in memory
+    for the constant expression EXP.  This is the counterpart of
+    output_constant_def at the tree level.  */
+ 
+ tree
+ tree_output_constant_def (tree exp)
+ {
+   struct constant_descriptor_tree *desc;
+   struct constant_descriptor_tree key;
+   void **loc;
+ 
+   /* Look up EXP in the table of constant descriptors.  If we didn't find
+      it, create a new one.  */
+   key.value = exp;
+   key.hash = const_hash_1 (exp);
+   loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);
+ 
+   desc = *loc;
+   if (desc == 0)
+     {
+       desc = build_constant_desc (exp);
+       desc->hash = key.hash;
+       *loc = desc;
+     }
+ 
+   if (desc->decl == NULL_TREE)
+     {
+       tree var
+	= build_decl (VAR_DECL, get_identifier (XSTR (XEXP (desc->rtl, 0), 0)),
+		      TREE_TYPE (exp));
+       DECL_ARTIFICIAL (var) = 1;
+       DECL_IGNORED_P (var) = 1;
+       TREE_READONLY (var) = 1;
+       TREE_STATIC (var) = 1;
+       TREE_ADDRESSABLE (var) = 1;
+       /* Declare it with the cgraph machinery to make sure objects
+ 	 referenced in the expression are not discarded, but pretend
+ 	 that it has already been expanded to RTL and assembled in
+ 	 order not to interfere with the varasm machinery.  */
+       DECL_INITIAL (var) = desc->value;
+       SET_DECL_RTL (var, desc->rtl);
+       TREE_ASM_WRITTEN (var) = 1;
+       rest_of_decl_compilation (var, 0, 0);
+       desc->decl = var;
+     }
+ 
+   /* See maybe_output_constant_def_contents.  We always defer
+      constants at the tree level.  */
+   if (cfun)
+     n_deferred_constants++;
+ 
+   return desc->decl;
+ }
  
  /* Used in the hash tables to avoid outputting the same constant
     twice.  Unlike 'struct constant_descriptor_tree', RTX constants
*************** init_varasm_status (struct function *f)
*** 3096,3102 ****
  
    pool = ggc_alloc (sizeof (struct rtx_constant_pool));
    p->pool = pool;
-   p->deferred_constants = 0;
  
    pool->const_rtx_htab = htab_create_ggc (31, const_desc_rtx_hash,
  					  const_desc_rtx_eq, NULL);
--- 3146,3151 ----
*** gcc/doc/invoke.texi.0	2007-04-17 18:33:13.000000000 +0200
--- gcc/doc/invoke.texi	2007-04-17 18:42:36.000000000 +0200
*************** Free form Fortran source code which shou
*** 880,885 ****
--- 880,888 ----
  Free form Fortran source code which must be preprocessed (with the
  traditional preprocessor).
  
+ @item @var{file}.idl
+ OMG IDL file which must be preprocessed.
+ 
  @c FIXME: Descriptions of Java file types.
  @c @var{file}.java
  @c @var{file}.class
*************** objective-c++ objective-c++-header objec
*** 932,937 ****
--- 935,941 ----
  assembler  assembler-with-cpp
  ada
  f95  f95-cpp-input
+ idl
  java
  treelang
  @end smallexample
*** gcc/c.opt.0	2007-04-17 17:35:51.000000000 +0200
--- gcc/c.opt	2007-04-17 17:36:03.000000000 +0200
*************** C Undocumented
*** 791,796 ****
--- 791,799 ----
  lang-fortran
  C Undocumented
  
+ lang-idl
+ C Undocumented
+ 
  lang-objc
  C ObjC C++ ObjC++ Undocumented
  
*** gcc/c-opts.c.0	2007-04-17 17:35:34.000000000 +0200
--- gcc/c-opts.c	2007-04-17 20:52:30.909105160 +0200
*************** c_common_init_options (unsigned int argc
*** 240,245 ****
--- 240,250 ----
  	    result |= CL_C | CL_ObjC | CL_CXX | CL_ObjCXX;
  	    break;
  	  }
+ 	else if (! strcmp (argv[i], "-lang-idl"))
+ 	  {
+ 	    result |= CL_C | CL_CXX;
+ 	    break;
+ 	  }
  
  #ifdef CL_Fortran
        for (i = 1; i < argc; i++)
*************** c_common_handle_option (size_t scode, co
*** 853,858 ****
--- 858,867 ----
        lang_fortran = true;
        break;
  
+     case OPT_lang_idl:
+       cpp_set_lang (parse_in, CLK_CXX98);
+       break;
+ 
      case OPT_lang_objc:
        cpp_opts->objc = 1;
        break;
*** gcc/gcc.c.0	2007-04-17 16:48:27.000000000 +0200
--- gcc/gcc.c	2007-04-17 18:35:39.000000000 +0200
*************** static const struct compiler default_com
*** 996,1001 ****
--- 996,1005 ----
         as %(asm_debug) %(asm_options) %m.s %A }}}}"
  #endif
     , 0, 1, 0},
+   {".idl", "@idl", 0, 1, 0},
+   {"@idl",
+     "%{E:%(trad_capable_cpp) -lang-idl %(cpp_options) %(cpp_debug_options)}\
+      %{!E:%e-E required for IDL file}", 0, 1, 0},
  
  #include "specs.h"
    /* Mark end of table.  */
*** gcc/tree-sra.c.0	2007-05-09 16:16:09.558665016 +0200
--- gcc/tree-sra.c	2007-05-09 16:20:43.593005464 +0200
*************** decide_block_copy (struct sra_elt *elt)
*** 1407,1414 ****
        return false;
      }
  
!   /* Don't decide if we've no uses.  */
!   if (elt->n_uses == 0 && elt->n_copies == 0)
      ;
  
    else if (!elt->is_scalar)
--- 1407,1414 ----
        return false;
      }
  
!   /* Don't decide if we've no uses and no groups.  */
!   if (elt->n_uses == 0 && elt->n_copies == 0 && elt->groups == NULL)
      ;
  
    else if (!elt->is_scalar)
*** gcc/expr.c.ori	Sat May  5 16:21:28 2007
--- gcc/expr.c	Thu May 10 14:57:06 2007
*************** handled_component_p (tree t)
*** 5773,5778 ****
--- 5773,5816 ----
        return 0;
      }
  }
+ 
+ /* Alignment in bits the TARGET of an assignment may be assumed to have.  */
+ 
+ static unsigned HOST_WIDE_INT
+ target_align (tree target)
+ {
+   /* We might have a chain of nested references with intermediate misaligning
+      bitfields components, so need to recurse to find out.  */
+ 
+   unsigned HOST_WIDE_INT this_align, outer_align;
+ 
+   switch (TREE_CODE (target))
+     {
+     case BIT_FIELD_REF:
+     case COMPONENT_REF:
+       this_align = DECL_ALIGN (TREE_OPERAND (target, 1));
+       outer_align = target_align (TREE_OPERAND (target, 0));
+       return MIN (this_align, outer_align);
+ 
+     case ARRAY_REF:
+     case ARRAY_RANGE_REF:
+       this_align = TYPE_ALIGN (TREE_TYPE (target));
+       outer_align = target_align (TREE_OPERAND (target, 0));
+       return MIN (this_align, outer_align);
+ 
+     case NON_LVALUE_EXPR:
+     case VIEW_CONVERT_EXPR:
+     case NOP_EXPR:
+     case CONVERT_EXPR:
+       this_align = TYPE_ALIGN (TREE_TYPE (target));
+       outer_align = target_align (TREE_OPERAND (target, 0));
+       return MAX (this_align, outer_align);
+ 
+     default:
+       return TYPE_ALIGN (TREE_TYPE (target));
+     }
+ }
+ 
  
  /* Given an rtx VALUE that may contain additions and multiplications, return
     an equivalent value that just refers to a register, memory, or constant.
*************** highest_pow2_factor (tree exp)
*** 6199,6219 ****
  }
  
  /* Similar, except that the alignment requirements of TARGET are
!    taken into account.  Assume it is at least as aligned as its
!    type, unless it is a COMPONENT_REF in which case the layout of
!    the structure gives the alignment.  */
  
  static unsigned HOST_WIDE_INT
  highest_pow2_factor_for_target (tree target, tree exp)
  {
!   unsigned HOST_WIDE_INT target_align, factor;
! 
!   factor = highest_pow2_factor (exp);
!   if (TREE_CODE (target) == COMPONENT_REF)
!     target_align = DECL_ALIGN_UNIT (TREE_OPERAND (target, 1));
!   else
!     target_align = TYPE_ALIGN_UNIT (TREE_TYPE (target));
!   return MAX (factor, target_align);
  }
  
  /* Expands variable VAR.  */
--- 6237,6251 ----
  }
  
  /* Similar, except that the alignment requirements of TARGET are
!    taken into account.  */
  
  static unsigned HOST_WIDE_INT
  highest_pow2_factor_for_target (tree target, tree exp)
  {
!    unsigned HOST_WIDE_INT talign = target_align (target) / BITS_PER_UNIT;
!    unsigned HOST_WIDE_INT factor = highest_pow2_factor (exp);
!    
!    return MAX (factor, talign);
  }
  
  /* Expands variable VAR.  */
*** gcc/output.h.0	2007-03-13 21:29:04.598889240 +0100
--- gcc/output.h	2007-03-12 07:53:00.000000000 +0100
*************** extern void output_constant_pool (const 
*** 353,359 ****
     its elements are.  This used to be internal to initializer_constant_valid_p
     and has been exposed to let other functions like categorize_ctor_elements
     evaluate the property while walking a constructor for other purposes.  */
- 
  extern bool constructor_static_from_elts_p (tree);
  
  /* Return nonzero if VALUE is a valid constant-valued expression
--- 353,358 ----
*************** extern bool constructor_static_from_elts
*** 367,372 ****
--- 366,376 ----
     arithmetic-combinations of integers.  */
  extern tree initializer_constant_valid_p (tree, tree);
  
+ /* Return true if VALUE is a valid constant-valued expression
+    for use in initializing a static bit-field; one that can be
+    an element of a "constant" initializer.  */
+ extern bool initializer_constant_valid_for_bitfield_p (tree);
+ 
  /* Output assembler code for constant EXP to FILE, with no label.
     This includes the pseudo-op such as ".int" or ".byte", and a newline.
     Assumes output_addressed_constants has been done on EXP already.
*** gcc/varasm.c.0	2007-05-10 12:14:41.846975928 +0200
--- gcc/varasm.c	2007-05-10 12:15:02.116894432 +0200
*************** static void output_constant_def_contents
*** 118,124 ****
  static void output_addressed_constants (tree);
  static unsigned HOST_WIDE_INT array_size_for_constructor (tree);
  static unsigned min_align (unsigned, unsigned);
- static void output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int);
  static void globalize_decl (tree);
  static void maybe_assemble_visibility (tree);
  static int in_named_entry_eq (const void *, const void *);
--- 118,123 ----
*************** initializer_constant_valid_p (tree value
*** 3923,3929 ****
  
    return 0;
  }
! 
  /* Output assembler code for constant EXP to FILE, with no label.
     This includes the pseudo-op such as ".int" or ".byte", and a newline.
     Assumes output_addressed_constants has been done on EXP already.
--- 3922,3978 ----
  
    return 0;
  }
! 
! /* Return true if VALUE is a valid constant-valued expression
!    for use in initializing a static bit-field; one that can be
!    an element of a "constant" initializer.  */
! 
! bool
! initializer_constant_valid_for_bitfield_p (tree value)
! {
!   /* Give the front-end a chance to convert VALUE to something that
!      looks more like a constant to the back-end.  */
!   value = lang_hooks.expand_constant (value);
! 
!   switch (TREE_CODE (value))
!     {
!     case CONSTRUCTOR:
!       {
! 	unsigned HOST_WIDE_INT idx;
! 	tree elt;
! 
! 	FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (value), idx, elt)
! 	  if (!initializer_constant_valid_for_bitfield_p (elt))
! 	    return false;
! 	return true;
!       }
! 
!     case INTEGER_CST:
!       return true;
! 
!     case VIEW_CONVERT_EXPR:
!     case NON_LVALUE_EXPR:
!       return
! 	initializer_constant_valid_for_bitfield_p (TREE_OPERAND (value, 0));
! 
!     default:
!       break;
!     }
! 
!   return false;
! }
! 
! struct oc_data
! {
!   unsigned int bit_offset;
!   int byte;
! };
! 
! static unsigned HOST_WIDE_INT output_constructor (tree,
! 						  unsigned HOST_WIDE_INT,
! 						  unsigned int,
! 						  struct oc_data *);
! 
  /* Output assembler code for constant EXP to FILE, with no label.
     This includes the pseudo-op such as ".int" or ".byte", and a newline.
     Assumes output_addressed_constants has been done on EXP already.
*************** output_constant (tree exp, unsigned HOST
*** 4065,4071 ****
        switch (TREE_CODE (exp))
  	{
  	case CONSTRUCTOR:
! 	  output_constructor (exp, size, align);
  	  return;
  	case STRING_CST:
  	  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),
--- 4114,4120 ----
        switch (TREE_CODE (exp))
  	{
  	case CONSTRUCTOR:
! 	  output_constructor (exp, size, align, NULL);
  	  return;
  	case STRING_CST:
  	  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),
*************** output_constant (tree exp, unsigned HOST
*** 4103,4109 ****
      case RECORD_TYPE:
      case UNION_TYPE:
        gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);
!       output_constructor (exp, size, align);
        return;
  
      case ERROR_MARK:
--- 4152,4158 ----
      case RECORD_TYPE:
      case UNION_TYPE:
        gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);
!       output_constructor (exp, size, align, NULL);
        return;
  
      case ERROR_MARK:
*************** array_size_for_constructor (tree val)
*** 4160,4170 ****
  }
  
  /* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).
!    Generate at least SIZE bytes, padding if necessary.  */
  
! static void
  output_constructor (tree exp, unsigned HOST_WIDE_INT size,
! 		    unsigned int align)
  {
    tree type = TREE_TYPE (exp);
    tree field = 0;
--- 4209,4221 ----
  }
  
  /* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).
!    Generate at least SIZE bytes, padding if necessary, and return the number
!    of bytes effectively output.  ALIGN is the alignment of the data in bits.
!    RECURSE must only be set for recursive calls.  */
  
! static unsigned HOST_WIDE_INT
  output_constructor (tree exp, unsigned HOST_WIDE_INT size,
! 		    unsigned int align, struct oc_data *recurse)
  {
    tree type = TREE_TYPE (exp);
    tree field = 0;
*************** output_constructor (tree exp, unsigned H
*** 4172,4180 ****
    /* Number of bytes output or skipped so far.
       In other words, current position within the constructor.  */
    HOST_WIDE_INT total_bytes = 0;
    /* Nonzero means BYTE contains part of a byte, to be output.  */
!   int byte_buffer_in_use = 0;
!   int byte = 0;
    unsigned HOST_WIDE_INT cnt;
    constructor_elt *ce;
  
--- 4223,4236 ----
    /* Number of bytes output or skipped so far.
       In other words, current position within the constructor.  */
    HOST_WIDE_INT total_bytes = 0;
+ 
+   /* Relative index of the last array element output as part of an outer
+      bitfield.  */
+   HOST_WIDE_INT last_relative_index = -1;
+   
    /* Nonzero means BYTE contains part of a byte, to be output.  */
!   bool byte_buffer_in_use = recurse ? true : false;
!   int byte = recurse ? recurse->byte : 0;
    unsigned HOST_WIDE_INT cnt;
    constructor_elt *ce;
  
*************** output_constructor (tree exp, unsigned H
*** 4213,4218 ****
--- 4269,4278 ----
        else if (TREE_CODE (type) == ARRAY_TYPE)
  	index = ce->index;
  
+       /* We don't handle designated initializers for array ranges within
+ 	 bitfields and expect never to see one here.  */
+       gcc_assert (!(recurse && index && TREE_CODE (index) == RANGE_EXPR));
+ 
  #ifdef ASM_COMMENT_START
        if (field && flag_verbose_asm)
  	fprintf (asm_out_file, "%s %s:\n",
*************** output_constructor (tree exp, unsigned H
*** 4226,4232 ****
        if (val != 0)
  	STRIP_NOPS (val);
  
!       if (index && TREE_CODE (index) == RANGE_EXPR)
  	{
  	  unsigned HOST_WIDE_INT fieldsize
  	    = int_size_in_bytes (TREE_TYPE (type));
--- 4286,4293 ----
        if (val != 0)
  	STRIP_NOPS (val);
  
!       if (!recurse
! 	  && index && TREE_CODE (index) == RANGE_EXPR)
  	{
  	  unsigned HOST_WIDE_INT fieldsize
  	    = int_size_in_bytes (TREE_TYPE (type));
*************** output_constructor (tree exp, unsigned H
*** 4247,4255 ****
  	      total_bytes += fieldsize;
  	    }
  	}
!       else if (field == 0 || !DECL_BIT_FIELD (field))
  	{
! 	  /* An element that is not a bit-field.  */
  
  	  unsigned HOST_WIDE_INT fieldsize;
  	  /* Since this structure is static,
--- 4308,4319 ----
  	      total_bytes += fieldsize;
  	    }
  	}
!       else if (!recurse
! 	       && (!field
! 		   || !DECL_BIT_FIELD (field)
! 		   || DECL_MODE (field) == BLKmode))
  	{
! 	  /* An element that is not a true bit-field or part of one.  */
  
  	  unsigned HOST_WIDE_INT fieldsize;
  	  /* Since this structure is static,
*************** output_constructor (tree exp, unsigned H
*** 4266,4272 ****
  	    {
  	      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
  	      total_bytes++;
! 	      byte_buffer_in_use = 0;
  	    }
  
  	  /* Advance to offset of this element.
--- 4330,4336 ----
  	    {
  	      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
  	      total_bytes++;
! 	      byte_buffer_in_use = false;
  	    }
  
  	  /* Advance to offset of this element.
*************** output_constructor (tree exp, unsigned H
*** 4321,4340 ****
  	  /* Count its size.  */
  	  total_bytes += fieldsize;
  	}
-       else if (val != 0 && TREE_CODE (val) != INTEGER_CST)
- 	error ("invalid initial value for member %qs",
- 	       IDENTIFIER_POINTER (DECL_NAME (field)));
        else
  	{
! 	  /* Element that is a bit-field.  */
  
! 	  HOST_WIDE_INT next_offset = int_bit_position (field);
! 	  HOST_WIDE_INT end_offset
! 	    = (next_offset + tree_low_cst (DECL_SIZE (field), 1));
  
  	  if (val == 0)
  	    val = integer_zero_node;
  
  	  /* If this field does not start in this (or, next) byte,
  	     skip some bytes.  */
  	  if (next_offset / BITS_PER_UNIT != total_bytes)
--- 4385,4436 ----
  	  /* Count its size.  */
  	  total_bytes += fieldsize;
  	}
        else
  	{
! 	  /* An element that is a true bit-field, or part of an outer one if
! 	     recurse != 0.  This might be part of a nested array, so we don't
! 	     necessarily have a "field" at hand and rely on the relative index
! 	     to compute the position in such a case.  */
! 
! 	  HOST_WIDE_INT bit_size
! 	    = (field
! 	       ? tree_low_cst (DECL_SIZE (field), 1)
! 	       : tree_low_cst (TYPE_SIZE (TREE_TYPE (type)), 1));
! 
! 	  HOST_WIDE_INT relative_index
! 	    = (!field
! 	       ? (index
! 		  ? (tree_low_cst (index, 0) - tree_low_cst (min_index, 0))
! 		  : last_relative_index + 1)
! 	       : 0);
! 
! 	  HOST_WIDE_INT bit_pos
! 	    = ((recurse ? recurse->bit_offset : 0)
! 	       + (field
! 		  ? int_bit_position (field) 
! 		  : bit_size * relative_index));
! 
! 	  /* next_offset is the adjusted offset from the beginning of the
! 	     structure to the first bit of this element to be processed.
! 	     end_offset is the adjusted offset from the beginning of the
! 	     structure to the first bit past the end of this element.  */
! 	  HOST_WIDE_INT next_offset = bit_pos;
! 	  HOST_WIDE_INT end_offset = bit_pos + bit_size;
  
! 	  last_relative_index = relative_index;
  
  	  if (val == 0)
  	    val = integer_zero_node;
  
+ 	  while (TREE_CODE (val) == VIEW_CONVERT_EXPR
+ 		 || TREE_CODE (val) == NON_LVALUE_EXPR)
+ 	    val = TREE_OPERAND (val, 0);
+ 
+ 	  if (TREE_CODE (val) != INTEGER_CST
+ 	      && TREE_CODE (val) != CONSTRUCTOR)
+ 	    error ("invalid initial value for member %qs",
+ 		   IDENTIFIER_POINTER (DECL_NAME (field)));
+ 
  	  /* If this field does not start in this (or, next) byte,
  	     skip some bytes.  */
  	  if (next_offset / BITS_PER_UNIT != total_bytes)
*************** output_constructor (tree exp, unsigned H
*** 4344,4350 ****
  		{
  		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
  		  total_bytes++;
! 		  byte_buffer_in_use = 0;
  		}
  
  	      /* If still not at proper byte, advance to there.  */
--- 4440,4446 ----
  		{
  		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
  		  total_bytes++;
! 		  byte_buffer_in_use = false;
  		}
  
  	      /* If still not at proper byte, advance to there.  */
*************** output_constructor (tree exp, unsigned H
*** 4356,4474 ****
  		}
  	    }
  
! 	  if (! byte_buffer_in_use)
! 	    byte = 0;
! 
! 	  /* We must split the element into pieces that fall within
! 	     separate bytes, and combine each byte with previous or
! 	     following bit-fields.  */
! 
! 	  /* next_offset is the offset n fbits from the beginning of
! 	     the structure to the next bit of this element to be processed.
! 	     end_offset is the offset of the first bit past the end of
! 	     this element.  */
! 	  while (next_offset < end_offset)
  	    {
! 	      int this_time;
! 	      int shift;
! 	      HOST_WIDE_INT value;
! 	      HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
! 	      HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
! 
! 	      /* Advance from byte to byte
! 		 within this element when necessary.  */
! 	      while (next_byte != total_bytes)
! 		{
! 		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
! 		  total_bytes++;
! 		  byte = 0;
! 		}
! 
! 	      /* Number of bits we can process at once
! 		 (all part of the same byte).  */
! 	      this_time = MIN (end_offset - next_offset,
! 			       BITS_PER_UNIT - next_bit);
! 	      if (BYTES_BIG_ENDIAN)
! 		{
! 		  /* On big-endian machine, take the most significant bits
! 		     first (of the bits that are significant)
! 		     and put them into bytes from the most significant end.  */
! 		  shift = end_offset - next_offset - this_time;
! 
! 		  /* Don't try to take a bunch of bits that cross
! 		     the word boundary in the INTEGER_CST. We can
! 		     only select bits from the LOW or HIGH part
! 		     not from both.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT
! 		      && shift + this_time > HOST_BITS_PER_WIDE_INT)
! 		    {
! 		      this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;
! 		      shift = HOST_BITS_PER_WIDE_INT;
! 		    }
! 
! 		  /* Now get the bits from the appropriate constant word.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT)
! 		    value = TREE_INT_CST_LOW (val);
! 		  else
! 		    {
! 		      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
! 		      value = TREE_INT_CST_HIGH (val);
! 		      shift -= HOST_BITS_PER_WIDE_INT;
! 		    }
! 
! 		  /* Get the result. This works only when:
! 		     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
! 		  byte |= (((value >> shift)
! 			    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
! 			   << (BITS_PER_UNIT - this_time - next_bit));
! 		}
! 	      else
! 		{
! 		  /* On little-endian machines,
! 		     take first the least significant bits of the value
! 		     and pack them starting at the least significant
! 		     bits of the bytes.  */
! 		  shift = next_offset - int_bit_position (field);
! 
! 		  /* Don't try to take a bunch of bits that cross
! 		     the word boundary in the INTEGER_CST. We can
! 		     only select bits from the LOW or HIGH part
! 		     not from both.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT
! 		      && shift + this_time > HOST_BITS_PER_WIDE_INT)
! 		    this_time = (HOST_BITS_PER_WIDE_INT - shift);
! 
! 		  /* Now get the bits from the appropriate constant word.  */
! 		  if (shift < HOST_BITS_PER_WIDE_INT)
! 		    value = TREE_INT_CST_LOW (val);
! 		  else
! 		    {
! 		      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
! 		      value = TREE_INT_CST_HIGH (val);
! 		      shift -= HOST_BITS_PER_WIDE_INT;
! 		    }
! 
! 		  /* Get the result. This works only when:
! 		     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
! 		  byte |= (((value >> shift)
! 			    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
! 			   << next_bit);
! 		}
  
! 	      next_offset += this_time;
! 	      byte_buffer_in_use = 1;
  	    }
  	}
      }
  
!   if (byte_buffer_in_use)
      {
!       assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
!       total_bytes++;
      }
  
!   if ((unsigned HOST_WIDE_INT)total_bytes < size)
!     assemble_zeros (size - total_bytes);
  }
  
  /* This TREE_LIST contains any weak symbol declarations waiting
--- 4452,4589 ----
  		}
  	    }
  
! 	  /* Set up the buffer if necessary.  */
! 	  if (!byte_buffer_in_use)
  	    {
! 	      byte = 0;
! 	      if (bit_size > 0)
! 		byte_buffer_in_use = true;
! 	    }
  
! 	  if (TREE_CODE (val) == CONSTRUCTOR)
! 	    {
! 	      /* We must recursively pass the bit offset and the pending
! 		 data and retrieve the new pending data afterwards.  */
! 	      struct oc_data inner;
! 	      inner.bit_offset = next_offset % BITS_PER_UNIT;
! 	      inner.byte = byte;
! 	      total_bytes += output_constructor (val, 0, 0, &inner);
! 	      byte = inner.byte;
  	    }
+ 	  else
+ 	    /* We must split the element into pieces that fall within
+ 	       separate bytes, and combine each byte with previous or
+ 	       following bit-fields.  */
+ 	    while (next_offset < end_offset)
+ 	      {
+ 		HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
+ 		HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
+ 		HOST_WIDE_INT value;
+ 		int this_time, shift;
+ 
+ 		/* Advance from byte to byte within this element.  */
+ 		while (next_byte != total_bytes)
+ 		  {
+ 		    assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
+ 		    total_bytes++;
+ 		    byte = 0;
+ 		  }
+ 
+ 		/* Number of bits we can process (part of the same byte).  */
+ 		this_time
+ 		  = MIN (end_offset - next_offset, BITS_PER_UNIT - next_bit);
+ 
+ 		if (BYTES_BIG_ENDIAN)
+ 		  {
+ 		    /* On big-endian machine, take the most significant bits
+ 		       first (of the bits that are significant) and put them
+ 		       into bytes from the most significant end.  */
+ 		    shift = end_offset - next_offset - this_time;
+ 
+ 		    /* Don't try to take a bunch of bits that cross
+ 		       the word boundary in the INTEGER_CST. We can
+ 		       only select bits from the LOW or HIGH part
+ 		       not from both.  */
+ 		    if (shift < HOST_BITS_PER_WIDE_INT
+ 			&& shift + this_time > HOST_BITS_PER_WIDE_INT)
+ 		      {
+ 			this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;
+ 			shift = HOST_BITS_PER_WIDE_INT;
+ 		      }
+ 
+ 		    /* Now get the bits from the appropriate constant word.  */
+ 		    if (shift < HOST_BITS_PER_WIDE_INT)
+ 		      value = TREE_INT_CST_LOW (val);
+ 		    else
+ 		      {
+ 			gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
+ 			value = TREE_INT_CST_HIGH (val);
+ 			shift -= HOST_BITS_PER_WIDE_INT;
+ 		      }
+ 
+ 		    /* Get the result. This works only when:
+ 		       1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
+ 		    byte |= (((value >> shift)
+ 			      & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
+ 			     << (BITS_PER_UNIT - this_time - next_bit));
+ 		  }
+ 		else
+ 		  {
+ 		    /* On little-endian machines, take first the least
+ 		       significant bits of the value and pack them starting
+ 		       at the least significant bits of the bytes.  */
+ 		    shift = next_offset - bit_pos;
+ 
+ 		    /* Don't try to take a bunch of bits that cross
+ 		       the word boundary in the INTEGER_CST. We can
+ 		       only select bits from the LOW or HIGH part
+ 		       not from both.  */
+ 		    if (shift < HOST_BITS_PER_WIDE_INT
+ 			&& shift + this_time > HOST_BITS_PER_WIDE_INT)
+ 		      this_time = (HOST_BITS_PER_WIDE_INT - shift);
+ 
+ 		    /* Now get the bits from the appropriate constant word.  */
+ 		    if (shift < HOST_BITS_PER_WIDE_INT)
+ 		      value = TREE_INT_CST_LOW (val);
+ 		    else
+ 		      {
+ 			gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);
+ 			value = TREE_INT_CST_HIGH (val);
+ 			shift -= HOST_BITS_PER_WIDE_INT;
+ 		      }
+ 
+ 		    /* Get the result. This works only when:
+ 		       1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
+ 		    byte |= (((value >> shift)
+ 			      & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
+ 			     << next_bit);
+ 		  }
+ 
+ 		next_offset += this_time;
+ 	      }
  	}
      }
  
!   /* If we are not at toplevel, save the pending data for our caller.
!      Otherwise output the pending data and padding zeros as needed. */
!   if (recurse)
!     recurse->byte = byte;
!   else
      {
!       if (byte_buffer_in_use)
! 	{
! 	  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
! 	  total_bytes++;
! 	}
! 
!       if ((unsigned HOST_WIDE_INT)total_bytes < size)
! 	{
! 	  assemble_zeros (size - total_bytes);
! 	  total_bytes = size;
! 	}
      }
  
!   return total_bytes;
  }
  
  /* This TREE_LIST contains any weak symbol declarations waiting
*** gcc/passes.c.0	2007-05-19 16:03:15.000000000 +0200
--- gcc/passes.c	2007-05-20 15:29:56.000000000 +0200
*************** init_optimization_passes (void)
*** 561,567 ****
       may help.  */
    NEXT_PASS (pass_late_warn_uninitialized);
    NEXT_PASS (pass_dse);
!   NEXT_PASS (pass_forwprop);
    NEXT_PASS (pass_phiopt);
    NEXT_PASS (pass_tail_calls);
    NEXT_PASS (pass_rename_ssa_copies);
--- 561,567 ----
       may help.  */
    NEXT_PASS (pass_late_warn_uninitialized);
    NEXT_PASS (pass_dse);
!   NEXT_PASS (pass_forwprop_final);
    NEXT_PASS (pass_phiopt);
    NEXT_PASS (pass_tail_calls);
    NEXT_PASS (pass_rename_ssa_copies);
*** gcc/tree-pass.h.0	2007-05-19 16:03:15.000000000 +0200
--- gcc/tree-pass.h	2007-05-19 16:03:00.000000000 +0200
*************** extern struct tree_opt_pass pass_warn_fu
*** 264,269 ****
--- 264,270 ----
  extern struct tree_opt_pass pass_warn_function_noreturn;
  extern struct tree_opt_pass pass_phiopt;
  extern struct tree_opt_pass pass_forwprop;
+ extern struct tree_opt_pass pass_forwprop_final;
  extern struct tree_opt_pass pass_redundant_phi;
  extern struct tree_opt_pass pass_dse;
  extern struct tree_opt_pass pass_nrv;
*** gcc/tree-ssa-forwprop.c.0	2008-12-12 18:21:37.000000000 +0100
--- gcc/tree-ssa-forwprop.c	2008-12-12 18:23:04.000000000 +0100
*************** forward_propagate_addr_expr (tree stmt)
*** 680,689 ****
    return false;
  }
  
  /* Main entry point for the forward propagation optimizer.  */
  
  static void
! tree_ssa_forward_propagate_single_use_vars (void)
  {
    basic_block bb;
  
--- 680,842 ----
    return false;
  }
  
+ /* REF is a reference, in the statement pointed to by BSI, of the form
+ 
+      ARRAY_REF <ARRAY_REF <...>>
+ 
+    Try to forward propagate small perturbations into the index of
+    inner array references to avoid pessimizing the initial RTL.
+ 
+    Consider
+ 
+      R[0] = A[i1+1][i2][i3]   + A[i1][i2+1][i3] + A[i1][i2][i3+1]
+      R[1] = A[i1+1][i2][i3+1] + A[i1][i2][i3]   + A[i1-1][i2][i3-1]
+      R[2] = A[i1-1][i2][i3+1] + A[i1][i2][i3]   + A[i1+1][i2][i3-1]
+ 
+    Gimplification and Common Subexpression Elimination have created
+    temporaries for the perturbated variables i1+1, i1-1, i2+1, i3+1
+    and i3-1 as well as unified the duplicated ones.  Now, since TER
+    only operates on temporaries with a single use, the code handed
+    down to the RTL expander would be:
+ 
+      D1 = i1+1
+      D2 = i1-1
+      D3 = i3+1
+      D4 = i3-1
+      R[0] = A[D1][i2][i3] + A[i1][i2+1][i3] + A[i1][i2][D3]
+      R[1] = A[D1][i2][D3] + A[i1][i2][i3]   + A[D2][i2][D4]
+      R[2] = A[D2][i2][D3] + A[i1][i2][i3]   + A[D1][i2][D4]
+ 
+    While the small perturbations contained in D3 and D4 can easily be
+    retrofitted after the array references have been flattened to RTL,
+    those contained in D1 and D2 cannot because their effect is spread
+    over numerous computations.
+ 
+    We use the property that ARRAY_RANGE_REF of an array doesn't "cut"
+    the (outermost) dimension but only "renumbers" it, to rewrite the
+    original ARRAY_REF using the perturbation as the index in a new
+    dimension centered around the fixed part:
+ 
+      A[i1+1][i2][i3] -> A[i1 ...][1][i2][i3]
+ 
+    In doing so we generate formally out-of-bounds array references,
+    but the compiler is supposed to be able to cope with them since
+    they are a common idiom of the C language.  */
+ 
+ #define CONTAINS_INNER_ARRAY_REF_P(NODE)		\
+   (TREE_CODE ((NODE)) == ARRAY_REF			\
+    && TREE_CODE (TREE_OPERAND ((NODE), 0)) == ARRAY_REF)
+ 
+ #define FIRST_INNER_ARRAY_REF(NODE) TREE_OPERAND ((NODE), 0)
+ 
+ static void
+ forward_propagate_into_inner_array_ref (tree ref, block_stmt_iterator bsi)
+ {
+   tree t, next;
+   bool changed = false;
+ 
+   /* Loop over inner array references from the outermost to the innermost.
+      Note that we may be expanding the chain while we are walking it, so
+      we must be careful and for example prefetch the next step.  */
+   for (t = FIRST_INNER_ARRAY_REF (ref); TREE_CODE (t) == ARRAY_REF; t = next)
+     {
+       tree def_stmt, index, index_type, range_type, base, offset;
+       bool with_cast = false;
+ 
+       /* See above comment.  */
+       next = TREE_OPERAND (t, 0);
+ 
+       /* We're looking for an SSA_NAME index...  */
+       index = TREE_OPERAND (t, 1);
+       index_type = TREE_TYPE (index);
+       if (TREE_CODE (index) != SSA_NAME)
+ 	continue;
+ 
+       /* ... whose defining RHS...  */
+       def_stmt = SSA_NAME_DEF_STMT (index);
+       if (TREE_CODE (def_stmt) != MODIFY_EXPR)
+ 	continue;
+ 
+       /* ... modulo a cast...  */
+       index = TREE_OPERAND (def_stmt, 1);
+       if (TREE_CODE (index) == NOP_EXPR)
+ 	{
+ 	  index = TREE_OPERAND (index, 0);
+ 	  if (TREE_CODE (index) != SSA_NAME)
+ 	    continue;
+ 
+ 	  def_stmt = SSA_NAME_DEF_STMT (index);
+ 	  if (TREE_CODE (def_stmt) != MODIFY_EXPR)
+ 	    continue;
+ 
+ 	  index = TREE_OPERAND (def_stmt, 1);
+ 	  with_cast = true;
+ 	}
+ 
+       /* ... is an additive perturbation of small extent.  */
+       if ((TREE_CODE (index) == PLUS_EXPR || TREE_CODE (index) == MINUS_EXPR)
+ 	  && TREE_CODE (TREE_OPERAND (index, 1)) == INTEGER_CST)
+ 	{
+ 	  offset = TREE_OPERAND (index, 1);
+ 	  base = TREE_OPERAND (index, 0);
+ 	}
+ 
+       /* Otherwise fall back to the original index if there was a cast.
+ 	 This may seem useless but actually is not because we're going
+ 	 to make a new instance of the casted variable, which will make
+ 	 it possible for TER to fold the cast into the array reference.  */
+       else if (with_cast)
+ 	{
+ 	  offset = NULL_TREE;
+ 	  base = TREE_OPERAND (def_stmt, 0);
+ 	}
+ 
+       else
+ 	continue;
+ 
+       /* Preserve type consistency for the index.  TER will fold it.  */
+       if (TREE_TYPE (base) != index_type)
+ 	{
+ 	  tree tmp, conv_stmt;
+ 	  tmp = create_tmp_var (index_type, "fwptmp");
+ 	  add_referenced_tmp_var (tmp);
+ 	  base = fold_convert (index_type, base);
+ 	  conv_stmt = build (MODIFY_EXPR, index_type, tmp, base);
+ 	  base = make_ssa_name (tmp, conv_stmt);
+ 	  TREE_OPERAND (conv_stmt, 0) = base;
+ 	  bsi_insert_before (&bsi, conv_stmt, TSI_SAME_STMT);
+ 	}
+ 
+       if (offset)
+ 	{
+ 	  /* Insert the ARRAY_RANGE_REF and change the ARRAY_REF.  */
+ 	  range_type = build_array_type (TREE_TYPE (t),
+ 					 build_index_type (size_zero_node));
+ 	  TREE_OPERAND (t, 0) = build4 (ARRAY_RANGE_REF, range_type,
+ 					TREE_OPERAND (t, 0), base,
+ 					TREE_OPERAND (t, 2),
+ 					TREE_OPERAND (t, 3));
+ 	  index_type = signed_type_for (index_type);
+ 	  offset = fold_convert (index_type, offset);
+ 	  if (TREE_CODE (index) == MINUS_EXPR)
+ 	    offset = fold_build1 (NEGATE_EXPR, index_type, offset);
+ 	  TREE_OPERAND (t, 1) = offset;
+ 	  TREE_OPERAND (t, 2) = build_int_cst (index_type, 0);
+ 	}
+       else
+ 	TREE_OPERAND (t, 1) = base;
+ 
+       changed = true;
+     }
+ 
+   if (changed)
+     update_stmt (bsi_stmt (bsi));
+ }
+ 
  /* Main entry point for the forward propagation optimizer.  */
  
  static void
! tree_ssa_forward_propagate_vars (bool final)
  {
    basic_block bb;
  
*************** tree_ssa_forward_propagate_single_use_va
*** 698,721 ****
  	{
  	  tree stmt = bsi_stmt (bsi);
  
! 	  /* If this statement sets an SSA_NAME to an address,
! 	     try to propagate the address into the uses of the SSA_NAME.  */
! 	  if (TREE_CODE (stmt) == MODIFY_EXPR
! 	      && TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR
! 	      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME)
  	    {
! 	      if (forward_propagate_addr_expr (stmt))
! 		bsi_remove (&bsi);
! 	      else
! 		bsi_next (&bsi);
  	    }
  	  else if (TREE_CODE (stmt) == COND_EXPR)
! 	    {
! 	      forward_propagate_into_cond (stmt);
! 	      bsi_next (&bsi);
! 	    }
! 	  else
! 	    bsi_next (&bsi);
  	}
      }
  
--- 851,882 ----
  	{
  	  tree stmt = bsi_stmt (bsi);
  
! 	  if (TREE_CODE (stmt) == MODIFY_EXPR)
  	    {
! 	      tree lhs = TREE_OPERAND (stmt, 0);
! 	      tree rhs = TREE_OPERAND (stmt, 1);
! 
! 	      /* If this statement sets an SSA_NAME to an address, try
! 		 to propagate the address into the uses of the SSA_NAME.  */
! 	      if (TREE_CODE (lhs) == SSA_NAME && TREE_CODE (rhs) == ADDR_EXPR)
! 		{
! 		  if (forward_propagate_addr_expr (stmt))
! 		    {
! 		      bsi_remove (&bsi);
! 		      continue;
! 		    }
! 		}
! 	      /* During the final pass, try to make inner array
! 		 references more suitable for RTL expansion.  */
! 	      else if (final && CONTAINS_INNER_ARRAY_REF_P (lhs))
! 		forward_propagate_into_inner_array_ref (lhs, bsi);
! 	      else if (final && CONTAINS_INNER_ARRAY_REF_P (rhs))
! 		forward_propagate_into_inner_array_ref (rhs, bsi);
  	    }
  	  else if (TREE_CODE (stmt) == COND_EXPR)
! 	    forward_propagate_into_cond (stmt);
! 
! 	  bsi_next (&bsi);
  	}
      }
  
*************** tree_ssa_forward_propagate_single_use_va
*** 723,728 ****
--- 884,900 ----
      cleanup_tree_cfg ();
  }
  
+ static void
+ tree_ssa_forward_propagate_single_use_vars (void)
+ {
+   tree_ssa_forward_propagate_vars (false);
+ }
+ 
+ static void
+ tree_ssa_forward_propagate_final_vars (void)
+ {
+   tree_ssa_forward_propagate_vars (true);
+ }
  
  static bool
  gate_forwprop (void)
*************** struct tree_opt_pass pass_forwprop = {
*** 747,749 ****
--- 919,939 ----
    | TODO_update_ssa | TODO_verify_ssa,
    0					/* letter */
  };
+ 
+ struct tree_opt_pass pass_forwprop_final = {
+   "forwpropfinal",			/* name */
+   gate_forwprop,		/* gate */
+   tree_ssa_forward_propagate_final_vars,	/* execute */
+   NULL,				/* sub */
+   NULL,				/* next */
+   0,				/* static_pass_number */
+   TV_TREE_FORWPROP,		/* tv_id */
+   PROP_cfg | PROP_ssa
+     | PROP_alias,		/* properties_required */
+   0,				/* properties_provided */
+   0,				/* properties_destroyed */
+   0,				/* todo_flags_start */
+   TODO_dump_func | TODO_ggc_collect	/* todo_flags_finish */
+   | TODO_update_ssa | TODO_verify_ssa,
+   0					/* letter */
+ };
*** gcc/common.opt.0	2007-05-23 17:00:39.169038136 +0200
--- gcc/common.opt	2007-05-21 20:46:00.000000000 +0200
*************** fdata-sections
*** 341,346 ****
--- 341,350 ----
  Common Report Var(flag_data_sections)
  Place data items into their own section
  
+ fdead-non-call-exceptions
+ Common Report Var(flag_dead_non_call_exceptions)
+ Preserve synchronous non-call exceptions raised from dead code
+ 
  ; Nonzero for -fdefer-pop: don't pop args after each function call
  ; instead save them up to pop many calls' args with one insns.
  fdefer-pop
*** gcc/doc/invoke.texi.0	2007-05-23 17:00:39.175037224 +0200
--- gcc/doc/invoke.texi	2007-05-23 17:00:42.931466160 +0200
*************** See S/390 and zSeries Options.
*** 752,758 ****
  @xref{Code Gen Options,,Options for Code Generation Conventions}.
  @gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
  -ffixed-@var{reg}  -fexceptions @gol
! -fnon-call-exceptions  -funwind-tables @gol
  -fasynchronous-unwind-tables @gol
  -finhibit-size-directive  -finstrument-functions @gol
  -fno-common  -fno-ident @gol
--- 752,758 ----
  @xref{Code Gen Options,,Options for Code Generation Conventions}.
  @gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
  -ffixed-@var{reg}  -fexceptions @gol
! -fnon-call-exceptions  -fdead-non-call-exceptions  -funwind-tables @gol
  -fasynchronous-unwind-tables @gol
  -finhibit-size-directive  -finstrument-functions @gol
  -fno-common  -fno-ident @gol
*************** instructions to throw exceptions, i.e.@:
*** 12882,12887 ****
--- 12882,12894 ----
  point instructions.  It does not allow exceptions to be thrown from
  arbitrary signal handlers such as @code{SIGALRM}.
  
+ @item -fdead-non-call-exceptions
+ @opindex fdead-non-call-exceptions
+ Do not eliminate otherwise dead code containing trapping instructions
+ that can throw exceptions, in other words do not consider code containing
+ trapping instructions that may raise an exception but that would effectively
+ be dead if no exception was eventually raised as dead.
+ 
  @item -funwind-tables
  @opindex funwind-tables
  Similar to @option{-fexceptions}, except that it will just generate any needed
*** gcc/cse.c.0	2007-05-23 17:00:39.185035704 +0200
--- gcc/cse.c	2007-05-23 17:00:42.942464488 +0200
*************** static bool
*** 7372,7378 ****
  insn_live_p (rtx insn, int *counts)
  {
    int i;
!   if (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))
      return true;
    else if (GET_CODE (PATTERN (insn)) == SET)
      return set_live_p (PATTERN (insn), insn, counts);
--- 7372,7378 ----
  insn_live_p (rtx insn, int *counts)
  {
    int i;
!   if (flag_dead_non_call_exceptions && may_trap_p (PATTERN (insn)))
      return true;
    else if (GET_CODE (PATTERN (insn)) == SET)
      return set_live_p (PATTERN (insn), insn, counts);
*** gcc/flow.c.0	2007-05-23 17:00:39.190034944 +0200
--- gcc/flow.c	2007-05-23 17:20:43.534946688 +0200
*************** update_life_info (sbitmap blocks, enum u
*** 611,616 ****
--- 611,617 ----
  	      changed |= propagate_block (bb, tmp, NULL, NULL,
  				prop_flags & (PROP_SCAN_DEAD_CODE
  					      | PROP_SCAN_DEAD_STORES
+ 					      | PROP_ALLOW_CFG_CHANGES
  					      | PROP_KILL_DEAD_CODE));
  	    }
  
*************** update_life_info (sbitmap blocks, enum u
*** 618,626 ****
  	     subsequent propagate_block calls, since removing or acting as
  	     removing dead code can affect global register liveness, which
  	     is supposed to be finalized for this call after this loop.  */
! 	  stabilized_prop_flags
! 	    &= ~(PROP_SCAN_DEAD_CODE | PROP_SCAN_DEAD_STORES
! 		 | PROP_KILL_DEAD_CODE);
  
  	  if (! changed)
  	    break;
--- 619,628 ----
  	     subsequent propagate_block calls, since removing or acting as
  	     removing dead code can affect global register liveness, which
  	     is supposed to be finalized for this call after this loop.  */
! 	  stabilized_prop_flags &= ~(PROP_SCAN_DEAD_CODE
! 				     | PROP_SCAN_DEAD_STORES
! 				     | PROP_ALLOW_CFG_CHANGES
! 				     | PROP_KILL_DEAD_CODE);
  
  	  if (! changed)
  	    break;
*************** insn_dead_p (struct propagate_block_info
*** 2209,2216 ****
  {
    enum rtx_code code = GET_CODE (x);
  
!   /* Don't eliminate insns that may trap.  */
!   if (flag_non_call_exceptions && may_trap_p (x))
      return 0;
  
  #ifdef AUTO_INC_DEC
--- 2211,2220 ----
  {
    enum rtx_code code = GET_CODE (x);
  
!   /* If requested, don't eliminate insns that may trap.  */
!   if ((flag_dead_non_call_exceptions
!        || (flag_non_call_exceptions && !(pbi->flags & PROP_ALLOW_CFG_CHANGES)))
!       && may_trap_p (x))
      return 0;
  
  #ifdef AUTO_INC_DEC
*** gcc/tree-ssa-dce.c.0	2007-05-23 17:00:39.193034488 +0200
--- gcc/tree-ssa-dce.c	2007-05-23 17:00:42.949463424 +0200
*************** mark_stmt_if_obviously_necessary (tree s
*** 288,297 ****
    tree op, def;
    ssa_op_iter iter;
  
!   /* With non-call exceptions, we have to assume that all statements could
!      throw.  If a statement may throw, it is inherently necessary.  */
!   if (flag_non_call_exceptions
!       && tree_could_throw_p (stmt))
      {
        mark_stmt_necessary (stmt, true);
        return;
--- 288,295 ----
    tree op, def;
    ssa_op_iter iter;
  
!   /* If requested, don't eliminate statements that may throw.  */
!   if (flag_dead_non_call_exceptions && tree_could_throw_p (stmt))
      {
        mark_stmt_necessary (stmt, true);
        return;
*** gcc/config.gcc.orig	2007-05-24 20:57:08.221273000 -0400
--- gcc/config.gcc	2007-05-24 20:58:56.609927000 -0400
***************
*** 1210,1216 ****
  	tm_file="${tm_file} i386/sysv4.h i386/unix.h i386/att.h vx-common.h"
  	case ${target} in
  	  *-vxworksae*)
! 	    tm_file="${tm_file} vxworksae.h i386/vxworksae.h"
  	    tmake_file="${tmake_file} i386/t-vxworks i386/t-vxworksae"
  	    ;;
  	  *)
--- 1210,1216 ----
  	tm_file="${tm_file} i386/sysv4.h i386/unix.h i386/att.h vx-common.h"
  	case ${target} in
  	  *-vxworksae*)
! 	    tm_file="${tm_file} vxworksae.h i386/vxworks.h i386/vxworksae.h"
  	    tmake_file="${tmake_file} i386/t-vxworks i386/t-vxworksae"
  	    ;;
  	  *)
*** gcc/collect2.c.orig	2007-05-09 12:33:38.000000000 +0200
--- gcc/collect2.c	2007-05-09 12:38:02.000000000 +0200
*************** main (int argc, char **argv)
*** 804,809 ****
--- 804,810 ----
    const char **ld2;
    char **object_lst;
    const char **object;
+   int object_nbr = argc;
    int first_file;
    int num_c_args	= argc+9;
  
*************** main (int argc, char **argv)
*** 833,839 ****
  
    ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+4));
    ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+11));
!   object = (const char **)(object_lst = xcalloc(sizeof (char *), argc));
  
  #ifdef DEBUG
    debug = 1;
--- 834,840 ----
  
    ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+4));
    ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+11));
!   object = (const char **)(object_lst = XNEWVEC(char *, object_nbr));
  
  #ifdef DEBUG
    debug = 1;
*************** main (int argc, char **argv)
*** 1096,1101 ****
--- 1097,1154 ----
  		}
  	      break;
  
+ #ifdef OBJECT_FORMAT_COFF
+ 	    case 'f':
+ 	      /* File containing a list of input files to process.  */
+ 	      {
+ 		FILE *stream;
+ 		char buf[MAXPATHLEN + 2];
+ 		/* Number of additionnal object files.  */
+ 		int add_nbr = 0;
+ 		/* Maximum of additionnal object files before vector
+ 		   expansion.  */
+ 		int add_max = 0;
+ 		const char *list_filename = arg + 2;
+ 
+ 		/* Accept -fFILENAME and -f FILENAME.  */
+ 		if (*list_filename == '\0' && argv[1])
+ 		  {
+ 		    ++argv;
+ 		    list_filename = *argv;
+ 		    *ld1++ = *ld2++ = *argv;
+ 		  }
+ 
+ 		stream = fopen (list_filename, "r");
+ 		if (stream == NULL)
+ 		  fatal_perror ("can't open %s", list_filename);
+ 
+ 		while (fgets (buf, sizeof buf, stream) != NULL)
+ 		  {
+ 		    /* Remove end of line.  */
+ 		    int len = strlen (buf);
+ 		    if (len >= 1 && buf[len - 1] =='\n')
+ 		      buf[len - 1] = '\0';
+ 		
+ 		    /* Put on object vector.
+ 		       Note: we only expanse vector here, so we must keep
+ 		       extra space for remaining arguments.  */
+ 		    if (add_nbr >= add_max)
+ 		      {
+ 			int pos = (char **)object - object_lst;
+ 			add_max = (add_max == 0) ? 16 : add_max * 2;
+ 			object_lst = XRESIZEVEC(char *, object_lst,
+ 						object_nbr + add_max);
+ 			object = (const char **)object_lst + pos;
+ 			object_nbr += add_max;
+ 		      }
+ 		    *object++ = xstrdup(buf);
+ 		    add_nbr++;
+ 		  }
+ 		fclose (stream);
+ 	      }
+ 	      break;
+ #endif
+ 
  	    case 'l':
  	      if (first_file)
  		{
*** Makefile.def.0	2007-06-05 22:22:58.270350168 +0200
--- Makefile.def	2007-06-05 22:23:40.522926800 +0200
*************** flags_to_pass = { flag= SHELL ; };
*** 204,210 ****
--- 204,212 ----
  flags_to_pass = { flag= YACC ; };
  
  // Host tools
+ flags_to_pass = { flag= ADAFLAGS ; optional=true ; };
  flags_to_pass = { flag= AR_FLAGS ; };
+ flags_to_pass = { flag= BOOT_ADAFLAGS ; optional=true ; };
  flags_to_pass = { flag= BOOT_CFLAGS ; };
  flags_to_pass = { flag= BOOT_LDFLAGS ; };
  flags_to_pass = { flag= CFLAGS ; };
*** Makefile.tpl.0	2007-06-05 22:22:55.624752360 +0200
--- Makefile.tpl	2007-06-05 22:42:08.971417016 +0200
*************** HOST_LIB_PATH_[+module+] = \
*** 388,395 ****
  [+ ENDIF lib_path +][+ ENDFOR host_modules +]
  
  # Flags to pass down to all sub-makes.
! BASE_FLAGS_TO_PASS = [+ FOR flags_to_pass +]\
! 	"[+flag+]=$([+flag+])" [+ ENDFOR flags_to_pass +]\
  	"CONFIG_SHELL=$(SHELL)" \
  	"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)" 
  
--- 388,396 ----
  [+ ENDIF lib_path +][+ ENDFOR host_modules +]
  
  # Flags to pass down to all sub-makes.
! BASE_FLAGS_TO_PASS =[+ FOR flags_to_pass +][+ IF optional +] \
! 	"`echo '[+flag+]=$([+flag+])' | sed -e s'/[^=][^=]*=$$/XFOO=/'`"[+ ELSE optional +] \
! 	"[+flag+]=$([+flag+])"[+ ENDIF optional+][+ ENDFOR flags_to_pass +] \
  	"CONFIG_SHELL=$(SHELL)" \
  	"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)" 
  
*************** EXTRA_GCC_FLAGS = \
*** 464,472 ****
  	"`echo 'LIBGCC2_CFLAGS=$(LIBGCC2_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_DEBUG_CFLAGS=$(LIBGCC2_DEBUG_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_INCLUDES=$(LIBGCC2_INCLUDES)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'STAGE1_CFLAGS=$(STAGE1_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'BOOT_CFLAGS=$(BOOT_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'BOOT_ADAFLAGS=$(BOOT_ADAFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`"
  
  GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(EXTRA_GCC_FLAGS)
  
--- 465,471 ----
  	"`echo 'LIBGCC2_CFLAGS=$(LIBGCC2_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_DEBUG_CFLAGS=$(LIBGCC2_DEBUG_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_INCLUDES=$(LIBGCC2_INCLUDES)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'STAGE1_CFLAGS=$(STAGE1_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`"
  
  GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(EXTRA_GCC_FLAGS)
  
*** Makefile.in.0	2007-06-05 22:22:53.071140568 +0200
--- Makefile.in	2007-06-05 22:43:57.000000000 +0200
*************** BASE_FLAGS_TO_PASS = \
*** 432,438 ****
--- 432,440 ----
  	"RUNTESTFLAGS=$(RUNTESTFLAGS)" \
  	"SHELL=$(SHELL)" \
  	"YACC=$(YACC)" \
+ 	"`echo 'ADAFLAGS=$(ADAFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"AR_FLAGS=$(AR_FLAGS)" \
+ 	"`echo 'BOOT_ADAFLAGS=$(BOOT_ADAFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"BOOT_CFLAGS=$(BOOT_CFLAGS)" \
  	"BOOT_LDFLAGS=$(BOOT_LDFLAGS)" \
  	"CFLAGS=$(CFLAGS)" \
*************** EXTRA_GCC_FLAGS = \
*** 534,542 ****
  	"`echo 'LIBGCC2_CFLAGS=$(LIBGCC2_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_DEBUG_CFLAGS=$(LIBGCC2_DEBUG_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_INCLUDES=$(LIBGCC2_INCLUDES)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'STAGE1_CFLAGS=$(STAGE1_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'BOOT_CFLAGS=$(BOOT_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'BOOT_ADAFLAGS=$(BOOT_ADAFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`"
  
  GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(EXTRA_GCC_FLAGS)
  
--- 536,542 ----
  	"`echo 'LIBGCC2_CFLAGS=$(LIBGCC2_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_DEBUG_CFLAGS=$(LIBGCC2_DEBUG_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
  	"`echo 'LIBGCC2_INCLUDES=$(LIBGCC2_INCLUDES)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`" \
! 	"`echo 'STAGE1_CFLAGS=$(STAGE1_CFLAGS)' | sed -e s'/[^=][^=]*=$$/XFOO=/'`"
  
  GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(EXTRA_GCC_FLAGS)
  
*** gcc/doc/tm.texi.ori	Tue Jun  5 11:33:10 2007
--- gcc/doc/tm.texi	Tue Jun  5 11:34:13 2007
*************** Alignment required for a function entry 
*** 1041,1046 ****
--- 1041,1050 ----
  Biggest alignment that any data type can require on this machine, in bits.
  @end defmac
  
+ @defmac MALLOC_ALIGNMENT
+ Alignment that 'malloc' is known to honor on this machine, in bits.
+ @end defmac
+ 
  @defmac MINIMUM_ATOMIC_ALIGNMENT
  If defined, the smallest alignment, in bits, that can be given to an
  object that can be referenced in one operation, without disturbing any
*** gcc/defaults.h.ori	Thu May 31 16:33:07 2007
--- gcc/defaults.h	Thu May 31 18:00:07 2007
*************** Software Foundation, 51 Franklin Street,
*** 501,506 ****
--- 501,513 ----
  #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY
  #endif
  
+ /* Assume the alignment guaranteed to be honored by the operating system
+    memory allocator matches the maximum for any possible base datatype
+    requirement on the target.  */
+ #ifndef MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT BIGGEST_ALIGNMENT
+ #endif
+ 
  #ifndef TARGET_DEFAULT_PACK_STRUCT
  #define TARGET_DEFAULT_PACK_STRUCT 0
  #endif
*** gcc/config/i386/linux.h.ori	Thu May 31 16:33:07 2007
--- gcc/config/i386/linux.h	Thu May 31 18:30:16 2007
*************** Boston, MA 02110-1301, USA.  */
*** 196,198 ****
--- 196,202 ----
  /* i386 glibc provides __stack_chk_guard in %gs:0x14.  */
  #define TARGET_THREAD_SSP_OFFSET	0x14
  #endif
+ 
+ /* The maximum alignment 'malloc' is guaranteed to offer.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
*** gcc/config/i386/cygming.h.ori	Thu May 31 18:29:24 2007
--- gcc/config/i386/cygming.h	Thu May 31 16:46:11 2007
*************** extern int i386_pe_dllimport_name_p (con
*** 440,442 ****
--- 440,446 ----
  #ifndef BUFSIZ
  # undef FILE
  #endif
+ 
+ /* The maximum alignment 'malloc' is guaranteed to offer.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
*** gcc/config/i386/sol2-unwind.h.ori	Wed May 30 12:47:19 2007
--- gcc/config/i386/sol2-unwind.h	Fri Jun  1 18:19:37 2007
***************
*** 0 ****
--- 1,121 ----
+ /* DWARF2 EH unwinding support for x86.
+    Copyright (C) 2007 Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file with other programs, and to distribute
+ those programs without any restriction coming from the use of this
+ file.  (The General Public License restrictions do apply in other
+ respects; for example, they cover modification of the file, and
+ distribution when not linked into another program.)
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR sol2_fallback_frame_state
+ 
+ #include <signal.h>
+ #include <siginfo.h>
+ #include <sys/ucontext.h>
+ #include <sys/regset.h>
+ 
+ static _Unwind_Reason_Code
+ sol2_fallback_frame_state (struct _Unwind_Context *context,
+ 			   _Unwind_FrameState *fs)
+ {
+   static int eh_debug = -1;
+ 
+   unsigned char *pc = context->ra;
+   ucontext_t *uctx;
+   mcontext_t *mctx;
+   long new_cfa;
+ 
+   if (eh_debug == -1)
+     eh_debug = getenv ("EH_DEBUG") != 0;
+ 
+   if (eh_debug)
+     printf ("FALLBACK # ra = 0x%p, cfa = 0x%p...\n",
+ 	    context->ra, context->cfa);
+ 
+   /* <sighandler+0>:      push   %ebp
+      <sighandler+1>:      mov    %esp,%ebp
+      <sighandler+3>:      pushl  0x10(%ebp)    # push ucontext ptr
+      <sighandler+6>:      pushl  0xc(%ebp)     # push siginfo ptr
+      <sighandler+9>:      pushl  0x8(%ebp)     # push signo
+      <sighandler+12>:     call   *0x14(%ebp)
+      <sighandler+15>:     add    $0xc,%esp     <--- context->ra
+      <sighandler+18>:     leave
+      <sighandler+19>:     ret
+ 
+      20 bytes = 5 longs from ra - 15 ...
+   */
+ 
+   if (*(unsigned long *)(pc - 15) == 0xffec8b55
+       && *(unsigned long *)(pc - 11) == 0x75ff1075
+       && *(unsigned long *)(pc - 7)  == 0x0875ff0c
+       && *(unsigned long *)(pc - 3)  == 0x831455ff
+       && *(unsigned long *)(pc + 1)  == 0xc3c90cc4)
+     {
+       typedef struct {
+ 	int signo;
+ 	siginfo_t  * siginfo;
+ 	ucontext_t * ucontext;
+       } handler_args_t;
+ 
+       handler_args_t * handler_args = context->cfa;
+ 
+       uctx = handler_args->ucontext;
+       mctx = &uctx->uc_mcontext;
+     }
+   else
+     return _URC_END_OF_STACK;
+ 
+   if (eh_debug)
+     printf ("FALLBACK - uctx = 0x%p, mctx = 0x%p\n", uctx, mctx);
+ 
+   new_cfa = mctx->gregs[UESP];
+ 
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = 4;
+   fs->cfa_offset = new_cfa - (long) context->cfa;
+ 
+   /* The SVR4 register numbering macros aren't usable in libgcc.  */
+   fs->regs.reg[0].how = REG_SAVED_OFFSET;
+   fs->regs.reg[0].loc.offset = (long)&mctx->gregs[EAX] - new_cfa;
+   fs->regs.reg[3].how = REG_SAVED_OFFSET;
+   fs->regs.reg[3].loc.offset = (long)&mctx->gregs[EBX] - new_cfa;
+   fs->regs.reg[1].how = REG_SAVED_OFFSET;
+   fs->regs.reg[1].loc.offset = (long)&mctx->gregs[ECX] - new_cfa;
+   fs->regs.reg[2].how = REG_SAVED_OFFSET;
+   fs->regs.reg[2].loc.offset = (long)&mctx->gregs[EDX] - new_cfa;
+   fs->regs.reg[6].how = REG_SAVED_OFFSET;
+   fs->regs.reg[6].loc.offset = (long)&mctx->gregs[ESI] - new_cfa;
+   fs->regs.reg[7].how = REG_SAVED_OFFSET;
+   fs->regs.reg[7].loc.offset = (long)&mctx->gregs[EDI] - new_cfa;
+   fs->regs.reg[5].how = REG_SAVED_OFFSET;
+   fs->regs.reg[5].loc.offset = (long)&mctx->gregs[EBP] - new_cfa;
+   fs->regs.reg[8].how = REG_SAVED_OFFSET;
+   fs->regs.reg[8].loc.offset = (long)&mctx->gregs[EIP] - new_cfa;
+   fs->retaddr_column = 8;
+ 
+   if (eh_debug)
+     printf ("FALLBACK - ncfa = 0x%p, nip = 0x%p\n",
+ 	    (void *)new_cfa, (void *)mctx->gregs[EIP]);
+ 
+   return _URC_NO_REASON;
+ }
+ 
*** gcc/config/i386/sol2.h.ori	Wed May 30 12:47:35 2007
--- gcc/config/i386/sol2.h	Wed May 30 12:49:01 2007
*************** Boston, MA 02110-1301, USA.  */
*** 116,118 ****
--- 116,119 ----
  #undef  MCOUNT_PRESERVES_ALL_REGS
  #define MCOUNT_PRESERVES_ALL_REGS 0
  
+ #define MD_UNWIND_SUPPORT "config/i386/sol2-unwind.h"
*** gcc/config/rs6000/rs6000.c.0	2007-06-06 08:57:41.626859392 +0200
--- gcc/config/rs6000/rs6000.c	2007-06-06 09:00:21.106614784 +0200
*************** rs6000_output_function_entry (FILE *file
*** 10223,10232 ****
  	  break;
  	}
      }
!   if (TARGET_AIX)
!     RS6000_OUTPUT_BASENAME (file, fname);
!   else
!     assemble_name (file, fname);
  }
  
  /* Print an operand.  Recognize special options, documented below.  */
--- 10223,10230 ----
  	  break;
  	}
      }
! 
!   RS6000_OUTPUT_BASENAME (file, fname);
  }
  
  /* Print an operand.  Recognize special options, documented below.  */
*************** rs6000_output_function_epilogue (FILE *f
*** 15648,15657 ****
        /* Offset from start of code to tb table.  */
        fputs ("\t.long ", file);
        ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, "LT");
!       if (TARGET_AIX)
! 	RS6000_OUTPUT_BASENAME (file, fname);
!       else
! 	assemble_name (file, fname);
        putc ('-', file);
        rs6000_output_function_entry (file, fname);
        putc ('\n', file);
--- 15646,15652 ----
        /* Offset from start of code to tb table.  */
        fputs ("\t.long ", file);
        ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, "LT");
!       RS6000_OUTPUT_BASENAME (file, fname);
        putc ('-', file);
        rs6000_output_function_entry (file, fname);
        putc ('\n', file);
*** gcc/genmodes.c.ori	Tue Jun  5 21:47:04 2007
--- gcc/genmodes.c	Tue Jun  5 21:55:21 2007
*************** calc_wider_mode (void)
*** 751,757 ****
  
  #define tagged_printf(FMT, ARG, TAG) do {		\
    int count_;						\
!   printf ("  " FMT ",%n", ARG, &count_);		\
    printf ("%*s/* %s */\n", 27 - count_, "", TAG);	\
  } while (0)
  
--- 751,757 ----
  
  #define tagged_printf(FMT, ARG, TAG) do {		\
    int count_;						\
!   count_ = printf ("  " FMT ",", ARG);		\
    printf ("%*s/* %s */\n", 27 - count_, "", TAG);	\
  } while (0)
  
*************** enum machine_mode\n{");
*** 786,792 ****
      for (m = modes[c]; m; m = m->next)
        {
  	int count_;
! 	printf ("  %smode,%n", m->name, &count_);
  	printf ("%*s/* %s:%d */\n", 27 - count_, "",
  		 trim_filename (m->file), m->line);
        }
--- 786,792 ----
      for (m = modes[c]; m; m = m->next)
        {
  	int count_;
! 	count_ = printf ("  %smode,", m->name);
  	printf ("%*s/* %s:%d */\n", 27 - count_, "",
  		 trim_filename (m->file), m->line);
        }
*** gcc/config/i386/sol2-unwind.h.ori	Thu Jun  7 17:00:16 2007
--- gcc/config/i386/sol2-unwind.h	Fri Jun  8 05:27:01 2007
***************
*** 39,48 ****
  {
    static int eh_debug = -1;
  
!   unsigned char *pc = context->ra;
    ucontext_t *uctx;
    mcontext_t *mctx;
    long new_cfa;
  
    if (eh_debug == -1)
      eh_debug = getenv ("EH_DEBUG") != 0;
--- 39,50 ----
  {
    static int eh_debug = -1;
  
!   unsigned char *ra = context->ra;
    ucontext_t *uctx;
    mcontext_t *mctx;
    long new_cfa;
+   
+   int context_is_sighandler;
  
    if (eh_debug == -1)
      eh_debug = getenv ("EH_DEBUG") != 0;
***************
*** 51,74 ****
      printf ("FALLBACK # ra = 0x%p, cfa = 0x%p...\n",
  	    context->ra, context->cfa);
  
!   /* <sighandler+0>:      push   %ebp
!      <sighandler+1>:      mov    %esp,%ebp
!      <sighandler+3>:      pushl  0x10(%ebp)    # push ucontext ptr
!      <sighandler+6>:      pushl  0xc(%ebp)     # push siginfo ptr
!      <sighandler+9>:      pushl  0x8(%ebp)     # push signo
!      <sighandler+12>:     call   *0x14(%ebp)
!      <sighandler+15>:     add    $0xc,%esp     <--- context->ra
!      <sighandler+18>:     leave
!      <sighandler+19>:     ret
! 
!      20 bytes = 5 longs from ra - 15 ...
!   */
! 
!   if (*(unsigned long *)(pc - 15) == 0xffec8b55
!       && *(unsigned long *)(pc - 11) == 0x75ff1075
!       && *(unsigned long *)(pc - 7)  == 0x0875ff0c
!       && *(unsigned long *)(pc - 3)  == 0x831455ff
!       && *(unsigned long *)(pc + 1)  == 0xc3c90cc4)
      {
        typedef struct {
  	int signo;
--- 53,109 ----
      printf ("FALLBACK # ra = 0x%p, cfa = 0x%p...\n",
  	    context->ra, context->cfa);
  
!   context_is_sighandler =
!     /* Solaris 2.8 - mono thread
!        -------------------------
!        <sigacthandler+17>:  mov    0x10(%ebp),%esi
!        <sigacthandler+20>:  push   %esi
!        <sigacthandler+21>:  pushl  0xc(%ebp)
!        <sigacthandler+24>:  mov    0x8(%ebp),%ecx
!        <sigacthandler+27>:  push   %ecx
!        <sigacthandler+28>:  mov    0x244(%ebx),%eax
!        <sigacthandler+34>:  call   *(%eax,%ecx,4)
!        <sigacthandler+37>:  add    $0xc,%esp        <--- context->ra
!        <sigacthandler+40>:  push   %esi ... */
!     (*(unsigned long *)(ra - 20) == 0x5610758b
!      && *(unsigned long *)(ra - 16) == 0x8b0c75ff
!      && *(unsigned long *)(ra - 12) == 0x8b51084d
!      && *(unsigned long *)(ra - 8)  == 0x00024483
!      && *(unsigned long *)(ra - 4)  == 0x8814ff00
!      && *(unsigned long *)(ra - 0)  == 0x560cc483)
! 
!     ||  /* Solaris 2.8 - multi threads
! 	   ---------------------------
! 	   <__sighndlr+0>:      push   %ebp
! 	   <__sighndlr+1>:      mov    %esp,%ebp
! 	   <__sighndlr+3>:      pushl  0x10(%ebp)
! 	   <__sighndlr+6>:      pushl  0xc(%ebp)
! 	   <__sighndlr+9>:      pushl  0x8(%ebp)
! 	   <__sighndlr+12>:     call   *0x14(%ebp)
! 	   <__sighndlr+15>:     leave               <--- context->ra  */
!     (*(unsigned long *)(ra - 15) == 0xffec8b55
!      && *(unsigned long *)(ra - 11) == 0x75ff1075
!      && *(unsigned long *)(ra - 7)  == 0x0875ff0c
!      && *(unsigned long *)(ra - 3)  == 0xc91455ff)
! 
!     ||  /* Solaris 2.10
! 	   ------------
! 	   <__sighndlr+0>:      push   %ebp
! 	   <__sighndlr+1>:      mov    %esp,%ebp
! 	   <__sighndlr+3>:      pushl  0x10(%ebp)
! 	   <__sighndlr+6>:      pushl  0xc(%ebp)
! 	   <__sighndlr+9>:      pushl  0x8(%ebp)
! 	   <__sighndlr+12>:     call   *0x14(%ebp)
! 	   <__sighndlr+15>:     add    $0xc,%esp     <--- context->ra
! 	   <__sighndlr+18>:     leave
! 	   <__sighndlr+19>:     ret  */
!     (*(unsigned long *)(ra - 15) == 0xffec8b55
!      && *(unsigned long *)(ra - 11) == 0x75ff1075
!      && *(unsigned long *)(ra - 7)  == 0x0875ff0c
!      && *(unsigned long *)(ra - 3)  == 0x831455ff
!      && *(unsigned long *)(ra + 1)  == 0xc3c90cc4);
! 
!   if (context_is_sighandler)
      {
        typedef struct {
  	int signo;
*** gcc/config/i386/sol2.h.ori	Fri Jun  8 15:41:09 2007
--- gcc/config/i386/sol2.h	Fri Jun  8 15:41:12 2007
*************** Boston, MA 02110-1301, USA.  */
*** 117,119 ****
--- 117,123 ----
  #define MCOUNT_PRESERVES_ALL_REGS 0
  
  #define MD_UNWIND_SUPPORT "config/i386/sol2-unwind.h"
+ 
+ /* The maximum alignment 'malloc' is guaranteed to offer.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
*** gcc/config/i386/vxworks.h.ori	Fri Jun  8 15:30:52 2007
--- gcc/config/i386/vxworks.h	Fri Jun  8 15:33:48 2007
*************** VXWORKS_STACK_CHECK_SPEC
*** 96,98 ****
--- 96,102 ----
  
  /* Static stack checking is supported only in RTP mode */
  #define VXWORKS_STACK_CHECK_SPEC "%{fstack-check:%{!mrtp:-fold-stack-check}}"
+ 
+ /* The maximum alignment 'malloc' is guaranteed to offer.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
*** gcc/config/mips/iris.h.ori	Fri Jun  8 15:21:25 2007
--- gcc/config/mips/iris.h	Fri Jun  8 15:33:33 2007
*************** Boston, MA 02110-1301, USA.  */
*** 220,222 ****
--- 220,226 ----
  #undef HAVE_GAS_SHF_MERGE
  #define HAVE_GAS_SHF_MERGE 0
  #endif
+ 
+ /* The maximum alignment 'malloc' is guaranteed to offer.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
*** gcc/config/rs6000/aix52.h.ori	Sun Jun 10 22:49:34 2007
--- gcc/config/rs6000/aix52.h	Sun Jun 10 22:55:26 2007
*************** extern long long int    atoll(const char
*** 191,193 ****
--- 191,197 ----
  
  /* This target uses the aix64.opt file.  */
  #define TARGET_USES_AIX64_OPT 1
+ 
+ /* The maximum alignment 'malloc' is guaranteed to offer.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT ((TARGET_64BIT ? 16 : 8) * BITS_PER_UNIT)
*** gcc/gcov.c.orig	2007-06-13 11:00:25.000000000 +0200
--- gcc/gcov.c	2007-06-13 13:55:54.000000000 +0200
*************** Boston, MA 02110-1301, USA.  */
*** 29,43 ****
  /* ??? Should have an option to print the number of basic blocks, and the
     percent of them that are covered.  */
  
- /* ??? Does not correctly handle the case where two .bb files refer to
-    the same included source file.  For example, if one has a short
-    file containing only inline functions, which is then included in
-    two other files, then there will be two .bb files which refer to
-    the include file, but there is no way to get the total execution
-    counts for the included file, can only get execution counts for one
-    or the other of the including files. this can be fixed by --ratios
-    --long-file-names --preserve-paths and perl.  */
- 
  /* Need an option to show individual block counts, and show
     probabilities of fall through arcs.  */
  
--- 29,34 ----
*************** Boston, MA 02110-1301, USA.  */
*** 54,60 ****
  #include "gcov-io.h"
  #include "gcov-io.c"
  
! /* The bbg file is generated by -ftest-coverage option. The da file is
     generated by a program compiled with -fprofile-arcs. Their formats
     are documented in gcov-io.h.  */
  
--- 45,51 ----
  #include "gcov-io.h"
  #include "gcov-io.c"
  
! /* The gcno file is generated by -ftest-coverage option. The gcda file is
     generated by a program compiled with -fprofile-arcs. Their formats
     are documented in gcov-io.h.  */
  
*************** typedef struct source_info
*** 234,239 ****
--- 225,231 ----
    /* Name of source file.  */
    char *name;
    unsigned index;
+   time_t file_time;
  
    /* Array of line information.  */
    line_t *lines;
*************** typedef struct source_info
*** 253,262 ****
  
  static function_t *functions;
  
! /* This points to the head of the sourcefile structure list.  */
  
  static source_t *sources;
  
  /* This holds data summary information.  */
  
  static struct gcov_summary object_summary;
--- 245,259 ----
  
  static function_t *functions;
  
! /* This points to the head of the sourcefile structure list.  New elements
!    are always prepended.  */
  
  static source_t *sources;
  
+ /* Next index for a source file.  */
+ 
+ static unsigned source_index;
+ 
  /* This holds data summary information.  */
  
  static struct gcov_summary object_summary;
*************** static unsigned bbg_stamp;
*** 277,282 ****
--- 274,286 ----
  
  static char *da_file_name;
  
+ /* If there is several input files, compute and display results after
+    reading all data files.  This way if two or more gcda file refer to
+    the same source file (eg inline subprograms in a .h file), the
+    counts are added.  */
+ 
+ static int multiple_files = 0;
+ 
  /* Output branch probabilities.  */
  
  static int flag_branches = 0;
*************** static int process_args (int, char **);
*** 326,331 ****
--- 330,336 ----
  static void print_usage (int) ATTRIBUTE_NORETURN;
  static void print_version (void) ATTRIBUTE_NORETURN;
  static void process_file (const char *);
+ static void generate_results (const char *);
  static void create_file_names (const char *);
  static source_t *find_source (const char *);
  static int read_graph_file (void);
*************** main (int argc, char **argv)
*** 358,369 ****
    if (optind == argc)
      print_usage (true);
  
    for (; argno != argc; argno++)
!     {
!       release_structures ();
  
!       process_file (argv[argno]);
!     }
  
    return 0;
  }
--- 363,377 ----
    if (optind == argc)
      print_usage (true);
  
+   if (argc - argno > 1)
+     multiple_files = 1;
+ 
    for (; argno != argc; argno++)
!     process_file (argv[argno]);
  
!   generate_results (multiple_files ? NULL : argv[argc - 1]);
! 
!   release_structures ();
  
    return 0;
  }
*************** print_usage (int error_p)
*** 416,422 ****
    FILE *file = error_p ? stderr : stdout;
    int status = error_p ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;
  
!   fnotice (file, "Usage: gcov [OPTION]... SOURCEFILE\n\n");
    fnotice (file, "Print code coverage information.\n\n");
    fnotice (file, "  -h, --help                      Print this help, then exit\n");
    fnotice (file, "  -v, --version                   Print version number, then exit\n");
--- 424,430 ----
    FILE *file = error_p ? stderr : stdout;
    int status = error_p ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;
  
!   fnotice (file, "Usage: gcov [OPTION]... SOURCEFILE...\n\n");
    fnotice (file, "Print code coverage information.\n\n");
    fnotice (file, "  -h, --help                      Print this help, then exit\n");
    fnotice (file, "  -v, --version                   Print version number, then exit\n");
*************** process_args (int argc, char **argv)
*** 526,533 ****
  static void
  process_file (const char *file_name)
  {
-   source_t *src;
    function_t *fn;
  
    create_file_names (file_name);
    if (read_graph_file ())
--- 534,547 ----
  static void
  process_file (const char *file_name)
  {
    function_t *fn;
+   function_t *fn_p;
+   function_t *old_functions;
+ 
+   /* Save and clear the list of current functions.  They will be appended
+      later.  */
+   old_functions = functions;
+   functions = NULL;
  
    create_file_names (file_name);
    if (read_graph_file ())
*************** process_file (const char *file_name)
*** 542,549 ****
    if (read_count_file ())
      return;
  
!   for (fn = functions; fn; fn = fn->next)
      solve_flow_graph (fn);
    for (src = sources; src; src = src->next)
      src->lines = xcalloc (src->num_lines, sizeof (line_t));
    for (fn = functions; fn; fn = fn->next)
--- 556,574 ----
    if (read_count_file ())
      return;
  
!   for (fn_p = NULL, fn = functions; fn; fn_p = fn, fn = fn->next)
      solve_flow_graph (fn);
+ 
+   if (fn_p)
+     fn_p->next = old_functions;
+ }
+ 
+ static void
+ generate_results (const char *file_name)
+ {
+   source_t *src;
+   function_t *fn;
+ 
    for (src = sources; src; src = src->next)
      src->lines = xcalloc (src->num_lines, sizeof (line_t));
    for (fn = functions; fn; fn = fn->next)
*************** release_structures (void)
*** 596,607 ****
    function_t *fn;
    source_t *src;
  
-   free (bbg_file_name);
-   free (da_file_name);
-   da_file_name = bbg_file_name = NULL;
-   bbg_file_time = 0;
-   bbg_stamp = 0;
- 
    while ((src = sources))
      {
        sources = src->next;
--- 621,626 ----
*************** create_file_names (const char *file_name
*** 647,652 ****
--- 666,680 ----
    int length = strlen (file_name);
    int base;
  
+   /* Free previous file names.  */
+   if (bbg_file_name)
+     free (bbg_file_name);
+   if (da_file_name)
+     free (da_file_name);
+   da_file_name = bbg_file_name = NULL;
+   bbg_file_time = 0;
+   bbg_stamp = 0;
+ 
    if (object_directory && object_directory[0])
      {
        struct stat status;
*************** static source_t *
*** 699,719 ****
  find_source (const char *file_name)
  {
    source_t *src;
  
    if (!file_name)
      file_name = "<unknown>";
  
    for (src = sources; src; src = src->next)
      if (!strcmp (file_name, src->name))
!       return src;
! 
!   src = xcalloc (1, sizeof (source_t));
!   src->name = xstrdup (file_name);
!   src->coverage.name = src->name;
!   src->index = sources ? sources->index + 1 : 1;
!   src->next = sources;
!   sources = src;
! 
    return src;
  }
  
--- 727,769 ----
  find_source (const char *file_name)
  {
    source_t *src;
+   struct stat status;
  
    if (!file_name)
      file_name = "<unknown>";
  
    for (src = sources; src; src = src->next)
      if (!strcmp (file_name, src->name))
!        break;
!   
!   if (!src)
!     {
!       src = xcalloc (1, sizeof (source_t));
!       src->name = xstrdup (file_name);
!       src->coverage.name = src->name;
!       src->index = source_index++;
!       src->next = sources;
!       sources = src;
!       
!       if (!stat (file_name, &status))
!  	src->file_time = status.st_mtime;
!     }
!  
!   if (src->file_time > bbg_file_time)
!     {
!       static int info_emitted;
!       
!       fnotice (stderr, "%s:source file is newer than graph file '%s'\n",
!  	       src->name, bbg_file_name);
!       if (!info_emitted)
!  	{
!  	  fnotice (stderr,
!  		   "(the message is only displayed one per source file)\n");
!  	  info_emitted = 1;
!  	}
!       src->file_time = 0;
!     }
!   
    return src;
  }
  
*************** read_graph_file (void)
*** 725,730 ****
--- 775,781 ----
    unsigned version;
    unsigned current_tag = 0;
    struct function_info *fn = NULL;
+   function_t *old_functions_head = functions;
    source_t *src = NULL;
    unsigned ix;
    unsigned tag;
*************** read_graph_file (void)
*** 946,952 ****
    {
      function_t *fn, *fn_p, *fn_n;
  
!     for (fn_p = NULL, fn = functions; fn; fn_p = fn, fn = fn_n)
        {
  	unsigned ix;
  
--- 997,1005 ----
    {
      function_t *fn, *fn_p, *fn_n;
  
!     for (fn_p = old_functions_head, fn = functions;
! 	 fn != old_functions_head;
! 	 fn_p = fn, fn = fn_n)
        {
  	unsigned ix;
  
*************** read_count_file (void)
*** 1036,1041 ****
--- 1089,1097 ----
  	  unsigned ident = gcov_read_unsigned ();
  	  struct function_info *fn_n = functions;
  
+ 	  /* Try to find the function in the list.
+ 	     To speed up the search, first start from the last function
+ 	     found.   */
  	  for (fn = fn ? fn->next : NULL; ; fn = fn->next)
  	    {
  	      if (fn)
*************** static char *
*** 1448,1463 ****
  make_gcov_file_name (const char *input_name, const char *src_name)
  {
    char *cptr;
!   char *name = xmalloc (strlen (src_name) + strlen (input_name) + 10);
! 
!   name[0] = 0;
!   if (flag_long_names && strcmp (src_name, input_name))
      {
        /* Generate the input filename part.  */
        cptr = flag_preserve_paths ? NULL : l_strrchr (input_name);
        strcat (name, cptr ? cptr + 1 : input_name);
        strcat (name, "##");
      }
  
    /* Generate the source filename part.  */
    cptr = flag_preserve_paths ? NULL : l_strrchr (src_name);
--- 1504,1525 ----
  make_gcov_file_name (const char *input_name, const char *src_name)
  {
    char *cptr;
!   char *name;
!   
!   if (flag_long_names && input_name && strcmp (src_name, input_name))
      {
+       name = xmalloc (strlen (src_name) + strlen (input_name) + 10);
+       name[0] = 0;
        /* Generate the input filename part.  */
        cptr = flag_preserve_paths ? NULL : l_strrchr (input_name);
        strcat (name, cptr ? cptr + 1 : input_name);
        strcat (name, "##");
      }
+   else
+     {
+       name = xmalloc (strlen (src_name) + 10);
+       name[0] = 0;
+     }
  
    /* Generate the source filename part.  */
    cptr = flag_preserve_paths ? NULL : l_strrchr (src_name);
*************** output_lines (FILE *gcov_file, const sou
*** 1811,1820 ****
    function_t *fn = NULL;
  
    fprintf (gcov_file, "%9s:%5d:Source:%s\n", "-", 0, src->name);
!   fprintf (gcov_file, "%9s:%5d:Graph:%s\n", "-", 0, bbg_file_name);
!   fprintf (gcov_file, "%9s:%5d:Data:%s\n", "-", 0, da_file_name);
!   fprintf (gcov_file, "%9s:%5d:Runs:%u\n", "-", 0,
! 	   object_summary.ctrs[GCOV_COUNTER_ARCS].runs);
    fprintf (gcov_file, "%9s:%5d:Programs:%u\n", "-", 0, program_count);
  
    source_file = fopen (src->name, "r");
--- 1873,1885 ----
    function_t *fn = NULL;
  
    fprintf (gcov_file, "%9s:%5d:Source:%s\n", "-", 0, src->name);
!   if (!multiple_files)
!     {
!       fprintf (gcov_file, "%9s:%5d:Graph:%s\n", "-", 0, bbg_file_name);
!       fprintf (gcov_file, "%9s:%5d:Data:%s\n", "-", 0, da_file_name);
!       fprintf (gcov_file, "%9s:%5d:Runs:%u\n", "-", 0,
! 	       object_summary.ctrs[GCOV_COUNTER_ARCS].runs);
!     }
    fprintf (gcov_file, "%9s:%5d:Programs:%u\n", "-", 0, program_count);
  
    source_file = fopen (src->name, "r");
*************** output_lines (FILE *gcov_file, const sou
*** 1823,1841 ****
        fnotice (stderr, "%s:cannot open source file\n", src->name);
        retval = NULL;
      }
!   else
!     {
!       struct stat status;
! 
!       if (!fstat (fileno (source_file), &status)
! 	  && status.st_mtime > bbg_file_time)
! 	{
! 	  fnotice (stderr, "%s:source file is newer than graph file '%s'\n",
! 		   src->name, bbg_file_name);
! 	  fprintf (gcov_file, "%9s:%5d:Source is newer than graph\n",
! 		   "-", 0);
! 	}
!     }
  
    if (flag_branches)
      fn = src->functions;
--- 1888,1895 ----
        fnotice (stderr, "%s:cannot open source file\n", src->name);
        retval = NULL;
      }
!   else if (src->file_time == 0)
!     fprintf (gcov_file, "%9s:%5d:Source is newer than graph\n", "-", 0);
  
    if (flag_branches)
      fn = src->functions;
*** gcc/doc/gcov.texi.orig	2007-06-13 11:04:40.000000000 +0200
--- gcc/doc/gcov.texi	2007-06-13 10:50:26.000000000 +0200
*************** compatible with any other profiling or t
*** 113,119 ****
  @section Invoking gcov
  
  @smallexample
! gcov @r{[}@var{options}@r{]} @var{sourcefile}
  @end smallexample
  
  @command{gcov} accepts the following options:
--- 113,119 ----
  @section Invoking gcov
  
  @smallexample
! gcov @r{[}@var{options}@r{]} @var{sourcefiles}
  @end smallexample
  
  @command{gcov} accepts the following options:
*************** gcov [@option{-v}|@option{--version}] [@
*** 128,134 ****
       [@option{-l}|@option{--long-file-names}]
       [@option{-p}|@option{--preserve-paths}]
       [@option{-f}|@option{--function-summaries}]
!      [@option{-o}|@option{--object-directory} @var{directory|file}] @var{sourcefile}
       [@option{-u}|@option{--unconditional-branches}]
  @c man end
  @c man begin SEEALSO
--- 128,134 ----
       [@option{-l}|@option{--long-file-names}]
       [@option{-p}|@option{--preserve-paths}]
       [@option{-f}|@option{--function-summaries}]
!      [@option{-o}|@option{--object-directory} @var{directory|file}] @var{sourcefiles}
       [@option{-u}|@option{--unconditional-branches}]
  @c man end
  @c man begin SEEALSO
*** gcc/tree-sra.c.0	2007-06-13 22:00:16.021579560 +0200
--- gcc/tree-sra.c	2007-06-13 22:52:17.718009568 +0200
*************** maybe_lookup_element_for_expr (tree expr
*** 614,623 ****
        break;
  
      case COMPONENT_REF:
!       /* Don't look through unions.  */
!       if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) != RECORD_TYPE)
! 	return NULL;
!       child = TREE_OPERAND (expr, 1);
        break;
  
      case REALPART_EXPR:
--- 614,630 ----
        break;
  
      case COMPONENT_REF:
!       {
! 	tree type = TREE_TYPE (TREE_OPERAND (expr, 0));
! 	/* Don't look through unions.  */
! 	if (TREE_CODE (type) != RECORD_TYPE)
! 	  return NULL;
! 	/* Neither through variable-sized records.  */
! 	if (TYPE_SIZE (type) == NULL_TREE
! 	    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)
! 	  return NULL;
! 	child = TREE_OPERAND (expr, 1);
!       }
        break;
  
      case REALPART_EXPR:
*************** sra_walk_expr (tree *expr_p, block_stmt_
*** 767,780 ****
  	break;
  
        case COMPONENT_REF:
! 	/* A reference to a union member constitutes a reference to the
! 	   entire union.  */
! 	if (TREE_CODE (TREE_TYPE (TREE_OPERAND (inner, 0))) != RECORD_TYPE)
! 	  goto use_all;
! 	/* ??? See above re non-constant stride.  */
! 	if (TREE_OPERAND (inner, 2))
! 	  goto use_all;
! 	inner = TREE_OPERAND (inner, 0);
  	break;
  
        case REALPART_EXPR:
--- 774,790 ----
  	break;
  
        case COMPONENT_REF:
! 	{
! 	  tree type = TREE_TYPE (TREE_OPERAND (inner, 0));
! 	  /* Don't look through unions.  */
! 	  if (TREE_CODE (type) != RECORD_TYPE)
! 	    goto use_all;
! 	  /* Neither through variable-sized records.  */
! 	  if (TYPE_SIZE (type) == NULL_TREE
! 	      || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)
! 	    goto use_all;
! 	  inner = TREE_OPERAND (inner, 0);
! 	}
  	break;
  
        case REALPART_EXPR:
*** gcc/c-opts.c	Tue Jun 19 11:16:17 2007
--- gcc/c-opts.c	Tue Jun 19 16:28:48 2007
*************** c_common_handle_option (size_t scode, co
*** 816,821 ****
--- 816,833 ----
        flag_gen_declaration = 1;
        break;
  
+     case OPT_femit_struct_debug_baseonly:
+       set_struct_debug_option ("base");
+       break;
+ 
+     case OPT_femit_struct_debug_reduced:
+       set_struct_debug_option ("dir:ord:sys,dir:gen:any,ind:base");
+       break;
+ 
+     case OPT_femit_struct_debug_detailed_:
+       set_struct_debug_option (arg);
+         break;
+         
      case OPT_idirafter:
        add_path (xstrdup (arg), AFTER, 0, true);
        break;
*** gcc/c.opt.0	Tue Jun 19 11:16:17 2007
--- gcc/c.opt	Tue Jun 19 16:28:20 2007
*************** gen-decls
*** 749,754 ****
--- 749,766 ----
  ObjC ObjC++
  Dump declarations to a .decl file
  
+ femit-struct-debug-baseonly
+ C ObjC C++ ObjC++
+ -femit-struct-debug-baseonly	Aggressive reduced debug info for structs
+ 
+ femit-struct-debug-reduced
+ C ObjC C++ ObjC++
+ -femit-struct-debug-reduced	Conservative reduced debug info for structs
+ 
+ femit-struct-debug-detailed=
+ C ObjC C++ ObjC++ Joined
+ -femit-struct-debug-detailed=<spec-list>	Detailed reduced debug info for structs
+ 
  idirafter
  C ObjC C++ ObjC++ Joined Separate
  -idirafter <dir>	Add <dir> to the end of the system include path
*** gcc/doc/invoke.texi.0	Tue Jun 19 11:16:17 2007
--- gcc/doc/invoke.texi	Tue Jun 19 16:28:23 2007
*************** Objective-C and Objective-C++ Dialects}.
*** 293,298 ****
--- 293,300 ----
  -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
  -g  -g@var{level}  -gcoff -gdwarf-2 -gdwarf+ @gol
  -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
+ -femit-struct-debug-baseonly -femit-struct-debug-reduced @gol
+ -femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]} @gol
  -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol
  -print-multi-directory  -print-multi-lib @gol
  -print-prog-name=@var{program}  -print-search-dirs  -Q @gol
*************** information about each symbol.  This opt
*** 3573,3578 ****
--- 3575,3652 ----
  generating DWARF2 debugging information with @option{-gdwarf-2} or
  @option{-gdwarf+}.
  
+ @item -femit-struct-debug-baseonly
+ Emit debug information for struct-like types
+ only when the base name of the compilation source file
+ matches the base name of file in which the struct was defined.
+ 
+ This option substantially reduces the size of debugging information,
+ but at significant potential loss in type information to the debugger.
+ See @option{-femit-struct-debug-reduced} for a less aggressive option.
+ See @option{-femit-struct-debug-detailed} for more detailed control.
+ 
+ This option works only with DWARF 2.
+ 
+ @item -femit-struct-debug-reduced
+ Emit debug information for struct-like types
+ only when the base name of the compilation source file
+ matches the base name of file in which the type was defined,
+ unless the struct is a template or defined in a system header.
+ 
+ This option significantly reduces the size of debugging information,
+ with some potential loss in type information to the debugger.
+ See @option{-femit-struct-debug-baseonly} for a more aggressive option.
+ See @option{-femit-struct-debug-detailed} for more detailed control.
+ 
+ This option works only with DWARF 2.
+ 
+ @item -femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]}
+ Specify the struct-like types
+ for which the compiler will generate debug information.
+ The intent is to reduce duplicate struct debug information
+ between different object files within the same program.
+ 
+ This option is a detailed version of
+ @option{-femit-struct-debug-reduced} and @option{-femit-struct-debug-baseonly},
+ which will serve for most needs.
+ 
+ A specification has the syntax
+ [@samp{dir:}|@samp{ind:}][@samp{ord:}|@samp{gen:}](@samp{any}|@samp{sys}|@samp{base}|@samp{none})
+ 
+ The optional first word limits the specification to
+ structs that are used directly (@samp{dir:}) or used indirectly (@samp{ind:}).
+ A struct type is used directly when it is the type of a variable, member.
+ Indirect uses arise through pointers to structs.
+ That is, when use of an incomplete struct would be legal, the use is indirect.
+ An example is
+ @samp{struct one direct; struct two * indirect;}.
+ 
+ The optional second word limits the specification to
+ ordinary structs (@samp{ord:}) or generic structs (@samp{gen:}).
+ Generic structs are a bit complicated to explain.
+ For C++, these are non-explicit specializations of template classes,
+ or non-template classes within the above.
+ Other programming languages have generics,
+ but @samp{-femit-struct-debug-detailed} does not yet implement them.
+ 
+ The third word specifies the source files for those
+ structs for which the compiler will emit debug information.
+ The values @samp{none} and @samp{any} have the normal meaning.
+ The value @samp{base} means that
+ the base of name of the file in which the type declaration appears
+ must match the base of the name of the main compilation file.
+ In practice, this means that
+ types declared in @file{foo.c} and @file{foo.h} will have debug information,
+ but types declared in other header will not.
+ The value @samp{sys} means those types satisfying @samp{base}
+ or declared in system or compiler headers.
+ 
+ You may need to experiment to determine the best settings for your application.
+ 
+ The default is @samp{-femit-struct-debug-detailed=all}.
+ 
+ This option works only with DWARF 2.
+ 
  @cindex @command{prof}
  @item -p
  @opindex p
*** gcc/dwarf2out.c.0	Tue Jun 19 11:16:18 2007
--- gcc/dwarf2out.c	Tue Jun 19 16:49:24 2007
*************** static dw_die_ref gen_compile_unit_die (
*** 4179,4185 ****
  static void gen_string_type_die (tree, dw_die_ref);
  static void gen_inheritance_die (tree, tree, dw_die_ref);
  static void gen_member_die (tree, dw_die_ref);
! static void gen_struct_or_union_type_die (tree, dw_die_ref);
  static void gen_subroutine_type_die (tree, dw_die_ref);
  static void gen_typedef_die (tree, dw_die_ref);
  static void gen_type_die (tree, dw_die_ref);
--- 4179,4186 ----
  static void gen_string_type_die (tree, dw_die_ref);
  static void gen_inheritance_die (tree, tree, dw_die_ref);
  static void gen_member_die (tree, dw_die_ref);
! static void gen_struct_or_union_type_die (tree, dw_die_ref,
! 						enum debug_info_usage);
  static void gen_subroutine_type_die (tree, dw_die_ref);
  static void gen_typedef_die (tree, dw_die_ref);
  static void gen_type_die (tree, dw_die_ref);
*************** gen_member_die (tree type, dw_die_ref co
*** 12441,12447 ****
     member DIEs needed by later specification DIEs.  */
  
  static void
! gen_struct_or_union_type_die (tree type, dw_die_ref context_die)
  {
    dw_die_ref type_die = lookup_type_die (type);
    dw_die_ref scope_die = 0;
--- 12442,12449 ----
     member DIEs needed by later specification DIEs.  */
  
  static void
! gen_struct_or_union_type_die (tree type, dw_die_ref context_die,
! 				enum debug_info_usage usage)
  {
    dw_die_ref type_die = lookup_type_die (type);
    dw_die_ref scope_die = 0;
*************** gen_struct_or_union_type_die (tree type,
*** 12450,12455 ****
--- 12452,12458 ----
  		  && (! TYPE_STUB_DECL (type)
  		      || ! TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type))));
    int ns_decl = (context_die && context_die->die_tag == DW_TAG_namespace);
+   complete = complete && should_emit_struct_debug (type, usage);
  
    if (type_die && ! complete)
      return;
*************** gen_typedef_die (tree decl, dw_die_ref c
*** 12581,12587 ****
  /* Generate a type description DIE.  */
  
  static void
! gen_type_die (tree type, dw_die_ref context_die)
  {
    int need_pop;
  
--- 12584,12591 ----
  /* Generate a type description DIE.  */
  
  static void
! gen_type_die_with_usage (tree type, dw_die_ref context_die,
! 				enum debug_info_usage usage)
  {
    int need_pop;
  
*************** gen_type_die (tree type, dw_die_ref cont
*** 12629,12644 ****
  
        /* For these types, all that is required is that we output a DIE (or a
  	 set of DIEs) to represent the "basis" type.  */
!       gen_type_die (TREE_TYPE (type), context_die);
        break;
  
      case OFFSET_TYPE:
        /* This code is used for C++ pointer-to-data-member types.
  	 Output a description of the relevant class type.  */
!       gen_type_die (TYPE_OFFSET_BASETYPE (type), context_die);
  
        /* Output a description of the type of the object pointed to.  */
!       gen_type_die (TREE_TYPE (type), context_die);
  
        /* Now output a DIE to represent this pointer-to-data-member type
  	 itself.  */
--- 12633,12651 ----
  
        /* For these types, all that is required is that we output a DIE (or a
  	 set of DIEs) to represent the "basis" type.  */
!       gen_type_die_with_usage (TREE_TYPE (type), context_die,
! 				DINFO_USAGE_IND_USE);
        break;
  
      case OFFSET_TYPE:
        /* This code is used for C++ pointer-to-data-member types.
  	 Output a description of the relevant class type.  */
!       gen_type_die_with_usage (TYPE_OFFSET_BASETYPE (type), context_die,
! 					DINFO_USAGE_IND_USE);
  
        /* Output a description of the type of the object pointed to.  */
!       gen_type_die_with_usage (TREE_TYPE (type), context_die,
! 					DINFO_USAGE_IND_USE);
  
        /* Now output a DIE to represent this pointer-to-data-member type
  	 itself.  */
*************** gen_type_die (tree type, dw_die_ref cont
*** 12647,12670 ****
  
      case FUNCTION_TYPE:
        /* Force out return type (in case it wasn't forced out already).  */
!       gen_type_die (TREE_TYPE (type), context_die);
        gen_subroutine_type_die (type, context_die);
        break;
  
      case METHOD_TYPE:
        /* Force out return type (in case it wasn't forced out already).  */
!       gen_type_die (TREE_TYPE (type), context_die);
        gen_subroutine_type_die (type, context_die);
        break;
  
!     case ARRAY_TYPE:
!       if (TYPE_STRING_FLAG (type) && TREE_CODE (TREE_TYPE (type)) == CHAR_TYPE)
! 	{
! 	  gen_type_die (TREE_TYPE (type), context_die);
! 	  gen_string_type_die (type, context_die);
! 	}
!       else
! 	gen_array_type_die (type, context_die);
        break;
  
      case VECTOR_TYPE:
--- 12654,12679 ----
  
      case FUNCTION_TYPE:
        /* Force out return type (in case it wasn't forced out already).  */
!       gen_type_die_with_usage (TREE_TYPE (type), context_die,
! 					DINFO_USAGE_DIR_USE);
        gen_subroutine_type_die (type, context_die);
        break;
  
      case METHOD_TYPE:
        /* Force out return type (in case it wasn't forced out already).  */
!       gen_type_die_with_usage (TREE_TYPE (type), context_die,
! 					DINFO_USAGE_DIR_USE);
        gen_subroutine_type_die (type, context_die);
        break;
  
!       case ARRAY_TYPE:
!         if (TYPE_STRING_FLAG (type) && TREE_CODE (TREE_TYPE (type)) == CHAR_TYPE)
!           {
!             gen_type_die (TREE_TYPE (type), context_die);
!             gen_string_type_die (type, context_die);
!           }
!         else
!           gen_array_type_die (type, context_die);
        break;
  
      case VECTOR_TYPE:
*************** gen_type_die (tree type, dw_die_ref cont
*** 12685,12691 ****
  	  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))
  	  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))
  	{
! 	  gen_type_die (TYPE_CONTEXT (type), context_die);
  
  	  if (TREE_ASM_WRITTEN (type))
  	    return;
--- 12694,12700 ----
  	  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))
  	  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))
  	{
! 	  gen_type_die_with_usage (TYPE_CONTEXT (type), context_die, usage);
  
  	  if (TREE_ASM_WRITTEN (type))
  	    return;
*************** gen_type_die (tree type, dw_die_ref cont
*** 12709,12715 ****
  	    gen_enumeration_type_die (type, context_die);
  	}
        else
! 	gen_struct_or_union_type_die (type, context_die);
  
        if (need_pop)
  	pop_decl_scope ();
--- 12718,12724 ----
  	    gen_enumeration_type_die (type, context_die);
  	}
        else
! 	gen_struct_or_union_type_die (type, context_die, usage);
  
        if (need_pop)
  	pop_decl_scope ();
*************** gen_type_die (tree type, dw_die_ref cont
*** 12739,12744 ****
--- 12748,12759 ----
    TREE_ASM_WRITTEN (type) = 1;
  }
  
+ static void
+ gen_type_die (tree type, dw_die_ref context_die)
+ {
+   gen_type_die_with_usage (type, context_die, DINFO_USAGE_DIR_USE);
+ }
+ 
  /* Generate a DIE for a tagged type instantiation.  */
  
  static void
*************** dwarf2out_imported_module_or_decl (tree 
*** 13358,13364 ****
    if (!context)
      scope_die = comp_unit_die;
    else if (TYPE_P (context))
!     scope_die = force_type_die (context);
    else
      scope_die = force_decl_die (context);
  
--- 13373,13383 ----
    if (!context)
      scope_die = comp_unit_die;
    else if (TYPE_P (context))
!     {
!       if (!should_emit_struct_debug (context, DINFO_USAGE_DIR_USE))
! 	return;
!       scope_die = force_type_die (context);
!     } 
    else
      scope_die = force_decl_die (context);
  
*************** dwarf2out_imported_module_or_decl (tree 
*** 13384,13390 ****
--- 13403,13414 ----
  
  	      if (TYPE_CONTEXT (type))
  		if (TYPE_P (TYPE_CONTEXT (type)))
+ 		  {
+ 		    if (!should_emit_struct_debug (TYPE_CONTEXT (type),
+ 						   DINFO_USAGE_DIR_USE))
+ 		      return;
  		  type_context_die = force_type_die (TYPE_CONTEXT (type));
+ 		  }
  	      else
  		type_context_die = force_decl_die (TYPE_CONTEXT (type));
  	      else
*** gcc/flags.h.0	Tue Jun 19 11:16:18 2007
--- gcc/flags.h	Tue Jun 19 16:28:44 2007
*************** enum debug_info_level
*** 54,59 ****
--- 54,78 ----
  /* Specify how much debugging info to generate.  */
  extern enum debug_info_level debug_info_level;
  
+ /* A major contribution to object and executable size is debug
+    information size.  A major contribution to debug information
+    size is struct descriptions replicated in several object files.
+    The following function determines whether or not debug information
+    should be generated for a given struct.  The indirect parameter
+    indicates that the struct is being handled indirectly, via
+    a pointer.  See opts.c for the implementation. */
+ 
+ enum debug_info_usage
+ {
+   DINFO_USAGE_DFN,	/* A struct definition. */
+   DINFO_USAGE_DIR_USE,	/* A direct use, such as the type of a variable. */
+   DINFO_USAGE_IND_USE,	/* An indirect use, such as through a pointer. */
+   DINFO_USAGE_NUM_ENUMS	/* The number of enumerators. */
+ };
+ 
+ extern bool should_emit_struct_debug (tree type_decl, enum debug_info_usage);
+ extern void set_struct_debug_option (const char *value);
+ 
  /* Nonzero means use GNU-only extensions in the generated symbolic
     debugging information.  */
  extern bool use_gnu_debug_info_extensions;
*** gcc/langhooks-def.h.0	Tue Jun 19 11:16:18 2007
--- gcc/langhooks-def.h	Tue Jun 19 16:28:26 2007
*************** extern tree lhd_make_node (enum tree_cod
*** 214,219 ****
--- 214,220 ----
     so we create a compile-time error instead.  */
  #define LANG_HOOKS_MAKE_TYPE lhd_make_node
  #define LANG_HOOKS_INCOMPLETE_TYPE_ERROR lhd_incomplete_type_error
+ #define LANG_HOOKS_GENERIC_TYPE_P	hook_bool_tree_false
  #define LANG_HOOKS_TYPE_PROMOTES_TO lhd_type_promotes_to
  #define LANG_HOOKS_REGISTER_BUILTIN_TYPE lhd_register_builtin_type
  #define LANG_HOOKS_TYPE_MAX_SIZE	lhd_return_null_tree
*************** extern tree lhd_make_node (enum tree_cod
*** 226,231 ****
--- 227,233 ----
    LANG_HOOKS_UNSIGNED_TYPE, \
    LANG_HOOKS_SIGNED_TYPE, \
    LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE, \
+   LANG_HOOKS_GENERIC_TYPE_P, \
    LANG_HOOKS_TYPE_PROMOTES_TO, \
    LANG_HOOKS_REGISTER_BUILTIN_TYPE, \
    LANG_HOOKS_INCOMPLETE_TYPE_ERROR, \
*** gcc/langhooks.h.0	Tue Jun 19 11:16:18 2007
--- gcc/langhooks.h	Tue Jun 19 16:28:33 2007
*************** struct lang_hooks_for_types
*** 117,122 ****
--- 117,126 ----
       according to UNSIGNEDP.  */
    tree (*signed_or_unsigned_type) (int, tree);
  
+   /* True if the type is an instantiation of a generic type,
+      e.g. C++ template implicit specializations.  */
+   bool (*generic_p) (tree);
+   
    /* Given a type, apply default promotions to unnamed function
       arguments and return the new type.  Return the same type if no
       change.  Required by any language that supports variadic
*** gcc/opts.c.0	Tue Jun 19 11:16:18 2007
--- gcc/opts.c	Tue Jun 19 16:28:41 2007
*************** enum debug_info_type write_symbols = NO_
*** 73,78 ****
--- 73,328 ----
     the definitions of the different possible levels.  */
  enum debug_info_level debug_info_level = DINFO_LEVEL_NONE;
  
+ /* A major contribution to object and executable size is debug
+    information size.  A major contribution to debug information size
+    is struct descriptions replicated in several object files. The
+    following flags attempt to reduce this information.  The basic
+    idea is to not emit struct debugging information in the current
+    compilation unit when that information will be generated by
+    another compilation unit.
+ 
+    Debug information for a struct defined in the current source
+    file should be generated in the object file.  Likewise the
+    debug information for a struct defined in a header should be
+    generated in the object file of the corresponding source file.
+    Both of these case are handled when the base name of the file of
+    the struct definition matches the base name of the source file
+    of thet current compilation unit.  This matching emits minimal
+    struct debugging information.
+ 
+    The base file name matching rule above will fail to emit debug
+    information for structs defined in system headers.  So a second
+    category of files includes system headers in addition to files
+    with matching bases.
+ 
+    The remaining types of files are library headers and application
+    headers.  We cannot currently distinguish these two types.  */
+ 
+ enum debug_struct_file
+ {
+   DINFO_STRUCT_FILE_NONE,   /* Debug no structs. */
+   DINFO_STRUCT_FILE_BASE,   /* Debug structs defined in files with the
+                                same base name as the compilation unit. */
+   DINFO_STRUCT_FILE_SYS,    /* Also debug structs defined in system
+                                header files.  */
+   DINFO_STRUCT_FILE_ANY     /* Debug structs defined in all files. */
+ };
+ 
+ /* Generic structs (e.g. templates not explicitly specialized)
+    may not have a compilation unit associated with them, and so
+    may need to be treated differently from ordinary structs.
+ 
+    Structs only handled by reference (indirectly), will also usually
+    not need as much debugging information.  */
+ 
+ static enum debug_struct_file debug_struct_ordinary[DINFO_USAGE_NUM_ENUMS]
+   = { DINFO_STRUCT_FILE_ANY, DINFO_STRUCT_FILE_ANY, DINFO_STRUCT_FILE_ANY };
+ static enum debug_struct_file debug_struct_generic[DINFO_USAGE_NUM_ENUMS]
+   = { DINFO_STRUCT_FILE_ANY, DINFO_STRUCT_FILE_ANY, DINFO_STRUCT_FILE_ANY };
+ 
+ /* Parse the -femit-struct-debug-detailed option value
+    and set the flag variables. */
+ 
+ #define MATCH( prefix, string ) \
+   ((strncmp (prefix, string, sizeof prefix - 1) == 0) \
+    ? ((string += sizeof prefix - 1), 1) : 0)
+ 
+ void
+ set_struct_debug_option (const char *spec)
+ {
+   /* various labels for comparison */
+   static char dfn_lbl[] = "dfn:", dir_lbl[] = "dir:", ind_lbl[] = "ind:";
+   static char ord_lbl[] = "ord:", gen_lbl[] = "gen:";
+   static char none_lbl[] = "none", any_lbl[] = "any";
+   static char base_lbl[] = "base", sys_lbl[] = "sys";
+ 
+   enum debug_struct_file files = DINFO_STRUCT_FILE_ANY;
+   /* Default is to apply to as much as possible. */
+   enum debug_info_usage usage = DINFO_USAGE_NUM_ENUMS;
+   int ord = 1, gen = 1;
+ 
+   /* What usage? */
+   if (MATCH (dfn_lbl, spec))
+     usage = DINFO_USAGE_DFN;
+   else if (MATCH (dir_lbl, spec))
+     usage = DINFO_USAGE_DIR_USE;
+   else if (MATCH (ind_lbl, spec))
+     usage = DINFO_USAGE_IND_USE;
+ 
+   /* Generics or not? */
+   if (MATCH (ord_lbl, spec))
+     gen = 0;
+   else if (MATCH (gen_lbl, spec))
+     ord = 0;
+ 
+   /* What allowable environment? */
+   if (MATCH (none_lbl, spec))
+     files = DINFO_STRUCT_FILE_NONE;
+   else if (MATCH (any_lbl, spec))
+     files = DINFO_STRUCT_FILE_ANY;
+   else if (MATCH (sys_lbl, spec))
+     files = DINFO_STRUCT_FILE_SYS;
+   else if (MATCH (base_lbl, spec))
+     files = DINFO_STRUCT_FILE_BASE;
+   else
+     error ("argument %qs to %<-femit-struct-debug-detailed%> not recognized",
+            spec);
+ 
+   /* Effect the specification. */
+   if (usage == DINFO_USAGE_NUM_ENUMS)
+     {
+       if (ord)
+         {
+           debug_struct_ordinary[DINFO_USAGE_DFN] = files;
+           debug_struct_ordinary[DINFO_USAGE_DIR_USE] = files;
+           debug_struct_ordinary[DINFO_USAGE_IND_USE] = files;
+         }
+       if (gen)
+         {
+           debug_struct_generic[DINFO_USAGE_DFN] = files;
+           debug_struct_generic[DINFO_USAGE_DIR_USE] = files;
+           debug_struct_generic[DINFO_USAGE_IND_USE] = files;
+         }
+     }
+   else
+     {
+       if (ord)
+         debug_struct_ordinary[usage] = files;
+       if (gen)
+         debug_struct_generic[usage] = files;
+     }
+ 
+   if (*spec == ',')
+     set_struct_debug_option (spec+1);
+   else
+     {
+       /* No more -femit-struct-debug-detailed specifications.
+          Do final checks. */
+       if (*spec != '\0')
+ 	error ("argument %qs to %<-femit-struct-debug-detailed%> unknown",
+                spec);
+       if (debug_struct_ordinary[DINFO_USAGE_DIR_USE]
+ 		< debug_struct_ordinary[DINFO_USAGE_IND_USE]
+ 	  || debug_struct_generic[DINFO_USAGE_DIR_USE]
+ 		< debug_struct_generic[DINFO_USAGE_IND_USE])
+ 	error ("%<-femit-struct-debug-detailed=dir:...%> must allow at least"
+                " as much as %<-femit-struct-debug-detailed=ind:...%>");
+     }
+ }
+ 
+ /* Find the base name of a path, stripping off both directories and
+    a single final extension. */
+ static int
+ base_of_path (const char *path, const char **base_out)
+ {
+   const char *base = path;
+   const char *dot = 0;
+   const char *p = path;
+   char c = *p;
+   while (c)
+     {
+       if (IS_DIR_SEPARATOR(c))
+         {
+           base = p + 1;
+           dot = 0;
+         }
+       else if (c == '.')
+         dot = p;
+       c = *++p;
+     }
+   if (!dot)
+     dot = p;
+   *base_out = base;
+   return dot - base;
+ }
+ 
+ /* Match the base name of a file to the base name of a compilation unit. */
+ 
+ static const char *main_input_basename;
+ static int main_input_baselength;
+ 
+ static int
+ matches_main_base (const char *path)
+ {
+   /* Cache the last query. */
+   static const char *last_path = NULL;
+   static int last_match = 0;
+   if (path != last_path)
+     {
+       const char *base;
+       int length = base_of_path (path, &base);
+       last_path = path;
+       last_match = (length == main_input_baselength
+                     && memcmp (base, main_input_basename, length) == 0);
+     }
+   return last_match;
+ }
+ 
+ #ifdef DEBUG_DEBUG_STRUCT
+ 
+ static int
+ dump_struct_debug (tree type, enum debug_info_usage usage,
+ 		   enum debug_struct_file criterion, int generic,
+ 		   int matches, int result)
+ {
+   /* Find the type name. */
+   tree type_decl = TYPE_STUB_DECL (type);
+   tree t = type_decl;
+   const char *name = 0;
+   if (TREE_CODE (t) == TYPE_DECL)
+     t = DECL_NAME (t);
+   if (t)
+     name = IDENTIFIER_POINTER (t);
+ 
+   fprintf (stderr, "	struct %d %s %s %s %s %d %p %s\n",
+ 	   criterion,
+            DECL_IN_SYSTEM_HEADER (type_decl) ? "sys" : "usr",
+            matches ? "bas" : "hdr",
+            generic ? "gen" : "ord",
+            usage == DINFO_USAGE_DFN ? ";" :
+              usage == DINFO_USAGE_DIR_USE ? "." : "*",
+            result,
+            (void*) type_decl, name);
+   return result;
+ }
+ #define DUMP_GSTRUCT(type, usage, criterion, generic, matches, result) \
+   dump_struct_debug (type, usage, criterion, generic, matches, result)
+ 
+ #else
+ 
+ #define DUMP_GSTRUCT(type, usage, criterion, generic, matches, result) \
+   (result)
+ 
+ #endif
+ 
+ 
+ bool
+ should_emit_struct_debug (tree type, enum debug_info_usage usage)
+ {
+   enum debug_struct_file criterion;
+   tree type_decl;
+   bool generic = lang_hooks.types.generic_p (type);
+ 
+   if (generic)
+     criterion = debug_struct_generic[usage];
+   else
+     criterion = debug_struct_ordinary[usage];
+ 
+   if (criterion == DINFO_STRUCT_FILE_NONE)
+     return DUMP_GSTRUCT (type, usage, criterion, generic, false, false);
+   if (criterion == DINFO_STRUCT_FILE_ANY)
+     return DUMP_GSTRUCT (type, usage, criterion, generic, false, true);
+ 
+   type_decl = TYPE_STUB_DECL (type);
+ 
+   if (criterion == DINFO_STRUCT_FILE_SYS && DECL_IN_SYSTEM_HEADER (type_decl))
+     return DUMP_GSTRUCT (type, usage, criterion, generic, false, true);
+ 
+   if (matches_main_base (DECL_SOURCE_FILE (type_decl)))
+     return DUMP_GSTRUCT (type, usage, criterion, generic, true, true);
+   return DUMP_GSTRUCT (type, usage, criterion, generic, false, false);
+ }
+ 
  /* Nonzero means use GNU-only extensions in the generated symbolic
     debugging information.  Currently, this only has an effect when
     write_symbols is set to DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
*** gcc/config/ia64/ia64.c.orig	2007-07-02 12:49:54.000000000 +0200
--- gcc/config/ia64/ia64.c	2007-07-03 17:44:03.000000000 +0200
***************
*** 2891,2898 ****
  
  /* See Table 6.2 of the IA-64 Software Developer Manual, Volume 2.  */
  #define BACKING_STORE_SIZE(N) ((N) > 0 ? ((N) + (N)/63 + 1) * 8 : 0)
- #define BACKING_STORE_PROTECT (2 * 1024)
- #define MAX_STACKED_REGISTERS 96
  
  const char *
  output_probe_stack_range (rtx first_rtx, rtx size_rtx)
--- 2891,2896 ----
***************
*** 2902,2908 ****
    HOST_WIDE_INT size = INTVAL (size_rtx);
    HOST_WIDE_INT end = first + size;
    HOST_WIDE_INT rounded_size;
!   int sol, bs_size, bs_end;
    char loop_lab[32], end_lab[32];
  
    /* On the IA-64 there is a second stack in memory, namely the Backing Store
--- 2900,2906 ----
    HOST_WIDE_INT size = INTVAL (size_rtx);
    HOST_WIDE_INT end = first + size;
    HOST_WIDE_INT rounded_size;
!   int sol, bs_size;
    char loop_lab[32], end_lab[32];
  
    /* On the IA-64 there is a second stack in memory, namely the Backing Store
***************
*** 2911,2950 ****
    sol = current_frame_info.n_input_regs + current_frame_info.n_local_regs;
    bs_size = BACKING_STORE_SIZE (sol);
  
-   /* End of the probed area for the Backing Store.  */
-   bs_end = BACKING_STORE_PROTECT + bs_size;
- 
-   /* Unlike for the memory stack, it seems that we need to probe every single
-      page above the current BSP.  Since we use only one probe for the Backing
-      Store, the following condition should be false at compile time.  */
- #if (BACKING_STORE_PROTECT + BACKING_STORE_SIZE (MAX_STACKED_REGISTERS)) > PROBE_INTERVAL
- #error Cannot use a single probe for the Backing Store
- #endif
- 
    /* Detect collision of the 2 stacks if necessary.  */
    if (bs_size > 0 || size > 0)
      {
!       fputs ("\tmov r3 = ar.bsp\n", asm_out_file);
!       fprintf (asm_out_file, "\tmovl r2 = -"HOST_WIDE_INT_PRINT_DEC"\n\t;;\n",
! 	       end);
  
        /* Compare current value of BSP and SP registers.  */
!       fputs ("\tcmp.ltu p6, p0 = r3, r12\n", asm_out_file);
  
        /* Compute the address of the probe for the Backing Store (which grows
! 	 towards higher addresses) and that of the last probe for the memory
  	 stack (which grows towards lower addresses).  */
!       fprintf (asm_out_file, "\taddl r3 = %d, r3\n", bs_end);
        fputs ("\tadd r2 = r2, r12\n\t;;\n", asm_out_file);
  
        /* Compare them and raise SEGV if the former has topped the latter.  */
        fputs ("\t(p6) cmp.ltu p0, p6 = r3, r2\n\t;;\n", asm_out_file);
        fputs ("\t(p6) break 11\n\t;;\n", asm_out_file);
      }
  
    /* Probe the Backing Store if necessary.  */
    if (bs_size > 0)
!     fputs ("\tst8.rel [r3] = r0\n", asm_out_file);
  
    /* Probe the memory stack if necessary.  */
    if (size == 0)
--- 2909,2953 ----
    sol = current_frame_info.n_input_regs + current_frame_info.n_local_regs;
    bs_size = BACKING_STORE_SIZE (sol);
  
    /* Detect collision of the 2 stacks if necessary.  */
    if (bs_size > 0 || size > 0)
      {
!       /* FIXME: clobber r2 and r3.  Should check for fixed registers.  */
  
+       fputs ("\tmov r3 = ar.bsp\n", asm_out_file);
+       /* Micro-optimization based on number of bits for END.  */
+       if (end >= (1 << 21))
+ 	fprintf (asm_out_file,
+ 		 "\tmovl r2 = -"HOST_WIDE_INT_PRINT_DEC"\n", end);
+       else
+ 	fprintf (asm_out_file,
+ 		 "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC",r0\n", end);
+       
        /* Compare current value of BSP and SP registers.  */
!       fputs ("\t;;\n"
! 	     "\tcmp.ltu p6, p0 = r3, r12\n", asm_out_file);
  
        /* Compute the address of the probe for the Backing Store (which grows
! 	 towards higher addresses).  We probe only at the first offset of
! 	 the next page because some OS (eg Linux/ia64) only extend the
! 	 backing store when this specific address is hit (but generate a SEGV
! 	 on other address).  Page size is the worst case (4KB).  The reserve
! 	 size is at least 4096 - (96 + 2) * 8 = 3312 bytes - which is
! 	 enough.
! 	 Also compute the address of the last probe for the memory
  	 stack (which grows towards lower addresses).  */
!       fputs ("\tadd r3 = 4095, r3\n", asm_out_file);
        fputs ("\tadd r2 = r2, r12\n\t;;\n", asm_out_file);
  
        /* Compare them and raise SEGV if the former has topped the latter.  */
        fputs ("\t(p6) cmp.ltu p0, p6 = r3, r2\n\t;;\n", asm_out_file);
+       fputs ("\tdep r3 = r0, r3, 0, 12\n", asm_out_file);
        fputs ("\t(p6) break 11\n\t;;\n", asm_out_file);
      }
  
    /* Probe the Backing Store if necessary.  */
    if (bs_size > 0)
!     fputs ("\tst8 [r3] = r0\n", asm_out_file);
  
    /* Probe the memory stack if necessary.  */
    if (size == 0)
***************
*** 2953,2959 ****
    /* See if we have a constant small number of probes to generate.  If so,
       that's the easy case.  */
    else if (size <= PROBE_INTERVAL)
!     fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
  
    /* The run-time loop is made up of 8 insns in the generic case while this
       compile-time loop is made up of 5+2*(n-2) insns for n # of intervals.  */
--- 2956,2962 ----
    /* See if we have a constant small number of probes to generate.  If so,
       that's the easy case.  */
    else if (size <= PROBE_INTERVAL)
!     fputs ("\tst8 [r2] = r0\n", asm_out_file);
  
    /* The run-time loop is made up of 8 insns in the generic case while this
       compile-time loop is made up of 5+2*(n-2) insns for n # of intervals.  */
***************
*** 2964,2970 ****
        fputs ("\tmov r2 = r12\n\t;;\n", asm_out_file);
        fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
  	       first + PROBE_INTERVAL);
!       fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
  
        /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
  	 it exceeds SIZE.  If only two probes are needed, this will not
--- 2967,2973 ----
        fputs ("\tmov r2 = r12\n\t;;\n", asm_out_file);
        fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
  	       first + PROBE_INTERVAL);
!       fputs ("\tst8 [r2] = r0\n", asm_out_file);
  
        /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until
  	 it exceeds SIZE.  If only two probes are needed, this will not
***************
*** 2972,2983 ****
        for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
  	{
  	  fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
! 	  fputs ("\tst8.rel [r2] = r0\n\t;;\n", asm_out_file);
  	}
  
        fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
  	       size - (i - PROBE_INTERVAL));
!       fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
      }
  
    /* Otherwise, do the same as above, but in a loop.  Note that we must be
--- 2975,2986 ----
        for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
  	{
  	  fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
! 	  fputs ("\tst8 [r2] = r0\n\t;;\n", asm_out_file);
  	}
  
        fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
  	       size - (i - PROBE_INTERVAL));
!       fputs ("\tst8 [r2] = r0\n", asm_out_file);
      }
  
    /* Otherwise, do the same as above, but in a loop.  Note that we must be
***************
*** 3039,3045 ****
        fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
    
        /* Probe at TEST_ADDR and branch.  */
!       fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
        fprintf (asm_out_file, "\tbr "); assemble_name (asm_out_file, loop_lab);
        fputc ('\n', asm_out_file);
  
--- 3042,3048 ----
        fprintf (asm_out_file, "\taddl r2 = -%d, r2\n\t;;\n", PROBE_INTERVAL);
    
        /* Probe at TEST_ADDR and branch.  */
!       fputs ("\tst8 [r2] = r0\n", asm_out_file);
        fprintf (asm_out_file, "\tbr "); assemble_name (asm_out_file, loop_lab);
        fputc ('\n', asm_out_file);
  
***************
*** 3054,3060 ****
          {
  	  fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
  		   size - rounded_size);
! 	  fputs ("\tst8.rel [r2] = r0\n", asm_out_file);
  	}
      }
  
--- 3057,3063 ----
          {
  	  fprintf (asm_out_file, "\taddl r2 = -"HOST_WIDE_INT_PRINT_DEC", r2\n\t;;\n",
  		   size - rounded_size);
! 	  fputs ("\tst8 [r2] = r0\n", asm_out_file);
  	}
      }
  
*** gcc/dbxout.c.0	2007-07-07 18:18:09.535320376 +0200
--- gcc/dbxout.c	2007-07-07 18:41:16.475473424 +0200
*************** dbxout_class_name_qualifiers (tree decl)
*** 2326,2343 ****
  
  /* This is a specialized subset of expand_expr for use by dbxout_symbol in
     evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that
!    havn't been expanded, or if the expression is getting so complex we won't
!    be able to represent it in stabs anyway.  Returns NULL on failure.  */
  
  static rtx
! dbxout_expand_expr (tree expr)
  {
    switch (TREE_CODE (expr))
      {
      case VAR_DECL:
      case PARM_DECL:
        if (DECL_HAS_VALUE_EXPR_P (expr))
! 	return dbxout_expand_expr (DECL_VALUE_EXPR (expr));
        /* FALLTHRU */
  
      case CONST_DECL:
--- 2326,2346 ----
  
  /* This is a specialized subset of expand_expr for use by dbxout_symbol in
     evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that
!    haven't been expanded, or if the expression is getting so complex we won't
!    be able to represent it in stabs anyway.
! 
!    Return the RTX for EXPR and set TYPE to the new type associated with it
!    if it is not that of EXPR.  Return NULL on failure.  */
  
  static rtx
! dbxout_expand_expr (tree expr, tree *type)
  {
    switch (TREE_CODE (expr))
      {
      case VAR_DECL:
      case PARM_DECL:
        if (DECL_HAS_VALUE_EXPR_P (expr))
! 	return dbxout_expand_expr (DECL_VALUE_EXPR (expr), type);
        /* FALLTHRU */
  
      case CONST_DECL:
*************** dbxout_expand_expr (tree expr)
*** 2361,2367 ****
  	tem = get_inner_reference (expr, &bitsize, &bitpos, &offset,
  				   &mode, &unsignedp, &volatilep, true);
  
! 	x = dbxout_expand_expr (tem);
  	if (x == NULL || !MEM_P (x))
  	  return NULL;
  	if (offset != NULL)
--- 2364,2370 ----
  	tem = get_inner_reference (expr, &bitsize, &bitpos, &offset,
  				   &mode, &unsignedp, &volatilep, true);
  
! 	x = dbxout_expand_expr (tem, type);
  	if (x == NULL || !MEM_P (x))
  	  return NULL;
  	if (offset != NULL)
*************** dbxout_expand_expr (tree expr)
*** 2376,2381 ****
--- 2379,2390 ----
  	return x;
        }
  
+     case INDIRECT_REF:
+       /* The real object is the underlying pointer.  */
+       *type = make_node (REFERENCE_TYPE);
+       TREE_TYPE (*type) = TREE_TYPE (expr);
+       return dbxout_expand_expr (TREE_OPERAND (expr, 0), type);
+       
      default:
        return NULL;
      }
*************** dbxout_symbol (tree decl, int local ATTR
*** 2704,2710 ****
  	}
        /* else it is something we handle like a normal variable.  */
  
!       decl_rtl = dbxout_expand_expr (decl);
        if (!decl_rtl)
  	DBXOUT_DECR_NESTING_AND_RETURN (0);
  
--- 2713,2719 ----
  	}
        /* else it is something we handle like a normal variable.  */
  
!       decl_rtl = dbxout_expand_expr (decl, &type);
        if (!decl_rtl)
  	DBXOUT_DECR_NESTING_AND_RETURN (0);
  
*** gcc/dbxout.c.0	2007-07-07 22:55:10.000000000 +0200
--- gcc/dbxout.c	2007-07-07 23:02:14.130148104 +0200
*************** dbxout_reg_parms (tree parms)
*** 3251,3260 ****
        {
  	/* Report parms that live in registers during the function
  	   but were passed in memory.  */
! 	if (REG_P (DECL_RTL (parms))
! 	    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
! 	  dbxout_symbol_location (parms, TREE_TYPE (parms),
! 				  0, DECL_RTL (parms));
  	else if (GET_CODE (DECL_RTL (parms)) == CONCAT)
  	  dbxout_symbol_location (parms, TREE_TYPE (parms),
  				  0, DECL_RTL (parms));
--- 3251,3287 ----
        {
  	/* Report parms that live in registers during the function
  	   but were passed in memory.  */
! 	if (REG_P (DECL_RTL (parms)))
! 	  {
! 	    if (REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)
! 	      dbxout_symbol_location (parms, TREE_TYPE (parms),
! 				    0, DECL_RTL (parms));
! 	    else
! 	      {
! 		/* Here, we are looking at where the parameter lives. This is
! 	           normally indicated by DECL_RTL. However, when optimization
! 		   is enabled, this might contain a pseudo-reg (this is the
! 	           case here, see test above.
! 	           In this case, we can use DECL_INCOMING_RTL as the source
! 	           for this information, in certain limited cases. For a full
! 	           explanations of the heuristics used, see file dwarf2out.c,
! 	           function rtl_for_decl_location.  */
! 
! 	        tree declared_type = TYPE_MAIN_VARIANT (TREE_TYPE (parms));
! 	        tree passed_type = TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parms));
! 
! 	        if (declared_type == passed_type)
! 	          dbxout_symbol_location (parms, TREE_TYPE (parms),
! 	                                  0, DECL_INCOMING_RTL (parms));
! 	        else if (! BYTES_BIG_ENDIAN
! 	                 && ((TREE_CODE (declared_type) == INTEGER_TYPE)
! 	                     || (TREE_CODE (declared_type) == ENUMERAL_TYPE))
! 	                 && (GET_MODE_SIZE (TYPE_MODE (declared_type))
! 	                      <= GET_MODE_SIZE (TYPE_MODE (passed_type))))
! 	          dbxout_symbol_location (parms, TREE_TYPE (parms),
!                                           0, DECL_INCOMING_RTL (parms));
! 	      }
! 	  }
  	else if (GET_CODE (DECL_RTL (parms)) == CONCAT)
  	  dbxout_symbol_location (parms, TREE_TYPE (parms),
  				  0, DECL_RTL (parms));
*** gcc/doc/tm.texi.ori	Thu Jul 12 10:33:55 2007
--- gcc/doc/tm.texi	Thu Jul 12 10:34:05 2007
*************** addresses.  Many RISC machines have no m
*** 5129,5134 ****
--- 5129,5144 ----
  You may assume that @var{addr} is a valid address for the machine.
  @end defmac
  
+ @defmac GO_IF_MAY_NARROW_ACCESS_TO (@var{addr}, @var{mode}, @var{label})
+ A C statement or compound statement with a conditional @code{goto
+ @var{label};} executed if @var{addr}, an RTX for a legitimate memory
+ address in mode, may be accessed using a narrower mode for the purpose
+ of an ``offsettable'' reference.
+ 
+ The default definition implements a win if @var{addr} is not mode
+ dependent.
+ @end defmac
+ 
  @defmac LEGITIMATE_CONSTANT_P (@var{x})
  A C expression that is nonzero if @var{x} is a legitimate constant for
  an immediate operand on the target machine.  You can assume that
*** gcc/config/rs6000/rs6000.c.ori	Thu Jul 12 10:33:55 2007
--- gcc/config/rs6000/rs6000.c	Thu Jul 12 10:34:06 2007
*************** rs6000_legitimate_address (enum machine_
*** 3542,3557 ****
    return 0;
  }
  
! /* Go to LABEL if ADDR (a legitimate address expression)
!    has an effect that depends on the machine mode it is used for.
  
     On the RS/6000 this is true of all integral offsets (since AltiVec
!    modes don't allow them) or is a pre-increment or decrement.
! 
!    ??? Except that due to conceptual problems in offsettable_address_p
!    we can't really report the problems of integral offsets.  So leave
!    this assuming that the adjustable offset must be valid for the
!    sub-words of a TFmode operand, which is what we had before.  */
  
  bool
  rs6000_mode_dependent_address (rtx addr)
--- 3542,3552 ----
    return 0;
  }
  
! /* Whether ADDR, a legitimate address expression, has an effect that depends
!    on the machine mode it is used for.
  
     On the RS/6000 this is true of all integral offsets (since AltiVec
!    modes don't allow them) or is a pre-increment or decrement.  */
  
  bool
  rs6000_mode_dependent_address (rtx addr)
*************** rs6000_mode_dependent_address (rtx addr)
*** 3560,3569 ****
      {
      case PLUS:
        if (GET_CODE (XEXP (addr, 1)) == CONST_INT)
! 	{
! 	  unsigned HOST_WIDE_INT val = INTVAL (XEXP (addr, 1));
! 	  return val + 12 + 0x8000 >= 0x10000;
! 	}
        break;
  
      case LO_SUM:
--- 3555,3561 ----
      {
      case PLUS:
        if (GET_CODE (XEXP (addr, 1)) == CONST_INT)
! 	return true;
        break;
  
      case LO_SUM:
*************** rs6000_mode_dependent_address (rtx addr)
*** 3580,3585 ****
--- 3572,3597 ----
    return false;
  }
  
+ /* Whether ADDR, a legitimate address expression for MODE, may be accessed
+    using a narrower mode for the purpose of an "offsettable" reference.  */
+ 
+ bool
+ rs6000_may_narrow_access_to (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED)
+ {
+   switch (GET_CODE (addr))
+     {
+     case LO_SUM:
+       return false;
+ 
+     case PRE_INC:
+     case PRE_DEC:
+       return !TARGET_UPDATE;
+ 
+     default:
+       return true;
+     }
+ }
+ 
  /* More elaborate version of recog's offsettable_memref_p predicate
     that works around the ??? note of rs6000_mode_dependent_address.
     In particular it accepts
*** gcc/config/rs6000/rs6000.h.ori	Thu Jul 12 10:33:55 2007
--- gcc/config/rs6000/rs6000.h	Thu Jul 12 10:34:06 2007
*************** do {								\
*** 1823,1828 ****
--- 1823,1838 ----
    if (rs6000_mode_dependent_address (ADDR))			\
      goto LABEL;							\
  } while (0)
+ 
+ /* Go to LABEL if ADDR, a legitimate address expression in MODE,
+    may be accessed using a narrower mode for the purpose of an
+    "offsettable" constraint check.  */
+ 
+ #define GO_IF_MAY_NARROW_ACCESS_TO(ADDR,MODE,LABEL)		\
+ do {								\
+   if (rs6000_may_narrow_access_to ((ADDR), (MODE)))		\
+     goto LABEL;							\
+ } while (0)
  
  /* The register number of the register used to address a table of
     static data addresses in memory.  In some cases this register is
*** gcc/config/rs6000/rs6000-protos.h.ori	Thu Jul 12 10:33:55 2007
--- gcc/config/rs6000/rs6000-protos.h	Thu Jul 12 10:34:06 2007
*************** extern int rs6000_legitimate_address (en
*** 102,107 ****
--- 102,108 ----
  extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);
  extern bool rs6000_mode_dependent_address (rtx);
  extern bool rs6000_offsettable_memref_p (rtx);
+ extern bool rs6000_may_narrow_access_to (rtx, enum machine_mode);
  extern rtx rs6000_return_addr (int, rtx);
  extern void rs6000_output_symbol_ref (FILE*, rtx);
  extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);
*** gcc/recog.c.ori	Thu Jul 12 10:33:55 2007
--- gcc/recog.c	Thu Jul 12 10:34:05 2007
*************** static void validate_replace_rtx_1 (rtx 
*** 62,67 ****
--- 62,68 ----
  static rtx *find_single_use_1 (rtx, rtx *);
  static void validate_replace_src_1 (rtx *, void *);
  static rtx split_insn (rtx);
+ static int may_narrow_access_to (rtx, enum machine_mode);
  
  /* Nonzero means allow operands to be volatile.
     This should be 0 if you are generating rtl, such as if you are calling
*************** offsettable_address_p (int strictp, enum
*** 1914,1920 ****
    /* Adjusting an offsettable address involves changing to a narrower mode.
       Make sure that's OK.  */
  
!   if (mode_dependent_address_p (y))
      return 0;
  
    /* ??? How much offset does an offsettable BLKmode reference need?
--- 1915,1921 ----
    /* Adjusting an offsettable address involves changing to a narrower mode.
       Make sure that's OK.  */
  
!   if (!may_narrow_access_to (y, mode))
      return 0;
  
    /* ??? How much offset does an offsettable BLKmode reference need?
*************** mode_dependent_address_p (rtx addr ATTRI
*** 1978,1983 ****
--- 1979,2011 ----
   win: ATTRIBUTE_UNUSED_LABEL
    return 1;
  }
+ 
+ /* Default GO_IF_MAY_NARROW_ACCESS_TO. Go to LABEL if ADDR, a legitimate
+    address expression for MODE, may be accessed using a narrower mode for the
+    purpose of an "offsettable" reference.  */
+  
+ #ifndef GO_IF_MAY_NARROW_ACCESS_TO
+ #define GO_IF_MAY_NARROW_ACCESS_TO(ADDR,MODE,LABEL)		\
+ do {								\
+       /* We may for sure access ADDR using a narrower		\
+ 	 mode than MODE if the effect is mode independant.  */	\
+      if (!mode_dependent_address_p (ADDR))			\
+        goto LABEL;						\
+ } while (0)
+ #endif
+ 
+ /* Return 1 if ADDR, known to be valid for MODE, might be accessed using a
+    narrower mode for the purpose of an "offsettable" reference.  */
+ 
+ static int
+ may_narrow_access_to (rtx addr ATTRIBUTE_UNUSED,
+ 		      enum machine_mode mode ATTRIBUTE_UNUSED)
+ {
+   GO_IF_MAY_NARROW_ACCESS_TO (addr, mode, win);
+   return 0;
+  win: ATTRIBUTE_UNUSED_LABEL
+   return 1;
+ }
  
  /* Like extract_insn, but save insn extracted and don't extract again, when
     called again for the same insn expecting that recog_data still contain the
*** gcc/config/pa/pa.c.ori	Thu Jul 12 17:11:43 2007
--- gcc/config/pa/pa.c	Thu Jul 12 17:11:48 2007
*************** output_call (rtx insn, rtx call_dest, in
*** 7550,7568 ****
    if (!delay_slot_filled && INSN_ADDRESSES_SET_P ())
      {
        /* See if the return address can be adjusted.  Use the containing
!          sequence insn's address.  */
!       rtx seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));
!       int distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))
! 		      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);
! 
!       if (VAL_14_BITS_P (distance))
! 	{
! 	  xoperands[1] = gen_label_rtx ();
! 	  output_asm_insn ("ldo %0-%1(%%r2),%%r2", xoperands);
! 	  (*targetm.asm_out.internal_label) (asm_out_file, "L",
! 					     CODE_LABEL_NUMBER (xoperands[1]));
  	}
!       else
  	output_asm_insn ("nop\n\tb,n %0", xoperands);
      }
    else
--- 7550,7580 ----
    if (!delay_slot_filled && INSN_ADDRESSES_SET_P ())
      {
        /* See if the return address can be adjusted.  Use the containing
!          sequence insn's address.  Avoid doing that if we're generating call
!          frame information, because we need the return address to remain right
!          after the call in order not to badly confuse the unwinder.  */
!       int call_with_adjusted_ra = 0;
! 
!       if (!DO_FRAME_NOTES)
! 	{	  
! 	  rtx seq_insn
! 	    = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));
! 
! 	  int distance
! 	    = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))
! 	       - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);
! 
! 	  if (VAL_14_BITS_P (distance))
! 	    {
! 	      xoperands[1] = gen_label_rtx ();
! 	      output_asm_insn ("ldo %0-%1(%%r2),%%r2", xoperands);
! 	      (*targetm.asm_out.internal_label)
! 		(asm_out_file, "L", CODE_LABEL_NUMBER (xoperands[1]));
! 	      call_with_adjusted_ra = 1;
! 	    }
  	}
!       
!       if (!call_with_adjusted_ra)
  	output_asm_insn ("nop\n\tb,n %0", xoperands);
      }
    else
*** gcc/config/mips/iris6.h.ori	Tue Jul 10 11:32:36 2007
--- gcc/config/mips/iris6.h	Tue Jul 10 12:57:22 2007
*************** Boston, MA 02110-1301, USA.  */
*** 52,57 ****
--- 52,58 ----
  #else
  #define IRIX_SUBTARGET_LINK_SPEC \
    "%{w} -_SYSTYPE_SVR4 -woff 131 \
+    %{shared:-hidden_symbol __gcc_init,__gcc_fini,__dso_handle} \
     %{mabi=32: -32}%{mabi=n32: -n32}%{mabi=64: -64}%{!mabi*: -n32}"
  #endif
  
*** gcc/config/pa/pa.c.ori	Wed Jul 18 22:33:44 2007
--- gcc/config/pa/pa.c	Wed Jul 18 22:33:54 2007
*************** pa_output_function_prologue (FILE *file,
*** 3537,3549 ****
    /* The function's label and associated .PROC must never be
       separated and must be output *after* any profiling declarations
       to avoid changing spaces/subspaces within a procedure.  */
!   ASM_OUTPUT_LABEL (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));
    fputs ("\t.PROC\n", file);
  
    /* hppa_expand_prologue does the dirty work now.  We just need
       to output the assembler directives which denote the start
       of a function.  */
    fprintf (file, "\t.CALLINFO FRAME=" HOST_WIDE_INT_PRINT_DEC, actual_fsize);
    if (regs_ever_live[2])
      fputs (",CALLS,SAVE_RP", file);
    else
--- 3537,3581 ----
    /* The function's label and associated .PROC must never be
       separated and must be output *after* any profiling declarations
       to avoid changing spaces/subspaces within a procedure.  */
!   ASM_OUTPUT_LABEL
!     (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));
    fputs ("\t.PROC\n", file);
  
    /* hppa_expand_prologue does the dirty work now.  We just need
       to output the assembler directives which denote the start
       of a function.  */
+ 
+   /* Announce the size of the static part of the frame. Note that the value
+      output here is not in accordance with the HP convention, but the delta
+      is compensated by GAS.  */  
    fprintf (file, "\t.CALLINFO FRAME=" HOST_WIDE_INT_PRINT_DEC, actual_fsize);
+ 
+   /* If dynamic stack allocation occurs within the function, say so.  */
+   if (current_function_calls_alloca) 
+     {
+       fprintf (file, ",ALLOCA_FRAME,LARGE_FRAME");
+       
+       /* LARGE_FRAME is actually not a valid argument since the corresponding
+ 	 unwind entry bit is supposed to be computed by the assembler based
+ 	 upon the actual size of the static part of the frame. GAS does not
+ 	 honor this, however, and due to variations between HP and GCC frame
+ 	 layout conventions, standard calls to the HP unwinding library for
+ 	 backtracing purposes badly fail upon alloca frames if nothing is
+ 	 done. 
+ 
+ 	 We can fake the unwinder about the value of the frame pointer but its
+ 	 easier to do this when the value of r4 is used, which is the case
+ 	 when the LARGE_FRAME bit is set. To be able to always do this, a
+ 	 patch to GAS makes it support the LARGE_FRAME argument and we always
+ 	 ask for this bit to be set when dynamic stack allocation occurs.
+ 
+ 	 Another solution to this issue would be to announce 0 for the size of
+          the static part of the frame, but this badly confuses GDB in a way
+          currently not easily recoverable.  */
+     }
+ 
+   /* If this functions calls other functions say so. RP is always saved at
+      the conventional place in such cases, so announce it.  */
    if (regs_ever_live[2])
      fputs (",CALLS,SAVE_RP", file);
    else
*************** pa_output_function_prologue (FILE *file,
*** 3572,3579 ****
    if (gr_saved)
      fprintf (file, ",ENTRY_GR=%d", gr_saved + 2);
  
!   if (fr_saved)
!     fprintf (file, ",ENTRY_FR=%d", fr_saved + 11);
  
    fputs ("\n\t.ENTRY\n", file);
  
--- 3604,3617 ----
    if (gr_saved)
      fprintf (file, ",ENTRY_GR=%d", gr_saved + 2);
  
!   /* Don't tell about the floating point registers because this would make the
!      backtrace unwinder look for r3 at the wrong place (that is, not where GCC
!      has put it). Might confuse GDB in some cases, but this effect is much
!      less an issue than the mess we get with backtraces otherwise.
! 
!      The right solution would be to fix the frame layout to synchronize with
!      the HP convention. This is desireable but requires a very significant 
!      additional amount of work.  */
  
    fputs ("\n\t.ENTRY\n", file);
  
*** gcc/config/pa/pa.h.ori	Wed Jul 18 22:33:44 2007
--- gcc/config/pa/pa.h	Wed Jul 18 22:33:54 2007
*************** typedef struct machine_function GTY(())
*** 359,367 ****
  /* Base register for access to local variables of the function.  */
  #define FRAME_POINTER_REGNUM 3
  
! /* Value should be nonzero if functions must have frame pointers.  */
! #define FRAME_POINTER_REQUIRED \
!   (current_function_calls_alloca)
  
  /* Don't allow hard registers to be renamed into r2 unless r2
     is already live or already being saved (due to eh).  */
--- 359,370 ----
  /* Base register for access to local variables of the function.  */
  #define FRAME_POINTER_REGNUM 3
  
! /* Value should be nonzero if functions must have frame pointers.
! 
!    ??? Currently forced to 1 to ease backtrace computations using the hpux
!    unwinding library, only device able to backtrace through non GCC code
!    properly.  */
! #define FRAME_POINTER_REQUIRED 1
  
  /* Don't allow hard registers to be renamed into r2 unless r2
     is already live or already being saved (due to eh).  */
*** gcc/mips-tfile.c.ori	2007-07-26 08:48:35.648675000 -0400
--- gcc/mips-tfile.c	2007-07-26 09:00:01.846803000 -0400
*************** add_procedure (const char *func_start,  
*** 2352,2366 ****
  STATIC void
  initialize_init_file (void)
  {
    memset (&init_file, 0, sizeof (init_file));
  
    init_file.fdr.lang = langC;
    init_file.fdr.fMerge = 1;
    init_file.fdr.glevel = GLEVEL_2;
  
! #ifdef WORDS_BIG_ENDIAN
!   init_file.fdr.fBigendian = 1;
! #endif
  
    INITIALIZE_VARRAY (&init_file.strings, char);
    INITIALIZE_VARRAY (&init_file.symbols, SYMR);
--- 2352,2379 ----
  STATIC void
  initialize_init_file (void)
  {
+   union {
+     unsigned char c[4];
+     int i;
+   } endian_test;
+ 
    memset (&init_file, 0, sizeof (init_file));
  
    init_file.fdr.lang = langC;
    init_file.fdr.fMerge = 1;
    init_file.fdr.glevel = GLEVEL_2;
  
!   /* mips-tfile doesn't attempt to perform byte swapping and always writes
!      out integers in its native ordering.  For cross-compilers, this need
!      not be the same as either the host or the target.  The simplest thing
!      to do is skip the configury and perform an introspective test.  */
!   /* ??? Despite the name, mips-tfile is currently only used on alpha/Tru64
!      and would/may require significant work to be used in cross-compiler
!      configurations, so we could simply admit defeat and hard code this as
!      little-endian, i.e. init_file.fdr.fBigendian = 0.  */
!   endian_test.i = 1;
!   if (endian_test.c[3])
!     init_file.fdr.fBigendian = 1;
  
    INITIALIZE_VARRAY (&init_file.strings, char);
    INITIALIZE_VARRAY (&init_file.symbols, SYMR);
*** gcc/config/alpha/osf5-unwind.h.ori	2007-07-27 05:45:15.058600000 -0400
--- gcc/config/alpha/osf5-unwind.h	2007-07-27 05:43:17.697480000 -0400
*************** Boston, MA 02110-1301, USA.  */
*** 195,246 ****
  
     --
  
-    Despite the apparent simplicity of the rules above, a trick is played to
-    deal with the kernel frame "return address", because what we typically get
-    in a signal context is not really a return address but some of functions in
-    the general unwinder think it is.
- 
-    The basic issue is that...
- 
-    o The generic unwinding engine is expecting to deal with a call return
-      address, because that is the nominal case. It is however actually
-      interested in what region the call itself pertains to, so it substracts 1
-      to the frame_state's "return address" and uses that to search the unwind
-      table (see e.g. uw_frame_state_for).
-    
-    o The address we get for a signal context is not a return address but the
-      address of a faulting instruction, which we want to use *untouched* to
-      search the tables.
- 
-    o There is currently no provision in the generic unwinder to allow
-      differentiating the two cases.
- 
-    What we do here is we cheat by adjusting the faulting address *value* by 1
-    at the place where it is saved in the sigcontext structure to compensate.
-    Note that we must account for the fact that we may be called more than once
-    for the same context and ensure the adjustment remains constant. We exploit
-    the fact that instruction address are normally always multiple of 4 here,
-    and only adjust if it (still) the case.
- 
-    Something that needs to be taken into account is that floating point traps
-    are imprecise in the Alpha architecture.  Hence, software assistance
-    is needed for determining the exact location that caused the floating point
-    trap, so that the return address that is stored in the sigcontext structure
-    is *exactly* the faulting address.  It can be achieved by using the
-    "-mtrap-precision=i" GCC command option, so that the trap handler can
-    determine the exact instruction that caused the floating point exception,
-    and then the unwinding mechanism works appropriately.  Not specifying this
-    command option results in the unwinder not using the address of the
-    instruction that triggered the trap but the one where the trap was
-    delivered, that can be placed an arbitrary number of instructions after the
-    trigger instruction, so that we may indeed unwind to the wrong place. Note
-    that, in the case of programs that may cause floating point exceptions, it
-    could be more efficient to use the "-mieee" GCC command option so that
-    the generated code is able to correctly support denormalized numbers and
-    exceptional IEEE values without generating traps.
- 
-    --
- 
     Also, note that there is an important difference between the return address
     we need to claim for the kernel frame and the value of the return address
     register at the interruption point.
--- 195,200 ----
*************** alpha_fallback_frame_state (struct _Unwi
*** 391,403 ****
    fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset
      = (void *) &sigctx->sc_pc - (void *) k_cfa;
  
-   /* Trick its value to compensate for later adjustments from the generic
-      unwinding circuitry, which thinks it is a real return address. We
-      may be called more than once for the same context, so take care not
-      to perform the adjustment multiple times. We exploit the fact that
-      instruction addresses are normally always multiple of 4 here.  */
-   if ((sigctx->sc_pc & 0x3) == 0)
-     sigctx->sc_pc +=1;
- 
    return _URC_NO_REASON;
  }
--- 345,349 ----
*** gcc/config/alpha/alpha.md.0	2007-09-03 12:28:03.860628000 -0400
--- gcc/config/alpha/alpha.md	2007-09-03 12:48:17.225843000 -0400
***************
*** 5707,5714 ****
        else
  	target = operands[0];
  
!       emit_insn (gen_movdi (gen_rtx_SUBREG (DImode, target, 0), out[0]));
!       emit_insn (gen_movdi (gen_rtx_SUBREG (DImode, target, 8), out[1]));
  
        if (target != operands[0])
  	emit_insn (gen_rtx_SET (VOIDmode, operands[0], target));
--- 5707,5714 ----
        else
  	target = operands[0];
  
!       emit_insn (gen_movdi (operand_subword (target, 0, 0, TImode), out[0]));
!       emit_insn (gen_movdi (operand_subword (target, 1, 0, TImode), out[1]));
  
        if (target != operands[0])
  	emit_insn (gen_rtx_SET (VOIDmode, operands[0], target));
*** gcc/config/mips/iris6.h.ori	Tue Sep  4 10:22:43 2007
--- gcc/config/mips/iris6.h	Tue Sep  4 10:23:14 2007
*************** Boston, MA 02110-1301, USA.  */
*** 51,57 ****
    "%{mabi=32: -melf32bsmip}%{mabi=n32: -melf32bmipn32}%{mabi=64: -melf64bmip}"
  #else
  #define IRIX_SUBTARGET_LINK_SPEC \
!   "%{w} -_SYSTYPE_SVR4 -woff 131 \
     %{shared:-hidden_symbol __gcc_init,__gcc_fini,__dso_handle} \
     %{mabi=32: -32}%{mabi=n32: -n32}%{mabi=64: -64}%{!mabi*: -n32}"
  #endif
--- 51,57 ----
    "%{mabi=32: -melf32bsmip}%{mabi=n32: -melf32bmipn32}%{mabi=64: -melf64bmip}"
  #else
  #define IRIX_SUBTARGET_LINK_SPEC \
!   "%{w} -_SYSTYPE_SVR4 -w \
     %{shared:-hidden_symbol __gcc_init,__gcc_fini,__dso_handle} \
     %{mabi=32: -32}%{mabi=n32: -n32}%{mabi=64: -64}%{!mabi*: -n32}"
  #endif
*** gcc/config/mips/mips.h.ori	Tue Sep  4 11:28:03 2007
--- gcc/config/mips/mips.h	Tue Sep  4 11:31:04 2007
*************** extern const struct mips_rtx_cost_data *
*** 981,986 ****
--- 981,987 ----
  
  /* For MIPS, width of a floating point register.  */
  #define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)
+ #define WIDEST_HARDWARE_FP_SIZE 64
  
  /* If register $f0 holds a floating-point value, $f(0 + FP_INC) is
     the next available register.  */
*** gcc/config/mips/iris6-unwind.h.ori	Tue Sep  4 06:11:10 2007
--- gcc/config/mips/iris6-unwind.h	Tue Sep  4 06:11:14 2007
*************** Boston, MA 02110-1301, USA.  */
*** 40,71 ****
     if it does match, or 0 otherwise.  */
  
  static sigcontext_t *
! sigcontext_for (void *ra, void *cfa)
  {
!   /* IRIX 6.5, mono-threaded application.  */
!   if (UINT_AT (ra - 40) == 0x00e0c825
!       && UINT_AT (ra - 36) == 0x658cd38c
!       && UINT_AT (ra - 32) == 0x019f602d
!       && UINT_AT (ra - 28) == 0x0300f825
!       && UINT_AT (ra - 24) == 0x8d8c9744
!       && UINT_AT (ra - 20) == 0x8d8c0000
!       && UINT_AT (ra - 16) == 0x8d8d0000
!       && UINT_AT (ra - 12) == 0xffac0008
!       && UINT_AT (ra - 8)  == 0x0320f809
!       && UINT_AT (ra - 4)  == 0xffad0010)
      return (sigcontext_t *)(cfa + 0x30);
  
!   /* IRIX 6.5, multi-threaded application, pthreads.  */
!   if (UINT_AT (ra - 40) == 0xffb00000
!       && UINT_AT (ra - 36) == 0x0004f880
!       && UINT_AT (ra - 32) == 0x27399058
!       && UINT_AT (ra - 28) == 0x8c300edc
!       && UINT_AT (ra - 24) == 0x033fc821
!       && UINT_AT (ra - 20) == 0x8f390000
!       && UINT_AT (ra - 16) == 0xdc210e70
!       && UINT_AT (ra - 12) == 0xde120058
!       && UINT_AT (ra - 8)  == 0x0320f809
!       && UINT_AT (ra - 4)  == 0xfe010058)
      return (sigcontext_t *)(cfa + 0x60);
  
    return 0;
--- 40,66 ----
     if it does match, or 0 otherwise.  */
  
  static sigcontext_t *
! sigcontext_for (void * ra, void * cfa)
  {
!   /* IRIX 6.5, mono-threaded application.  We're lucky enough to be able
!      to expect a short very sighandler specific sequence around.  */
!   if (UINT_AT (ra + 24) == 0x24020440      /* li v0,1088 (SYS_sigreturn) */
!       && UINT_AT (ra + 28) == 0x0000000c)  /* syscall */
      return (sigcontext_t *)(cfa + 0x30);
  
!   /* IRIX 6.5 variants, multi-threaded application, pthreads.  Nothing really
!      sighandler specific handy, so match a fairly long constant sequence.  */
!   if (UINT_AT (ra - 40) == 0xffb00000          /* sd      s0,0(sp)     */
!       && UINT_AT (ra - 36) == 0x0004f880       /* sll     ra,a0,0x2    */
!       && (UINT_AT (ra - 32) == 0x27399058      /* addiu   t9,t9,-28584 */
! 	  || UINT_AT (ra - 32) == 0x273990d8)  /* addiu   t9,t9,-28456 */
!       && UINT_AT (ra - 28) == 0x8c300edc       /* lw      s0,3804(at)  */
!       && UINT_AT (ra - 24) == 0x033fc821       /* addu    t9,t9,ra     */
!       && UINT_AT (ra - 20) == 0x8f390000       /* lw      t9,0(t9)     */
!       && UINT_AT (ra - 16) == 0xdc210e70       /* ld      at,3696(at)  */
!       && UINT_AT (ra - 12) == 0xde120058       /* ld      s2,88(s0)    */
!       && UINT_AT (ra - 8)  == 0x0320f809       /* jalr    t9           */
!       && UINT_AT (ra - 4)  == 0xfe010058)      /* sd      at,88(s0)    */
      return (sigcontext_t *)(cfa + 0x60);
  
    return 0;
*** gcc/profile.c~	2006-10-19 03:08:33.000000000 +0200
--- gcc/profile.c	2007-09-04 16:16:01.587828352 +0200
*************** branch_prob (void)
*** 1075,1080 ****
--- 1075,1088 ----
  		    output_location (EXPR_FILENAME (stmt), 
  				     EXPR_LINENO (stmt),
  				     &offset, bb);
+ 		  if (TREE_CODE (stmt) == MODIFY_EXPR)
+ 		    {
+ 		      tree op = TREE_OPERAND (stmt, 1);
+ 		      if (EXPR_HAS_LOCATION (op))
+ 			output_location (EXPR_FILENAME (op), 
+ 					 EXPR_LINENO (op),
+ 					 &offset, bb);
+ 		    }
  		}
  
  	      /* Notice GOTO expressions we eliminated while constructing the
*** gcc/reload.c.0	2007-09-06 21:50:45.996621600 +0200
--- gcc/reload.c	2007-09-06 21:58:26.203659496 +0200
*************** find_reloads_address_part (rtx x, rtx *l
*** 5894,5903 ****
        && (! LEGITIMATE_CONSTANT_P (x)
  	  || PREFERRED_RELOAD_CLASS (x, class) == NO_REGS))
      {
!       rtx tem;
! 
!       tem = x = force_const_mem (mode, x);
!       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),
  			    opnum, type, ind_levels, 0);
      }
  
--- 5894,5901 ----
        && (! LEGITIMATE_CONSTANT_P (x)
  	  || PREFERRED_RELOAD_CLASS (x, class) == NO_REGS))
      {
!       x = force_const_mem (mode, x);
!       find_reloads_address (mode, &x, XEXP (x, 0), &XEXP (x, 0),
  			    opnum, type, ind_levels, 0);
      }
  
*************** find_reloads_address_part (rtx x, rtx *l
*** 5910,5916 ****
  
        tem = force_const_mem (GET_MODE (x), XEXP (x, 1));
        x = gen_rtx_PLUS (GET_MODE (x), XEXP (x, 0), tem);
!       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),
  			    opnum, type, ind_levels, 0);
      }
  
--- 5908,5914 ----
  
        tem = force_const_mem (GET_MODE (x), XEXP (x, 1));
        x = gen_rtx_PLUS (GET_MODE (x), XEXP (x, 0), tem);
!       find_reloads_address (mode, &XEXP (x, 1), XEXP (tem, 0), &XEXP (tem, 0),
  			    opnum, type, ind_levels, 0);
      }
  
*** gcc/dbxout.c.0	2007-09-07 20:43:33.749424432 +0200
--- gcc/dbxout.c	2007-09-07 20:44:18.709589448 +0200
*************** dbxout_symbol_location (tree decl, tree 
*** 2928,2934 ****
  	 cases we're forced to lie to debuggers and tell them that
  	 this variable was itself `static'.  */
        code = N_LCSYM;
!       letter = 'V';
        addr = XEXP (XEXP (home, 0), 0);
      }
    else if (GET_CODE (home) == CONCAT)
--- 2928,2934 ----
  	 cases we're forced to lie to debuggers and tell them that
  	 this variable was itself `static'.  */
        code = N_LCSYM;
!       letter = decl_function_context (decl) ? 'V' : 'S';
        addr = XEXP (XEXP (home, 0), 0);
      }
    else if (GET_CODE (home) == CONCAT)
*************** dbxout_symbol_location (tree decl, tree 
*** 2967,2973 ****
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
    dbxout_begin_complex_stabs_noforcetext ();
--- 2967,2976 ----
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   /* A null address denotes a pure debug entity associated
!      with no real symbol so keep using the current block.  */
!   if (addr != const0_rtx)
!     DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
    dbxout_begin_complex_stabs_noforcetext ();
*************** dbxout_symbol_location (tree decl, tree 
*** 2976,2982 ****
    dbxout_finish_complex_stabs (decl, code, addr, 0, number);
  
  #ifdef DBX_STATIC_BLOCK_END
!   DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
  }
--- 2979,2987 ----
    dbxout_finish_complex_stabs (decl, code, addr, 0, number);
  
  #ifdef DBX_STATIC_BLOCK_END
!   /* See comment just above.  */
!   if (addr != const0_rtx)
!     DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
  }
*** gcc/unwind-generic.h.0	2007-09-08 10:23:16.517417296 +0200
--- gcc/unwind-generic.h	2007-09-08 10:46:07.363017088 +0200
*************** extern _Unwind_Ptr _Unwind_GetTextRelBas
*** 229,234 ****
--- 229,238 ----
     contains it.  */
  extern void * _Unwind_FindEnclosingFunction (void *pc);
  
+ /* This is for source compatibility with GCC 4.3 and later.  */
+ #define _uleb128_t  _Unwind_Word
+ #define _sleb128_t  _Unwind_Sword
+ 
  #ifdef __cplusplus
  }
  #endif
*** gcc/config/mips/iris.h.ori	Mon Sep 10 04:06:32 2007
--- gcc/config/mips/iris.h	Mon Sep 10 04:41:54 2007
*************** Boston, MA 02110-1301, USA.  */
*** 23,28 ****
--- 23,32 ----
  #undef TARGET_IRIX
  #define TARGET_IRIX 1
  
+ /* We're still using gdb 5.3 on irix targets, so ...  */
+ #undef  DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET
+ #define DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET 1
+ 
  /* The size in bytes of a DWARF field indicating an offset or length
     relative to a debug info section, specified to be 4 bytes in the DWARF-2
     specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */
*** gcc/dbxout.c.ori	2007-09-14 03:53:46.630015000 -0400
--- gcc/dbxout.c	2007-09-14 05:26:01.439935000 -0400
*************** Software Foundation, 51 Franklin Street,
*** 162,167 ****
--- 162,182 ----
  #define DBX_CONTIN_CHAR '\\'
  #endif
  
+ /* dbxout_symbol_location needs to know if it should prevent
+    STATIC_BLOCK_STARTs and ENDs for static debug-only symbols, which
+    is very target specific.
+ 
+    AIX features a smart garbage collecting linker which would leave
+    the debug-only symbols out if they were in a block of their own,
+    and a tolerant enough assembler not to barf on what we emit in
+    these cases.  */
+ 
+ #ifndef TARGET_AIX
+ #define TARGET_AIX 0
+ #endif
+ 
+ #define PREVENT_STATIC_DEBUG_ONLY_BLOCKS TARGET_AIX
+ 
  enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};
  
  /* Structure recording information about a C data type.
*************** dbxout_symbol_location (tree decl, tree 
*** 2967,2975 ****
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   /* A null address denotes a pure debug entity associated
!      with no real symbol so keep using the current block.  */
!   if (addr != const0_rtx)
      DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
--- 2982,2991 ----
    FORCE_TEXT;
  
  #ifdef DBX_STATIC_BLOCK_START
!   /* A null address denotes a pure debug entity associated with no
!      real symbol, for which we might want to prevent a static block
!      creation.  */
!   if (addr != const0_rtx || ! PREVENT_STATIC_DEBUG_ONLY_BLOCKS)
      DBX_STATIC_BLOCK_START (asm_out_file, code);
  #endif
  
*************** dbxout_symbol_location (tree decl, tree 
*** 2980,2986 ****
  
  #ifdef DBX_STATIC_BLOCK_END
    /* See comment just above.  */
!   if (addr != const0_rtx)
      DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
--- 2996,3002 ----
  
  #ifdef DBX_STATIC_BLOCK_END
    /* See comment just above.  */
!   if (addr != const0_rtx || ! PREVENT_STATIC_DEBUG_ONLY_BLOCKS)
      DBX_STATIC_BLOCK_END (asm_out_file, code);
  #endif
    return 1;
*** gcc/config.gcc.ori	2007-09-13 10:26:32.950015000 -0400
--- gcc/config.gcc	2007-09-14 04:38:34.650015000 -0400
*************** powerpc-wrs-windiss*)  # Instruction-lev
*** 1799,1804 ****
--- 1799,1813 ----
  	thread_file=""
  	use_fixproto=yes
  	;;
+ powerpc-xcoff-lynxos*)
+ 	tm_file="${tm_file} rs6000/lynx.h lynx.h"
+ 	tm_file="${tm_file} rs6000/xcoff.h rs6000/lynx-xcoff.h"
+ 	tmake_file="rs6000/t-fprules"
+ 	extra_options="${extra_options} lynx.opt rs6000/lynx-xcoff.opt"
+ 	thread_file=lynx
+ 	gnu_ld=yes
+ 	gas=yes
+ 	;;
  powerpc-*-lynxos*)
  	xm_defines=POSIX
  	tm_file="${tm_file} dbxelf.h elfos.h rs6000/sysv4.h rs6000/lynx.h lynx.h"
*** gcc/config/rs6000/rs6000.h.ori	2007-09-13 10:26:32.780015000 -0400
--- gcc/config/rs6000/rs6000.h	2007-09-13 10:27:48.010015000 -0400
***************
*** 41,46 ****
--- 41,50 ----
  #define TARGET_AIX 0
  #endif
  
+ #ifndef TARGET_LYNXOS
+ #define TARGET_LYNXOS 0
+ #endif
+ 
  /* Control whether function entry points use a "dot" symbol when
     ABI_AIX.  */
  #define DOT_SYMBOLS 1
*** gcc/config/lynx.h.ori	2007-09-13 10:26:32.810015000 -0400
--- gcc/config/lynx.h	2007-09-13 10:27:48.030015000 -0400
*************** Boston, MA 02110-1301, USA.  */
*** 26,31 ****
--- 26,34 ----
     them here we might accidentally disable some target-specific
     defines.  */
  
+ #undef  TARGET_LYNXOS
+ #define TARGET_LYNXOS 1
+ 
  #ifndef EXTRA_OS_LYNX_TARGET_SPECS
  # define EXTRA_OS_LYNX_TARGET_SPECS
  #endif
*** gcc/config/rs6000/lynx-xcoff.h.ori	2007-09-13 10:29:50.351839000 -0400
--- gcc/config/rs6000/lynx-xcoff.h	2007-09-13 10:27:47.950015000 -0400
***************
*** 0 ****
--- 1,64 ----
+ /* Target independent definitions for LynxOS XCOFF on PowerPC.
+    Copyright (C) 1993, 1994, 1995, 1996, 1999, 2000, 2002, 2003, 2004
+    Free Software Foundation, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+ 
+ /* Use the AIX ABI and borrow other bits of the AIX configuration.  */
+ 
+ #define DEFAULT_ABI ABI_AIX
+ 
+ #define TARGET_NO_TOC 0
+ #define TARGET_TOC 1
+ 
+ #define FIXED_R2 1
+ #define FIXED_R13 0
+ 
+ #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)
+ 
+ /* Then override generic settings according to the lynx-xcoff
+    specificities.  */
+ 
+ #undef  STARTFILE_SPEC
+ #define STARTFILE_SPEC \
+   "%{p:%{pg:%e-p and -pg options are incompatible}}\
+    %{p:pinit1.o%s} %{pg:gpinit1.o%s}\
+    %{!p:%{!pg:init1.o%s}}"
+ 
+ #undef  ENDFILE_SPEC
+ 
+ #undef  LINK_SPEC
+ #define LINK_SPEC "-T0x10001000 -D0x20000000"
+ 
+ #undef  DEFAULT_SIGNED_CHAR
+ #define DEFAULT_SIGNED_CHAR 1
+ 
+ #undef  RS6000_DEFAULT_LONG_DOUBLE_SIZE
+ #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 64
+ 
+ #undef  PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG
+ 
+ #undef  TARGET_DEFAULT
+ #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)
+ 
+ #undef  USER_LABEL_PREFIX
+ #define USER_LABEL_PREFIX ""
+ 
+ #undef  FUNCTION_PROFILER
+ #define FUNCTION_PROFILER(file, profile_label_no)
*** gcc/config/rs6000/lynx-xcoff.opt.ori	2007-09-13 10:29:52.756879000 -0400
--- gcc/config/rs6000/lynx-xcoff.opt	2007-09-13 10:27:47.980015000 -0400
***************
*** 0 ****
--- 1,28 ----
+ ; Lynx/XCOFF options for PPC port.
+ ;
+ ; Copyright (C) 2007 Free Software Foundation, Inc.
+ ;
+ ; This file is part of GCC.
+ ;
+ ; GCC is free software; you can redistribute it and/or modify it under
+ ; the terms of the GNU General Public License as published by the Free
+ ; Software Foundation; either version 2, or (at your option) any later
+ ; version.
+ ;
+ ; GCC is distributed in the hope that it will be useful, but WITHOUT
+ ; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ ; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+ ; License for more details.
+ ;
+ ; You should have received a copy of the GNU General Public License
+ ; along with GCC; see the file COPYING.  If not, write to the Free
+ ; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+ ; 02110-1301, USA.
+ 
+ m64
+ Target Report RejectNegative Mask(64BIT)
+ Generate 64-bit code
+ 
+ m32
+ Target Report RejectNegative InverseMask(64BIT)
+ Generate 32-bit code
*** gcc/config/rs6000/rs6000.c.ori	2007-09-13 10:26:32.750015000 -0400
--- gcc/config/rs6000/rs6000.c	2007-09-13 10:27:47.940015000 -0400
*************** static const char alt_reg_names[][8] =
*** 868,876 ****
  /* Default unaligned ops are only provided for ELF.  Find the ops needed
     for non-ELF systems.  */
  #ifndef OBJECT_FORMAT_ELF
! #if TARGET_XCOFF
! /* For XCOFF.  rs6000_assemble_integer will handle unaligned DIs on
!    64-bit targets.  */
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.vbyte\t2,"
  #undef TARGET_ASM_UNALIGNED_SI_OP
--- 868,878 ----
  /* Default unaligned ops are only provided for ELF.  Find the ops needed
     for non-ELF systems.  */
  #ifndef OBJECT_FORMAT_ELF
! 
! /* For XCOFF, use .vbyte, except on Lynx where the system assembler
!    doesn't support it. rs6000_assemble_integer will handle unaligned
!    DIs on 64-bit targets. .  */
! #if TARGET_XCOFF && !TARGET_LYNXOS
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.vbyte\t2,"
  #undef TARGET_ASM_UNALIGNED_SI_OP
*************** static const char alt_reg_names[][8] =
*** 878,884 ****
  #undef TARGET_ASM_UNALIGNED_DI_OP
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.vbyte\t8,"
  #else
! /* For Darwin.  */
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.short\t"
  #undef TARGET_ASM_UNALIGNED_SI_OP
--- 880,886 ----
  #undef TARGET_ASM_UNALIGNED_DI_OP
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.vbyte\t8,"
  #else
! /* For LynxOS/XCOFF or Darwin.  */
  #undef TARGET_ASM_UNALIGNED_HI_OP
  #define TARGET_ASM_UNALIGNED_HI_OP "\t.short\t"
  #undef TARGET_ASM_UNALIGNED_SI_OP
*************** print_operand_address (FILE *file, rtx x
*** 10935,10941 ****
  #endif
    else if (legitimate_constant_pool_address_p (x))
      {
!       if (TARGET_AIX && (!TARGET_ELF || !TARGET_MINIMAL_TOC))
  	{
  	  rtx contains_minus = XEXP (x, 1);
  	  rtx minus, symref;
--- 10937,10944 ----
  #endif
    else if (legitimate_constant_pool_address_p (x))
      {
!       if ((TARGET_AIX && (!TARGET_ELF || !TARGET_MINIMAL_TOC))
! 	  || (TARGET_LYNXOS && TARGET_XCOFF))
  	{
  	  rtx contains_minus = XEXP (x, 1);
  	  rtx minus, symref;
*************** rs6000_xcoff_file_start (void)
*** 18557,18562 ****
--- 18559,18569 ----
    fputs ("\t.file\t", asm_out_file);
    output_quoted_string (asm_out_file, main_input_filename);
    fputc ('\n', asm_out_file);
+ 
+   /* ??? The xcoff-lynxos assembler mishandles toc-relative references
+      if there is anything before the toc in .data, so open the toc first.  */
+   if (TARGET_LYNXOS)
+     toc_section ();
    if (write_symbols != NO_DEBUG)
      private_data_section ();
    text_section ();
*** gcc/dwarf2out.c.0	2007-09-14 18:21:42.974738392 +0200
--- gcc/dwarf2out.c	2007-09-14 18:25:57.209088896 +0200
*************** subrange_type_die (tree type, dw_die_ref
*** 8346,8352 ****
      context_die = comp_unit_die;
  
    if (TREE_CODE (subtype) == ENUMERAL_TYPE)
!     subtype_die = gen_enumeration_type_die (subtype, context_die);
    else
      subtype_die = base_type_die (subtype);
  
--- 8346,8356 ----
      context_die = comp_unit_die;
  
    if (TREE_CODE (subtype) == ENUMERAL_TYPE)
!     {
!       subtype_die = lookup_type_die (subtype);
!       if (!subtype_die)
! 	subtype_die = gen_enumeration_type_die (subtype, context_die);
!     }
    else
      subtype_die = base_type_die (subtype);
  
*** gcc/alias.c.0	2007-09-15 17:20:31.327026360 +0200
--- gcc/alias.c	2007-09-15 17:20:35.688363336 +0200
*************** fixed_scalar_and_varying_struct_p (rtx m
*** 1912,1924 ****
    if (! flag_strict_aliasing)
      return NULL_RTX;
  
!   if (MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2)
        && !varies_p (mem1_addr, 1) && varies_p (mem2_addr, 1))
      /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a
         varying address.  */
      return mem1;
  
!   if (MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2)
        && varies_p (mem1_addr, 1) && !varies_p (mem2_addr, 1))
      /* MEM2 is a scalar at a fixed address; MEM1 is a struct at a
         varying address.  */
--- 1912,1926 ----
    if (! flag_strict_aliasing)
      return NULL_RTX;
  
!   if (MEM_ALIAS_SET (mem2)
!       && MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2)
        && !varies_p (mem1_addr, 1) && varies_p (mem2_addr, 1))
      /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a
         varying address.  */
      return mem1;
  
!   if (MEM_ALIAS_SET (mem1)
!       && MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2)
        && varies_p (mem1_addr, 1) && !varies_p (mem2_addr, 1))
      /* MEM2 is a scalar at a fixed address; MEM1 is a struct at a
         varying address.  */
*** gcc/dbxout.c.0	2007-09-17 21:44:10.495198848 +0200
--- gcc/dbxout.c	2007-09-17 21:48:13.969185176 +0200
*************** dbxout_parms (tree parms)
*** 3230,3235 ****
--- 3230,3237 ----
  		&& GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))) < UNITS_PER_WORD)
  	      number += (GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))
  			 - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))));
+ 
+ 	    number = DEBUGGER_ARG_OFFSET (number,  XEXP (DECL_RTL (parms), 0));
  	  }
  	else
  	  /* ??? We don't know how to represent this argument.  */
*** gcc/config/mips/t-slibgcc-irix.ori	2007-09-18 05:06:01.669410005 -0400
--- gcc/config/mips/t-slibgcc-irix	2007-09-18 05:33:22.018175992 -0400
*************** SHLIB_MAP = @shlib_map_file@
*** 8,14 ****
  SHLIB_OBJS = @shlib_objs@
  SHLIB_DIR = @multilib_dir@
  SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
! SHLIB_LC = -lc
  
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
  	-Wl,-soname,$(SHLIB_SONAME) \
--- 8,15 ----
  SHLIB_OBJS = @shlib_objs@
  SHLIB_DIR = @multilib_dir@
  SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
! SHLIB_LC = -lc -lm
! # -lm is to satisfy references to copysignl for multc3/divtc3
  
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
  	-Wl,-soname,$(SHLIB_SONAME) \
*** gcc/alias.h.0	2008-05-17 15:58:07.733364464 +0200
--- gcc/alias.h	2008-05-17 15:58:12.674613280 +0200
*************** Software Foundation, 51 Franklin Street,
*** 24,29 ****
--- 24,30 ----
  extern HOST_WIDE_INT new_alias_set (void);
  extern HOST_WIDE_INT get_varargs_alias_set (void);
  extern HOST_WIDE_INT get_frame_alias_set (void);
+ extern void record_alias_subset (HOST_WIDE_INT, HOST_WIDE_INT);
  extern void record_base_value (unsigned int, rtx, int);
  extern bool component_uses_parent_alias_set (tree);
  
*** gcc/alias.c.0	2008-05-17 15:58:07.736364008 +0200
--- gcc/alias.c	2008-05-17 15:58:12.675613128 +0200
*************** static int nonoverlapping_memrefs_p (rtx
*** 169,175 ****
  static int write_dependence_p (rtx, rtx, int);
  
  static void memory_modified_1 (rtx, rtx, void *);
- static void record_alias_subset (HOST_WIDE_INT, HOST_WIDE_INT);
  
  /* Set up all info needed to perform alias analysis on memory references.  */
  
--- 169,174 ----
*************** new_alias_set (void)
*** 663,669 ****
     It is illegal for SUPERSET to be zero; everything is implicitly a
     subset of alias set zero.  */
  
! static void
  record_alias_subset (HOST_WIDE_INT superset, HOST_WIDE_INT subset)
  {
    alias_set_entry superset_entry;
--- 662,668 ----
     It is illegal for SUPERSET to be zero; everything is implicitly a
     subset of alias set zero.  */
  
! void
  record_alias_subset (HOST_WIDE_INT superset, HOST_WIDE_INT subset)
  {
    alias_set_entry superset_entry;
*** gcc/tree-inline.c.0	2008-05-17 15:58:07.738363704 +0200
--- gcc/tree-inline.c	2008-05-17 16:00:43.945616592 +0200
*************** typedef struct inline_data
*** 143,148 ****
--- 143,150 ----
    /* Take region number in the function being copied, add this value and
       get eh region number of the duplicate in the function we inline into.  */
    int eh_region_offset;
+   /* Special alias set whose children are pointed to by ref-all pointers.  */
+   HOST_WIDE_INT ref_all_alias_set;
  } inline_data;
  
  /* Prototypes.  */
*************** remap_type_1 (tree type, inline_data *id
*** 266,287 ****
  {
    tree new, t;
  
!   /* We do need a copy.  build and register it now.  If this is a pointer or
!      reference type, remap the designated type and make a new pointer or
!      reference type.  */
    if (TREE_CODE (type) == POINTER_TYPE)
      {
        new = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					 TYPE_MODE (type),
! 					 TYPE_REF_CAN_ALIAS_ALL (type));
        insert_decl_map (id, type, new);
        return new;
      }
    else if (TREE_CODE (type) == REFERENCE_TYPE)
      {
        new = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					    TYPE_MODE (type),
! 					    TYPE_REF_CAN_ALIAS_ALL (type));
        insert_decl_map (id, type, new);
        return new;
      }
--- 268,305 ----
  {
    tree new, t;
  
!   /* We do need a copy.  Build and register it now.  If this is a pointer
!      or reference type, remap the designated type and make a new pointer
!      or reference type.  Moreover, if the designated type can be pointed
!      to by ref-all pointers, we might be remapping a chain starting from
!      one of them so we need to propagate the property to it.  */
    if (TREE_CODE (type) == POINTER_TYPE)
      {
+       bool can_alias_all = TYPE_REF_CAN_ALIAS_ALL (type);
+       if (!can_alias_all && id->ref_all_alias_set)
+ 	{
+ 	  HOST_WIDE_INT alias_set = get_alias_set (TREE_TYPE (type));
+ 	  if (alias_set
+ 	      && alias_sets_conflict_p (id->ref_all_alias_set, alias_set))
+ 	    can_alias_all = TRUE;
+ 	}
        new = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					 TYPE_MODE (type), can_alias_all);
        insert_decl_map (id, type, new);
        return new;
      }
    else if (TREE_CODE (type) == REFERENCE_TYPE)
      {
+       bool can_alias_all = TYPE_REF_CAN_ALIAS_ALL (type);
+       if (!can_alias_all && id->ref_all_alias_set)
+ 	{
+ 	  HOST_WIDE_INT alias_set = get_alias_set (TREE_TYPE (type));
+ 	  if (alias_set
+ 	      && alias_sets_conflict_p (id->ref_all_alias_set, alias_set))
+ 	    can_alias_all = TRUE;
+ 	}
        new = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),
! 					   TYPE_MODE (type), can_alias_all);
        insert_decl_map (id, type, new);
        return new;
      }
*************** remap_type (tree type, inline_data *id)
*** 381,388 ****
    if (node)
      return (tree) node->value;
  
!   /* The type only needs remapping if it's variably modified.  */
!   if (! variably_modified_type_p (type, id->callee))
      {
        insert_decl_map (id, type, type);
        return type;
--- 399,408 ----
    if (node)
      return (tree) node->value;
  
!   /* The type only needs remapping if we have ref-all pointers and
!      it is a pointer or is variably modified.  */
!   if (!(id->ref_all_alias_set && POINTER_TYPE_P (type))
!       && !variably_modified_type_p (type, id->callee))
      {
        insert_decl_map (id, type, type);
        return type;
*************** setup_one_parameter (inline_data *id, tr
*** 1170,1178 ****
       the argument to the proper type in case it was promoted.  */
    if (value)
      {
-       tree rhs = fold_convert (TREE_TYPE (var), value);
        block_stmt_iterator bsi = bsi_last (bb);
  
        if (rhs == error_mark_node)
  	return;
  
--- 1190,1228 ----
       the argument to the proper type in case it was promoted.  */
    if (value)
      {
        block_stmt_iterator bsi = bsi_last (bb);
+       tree type = TREE_TYPE (var);
+       tree rhs;
+ 
+       /* If the argument is a pointer that can alias everything, we need
+ 	 to propagate the property to the VAR_DECL.  But, at this point,
+ 	 it is too late to have a better granularity than types and we
+ 	 need to propagate the property to all the types that can point
+ 	 to (or within) the object pointed to by the VAR_DECL.  */
+       if (POINTER_TYPE_P (TREE_TYPE (value))
+ 	  && TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (value))
+ 	  && POINTER_TYPE_P (type)
+ 	  && !TYPE_REF_CAN_ALIAS_ALL (type))
+ 	{
+ 	  HOST_WIDE_INT alias_set = get_alias_set (TREE_TYPE (type));
+ 	  if (alias_set)
+ 	    {
+ 	      if (!id->ref_all_alias_set)
+ 		id->ref_all_alias_set = new_alias_set ();
+ 	      record_alias_subset (id->ref_all_alias_set, alias_set);
+ 	      if (TREE_CODE (type) == POINTER_TYPE)
+ 		type = build_pointer_type_for_mode (TREE_TYPE (type),
+ 						    TYPE_MODE (type),
+ 						    true);
+ 	      else
+ 	        type = build_reference_type_for_mode (TREE_TYPE (type),
+ 						      TYPE_MODE (type),
+ 						      true);
+ 	      TREE_TYPE (var) = type;
+ 	    }
+ 	}
  
+       rhs = fold_convert (type, value);
        if (rhs == error_mark_node)
  	return;
  
*************** setup_one_parameter (inline_data *id, tr
*** 1180,1186 ****
  
        /* We want to use MODIFY_EXPR, not INIT_EXPR here so that we
  	 keep our trees in gimple form.  */
!       init_stmt = build (MODIFY_EXPR, TREE_TYPE (var), var, rhs);
  
        /* If we did not create a gimple value and we did not create a gimple
  	 cast of a gimple value, then we will need to gimplify INIT_STMTS
--- 1230,1236 ----
  
        /* We want to use MODIFY_EXPR, not INIT_EXPR here so that we
  	 keep our trees in gimple form.  */
!       init_stmt = build (MODIFY_EXPR, type, var, rhs);
  
        /* If we did not create a gimple value and we did not create a gimple
  	 cast of a gimple value, then we will need to gimplify INIT_STMTS
*** gcc/tree-ssa-dom.c.0	2007-09-24 12:24:32.697039712 +0200
--- gcc/tree-ssa-dom.c	2007-09-24 12:43:03.929106760 +0200
*************** find_equivalent_equality_comparison (tre
*** 1939,1945 ****
        /* Now make sure the RHS of the MODIFY_EXPR is a typecast.  */
        if ((TREE_CODE (def_rhs) == NOP_EXPR
  	   || TREE_CODE (def_rhs) == CONVERT_EXPR)
! 	  && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME)
  	{
  	  tree def_rhs_inner = TREE_OPERAND (def_rhs, 0);
  	  tree def_rhs_inner_type = TREE_TYPE (def_rhs_inner);
--- 1939,1946 ----
        /* Now make sure the RHS of the MODIFY_EXPR is a typecast.  */
        if ((TREE_CODE (def_rhs) == NOP_EXPR
  	   || TREE_CODE (def_rhs) == CONVERT_EXPR)
! 	  && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME
! 	  && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (def_rhs, 0)))
  	{
  	  tree def_rhs_inner = TREE_OPERAND (def_rhs, 0);
  	  tree def_rhs_inner_type = TREE_TYPE (def_rhs_inner);
*** gcc/basic-block.h.old	2005-11-19 19:38:38.000000000 +0100
--- gcc/basic-block.h	2007-09-26 14:36:41.615291468 +0200
*************** DEF_VEC_ALLOC_P(edge,gc);
*** 169,175 ****
  #define EDGE_CROSSING		8192    /* Edge crosses between hot
  					   and cold sections, when we
  					   do partitioning.  */
! #define EDGE_ALL_FLAGS	       16383
  
  #define EDGE_COMPLEX	(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)
  
--- 169,176 ----
  #define EDGE_CROSSING		8192    /* Edge crosses between hot
  					   and cold sections, when we
  					   do partitioning.  */
! #define EDGE_EXPLICIT	       16384    /* Edge must be an explicit jump.  */
! #define EDGE_ALL_FLAGS	       32767
  
  #define EDGE_COMPLEX	(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)
  
*** gcc/cfgcleanup.c.old	2005-11-19 19:38:38.000000000 +0100
--- gcc/cfgcleanup.c	2007-09-26 14:40:02.770627726 +0200
*************** try_forward_edges (int mode, basic_block
*** 433,444 ****
        bool may_thread = first_pass | (b->flags & BB_DIRTY);
  
        /* Skip complex edges because we don't know how to update them.
! 
           Still handle fallthru edges, as we can succeed to forward fallthru
           edge to the same place as the branch edge of conditional branch
           and turn conditional branch to an unconditional branch.  */
!       if (e->flags & EDGE_COMPLEX)
! 	{
  	  ei_next (&ei);
  	  continue;
  	}
--- 433,445 ----
        bool may_thread = first_pass | (b->flags & BB_DIRTY);
  
        /* Skip complex edges because we don't know how to update them.
!          Skip explicit edge as we want to keep them.
!  
           Still handle fallthru edges, as we can succeed to forward fallthru
           edge to the same place as the branch edge of conditional branch
           and turn conditional branch to an unconditional branch.  */
!       if (e->flags & (EDGE_COMPLEX | EDGE_EXPLICIT))
!  	{
  	  ei_next (&ei);
  	  continue;
  	}
*************** try_forward_edges (int mode, basic_block
*** 467,473 ****
  	  may_thread |= target->flags & BB_DIRTY;
  
  	  if (FORWARDER_BLOCK_P (target)
!   	      && !(single_succ_edge (target)->flags & EDGE_CROSSING)
  	      && single_succ (target) != EXIT_BLOCK_PTR)
  	    {
  	      /* Bypass trivial infinite loops.  */
--- 468,475 ----
  	  may_thread |= target->flags & BB_DIRTY;
  
  	  if (FORWARDER_BLOCK_P (target)
! 	      && !(single_succ_edge (target)->flags 
! 		   & (EDGE_CROSSING | EDGE_EXPLICIT))
  	      && single_succ (target) != EXIT_BLOCK_PTR)
  	    {
  	      /* Bypass trivial infinite loops.  */
*************** try_optimize_cfg (int mode)
*** 1922,1928 ****
  
  	      if (single_succ_p (b)
  		  && (s = single_succ_edge (b))
! 		  && !(s->flags & EDGE_COMPLEX)
  		  && (c = s->dest) != EXIT_BLOCK_PTR
  		  && single_pred_p (c)
  		  && b != c)
--- 1924,1930 ----
  
  	      if (single_succ_p (b)
  		  && (s = single_succ_edge (b))
! 		  && !(s->flags & (EDGE_COMPLEX | EDGE_EXPLICIT))
  		  && (c = s->dest) != EXIT_BLOCK_PTR
  		  && single_pred_p (c)
  		  && b != c)
*** gcc/cfghooks.c.old	2005-11-19 19:38:35.000000000 +0100
--- gcc/cfghooks.c	2007-09-26 14:29:45.932716180 +0200
*************** tidy_fallthru_edges (void)
*** 659,665 ****
        if (single_succ_p (b))
  	{
  	  s = single_succ_edge (b);
! 	  if (! (s->flags & EDGE_COMPLEX)
  	      && s->dest == c
  	      && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))
  	    tidy_fallthru_edge (s);
--- 659,665 ----
        if (single_succ_p (b))
  	{
  	  s = single_succ_edge (b);
! 	  if (! (s->flags & (EDGE_COMPLEX | EDGE_EXPLICIT))
  	      && s->dest == c
  	      && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))
  	    tidy_fallthru_edge (s);
*** gcc/cfgrtl.c.old	2007-09-26 14:31:58.488994118 +0200
--- gcc/cfgrtl.c	2007-09-26 14:39:30.730891646 +0200
*************** try_redirect_by_replacing_jump (edge e, 
*** 696,701 ****
--- 696,706 ----
        || BB_PARTITION (src) != BB_PARTITION (target))
      return NULL;
  
+   /* We don't want to remove an explicit jump otherwise its location will
+      be lost.  */
+   if (e->flags & EDGE_EXPLICIT)
+     return NULL;
+ 
    /* We can replace or remove a complex jump only when we have exactly
       two edges.  Also, if we have exactly one outgoing edge, we can
       redirect that.  */
*************** rtl_verify_flow_info_1 (void)
*** 2006,2011 ****
--- 2011,2017 ----
  			    | EDGE_CAN_FALLTHRU
  			    | EDGE_IRREDUCIBLE_LOOP
  			    | EDGE_LOOP_EXIT
+ 			    | EDGE_EXPLICIT
  			    | EDGE_CROSSING)) == 0)
  	    n_branch++;
  
*** gcc/c-typeck.c.old	2006-10-26 03:08:01.000000000 +0200
--- gcc/c-typeck.c	2007-09-26 14:33:22.478461290 +0200
*************** build_asm_expr (tree string, tree output
*** 6758,6763 ****
--- 6758,6764 ----
  tree
  c_finish_goto_label (tree label)
  {
+   tree stmt;
    tree decl = lookup_label (label);
    if (!decl)
      return NULL_TREE;
*************** c_finish_goto_label (tree label)
*** 6798,6804 ****
      }
  
    TREE_USED (decl) = 1;
!   return add_stmt (build1 (GOTO_EXPR, void_type_node, decl));
  }
  
  /* Generate a computed goto statement to EXPR.  */
--- 6799,6808 ----
      }
  
    TREE_USED (decl) = 1;
!   stmt = build1 (GOTO_EXPR, void_type_node, decl);
!   if (!optimize)
!     GOTO_EXPLICIT_P (stmt) = 1;
!   return add_stmt (stmt);
  }
  
  /* Generate a computed goto statement to EXPR.  */
*************** c_finish_goto_label (tree label)
*** 6806,6815 ****
  tree
  c_finish_goto_ptr (tree expr)
  {
    if (pedantic)
      pedwarn ("ISO C forbids %<goto *expr;%>");
    expr = convert (ptr_type_node, expr);
!   return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));
  }
  
  /* Generate a C `return' statement.  RETVAL is the expression for what
--- 6810,6824 ----
  tree
  c_finish_goto_ptr (tree expr)
  {
+   tree stmt;
+ 
    if (pedantic)
      pedwarn ("ISO C forbids %<goto *expr;%>");
    expr = convert (ptr_type_node, expr);
!   stmt = build1 (GOTO_EXPR, void_type_node, expr);
!   if (!optimize)
!     GOTO_EXPLICIT_P (stmt) = 1;
!   return add_stmt (stmt);
  }
  
  /* Generate a C `return' statement.  RETVAL is the expression for what
*************** tree
*** 7234,7239 ****
--- 7243,7249 ----
  c_finish_bc_stmt (tree *label_p, bool is_break)
  {
    bool skip;
+   tree stmt;
    tree label = *label_p;
  
    /* In switch statements break is sometimes stylistically used after
*************** c_finish_bc_stmt (tree *label_p, bool is
*** 7262,7268 ****
    if (skip)
      return NULL_TREE;
  
!   return add_stmt (build1 (GOTO_EXPR, void_type_node, label));
  }
  
  /* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */
--- 7272,7281 ----
    if (skip)
      return NULL_TREE;
  
!   stmt = build1 (GOTO_EXPR, void_type_node, label);
!   if (!optimize)
!     GOTO_EXPLICIT_P (stmt) = 1;
!   return add_stmt (stmt);
  }
  
  /* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */
*** gcc/gimple-low.c.old	2007-09-26 14:31:59.027075160 +0200
--- gcc/gimple-low.c	2007-09-26 14:29:45.854591969 +0200
*************** lower_cond_expr (tree_stmt_iterator *tsi
*** 447,456 ****
    lower_stmt_body (else_branch, data);
  
    then_goto = expr_only (then_branch);
!   then_is_goto = then_goto && simple_goto_p (then_goto);
  
    else_goto = expr_only (else_branch);
!   else_is_goto = else_goto && simple_goto_p (else_goto);
  
    if (!then_is_goto || !else_is_goto)
      {
--- 447,456 ----
    lower_stmt_body (else_branch, data);
  
    then_goto = expr_only (then_branch);
!   then_is_goto = then_goto && simple_implicit_goto_p (then_goto);
  
    else_goto = expr_only (else_branch);
!   else_is_goto = else_goto && simple_implicit_goto_p (else_goto);
  
    if (!then_is_goto || !else_is_goto)
      {
*** gcc/tree-cfg.c.old	2007-09-26 14:31:59.411837283 +0200
--- gcc/tree-cfg.c	2007-09-26 14:33:41.300554183 +0200
*************** make_goto_expr_edges (basic_block bb)
*** 841,847 ****
    if (simple_goto_p (goto_t))
      {
        tree dest = GOTO_DESTINATION (goto_t);
!       edge e = make_edge (bb, label_to_block (dest), EDGE_FALLTHRU);
  #ifdef USE_MAPPED_LOCATION
        e->goto_locus = EXPR_LOCATION (goto_t);
  #else
--- 841,855 ----
    if (simple_goto_p (goto_t))
      {
        tree dest = GOTO_DESTINATION (goto_t);
!       int flags = EDGE_FALLTHRU;
!       edge e;
! 
!       /* Marking an edge explicit prevent some optimizations (forwarding),
! 	 so do it only if not optimizing.  */
!       if (GOTO_EXPLICIT_P (goto_t))
! 	flags |= EDGE_EXPLICIT;
! 
!       e = make_edge (bb, label_to_block (dest), flags);
  #ifdef USE_MAPPED_LOCATION
        e->goto_locus = EXPR_LOCATION (goto_t);
  #else
*************** tree_can_merge_blocks_p (basic_block a, 
*** 1142,1148 ****
    if (!single_succ_p (a))
      return false;
  
!   if (single_succ_edge (a)->flags & EDGE_ABNORMAL)
      return false;
  
    if (single_succ (a) != b)
--- 1150,1156 ----
    if (!single_succ_p (a))
      return false;
  
!   if (single_succ_edge (a)->flags & (EDGE_ABNORMAL | EDGE_EXPLICIT))
      return false;
  
    if (single_succ (a) != b)
*************** remove_useless_stmts_goto (tree *stmt_p,
*** 1727,1733 ****
    data->last_goto = NULL;
  
    /* Record the last goto expr, so that we can delete it if unnecessary.  */
!   if (TREE_CODE (dest) == LABEL_DECL)
      data->last_goto = stmt_p;
  }
  
--- 1735,1741 ----
    data->last_goto = NULL;
  
    /* Record the last goto expr, so that we can delete it if unnecessary.  */
!   if (TREE_CODE (dest) == LABEL_DECL && !GOTO_EXPLICIT_P (*stmt_p))
      data->last_goto = stmt_p;
  }
  
*************** tree_can_make_abnormal_goto (tree t)
*** 2508,2513 ****
--- 2516,2530 ----
  }
  
  
+ /* Checks wether T is a simple non-explicit local goto.  */
+ 
+ bool
+ simple_implicit_goto_p (tree t)
+ {
+   return simple_goto_p (t) && !GOTO_EXPLICIT_P (t);
+ }
+ 
+ 
  /* Return true if T should start a new basic block.  PREV_T is the
     statement preceding T.  It is used when T is a label or a case label.
     Labels should only start a new basic block if their previous statement
*************** disband_implicit_edges (void)
*** 2619,2625 ****
  	if (e->flags & EDGE_FALLTHRU)
  	  break;
  
!       if (!e || e->dest == bb->next_bb)
  	continue;
  
        gcc_assert (e->dest != EXIT_BLOCK_PTR);
--- 2636,2642 ----
  	if (e->flags & EDGE_FALLTHRU)
  	  break;
  
!       if (!e || (e->dest == bb->next_bb && !(e->flags & EDGE_EXPLICIT)))
  	continue;
  
        gcc_assert (e->dest != EXIT_BLOCK_PTR);
*** gcc/tree-flow.h.old	2007-09-26 14:31:59.034887589 +0200
--- gcc/tree-flow.h	2007-09-26 14:29:45.850685758 +0200
*************** extern bool is_ctrl_stmt (tree);
*** 514,519 ****
--- 514,520 ----
  extern bool is_ctrl_altering_stmt (tree);
  extern bool computed_goto_p (tree);
  extern bool simple_goto_p (tree);
+ extern bool simple_implicit_goto_p (tree);
  extern bool tree_can_make_abnormal_goto (tree);
  extern basic_block single_noncomplex_succ (basic_block bb);
  extern void tree_dump_bb (basic_block, FILE *, int);
*** gcc/tree.h.old	2007-09-26 14:31:59.414766944 +0200
--- gcc/tree.h	2007-09-26 14:32:52.678929480 +0200
*************** struct tree_common GTY(())
*** 327,332 ****
--- 327,334 ----
         EH_FILTER_MUST_NOT_THROW in EH_FILTER_EXPR
         TYPE_REF_CAN_ALIAS_ALL in
             POINTER_TYPE, REFERENCE_TYPE
+        GOTO_EXPLICIT_P in
+            GOTO_EXPR
  
     public_flag:
  
*************** extern void tree_operand_check_failed (i
*** 879,884 ****
--- 881,892 ----
     of its scope.  */
  #define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)
  
+ /* Used to mark a GOTO_EXPR as coming directly from user code (either from
+    a goto statement or a break/continue statements.  If this flag is set,
+    an instruction is always generated for the goto and it is therefore
+    possible to set a breakpoint on this goto.  */
+ #define GOTO_EXPLICIT_P(NODE) ((NODE)->common.static_flag)
+ 
  /* In an expr node (usually a conversion) this means the node was made
     implicitly and should not lead to any sort of warning.  In a decl node,
     warnings concerning the decl should be suppressed.  This is used at
*** gcc/gcov.c.old	2007-09-04 15:26:37.000000000 +0200
--- gcc/gcov.c	2007-09-26 17:58:23.044871275 +0200
***************
*** 359,364 ****
--- 359,367 ----
  
    gcc_init_libintl ();
  
+   /* Handle response files.  */
+   expandargv (&argc, &argv);
+ 
    argno = process_args (argc, argv);
    if (optind == argc)
      print_usage (true);
*** gcc/dbxout.c.ori	Thu Sep 27 23:04:59 2007
--- gcc/dbxout.c	Thu Sep 27 23:02:27 2007
*************** Software Foundation, 51 Franklin Street,
*** 177,182 ****
--- 177,186 ----
  
  #define PREVENT_STATIC_DEBUG_ONLY_BLOCKS TARGET_AIX
  
+ /* The base name for function "scope" labels.  */
+ 
+ #define SCOPE_LABEL_BASENAME "Lscope" 
+ 
  enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};
  
  /* Structure recording information about a C data type.
*************** static struct dbx_file *current_file;
*** 249,258 ****
  
  static GTY(()) int next_file_number;
  
- /* A counter for dbxout_function_end.  */
- 
- static GTY(()) int scope_labelno;
- 
  /* A counter for dbxout_source_line.  */
  
  static GTY(()) int dbxout_source_line_counter;
--- 253,258 ----
*************** static void dbxout_handle_pch (unsigned)
*** 351,356 ****
--- 351,357 ----
  
  static void dbxout_source_line (unsigned int, const char *);
  static void dbxout_begin_prologue (unsigned int, const char *);
+ static void dbxout_end_epilogue (unsigned int, const char *);
  static void dbxout_source_file (const char *);
  static void dbxout_function_end (tree);
  static void dbxout_begin_function (tree);
*************** const struct gcc_debug_hooks dbx_debug_h
*** 372,378 ****
    dbxout_source_line,		         /* source_line */
    dbxout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
!   debug_nothing_int_charstar,	         /* end_epilogue */
  #ifdef DBX_FUNCTION_FIRST
    dbxout_begin_function,
  #else
--- 373,379 ----
    dbxout_source_line,		         /* source_line */
    dbxout_begin_prologue,	         /* begin_prologue */
    debug_nothing_int_charstar,	         /* end_prologue */
!   dbxout_end_epilogue,		         /* end_epilogue */
  #ifdef DBX_FUNCTION_FIRST
    dbxout_begin_function,
  #else
*************** dbxout_function_end (tree decl)
*** 920,945 ****
  {
    char lscope_label_name[100];
  
-   /* The Lscope label must be emitted even if we aren't doing anything
-      else; dbxout_block needs it.  */
-   function_section (current_function_decl);
-   
-   /* Convert Lscope into the appropriate format for local labels in case
-      the system doesn't insert underscores in front of user generated
-      labels.  */
-   ASM_GENERATE_INTERNAL_LABEL (lscope_label_name, "Lscope", scope_labelno);
-   targetm.asm_out.internal_label (asm_out_file, "Lscope", scope_labelno);
-   scope_labelno++;
- 
    /* The N_FUN tag at the end of the function is a GNU extension,
!      which may be undesirable, and is unnecessary if we do not have
!      named sections.  */
    if (!use_gnu_debug_info_extensions
        || NO_DBX_FUNCTION_END
-       || !targetm.have_named_sections
        || DECL_IGNORED_P (decl))
      return;
  
    /* By convention, GCC will mark the end of a function with an N_FUN
       symbol and an empty string.  */
  #ifdef DBX_OUTPUT_NFUN
--- 921,938 ----
  {
    char lscope_label_name[100];
  
    /* The N_FUN tag at the end of the function is a GNU extension,
!      which may be undesirable.  */
    if (!use_gnu_debug_info_extensions
        || NO_DBX_FUNCTION_END
        || DECL_IGNORED_P (decl))
      return;
  
+   function_section (current_function_decl);
+   
+   ASM_GENERATE_INTERNAL_LABEL
+     (lscope_label_name, SCOPE_LABEL_BASENAME, current_function_funcdef_no);
+ 
    /* By convention, GCC will mark the end of a function with an N_FUN
       symbol and an empty string.  */
  #ifdef DBX_OUTPUT_NFUN
*************** dbxout_begin_prologue (unsigned int line
*** 1269,1274 ****
--- 1262,1289 ----
    dbxout_source_line (lineno, filename);
  }
  
+ /* Right after the function's epilogue, emit the function "scope" label.  */
+ 
+ static void
+ dbxout_end_epilogue (unsigned int lineno ATTRIBUTE_UNUSED,
+ 		     const char *filename ATTRIBUTE_UNUSED)
+ {
+   /* The function scope label must be emitted even if we aren't doing
+      anything else because dbxout_block needs it.
+ 
+      We emit it here because we know we are still in function's section,
+      and the typical use is from dbxout_function_end, where we emit an
+      expression to compute the function size as the difference between the
+      address of this label and that of the function entry point.  
+ 
+      We used to emit the label from dbxout_function_end itself, but we need
+      to switch back into the function section there and some assemblers
+      can't process the difference in this context.  */
+ 
+   targetm.asm_out.internal_label
+     (asm_out_file, SCOPE_LABEL_BASENAME, current_function_funcdef_no);
+ }
+ 
  /* Output a line number symbol entry for source file FILENAME and line
     number LINENO.  */
  
*************** dbxout_block (tree block, int depth, tre
*** 3452,3459 ****
  	      if (depth == 0)
  		/* The outermost block doesn't get LBE labels;
  		   use the "scope" label which will be emitted
! 		   by dbxout_function_end.  */
! 		ASM_GENERATE_INTERNAL_LABEL (buf, "Lscope", scope_labelno);
  	      else
  		ASM_GENERATE_INTERNAL_LABEL (buf, "LBE", blocknum);
  
--- 3467,3475 ----
  	      if (depth == 0)
  		/* The outermost block doesn't get LBE labels;
  		   use the "scope" label which will be emitted
! 		   by dbxout_end_epilogue.  */
! 		ASM_GENERATE_INTERNAL_LABEL
! 		  (buf, SCOPE_LABEL_BASENAME, current_function_funcdef_no);
  	      else
  		ASM_GENERATE_INTERNAL_LABEL (buf, "LBE", blocknum);
  
*** gcc/config/i386/i386-protos.h.0	2007-10-01 18:03:32.609794080 +0200
--- gcc/config/i386/i386-protos.h	2007-10-01 18:04:47.963338600 +0200
*************** extern void ix86_expand_reduc_v4sf (rtx 
*** 190,195 ****
--- 190,199 ----
  /* In winnt.c  */
  extern int i386_pe_dllexport_name_p (const char *);
  extern int i386_pe_dllimport_name_p (const char *);
+ extern void i386_pe_rwreloc_select_section (tree, int,
+ 					    unsigned HOST_WIDE_INT);
+ extern void i386_pe_rwreloc_select_rtx_section (enum machine_mode, rtx,
+ 						unsigned HOST_WIDE_INT);
  extern void i386_pe_unique_section (tree, int);
  extern void i386_pe_declare_function_type (FILE *, const char *, int);
  extern void i386_pe_record_external_function (tree, const char *);
*** gcc/config/i386/mingw32.h.0	2007-10-01 17:20:13.000000000 +0200
--- gcc/config/i386/mingw32.h	2007-10-01 18:15:25.461424160 +0200
*************** Boston, MA 02110-1301, USA.  */
*** 61,66 ****
--- 61,74 ----
    %{shared|mdll: -e _DllMainCRTStartup@12} \
    --enable-auto-import --enable-runtime-pseudo-reloc"
  
+ /* The auto-import feature of the linker generates runtime relocations
+    in data sections for symbols imported from DLLs.  */
+ #undef  TARGET_ASM_SELECT_SECTION
+ #define TARGET_ASM_SELECT_SECTION  i386_pe_rwreloc_select_section
+ #undef  TARGET_ASM_SELECT_RTX_SECTION
+ #define TARGET_ASM_SELECT_RTX_SECTION  i386_pe_rwreloc_select_rtx_section
+ #define TARGET_RWRELOC  1
+ 
  /* Include in the mingw32 libraries with libgcc */
  #undef LIBGCC_SPEC
  #define LIBGCC_SPEC \
*** gcc/config/i386/winnt.c.0	2007-10-01 17:39:17.000000000 +0200
--- gcc/config/i386/winnt.c	2007-10-01 18:09:11.000000000 +0200
*************** void i386_pe_output_labelref (FILE *stre
*** 461,466 ****
--- 461,490 ----
      }
  }
  
+ #ifndef TARGET_RWRELOC
+ #define TARGET_RWRELOC flag_pic
+ #endif
+ 
+ void
+ i386_pe_rwreloc_select_section (tree decl, int reloc,
+ 				unsigned HOST_WIDE_INT align)
+ {
+   int save_pic = flag_pic;
+   flag_pic = TARGET_RWRELOC;
+   default_select_section (decl, reloc, align);
+   flag_pic = save_pic;
+ }
+ 
+ void
+ i386_pe_rwreloc_select_rtx_section (enum machine_mode mode, rtx x,
+ 				    unsigned HOST_WIDE_INT align)
+ {
+   int save_pic = flag_pic;
+   flag_pic = TARGET_RWRELOC;
+   default_select_rtx_section (mode, x, align);
+   flag_pic = save_pic;
+ }
+ 
  void
  i386_pe_unique_section (tree decl, int reloc)
  {
*************** i386_pe_unique_section (tree decl, int r
*** 479,485 ****
       without a .rdata section.  */
    if (TREE_CODE (decl) == FUNCTION_DECL)
      prefix = ".text$";
!   else if (decl_readonly_section (decl, reloc))
      prefix = ".rdata$";
    else
      prefix = ".data$";
--- 503,509 ----
       without a .rdata section.  */
    if (TREE_CODE (decl) == FUNCTION_DECL)
      prefix = ".text$";
!   else if (decl_readonly_section_1 (decl, reloc, TARGET_RWRELOC))
      prefix = ".rdata$";
    else
      prefix = ".data$";
*************** i386_pe_section_type_flags (tree decl, c
*** 522,528 ****
  
    if (decl && TREE_CODE (decl) == FUNCTION_DECL)
      flags = SECTION_CODE;
!   else if (decl && decl_readonly_section (decl, reloc))
      flags = 0;
    else
      {
--- 546,552 ----
  
    if (decl && TREE_CODE (decl) == FUNCTION_DECL)
      flags = SECTION_CODE;
!   else if (decl && decl_readonly_section_1 (decl, reloc, TARGET_RWRELOC))
      flags = 0;
    else
      {
*** gcc/dbxout.c.0	2007-10-03 19:52:26.386058096 +0200
--- gcc/dbxout.c	2007-10-03 20:13:19.327582032 +0200
*************** Software Foundation, 51 Franklin Street,
*** 134,145 ****
  #define DBX_REGPARM_STABS_LETTER 'P'
  #endif
  
! #ifndef NO_DBX_FUNCTION_END
! #define NO_DBX_FUNCTION_END 0
! #endif
! 
! #ifndef NO_DBX_BNSYM_ENSYM
! #define NO_DBX_BNSYM_ENSYM 0
  #endif
  
  #ifndef NO_DBX_MAIN_SOURCE_DIRECTORY
--- 134,141 ----
  #define DBX_REGPARM_STABS_LETTER 'P'
  #endif
  
! #ifndef DBX_BNSYM_ENSYM
! #define DBX_BNSYM_ENSYM 0
  #endif
  
  #ifndef NO_DBX_MAIN_SOURCE_DIRECTORY
*************** dbxout_function_end (tree decl)
*** 923,931 ****
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions
!       || NO_DBX_FUNCTION_END
!       || DECL_IGNORED_P (decl))
      return;
  
    function_section (current_function_decl);
--- 919,925 ----
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions || DECL_IGNORED_P (decl))
      return;
  
    function_section (current_function_decl);
*************** dbxout_function_end (tree decl)
*** 957,963 ****
  				
  #endif
  
!   if (!NO_DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)
      dbxout_stabd (N_ENSYM, 0);
  }
  #endif /* DBX_DEBUGGING_INFO */
--- 951,957 ----
  				
  #endif
  
!   if (DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)
      dbxout_stabd (N_ENSYM, 0);
  }
  #endif /* DBX_DEBUGGING_INFO */
*************** static void
*** 1254,1261 ****
  dbxout_begin_prologue (unsigned int lineno, const char *filename)
  {
    if (use_gnu_debug_info_extensions
!       && !NO_DBX_FUNCTION_END
!       && !NO_DBX_BNSYM_ENSYM
        && !flag_debug_only_used_symbols)
      dbxout_stabd (N_BNSYM, 0);
  
--- 1248,1254 ----
  dbxout_begin_prologue (unsigned int lineno, const char *filename)
  {
    if (use_gnu_debug_info_extensions
!       && DBX_BNSYM_ENSYM
        && !flag_debug_only_used_symbols)
      dbxout_stabd (N_BNSYM, 0);
  
*** gcc/mips-tfile.c.0	2007-10-03 19:52:26.403055512 +0200
--- gcc/mips-tfile.c	2007-10-03 20:14:28.267101632 +0200
*************** static alloc_info_t alloc_counts[ (int) 
*** 1454,1459 ****
--- 1454,1462 ----
  
  /* Pointers and such to the original symbol table that is read in.  */
  static struct filehdr orig_file_header;		/* global object file header */
+ static struct scnhdr *section_headers;			/* section headers */
+ static Size_t rdata_vaddr;				/* .rdata section address */
+ static char  *rdata_ptr;				/* .rdata section contents */
  
  static HDRR	 orig_sym_hdr;			/* symbolic header on input */
  static char	*orig_linenum;			/* line numbers */
*************** parse_stabs_common (const char *string_s
*** 3669,3681 ****
  	    {
  	      sc = scNil;
  	      st = stNil;
  	    }
  	  else
  	    {
  	      sc = (sc_t) sym_ptr->sc;
  	      st = (st_t) sym_ptr->st;
  	    }
- 	  value = sym_ptr->value;
  
  	  ch = *end_p1++;
  	  if (ch != '\n')
--- 3672,3702 ----
  	    {
  	      sc = scNil;
  	      st = stNil;
+ 	      value = sym_ptr->value;
+ 	    }
+ 	  /* Special case of N_FUN with empty string: the value is the
+ 	     32-bit numeric value pointed to by the symbol.  */
+ 	  else if (code == (int) N_FUN
+ 		   && string_start == string_end
+ 		   && sym_ptr->sc == scRData
+ 		   && rdata_vaddr > 0)
+ 	    {
+ 	      unsigned char *q = rdata_ptr + sym_ptr->value - rdata_vaddr;
+ 	      sc = scNil;
+ 	      st = stNil;
+ 	      if (init_file.fdr.fBigendian)
+ 		value = ((symint_t)q[0]<<24) + ((symint_t)q[1]<<16)
+ 			  + ((symint_t)q[2]<<8) + (symint_t)q[3];
+ 	      else
+ 		value = (symint_t)q[0] + ((symint_t)q[1]<<8)
+ 			  + ((symint_t)q[2]<<16) + ((symint_t)q[3]<<24);
  	    }
  	  else
  	    {
  	      sc = (sc_t) sym_ptr->sc;
  	      st = (st_t) sym_ptr->st;
+ 	      value = sym_ptr->value;
  	    }
  
  	  ch = *end_p1++;
  	  if (ch != '\n')
*************** copy_object (void)
*** 4321,4327 ****
    int remaining;
    int num_write;
    int sys_write;
!   int fd, es;
    int delete_ifd = 0;
    int *remap_file_number;
    struct stat stat_buf;
--- 4342,4348 ----
    int remaining;
    int num_write;
    int sys_write;
!   int fd, es, i;
    int delete_ifd = 0;
    int *remap_file_number;
    struct stat stat_buf;
*************** copy_object (void)
*** 4356,4361 ****
--- 4377,4400 ----
  	   input_name, (long) orig_file_header.f_nsyms, (long) sizeof (HDRR));
  
  
+   /* Read in the sections headers.  */
+   section_headers
+     = (SCNHDR *) read_seek (orig_file_header.f_nscns * sizeof (SCNHDR),
+ 			    sizeof (FILHDR) + orig_file_header.f_opthdr,
+ 			    "Section headers");
+ 
+   /* Look for the .rdata section.  */
+   for (i = 0; i < orig_file_header.f_nscns; i++)
+     if (strncmp (section_headers[i].s_name, _RDATA, 8) == 0)
+       {
+ 	rdata_vaddr = section_headers[i].s_vaddr;
+ 	rdata_ptr = (char *) read_seek (section_headers[i].s_size,
+ 					section_headers[i].s_scnptr,
+ 					"Read-only data section");
+ 	break;
+       }
+ 
+ 
    /* Read in the current symbolic header.  */
    if (fseek (obj_in_stream, (long) orig_file_header.f_symptr, SEEK_SET) != 0)
      pfatal_with_name (input_name);
*** gcc/doc/tm.texi.0	2007-10-03 19:52:26.421052776 +0200
--- gcc/doc/tm.texi	2007-10-03 20:34:12.364091528 +0200
*************** generate @code{N_BINCL} or @code{N_EINCL
*** 8099,8104 ****
--- 8099,8111 ----
  number for a type number.
  @end defmac
  
+ @defmac DBX_BNSYM_ENSYM
+ Define this macro if GCC should generate @code{N_BNSYM} and
+ @code{N_ENSYM} stabs for functions, as on Darwin systems.  Normally, GCC
+ does not generate @code{N_BNSYM} or @code{N_ENSYM} stabs because some
+ assemblers cannot grok them.
+ @end defmac
+ 
  @node DBX Hooks
  @subsection Open-Ended Hooks for DBX Format
  
*************** This macro should not be defined if the 
*** 8132,8150 ****
  if it can be made correct by defining @code{DBX_LINES_FUNCTION_RELATIVE}.
  @end defmac
  
- @defmac NO_DBX_FUNCTION_END
- Some stabs encapsulation formats (in particular ECOFF), cannot handle the
- @code{.stabs "",N_FUN,,0,0,Lscope-function-1} gdb dbx extension construct.
- On those machines, define this macro to turn this feature off without
- disturbing the rest of the gdb extensions.
- @end defmac
- 
- @defmac NO_DBX_BNSYM_ENSYM
- Some assemblers cannot handle the @code{.stabd BNSYM/ENSYM,0,0} gdb dbx
- extension construct.  On those machines, define this macro to turn this
- feature off without disturbing the rest of the gdb extensions.
- @end defmac
- 
  @node File Names and DBX
  @subsection File Names in DBX Format
  
--- 8139,8144 ----
*** gcc/config/darwin.h.0	2007-10-03 20:27:45.298934376 +0200
--- gcc/config/darwin.h	2007-09-28 15:32:41.000000000 +0200
*************** Boston, MA 02110-1301, USA.  */
*** 352,357 ****
--- 352,358 ----
  /* We use Dbx symbol format.  */
  
  #define DBX_DEBUGGING_INFO 1
+ #define DBX_BNSYM_ENSYM    1
  
  /* Also enable Dwarf 2 as an option.  */
  #define DWARF2_DEBUGGING_INFO
*** gcc/config/alpha/alpha.h.0	2007-10-03 19:52:26.455047608 +0200
--- gcc/config/alpha/alpha.h	2007-10-03 20:41:04.192484096 +0200
*************** extern int num_source_filenames;
*** 1495,1511 ****
  #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)			\
    alpha_output_filename (STREAM, NAME)
  
- /* mips-tfile.c limits us to strings of one page.  We must underestimate this
-    number, because the real length runs past this up to the next
-    continuation point.  This is really a dbxout.c bug.  */
- #define DBX_CONTIN_LENGTH 3000
- 
  /* By default, turn on GDB extensions.  */
  #define DEFAULT_GDB_EXTENSIONS 1
  
- /* Stabs-in-ECOFF can't handle dbxout_function_end().  */
- #define NO_DBX_FUNCTION_END 1
- 
  /* If we are smuggling stabs through the ALPHA ECOFF object
     format, put a comment in front of the .stab<x> operation so
     that the ALPHA assembler does not choke.  The mips-tfile program
--- 1495,1503 ----
*** gcc/config/alpha/osf.h.0	2007-10-03 20:26:58.462054664 +0200
--- gcc/config/alpha/osf.h	2007-10-03 20:16:41.685818904 +0200
*************** Boston, MA 02110-1301, USA.  */
*** 134,139 ****
--- 134,190 ----
  
  #endif
  
+ /* The mips-tfile post-processor limits us to strings of one page.
+    We must underestimate this number, because the real length runs
+    past this up to the next continuation point.  This is really a
+    dbxout.c bug.  */
+ #define DBX_CONTIN_LENGTH 3000
+ 
+ /* The mips-tfile post-processor cannot compute the difference
+    of labels so we need to use an indirection for the special
+    N_FUN emitted at the end of the STABS for a function:
+    
+ 	.ent _ada_p
+    _ada_p:
+ 	[...]
+    $Lscope:
+ 	.end _ada_p
+ 	[...]
+ 	.rdata
+    $Lspan:
+ 	.align 0
+ 	.long $Lscope-_ada_p
+ 	.text
+     #.stabs "",36,0,0,$Lspan
+ 
+    But we don't want to do this when we use the GNU assembler.  */
+ #define DBX_OUTPUT_NFUN(FILE, LSCOPE, DECL)				    \
+ {									    \
+   if (TARGET_GAS)							    \
+     {									    \
+       dbxout_begin_empty_stabs (N_FUN);					    \
+       dbxout_stab_value_label_diff (LSCOPE,				    \
+ 				    XSTR (XEXP (DECL_RTL (DECL), 0), 0));   \
+     }									    \
+   else									    \
+     {									    \
+       char lspan_label_name[100];					    \
+       readonly_data_section ();						    \
+       ASM_GENERATE_INTERNAL_LABEL					    \
+ 	(lspan_label_name, "Lspan", current_function_funcdef_no);	    \
+       ASM_OUTPUT_LABEL (FILE, lspan_label_name);			    \
+       fputs (integer_asm_op (4, 0), FILE);				    \
+       output_addr_const (FILE,						    \
+ 			 gen_rtx_MINUS (Pmode,				    \
+ 					gen_rtx_SYMBOL_REF (Pmode, LSCOPE), \
+ 					XEXP (DECL_RTL (DECL), 0)));	    \
+       fputc ('\n', FILE);						    \
+       function_section (current_function_decl);				    \
+       dbxout_begin_empty_stabs (N_FUN);					    \
+       dbxout_stab_value_label (lspan_label_name);			    \
+     }									    \
+ }
+ 
  #undef SUBTARGET_EXTRA_SPECS
  #define SUBTARGET_EXTRA_SPECS { "asm_oldas", ASM_OLDAS_SPEC }
  
*** gcc/gcov.c.old	2007-10-04 14:32:21.466792530 +0200
--- gcc/gcov.c	2007-10-04 14:44:36.674940927 +0200
***************
*** 655,665 ****
  
  /* Generate the names of the graph and data files. If OBJECT_DIRECTORY
     is not specified, these are looked for in the current directory,
!    and named from the basename of the FILE_NAME sans extension. If
!    OBJECT_DIRECTORY is specified and is a directory, the files are in
!    that directory, but named from the basename of the FILE_NAME, sans
!    extension. Otherwise OBJECT_DIRECTORY is taken to be the name of
!    the object *file*, and the data files are named from that.  */
  
  static void
  create_file_names (const char *file_name)
--- 655,665 ----
  
  /* Generate the names of the graph and data files. If OBJECT_DIRECTORY
     is not specified, these are looked for in the current directory,
!    and named from FILE_NAME sans extension. If OBJECT_DIRECTORY is
!    specified and is a directory, the files are in that directory, but
!    named from the basename of the FILE_NAME, sans extension. Otherwise
!    OBJECT_DIRECTORY is taken to be the name of the object *file*, and
!    the data files are named from that.  */
  
  static void
  create_file_names (const char *file_name)
***************
*** 694,701 ****
    else
      {
        name = xmalloc (length + 1);
!       name[0] = 0;
!       base = 1;
      }
  
    if (base)
--- 694,701 ----
    else
      {
        name = xmalloc (length + 1);
!       strcpy (name, file_name);
!       base = 0;
      }
  
    if (base)
*** gcc/config/alpha/alpha.c.0	2007-10-05 20:11:26.985616592 +0200
--- gcc/config/alpha/alpha.c	2007-10-05 20:25:29.530530296 +0200
*************** decl_has_samegp (tree decl)
*** 821,859 ****
    return !TREE_PUBLIC (decl) || !DECL_EXTERNAL (decl);
  }
  
- /* Return true if EXP should be placed in the small data section.  */
- 
- static bool
- alpha_in_small_data_p (tree exp)
- {
-   /* We want to merge strings, so we never consider them small data.  */
-   if (TREE_CODE (exp) == STRING_CST)
-     return false;
- 
-   /* Functions are never in the small data area.  Duh.  */
-   if (TREE_CODE (exp) == FUNCTION_DECL)
-     return false;
- 
-   if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
-     {
-       const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
-       if (strcmp (section, ".sdata") == 0
- 	  || strcmp (section, ".sbss") == 0)
- 	return true;
-     }
-   else
-     {
-       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
- 
-       /* If this is an incomplete type with size 0, then we can't put it
- 	 in sdata because it might be too big when completed.  */
-       if (size > 0 && (unsigned HOST_WIDE_INT) size <= g_switch_value)
- 	return true;
-     }
- 
-   return false;
- }
- 
  #if TARGET_ABI_OPEN_VMS
  static bool
  alpha_linkage_symbol_p (const char *symname)
--- 821,826 ----
*************** alpha_file_start (void)
*** 9402,9408 ****
  }
  #endif
  
! #ifdef OBJECT_FORMAT_ELF
  /* Since we've no .dynbss section, pretend flag_pic is always set, so that
     we don't wind up with dynamic relocations in .rodata.  */
  
--- 9384,9391 ----
  }
  #endif
  
! #if defined (OBJECT_FORMAT_ELF) && !TARGET_ABI_OPEN_VMS
! 
  /* Since we've no .dynbss section, pretend flag_pic is always set, so that
     we don't wind up with dynamic relocations in .rodata.  */
  
*************** alpha_elf_section_type_flags (tree decl,
*** 9453,9458 ****
--- 9436,9474 ----
    flags |= default_section_type_flags_1 (decl, name, reloc, true);
    return flags;
  }
+ 
+ /* Return true if EXP should be placed in the small data section.  */
+ 
+ static bool
+ alpha_in_small_data_p (tree exp)
+ {
+   /* We want to merge strings, so we never consider them small data.  */
+   if (TREE_CODE (exp) == STRING_CST)
+     return false;
+ 
+   /* Functions are never in the small data area.  Duh.  */
+   if (TREE_CODE (exp) == FUNCTION_DECL)
+     return false;
+ 
+   if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
+     {
+       const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
+       if (strcmp (section, ".sdata") == 0
+ 	  || strcmp (section, ".sbss") == 0)
+ 	return true;
+     }
+   else
+     {
+       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
+ 
+       /* If this is an incomplete type with size 0, then we can't put it
+ 	 in sdata because it might be too big when completed.  */
+       if (size > 0 && (unsigned HOST_WIDE_INT) size <= g_switch_value)
+ 	return true;
+     }
+ 
+   return false;
+ }
  #endif /* OBJECT_FORMAT_ELF */
  
  /* Structure to collect function names for final output in link section.  */
*************** alpha_init_libfuncs (void)
*** 10632,10640 ****
  # define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags
  #endif
  
- #undef TARGET_IN_SMALL_DATA_P
- #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p
- 
  #if TARGET_ABI_UNICOSMK
  # undef TARGET_INSERT_ATTRIBUTES
  # define TARGET_INSERT_ATTRIBUTES unicosmk_insert_attributes
--- 10648,10653 ----
*************** alpha_init_libfuncs (void)
*** 10666,10672 ****
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.align 0\n\t.quad\t"
  #endif
  
! #ifdef OBJECT_FORMAT_ELF
  #undef  TARGET_ASM_SELECT_SECTION
  #define TARGET_ASM_SELECT_SECTION  alpha_elf_select_section
  #undef  TARGET_ASM_UNIQUE_SECTION
--- 10679,10685 ----
  #define TARGET_ASM_UNALIGNED_DI_OP "\t.align 0\n\t.quad\t"
  #endif
  
! #if defined (OBJECT_FORMAT_ELF) && !TARGET_ABI_OPEN_VMS
  #undef  TARGET_ASM_SELECT_SECTION
  #define TARGET_ASM_SELECT_SECTION  alpha_elf_select_section
  #undef  TARGET_ASM_UNIQUE_SECTION
*************** alpha_init_libfuncs (void)
*** 10675,10680 ****
--- 10688,10695 ----
  #define	TARGET_ASM_SELECT_RTX_SECTION  alpha_elf_select_rtx_section
  #undef  TARGET_SECTION_TYPE_FLAGS
  #define TARGET_SECTION_TYPE_FLAGS  alpha_elf_section_type_flags
+ #undef TARGET_IN_SMALL_DATA_P
+ #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p
  #endif
  
  #undef TARGET_ASM_FUNCTION_END_PROLOGUE
*** /dev/null	2007-10-08 16:21:38.000000000 -0400
--- gcc/config/arm/nucleus.h	2007-10-08 16:21:38.000000000 -0400
***************
*** 0 ****
--- 1,50 ----
+ /* Configuration file for Nucleus OS on ARM processors.
+    Copyright (C) 2007 Free Software Foundation, Inc.
+    Contributed by AdaCore, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to
+    the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.  */
+ 
+ /* Nucleus OS does not use crt*.o, unlike the generic unknown-elf
+    configuration.  */
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC ""
+ 
+ #undef ENDFILE_SPEC
+ #define ENDFILE_SPEC ""
+ 
+ /* Do not link with any libraries by default.  On Nucleus OS, the user
+    must supply all required libraries on the command line.  */
+ #undef LIB_SPEC
+ #define LIB_SPEC ""
+ 
+ /* Define the __nucleus__ macro.  */
+ #undef TARGET_OS_CPP_BUILTINS
+ #define TARGET_OS_CPP_BUILTINS()		\
+   do						\
+     {						\
+       /* Include the default BPABI stuff.  */	\
+       TARGET_BPABI_CPP_BUILTINS ();		\
+       builtin_define ("__nucleus__");		\
+     }						\
+   while (false)
+ 
+ #undef  TARGET_VERSION
+ #define TARGET_VERSION	fputs (" (ARM/Nucleus OS)", stderr);
+ 
+ /* There is no default multilib.  */
+ #undef MULTILIB_DEFAULTS
*** /dev/null   2006-12-08 08:28:33.872007232 -0500
--- gcc/config/arm/t-nucleus    2007-10-15 08:49:53.830015000 -0400
***************
*** 0 ****
--- 1,8 ----
+ MULTILIB_OPTIONS     =
+ MULTILIB_DIRNAMES    =
+ 
+ # There is no C library to link against on Nucleus OS
+ SHLIB_LC =
+ 
+ # Nucleus OS provides its own startup code.
+ EXTRA_MULTILIB_PARTS=
*** gcc/config.gcc.orig	2006-10-15 21:08:27.000000000 -0400
--- gcc/config.gcc	2007-10-08 16:22:40.000000000 -0400
*************** arm*-*-ecos-elf)
*** 705,711 ****
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h"
  	tmake_file="arm/t-arm arm/t-arm-elf"
  	;;
! arm*-*-eabi* | arm*-*-symbianelf* )
  	# The BPABI long long divmod functions return a 128-bit value in 
  	# registers r0-r3.  Correctly modeling that requires the use of
  	# TImode.
--- 705,711 ----
  	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h"
  	tmake_file="arm/t-arm arm/t-arm-elf"
  	;;
! arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-nucleus* )
  	# The BPABI long long divmod functions return a 128-bit value in 
  	# registers r0-r3.  Correctly modeling that requires the use of
  	# TImode.
*************** arm*-*-eabi* | arm*-*-symbianelf* )
*** 723,728 ****
--- 723,732 ----
  	  # provides its own implementation of the BPABI functions.
  	  tmake_file="${tmake_file} t-slibgcc-elf-ver arm/t-symbian"
  	  ;;
+         arm*-*-nucleus*)
+ 	  tm_file="${tm_file} arm/nucleus.h"
+ 	  tmake_file="${tmake_file} arm/t-bpabi arm/t-nucleus"
+ 	  ;;
  	esac
  	tm_file="${tm_file} arm/aout.h arm/arm.h"
  	;;
*** libcpp/configure.orig	2005-11-19 13:47:13.000000000 -0500
--- libcpp/configure	2007-10-08 16:21:38.000000000 -0400
*************** case $target in
*** 8220,8225 ****
--- 8220,8226 ----
  	alpha*-*-* | \
  	arm*-*-*eabi* | \
  	arm*-*-symbianelf* | \
+ 	arm*-*-nucleus* | \
  	x86_64-*-* | \
  	ia64-*-* | \
  	hppa*64*-*-* | parisc*64*-*-* | \
*** libcpp/configure.ac.orig	2005-11-19 13:47:13.000000000 -0500
--- libcpp/configure.ac	2007-10-08 16:21:38.000000000 -0400
*************** case $target in
*** 115,120 ****
--- 115,121 ----
  	alpha*-*-* | \
  	arm*-*-*eabi* | \
  	arm*-*-symbianelf* | \
+ 	arm*-*-nucleus* | \
  	x86_64-*-* | \
  	ia64-*-* | \
  	hppa*64*-*-* | parisc*64*-*-* | \
*** gcc/dbxout.h.0	2007-10-12 15:33:46.000000000 +0200
--- gcc/dbxout.h	2007-10-11 07:00:00.000000000 +0200
*************** extern int dbxout_symbol (tree, int);
*** 26,31 ****
--- 26,32 ----
  extern void dbxout_parms (tree);
  extern void dbxout_reg_parms (tree);
  extern int dbxout_syms (tree);
+ extern void dbxout_static_link (tree);
  
  /* Language description for N_SO stabs.  */
  #define N_SO_AS          1
*** gcc/dbxout.c.0	2007-10-12 15:33:46.000000000 +0200
--- gcc/dbxout.c	2007-10-12 18:12:36.655715792 +0200
*************** static GTY(()) int next_type_number;
*** 216,221 ****
--- 216,225 ----
  
  static GTY(()) tree preinit_symbols;
  
+ /* The fake variable pointing to the static link in the frame.  */
+ 
+ static GTY(()) tree static_link_var;
+ 
  enum binclstatus {BINCL_NOT_REQUIRED, BINCL_PENDING, BINCL_PROCESSED};
  
  /* When using N_BINCL in dbx output, each type number is actually a
*************** dbxout_init (const char *input_file_name
*** 1075,1080 ****
--- 1079,1087 ----
  	dbxout_symbol (TREE_VALUE (t), 0);
        preinit_symbols = 0;
      }
+ 
+   static_link_var = build_decl (VAR_DECL, get_identifier ("__link"),
+ 				build_pointer_type (void_type_node));
  }
  
  /* Output any typedef names for types described by TYPE_DECLs in SYMS.  */
*************** dbxout_begin_function (tree decl)
*** 3502,3510 ****
--- 3509,3529 ----
    dbxout_parms (DECL_ARGUMENTS (decl));
    if (DECL_NAME (DECL_RESULT (decl)) != 0)
      dbxout_symbol (DECL_RESULT (decl), 1);
+ 
+   if (cfun->static_chain_decl)
+     dbxout_static_link (cfun->static_chain_decl);
  }
  #endif /* DBX_DEBUGGING_INFO */
  
+ /* Output the information about the static link.  */
+ 
+ void
+ dbxout_static_link (tree decl)
+ {
+   dbxout_symbol_location (static_link_var, TREE_TYPE (static_link_var), NULL,
+ 			  eliminate_regs (DECL_RTL (decl), 0, NULL_RTX));
+ }
+ 
  #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
  
  #include "gt-dbxout.h"
*** gcc/xcoffout.c.0	2007-10-12 15:33:46.000000000 +0200
--- gcc/xcoffout.c	2007-10-12 16:17:04.000000000 +0200
*************** Software Foundation, 51 Franklin Street,
*** 34,39 ****
--- 34,40 ----
  #include "toplev.h"
  #include "output.h"
  #include "ggc.h"
+ #include "function.h"
  #include "target.h"
  
  #ifdef XCOFF_DEBUGGING_INFO
*************** xcoffout_begin_prologue (unsigned int li
*** 450,455 ****
--- 451,459 ----
    xcoffout_block (DECL_INITIAL (current_function_decl), 0,
  		  DECL_ARGUMENTS (current_function_decl));
  
+   if (cfun->static_chain_decl)
+     dbxout_static_link (cfun->static_chain_decl);
+ 
    ASM_OUTPUT_LINE (asm_out_file, line);
  }
  
*** gcc/Makefile.in.0	2007-10-12 15:33:46.000000000 +0200
--- gcc/Makefile.in	2007-10-11 07:00:00.000000000 +0200
*************** vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(
*** 2147,2153 ****
     $(RTL_H) $(FLAGS_H) output.h vmsdbg.h debug.h langhooks.h function.h $(TARGET_H)
  xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) toplev.h output.h dbxout.h \
!    $(GGC_H) $(TARGET_H) gstab.h xcoff.h
  emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \
     $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \
--- 2147,2153 ----
     $(RTL_H) $(FLAGS_H) output.h vmsdbg.h debug.h langhooks.h function.h $(TARGET_H)
  xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) toplev.h output.h dbxout.h \
!    $(GGC_H) function.h $(TARGET_H) gstab.h xcoff.h
  emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
     $(TREE_H) $(FLAGS_H) function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \
     $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \
*** gcc/function.c.0	2007-10-12 15:33:46.000000000 +0200
--- gcc/function.c	2007-10-12 17:05:15.000000000 +0200
*************** instantiate_decls (tree fndecl)
*** 1655,1660 ****
--- 1655,1665 ----
  	}
      }
  
+   /* Process the static chain if it exists.  */
+   decl = DECL_STRUCT_FUNCTION (fndecl)->static_chain_decl;
+   if (decl)
+     instantiate_decl (DECL_RTL (decl));
+ 
    /* Now process all variables defined in the function or its subblocks.  */
    instantiate_decls_1 (DECL_INITIAL (fndecl));
  }
*************** expand_function_start (tree subr)
*** 4195,4205 ****
    if (cfun->static_chain_decl)
      {
        tree parm = cfun->static_chain_decl;
!       rtx local = gen_reg_rtx (Pmode);
  
        set_decl_incoming_rtl (parm, static_chain_incoming_rtx);
        SET_DECL_RTL (parm, local);
-       mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));
  
        emit_move_insn (local, static_chain_incoming_rtx);
      }
--- 4200,4217 ----
    if (cfun->static_chain_decl)
      {
        tree parm = cfun->static_chain_decl;
!       rtx local;
! 
!       if (optimize)
! 	{
! 	  local = gen_reg_rtx (Pmode);
! 	  mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));
! 	}
!       else
! 	local = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);
  
        set_decl_incoming_rtl (parm, static_chain_incoming_rtx);
        SET_DECL_RTL (parm, local);
  
        emit_move_insn (local, static_chain_incoming_rtx);
      }
*** gcc/tree-nested.c.0	2008-02-06 19:47:53.914793200 +0100
--- gcc/tree-nested.c	2008-02-06 22:33:22.153471504 +0100
*************** struct nesting_info GTY ((chain_next ("%
*** 102,107 ****
--- 102,108 ----
    bool any_parm_remapped;
    bool any_tramp_created;
    bool reachable;
+   bool address_taken;
  };
  
  static FILE *local_dump_file;
*************** static struct nesting_info *reachable_qu
*** 774,780 ****
  /* Mark FNDECL as reachable if it is not already and add it to the queue.  */
  
  static void
! mark_reachable_function_1 (tree fndecl)
  {
    struct nesting_info dummy;
    struct nesting_info *info;
--- 774,780 ----
  /* Mark FNDECL as reachable if it is not already and add it to the queue.  */
  
  static void
! mark_reachable_function_1 (tree fndecl, bool address_taken)
  {
    struct nesting_info dummy;
    struct nesting_info *info;
*************** mark_reachable_function_1 (tree fndecl)
*** 791,796 ****
--- 792,800 ----
        info->next_reachable = reachable_queue;
        reachable_queue = info;
      }
+ 
+   if (address_taken)
+     info->address_taken = true;
  }
  
  /* Called via walk_function+walk_tree, mark the nested functions
*************** mark_reachable_functions_1 (tree *tp, in
*** 809,821 ****
      case ADDR_EXPR:
        decl = TREE_OPERAND (t, 0);
        if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))
! 	mark_reachable_function_1 (decl);
        break;
  
      case CALL_EXPR:
        decl = get_callee_fndecl (t);
        if (decl && decl_function_context (decl))
! 	mark_reachable_function_1 (decl);
  
        walk_tree (&TREE_OPERAND (t, 1), mark_reachable_functions_1, wi, NULL);
        break;
--- 813,825 ----
      case ADDR_EXPR:
        decl = TREE_OPERAND (t, 0);
        if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))
! 	mark_reachable_function_1 (decl, true);
        break;
  
      case CALL_EXPR:
        decl = get_callee_fndecl (t);
        if (decl && decl_function_context (decl))
! 	mark_reachable_function_1 (decl, false);
  
        walk_tree (&TREE_OPERAND (t, 1), mark_reachable_functions_1, wi, NULL);
        break;
*************** convert_local_reference (tree *tp, int *
*** 1112,1117 ****
--- 1113,1125 ----
  
  	  x = get_frame_field (info, info->context, field, &wi->tsi);
  
+ 	  /* Declare the transformation for debugging purposes.  */
+ 	  if (!optimize && !DECL_HAS_VALUE_EXPR_P (t))
+ 	    {
+ 	      SET_DECL_VALUE_EXPR (t, unshare_expr (x));
+ 	      DECL_HAS_VALUE_EXPR_P (t) = 1;
+ 	    }
+ 
  	  if (wi->val_only)
  	    {
  	      if (wi->is_lhs)
*************** convert_all_function_calls (struct nesti
*** 1450,1455 ****
--- 1461,1477 ----
        walk_function (convert_tramp_reference, root);
        walk_function (convert_call_expr, root);
  
+       /* Always create a static chain if not optimizing, unless this could
+ 	 artificially cause a trampoline to be created or if the function
+ 	 really doesn't want one.  This makes it possible to reconstruct
+ 	 the static nesting tree at runtime and thus to resolve up-level
+ 	 references from within the debugger.  */
+       if (root->outer
+ 	  && !optimize
+ 	  && !root->address_taken
+ 	  && !DECL_NO_STATIC_CHAIN (root->context))
+ 	(void) get_chain_decl (root);
+ 
        /* If the function does not use a static chain, then remember that.  */
        if (root->outer && !root->chain_decl && !root->chain_field)
  	DECL_NO_STATIC_CHAIN (root->context) = 1;
*** gcc/config/arm/arm.c.ori	2007-10-15 09:27:26.000000000 -0400
--- gcc/config/arm/arm.c	2007-10-15 10:35:56.000000000 -0400
*************** arm_unwind_emit_set (FILE * asm_out_file
*** 15373,15378 ****
--- 15373,15387 ----
  	  /* Move from sp to reg.  */
  	  asm_fprintf (asm_out_file, "\t.movsp %r\n", REGNO (e0));
  	}
+       else if (GET_CODE (e1) == PLUS
+               && GET_CODE (XEXP (e1, 0)) == REG
+               && REGNO (XEXP (e1, 0)) == SP_REGNUM
+               && GET_CODE (XEXP (e1, 1)) == CONST_INT)
+         {
+           /* Set reg to offset from sp.  */
+           asm_fprintf (asm_out_file, "\t.movsp %r, #%d\n",
+                        REGNO (e0), (int)INTVAL(XEXP (e1, 1)));
+         }
        else
  	abort ();
        break;
*** gcc/config/arm/unwind-arm.h	(revision 121376)
--- gcc/config/arm/unwind-arm.h	(revision 121377)
*************** extern "C" {
*** 261,266 ****
--- 261,273 ----
  #define _Unwind_SetIP(context, val) \
    _Unwind_SetGR (context, 15, val | (_Unwind_GetGR (context, 15) & 1))
  
+ /* leb128 type numbers have a potentially unlimited size.
+    The target of the following definitions of _sleb128_t and _uleb128_t
+    is to have efficient data types large enough to hold the leb128 type
+    numbers used in the unwind code.  */
+ typedef long _sleb128_t;
+ typedef unsigned long _uleb128_t;
+ 
  #ifdef __cplusplus
  }   /* extern "C" */
  #endif
*** gcc/config/arm/unwind-arm.h.ori	Tue Oct 16 18:29:57 2007
--- gcc/config/arm/unwind-arm.h	Tue Oct 16 18:30:06 2007
*************** extern "C" {
*** 50,55 ****
--- 50,58 ----
      {
        _URC_OK = 0,       /* operation completed successfully */
        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
+       _URC_FATAL_PHASE2_ERROR = 2,
+       _URC_FATAL_PHASE1_ERROR = 3,
+       _URC_NORMAL_STOP = 4,
        _URC_END_OF_STACK = 5,
        _URC_HANDLER_FOUND = 6,
        _URC_INSTALL_CONTEXT = 7,
*** gcc/libgcov.c.old	2005-11-19 19:38:39.000000000 +0100
--- gcc/libgcov.c	2007-10-17 17:49:49.508222326 +0200
*************** create_file_directory (char *filename)
*** 132,140 ****
     
  static int
  gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,
! 	      const char *filename)
  {
!   if (version != GCOV_VERSION)
      {
        char v[4], e[4];
  
--- 132,141 ----
     
  static int
  gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,
! 	      const char *filename, int strict_p)
  {
!   if ((version != GCOV_VERSION && strict_p)
!       || version < (gcov_unsigned_t)0x33303432)
      {
        char v[4], e[4];
  
*************** gcov_exit (void)
*** 328,334 ****
  	      goto read_fatal;
  	    }
  	  length = gcov_read_unsigned ();
! 	  if (!gcov_version (gi_ptr, length, gi_filename))
  	    goto read_fatal;
  
  	  length = gcov_read_unsigned ();
--- 329,335 ----
  	      goto read_fatal;
  	    }
  	  length = gcov_read_unsigned ();
! 	  if (!gcov_version (gi_ptr, length, gi_filename, 1))
  	    goto read_fatal;
  
  	  length = gcov_read_unsigned ();
*************** __gcov_init (struct gcov_info *info)
*** 539,545 ****
  {
    if (!info->version)
      return;
!   if (gcov_version (info, info->version, 0))
      {
        const char *ptr = info->filename;
        gcov_unsigned_t crc32 = gcov_crc32;
--- 540,546 ----
  {
    if (!info->version)
      return;
!   if (gcov_version (info, info->version, 0, 0))
      {
        const char *ptr = info->filename;
        gcov_unsigned_t crc32 = gcov_crc32;
*** gcc/tree.h.0	2007-10-22 08:40:29.276318320 +0200
--- gcc/tree.h	2007-10-21 08:24:00.000000000 +0200
*************** extern void tree_operand_check_failed (i
*** 871,876 ****
--- 871,877 ----
  /* In a VAR_DECL, nonzero means allocate static storage.
     In a FUNCTION_DECL, nonzero if function has been defined.
     In a CONSTRUCTOR, nonzero means allocate static storage.
+    In a ADDR_EXPR, nonzero means do not use a trampoline.
  
     ??? This is also used in lots of other nodes in unclear ways which
     should be cleaned up some day.  */
*** gcc/tree-nested.c.0	2007-10-22 08:27:44.595618376 +0200
--- gcc/tree-nested.c	2007-10-22 09:02:46.474033368 +0200
*************** convert_tramp_reference (tree *tp, int *
*** 1365,1370 ****
--- 1365,1374 ----
        if (DECL_NO_STATIC_CHAIN (decl))
  	break;
  
+       /* If we don't want a trampoline, then don't build one.  */
+       if (TREE_STATIC (t))
+ 	break;
+ 
        /* Lookup the immediate parent of the callee, as that's where
  	 we need to insert the trampoline.  */
        for (i = info; i->context != target_context; i = i->outer)
*** gcc/varasm.c.0	2007-10-22 08:38:28.315707128 +0200
--- gcc/varasm.c	2007-10-22 09:06:39.620589704 +0200
*************** initializer_constant_valid_p (tree value
*** 3730,3755 ****
  
      case ADDR_EXPR:
      case FDESC_EXPR:
!       value = staticp (TREE_OPERAND (value, 0));
!       if (value)
! 	{
! 	  /* "&(*a).f" is like unto pointer arithmetic.  If "a" turns out to
! 	     be a constant, this is old-skool offsetof-like nonsense.  */
! 	  if (TREE_CODE (value) == INDIRECT_REF
! 	      && TREE_CONSTANT (TREE_OPERAND (value, 0)))
! 	    return null_pointer_node;
! 	  /* Taking the address of a nested function involves a trampoline.  */
! 	  if (TREE_CODE (value) == FUNCTION_DECL
! 	      && ((decl_function_context (value) 
! 		   && !DECL_NO_STATIC_CHAIN (value))
! 		  || DECL_DLLIMPORT_P (value)))
! 	    return NULL_TREE;
! 	  /* "&{...}" requires a temporary to hold the constructed
! 	     object.  */
! 	  if (TREE_CODE (value) == CONSTRUCTOR)
! 	    return NULL_TREE;
! 	}
!       return value;
  
      case VIEW_CONVERT_EXPR:
      case NON_LVALUE_EXPR:
--- 3730,3759 ----
  
      case ADDR_EXPR:
      case FDESC_EXPR:
!       {
! 	tree op0 = staticp (TREE_OPERAND (value, 0));
! 	if (op0)
! 	  {
! 	    /* "&(*a).f" is like unto pointer arithmetic.  If "a" turns out
! 	       to be a constant, this is old-skool offsetof-like nonsense.  */
! 	    if (TREE_CODE (op0) == INDIRECT_REF
! 		&& TREE_CONSTANT (TREE_OPERAND (op0, 0)))
! 	      return null_pointer_node;
! 	    /* Taking the address of a nested function involves a trampoline,
! 	       unless we don't need or want one.  */
! 	    if (TREE_CODE (op0) == FUNCTION_DECL
! 		&& ((decl_function_context (op0) 
! 		     && !DECL_NO_STATIC_CHAIN (op0)
! 		     && !TREE_STATIC (value))
! 		    || DECL_DLLIMPORT_P (op0)))
! 	      return NULL_TREE;
! 	    /* "&{...}" requires a temporary to hold the constructed
! 	       object.  */
! 	    if (TREE_CODE (op0) == CONSTRUCTOR)
! 	      return NULL_TREE;
! 	  }
! 	return op0;
!       }
  
      case VIEW_CONVERT_EXPR:
      case NON_LVALUE_EXPR:
*** gcc/expmed.c.0	2007-11-16 08:58:30.552021416 +0100
--- gcc/expmed.c	2007-11-16 10:20:12.767771344 +0100
*************** store_fixed_bit_field (rtx op0, unsigned
*** 891,903 ****
  		      && bitpos + bitsize != GET_MODE_BITSIZE (mode));
  
        if (GET_MODE (value) != mode)
! 	{
! 	  if ((REG_P (value) || GET_CODE (value) == SUBREG)
! 	      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (value)))
! 	    value = gen_lowpart (mode, value);
! 	  else
! 	    value = convert_to_mode (mode, value, 1);
! 	}
  
        if (must_and)
  	value = expand_binop (mode, and_optab, value,
--- 891,897 ----
  		      && bitpos + bitsize != GET_MODE_BITSIZE (mode));
  
        if (GET_MODE (value) != mode)
! 	value = convert_to_mode (mode, value, 1);
  
        if (must_and)
  	value = expand_binop (mode, and_optab, value,
*************** extract_bit_field (rtx str_rtx, unsigned
*** 1243,1249 ****
  	       ? bitpos + bitsize == BITS_PER_WORD
  	       : bitpos == 0)))
        && ((!MEM_P (op0)
! 	   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),
  				     GET_MODE_BITSIZE (GET_MODE (op0)))
  	   && GET_MODE_SIZE (mode1) != 0
  	   && byte_offset % GET_MODE_SIZE (mode1) == 0)
--- 1237,1243 ----
  	       ? bitpos + bitsize == BITS_PER_WORD
  	       : bitpos == 0)))
        && ((!MEM_P (op0)
! 	   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode1),
  				     GET_MODE_BITSIZE (GET_MODE (op0)))
  	   && GET_MODE_SIZE (mode1) != 0
  	   && byte_offset % GET_MODE_SIZE (mode1) == 0)
*** gcc/common.opt.0	2007-11-17 15:21:04.000000000 +0100
--- gcc/common.opt	2007-11-17 17:29:41.000000000 +0100
*************** Wsystem-headers
*** 141,146 ****
--- 141,150 ----
  Common Var(warn_system_headers)
  Do not suppress warnings from system headers
  
+ Wtrampolines
+ Common Var(warn_trampolines)
+ Warn about trampolines generated for pointers to nested functions
+ 
  Wuninitialized
  Common Var(warn_uninitialized)
  Warn about uninitialized automatic variables
*************** ftracer
*** 882,887 ****
--- 886,895 ----
  Common Report Var(flag_tracer)
  Perform superblock formation via tail duplication
  
+ ftrampolines
+ Common Report Var(flag_trampolines) Init(0)
+ Always generate trampolines for pointers to nested functions
+ 
  ; Zero means that floating-point math operations cannot generate a
  ; (user-visible) trap.  This is the case, for example, in nonstop
  ; IEEE 754 arithmetic.
*** gcc/opts.c.0	2007-11-17 15:21:04.000000000 +0100
--- gcc/opts.c	2007-11-17 18:12:28.255017368 +0100
*************** decode_options (unsigned int argc, const
*** 967,972 ****
--- 967,977 ----
        flag_reorder_blocks_and_partition = 0;
        flag_reorder_blocks = 1;
      }
+ 
+ #if !USE_RUNTIME_DESCRIPTORS
+   /* Do not generate runtime descriptors if they are not requested.  */
+   flag_trampolines = 1;
+ #endif
  }
  
  /* Handle target- and language-independent options.  Return zero to
*** gcc/doc/invoke.texi.0	2007-11-17 15:21:04.000000000 +0100
--- gcc/doc/invoke.texi	2007-11-17 17:26:55.833408592 +0100
*************** Objective-C and Objective-C++ Dialects}.
*** 246,252 ****
  -Wsign-compare  -Wstack-protector @gol
  -Wstrict-aliasing -Wstrict-aliasing=2 @gol
  -Wswitch  -Wswitch-default  -Wswitch-enum @gol
! -Wsystem-headers  -Wtrigraphs  -Wundef  -Wuninitialized @gol
  -Wunknown-pragmas  -Wno-pragmas -Wunreachable-code @gol
  -Wunused  -Wunused-function  -Wunused-label  -Wunused-parameter @gol
  -Wunused-value  -Wunused-variable  -Wvariadic-macros @gol
--- 246,252 ----
  -Wsign-compare  -Wstack-protector @gol
  -Wstrict-aliasing -Wstrict-aliasing=2 @gol
  -Wswitch  -Wswitch-default  -Wswitch-enum @gol
! -Wsystem-headers  -Wtrampolines -Wtrigraphs  -Wundef  -Wuninitialized @gol
  -Wunknown-pragmas  -Wno-pragmas -Wunreachable-code @gol
  -Wunused  -Wunused-function  -Wunused-label  -Wunused-parameter @gol
  -Wunused-value  -Wunused-variable  -Wvariadic-macros @gol
*************** See S/390 and zSeries Options.
*** 767,773 ****
  -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fleading-underscore @gol
! -ftls-model=@var{model} @gol
  -ftrapv  -fwrapv  -fbounds-check @gol
  -fvisibility}
  @end table
--- 767,773 ----
  -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
  -fno-stack-limit  -fargument-alias  -fargument-noalias @gol
  -fargument-noalias-global  -fleading-underscore @gol
! -ftls-model=@var{model} -ftrampolines @gol
  -ftrapv  -fwrapv  -fbounds-check @gol
  -fvisibility}
  @end table
*************** Make all warnings into errors.
*** 3439,3444 ****
--- 3439,3453 ----
  This option is only active when @option{-fstack-protector} is active.  It
  warns about functions that will not be protected against stack smashing.
  
+ @item -Wtrampolines
+ Warn about trampolines generated for pointers to nested functions.
+ 
+ A trampoline is a small piece of data or code that is created at run
+ time on the stack when the address of a nested function is taken, and
+ is used to call the nested function indirectly.  For some targets, it
+ is made up of data only and thus requires no special treatment.  But,
+ for most targets, it is made up of code and thus requires the stack
+ to be made executable in order for the program to work properly.
  @end table
  
  @node Debugging Options
*************** The @var{model} argument should be one o
*** 13320,13325 ****
--- 13506,13535 ----
  The default without @option{-fpic} is @code{initial-exec}; with
  @option{-fpic} the default is @code{global-dynamic}.
  
+ @item -ftrampolines
+ Always generate trampolines for pointers to nested functions.
+ 
+ A trampoline is a small piece of data or code that is created at run
+ time on the stack when the address of a nested function is taken, and
+ is used to call the nested function indirectly.  For some targets, it
+ is made up of data only and thus requires no special treatment.  But,
+ for most targets, it is made up of code and thus requires the stack
+ to be made executable in order for the program to work properly.
+ 
+ @option{-fno-trampolines} is enabled by default to let the compiler avoid
+ generating them if it computes that this is safe, on a case by case basis,
+ and replace them with descriptors.  Descriptors are always made up of data
+ only, but the generated code must be prepared to deal with them.
+ 
+ This option has no effects for any other languages than Ada as of this
+ writing.  Moreover, code compiled with @option{-ftrampolines} and code
+ compiled with @option{-fno-trampolines} are not binary compatible if
+ nested functions are present.  This option must therefore be used on
+ a program-wide basis and be manipulated with extreme care.
+ 
+ This option has no effects for targets whose trampolines are made up of
+ data only, for example IA-64 targets, AIX or VMS platforms.
+ 
  @item -fvisibility=@var{default|internal|hidden|protected}
  @opindex fvisibility
  Set the default ELF image symbol visibility to the specified option---all
*** gcc/doc/tm.texi.0	2007-11-17 15:21:04.000000000 +0100
--- gcc/doc/tm.texi	2007-11-17 18:18:18.814724192 +0100
*************** global.  Then trampolines can use that l
*** 4770,4775 ****
--- 4770,4787 ----
  special assembler code.
  @end defmac
  
+ @defmac USE_RUNTIME_DESCRIPTORS
+ Define this macro to 1 if the target will benefit from the use of runtime
+ descriptors instead of trampolines.  Such descriptors are created at run
+ time on the stack and made up of data only, but the generated code must be
+ prepared to deal with them.  Define this macro to 0 if the target already
+ uses descriptors for its standard calling sequence, which very likely means
+ that trampolines need not reside on the stack.
+ 
+ The macro should be defined to 1 for targets whose trampolines reside on
+ the stack, thus requiring it to be made executable.
+ @end defmac
+ 
  @node Library Calls
  @section Implicit Calls to Library Routines
  @cindex library subroutine names
*** gcc/builtins.def.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/builtins.def	2007-11-17 15:21:14.000000000 +0100
*************** DEF_C99_BUILTIN        (BUILT_IN__EXIT2,
*** 662,667 ****
--- 662,669 ----
  /* Implementing nested functions.  */
  DEF_BUILTIN_STUB (BUILT_IN_INIT_TRAMPOLINE, "__builtin_init_trampoline")
  DEF_BUILTIN_STUB (BUILT_IN_ADJUST_TRAMPOLINE, "__builtin_adjust_trampoline")
+ DEF_BUILTIN_STUB (BUILT_IN_INIT_DESCRIPTOR, "__builtin_init_descriptor")
+ DEF_BUILTIN_STUB (BUILT_IN_ADJUST_DESCRIPTOR, "__builtin_adjust_descriptor")
  DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, "__builtin_nonlocal_goto")
  
  /* Implementing __builtin_setjmp.  */
*** gcc/builtins.c.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/builtins.c	2007-11-17 18:08:02.223460312 +0100
*************** expand_builtin_init_trampoline (tree arg
*** 5253,5259 ****
    emit_block_move (blktramp, assemble_trampoline_template (),
  		   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
  #endif
-   trampolines_created = 1;
    INITIALIZE_TRAMPOLINE (r_tramp, r_func, r_chain);
  
    return const0_rtx;
--- 5253,5258 ----
*************** expand_builtin_adjust_trampoline (tree a
*** 5276,5281 ****
--- 5275,5332 ----
    return tramp;
  }
  
+ #if USE_RUNTIME_DESCRIPTORS
+ 
+ /* Expand a call to the builtin descriptor initialization routine.
+    A descriptor is made up of a couple of pointers to the static
+    chain and the code entry in this order.  */
+ 
+ static rtx
+ expand_builtin_init_descriptor (tree arglist)
+ {
+   tree t_tramp, t_func, t_chain;
+   rtx r_tramp, r_func, r_chain;
+ 
+   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE,
+ 			 POINTER_TYPE, VOID_TYPE))
+     return NULL_RTX;
+ 
+   t_tramp = TREE_VALUE (arglist);
+   arglist = TREE_CHAIN (arglist);
+   t_func = TREE_VALUE (arglist);
+   arglist = TREE_CHAIN (arglist);
+   t_chain = TREE_VALUE (arglist);
+ 
+   r_tramp = expand_expr (t_tramp, NULL_RTX, VOIDmode, 0);
+   r_func = expand_expr (t_func, NULL_RTX, VOIDmode, 0);
+   r_chain = expand_expr (t_chain, NULL_RTX, VOIDmode, 0);
+ 
+   /* Generate insns to initialize the descriptor.  */
+   emit_move_insn (gen_rtx_MEM (Pmode, r_tramp), r_chain);
+   emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (r_tramp, UNITS_PER_WORD)),
+ 		  r_func);
+ 
+   return const0_rtx;
+ }
+ 
+ /* Expand a call to the builtin descriptor adjustment routine.  */
+ 
+ static rtx
+ expand_builtin_adjust_descriptor (tree arglist)
+ {
+   rtx tramp;
+ 
+   if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
+     return NULL_RTX;
+ 
+   tramp = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
+ 
+   /* Unalign the descriptor to allow runtime identification.  */
+   return force_operand (plus_constant (tramp, 1), NULL_RTX);
+ }
+ 
+ #endif /* USE_RUNTIME_DESCRIPTORS */
+ 
  /* Expand a call to the built-in signbit, signbitf or signbitl function.
     Return NULL_RTX if a normal call should be emitted rather than expanding
     the function in-line.  EXP is the expression that is a call to the builtin
*************** expand_builtin (tree exp, rtx target, rt
*** 6310,6315 ****
--- 6361,6379 ----
      case BUILT_IN_ADJUST_TRAMPOLINE:
        return expand_builtin_adjust_trampoline (arglist);
  
+     case BUILT_IN_INIT_DESCRIPTOR:
+ #if USE_RUNTIME_DESCRIPTORS
+       return expand_builtin_init_descriptor (arglist);
+ #else
+       gcc_unreachable ();
+ #endif
+     case BUILT_IN_ADJUST_DESCRIPTOR:
+ #if USE_RUNTIME_DESCRIPTORS
+       return expand_builtin_adjust_descriptor (arglist);
+ #else
+       gcc_unreachable ();
+ #endif
+ 
      case BUILT_IN_FORK:
      case BUILT_IN_EXECL:
      case BUILT_IN_EXECV:
*** gcc/calls.c.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/calls.c	2007-11-17 18:08:37.042167064 +0100
*************** static void restore_fixed_argument_area 
*** 165,181 ****
  
  rtx
  prepare_call_address (rtx funexp, rtx static_chain_value,
! 		      rtx *call_fusage, int reg_parm_seen, int sibcallp)
  {
    /* Make a valid memory address and copy constants through pseudo-regs,
       but not for a constant address if -fno-function-cse.  */
    if (GET_CODE (funexp) != SYMBOL_REF)
!     /* If we are using registers for parameters, force the
!        function address into a register now.  */
!     funexp = ((SMALL_REGISTER_CLASSES && reg_parm_seen)
! 	      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))
! 	      : memory_address (FUNCTION_MODE, funexp));
!   else if (! sibcallp)
      {
  #ifndef NO_FUNCTION_CSE
        if (optimize && ! flag_no_function_cse)
--- 165,227 ----
  
  rtx
  prepare_call_address (rtx funexp, rtx static_chain_value,
! 		      rtx *call_fusage, int reg_parm_seen, int flags)
  {
    /* Make a valid memory address and copy constants through pseudo-regs,
       but not for a constant address if -fno-function-cse.  */
    if (GET_CODE (funexp) != SYMBOL_REF)
!     {
! #if USE_RUNTIME_DESCRIPTORS
!       /* If it's an indirect call by descriptor, generate code to perform
! 	 runtime identification of the pointer and load the descriptor.  */
!       if (!flag_trampolines && (flags & ECF_BY_DESCRIPTOR))
! 	{
! 	  rtx mask, insn, mem, call_lab = gen_label_rtx ();
! 
! 	  /* Avoid long live ranges around function calls.  */
! 	  funexp = copy_to_mode_reg (Pmode, funexp);
! 
! 	  if (REG_P (static_chain_rtx))
! 	    emit_insn (gen_rtx_CLOBBER (VOIDmode, static_chain_rtx));
! 
! 	  /* Emit the runtime identification pattern.  */
! 	  mask = gen_rtx_AND (Pmode, funexp, const1_rtx);
! 	  emit_cmp_and_jump_insns (mask, const0_rtx, EQ, NULL_RTX, Pmode, 1,
! 				   call_lab);
! 
! 	  /* Statically predict the branch to very likely taken.  */
! 	  insn = get_last_insn ();
! 	  if (JUMP_P (insn))
! 	    predict_insn_def (insn, PRED_BUILTIN_EXPECT, TAKEN);
! 
! 	  /* Load the descriptor.  */
! 	  mem = gen_rtx_MEM (Pmode, plus_constant (funexp, -1));
! 	  MEM_NOTRAP_P (mem) = 1;
! 	  emit_move_insn (static_chain_rtx, mem);
! 	  mem = gen_rtx_MEM (Pmode,
! 			     plus_constant (funexp, UNITS_PER_WORD - 1));
! 	  MEM_NOTRAP_P (mem) = 1;
! 	  emit_move_insn (funexp, mem);
! 
! 	  emit_label (call_lab);
! 
! 	  if (REG_P (static_chain_rtx))
! 	    use_reg (call_fusage, static_chain_rtx);
! 
! 	  /* Make sure we're not going to be overwritten below.  */
! 	  gcc_assert (!static_chain_value);
! 	}
! #endif /* USE_RUNTIME_DESCRIPTORS */
! 
!       /* If we are using registers for parameters, force the
! 	 function address into a register now.  */
!       funexp = ((SMALL_REGISTER_CLASSES && reg_parm_seen)
! 		? force_not_mem (memory_address (FUNCTION_MODE, funexp))
! 		: memory_address (FUNCTION_MODE, funexp));
! 
!     }
! 
!   else if (!(flags & ECF_SIBCALL))
      {
  #ifndef NO_FUNCTION_CSE
        if (optimize && ! flag_no_function_cse)
*************** call_expr_flags (tree t)
*** 626,636 ****
      flags = flags_from_decl_or_type (decl);
    else
      {
!       t = TREE_TYPE (TREE_OPERAND (t, 0));
!       if (t && TREE_CODE (t) == POINTER_TYPE)
! 	flags = flags_from_decl_or_type (TREE_TYPE (t));
        else
  	flags = 0;
      }
  
    return flags;
--- 672,684 ----
      flags = flags_from_decl_or_type (decl);
    else
      {
!       tree type = TREE_TYPE (TREE_OPERAND (t, 0));
!       if (type && TREE_CODE (type) == POINTER_TYPE)
! 	flags = flags_from_decl_or_type (TREE_TYPE (type));
        else
  	flags = 0;
+       if (CALL_EXPR_BY_DESCRIPTOR (t))
+ 	flags |= ECF_BY_DESCRIPTOR;
      }
  
    return flags;
*************** expand_call (tree exp, rtx target, int i
*** 1968,1973 ****
--- 2016,2023 ----
      {
        fntype = TREE_TYPE (TREE_TYPE (p));
        flags |= flags_from_decl_or_type (fntype);
+       if (CALL_EXPR_BY_DESCRIPTOR (exp))
+ 	flags |= ECF_BY_DESCRIPTOR;
      }
  
    struct_value = targetm.calls.struct_value_rtx (fntype, 0);
*************** expand_call (tree exp, rtx target, int i
*** 2711,2717 ****
  	}
  
        funexp = prepare_call_address (funexp, static_chain_value,
! 				     &call_fusage, reg_parm_seen, pass == 0);
  
        load_register_parameters (args, num_actuals, &call_fusage, flags,
  				pass == 0, &sibcall_failure);
--- 2761,2767 ----
  	}
  
        funexp = prepare_call_address (funexp, static_chain_value,
! 				     &call_fusage, reg_parm_seen, flags);
  
        load_register_parameters (args, num_actuals, &call_fusage, flags,
  				pass == 0, &sibcall_failure);
*** gcc/rtlanal.c.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/rtlanal.c	2007-11-17 18:10:50.368898320 +0100
*************** find_first_parameter_load (rtx call_insn
*** 3360,3365 ****
--- 3360,3372 ----
           CODE_LABEL.  */
        if (LABEL_P (before))
  	{
+ #if USE_RUNTIME_DESCRIPTORS
+ 	  /* Look for the conditional load of the static chain register.  */
+ 	  if (!boundary
+ 	      && parm.nregs == 1
+ 	      && TEST_HARD_REG_BIT (parm.regs, STATIC_CHAIN_REGNUM))
+ 	    continue;
+ #endif
  	  gcc_assert (before == boundary);
  	  break;
  	}
*** gcc/tree.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/tree.h	2007-11-17 15:21:14.000000000 +0100
*************** struct tree_common GTY(())
*** 343,348 ****
--- 343,352 ----
            ..._TYPE
         SAVE_EXPR_RESOLVED_P in
  	  SAVE_EXPR
+        FUNC_ADDR_BY_DESCRIPTOR in
+ 	  ADDR_EXPR
+        CALL_EXPR_BY_DESCRIPTOR in
+ 	  CALL_EXPR
  
     private_flag:
  
*************** extern void tree_operand_check_failed (i
*** 936,941 ****
--- 940,955 ----
  #define SAVE_EXPR_RESOLVED_P(NODE) \
    (TREE_CHECK (NODE, SAVE_EXPR)->common.public_flag)
  
+ /* In an ADDR_EXPR, indicates that this is a pointer to nested function
+    represented by a descriptor instead of a trampoline.  */
+ #define FUNC_ADDR_BY_DESCRIPTOR(NODE) \
+   (TREE_CHECK (NODE, ADDR_EXPR)->common.public_flag)
+ 
+ /* In a CALL_EXPR, indicates that this is an indirect call for which
+    pointers to nested function are descriptors instead of trampolines.  */
+ #define CALL_EXPR_BY_DESCRIPTOR(NODE) \
+   (TREE_CHECK (NODE, CALL_EXPR)->common.public_flag)
+ 
  /* In any expression, decl, or constant, nonzero means it has side effects or
     reevaluation of the whole expression could produce a different value.
     This is set if any subexpression is a function call, a side effect or a
*************** extern rtx emit_line_note (location_t);
*** 4104,4109 ****
--- 4118,4125 ----
  /* Function does not read or write memory (but may have side effects, so
     it does not necessarily fit ECF_CONST).  */
  #define ECF_NOVOPS		1024
+ /* Nonzero if this is an indirect call by descriptor.  */
+ #define ECF_BY_DESCRIPTOR	2048
  
  extern int flags_from_decl_or_type (tree);
  extern int call_expr_flags (tree);
*** gcc/tree.c.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/tree.c	2007-11-17 15:21:14.000000000 +0100
*************** build_common_builtin_nodes (void)
*** 6616,6621 ****
--- 6616,6636 ----
  
    tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
    tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
+   tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
+   ftype = build_function_type (void_type_node, tmp);
+   local_define_builtin ("__builtin_init_descriptor", ftype,
+ 			BUILT_IN_INIT_DESCRIPTOR,
+ 			"__builtin_init_descriptor", ECF_NOTHROW);
+ 
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   ftype = build_function_type (ptr_type_node, tmp);
+   local_define_builtin ("__builtin_adjust_descriptor", ftype,
+ 			BUILT_IN_ADJUST_DESCRIPTOR,
+ 			"__builtin_adjust_descriptor",
+ 			ECF_CONST | ECF_NOTHROW);
+ 
+   tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);
+   tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);
    ftype = build_function_type (void_type_node, tmp);
    local_define_builtin ("__builtin_nonlocal_goto", ftype,
  			BUILT_IN_NONLOCAL_GOTO,
*** gcc/tree-nested.c.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/tree-nested.c	2007-11-17 16:56:14.000000000 +0100
***************
*** 33,38 ****
--- 33,39 ----
  #include "tree-flow.h"
  #include "cgraph.h"
  #include "expr.h"
+ #include "toplev.h"
  #include "langhooks.h"
  #include "ggc.h"
  
*************** struct nesting_info GTY ((chain_next ("%
*** 101,106 ****
--- 102,108 ----
  
    bool any_parm_remapped;
    bool any_tramp_created;
+   bool any_descr_created;
    bool reachable;
    bool address_taken;
  };
*************** static GTY(()) tree trampoline_type;
*** 458,465 ****
  static tree
  get_trampoline_type (void)
  {
-   tree record, t;
    unsigned align, size;
  
    if (trampoline_type)
      return trampoline_type;
--- 460,467 ----
  static tree
  get_trampoline_type (void)
  {
    unsigned align, size;
+   tree t;
  
    if (trampoline_type)
      return trampoline_type;
*************** get_trampoline_type (void)
*** 481,504 ****
    DECL_ALIGN (t) = align;
    DECL_USER_ALIGN (t) = 1;
  
!   record = make_node (RECORD_TYPE);
!   TYPE_NAME (record) = get_identifier ("__builtin_trampoline");
!   TYPE_FIELDS (record) = t;
!   layout_type (record);
  
!   return record;
  }
  
! /* Given DECL, a nested function, find or create a field in the non-local
!    frame structure for a trampoline for this function.  */
  
  static tree
! lookup_tramp_for_decl (struct nesting_info *info, tree decl,
! 		       enum insert_option insert)
  {
    struct var_map_elt *elt, dummy;
    void **slot;
-   tree field;
  
    dummy.old = decl;
    slot = htab_find_slot (info->var_map, &dummy, insert);
--- 483,531 ----
    DECL_ALIGN (t) = align;
    DECL_USER_ALIGN (t) = 1;
  
!   trampoline_type = make_node (RECORD_TYPE);
!   TYPE_NAME (trampoline_type) = get_identifier ("__trampoline");
!   TYPE_FIELDS (trampoline_type) = t;
!   layout_type (trampoline_type);
  
!   return trampoline_type;
  }
  
! /* Build or return the type used to represent a nested function descriptor.  */
! 
! static GTY(()) tree descriptor_type;
  
  static tree
! get_descriptor_type (void)
! {
!   tree t;
! 
!   if (descriptor_type)
!     return descriptor_type;
! 
!   t = build_index_type (build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1));
!   t = build_array_type (char_type_node, t);
!   t = build_decl (FIELD_DECL, get_identifier ("__data"), t);
!   DECL_ALIGN (t) = BITS_PER_WORD;
!   DECL_USER_ALIGN (t) = 1;
! 
!   descriptor_type = make_node (RECORD_TYPE);
!   TYPE_NAME (descriptor_type) = get_identifier ("__descriptor");
!   TYPE_FIELDS (descriptor_type) = t;
!   layout_type (descriptor_type);
! 
!   return descriptor_type;
! }
! 
! /* Given DECL, a nested function, find or create an element in the
!    var map for this function.  */
! 
! static struct var_map_elt *
! lookup_element_for_decl (struct nesting_info *info, tree decl,
! 			 enum insert_option insert)
  {
    struct var_map_elt *elt, dummy;
    void **slot;
  
    dummy.old = decl;
    slot = htab_find_slot (info->var_map, &dummy, insert);
*************** lookup_tramp_for_decl (struct nesting_in
*** 507,535 ****
        gcc_assert (insert != INSERT);
        return NULL;
      }
    elt = *slot;
  
    if (!elt && insert == INSERT)
      {
!       field = make_node (FIELD_DECL);
!       DECL_NAME (field) = DECL_NAME (decl);
!       TREE_TYPE (field) = get_trampoline_type ();
!       TREE_ADDRESSABLE (field) = 1;
! 
!       insert_field_into_struct (get_frame_type (info), field);
! 
!       elt = ggc_alloc (sizeof (*elt));
        elt->old = decl;
!       elt->new = field;
        *slot = elt;
  
        info->any_tramp_created = true;
      }
-   else
-     field = elt ? elt->new : NULL;
  
    return field;
! } 
  
  /* Build or return the field within the non-local frame state that holds
     the non-local goto "jmp_buf".  The buffer itself is maintained by the
--- 534,618 ----
        gcc_assert (insert != INSERT);
        return NULL;
      }
+ 
    elt = *slot;
  
    if (!elt && insert == INSERT)
      {
!       elt = ggc_alloc (sizeof (struct var_map_elt));
        elt->old = decl;
!       elt->new = build_tree_list (NULL_TREE, NULL_TREE);
        *slot = elt;
+     }
+ 
+   return elt;
+ }
+ 
+ /* Given DECL, a nested function, create a field in the non-local
+    frame structure for this function.  */
+ 
+ static tree
+ create_field_for_decl (struct nesting_info *info, tree decl, tree type)
+ {
+   tree field = make_node (FIELD_DECL);
+   DECL_NAME (field) = DECL_NAME (decl);
+   TREE_TYPE (field) = type;
+   TREE_ADDRESSABLE (field) = 1;
+   insert_field_into_struct (get_frame_type (info), field);
+   return field;
+ }
+ 
+ /* Given DECL, a nested function, find or create a field in the non-local
+    frame structure for a trampoline for this function.  */
+ 
+ static tree
+ lookup_tramp_for_decl (struct nesting_info *info, tree decl,
+ 		       enum insert_option insert)
+ {
+   struct var_map_elt *elt;
+   tree field;
  
+   elt = lookup_element_for_decl (info, decl, insert);
+   if (!elt)
+     return NULL_TREE;
+ 
+   field = TREE_PURPOSE (elt->new);
+ 
+   if (!field && insert == INSERT)
+     {
+       field = create_field_for_decl (info, decl, get_trampoline_type ());
+       TREE_PURPOSE (elt->new) = field;
        info->any_tramp_created = true;
      }
  
    return field;
! }
! 
! /* Given DECL, a nested function, find or create a field in the non-local
!    frame structure for a descriptor for this function.  */
! 
! static tree
! lookup_descr_for_decl (struct nesting_info *info, tree decl,
! 		       enum insert_option insert)
! {
!   struct var_map_elt *elt;
!   tree field;
! 
!   elt = lookup_element_for_decl (info, decl, insert);
!   if (!elt)
!     return NULL_TREE;
! 
!   field = TREE_VALUE (elt->new);
! 
!   if (!field && insert == INSERT)
!     {
!       field = create_field_for_decl (info, decl, get_descriptor_type ());
!       TREE_VALUE (elt->new) = field;
!       info->any_descr_created = true;
!     }
! 
!   return field;
! }
  
  /* Build or return the field within the non-local frame state that holds
     the non-local goto "jmp_buf".  The buffer itself is maintained by the
*************** convert_tramp_reference (tree *tp, int *
*** 1340,1345 ****
--- 1423,1429 ----
    struct walk_stmt_info *wi = data;
    struct nesting_info *info = wi->info, *i;
    tree t = *tp, decl, target_context, x, arg;
+   bool descr;
  
    *walk_subtrees = 0;
    switch (TREE_CODE (t))
*************** convert_tramp_reference (tree *tp, int *
*** 1373,1379 ****
  	 we need to insert the trampoline.  */
        for (i = info; i->context != target_context; i = i->outer)
  	continue;
!       x = lookup_tramp_for_decl (i, decl, INSERT);
  
        /* Compute the address of the field holding the trampoline.  */
        x = get_frame_field (info, target_context, x, &wi->tsi);
--- 1457,1498 ----
  	 we need to insert the trampoline.  */
        for (i = info; i->context != target_context; i = i->outer)
  	continue;
! 
!       /* Decide whether to generate a descriptor or a trampoline. */
!       descr = !flag_trampolines && FUNC_ADDR_BY_DESCRIPTOR (t);
!       if (descr)
! 	x = lookup_descr_for_decl (i, decl, INSERT);
!       else
! 	{
! 	  x = lookup_tramp_for_decl (i, decl, INSERT);
! 	  trampolines_created = 1;
! 	  if (warn_trampolines)
! 	    {
! #ifdef USE_MAPPED_LOCATION
! 	      source_location location = EXPR_LOCATION (t);
! #else
! 	      location_t * locus = EXPR_LOCUS (t);
! #endif
! 	      tree save_context = current_function_decl;
! 	      current_function_decl = info->context;
! 	      warning (OPT_Wtrampolines, "trampoline generated for %q+F",
! 		       decl);
! #ifdef USE_MAPPED_LOCATION
! 	      if (location == UNKNOWN_LOCATION)
! #else
! 	      if (locus == NULL)
! #endif
! 	        warning (OPT_Wtrampolines, "address taken from here");
! 	      else
! 		warning (OPT_Wtrampolines, "%Haddress taken from here",
! #ifdef USE_MAPPED_LOCATION
! 			 &location);
! #else
! 			 locus);
! #endif
! 	      current_function_decl = save_context;
! 	    }
! 	}
  
        /* Compute the address of the field holding the trampoline.  */
        x = get_frame_field (info, target_context, x, &wi->tsi);
*************** convert_tramp_reference (tree *tp, int *
*** 1383,1389 ****
  
        /* Do machine-specific ugliness.  Normally this will involve
  	 computing extra alignment, but it can really be anything.  */
!       x = implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE];
        x = build_function_call_expr (x, arg);
        x = init_tmp_var (info, x, &wi->tsi);
  
--- 1502,1511 ----
  
        /* Do machine-specific ugliness.  Normally this will involve
  	 computing extra alignment, but it can really be anything.  */
!       if (descr)
! 	x = implicit_built_in_decls[BUILT_IN_ADJUST_DESCRIPTOR];
!       else
! 	x = implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE];
        x = build_function_call_expr (x, arg);
        x = init_tmp_var (info, x, &wi->tsi);
  
*************** convert_all_function_calls (struct nesti
*** 1484,1489 ****
--- 1606,1637 ----
      }
  }
  
+ /* Given DECL, a nested function, build an initialization call for FIELD,
+    the trampoline or descriptor for DECL, using FUNC as the function.  */
+ 
+ static tree
+ build_init_call_expr (struct nesting_info *info, tree decl, tree field,
+ 		      tree func)
+ {
+   tree x, arg;
+ 
+   if (DECL_NO_STATIC_CHAIN (decl))
+     x = null_pointer_node;
+   else
+     x = build_addr (info->frame_decl, info->context);
+   arg = tree_cons (NULL, x, NULL);
+ 
+   x = build_addr (decl, info->context);
+   arg = tree_cons (NULL, x, arg);
+ 
+   x = build (COMPONENT_REF, TREE_TYPE (field),
+ 	     info->frame_decl, field, NULL_TREE);
+   x = build_addr (x, info->context);
+   arg = tree_cons (NULL, x, arg);
+ 
+   return build_function_call_expr (func, arg);
+ }
+ 
  /* Do "everything else" to clean up or complete state collected by the
     various walking passes -- lay out the types and decls, generate code
     to initialize the frame decl, store critical expressions in the
*************** finalize_nesting_tree_1 (struct nesting_
*** 1551,1579 ****
        struct nesting_info *i;
        for (i = root->inner; i ; i = i->next)
  	{
! 	  tree arg, x, field;
  
  	  field = lookup_tramp_for_decl (root, i->context, NO_INSERT);
  	  if (!field)
  	    continue;
  
! 	  if (DECL_NO_STATIC_CHAIN (i->context))
! 	    x = null_pointer_node;
! 	  else
! 	    x = build_addr (root->frame_decl, context);
! 	  arg = tree_cons (NULL, x, NULL);
! 
! 	  x = build_addr (i->context, context);
! 	  arg = tree_cons (NULL, x, arg);
  
! 	  x = build (COMPONENT_REF, TREE_TYPE (field),
! 		     root->frame_decl, field, NULL_TREE);
! 	  x = build_addr (x, context);
! 	  arg = tree_cons (NULL, x, arg);
  
! 	  x = implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE];
! 	  x = build_function_call_expr (x, arg);
  
  	  append_to_statement_list (x, &stmt_list);
  	}
      }
--- 1699,1730 ----
        struct nesting_info *i;
        for (i = root->inner; i ; i = i->next)
  	{
! 	  tree field, x;
  
  	  field = lookup_tramp_for_decl (root, i->context, NO_INSERT);
  	  if (!field)
  	    continue;
  
! 	  x = implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE];
! 	  x = build_init_call_expr (root, i->context, field, x);
! 	  append_to_statement_list (x, &stmt_list);
! 	}
!     }
  
!   /* If descriptors were created, then we need to initialize them.  */
!   if (root->any_descr_created)
!     {
!       struct nesting_info *i;
!       for (i = root->inner; i ; i = i->next)
! 	{
! 	  tree field, x;
  
! 	  field = lookup_descr_for_decl (root, i->context, NO_INSERT);
! 	  if (!field)
! 	    continue;
  
+ 	  x = implicit_built_in_decls[BUILT_IN_INIT_DESCRIPTOR];
+ 	  x = build_init_call_expr (root, i->context, field, x);
  	  append_to_statement_list (x, &stmt_list);
  	}
      }
*** gcc/toplev.c.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/toplev.c	2007-11-17 15:21:14.000000000 +0100
*************** process_options (void)
*** 1618,1623 ****
--- 1618,1628 ----
    else
      aux_base_name = "gccaux";
  
+   /* Force minimum function alignment if using the least significant
+      bit to distinguish descriptor addresses from code addresses.  */
+   if (!flag_trampolines && force_align_functions_log < 1)
+     force_align_functions_log = 1;
+ 
    /* Set up the align_*_log variables, defaulting them to 1 if they
       were still unset.  */
    if (align_loops <= 0) align_loops = 1;
*** gcc/defaults.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/defaults.h	2007-11-17 15:21:14.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 831,840 ****
  #define CASE_VECTOR_PC_RELATIVE 0
  #endif
  
! /* Assume that trampolines need function alignment.  */
  #ifndef TRAMPOLINE_ALIGNMENT
  #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY
  #endif
  
  /* Register mappings for target machines without register windows.  */
  #ifndef INCOMING_REGNO
--- 831,845 ----
  #define CASE_VECTOR_PC_RELATIVE 0
  #endif
  
! /* Assume that trampolines need function alignment but make sure that
!    they are overaligned like code if runtime descriptors are used.  */
  #ifndef TRAMPOLINE_ALIGNMENT
+ #if USE_RUNTIME_DESCRIPTORS && (FUNCTION_BOUNDARY < 16)
+ #define TRAMPOLINE_ALIGNMENT 16
+ #else
  #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY
  #endif
+ #endif
  
  /* Register mappings for target machines without register windows.  */
  #ifndef INCOMING_REGNO
*** gcc/config/alpha/alpha.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/alpha/alpha.h	2007-11-17 15:21:14.000000000 +0100
*************** do {						\
*** 993,998 ****
--- 993,1002 ----
  #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
    alpha_initialize_trampoline (TRAMP, FNADDR, CXT, 16, 24, 8)
  
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
+ 
  /* A C expression whose value is RTL representing the value of the return
     address for the frame COUNT steps up from the current frame.
     FRAMEADDR is the frame pointer of the COUNT frame, or the frame pointer of
*** gcc/config/alpha/vms.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/alpha/vms.h	2007-11-17 18:25:44.298000440 +0100
*************** do {									\
*** 294,299 ****
--- 294,304 ----
  #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
    alpha_initialize_trampoline (TRAMP, FNADDR, CXT, 16, 24, -1)
  
+ /* VMS already uses descriptors for its standard calling sequence.  */
+ 
+ #undef USE_RUNTIME_DESCRIPTORS
+ #define USE_RUNTIME_DESCRIPTORS 0
+ 
  /* Control how constructors and destructors are emitted.  */
  #define TARGET_ASM_CONSTRUCTOR  vms_asm_out_constructor
  #define TARGET_ASM_DESTRUCTOR   vms_asm_out_destructor
*** gcc/config/i386/i386.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/i386/i386.h	2007-11-17 15:21:14.000000000 +0100
*************** typedef struct ix86_args {
*** 1567,1572 ****
--- 1567,1576 ----
  
  #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
    x86_initialize_trampoline ((TRAMP), (FNADDR), (CXT))
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Definitions for register eliminations.
  
*** gcc/config/i386/i386.md.0	2008-08-22 15:55:22.000000000 +0200
--- gcc/config/i386/i386.md	2008-08-22 16:00:25.000000000 +0200
***************
*** 14009,14015 ****
    [(set_attr "type" "call")])
  
  (define_insn "*sibcall_1"
!   [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,c,d,a"))
  	 (match_operand 1 "" ""))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
--- 14009,14015 ----
    [(set_attr "type" "call")])
  
  (define_insn "*sibcall_1"
!   [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,!c,d,a"))
  	 (match_operand 1 "" ""))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
***************
*** 20333,20339 ****
  
  (define_insn "*sibcall_value_1"
    [(set (match_operand 0 "" "")
! 	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,c,d,a"))
  	      (match_operand:SI 2 "" "")))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
--- 20333,20339 ----
  
  (define_insn "*sibcall_value_1"
    [(set (match_operand 0 "" "")
! 	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,!c,d,a"))
  	      (match_operand:SI 2 "" "")))]
    "SIBLING_CALL_P (insn) && !TARGET_64BIT"
  {
*** gcc/config/ia64/ia64.h.0	2007-11-17 18:20:22.423932736 +0100
--- gcc/config/ia64/ia64.h	2007-11-17 18:26:10.546010136 +0100
*************** do {									\
*** 1332,1337 ****
--- 1332,1341 ----
  
  #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \
    ia64_initialize_trampoline((ADDR), (FNADDR), (STATIC_CHAIN))
+ 
+ /* IA-64 already uses descriptors for its standard calling sequence.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 0
  
  /* Addressing Modes */
  
*** gcc/config/mips/mips.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/mips/mips.h	2007-11-17 15:21:14.000000000 +0100
*************** typedef struct mips_args {
*** 2217,2222 ****
--- 2217,2226 ----
  		       GEN_INT (TRAMPOLINE_SIZE), TYPE_MODE (integer_type_node),\
  		       GEN_INT (3), TYPE_MODE (integer_type_node));	    \
  }
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Addressing modes, and classification of registers for them.  */
  
*** gcc/config/pa/pa.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/pa/pa.h	2007-11-17 15:21:14.000000000 +0100
*************** extern int may_call_alloca;
*** 1028,1033 ****
--- 1028,1037 ----
  #define TRAMPOLINE_ADJUST_ADDRESS(ADDR) \
    if (!TARGET_64BIT) (ADDR) = memory_address (Pmode, plus_constant ((ADDR), 46))
  
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
+ 
  /* Implement `va_start' for varargs and stdarg.  */
  
  #define EXPAND_BUILTIN_VA_START(valist, nextarg) \
*** gcc/config/rs6000/rs6000.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/rs6000/rs6000.h	2007-11-17 15:21:14.000000000 +0100
*************** typedef struct rs6000_args
*** 1581,1586 ****
--- 1581,1590 ----
  
  #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)		\
    rs6000_initialize_trampoline (ADDR, FNADDR, CXT)
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Definitions for __builtin_return_address and __builtin_frame_address.
     __builtin_return_address (0) should give link register (65), enable
*** gcc/config/rs6000/aix.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/rs6000/aix.h	2007-11-17 18:26:03.592067296 +0100
***************
*** 269,271 ****
--- 269,275 ----
     collection activated.  */
  #define DWARF2_EMIT_FRAME_TABLE_ASM_REF rs6000_aix_emit_frame_table_asm_ref
  
+ /* AIX already uses descriptors for its standard calling sequence.  */
+ 
+ #undef USE_RUNTIME_DESCRIPTORS
+ #define USE_RUNTIME_DESCRIPTORS 0
*** gcc/config/sparc/sparc.h.0	2007-11-17 15:21:05.000000000 +0100
--- gcc/config/sparc/sparc.h	2007-11-17 15:21:14.000000000 +0100
*************** do {									\
*** 1676,1681 ****
--- 1676,1685 ----
        sparc64_initialize_trampoline (TRAMP, FNADDR, CXT);	\
      else							\
        sparc_initialize_trampoline (TRAMP, FNADDR, CXT)
+ 
+ /* Generate runtime descriptors instead of trampolines when possible.  */
+ 
+ #define USE_RUNTIME_DESCRIPTORS 1
  
  /* Implement `va_start' for varargs and stdarg.  */
  #define EXPAND_BUILTIN_VA_START(valist, nextarg) \
*** gcc/dwarf2out.c.0	2007-11-28 08:39:44.499690184 +0100
--- gcc/dwarf2out.c	2007-11-28 08:41:57.325497592 +0100
*************** static void record_comdat_symbol_number 
*** 4070,4076 ****
  static void add_sibling_attributes (dw_die_ref);
  static void build_abbrev_table (dw_die_ref);
  static void output_location_lists (dw_die_ref);
! static int constant_size (long unsigned);
  static unsigned long size_of_die (dw_die_ref);
  static void calc_die_sizes (dw_die_ref);
  static void mark_dies (dw_die_ref);
--- 4070,4076 ----
  static void add_sibling_attributes (dw_die_ref);
  static void build_abbrev_table (dw_die_ref);
  static void output_location_lists (dw_die_ref);
! static int constant_size (unsigned HOST_WIDE_INT);
  static unsigned long size_of_die (dw_die_ref);
  static void calc_die_sizes (dw_die_ref);
  static void mark_dies (dw_die_ref);
*************** build_abbrev_table (dw_die_ref die)
*** 6581,6587 ****
  /* Return the power-of-two number of bytes necessary to represent VALUE.  */
  
  static int
! constant_size (long unsigned int value)
  {
    int log;
  
--- 6581,6587 ----
  /* Return the power-of-two number of bytes necessary to represent VALUE.  */
  
  static int
! constant_size (unsigned HOST_WIDE_INT value)
  {
    int log;
  
*** gcc/gimplify.c.0	2007-12-02 18:40:33.575376616 +0100
--- gcc/gimplify.c	2007-12-02 18:50:47.751007728 +0100
*************** unshare_expr (tree expr)
*** 819,824 ****
--- 819,849 ----
    return expr;
  }
  
+ /* Callback for walk_tree to force a source location on *TP.  */
+ 
+ static tree
+ force_location_on_expr_r (tree *tp, int *walk_subtrees, void *data)
+ {
+   location_t *loc = (location_t *) data;
+   tree t = *tp;
+ 
+   if (EXPR_P (t) && TREE_CODE (t) != LABEL_EXPR)
+     SET_EXPR_LOCUS (t, loc);
+ 
+   if (IS_TYPE_OR_DECL_P (t))
+     *walk_subtrees = 0;
+ 
+   return NULL_TREE;
+ }
+ 
+ /* Force source location LOC on EXPR recursively.  */
+ 
+ void
+ force_location_on_expr (tree expr, location_t *loc)
+ {
+   walk_tree (&expr, force_location_on_expr_r, loc, NULL);
+ }
+ 
  /* A terser interface for building a representation of an exception
     specification.  */
  
*************** gimplify_call_expr (tree *expr_p, tree *
*** 1886,1891 ****
--- 1911,1917 ----
    tree decl;
    tree arglist;
    enum gimplify_status ret;
+   tree arg_pre = NULL_TREE;
  
    gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);
  
*************** gimplify_call_expr (tree *expr_p, tree *
*** 1955,1961 ****
      {
        enum gimplify_status t;
  
!       t = gimplify_arg (&TREE_VALUE (arglist), pre_p);
  
        if (t == GS_ERROR)
  	ret = GS_ERROR;
--- 1981,1987 ----
      {
        enum gimplify_status t;
  
!       t = gimplify_arg (&TREE_VALUE (arglist), &arg_pre);
  
        if (t == GS_ERROR)
  	ret = GS_ERROR;
*************** gimplify_call_expr (tree *expr_p, tree *
*** 1963,1968 ****
--- 1989,2003 ----
    if (PUSH_ARGS_REVERSED)
      TREE_OPERAND (*expr_p, 1) = nreverse (TREE_OPERAND (*expr_p, 1));
  
+   /* Use the source location of the calling expression for the argument
+      preparation statements.  This will mask the detrimental effect of
+      the potential reversal above on the 'next' debugger's command.  */
+   if (arg_pre)
+     {
+       force_location_on_expr (arg_pre, EXPR_LOCUS (*expr_p));
+       append_to_statement_list (arg_pre, pre_p);
+     }
+ 
    /* Try this again in case gimplification exposed something.  */
    if (ret != GS_ERROR)
      {
*** gcc/tree.h.0	2007-12-02 18:41:45.568432008 +0100
--- gcc/tree.h	2007-12-01 09:34:00.000000000 +0100
*************** extern tree create_artificial_label (voi
*** 4187,4192 ****
--- 4187,4193 ----
  extern void gimplify_function_tree (tree);
  extern const char *get_name (tree);
  extern tree unshare_expr (tree);
+ extern void force_location_on_expr (tree, source_locus);
  extern void sort_case_labels (tree);
  
  /* If KIND=='I', return a suitable global initializer (constructor) name.
*** gcc/explow.c.0	2007-11-26 10:26:09.000000000 +0100
--- gcc/explow.c	2007-11-27 12:06:28.000000000 +0100
*************** allocate_dynamic_stack_space (rtx size, 
*** 1297,1307 ****
    return target;
  }
  
! /* A front end may want to override GCC's stack checking by providing a
!    run-time routine to call to check the stack.  */
  
  rtx stack_check_libfunc;
! 
  /* Emit one stack probe at ADDRESS, an address within the stack.  */
  
  static void
--- 1297,1314 ----
    return target;
  }
  
! /* A front end may want to override GCC's stack checking by providing
!    either a symbol (data) or a function (code).  In either case, the
!    runtime also needs to provide the associated support.  */
! 
! /* Variable whose value is checked against the future value of the stack
!    pointer.  Upon stack overflow, the generated code will raise a trap.  */
! rtx stack_check_symbol;
  
+ /* Function that is passed the future value of the stack pointer.  Upon
+    stack overflow, it is responsible for raising the appropriate event.  */
  rtx stack_check_libfunc;
! 
  /* Emit one stack probe at ADDRESS, an address within the stack.  */
  
  static void
*************** emit_stack_probe (rtx address)
*** 1328,1336 ****
--- 1335,1347 ----
  #ifdef STACK_GROWS_DOWNWARD
  #define STACK_GROW_OP     MINUS
  #define STACK_GROW_OPTAB  sub_optab
+ #define STACK_HIGH(high,low)  low
+ #define STACK_LOW(high,low)   high
  #else
  #define STACK_GROW_OP     PLUS
  #define STACK_GROW_OPTAB  add_optab
+ #define STACK_HIGH(high,low)  high
+ #define STACK_LOW(high,low)   low
  #endif
  
  void
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1359,1364 ****
--- 1370,1399 ----
  			 ptr_mode);
      }
  
+   /* Next see if the runtime has got a symbol for us to compare against.  */
+   else if (stack_check_symbol)
+     {
+       rtx stack_check_limit = gen_rtx_MEM (Pmode, stack_check_symbol);
+       rtx avail
+ 	= expand_binop (Pmode, sub_optab,
+ 			STACK_HIGH (stack_check_limit, stack_pointer_rtx),
+ 			STACK_LOW (stack_check_limit, stack_pointer_rtx),
+ 			NULL_RTX, 1, OPTAB_WIDEN);
+       rtx req = plus_constant (size, first);
+ 
+ #if defined(HAVE_conditional_trap)
+       emit_insn (gen_cond_trap (LTU, avail, req, const0_rtx));
+ #elif defined(HAVE_trap)
+       rtx ok_lab = gen_label_rtx ();
+       emit_cmp_and_jump_insns (avail, req, GEU, NULL_RTX, Pmode, 1, ok_lab);
+       emit_insn (gen_trap ());
+       emit_barrier ();
+       emit_label (ok_lab);
+ #else
+       error ("stack checking not supported on this target");
+ #endif
+     }
+ 
    /* Otherwise we have to generate explicit probes.  If we have a constant
       small number of them to generate, that's the easy case.  */
    else if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
*** gcc/rtl.h.0	2007-11-27 09:54:26.000000000 +0100
--- gcc/rtl.h	2007-11-26 07:11:00.000000000 +0100
*************** extern int ceil_log2 (unsigned HOST_WIDE
*** 1337,1342 ****
--- 1337,1343 ----
  extern rtx expand_builtin_expect_jump (tree, rtx, rtx);
  
  /* In explow.c */
+ extern GTY(()) rtx stack_check_symbol;
  extern GTY(()) rtx stack_check_libfunc;
  extern HOST_WIDE_INT trunc_int_for_mode	(HOST_WIDE_INT, enum machine_mode);
  extern rtx plus_constant (rtx, HOST_WIDE_INT);
*** gcc/config/i386/vxworksae.h.0	2007-11-26 11:33:00.000000000 +0100
--- gcc/config/i386/vxworksae.h	2007-11-26 11:33:23.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 30,36 ****
     requires 4K of space for executing a possible last chance handler.  */
  #undef STACK_CHECK_PROTECT
  #define STACK_CHECK_PROTECT 4096
- 
- /* Static stack checking is supported unconditionally.  */
- #undef VXWORKS_STACK_CHECK_SPEC
- #define VXWORKS_STACK_CHECK_SPEC
--- 30,32 ----
*** gcc/config/i386/vxworks.h.0	2007-11-26 11:33:08.000000000 +0100
--- gcc/config/i386/vxworks.h	2007-11-26 11:34:56.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 25,33 ****
  #define TARGET_VERSION fprintf (stderr, " (80586, VxWorks syntax)");
  
  #undef  CC1_SPEC
! #define CC1_SPEC					\
! "%(cc1_cpu)"						\
! VXWORKS_STACK_CHECK_SPEC
  
  #undef  ASM_SPEC
  #define ASM_SPEC "%{v:-v} %{Qy:} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}"
--- 25,31 ----
  #define TARGET_VERSION fprintf (stderr, " (80586, VxWorks syntax)");
  
  #undef  CC1_SPEC
! #define CC1_SPEC "%(cc1_cpu)"
  
  #undef  ASM_SPEC
  #define ASM_SPEC "%{v:-v} %{Qy:} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}"
*************** VXWORKS_STACK_CHECK_SPEC
*** 94,102 ****
     exceptions reliably in case of stack overflow. */
  #define STACK_CHECK_PROTECT 8192
  
- /* Static stack checking is supported only in RTP mode */
- #define VXWORKS_STACK_CHECK_SPEC "%{fstack-check:%{!mrtp:-fold-stack-check}}"
- 
  /* The maximum alignment 'malloc' is guaranteed to offer.  */
  #undef  MALLOC_ALIGNMENT
  #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
--- 92,97 ----
*** gcc/config/i386/i386-protos.h.0	2007-11-26 15:32:24.000000000 +0100
--- gcc/config/i386/i386-protos.h	2007-11-26 07:11:00.000000000 +0100
*************** extern const char *output_387_binary_op 
*** 73,78 ****
--- 73,79 ----
  extern const char *output_387_reg_move (rtx, rtx*);
  extern const char *output_fix_trunc (rtx, rtx*, int);
  extern const char *output_fp_compare (rtx, rtx*, int, int);
+ extern const char *output_cond_trap (rtx);
  extern const char *output_probe_stack_range (rtx, rtx);
  
  extern void ix86_expand_clear (rtx);
*** gcc/config/i386/i386.c.0	2007-11-26 11:42:18.000000000 +0100
--- gcc/config/i386/i386.c	2007-11-27 11:48:21.000000000 +0100
*************** ix86_emit_probe_stack_range (HOST_WIDE_I
*** 5059,5064 ****
--- 5059,5112 ----
  	 compiling C code.  Doing nothing is not worse than emitting
  	 useless probes.  */
  
+   else if (stack_check_symbol)
+     {
+       rtx reg, res;
+       bool live_p;
+ 
+       /* Find a scratch register, if any.  */
+       if (regparm <= 1
+ 	  || (regparm == 2 && !needs_static_chain_p (current_function_decl)))
+ 	{
+ 	  reg = gen_rtx_REG (Pmode, regparm);
+ 	  live_p = false;
+ 	}
+       else
+ 	{
+ 	  reg = gen_rtx_REG (Pmode, 0);
+ 	  live_p = true;
+ 	}
+ 
+       /* Save the register if necessary.  */
+       if (live_p)
+ 	{
+ 	  rtx insn = emit_insn (gen_push (reg));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	}
+ 
+       emit_move_insn (reg,
+ 		      plus_constant (stack_pointer_rtx, -(first + size)));
+       res = ix86_expand_int_compare (LTU, reg,
+ 				     gen_rtx_MEM (Pmode, stack_check_symbol));
+       emit_insn (gen_rtx_TRAP_IF (VOIDmode, res, GEN_INT (6)));
+ 
+       /* Restore the clobbered register if necessary.  Note that we cannot
+ 	 use the pop insn because the RTX_FRAME_RELATED_P mechanism doesn't
+ 	 know how to handle it.  */
+       if (live_p)
+ 	{
+ 	  rtx mem = gen_rtx_MEM (Pmode, stack_pointer_rtx);
+ 	  rtx insn = emit_move_insn (reg, mem);
+ 	  /* The register may be dead in the end.  */
+ 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
+ 						reg,
+ 						REG_NOTES (insn));
+ 	  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,
+ 					   GEN_INT (UNITS_PER_WORD)));
+ 	  RTX_FRAME_RELATED_P (insn) = 1;
+ 	}
+     }
+ 
    else
      {
        int i, n = SMALL_INTERVAL (size) ? 0 : MIN (regparm, 2);
*************** ix86_emit_probe_stack_range (HOST_WIDE_I
*** 5104,5109 ****
--- 5152,5175 ----
    emit_insn (gen_blockage (const0_rtx));
  }
  
+ /* Generate a trap if COND is true.  */
+ 
+ const char *
+ output_cond_trap (rtx cond)
+ {
+   static int labelno = 0;
+   char ok_lab[32];
+ 
+   ASM_GENERATE_INTERNAL_LABEL (ok_lab, "LOCT", labelno++);
+ 
+   fputs ("\tj", asm_out_file); print_operand (asm_out_file, cond, 'c');
+   fputs ("\t", asm_out_file); assemble_name (asm_out_file, ok_lab);
+   fputs ("\n\t" ASM_SHORT "0x0b0f\n", asm_out_file);
+   ASM_OUTPUT_LABEL (asm_out_file, ok_lab);
+ 
+   return "";
+ }
+ 
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
     These are offsets from the current stack pointer.  */
  
*** gcc/config/i386/i386.md.0	2007-11-26 14:03:01.000000000 +0100
--- gcc/config/i386/i386.md	2007-11-26 16:58:29.000000000 +0100
***************
*** 20382,20387 ****
--- 20382,20395 ----
    { return ASM_SHORT "0x0b0f"; }
    [(set_attr "length" "2")])
  
+ (define_insn "*cond_trap"
+   [(trap_if (match_operator 0 "comparison_operator"
+              [(reg:CC FLAGS_REG) (const_int 0)])
+ 	    (const_int 6))]
+   ""
+   "* return output_cond_trap (operands[0]);"
+   [(set_attr "length" "4")])
+ 
  (define_expand "sse_prologue_save"
    [(parallel [(set (match_operand:BLK 0 "" "")
  		   (unspec:BLK [(reg:DI 21)
*** gcc/config/rs6000/vxworksae.h.0	2007-11-26 09:51:06.000000000 +0100
--- gcc/config/rs6000/vxworksae.h	2007-11-26 09:51:13.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 28,34 ****
     requires 4K of space for executing a possible last chance handler.  */
  #undef STACK_CHECK_PROTECT
  #define STACK_CHECK_PROTECT 4096
- 
- /* Static stack checking is supported unconditionally.  */
- #undef VXWORKS_STACK_CHECK_SPEC
- #define VXWORKS_STACK_CHECK_SPEC
--- 28,30 ----
*** gcc/config/rs6000/vxworks.h.0	2007-11-26 09:51:06.000000000 +0100
--- gcc/config/rs6000/vxworks.h	2007-11-26 09:51:00.000000000 +0100
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 94,101 ****
   %{mlittle|mlittle-endian:-mstrict-align}			\
   %{!mlongcall: %{!mno-longcall: -mlongcall}}			\
   %{profile: -p}		\
!  %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}"	\
! VXWORKS_STACK_CHECK_SPEC
  
  #define ASM_SPEC \
  "%(asm_cpu) \
--- 94,100 ----
   %{mlittle|mlittle-endian:-mstrict-align}			\
   %{!mlongcall: %{!mno-longcall: -mlongcall}}			\
   %{profile: -p}		\
!  %{fvec:-maltivec} %{fvec-eabi:-maltivec -mabi=altivec}"
  
  #define ASM_SPEC \
  "%(asm_cpu) \
*************** VXWORKS_STACK_CHECK_SPEC
*** 234,239 ****
     exceptions reliably in case of stack overflow. */
  #define STACK_CHECK_PROTECT 8192
  
! /* Static stack checking is supported only in RTP mode.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
- #define VXWORKS_STACK_CHECK_SPEC "%{fstack-check:%{!mrtp:-fold-stack-check}}"
--- 233,237 ----
     exceptions reliably in case of stack overflow. */
  #define STACK_CHECK_PROTECT 8192
  
! /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/rs6000/rs6000.c.0	2008-12-13 10:48:16.000000000 +0100
--- gcc/config/rs6000/rs6000.c	2008-12-13 10:58:12.000000000 +0100
*************** static void
*** 13867,13873 ****
  rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
  {
    gcc_assert (!stack_check_libfunc && !TARGET_64BIT); /* Not implemented.  */
!   emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
  }
  
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
--- 13867,13888 ----
  rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
  {
    gcc_assert (!stack_check_libfunc && !TARGET_64BIT); /* Not implemented.  */
! 
!   if (stack_check_symbol)
!     {
!       rtx reg1 = gen_rtx_REG (Pmode, 0), reg2 = gen_rtx_REG (Pmode, 12);
!       emit_insn (gen_addsi3 (reg1, stack_pointer_rtx,
! 			     GEN_INT (-(first + size))));
!       emit_insn (gen_rtx_SET (VOIDmode, reg2,
! 			      gen_rtx_HIGH (Pmode, stack_check_symbol)));
!       emit_insn (gen_rtx_SET (VOIDmode, reg2,
! 			      gen_rtx_MEM (Pmode,
! 					   gen_rtx_LO_SUM (Pmode, reg2,
! 							   stack_check_symbol))));
!       emit_insn (gen_cond_trap (LTU, reg1, reg2, const0_rtx));
!     }
!   else
!     emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
  }
  
  /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
*** gcc/config/arm/nucleus.h	Tue Dec  4 23:02:22 2007
--- gcc/config/arm/nucleus.h	Wed Dec  5 15:01:10 2007
***************
*** 32,37 ****
--- 32,57 ----
  #undef LIB_SPEC
  #define LIB_SPEC ""
  
+ /* This macro is called when code is dynamically generated for use
+    with trampolines. On ARM, it is necessary to also flush the data
+    cache to ensure the new instructions can be executed. There is no
+    API on Nucleus to do this, so execute the relevant instructions
+    directly.  */
+ #undef CLEAR_INSN_CACHE
+ #define CLEAR_INSN_CACHE(BEG,END) \
+   do                                                                 \
+     {                                                                \
+       unsigned long addr=(unsigned long)(BEG) & ~(31UL);             \
+       do                                                             \
+ 	{                                                            \
+ 	  /* Flush data cache line */                                \
+ 	  asm volatile("mcr    p15,0, %0, c7,c14,1" : : "r" (addr)); \
+ 	  addr += 32;                                                \
+ 	}                                                            \
+       while (addr && addr < (unsigned long) (END));                  \
+     }                                                                \
+   while (0)
+ 
  /* Define the __nucleus__ macro.  */
  #undef TARGET_OS_CPP_BUILTINS
  #define TARGET_OS_CPP_BUILTINS()		\
*** gcc/config/i386/linux.h	Thu Dec 13 12:12:56 2007
--- gcc/config/i386/linux.h	Thu Dec 13 12:06:19 2007
***************
*** 112,117 ****
--- 112,139 ----
    { "link_emulation", LINK_EMULATION },\
    { "dynamic_linker", DYNAMIC_LINKER }
  
+ /* Overwrite STARTFILE_SPEC and LIB_SPEC from linux.h to remove the -pg
+  * startup files and link with libgnatmon 
+  * ??? as soon as libgnatmon exists on all linux flavors, then we should
+  * move all this to the common linux.h file
+  */
+ #undef STARTFILE_SPEC
+ #if defined HAVE_LD_PIE
+ #define STARTFILE_SPEC \
+   "%{!shared: %{pie:Scrt1.o%s;:crt1.o%s}} \
+    crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+ #else
+ #define STARTFILE_SPEC \
+   "%{!shared: crt1.o%s} \
+    crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+ #endif
+ #undef LIB_SPEC
+ #define LIB_SPEC \
+   "%{pthread:-lpthread} \
+    %{p|pg:-lgnatmon} \
+    %{shared:-lc} \
+    %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+ 
  #undef	LINK_SPEC
  #define LINK_SPEC "-m %(link_emulation) %{shared:-shared} \
    %{!shared: \
*** gcc/config/i386/linux64.h	Sat Nov 19 19:37:59 2005
--- gcc/config/i386/linux64.h	Thu Dec 13 12:06:16 2007
***************
*** 54,59 ****
--- 54,81 ----
     When the -shared link option is used a final link is not being
     done.  */
  
+ /* Overwrite STARTFILE_SPEC and LIB_SPEC from linux.h to remove the -pg
+  * startup files and link with libgnatmon 
+  * ??? as soon as libgnatmon exists on all linux flavors, then we should
+  * move all this to the common linux.h file
+  */
+ #undef STARTFILE_SPEC
+ #if defined HAVE_LD_PIE
+ #define STARTFILE_SPEC \
+   "%{!shared: %{pie:Scrt1.o%s;:crt1.o%s}} \
+    crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+ #else
+ #define STARTFILE_SPEC \
+   "%{!shared: crt1.o%s} \
+    crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+ #endif
+ #undef LIB_SPEC
+ #define LIB_SPEC \
+   "%{pthread:-lpthread} \
+    %{p|pg:-lgnatmon} \
+    %{shared:-lc} \
+    %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+ 
  #undef	LINK_SPEC
  #define LINK_SPEC "%{!m32:-m elf_x86_64} %{m32:-m elf_i386} \
    %{shared:-shared} \
*** gcc/config/i386/mingw32.h	Thu Dec 13 12:12:57 2007
--- gcc/config/i386/mingw32.h	Thu Dec 13 12:06:19 2007
***************
*** 48,54 ****
  /* For Windows applications, include more libraries, but always include
     kernel32.  */
  #undef LIB_SPEC
! #define LIB_SPEC "%{pg:-lgmon} %{mwindows:-lgdi32 -lcomdlg32} \
                    -luser32 -lkernel32 -ladvapi32 -lshell32"
  
  /* Include in the mingw32 libraries with libgcc */
--- 48,54 ----
  /* For Windows applications, include more libraries, but always include
     kernel32.  */
  #undef LIB_SPEC
! #define LIB_SPEC "%{pg:-lgnatmon} %{mwindows:-lgdi32 -lcomdlg32} \
                    -luser32 -lkernel32 -ladvapi32 -lshell32"
  
  /* Include in the mingw32 libraries with libgcc */
***************
*** 76,82 ****
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
!   %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s} \
    %{!fno-exceptions:crtbegin%O%s}"
  
  #undef ENDFILE_SPEC
--- 76,82 ----
  
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
!   %{!shared:%{!mdll:crt2%O%s}} \
    %{!fno-exceptions:crtbegin%O%s}"
  
  #undef ENDFILE_SPEC
*** gcc/config/i386/t-sol2	Sat Nov 19 19:37:59 2005
--- gcc/config/i386/t-sol2	Thu Dec 13 12:06:16 2007
***************
*** 1,8 ****
- # gmon build rule:
- $(T)gmon.o:	$(srcdir)/config/i386/gmon-sol2.c $(GCC_PASSES) $(CONFIG_H)
- 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) \
- 		-c $(srcdir)/config/i386/gmon-sol2.c -o $(T)gmon.o
- 
  # Assemble startup files.
  # Apparently Sun believes that assembler files don't need comments, because no
  # single ASCII character is valid (tried them all).  So we manually strip out
--- 1,3 ----
*** gcc/config/i386/t-sol2-10	Sat Nov 19 19:37:59 2005
--- gcc/config/i386/t-sol2-10	Thu Dec 13 12:06:16 2007
***************
*** 8,11 ****
  # GCC contains i386 assembler sources for some of the startfiles
  # which aren't appropriate for amd64.  Just use the installed
  # versions of: crt1.o crti.o crtn.o gcrt1.o
! EXTRA_MULTILIB_PARTS=gmon.o crtbegin.o crtend.o
--- 8,11 ----
  # GCC contains i386 assembler sources for some of the startfiles
  # which aren't appropriate for amd64.  Just use the installed
  # versions of: crt1.o crti.o crtn.o gcrt1.o
! EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o
*** gcc/config/sol2.h	Wed Feb  8 03:09:40 2006
--- gcc/config/sol2.h	Thu Dec 13 12:06:16 2007
***************
*** 100,106 ****
       %{!symbolic:\
         %{pthreads|pthread:-lpthread} \
         %{!pthreads:%{!pthread:%{threads:-lthread}}} \
!        %{p|pg:-ldl} -lc}}"
  
  #undef  ENDFILE_SPEC
  #define ENDFILE_SPEC "crtend.o%s crtn.o%s"
--- 100,106 ----
       %{!symbolic:\
         %{pthreads|pthread:-lpthread} \
         %{!pthreads:%{!pthread:%{threads:-lthread}}} \
!        %{p|pg:-ldl -lgnatmon} -lc}}"
  
  #undef  ENDFILE_SPEC
  #define ENDFILE_SPEC "crtend.o%s crtn.o%s"
***************
*** 111,117 ****
  			 %{!symbolic: \
  			  %{p:mcrt1.o%s} \
                            %{!p: \
! 	                    %{pg:gcrt1.o%s gmon.o%s} \
                              %{!pg:crt1.o%s}}}} \
  			crti.o%s %(startfile_arch) \
  			crtbegin.o%s"
--- 111,117 ----
  			 %{!symbolic: \
  			  %{p:mcrt1.o%s} \
                            %{!p: \
! 	                    %{pg:gcrt1.o%s} \
                              %{!pg:crt1.o%s}}}} \
  			crti.o%s %(startfile_arch) \
  			crtbegin.o%s"
*** gcc/config/sparc/t-sol2	Sat Nov 19 19:37:52 2005
--- gcc/config/sparc/t-sol2	Thu Dec 13 12:06:16 2007
***************
*** 1,9 ****
- # gmon build rule:
- $(T)gmon.o:	$(srcdir)/config/sparc/gmon-sol2.c $(GCC_PASSES) \
-   $(TCONFIG_H) tsystem.h coretypes.h $(TM_H) stmp-int-hdrs
- 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) \
- 		-c $(srcdir)/config/sparc/gmon-sol2.c -o $(T)gmon.o
- 
  # Assemble startup files.
  $(T)crt1.o: $(srcdir)/config/sparc/sol2-c1.asm $(GCC_PASSES)
  	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crt1.o -x assembler-with-cpp $(srcdir)/config/sparc/sol2-c1.asm
--- 1,3 ----
*** gcc/config/sparc/t-sol2-64	Sat Nov 19 19:37:52 2005
--- gcc/config/sparc/t-sol2-64	Thu Dec 13 12:06:16 2007
***************
*** 6,10 ****
  LIBGCC = stmp-multilib
  INSTALL_LIBGCC = install-multilib
  
! EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o gmon.o crt1.o crti.o crtn.o gcrt1.o \
  	crtfastmath.o
--- 6,10 ----
  LIBGCC = stmp-multilib
  INSTALL_LIBGCC = install-multilib
  
! EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crt1.o crti.o crtn.o gcrt1.o \
  	crtfastmath.o
*** gcc/config.gcc.old	Fri Dec 14 09:02:52 2007
--- gcc/config.gcc	Fri Dec 14 09:03:21 2007
***************
*** 1164,1173 ****
  		need_64bit_hwint=yes
  		# Solaris 2.10 provides crt1.o, crti.o, crtn.o, and gcrt1.o as 
  		# part of the base system.
! 		extra_parts="gmon.o crtbegin.o crtend.o"
  		;;
  	*)
! 		extra_parts="crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o"
  		;;
  	esac
  	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
--- 1164,1173 ----
  		need_64bit_hwint=yes
  		# Solaris 2.10 provides crt1.o, crti.o, crtn.o, and gcrt1.o as 
  		# part of the base system.
! 		extra_parts="crtbegin.o crtend.o"
  		;;
  	*)
! 		extra_parts="crt1.o crti.o crtn.o gcrt1.o crtbegin.o crtend.o"
  		;;
  	esac
  	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
***************
*** 2159,2165 ****
  	cxx_target_objs="sol2-c.o"
  	extra_objs="sol2.o"
  	tm_p_file="${tm_p_file} sol2-protos.h"
! 	extra_parts="crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o"
  	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
  	  "":yes:* | yes:yes:* )
  		case ${target} in
--- 2159,2165 ----
  	cxx_target_objs="sol2-c.o"
  	extra_objs="sol2.o"
  	tm_p_file="${tm_p_file} sol2-protos.h"
! 	extra_parts="crt1.o crti.o crtn.o gcrt1.o crtbegin.o crtend.o"
  	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
  	  "":yes:* | yes:yes:* )
  		case ${target} in
*** gcc/config/rs6000/lynx.h.0	2007-12-15 12:23:56.000000000 +0100
--- gcc/config/rs6000/lynx.h	2007-12-15 12:25:00.420057880 +0100
***************
*** 107,112 ****
--- 107,115 ----
  #undef HAVE_AS_TLS
  #define HAVE_AS_TLS 0
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #ifdef CRT_BEGIN
  /* This function is part of crtbegin*.o which is at the beginning of
     the link and is called from .fini which is usually toward the end
*** libiberty/argv.c.old	Sat Nov 19 19:43:06 2005
--- libiberty/argv.c	Tue Dec 18 18:04:39 2007
***************
*** 330,335 ****
--- 330,337 ----
        FILE *f;
        /* The number of characters in the response file.  */
        long pos;
+       /* The number of characters read */
+       long b_read;
        /* A dynamically allocated buffer used to hold options read from a
  	 response file.  */
        char *buffer;
***************
*** 337,349 ****
  	 response file.  */
        char **file_argv;
        /* The number of options read from the response file, if any.  */
!      size_t file_argc;
        /* We are only interested in options of the form "@file".  */
        filename = (*argvp)[i];
        if (filename[0] != '@')
  	continue;
        /* Read the contents of the file.  */
!       f = fopen (++filename, "r");
        if (!f)
  	continue;
        if (fseek (f, 0L, SEEK_END) == -1)
--- 339,351 ----
  	 response file.  */
        char **file_argv;
        /* The number of options read from the response file, if any.  */
!       size_t file_argc;
        /* We are only interested in options of the form "@file".  */
        filename = (*argvp)[i];
        if (filename[0] != '@')
  	continue;
        /* Read the contents of the file.  */
!       f = fopen (++filename, "rb");
        if (!f)
  	continue;
        if (fseek (f, 0L, SEEK_END) == -1)
***************
*** 354,360 ****
        if (fseek (f, 0L, SEEK_SET) == -1)
  	goto error;
        buffer = (char *) xmalloc (pos * sizeof (char) + 1);
!       if (fread (buffer, sizeof (char), pos, f) != (size_t) pos)
  	goto error;
        /* Add a NUL terminator.  */
        buffer[pos] = '\0';
--- 356,363 ----
        if (fseek (f, 0L, SEEK_SET) == -1)
  	goto error;
        buffer = (char *) xmalloc (pos * sizeof (char) + 1);
!       b_read = (long) fread (buffer, sizeof (char), pos, f);
!       if (b_read != pos)
  	goto error;
        /* Add a NUL terminator.  */
        buffer[pos] = '\0';

*** gcc/flow.c.0	2007-12-22 13:54:09.973927496 +0100
--- gcc/flow.c	2007-12-22 14:13:48.687735760 +0100
*************** typedef struct {
*** 1448,1456 ****
  } find_regno_partial_param;
  
  
! /* Find the rtx for the reg numbers specified in 'data' if it is
!    part of an expression which only uses part of the register.  Return
!    it in the structure passed in.  */
  static int
  find_regno_partial (rtx *ptr, void *data)
  {
--- 1448,1457 ----
  } find_regno_partial_param;
  
  
! /* Find the rtx for the reg number specified in 'data' if it is
!    part of an expression which only uses part of the register.
!    Return it in the structure passed in.  */
! 
  static int
  find_regno_partial (rtx *ptr, void *data)
  {
*************** find_regno_partial (rtx *ptr, void *data
*** 1482,1487 ****
--- 1483,1507 ----
  	}
        break;
  
+     case IOR:
+       /* Inclusive OR can be used to do partial moves partly preserving
+ 	 the contents of the target; in this case, both source and target
+ 	 are ANDed with appropriate masks to select the right part.  The
+ 	 mask operations may be optimized away, if SUBREG_PROMOTED_VAR_P
+ 	 objects are involved for example, on the premise that they are
+ 	 properly initialized.  Fix things up here if they are not.  */
+       if (REG_P (XEXP (*ptr, 0)) && REGNO (XEXP (*ptr, 0)) == reg)
+ 	{
+ 	  param->retval = XEXP (*ptr, 0);
+ 	  return 1;
+ 	}
+       if (REG_P (XEXP (*ptr, 1)) && REGNO (XEXP (*ptr, 1)) == reg)
+ 	{
+ 	  param->retval = XEXP (*ptr, 1);
+ 	  return 1;
+ 	}
+       break;
+ 
      default:
        break;
      }
*** gcc/fold-const.c.0	2008-01-12 11:27:31.000000000 +0100
--- gcc/fold-const.c	2008-01-12 19:34:10.282649504 +0100
*************** fold_unary (enum tree_code code, tree ty
*** 6915,6921 ****
        return tem ? tem : NULL_TREE;
  
      case VIEW_CONVERT_EXPR:
!       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)
  	return build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
        return NULL_TREE;
  
--- 6915,6926 ----
        return tem ? tem : NULL_TREE;
  
      case VIEW_CONVERT_EXPR:
!       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR
! 	  || (TREE_CODE (op0) == NOP_EXPR
! 	      && INTEGRAL_TYPE_P (TREE_TYPE (op0))
! 	      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))
! 	      && TYPE_PRECISION (TREE_TYPE (op0))
! 		 == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))))
  	return build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
        return NULL_TREE;
  
*** gcc/expr.c.0	2008-05-06 16:01:23.646336000 +0200
--- gcc/expr.c	2008-05-06 18:57:39.198607680 +0200
*************** store_field (rtx target, HOST_WIDE_INT b
*** 5442,5454 ****
  	  && mode != TYPE_MODE (TREE_TYPE (exp)))
  	temp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);
  
!       /* If the modes of TARGET and TEMP are both BLKmode, both
  	 must be in memory and BITPOS must be aligned on a byte
! 	 boundary.  If so, we simply do a block copy.  */
!       if (GET_MODE (target) == BLKmode && GET_MODE (temp) == BLKmode)
  	{
  	  gcc_assert (MEM_P (target) && MEM_P (temp)
! 		      && !(bitpos % BITS_PER_UNIT));
  
  	  target = adjust_address (target, VOIDmode, bitpos / BITS_PER_UNIT);
  	  emit_block_move (target, temp,
--- 5442,5460 ----
  	  && mode != TYPE_MODE (TREE_TYPE (exp)))
  	temp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);
  
!       /* If the modes of TEMP and TARGET are both BLKmode, both
  	 must be in memory and BITPOS must be aligned on a byte
! 	 boundary.  If so, we simply do a block copy.  Likewise
! 	 for a BLKmode-like TARGET.  */
!       if (GET_MODE (temp) == BLKmode
! 	  && (GET_MODE (target) == BLKmode
! 	      || (MEM_P (target)
! 		  && GET_MODE_CLASS (GET_MODE (target)) == MODE_INT
! 		  && (bitpos % BITS_PER_UNIT) == 0
! 		  && (bitsize % BITS_PER_UNIT) == 0)))
  	{
  	  gcc_assert (MEM_P (target) && MEM_P (temp)
! 		      && (bitpos % BITS_PER_UNIT) == 0);
  
  	  target = adjust_address (target, VOIDmode, bitpos / BITS_PER_UNIT);
  	  emit_block_move (target, temp,
*************** store_field (rtx target, HOST_WIDE_INT b
*** 5494,5505 ****
     If any of the extraction expressions is volatile,
     we store 1 in *PVOLATILEP.  Otherwise we don't change that.
  
!    If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it
!    is a mode that can be used to access the field.  In that case, *PBITSIZE
!    is redundant.
  
     If the field describes a variable-sized object, *PMODE is set to
!    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in
     this case, but the address of the object can be found.
  
     If KEEP_ALIGNING is true and the target is STRICT_ALIGNMENT, we don't
--- 5500,5510 ----
     If any of the extraction expressions is volatile,
     we store 1 in *PVOLATILEP.  Otherwise we don't change that.
  
!    If the field is a non-BLKmode bit-field, *PMODE is set to VOIDmode.
!    Otherwise, it is a mode that can be used to access the field.
  
     If the field describes a variable-sized object, *PMODE is set to
!    BLKmode and *PBITSIZE is set to -1.  An access cannot be made in
     this case, but the address of the object can be found.
  
     If KEEP_ALIGNING is true and the target is STRICT_ALIGNMENT, we don't
*************** get_inner_reference (tree exp, HOST_WIDE
*** 5524,5529 ****
--- 5529,5535 ----
  {
    tree size_tree = 0;
    enum machine_mode mode = VOIDmode;
+   bool blkmode_bitfield = false;
    tree offset = size_zero_node;
    tree bit_offset = bitsize_zero_node;
    tree tem;
*************** get_inner_reference (tree exp, HOST_WIDE
*** 5532,5542 ****
       outermost expression.  */
    if (TREE_CODE (exp) == COMPONENT_REF)
      {
!       size_tree = DECL_SIZE (TREE_OPERAND (exp, 1));
!       if (! DECL_BIT_FIELD (TREE_OPERAND (exp, 1)))
! 	mode = DECL_MODE (TREE_OPERAND (exp, 1));
  
!       *punsignedp = DECL_UNSIGNED (TREE_OPERAND (exp, 1));
      }
    else if (TREE_CODE (exp) == BIT_FIELD_REF)
      {
--- 5538,5551 ----
       outermost expression.  */
    if (TREE_CODE (exp) == COMPONENT_REF)
      {
!       tree field = TREE_OPERAND (exp, 1);
!       size_tree = DECL_SIZE (field);
!       if (!DECL_BIT_FIELD (field))
! 	mode = DECL_MODE (field);
!       else if (DECL_MODE (field) == BLKmode)
! 	blkmode_bitfield = true;
  
!       *punsignedp = DECL_UNSIGNED (field);
      }
    else if (TREE_CODE (exp) == BIT_FIELD_REF)
      {
*************** get_inner_reference (tree exp, HOST_WIDE
*** 5656,5662 ****
    else
      *pbitpos = tree_low_cst (bit_offset, 0), *poffset = offset;
  
!   *pmode = mode;
    return exp;
  }
  
--- 5665,5679 ----
    else
      *pbitpos = tree_low_cst (bit_offset, 0), *poffset = offset;
  
!   /* We can use BLKmode for a byte-aligned BLKmode bitfield.  */
!   if (mode == VOIDmode
!       && blkmode_bitfield
!       && (*pbitpos % BITS_PER_UNIT) == 0
!       && (*pbitsize % BITS_PER_UNIT) == 0)
!     *pmode = BLKmode;
!   else
!     *pmode = mode;
! 
    return exp;
  }
  
*** gcc/config/arm/arm.c.ori	Thu Jan 10 11:38:00 2008
--- gcc/config/arm/arm.c	Fri Jan 18 10:45:33 2008
*************** const struct attribute_spec arm_attribut
*** 61,66 ****
--- 61,67 ----
  
  /* Forward function declarations.  */
  static arm_stack_offsets *arm_get_frame_offsets (void);
+ static int arm_args_to_rsa_distance (void);
  static void arm_add_gc_roots (void);
  static int arm_gen_constant (enum rtx_code, enum machine_mode, rtx,
  			     HOST_WIDE_INT, rtx, rtx, int, int);
*************** arm_get_frame_offsets (void)
*** 10379,10384 ****
--- 10380,10388 ----
    int saved;
    HOST_WIDE_INT frame_size;
  
+   /* Space between the arguments and the register save areas.  */
+   int args_to_rsa_distance;
+ 
    offsets = &cfun->machine->stack_offsets;
  
    /* We need to know if we are a leaf function.  Unfortunately, it
*************** arm_get_frame_offsets (void)
*** 10403,10410 ****
    /* Space for variadic functions.  */
    offsets->saved_args = current_function_pretend_args_size;
  
!   offsets->frame = offsets->saved_args + (frame_pointer_needed ? 4 : 0);
! 
    if (TARGET_ARM)
      {
        unsigned int regno;
--- 10407,10413 ----
    /* Space for variadic functions.  */
    offsets->saved_args = current_function_pretend_args_size;
  
!   /* Space for saved registers.  */
    if (TARGET_ARM)
      {
        unsigned int regno;
*************** arm_get_frame_offsets (void)
*** 10445,10453 ****
  	saved += 16;
      }
  
!   /* Saved registers include the stack frame.  */
!   offsets->saved_regs = offsets->saved_args + saved;
    offsets->soft_frame = offsets->saved_regs + CALLER_INTERWORKING_SLOT_SIZE;
    /* A leaf function does not need any stack alignment if it has nothing
       on the stack.  */
    if (leaf && frame_size == 0)
--- 10448,10468 ----
  	saved += 16;
      }
  
!   /* Space before the register save area.  */
!   args_to_rsa_distance = arm_args_to_rsa_distance ();
! 
!   /* The hard frame pointer offset, to the topmost slot in the registers
!      save area, then the offset to its bottommost slot and the soft frame
!      pointer just past it.  */
! 
!   offsets->frame
!     = (offsets->saved_args + args_to_rsa_distance
!        + (frame_pointer_needed ? 4 : 0));
!        
!   offsets->saved_regs = offsets->saved_args + args_to_rsa_distance + saved;
! 
    offsets->soft_frame = offsets->saved_regs + CALLER_INTERWORKING_SLOT_SIZE;
+ 
    /* A leaf function does not need any stack alignment if it has nothing
       on the stack.  */
    if (leaf && frame_size == 0)
*************** arm_compute_initial_elimination_offset (
*** 10495,10524 ****
    switch (from)
      {
      case ARG_POINTER_REGNUM:
        switch (to)
  	{
  	case THUMB_HARD_FRAME_POINTER_REGNUM:
  	  return 0;
  
  	case FRAME_POINTER_REGNUM:
! 	  /* This is the reverse of the soft frame pointer
! 	     to hard frame pointer elimination below.  */
! 	  return offsets->soft_frame - offsets->saved_args;
  
  	case ARM_HARD_FRAME_POINTER_REGNUM:
! 	  /* If there is no stack frame then the hard
! 	     frame pointer and the arg pointer coincide.  */
! 	  if (offsets->frame == offsets->saved_regs)
! 	    return 0;
! 	  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
! 	  return (frame_pointer_needed
! 		  && cfun->static_chain_decl != NULL
! 		  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;
  
  	case STACK_POINTER_REGNUM:
! 	  /* If nothing has been pushed on the stack at all
! 	     then this will return -4.  This *is* correct!  */
! 	  return offsets->outgoing_args - (offsets->saved_args + 4);
  
  	default:
  	  gcc_unreachable ();
--- 10510,10535 ----
    switch (from)
      {
      case ARG_POINTER_REGNUM:
+       /* We use offsets->saved_args as a reference offset to the actual
+ 	 arguments area then adjust by the difference with what the arg
+ 	 pointer designates.  */
+ 	 
        switch (to)
  	{
  	case THUMB_HARD_FRAME_POINTER_REGNUM:
  	  return 0;
  
  	case FRAME_POINTER_REGNUM:
! 	  return (offsets->soft_frame - offsets->saved_args
! 		  - FIRST_PARM_OFFSET (current_function_decl));
  
  	case ARM_HARD_FRAME_POINTER_REGNUM:
! 	  return (offsets->frame - offsets->saved_args
! 		  - FIRST_PARM_OFFSET (current_function_decl));
  
  	case STACK_POINTER_REGNUM:
! 	  return (offsets->outgoing_args - offsets->saved_args 
! 		  - FIRST_PARM_OFFSET (current_function_decl));
  
  	default:
  	  gcc_unreachable ();
*************** arm_compute_initial_elimination_offset (
*** 10558,10563 ****
--- 10569,10592 ----
  }
  
  
+ /* How many bytes the prologue expansion below pushes between
+    the arguments and the registers save area.  */
+ static int
+ arm_args_to_rsa_distance (void)
+ {  
+   int distance = 0;
+   
+   /* Account for our possible push of the static chain.  */
+ 
+   if (frame_pointer_needed
+       && IS_NESTED (arm_current_func_type ())
+       && regs_ever_live[3] != 0
+       && current_function_pretend_args_size == 0)
+     distance += 4;
+ 
+   return distance;
+ }
+ 
  /* Generate the prologue instructions for entry into an ARM function.  */
  void
  arm_expand_prologue (void)
*************** arm_expand_prologue (void)
*** 10642,10650 ****
  	      insn = gen_rtx_SET (VOIDmode, insn, ip_rtx);
  	      insn = emit_insn (insn);
  
! 	      fp_offset = 4;
  
! 	      /* Just tell the dwarf backend that we adjusted SP.  */
  	      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
  				   gen_rtx_PLUS (SImode, stack_pointer_rtx,
  						 GEN_INT (-fp_offset)));
--- 10671,10684 ----
  	      insn = gen_rtx_SET (VOIDmode, insn, ip_rtx);
  	      insn = emit_insn (insn);
  
! 	      /* This push doesn't account as a regular register save in the
! 		 save_reg_mask sense, so shifts the "frame" location.  */
! 	      fp_offset += 4;
! 	      
! 	      /* We need to account for the space it takes, still, ...  */
! 	      saved_regs += 4;
  
! 	      /* ... and tell the dwarf backend that we adjusted SP.  */
  	      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
  				   gen_rtx_PLUS (SImode, stack_pointer_rtx,
  						 GEN_INT (-fp_offset)));
*** gcc/tree-sra.c.0	2008-01-18 15:02:05.000000000 +0100
--- gcc/tree-sra.c	2008-01-18 17:40:17.560755648 +0100
*************** sra_walk_expr (tree *expr_p, block_stmt_
*** 794,809 ****
  
        case BIT_FIELD_REF:
  	/* A bit field reference (access to *multiple* fields simultaneously)
! 	   is not currently scalarized.  Consider this an access to the
! 	   complete outer element, to which walk_tree will bring us next.  */
  	goto use_all;
  
-       case VIEW_CONVERT_EXPR:
        case NOP_EXPR:
! 	/* Similarly, a view/nop explicitly wants to look at an object in a
  	   type other than the one we've scalarized.  */
  	goto use_all;
  
        case WITH_SIZE_EXPR:
  	/* This is a transparent wrapper.  The entire inner expression really
  	   is being used.  */
--- 794,819 ----
  
        case BIT_FIELD_REF:
  	/* A bit field reference (access to *multiple* fields simultaneously)
! 	   is not currently scalarized.  Consider this an access to the full
! 	   outer element, to which walk_tree will bring us next.  */
  	goto use_all;
  
        case NOP_EXPR:
! 	/* Similarly, a nop explicitly wants to look at an object in a
  	   type other than the one we've scalarized.  */
  	goto use_all;
  
+       case VIEW_CONVERT_EXPR:
+ 	/* Likewise for a view conversion, but with an additional twist:
+ 	   it can be on the LHS and, in this case, an access to the full
+ 	   outer element would mean a killing def.  So we need to punt
+ 	   if we haven't already a full access to the current element,
+ 	   because we cannot pretend to have a killing def if we only
+ 	   have a partial access at some level.  */
+ 	if (is_output && !use_all_p && inner != expr)
+ 	  disable_scalarization = true;
+ 	goto use_all;
+ 
        case WITH_SIZE_EXPR:
  	/* This is a transparent wrapper.  The entire inner expression really
  	   is being used.  */
*** gcc/tree-ssa-operands.c.0	2008-01-26 14:27:05.000000000 +0100
--- gcc/tree-ssa-operands.c	2008-01-26 14:38:50.094548240 +0100
*************** get_indirect_ref_operands (tree stmt, tr
*** 1437,1442 ****
--- 1437,1445 ----
    tree ptr = *pptr;
    stmt_ann_t s_ann = stmt_ann (stmt);
  
+   if (s_ann && TREE_THIS_VOLATILE (expr))
+     s_ann->has_volatile_ops = true; 
+ 
    /* Stores into INDIRECT_REF operands are never killing definitions.  */
    flags &= ~opf_kill_def;
  
*** gcc/dbxout.c.0	2008-01-29 10:25:03.000000000 +0100
--- gcc/dbxout.c	2008-01-29 13:23:11.345625128 +0100
*************** dbxout_function_decl (tree decl)
*** 1350,1356 ****
  static void
  dbxout_global_decl (tree decl)
  {
!   if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))
      {
        int saved_tree_used = TREE_USED (decl);
        TREE_USED (decl) = 1;
--- 1350,1362 ----
  static void
  dbxout_global_decl (tree decl)
  {
!   if (TREE_CODE (decl) == VAR_DECL
!       && !DECL_EXTERNAL (decl)
!       /* Do not produce debug information for local static variables
! 	 twice.  Note that it's done the other way around for DWARF-2
! 	 (they are not emitted within their scope) but we need proper
! 	 scoping for STABS.  */
!       && !decl_function_context (decl))
      {
        int saved_tree_used = TREE_USED (decl);
        TREE_USED (decl) = 1;
*** gcc/tree-inline.c.0	2008-02-01 19:23:52.251449768 +0100
--- gcc/tree-inline.c	2008-02-01 19:24:14.976994960 +0100
*************** copy_body_r (tree *tp, int *walk_subtree
*** 687,692 ****
--- 687,693 ----
  		    {
  	              *tp = build1 (INDIRECT_REF, type, new);
  		      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);
+ 		      TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);
  		    }
  		}
  	      *walk_subtrees = 0;
*** gcc/tree-sra.c.0	2008-07-14 23:24:30.974987112 +0200
--- gcc/tree-sra.c	2008-07-14 23:27:21.717030376 +0200
*************** sra_walk_asm_expr (tree expr, block_stmt
*** 867,872 ****
--- 867,901 ----
    sra_walk_tree_list (ASM_OUTPUTS (expr), bsi, true, fns);
  }
  
+ /* Return true if EXPR is a view conversion that must be treated as
+    a barrier for the purpose of scalarization.  */
+ 
+ static bool
+ view_convert_barrier_p (tree expr)
+ {
+   tree source_type, target_type;
+ 
+   if (TREE_CODE (expr) != VIEW_CONVERT_EXPR)
+     return false;
+ 
+   source_type = TREE_TYPE (TREE_OPERAND (expr, 0));
+   target_type = TREE_TYPE (expr);
+ 
+   /* Treat a view conversion from an integral type to an aggregate type
+      (and vice versa) as a barrier if they have the same constant size,
+      i.e. if they are supposed to represent the same underlying object.
+      The problem is that the former has always contiguous representation
+      whereas the latter may have holes, e.g. in Ada; the scalarization
+      will expose this discrepancy, which will break code that effectively
+      expects the undefined bits to be copied in an assignment.  */
+   if (((INTEGRAL_TYPE_P (source_type) && AGGREGATE_TYPE_P (target_type))
+        || (AGGREGATE_TYPE_P (source_type) && INTEGRAL_TYPE_P (target_type)))
+       && tree_int_cst_equal (TYPE_SIZE (source_type), TYPE_SIZE (target_type)))
+     return true;
+ 
+   return false;
+ }
+ 
  /* Walk a MODIFY_EXPR and categorize the assignment appropriately.  */
  
  static void
*************** sra_walk_modify_expr (tree expr, block_s
*** 891,897 ****
    /* If the RHS is scalarizable, handle it.  There are only two cases.  */
    if (rhs_elt)
      {
!       if (!rhs_elt->is_scalar && !TREE_SIDE_EFFECTS (lhs))
  	fns->ldst (rhs_elt, lhs, bsi, false);
        else
  	fns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false, false);
--- 920,928 ----
    /* If the RHS is scalarizable, handle it.  There are only two cases.  */
    if (rhs_elt)
      {
!       if (!rhs_elt->is_scalar
! 	  && !TREE_SIDE_EFFECTS (lhs)
! 	  && !view_convert_barrier_p (lhs))
  	fns->ldst (rhs_elt, lhs, bsi, false);
        else
  	fns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false, false);
*************** sra_walk_modify_expr (tree expr, block_s
*** 935,941 ****
  	 the result of a function call.  Which would result in trying to call
  	 the function multiple times, and other evil things.  */
        else if (!lhs_elt->is_scalar
! 	       && !TREE_SIDE_EFFECTS (rhs) && is_gimple_addressable (rhs))
  	fns->ldst (lhs_elt, rhs, bsi, true);
  
        /* Otherwise we're being used in some context that requires the
--- 966,974 ----
  	 the result of a function call.  Which would result in trying to call
  	 the function multiple times, and other evil things.  */
        else if (!lhs_elt->is_scalar
! 	       && !TREE_SIDE_EFFECTS (rhs)
! 	       && !view_convert_barrier_p (rhs)
! 	       && is_gimple_addressable (rhs))
  	fns->ldst (lhs_elt, rhs, bsi, true);
  
        /* Otherwise we're being used in some context that requires the
*** gcc/cfgbuild.c.0	2008-02-05 22:29:52.000000000 +0100
--- gcc/cfgbuild.c	2008-02-06 00:40:11.125886144 +0100
*************** control_flow_insn_p (rtx insn)
*** 120,126 ****
  	      || can_throw_internal (insn));
  
      case INSN:
!       return (flag_non_call_exceptions && can_throw_internal (insn));
  
      case BARRIER:
        /* It is nonsense to reach barrier when looking for the
--- 120,129 ----
  	      || can_throw_internal (insn));
  
      case INSN:
!       return (flag_non_call_exceptions
! 	      && can_throw_internal (insn)
! 	      /* ??? The IA-64 puts REG_EH_REGION notes on nops.  */
! 	      && GET_CODE (PATTERN (insn)) != CONST_INT);
  
      case BARRIER:
        /* It is nonsense to reach barrier when looking for the
*** gcc/print-tree.c.0	2008-02-06 10:16:01.000000000 +0100
--- gcc/print-tree.c	2008-02-06 10:16:46.825182648 +0100
*************** print_node (FILE *file, const char *pref
*** 751,756 ****
--- 751,771 ----
  	      }
  	  break;
  
+ 	case CONSTRUCTOR:
+ 	  {
+ 	    unsigned HOST_WIDE_INT cnt;
+ 	    tree index, value;
+ 	    len = VEC_length (constructor_elt, CONSTRUCTOR_ELTS (node));
+ 	    fprintf (file, " lngt %d", len);
+ 	    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (node),
+ 				      cnt, index, value)
+ 	      {
+ 		print_node (file, "idx", index, indent + 4);
+ 		print_node (file, "val", value, indent + 4);
+ 	      }
+ 	  }
+ 	  break;
+ 
      	case STATEMENT_LIST:
  	  fprintf (file, " head %p tail %p stmts",
  		   (void *) node->stmt_list.head, (void *) node->stmt_list.tail);
*** gcc/gimplify.c.ori	Mon Jan 14 14:21:59 2008
--- gcc/gimplify.c	Thu Feb  7 16:45:33 2008
*************** gimplify_modify_expr (tree *expr_p, tree
*** 3447,3453 ****
        tree size = TREE_OPERAND (*from_p, 1);
  
        if (TREE_CODE (from) == CONSTRUCTOR)
! 	return gimplify_modify_expr_to_memset (expr_p, size, want_value);
        if (is_gimple_addressable (from))
  	{
  	  *from_p = from;
--- 3447,3456 ----
        tree size = TREE_OPERAND (*from_p, 1);
  
        if (TREE_CODE (from) == CONSTRUCTOR)
! 	{
! 	  gcc_assert (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (from)));
! 	  return gimplify_modify_expr_to_memset (expr_p, size, want_value);
! 	}
        if (is_gimple_addressable (from))
  	{
  	  *from_p = from;
*** gcc/stor-layout.c.0	2008-02-17 10:17:50.000000000 +0100
--- gcc/stor-layout.c	2008-02-17 11:27:17.233107104 +0100
*************** layout_decl (tree decl, unsigned int kno
*** 590,602 ****
  	    {
  	      enum machine_mode xmode
  		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
  
  	      if (xmode != BLKmode
! 		  && (known_align == 0
! 		      || known_align >= GET_MODE_ALIGNMENT (xmode)))
  		{
! 		  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),
! 					   DECL_ALIGN (decl));
  		  DECL_MODE (decl) = xmode;
  		  DECL_BIT_FIELD (decl) = 0;
  		}
--- 590,602 ----
  	    {
  	      enum machine_mode xmode
  		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
+ 	      unsigned int xalign = GET_MODE_ALIGNMENT (xmode);
  
  	      if (xmode != BLKmode
! 		  && !(xalign > BITS_PER_UNIT && DECL_PACKED (decl))
! 		  && (known_align == 0 || known_align >= xalign))
  		{
! 		  DECL_ALIGN (decl) = MAX (xalign, DECL_ALIGN (decl));
  		  DECL_MODE (decl) = xmode;
  		  DECL_BIT_FIELD (decl) = 0;
  		}
*** gcc/config/rs6000/vxworks.h.ori	Mon Feb 18 17:44:39 2008
--- gcc/config/rs6000/vxworks.h	Mon Feb 18 17:46:20 2008
*************** VXWORKS_ADDITIONAL_CPP_SPEC
*** 235,237 ****
--- 235,239 ----
  
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ #define MD_UNWIND_SUPPORT "config/rs6000/vxworks-unwind.h"
*** gcc/config/rs6000/vxworks-unwind.h.ori	Mon Feb 18 17:23:04 2008
--- gcc/config/rs6000/vxworks-unwind.h	Tue Feb 19 12:27:58 2008
***************
*** 0 ****
--- 1,145 ----
+ /* DWARF2 EH unwinding support for PowerPC VxWorks.
+    Copyright (C) 2006 Free Software Foundation, Inc.
+ 
+    This file is part of GCC.
+ 
+    GCC is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published
+    by the Free Software Foundation; either version 2, or (at your
+    option) any later version.
+ 
+    In addition to the permissions in the GNU General Public License,
+    the Free Software Foundation gives you unlimited permission to link
+    the compiled version of this file with other programs, and to
+    distribute those programs without any restriction coming from the
+    use of this file.  (The General Public License restrictions do
+    apply in other respects; for example, they cover modification of
+    the file, and distribution when not linked into another program.)
+ 
+    GCC is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the
+    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+    MA 02110-1301, USA.  */
+ 
+ /* Do code reading to identify a signal frame, and set the frame
+    state data appropriately.  See unwind-dw2.c for the structs.  */
+ 
+ #define MD_FALLBACK_FRAME_STATE_FOR ppc_vxworks_fallback_frame_state
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <stddef.h>
+ #include <signal.h>
+ 
+ /* We need the constant and structure definitions describing the machine
+    state.  Part of this is normally retrieved from the VxWorks "regs.h" but
+    #including it here gets the GCC internals instance of this file instead.
+    We need to #include the version we need directly here, and prevent the
+    possibly indirect inclusion of the GCC one, as its contents is useless to
+    us and it depends on several other headers that we don't have at hand.  */
+ #include <arch/ppc/regsPpc.h>
+ #define GCC_REGS_H
+ 
+ #include <sigLib.h>
+ 
+ typedef struct sigcontext sigcontext_t;
+ 
+ /* Determine whether CONTEXT designates a signal handler, and return the
+    associated sigontext address if so.  Return NULL otherwise.  */
+ 
+ static sigcontext_t *
+ sigcontext_for (struct _Unwind_Context *context)
+ {
+   const unsigned int * ra = context->ra;
+ 
+   /* VxWorks 5.5.  */
+   if (*(ra - 6) == 0x7fe3fb78      /* or     r3,r31,r31 */
+       && *(ra - 5) == 0x389e000c   /* addi   r4,r30,0xc */
+       && *(ra - 4) == 0x7fa803a6   /* mtspr  LR,r29 */
+       && *(ra - 3) == 0x7fc5f378   /* or     r5,r30,r30 */
+       && *(ra - 2) == 0x4cc63182   /* crxor  crb6,crb6,crb6 */
+       && *(ra - 1) == 0x4e800021)  /* blrl */
+     {
+ 	struct {
+ 	    char pad [0x40];
+ 	    sigcontext_t sigcontext;
+ 	} * frame = context->cfa;
+ 	return &frame->sigcontext;
+     }
+ 
+   return 0;
+ }
+ 
+ /* The fallback proper.  */
+ 
+ #ifdef DWARF_ALT_FRAME_RETURN_COLUMN
+ #define RETURN_COLUMN DWARF_ALT_FRAME_RETURN_COLUMN
+ #else
+ #define RETURN_COLUMN ARG_POINTER_REGNUM
+ #endif
+ 
+ #define LR_REGNO LINK_REGISTER_REGNUM
+ 
+ #define REGISTER_CFA_OFFSET_FOR(FS,REGNO,ADDR,CFA)\
+ do { \
+ (FS)->regs.reg[REGNO].how = REG_SAVED_OFFSET; \
+ (FS)->regs.reg[REGNO].loc.offset = (long) (ADDR) - (CFA); \
+ } while (0);
+ 
+ static _Unwind_Reason_Code
+ ppc_vxworks_fallback_frame_state (struct _Unwind_Context *context,
+ 				  _Unwind_FrameState *fs)
+ {
+   static int eh_debug = -1;
+ 
+   sigcontext_t * sigctx = sigcontext_for (context);
+   REG_SET * mctx;
+ 
+   long new_cfa;
+   int i;
+ 
+   if (eh_debug == -1)
+     {
+       char *eh_debug_env = getenv ("EH_DEBUG");
+       eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+    }
+   
+   if (eh_debug)
+     printf ("FALLBACK called for CFA = %p, RA = %p, SIGCTX = %p\n",
+ 	    context->cfa, context->ra, sigctx);
+ 
+   if (sigctx == NULL)
+     return _URC_END_OF_STACK;
+ 
+   mctx = sigctx->sc_pregs;
+ 
+   /* The "kernel" frame cfa is the stack pointer at the signal occurrence
+      point.  */
+   new_cfa = mctx->gpr[STACK_POINTER_REGNUM];
+ 
+   fs->cfa_how = CFA_REG_OFFSET;
+   fs->cfa_reg = STACK_POINTER_REGNUM;
+   fs->cfa_offset = new_cfa - (long) context->cfa;
+ 
+   /* And we state how to find the various registers it has saved with
+      relative offset rules from there.  */
+ 
+   for (i = 0; i < 32; i++)
+     if (i != STACK_POINTER_REGNUM)
+       REGISTER_CFA_OFFSET_FOR (fs, i, &mctx->gpr[i], new_cfa);
+ 
+   REGISTER_CFA_OFFSET_FOR (fs, CR2_REGNO, &mctx->cr, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, XER_REGNO, &mctx->xer, new_cfa);
+   REGISTER_CFA_OFFSET_FOR (fs, LR_REGNO, &mctx->lr, new_cfa);
+ 
+   fs->retaddr_column = RETURN_COLUMN;
+   REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->pc, new_cfa);
+ 
+   return _URC_NO_REASON;
+ }
+ 
*** gcc/config/alpha/t-osf4.ori	Thu Feb 21 12:25:19 2008
--- gcc/config/alpha/t-osf4	Thu Feb 21 12:37:32 2008
*************** SHLIB_NAME = @shlib_base_name@.so
*** 10,20 ****
  SHLIB_SONAME = @shlib_base_name@.so.1
  SHLIB_OBJS = @shlib_objs@
  
! # Hide all POSIX threads related symbols provided by gthr-posix.c.  This
! # only has an effect if t-osf-pthread is in use.
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
- 	-Wl,-hidden_symbol,pthread\* -Wl,-hidden_symbol,__pthread\* \
- 	-Wl,-hidden_symbol,sched_get_\* -Wl,-hidden_symbol,sched_yield \
  	-Wl,-msym -Wl,-set_version,gcc.1 -Wl,-soname,$(SHLIB_SONAME) \
  	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
  	rm -f $(SHLIB_SONAME) && \
--- 10,21 ----
  SHLIB_SONAME = @shlib_base_name@.so.1
  SHLIB_OBJS = @shlib_objs@
  
! # We used to hide all POSIX threads related weak dummy symbols provided by
! # gthr-posix.c, only included if t-osf-pthread is in use. As documented in
! # "The Tru64 UNIX Object File/Symbol Table Format Specification", this
! # prevents their preemption with real symbols, so we don't do it any more.
! 
  SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
  	-Wl,-msym -Wl,-set_version,gcc.1 -Wl,-soname,$(SHLIB_SONAME) \
  	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
  	rm -f $(SHLIB_SONAME) && \
*** gcc/doc/tm.texi.ori	Mon Feb 25 11:41:19 2008
--- gcc/doc/tm.texi	Mon Feb 25 11:48:26 2008
*************** object files that are not referenced fro
*** 9549,9554 ****
--- 9549,9559 ----
  lists.
  @end defmac
  
+ @defmac COLLECT_PRESERVE_RO_OUTPUT
+ If defined, @code{collect2} will preserve an existing read-only output
+ file and return on error when one is found.
+ @end defmac
+ 
  @defmac MODIFY_JNI_METHOD_CALL (@var{mdecl})
  Define this macro to a C expression representing a variant of the
  method call @var{mdecl}, if Java Native Interface (JNI) methods
*** gcc/collect2.c.ori	Mon Feb 25 10:38:28 2008
--- gcc/collect2.c	Mon Feb 25 11:39:29 2008
*************** static char *resolve_lib_name (const cha
*** 283,292 ****
  #endif
  static char *extract_string (const char **);
  
! /* Delete tempfiles and exit function.  */
  
  void
! collect_exit (int status)
  {
    if (c_file != 0 && c_file[0])
      maybe_unlink (c_file);
--- 283,293 ----
  #endif
  static char *extract_string (const char **);
  
! /* Delete tempfiles, the output file unless KEEP_OUTPUT is non-zero,
!    and exit function.  */
  
  void
! collect_exit (int status, int keep_output)
  {
    if (c_file != 0 && c_file[0])
      maybe_unlink (c_file);
*************** collect_exit (int status)
*** 311,317 ****
        maybe_unlink (lderrout);
      }
  
!   if (status != 0 && output_file != 0 && output_file[0])
      maybe_unlink (output_file);
  
    exit (status);
--- 312,318 ----
        maybe_unlink (lderrout);
      }
  
!   if (status != 0 && !keep_output && output_file != 0 && output_file[0])
      maybe_unlink (output_file);
  
    exit (status);
*************** fatal_perror (const char * cmsgid, ...)
*** 343,349 ****
    fprintf (stderr, ": %s\n", xstrerror (e));
    va_end (ap);
  
!   collect_exit (FATAL_EXIT_CODE);
  }
  
  /* Just die.  */
--- 344,350 ----
    fprintf (stderr, ": %s\n", xstrerror (e));
    va_end (ap);
  
!   collect_exit (FATAL_EXIT_CODE, 0);
  }
  
  /* Just die.  */
*************** fatal (const char * cmsgid, ...)
*** 359,365 ****
    fprintf (stderr, "\n");
    va_end (ap);
  
!   collect_exit (FATAL_EXIT_CODE);
  }
  
  /* Write error message.  */
--- 360,366 ----
    fprintf (stderr, "\n");
    va_end (ap);
  
!   collect_exit (FATAL_EXIT_CODE, 0);
  }
  
  /* Write error message.  */
*************** main (int argc, char **argv)
*** 1275,1280 ****
--- 1276,1292 ----
  #endif
  	}
      }
+   
+   /* If we are to preserve an existing read-only output file, do so.  */
+ #ifdef COLLECT_PRESERVE_RO_OUTPUT
+   if (output_file
+       && access (output_file, F_OK) == 0
+       && access (output_file, W_OK) != 0)
+     {
+       error ("output file %s exists and is read-only", output_file);
+       collect_exit (FATAL_EXIT_CODE, 1);
+     }
+ #endif
  
  #ifdef COLLECT_EXPORT_LIST
    /* This is added only for debugging purposes.  */
*************** collect_wait (const char *prog, struct p
*** 1568,1574 ****
  	  error ("%s terminated with signal %d [%s]%s",
  		 prog, sig, strsignal(sig),
  		 WCOREDUMP(status) ? ", core dumped" : "");
! 	  collect_exit (FATAL_EXIT_CODE);
  	}
  
        if (WIFEXITED (status))
--- 1580,1586 ----
  	  error ("%s terminated with signal %d [%s]%s",
  		 prog, sig, strsignal(sig),
  		 WCOREDUMP(status) ? ", core dumped" : "");
! 	  collect_exit (FATAL_EXIT_CODE, 0);
  	}
  
        if (WIFEXITED (status))
*************** do_wait (const char *prog, struct pex_ob
*** 1584,1590 ****
    if (ret != 0)
      {
        error ("%s returned %d exit status", prog, ret);
!       collect_exit (ret);
      }
  }
  
--- 1596,1602 ----
    if (ret != 0)
      {
        error ("%s returned %d exit status", prog, ret);
!       collect_exit (ret, 0);
      }
  }
  
*** gcc/collect2.h.ori	Mon Feb 25 10:46:14 2008
--- gcc/collect2.h	Mon Feb 25 10:46:38 2008
*************** extern void do_tlink (char **, char **);
*** 26,32 ****
  extern struct pex_obj *collect_execute (const char *, char **, const char *,
  					const char *);
  
! extern void collect_exit (int) ATTRIBUTE_NORETURN;
  
  extern int collect_wait (const char *, struct pex_obj *);
  
--- 26,32 ----
  extern struct pex_obj *collect_execute (const char *, char **, const char *,
  					const char *);
  
! extern void collect_exit (int, int) ATTRIBUTE_NORETURN;
  
  extern int collect_wait (const char *, struct pex_obj *);
  
*** gcc/tlink.c.ori	Mon Feb 25 10:46:25 2008
--- gcc/tlink.c	Mon Feb 25 10:46:46 2008
*************** do_tlink (char **ld_argv, char **object_
*** 773,778 ****
    if (exit)
      {
        error ("ld returned %d exit status", exit);
!       collect_exit (exit);
      }
  }
--- 773,778 ----
    if (exit)
      {
        error ("ld returned %d exit status", exit);
!       collect_exit (exit, 0);
      }
  }
*** gcc/config/rs6000/aix.h.ori	Mon Feb 25 11:58:13 2008
--- gcc/config/rs6000/aix.h	Mon Feb 25 11:59:34 2008
***************
*** 50,55 ****
--- 50,58 ----
     collect has a chance to see them, so scan the object files directly.  */
  #define COLLECT_EXPORT_LIST
  
+ /* The AIX linker preserves read-only executables.  */
+ #define COLLECT_PRESERVE_RO_OUTPUT
+ 
  /* Handle #pragma weak and #pragma pack.  */
  #define HANDLE_SYSV_PRAGMA 1
  
*** gcc/common.opt.0	2008-03-07 22:19:46.416171240 +0100
--- gcc/common.opt	2008-03-07 22:19:49.028774064 +0100
*************** fvariable-expansion-in-unroller
*** 819,824 ****
--- 819,828 ----
  Common Report Var(flag_variable_expansion_in_unroller) 
  Apply variable expansion when loops are unrolled
  
+ fsjlj
+ Common Var(flag_sjlj)
+ Only accepted for compatibility with GCC 4.3
+ 
  fold-stack-check
  Common Report
  Insert old-style stack checking code into the program
*** gcc/Makefile.in.orig	Wed Mar 12 16:04:59 2008
--- gcc/Makefile.in	Wed Mar 12 16:06:45 2008
***************
*** 281,286 ****
--- 281,288 ----
  # UNSORTED
  # --------
  
+ CROSS=@CROSS@
+ 
  # Some compilers can't handle cc -c blah.c -o foo/blah.o.
  # In stage2 and beyond, we force this to "-o $@" since we know we're using gcc.
  OUTPUT_OPTION = @OUTPUT_OPTION@
*** gcc/expr.h.0	2008-03-13 23:20:41.000000000 +0100
--- gcc/expr.h	2008-03-25 07:42:02.000000000 +0100
*************** do {							\
*** 217,227 ****
--- 217,237 ----
  #define STACK_CHECK_PROBE_INTERVAL_EXP 12
  #endif
  
+ /* The default is not to use an inclusive OR.  */
+ #ifndef STACK_CHECK_PROBE_IOR
+ #define STACK_CHECK_PROBE_IOR 0
+ #endif
+ 
  /* The default is to do a store into the stack.  */
  #ifndef STACK_CHECK_PROBE_LOAD
  #define STACK_CHECK_PROBE_LOAD 0
  #endif
  
+ /* The default is not to move the stack pointer.  */
+ #ifndef STACK_CHECK_MOVING_SP
+ #define STACK_CHECK_MOVING_SP 0
+ #endif
+ 
  /* This is a kludge to try to capture the discrepancy between the old
     mechanism (generic stack checking) and the new mechanism (static
     builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped
*** gcc/doc/tm.texi.0	2008-03-13 23:20:23.000000000 +0100
--- gcc/doc/tm.texi	2008-03-25 07:42:02.000000000 +0100
*************** the ``guard pages'' at the end of a stac
*** 3174,3185 ****
  of 12 (4096-byte interval) is suitable for most systems.
  @end defmac
  
  @defmac STACK_CHECK_PROBE_LOAD
! A integer which is nonzero if GCC should perform the stack probe
  as a load instruction and zero if GCC should use a store instruction.
  The default is zero, which is the most efficient choice on most systems.
  @end defmac
  
  @defmac STACK_CHECK_PROTECT
  The number of bytes of stack needed to recover from a stack overflow,
  for languages where such a recovery is supported.  The default value of
--- 3174,3199 ----
  of 12 (4096-byte interval) is suitable for most systems.
  @end defmac
  
+ @defmac STACK_CHECK_PROBE_IOR
+ An integer which is nonzero if GCC should perform the stack probe
+ as an inclusive OR instruction.  The default is zero.
+ @end defmac
+ 
  @defmac STACK_CHECK_PROBE_LOAD
! An integer which is nonzero if GCC should perform the stack probe
  as a load instruction and zero if GCC should use a store instruction.
  The default is zero, which is the most efficient choice on most systems.
  @end defmac
  
+ @defmac STACK_CHECK_MOVING_SP
+ An integer which is nonzero if GCC should move the stack pointer during
+ stack checking.  This can be necessary on systems where the stack pointer
+ contains the bottom address of the memory area accessible to the executing
+ thread at any point in time.  In this situation an alternate signal stack
+ is required in order to be able to recover from a stack overflow.
+ The default value of this macro is zero.
+ @end defmac
+ 
  @defmac STACK_CHECK_PROTECT
  The number of bytes of stack needed to recover from a stack overflow,
  for languages where such a recovery is supported.  The default value of
*** gcc/explow.c.0	2008-12-14 16:54:04.000000000 +0100
--- gcc/explow.c	2008-12-14 16:54:16.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 42,47 ****
--- 42,48 ----
  
  static rtx break_out_memory_refs (rtx);
  static void emit_stack_probe (rtx);
+ static void anti_adjust_stack_and_probe (rtx);
  
  
  /* Truncate and perhaps sign-extend C as appropriate for MODE.  */
*************** allocate_dynamic_stack_space (rtx size, 
*** 1196,1204 ****
    gcc_assert (!(stack_pointer_delta
  		% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));
  
!   /* If needed, check that we have the required amount of stack.  Take into
!      account what has already been checked.  */
!   if (flag_stack_check == GENERIC_STACK_CHECK)
      probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,
  		       size);
    else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
--- 1197,1207 ----
    gcc_assert (!(stack_pointer_delta
  		% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));
  
!   /* If needed, check that we have the required amount of stack.
!      Take into account what has already been checked.  */
!   if (STACK_CHECK_MOVING_SP)
!     ;
!   else if (flag_stack_check == GENERIC_STACK_CHECK)
      probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,
  		       size);
    else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
*************** allocate_dynamic_stack_space (rtx size, 
*** 1267,1273 ****
  	  emit_label (space_available);
  	}
  
!       anti_adjust_stack (size);
  
  #ifdef STACK_GROWS_DOWNWARD
        emit_move_insn (target, virtual_stack_dynamic_rtx);
--- 1270,1279 ----
  	  emit_label (space_available);
  	}
  
!       if (flag_stack_check && STACK_CHECK_MOVING_SP)
! 	anti_adjust_stack_and_probe (size);
!       else
! 	anti_adjust_stack (size);
  
  #ifdef STACK_GROWS_DOWNWARD
        emit_move_insn (target, virtual_stack_dynamic_rtx);
*************** emit_stack_probe (rtx address)
*** 1318,1324 ****
  
    MEM_VOLATILE_P (memref) = 1;
  
!   if (STACK_CHECK_PROBE_LOAD)
      emit_move_insn (gen_reg_rtx (word_mode), memref);
    else
      emit_move_insn (memref, const0_rtx);
--- 1324,1339 ----
  
    MEM_VOLATILE_P (memref) = 1;
  
!   if (STACK_CHECK_PROBE_IOR)
!     {
!       if (word_mode == SImode)
! 	emit_insn (gen_iorsi3 (memref, const0_rtx, memref));
!       else if (word_mode == DImode)
! 	emit_insn (gen_iordi3 (memref, const0_rtx, memref));
!       else
! 	gcc_unreachable ();
!     }
!   else if (STACK_CHECK_PROBE_LOAD)
      emit_move_insn (gen_reg_rtx (word_mode), memref);
    else
      emit_move_insn (memref, const0_rtx);
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1398,1416 ****
       small number of them to generate, that's the easy case.  */
    else if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
      {
!       HOST_WIDE_INT i;
  
        /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
  	 it exceeds SIZE.  If only one probe is needed, this will not
! 	 generate any code.  Then probe at SIZE.  */
!       for (i = PROBE_INTERVAL; i < INTVAL (size); i += PROBE_INTERVAL)
! 	emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					  stack_pointer_rtx,
! 					  GEN_INT (i + first)));
! 
!       emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					stack_pointer_rtx,
! 					plus_constant (size, first)));
      }
  
    /* In the variable case, do the same as above, but in a loop.  Note that we
--- 1413,1441 ----
       small number of them to generate, that's the easy case.  */
    else if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
      {
!       HOST_WIDE_INT i, offset, size_int = INTVAL (size);
!       rtx addr;
  
        /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
  	 it exceeds SIZE.  If only one probe is needed, this will not
! 	 generate any code.  Then probe at FIRST + SIZE.  */
!       for (i = PROBE_INTERVAL; i < size_int; i += PROBE_INTERVAL)
! 	{
! 	  offset = first + i;
! #ifdef STACK_GROWS_DOWNWARD
! 	  offset = -offset;
! #endif
! 	  addr = memory_address (Pmode,
! 				 plus_constant (stack_pointer_rtx, offset));
! 	  emit_stack_probe (addr);
! 	}
! 
!       offset = first + size_int;
! #ifdef STACK_GROWS_DOWNWARD
!       offset = -offset;
! #endif
!       addr = memory_address (Pmode, plus_constant (stack_pointer_rtx, offset));
!       emit_stack_probe (addr);
      }
  
    /* In the variable case, do the same as above, but in a loop.  Note that we
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1457,1463 ****
  	    }
  
  	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
! 	 until it exceeds ROUNDED_SIZE.  */
  
        emit_label (loop_lab);
  
--- 1482,1488 ----
  	    }
  
  	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
! 	 until it is equal to ROUNDED_SIZE.  */
  
        emit_label (loop_lab);
  
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1479,1486 ****
  
        emit_label (end_lab);
  
!       /* Step 4: probe at SIZE if we cannot assert at compile-time that
! 	 it is equal to ROUNDED_SIZE.  */
  
        /* TEMP = SIZE - ROUNDED_SIZE.  */
        temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);
--- 1504,1643 ----
  
        emit_label (end_lab);
  
!       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
! 	 that SIZE is equal to ROUNDED_SIZE.  */
! 
!       /* TEMP = SIZE - ROUNDED_SIZE.  */
!       temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);
!       if (temp != const0_rtx)
! 	{
! 	  rtx addr;
! 
! 	  if (GET_CODE (temp) == CONST_INT)
! 	    {
! 	      /* Use [base + disp} addressing mode if supported.  */
! 	      HOST_WIDE_INT offset = INTVAL (temp);
! #ifdef STACK_GROWS_DOWNWARD
! 	      offset = -offset;
! #endif
! 	      addr = memory_address (Pmode, plus_constant (last_addr, offset));
! 	    }
! 	  else
! 	    {
! 	      /* Manual CSE if the difference is not known at compile-time.  */
! 	      temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);
! 	      addr = memory_address (Pmode,
! 				     gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 						     last_addr, temp));
! 	    }
! 
! 	  emit_stack_probe (addr);
! 	}
!     }
! }
! 
! /* Adjust the stack by SIZE bytes while probing it.  Note that we skip the
!    probe for the first interval + a small dope of 4 words and instead probe
!    that many bytes past the specified size to maintain a protection area.  */
! 
! static void
! anti_adjust_stack_and_probe (rtx size)
! {
!   const int dope = 4 * UNITS_PER_WORD;
! 
!   /* First ensure SIZE is Pmode.  */
!   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)
!     size = convert_to_mode (Pmode, size, 1);
! 
!   /* If we have a constant small number of probes to generate, that's the
!      easy case.  */
!   if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)
!     {
!       HOST_WIDE_INT i, int_size = INTVAL (size);
!       bool first_probe = true;
! 
!       /* Adjust SP and probe to PROBE_INTERVAL + N * PROBE_INTERVAL for
! 	 values of N from 1 until it exceeds SIZE.  If only one probe is
! 	 needed, this will not generate any code.  Then adjust and probe
! 	 to PROBE_INTERVAL + SIZE.  */
!       for (i = PROBE_INTERVAL; i < int_size; i += PROBE_INTERVAL)
! 	{
! 	  if (first_probe)
! 	    {
! 	      anti_adjust_stack (GEN_INT (2 * PROBE_INTERVAL + dope));
! 	      first_probe = false;
! 	    }
! 	  else
! 	    anti_adjust_stack (GEN_INT (PROBE_INTERVAL));
! 	  emit_stack_probe (stack_pointer_rtx);
! 	}
! 
!       if (first_probe)
! 	anti_adjust_stack (plus_constant (size, PROBE_INTERVAL + dope));
!       else
! 	anti_adjust_stack (plus_constant (size, PROBE_INTERVAL - i));
!       emit_stack_probe (stack_pointer_rtx);
!     }
! 
!   /* In the variable case, do the same as above, but in a loop.  Note that we
!      must be extra careful with variables wrapping around because we might be
!      at the very top (or the very bottom) of the address space and we have to
!      be able to handle this case properly; in particular, we use an equality
!      test for the loop condition.  */
!   else
!     {
!       rtx rounded_size, rounded_size_op, last_addr, temp;
!       rtx loop_lab = gen_label_rtx ();
!       rtx end_lab = gen_label_rtx ();
! 
!       /* Step 1: round SIZE to the previous multiple of the interval.  */
! 
!       /* ROUNDED_SIZE = SIZE & -PROBE_INTERVAL  */
!       rounded_size = simplify_gen_binary (AND, Pmode,
! 					  size,
! 					  GEN_INT (-PROBE_INTERVAL));
!       rounded_size_op = force_operand (rounded_size, NULL_RTX);
! 
! 
!       /* Step 2: compute initial and final value of the loop counter.  */
! 
!       /* SP = SP_0 + PROBE_INTERVAL.  */
!       anti_adjust_stack (GEN_INT (PROBE_INTERVAL + dope));
! 
!       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */
!       last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 						 stack_pointer_rtx,
! 						 rounded_size_op),
! 				 NULL_RTX);
! 
! 
!       /* Step 3: the loop
! 
! 	  while (SP != LAST_ADDR)
! 	    {
! 	      SP = SP + PROBE_INTERVAL
! 	      probe at SP
! 	    }
! 
! 	 adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for
! 	 values of N from 1 until it is equal to ROUNDED_SIZE.  */
! 
!       emit_label (loop_lab);
! 
!       /* Jump to END_LAB if SP == LAST_ADDR.  */
!       emit_cmp_and_jump_insns (stack_pointer_rtx, last_addr, EQ,
! 			       NULL_RTX, Pmode, 1, end_lab);
! 
!       /* SP = SP + PROBE_INTERVAL and probe at SP.  */
!       anti_adjust_stack (GEN_INT (PROBE_INTERVAL));
!       emit_stack_probe (stack_pointer_rtx);
! 
!       emit_jump (loop_lab);
! 
!       emit_label (end_lab);
! 
!       /* Step 4: adjust SP and probe to PROBE_INTERVAL + SIZE if we cannot
! 	 assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */
  
        /* TEMP = SIZE - ROUNDED_SIZE.  */
        temp = simplify_gen_binary (MINUS, Pmode, size, rounded_size);
*************** probe_stack_range (HOST_WIDE_INT first, 
*** 1489,1501 ****
  	  /* Manual CSE if the difference is not known at compile-time.  */
  	  if (GET_CODE (temp) != CONST_INT)
  	    temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);
! 	  emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,
! 					    last_addr,
! 					    temp));
  	}
      }
  }
! 
  /* Return an rtx representing the register or memory location
     in which a scalar value of data type VALTYPE
     was returned by a function call to function FUNC.
--- 1646,1660 ----
  	  /* Manual CSE if the difference is not known at compile-time.  */
  	  if (GET_CODE (temp) != CONST_INT)
  	    temp = gen_rtx_MINUS (Pmode, size, rounded_size_op);
! 	  anti_adjust_stack (temp);
! 	  emit_stack_probe (stack_pointer_rtx);
  	}
      }
+ 
+   /* Adjust back to account for the additional first interval.  */
+   adjust_stack (GEN_INT (PROBE_INTERVAL + dope));
  }
! 
  /* Return an rtx representing the register or memory location
     in which a scalar value of data type VALTYPE
     was returned by a function call to function FUNC.
*** gcc/reload1.c.0	2008-03-13 23:20:52.000000000 +0100
--- gcc/reload1.c	2008-03-25 07:42:02.000000000 +0100
*************** init_elim_table (void)
*** 3548,3553 ****
--- 3548,3556 ----
  			     sp-adjusting insns for this case.  */
  			  || (current_function_calls_alloca
  			      && EXIT_IGNORE_STACK)
+ 			  /* We need the frame pointer to catch stack overflow
+ 			     exceptions if sp is moved by stack cheking.  */
+ 			  || (flag_stack_check && STACK_CHECK_MOVING_SP)
  			  || current_function_accesses_prior_frames
  			  || FRAME_POINTER_REQUIRED);
  
*** gcc/rtlanal.c.0	2008-03-14 23:14:44.000000000 +0100
--- gcc/rtlanal.c	2008-03-25 07:42:02.000000000 +0100
*************** Software Foundation, 51 Franklin Street,
*** 36,41 ****
--- 36,42 ----
  #include "real.h"
  #include "regs.h"
  #include "function.h"
+ #include "expr.h"
  
  /* Forward declarations */
  static int global_reg_mentioned_p_1 (rtx *, void *);
*************** may_trap_p_1 (rtx x, bool unaligned_mems
*** 2142,2147 ****
--- 2143,2153 ----
  
        /* Memory ref can trap unless it's a static var or a stack slot.  */
      case MEM:
+       /* Recognize specific pattern of stack checking probes.  */
+       if (STACK_CHECK_MOVING_SP
+ 	  && MEM_VOLATILE_P (x)
+ 	  && XEXP (x, 0) == stack_pointer_rtx)
+ 	return 1;
        if (MEM_NOTRAP_P (x)
  	  && (!STRICT_ALIGNMENT || !unaligned_mems))
  	return 0;
*** gcc/Makefile.in.0	2008-03-14 23:43:07.000000000 +0100
--- gcc/Makefile.in	2008-03-25 07:42:02.000000000 +0100
*************** print-rtl.o : print-rtl.c $(CONFIG_H) $(
*** 2073,2079 ****
      $(BCONFIG_H)
  rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
     $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h \
!    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) function.h
  
  varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(FLAGS_H) function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \
--- 2073,2079 ----
      $(BCONFIG_H)
  rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \
     $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h \
!    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) function.h $(EXPR_H)
  
  varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(FLAGS_H) function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \
*** gcc/config/i386/i386.h.0	2008-03-20 17:51:04.000000000 +0100
--- gcc/config/i386/i386.h	2008-03-25 07:42:02.000000000 +0100
*************** struct machine_function GTY(())
*** 2305,2312 ****
  #define SYMBOL_REF_FAR_ADDR_P(X)	\
  	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_FAR_ADDR) != 0)
  
! /* Define this to be nonzero if static stack checking is supported.  */
! #define STACK_CHECK_STATIC_BUILTIN 1
  
  /*
  Local variables:
--- 2305,2312 ----
  #define SYMBOL_REF_FAR_ADDR_P(X)	\
  	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_FAR_ADDR) != 0)
  
! /* Define this to be nonzero to use an inclusive OR.  */
! #define STACK_CHECK_PROBE_IOR 1
  
  /*
  Local variables:
*** gcc/config/i386/cygming.h.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/cygming.h	2008-03-25 07:42:02.000000000 +0100
*************** extern int i386_pe_dllimport_name_p (con
*** 435,440 ****
--- 435,443 ----
  
  #define MD_UNWIND_SUPPORT "config/i386/win32-unwind.h"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #undef TREE
  
  #ifndef BUFSIZ
*** gcc/config/i386/freebsd.h.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/freebsd.h	2008-03-25 07:42:02.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 144,146 ****
--- 144,149 ----
  #define TARGET_96_ROUND_53_LONG_DOUBLE 0
  
  #define MD_UNWIND_SUPPORT "config/i386/freebsd-unwind.h"
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/i386/linux64.h.0	2008-03-17 23:49:03.000000000 +0100
--- gcc/config/i386/linux64.h	2008-03-25 07:42:02.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 99,104 ****
--- 99,110 ----
  
  #define MD_UNWIND_SUPPORT "config/i386/linux-unwind.h"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Define this to be nonzero if the stack pointer needs to be moved.  */
+ #define STACK_CHECK_MOVING_SP 1
+ 
  /* This macro may be overridden in i386/k*bsd-gnu.h.  */
  #define REG_NAME(reg) reg
  
*** gcc/config/i386/linux.h.0	2008-03-17 23:48:25.000000000 +0100
--- gcc/config/i386/linux.h	2008-03-25 07:42:02.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 211,216 ****
--- 211,222 ----
  
  #define MD_UNWIND_SUPPORT "config/i386/linux-unwind.h"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
+ /* Define this to be nonzero if the stack pointer needs to be moved.  */
+ #define STACK_CHECK_MOVING_SP 1
+ 
  /* This macro may be overridden in i386/k*bsd-gnu.h.  */
  #define REG_NAME(reg) reg
  
*** gcc/config/i386/lynx.h.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/lynx.h	2008-03-25 07:42:02.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 89,91 ****
--- 89,94 ----
     TLS is detected by configure.  We undefine it here.  */
  
  #undef HAVE_AS_TLS
+ 
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
*** gcc/config/i386/sol2.h.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/sol2.h	2008-03-25 07:42:02.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 118,123 ****
--- 118,126 ----
  
  #define MD_UNWIND_SUPPORT "config/i386/sol2-unwind.h"
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  /* The maximum alignment 'malloc' is guaranteed to offer.  */
  #undef  MALLOC_ALIGNMENT
  #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
*** gcc/config/i386/vxworks.h.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/vxworks.h	2008-03-25 07:42:02.000000000 +0100
*************** Boston, MA 02110-1301, USA.  */
*** 87,92 ****
--- 87,95 ----
  #undef FUNCTION_PROFILER
  #define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  /* This platform supports the probing method of stack checking (RTP mode)
     and the ZCX mechanism. 8K is reserved in the stack to propagate
     exceptions reliably in case of stack overflow. */
*** gcc/config/i386/i386.c.0	2008-12-14 16:54:09.000000000 +0100
--- gcc/config/i386/i386.c	2008-12-14 16:54:16.000000000 +0100
*************** const struct attribute_spec ix86_attribu
*** 1951,1962 ****
  bool
  ix86_target_stack_probe (void)
  {
!   /* Do not probe the stack twice if static builtin stack checking is
!      enabled and done with probes.  */
!   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && !stack_check_libfunc)
      return false;
  
!   return TARGET_STACK_PROBE != 0;
  }
  
  /* Decide whether we can make a sibling call to a function.  DECL is the
--- 1951,1961 ----
  bool
  ix86_target_stack_probe (void)
  {
!   /* Do not probe the stack twice if static stack checking is enabled.  */
!   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
      return false;
  
!   return TARGET_STACK_PROBE;
  }
  
  /* Decide whether we can make a sibling call to a function.  DECL is the
*************** ix86_compute_frame_layout (struct ix86_f
*** 4758,4763 ****
--- 4757,4766 ----
    else
      frame->save_regs_using_mov = false;
  
+   /* If static stack checking is enabled and done with probes, the registers
+      need to be saved before allocating the frame.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && !stack_check_symbol)
+     frame->save_regs_using_mov = false;
  
    /* Skip return address and saved base pointer.  */
    offset = frame_pointer_needed ? UNITS_PER_WORD * 2 : UNITS_PER_WORD;
*************** ix86_compute_frame_layout (struct ix86_f
*** 4865,5274 ****
  #endif
  }
  
- /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
-    inclusive.  These are offsets from the current stack pointer.  */
- 
- #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
- 
- /* The run-time loop is made up of 8 insns in the generic case while this
-    compile-time loop is made up of n insns for n # of intervals.  */
- #define SMALL_INTERVAL(size)  ((size) <= 8 * PROBE_INTERVAL)
- 
- static void
- ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
- {
-   /* On the x86 we may have no scratch registers; in this case, we need
-      to save and restore the registers we are going to clobber.  */
-   int regparm = ix86_function_regparm (TREE_TYPE (current_function_decl),
- 				       current_function_decl)
- 		  - current_function_args_info.nregs;
- 
-   gcc_assert (0 <= regparm && regparm <= REGPARM_MAX);
- 
-   if (stack_check_libfunc)
-     {
-       rtx fnaddr = gen_rtx_MEM (QImode, stack_check_libfunc);
-       rtx real_pic_offset_table_rtx = NULL_RTX, insn;
- 
-       /* We must end up aligned on PREFERRED_STACK_BOUNDARY immediately
- 	 before the call:
-                                        __________
- 	   saved pc                                ^
- 	   saved static chain pointer              |
- 	   saved PIC register                      |  n*STACK_SLOT_SIZE bytes
- 	   padding                                 |
- 	   allocated space             __________  V
-        */
- 
-       const int stack_slot_size = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;
-       const int pc = 1;
- 
-       int static_chain = (cfun->static_chain_decl != NULL_TREE);
-       int pic = (pic_offset_table_rtx != NULL_RTX);
-       int n_saved = static_chain + pic;
-       int n_allocated = regparm + !TARGET_64BIT;
-       int used = (pc + n_saved + n_allocated) * UNITS_PER_WORD;
-       int n_slots = (used + stack_slot_size - 1) / stack_slot_size;
-       int padding = n_slots * stack_slot_size - used;
-       int total = padding + (n_saved + n_allocated) * UNITS_PER_WORD;
- 
-       /* Save the static chain register if necessary.  */
-       if (static_chain)
-         {
- 	  insn = emit_insn (gen_push (static_chain_rtx));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	}
- 
-       /* Load the PIC register after saving it if necessary  */
-       if (pic)
- 	{
- 	  /* Beware that pic_offset_table_rtx may not be the canonical
- 	     PIC register under certain circumstances.  */
- 	  real_pic_offset_table_rtx
- 	    = gen_raw_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM);
- 	  insn = emit_insn (gen_push (real_pic_offset_table_rtx));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	  emit_insn (gen_set_got (real_pic_offset_table_rtx));
- 
- 	  /* Make sure the call is not scheduled before the above code.  */
- 	  emit_insn (gen_blockage (real_pic_offset_table_rtx));
- 	}
- 
-       /* Allocate space and/or maintain the stack alignment.  */
-       if (n_allocated || padding)
-         {
- 	  rtx dec = GEN_INT (padding + n_allocated * UNITS_PER_WORD);
- 	  insn = emit_insn (gen_sub2_insn (stack_pointer_rtx, dec));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	}
- 
-       /* Perform the call operation.  */
-       if (TARGET_64BIT)
-         {
- 	  rtx reg, mem, edi = gen_rtx_REG (Pmode, 5);
- 	  rtx disp, call, use = NULL_RTX;
- 	  int i;
- 
- 	  /* Save parameter registers used by the current function.  */
- 	  for (i = 0; i < regparm; i++)
- 	    {
- 	      reg = gen_rtx_REG (Pmode, x86_64_int_parameter_registers[i]);
- 	      mem = gen_rtx_MEM (Pmode,
- 				 plus_constant (stack_pointer_rtx,
- 					        i * UNITS_PER_WORD));
- 	      emit_move_insn (mem, reg);
- 	    }
- 
- 	  /* Pass the bottom of the range to the checking function.  */
- 	  disp = GEN_INT (-(first + size));
- 	  if (x86_64_immediate_operand (disp, DImode))
- 	    emit_insn (gen_add3_insn (edi, stack_pointer_rtx, disp));
- 	  else
- 	    {
- 	      emit_move_insn (edi, disp);
- 	      emit_insn (gen_add2_insn (edi, stack_pointer_rtx));
- 	    }
- 
- 	  call = emit_call_insn (gen_call (fnaddr, const0_rtx, constm1_rtx));
- 	  use_reg (&use, edi);
- 	  CALL_INSN_FUNCTION_USAGE (call) = use;
- 
- 	  /* Restore parameter registers previously saved.  */
- 	  for (i = 0; i < regparm; i++)
- 	    {
- 	      reg = gen_rtx_REG (Pmode, x86_64_int_parameter_registers[i]);
- 	      mem = gen_rtx_MEM (Pmode,
- 				 plus_constant (stack_pointer_rtx,
- 					        i * UNITS_PER_WORD));
- 	      insn = emit_move_insn (reg, mem);
- 	      /* The register may be dead in the end.  */
- 	      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
- 						    reg,
- 						    REG_NOTES (insn));
- 	    }
- 	}
-       else
- 	{
- 	  rtx reg, mem, eax = gen_rtx_REG (Pmode, 0);
- 	  int i;
- 
- 	  /* Save parameter registers used by the current function.  */
- 	  for (i = 0; i < regparm; i++)
- 	    {
- 	      reg = gen_rtx_REG (Pmode, i);
- 	      mem = gen_rtx_MEM (Pmode,
- 				 plus_constant (stack_pointer_rtx,
- 					        (i + 1) * UNITS_PER_WORD));
- 	      emit_move_insn (mem, reg);
- 	    }
- 
- 	  /* Pass the bottom of the range to the checking function.  */
- 	  emit_move_insn (eax,
- 			  plus_constant (stack_pointer_rtx, -(first + size)));
- 	  emit_move_insn (gen_rtx_MEM (Pmode, stack_pointer_rtx), eax);
- 	  emit_call_insn (gen_call (fnaddr, GEN_INT (UNITS_PER_WORD), 0));
- 
- 	  /* Restore parameter registers previously saved.  */
- 	  for (i = 0; i < regparm; i++)
- 	    {
- 	      reg = gen_rtx_REG (Pmode, i);
- 	      mem = gen_rtx_MEM (Pmode,
- 				 plus_constant (stack_pointer_rtx,
- 					        (i + 1) * UNITS_PER_WORD));
- 	      insn = emit_move_insn (reg, mem);
- 	      /* The register may be dead in the end.  */
- 	      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
- 						    reg,
- 						    REG_NOTES (insn));
- 	    }
- 	}
- 
-       /* Restore the PIC register if necessary.  */
-       if (pic)
- 	{
- 	  rtx mem = gen_rtx_MEM (Pmode,
- 				 plus_constant (stack_pointer_rtx,
- 					        total - n_saved * UNITS_PER_WORD));
- 	  insn = emit_move_insn (real_pic_offset_table_rtx, mem);
- 	  /* The register may be dead in the end.  */
- 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
- 						real_pic_offset_table_rtx,
- 						REG_NOTES (insn));
- 	}
- 
-       /* Restore the static chain register if necessary.  */
-       if (static_chain)
- 	{
- 	  rtx mem = gen_rtx_MEM (Pmode,
- 				 plus_constant (stack_pointer_rtx,
- 					        total - UNITS_PER_WORD));
- 	  insn = emit_move_insn (static_chain_rtx, mem);
- 	  /* The register may be dead in the end.  */
- 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
- 						static_chain_rtx,
- 						REG_NOTES (insn));
- 	}
- 
-       /* Restore the stack pointer.  Phew!  */
-       insn = emit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (total)));
-       RTX_FRAME_RELATED_P (insn) = 1;
-     }
- 
-   else if (TARGET_64BIT)
-     ; /* Not yet implemented, but do not assert as we'll get there when
- 	 compiling C code.  Doing nothing is not worse than emitting
- 	 useless probes.  */
- 
-   else if (stack_check_symbol)
-     {
-       rtx reg, res;
-       bool live_p;
- 
-       /* Find a scratch register, if any.  */
-       if (regparm <= 1
- 	  || (regparm == 2 && !needs_static_chain_p (current_function_decl)))
- 	{
- 	  reg = gen_rtx_REG (Pmode, regparm);
- 	  live_p = false;
- 	}
-       else
- 	{
- 	  reg = gen_rtx_REG (Pmode, 0);
- 	  live_p = true;
- 	}
- 
-       /* Save the register if necessary.  */
-       if (live_p)
- 	{
- 	  rtx insn = emit_insn (gen_push (reg));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	}
- 
-       emit_move_insn (reg,
- 		      plus_constant (stack_pointer_rtx, -(first + size)));
-       res = ix86_expand_int_compare (LTU, reg,
- 				     gen_rtx_MEM (Pmode, stack_check_symbol));
-       emit_insn (gen_rtx_TRAP_IF (VOIDmode, res, GEN_INT (6)));
- 
-       /* Restore the clobbered register if necessary.  Note that we cannot
- 	 use the pop insn because the RTX_FRAME_RELATED_P mechanism doesn't
- 	 know how to handle it.  */
-       if (live_p)
- 	{
- 	  rtx mem = gen_rtx_MEM (Pmode, stack_pointer_rtx);
- 	  rtx insn = emit_move_insn (reg, mem);
- 	  /* The register may be dead in the end.  */
- 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
- 						reg,
- 						REG_NOTES (insn));
- 	  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,
- 					   GEN_INT (UNITS_PER_WORD)));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	}
-     }
- 
-   else
-     {
-       int i, n = SMALL_INTERVAL (size) ? 0 : MIN (regparm, 2);
- 
-       /* Save eax and edx if they are used as parameter registers by the
- 	 current function and are clobbered by the probing code.  */
-       for (i = 0; i < n; i++)
- 	{
- 	  rtx reg = gen_rtx_REG (Pmode, i);
- 	  rtx insn = emit_insn (gen_push (reg));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	}
- 
-       emit_insn (gen_probe_stack_range (GEN_INT (first), GEN_INT (size)));
- 
-       /* Restore parameter registers previously saved.  Note that we cannot
- 	 use the pop insn because the RTX_FRAME_RELATED_P mechanism doesn't
- 	 know how to handle it.  */
-       for (i = 0; i < n; i++)
- 	{
- 	  rtx reg = gen_rtx_REG (Pmode, i);
- 	  rtx mem
- 	    = gen_rtx_MEM (Pmode,
- 			   plus_constant (stack_pointer_rtx,
- 					  (n - 1 - i) * UNITS_PER_WORD));
- 	  rtx insn = emit_move_insn (reg, mem);
- 	  /* The register may be dead in the end.  */
- 	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,
- 						reg,
- 						REG_NOTES (insn));
- 	}
- 
-       /* Restore the stack pointer if needed.  */
-       if (n > 0)
- 	{
- 	  rtx insn = emit_insn (gen_add2_insn (stack_pointer_rtx,
- 					       GEN_INT (n * UNITS_PER_WORD)));
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	}
-     }
- 
-   /* Make sure nothing is scheduled before we are done.  */
-   emit_insn (gen_blockage (const0_rtx));
- }
- 
- /* Generate a trap if COND is true.  */
- 
- const char *
- output_cond_trap (rtx cond)
- {
-   static int labelno = 0;
-   char ok_lab[32];
- 
-   ASM_GENERATE_INTERNAL_LABEL (ok_lab, "LOCT", labelno++);
- 
-   fputs ("\tj", asm_out_file); print_operand (asm_out_file, cond, 'c');
-   fputs ("\t", asm_out_file); assemble_name (asm_out_file, ok_lab);
-   fputs ("\n\t" ASM_SHORT "0x0b0f\n", asm_out_file);
-   ASM_OUTPUT_LABEL (asm_out_file, ok_lab);
- 
-   return "";
- }
- 
- /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
-    These are offsets from the current stack pointer.  */
- 
- const char *
- output_probe_stack_range (rtx first_rtx, rtx size_rtx)
- {
-   static int labelno = 0;
-   HOST_WIDE_INT first = INTVAL (first_rtx);
-   HOST_WIDE_INT size = INTVAL (size_rtx);
-   HOST_WIDE_INT rounded_size;
-   char loop_lab[32], end_lab[32];
- 
-   gcc_assert (!TARGET_64BIT); /* Not yet implemented.  */
- 
-   /* See if we have a constant small number of probes to generate.  If so,
-      that's the easy case.  */
-   if (SMALL_INTERVAL (size))
-     {
-       HOST_WIDE_INT i;
- 
-       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
- 	 it exceeds SIZE.  If only one probe is needed, this will not
- 	 generate any code.  Then probe at SIZE.  */
-       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
- 	fprintf (asm_out_file, "\torl\t$0, -"HOST_WIDE_INT_PRINT_DEC"(%%esp)\n",
- 		 first + i);
- 
-       fprintf (asm_out_file, "\torl\t$0, -"HOST_WIDE_INT_PRINT_DEC"(%%esp)\n",
- 	       first + size);
-     }
- 
-   /* Otherwise, do the same as above, but in a loop.  Note that we must be
-      extra careful with variables wrapping around because we might be at
-      the very top (or the very bottom) of the address space and we have
-      to be able to handle this case properly; in particular, we use an
-      equality test for the loop condition.  */
-   else
-     {
-       /* Step 1: round SIZE to the previous multiple of the interval.  */
- 
-       rounded_size = size & -PROBE_INTERVAL;
- 
- 
-       /* Step 2: compute initial and final value of the loop counter.  */
-       if (first)
- 	/* TEST_ADDR = SP + FIRST.  */
- 	fprintf (asm_out_file, "\tleal\t-"HOST_WIDE_INT_PRINT_DEC"(%%esp), %%eax\n",
- 		 first);
-       else
- 	fputs ("\tmovl\t%esp, %eax\n", asm_out_file);
- 
-       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
-       fprintf (asm_out_file, "\tleal\t-"HOST_WIDE_INT_PRINT_DEC"(%%eax), %%edx\n",
- 	       rounded_size);
- 
- 
-       /* Step 3: the loop
- 
-         while (TEST_ADDR != LAST_ADDR)
- 	  {
- 	    TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
- 	    probe at TEST_ADDR
- 	  }
- 
-         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
-         until it exceeds ROUNDED_SIZE.  */
- 
-       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
-       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
- 
-        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
-       fputs ("\tcmpl\t%eax, %edx\n", asm_out_file);
-       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
-       fputs ("\tje\t", asm_out_file); assemble_name (asm_out_file, end_lab);
-       fputc ('\n', asm_out_file);
-  
-       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
-       fprintf (asm_out_file, "\tsubl\t$%d, %%eax\n", PROBE_INTERVAL);
-   
-       /* Probe at TEST_ADDR and branch.  */
-       fputs ("\torl\t$0, (%eax)\n", asm_out_file);
-       fprintf (asm_out_file, "\tjmp\t"); assemble_name (asm_out_file, loop_lab);
-       fputc ('\n', asm_out_file);
- 
-       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
- 
- 
-       /* Step 4: probe at SIZE if we cannot assert at compile-time that
- 	 it is equal to ROUNDED_SIZE.  */
- 
-       /* TEMP = SIZE - ROUNDED_SIZE.  */
-       if (size != rounded_size)
- 	fprintf (asm_out_file, "\torl\t$0, -"HOST_WIDE_INT_PRINT_DEC"(%%edx)\n",
- 		 size - rounded_size);
-     }
- 
-   return "";
- }
- 
  /* Return the maximum static stack usage for the current function.  */
  
  static HOST_WIDE_INT
--- 4868,4873 ----
*************** ix86_internal_arg_pointer (void)
*** 5509,5514 ****
--- 5108,5562 ----
    return virtual_incoming_args_rtx;
  }
  
+ struct scratch_reg {
+   rtx reg;
+   bool saved;
+ };
+ 
+ /* Return a short-lived scratch register for use on function entry. 
+    In 32-bit mode, it is valid only after the registers are saved
+    in the prologue.  This register must be released by means of
+    release_scratch_register_on_entry once it is dead.  */
+ 
+ static void
+ get_scratch_register_on_entry (struct scratch_reg *sr)
+ {
+   int regno;
+ 
+   sr->saved = false;
+ 
+   if (TARGET_64BIT)
+     regno = FIRST_REX_INT_REG + 3; /* R11 */
+   else
+     {
+       /* See ix86_stack_realign_arg_pointer_regno_for for the logic.  */
+       tree decl = current_function_decl, fntype = TREE_TYPE (decl);
+       bool fast_p
+ 	= lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fntype)) != 0;
+       int regparm = ix86_function_regparm (fntype, decl);
+       int faap_regno = cfun->machine->force_align_arg_pointer
+ 		       ? REGNO (cfun->machine->force_align_arg_pointer)
+ 		       : INVALID_REGNUM;
+ 
+       if (!ix86_eax_maybe_live_in_or_out (decl, fast_p, regparm, 0)
+ 	  && faap_regno != 0)
+ 	regno = 0;
+       else if (!ix86_edx_maybe_live_in_or_out (decl, fast_p, regparm, 0)
+ 	       && faap_regno != 1)
+ 	regno = 1;
+       else if (!ix86_ecx_maybe_live_in_or_out (decl, fast_p, regparm, 0)
+ 	       && faap_regno != 2)
+ 	regno = 2;
+       else if (ix86_save_reg (3, true))
+ 	regno = 3;
+       else if (ix86_save_reg (4, true))
+ 	regno = 4;
+       else if (ix86_save_reg (5, true))
+ 	regno = 5;
+       else
+ 	{
+ 	  if (faap_regno == 0)
+ 	    regno = 1;
+ 	  else
+ 	    regno = 0;
+ 	  sr->saved = true;
+ 	}
+     }
+ 
+   sr->reg = gen_rtx_REG (Pmode, regno);
+   if (sr->saved)
+     {
+       rtx insn = emit_insn (gen_push (sr->reg));
+       RTX_FRAME_RELATED_P (insn) = 1;
+     }
+ }
+ 
+ /* Release a scratch register obtained from the preceding function.  */
+ 
+ static void
+ release_scratch_register_on_entry (struct scratch_reg *sr)
+ {
+   if (sr->saved)
+     {
+       rtx insn, x;
+ 
+       if (TARGET_64BIT)
+ 	insn = emit_insn (gen_popdi1 (sr->reg));
+       else
+ 	insn = emit_insn (gen_popsi1 (sr->reg));
+ 
+       /* The RTX_FRAME_RELATED_P mechanism doesn't know about pop.  */
+       RTX_FRAME_RELATED_P (insn) = 1;
+       x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (UNITS_PER_WORD));
+       x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);
+       REG_NOTES (insn)
+ 	= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);
+ 
+       /* The register may be dead in the end.  */
+       REG_NOTES (insn)
+ 	= gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, sr->reg, REG_NOTES (insn));
+   }
+ }
+ 
+ /* The run-time loop is made up of 8 insns in the generic case while this
+    compile-time loop is made up of n insns for n # of intervals.  */
+ #define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)
+ #define SMALL_INTERVAL(size) ((size) <= 8 * PROBE_INTERVAL)
+ 
+ /* Output one probe.  */
+ 
+ static inline void
+ output_probe_op (void)
+ {
+   fputs (TARGET_64BIT ? "\torq\t$0, " : "\torl\t$0, ", asm_out_file);
+ }
+ 
+ /* Adjust the stack by SIZE bytes and output one probe.  */
+ 
+ static void
+ output_adjust_stack_and_probe_op (HOST_WIDE_INT size)
+ {
+   fprintf (asm_out_file, "\tsub\t$"HOST_WIDE_INT_PRINT_DEC",", size);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   fputc ('\n', asm_out_file);
+   output_probe_op ();
+   fputc ('(', asm_out_file);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   fputs (")\n", asm_out_file);
+ }
+ 
+ /* Adjust the stack by SIZE bytes while probing it.  Note that we skip the
+    probe for the first interval + a small dope of 4 words and instead probe
+    that many bytes past the specified size to maintain a protection area.  */
+ 
+ const char *
+ output_adjust_stack_and_probe (rtx size_rtx, rtx reg)
+ {
+   const int dope = 4 * UNITS_PER_WORD;
+   static int labelno = 0;
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (SMALL_INTERVAL (size))
+     {
+       HOST_WIDE_INT i;
+       bool first_probe = true;
+ 
+       /* Adjust SP and probe to PROBE_INTERVAL + N * PROBE_INTERVAL for
+ 	 values of N from 1 until it exceeds SIZE.  If only one probe is
+ 	 needed, this will not generate any code.  Then adjust and probe
+ 	 to PROBE_INTERVAL + SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	{
+ 	  if (first_probe)
+ 	    {
+ 	      output_adjust_stack_and_probe_op (2 * PROBE_INTERVAL + dope);
+ 	      first_probe = false;
+ 	    }
+ 	  else
+ 	    output_adjust_stack_and_probe_op (PROBE_INTERVAL);
+ 	}
+ 
+       if (first_probe)
+ 	output_adjust_stack_and_probe_op (size + PROBE_INTERVAL + dope);
+       else
+ 	output_adjust_stack_and_probe_op (size + PROBE_INTERVAL - i);
+     }
+ 
+   /* In the variable case, do the same as above, but in a loop.  Note that we
+      must be extra careful with variables wrapping around because we might be
+      at the very top (or the very bottom) of the address space and we have to
+      be able to handle this case properly; in particular, we use an equality
+      test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* SP = SP_0 + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\tsub\t$%d, ", PROBE_INTERVAL + dope);
+       print_reg (stack_pointer_rtx, 0, asm_out_file);
+ 
+       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */
+       fprintf (asm_out_file, "\n\tmov\t$-"HOST_WIDE_INT_PRINT_DEC", ",
+ 	       rounded_size);
+       print_reg (reg, 0, asm_out_file);
+       fputs ("\n\tadd\t", asm_out_file);
+       print_reg (stack_pointer_rtx, 0, asm_out_file);
+       fputs (", ", asm_out_file);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+ 
+ 
+       /* Step 3: the loop
+ 
+ 	  while (SP != LAST_ADDR)
+ 	    {
+ 	      SP = SP + PROBE_INTERVAL
+ 	      probe at SP
+ 	    }
+ 
+ 	 adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for
+ 	 values of N from 1 until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+       /* Jump to END_LAB if SP == LAST_ADDR.  */
+       fputs ("\tcmp\t", asm_out_file);
+       print_reg (stack_pointer_rtx, 0, asm_out_file);
+       fputs (", ", asm_out_file);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tje\t", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+ 
+       /* SP = SP + PROBE_INTERVAL and probe at SP.  */
+       output_adjust_stack_and_probe_op (PROBE_INTERVAL);
+ 
+       fprintf (asm_out_file, "\tjmp\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: adjust SP and probe to PROBE_INTERVAL + SIZE if we cannot
+ 	 assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	output_adjust_stack_and_probe_op (size - rounded_size);
+     }
+ 
+   /* Adjust back to account for the additional first interval.  */
+   fprintf (asm_out_file, "\tadd\t$%d, ", PROBE_INTERVAL + dope);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   fputc ('\n', asm_out_file);
+ 
+   return "";
+ }
+ 
+ /* Wrapper around gen_adjust_stack_and_probe.  */
+ 
+ static rtx
+ ix86_gen_adjust_stack_and_probe (rtx op0, rtx op1)
+ {
+   if (TARGET_64BIT)
+     return gen_adjust_stack_and_probedi (op0, op1);
+   else
+     return gen_adjust_stack_and_probesi (op0, op1);
+ }
+ 
+ /* Emit code to adjust the stack by SIZE bytes while probing it.  */
+ 
+ static void
+ ix86_adjust_stack_and_probe (HOST_WIDE_INT size)
+ {
+   rtx size_rtx = GEN_INT (size), insn, x;
+ 
+   if (SMALL_INTERVAL (size))
+     insn = emit_insn (ix86_gen_adjust_stack_and_probe (size_rtx, const0_rtx));
+   else
+     {
+       struct scratch_reg sr;
+       get_scratch_register_on_entry (&sr);
+       insn = emit_insn (ix86_gen_adjust_stack_and_probe (size_rtx, sr.reg));
+       release_scratch_register_on_entry (&sr);
+     }
+ 
+   RTX_FRAME_RELATED_P (insn) = 1;
+   x = gen_rtx_MINUS (Pmode, stack_pointer_rtx, size_rtx);
+   x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);
+   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);
+ 
+   /* Make sure nothing is scheduled before we are done.  */
+   emit_insn (gen_blockage (const0_rtx));
+ }
+ 
+ /* Output a conditional trap.  COND is the condition code.  */
+ 
+ const char *
+ output_cond_trap (rtx cond)
+ {
+   static int labelno = 0;
+   char ok_lab[32];
+ 
+   ASM_GENERATE_INTERNAL_LABEL (ok_lab, "LOCT", labelno++);
+ 
+   fputs ("\tj", asm_out_file); print_operand (asm_out_file, cond, 'c');
+   fputs ("\t", asm_out_file); assemble_name (asm_out_file, ok_lab);
+   fputs ("\n" ASM_SHORT "0x0b0f\n", asm_out_file);
+   ASM_OUTPUT_LABEL (asm_out_file, ok_lab);
+ 
+   return "";
+ }
+ 
+ /* Output one probe at OFFSET + INDEX from the current stack pointer.  */
+ 
+ static void
+ output_probe_stack_range_op (HOST_WIDE_INT offset, rtx index)
+ {
+   output_probe_op ();
+   if (offset)
+     fprintf (asm_out_file, "-"HOST_WIDE_INT_PRINT_DEC, offset);
+   fputc ('(', asm_out_file);
+   print_reg (stack_pointer_rtx, 0, asm_out_file);
+   if (index)
+     {
+       fputc (',', asm_out_file);
+       print_reg (index, 0, asm_out_file);
+       fputs (",1", asm_out_file);
+     }
+   fputs (")\n", asm_out_file);
+ }
+ 
+ /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.
+    These are offsets from the current stack pointer.  */
+ 
+ const char *
+ output_probe_stack_range (rtx first_rtx, rtx size_rtx, rtx reg)
+ {
+   static int labelno = 0;
+   HOST_WIDE_INT first = INTVAL (first_rtx);
+   HOST_WIDE_INT size = INTVAL (size_rtx);
+   HOST_WIDE_INT rounded_size;
+   char loop_lab[32], end_lab[32];
+ 
+   /* See if we have a constant small number of probes to generate.  If so,
+      that's the easy case.  */
+   if (SMALL_INTERVAL (size))
+     {
+       HOST_WIDE_INT i;
+ 
+       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
+ 	 it exceeds SIZE.  If only one probe is needed, this will not
+ 	 generate any code.  Then probe at FIRST + SIZE.  */
+       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
+ 	output_probe_stack_range_op (first + i, NULL_RTX);
+ 
+       output_probe_stack_range_op (first + size, NULL_RTX);
+     }
+ 
+   /* Otherwise, do the same as above, but in a loop.  Note that we must be
+      extra careful with variables wrapping around because we might be at
+      the very top (or the very bottom) of the address space and we have
+      to be able to handle this case properly; in particular, we use an
+      equality test for the loop condition.  */
+   else
+     {
+       /* Step 1: round SIZE to the previous multiple of the interval.  */
+       rounded_size = size & -PROBE_INTERVAL;
+ 
+ 
+       /* Step 2: compute initial and final value of the loop counter.  */
+ 
+       /* TEST_OFFSET = FIRST.  */
+       fprintf (asm_out_file, "\tmov\t$-"HOST_WIDE_INT_PRINT_DEC", ", first);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+ 
+       /* LAST_OFFSET = FIRST + ROUNDED_SIZE.  */
+ 
+ 
+       /* Step 3: the loop
+ 
+         while (TEST_OFFSET != LAST_OFFSET)
+ 	  {
+ 	    TEST_OFFSET = TEST_OFFSET + PROBE_INTERVAL
+ 	    probe at SP + TEST_OFFSET
+ 	  }
+ 
+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+         until it is equal to ROUNDED_SIZE.  */
+ 
+       ASM_GENERATE_INTERNAL_LABEL (loop_lab, "LPSRL", labelno);
+       ASM_OUTPUT_LABEL (asm_out_file, loop_lab);
+ 
+        /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */
+       fprintf (asm_out_file, "\tcmp\t$-"HOST_WIDE_INT_PRINT_DEC", ",
+ 	       first + rounded_size);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+       ASM_GENERATE_INTERNAL_LABEL (end_lab, "LPSRE", labelno++);
+       fputs ("\tje\t", asm_out_file); assemble_name (asm_out_file, end_lab);
+       fputc ('\n', asm_out_file);
+ 
+       /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
+       fprintf (asm_out_file, "\tsub\t$%d, ", PROBE_INTERVAL);
+       print_reg (reg, 0, asm_out_file);
+       fputc ('\n', asm_out_file);
+ 
+       /* Probe at TEST_ADDR.  */
+       output_probe_stack_range_op (0, reg);
+ 
+       fprintf (asm_out_file, "\tjmp\t"); assemble_name (asm_out_file, loop_lab);
+       fputc ('\n', asm_out_file);
+ 
+       ASM_OUTPUT_LABEL (asm_out_file, end_lab);
+ 
+ 
+       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+ 	 that SIZE is equal to ROUNDED_SIZE.  */
+       if (size != rounded_size)
+ 	output_probe_stack_range_op (size - rounded_size, reg);
+     }
+ 
+   return "";
+ }
+ 
+ /* Wrapper around gen_probe_stack_range.  */
+ 
+ static rtx
+ ix86_gen_probe_stack_range (rtx op0, rtx op1, rtx op2)
+ {
+   if (TARGET_64BIT)
+     return gen_probe_stack_rangedi (op0, op1, op2);
+   else
+     return gen_probe_stack_rangesi (op0, op1, op2);
+ }
+ 
+ /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,
+    inclusive.  These are offsets from the current stack pointer.  */
+ 
+ static void
+ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
+ {
+   gcc_assert (!stack_check_libfunc); /* Not implemented.  */
+ 
+   if (stack_check_symbol)
+     {
+       struct scratch_reg sr;
+       rtx res;
+ 
+       get_scratch_register_on_entry (&sr);
+       emit_move_insn (sr.reg,
+ 		      plus_constant (stack_pointer_rtx, -(first + size)));
+       res = ix86_expand_int_compare (LTU, sr.reg,
+ 				     gen_rtx_MEM (Pmode, stack_check_symbol));
+       emit_insn (gen_rtx_TRAP_IF (VOIDmode, res, GEN_INT (6)));
+       release_scratch_register_on_entry (&sr);
+     }
+   else if (SMALL_INTERVAL (size))
+      emit_insn (ix86_gen_probe_stack_range (GEN_INT (first), GEN_INT (size),
+ 					    const0_rtx));
+   else
+     {
+       struct scratch_reg sr;
+       get_scratch_register_on_entry (&sr);
+       emit_insn (ix86_gen_probe_stack_range (GEN_INT (first), GEN_INT (size),
+ 					     sr.reg));
+       release_scratch_register_on_entry (&sr);
+     }
+ 
+   /* Make sure nothing is scheduled before we are done.  */
+   emit_insn (gen_blockage (const0_rtx));
+ }
+ 
  /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.
     This is called from dwarf2out.c to emit call frame instructions
     for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */
*************** ix86_expand_prologue (void)
*** 5545,5569 ****
  
    ix86_compute_frame_layout (&frame);
  
-   /* The stack has already been decremented by the instruction calling us
-      so we need to probe unconditionally to preserve the protection area.  */
-   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
-     {
-       HOST_WIDE_INT probed = UNITS_PER_WORD 
- 			     + (frame_pointer_needed ? UNITS_PER_WORD : 0)
- 			     + frame.to_allocate
- 			     + frame.nregs * UNITS_PER_WORD;
- 
-       /* If CHECK_STACK_LIMIT is positive, the target may expect unconditional
- 	 probing from the first allocated byte to grow the stack of threads.
- 	 It's the case on Windows.  If ix86_target_stack_probe returns false,
- 	 the builtin support has been disabled to avoid probing twice.  */
-       if (CHECK_STACK_LIMIT > 0 && !ix86_target_stack_probe ())
- 	ix86_emit_probe_stack_range (0, probed + STACK_CHECK_PROTECT);
-       else
- 	ix86_emit_probe_stack_range (STACK_CHECK_PROTECT, probed);
-     }
- 
    if (cfun->machine->force_align_arg_pointer)
      {
        rtx x, y;
--- 5593,5598 ----
*************** ix86_expand_prologue (void)
*** 5629,5634 ****
--- 5658,5689 ----
    else
      allocate += frame.nregs * UNITS_PER_WORD;
  
+   /* The stack has already been decremented by the instruction calling us
+      so we need to probe unconditionally to preserve the protection area.  */
+   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)
+     {
+       /* We expect the registers to be saved when probes are used.  */
+       gcc_assert (!frame.save_regs_using_mov || stack_check_symbol);
+ 
+       if (STACK_CHECK_MOVING_SP)
+ 	{
+ 	  ix86_adjust_stack_and_probe (allocate);
+ 	  allocate = 0;
+ 	}
+       else
+ 	{
+ 	  HOST_WIDE_INT size = allocate;
+ 
+ 	  if (TARGET_64BIT && size >= (HOST_WIDE_INT) 0x80000000)
+ 	    size = 0x80000000 - STACK_CHECK_PROTECT - 1;
+ 
+ 	  if (TARGET_STACK_PROBE)
+ 	    ix86_emit_probe_stack_range (0, size + STACK_CHECK_PROTECT);
+ 	  else
+ 	    ix86_emit_probe_stack_range (STACK_CHECK_PROTECT, size);
+ 	}
+     }
+ 
    /* When using red zone we may start register saving before allocating
       the stack frame saving one cycle of the prologue.  */
    if (TARGET_RED_ZONE && frame.save_regs_using_mov)
*************** ix86_expand_prologue (void)
*** 5638,5644 ****
  
    if (allocate == 0)
      ;
!   else if (! ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)
      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
  			       GEN_INT (-allocate), -1);
    else
--- 5693,5699 ----
  
    if (allocate == 0)
      ;
!   else if (!ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)
      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
  			       GEN_INT (-allocate), -1);
    else
*** gcc/config/i386/i386-protos.h.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/i386-protos.h	2008-03-25 07:42:02.000000000 +0100
*************** extern const char *output_387_binary_op 
*** 73,80 ****
  extern const char *output_387_reg_move (rtx, rtx*);
  extern const char *output_fix_trunc (rtx, rtx*, int);
  extern const char *output_fp_compare (rtx, rtx*, int, int);
  extern const char *output_cond_trap (rtx);
! extern const char *output_probe_stack_range (rtx, rtx);
  
  extern void ix86_expand_clear (rtx);
  extern void ix86_expand_move (enum machine_mode, rtx[]);
--- 73,81 ----
  extern const char *output_387_reg_move (rtx, rtx*);
  extern const char *output_fix_trunc (rtx, rtx*, int);
  extern const char *output_fp_compare (rtx, rtx*, int, int);
+ extern const char *output_adjust_stack_and_probe (rtx, rtx);
  extern const char *output_cond_trap (rtx);
! extern const char *output_probe_stack_range (rtx, rtx, rtx);
  
  extern void ix86_expand_clear (rtx);
  extern void ix86_expand_move (enum machine_mode, rtx[]);
*** gcc/config/i386/i386.md.0	2008-03-13 23:19:54.000000000 +0100
--- gcc/config/i386/i386.md	2008-03-28 17:28:48.000000000 +0100
***************
*** 19188,19202 ****
    DONE;
  })
  
! (define_insn "probe_stack_range"
!   [(unspec_volatile:SI [(match_operand:SI 0 "const_int_operand" "")
! 			(match_operand:SI 1 "const_int_operand" "")]
      UNSPECV_STACK_PROBE_INLINE)
!    (clobber (reg:SI 0))
!    (clobber (reg:SI 1))
!    (clobber (reg:CC 17))]
!   "!TARGET_64BIT"
!   "* return output_probe_stack_range (operands[0], operands[1]);"
    [(set_attr "type" "multi")])
  
  (define_expand "builtin_setjmp_receiver"
--- 19188,19214 ----
    DONE;
  })
  
! (define_mode_macro P [(SI "!TARGET_64BIT") (DI "TARGET_64BIT")])
! 
! (define_insn "adjust_stack_and_probe<P:mode>"
!   [(unspec_volatile:P [(match_operand:P 0 "const_int_operand" "n")]
      UNSPECV_STACK_PROBE_INLINE)
!    (set (reg:P SP_REG) (minus:P (reg:P SP_REG) (match_dup 0)))
!    (clobber (match_operand:P 1 "general_operand" "=rn"))
!    (clobber (reg:CC FLAGS_REG))
!    (clobber (mem:BLK (scratch)))]
!   ""
!   "* return output_adjust_stack_and_probe (operands[0], operands[1]);"
!   [(set_attr "type" "multi")])
! 
! (define_insn "probe_stack_range<P:mode>"
!   [(unspec_volatile:P [(match_operand:P 0 "const_int_operand" "n")
! 		       (match_operand:P 1 "const_int_operand" "n")]
!     UNSPECV_STACK_PROBE_INLINE)
!    (clobber (match_operand:P 2 "general_operand" "=rn"))
!    (clobber (reg:CC FLAGS_REG))]
!   ""
!   "* return output_probe_stack_range (operands[0], operands[1], operands[2]);"
    [(set_attr "type" "multi")])
  
  (define_expand "builtin_setjmp_receiver"
***************
*** 19649,19655 ****
                       [(match_dup 0)
                        (match_operand:SI 1 "nonmemory_operand" "")]))
                (clobber (reg:CC FLAGS_REG))])]
!   "! optimize_size && ! TARGET_READ_MODIFY_WRITE"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 2) (match_dup 1)]))
--- 19661,19669 ----
                       [(match_dup 0)
                        (match_operand:SI 1 "nonmemory_operand" "")]))
                (clobber (reg:CC FLAGS_REG))])]
!   "!optimize_size && !TARGET_READ_MODIFY_WRITE
!    /* Do not split stack checking probes.  */
!    && GET_CODE (operands[3]) != IOR && operands[1] != const0_rtx"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 2) (match_dup 1)]))
***************
*** 19664,19670 ****
                       [(match_operand:SI 1 "nonmemory_operand" "")
                        (match_dup 0)]))
                (clobber (reg:CC FLAGS_REG))])]
!   "! optimize_size && ! TARGET_READ_MODIFY_WRITE"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
--- 19678,19686 ----
                       [(match_operand:SI 1 "nonmemory_operand" "")
                        (match_dup 0)]))
                (clobber (reg:CC FLAGS_REG))])]
!   "!optimize_size && !TARGET_READ_MODIFY_WRITE
!    /* Do not split stack checking probes.  */
!    && GET_CODE (operands[3]) != IOR && operands[1] != const0_rtx"
    [(set (match_dup 2) (match_dup 0))
     (parallel [(set (match_dup 2)
                     (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
*** gcc/fold-const.c.0	2008-03-29 13:39:50.000000000 +0100
--- gcc/fold-const.c	2008-03-29 16:17:23.247707680 +0100
*************** fold (tree expr)
*** 10499,10504 ****
--- 10499,10543 ----
  
    switch (code)
      {
+     case ARRAY_REF:
+       {
+ 	tree op0 = TREE_OPERAND (t, 0);
+ 	tree op1 = TREE_OPERAND (t, 1);
+ 
+ 	if (TREE_CODE (op1) == INTEGER_CST
+ 	    && TREE_CODE (op0) == CONSTRUCTOR
+ 	    && ! type_contains_placeholder_p (TREE_TYPE (op0)))
+ 	  {
+ 	    VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (op0);
+ 	    unsigned HOST_WIDE_INT end = VEC_length (constructor_elt, elts);
+ 	    unsigned HOST_WIDE_INT begin = 0;
+ 
+ 	    /* Find a matching index by means of a binary search.  */
+ 	    while (begin != end)
+ 	      {
+ 		unsigned HOST_WIDE_INT middle = (begin + end) / 2;
+ 		tree index = VEC_index (constructor_elt, elts, middle)->index;
+ 
+ 		if (TREE_CODE (index) == INTEGER_CST
+ 		    && tree_int_cst_lt (index, op1))
+ 		  begin = middle + 1;
+ 		else if (TREE_CODE (index) == INTEGER_CST
+ 			 && tree_int_cst_lt (op1, index))
+ 		  end = middle;
+ 		else if (TREE_CODE (index) == RANGE_EXPR
+ 			 && tree_int_cst_lt (TREE_OPERAND (index, 1), op1))
+ 		  begin = middle + 1;
+ 		else if (TREE_CODE (index) == RANGE_EXPR
+ 			 && tree_int_cst_lt (op1, TREE_OPERAND (index, 0)))
+ 		  end = middle;
+ 		else
+ 		  return VEC_index (constructor_elt, elts, middle)->value;
+ 	      }
+ 	  }
+ 
+ 	return t;
+       }
+ 
      case CONST_DECL:
        return fold (DECL_INITIAL (t));
  
*** gcc/tree-inline.c.0	2008-04-01 14:00:35.527282040 +0200
--- gcc/tree-inline.c	2008-04-01 14:01:57.921756176 +0200
*************** expand_call_inline (basic_block bb, tree
*** 2186,2199 ****
    id->decl_map = splay_tree_new (splay_tree_compare_pointers,
  				 NULL, NULL);
  
    /* Initialize the parameters.  */
    args = TREE_OPERAND (t, 1);
  
    initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);
  
-   /* Record the function we are about to inline.  */
-   id->callee = fn;
- 
    if (DECL_STRUCT_FUNCTION (fn)->saved_blocks)
      add_lexical_block (id->block, remap_blocks (DECL_STRUCT_FUNCTION (fn)->saved_blocks, id));
    else if (DECL_INITIAL (fn))
--- 2186,2199 ----
    id->decl_map = splay_tree_new (splay_tree_compare_pointers,
  				 NULL, NULL);
  
+   /* Record the function we are about to inline.  */
+   id->callee = fn;
+ 
    /* Initialize the parameters.  */
    args = TREE_OPERAND (t, 1);
  
    initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);
  
    if (DECL_STRUCT_FUNCTION (fn)->saved_blocks)
      add_lexical_block (id->block, remap_blocks (DECL_STRUCT_FUNCTION (fn)->saved_blocks, id));
    else if (DECL_INITIAL (fn))
*** gcc/config/rs6000/vxworks-unwind.h.ori	Wed Apr  2 11:07:55 2008
--- gcc/config/rs6000/vxworks-unwind.h	Wed Apr  2 13:02:08 2008
*************** sigcontext_for (struct _Unwind_Context *
*** 58,69 ****
    const unsigned int * ra = context->ra;
  
    /* VxWorks 5.5.  */
!   if (*(ra - 6) == 0x7fe3fb78      /* or     r3,r31,r31 */
!       && *(ra - 5) == 0x389e000c   /* addi   r4,r30,0xc */
!       && *(ra - 4) == 0x7fa803a6   /* mtspr  LR,r29 */
!       && *(ra - 3) == 0x7fc5f378   /* or     r5,r30,r30 */
!       && *(ra - 2) == 0x4cc63182   /* crxor  crb6,crb6,crb6 */
!       && *(ra - 1) == 0x4e800021)  /* blrl */
      {
  	struct {
  	    char pad [0x40];
--- 58,77 ----
    const unsigned int * ra = context->ra;
  
    /* VxWorks 5.5.  */
!   if ((*(ra - 6) == 0x7fe3fb78      /* or     r3,r31,r31 */
!        && *(ra - 5) == 0x389e000c   /* addi   r4,r30,0xc */
!        && *(ra - 4) == 0x7fa803a6   /* mtspr  LR,r29 */
!        && *(ra - 3) == 0x7fc5f378   /* or     r5,r30,r30 */
!        && *(ra - 2) == 0x4cc63182   /* crxor  crb6,crb6,crb6 */
!        && *(ra - 1) == 0x4e800021)  /* blrl */
!       ||
!       (*(ra - 6) == 0x7fe3fb78      /* or     r3,r31,r31 */
!        && *(ra - 5) == 0x809e0014   /* lwz    r4,20(r30) */
!        && *(ra - 4) == 0x7fc5f378   /* or     r5,r30,r30 */
!        && *(ra - 3) == 0x7fa803a6   /* mtspr  LR,r29 */
!        && *(ra - 2) == 0x4cc63182   /* crxor  crb6,crb6,crb6 */
!        && *(ra - 1) == 0x4e800021   /* blrl */
!        && *(ra - 0) == 0x7fc3f378)) /* or     r3,r30,r30 */
      {
  	struct {
  	    char pad [0x40];
*** gcc/gimplify.c.0	2008-04-02 13:02:07.000000000 +0200
--- gcc/gimplify.c	2008-04-02 13:10:18.318626056 +0200
*************** gimplify_modify_expr_rhs (tree *expr_p, 
*** 3246,3252 ****
  	    tree result = *to_p;
  
  	    ret = gimplify_expr (&result, pre_p, post_p,
! 				 is_gimple_min_lval, fb_lvalue);
  	    if (ret != GS_ERROR)
  	      ret = GS_OK;
  
--- 3246,3252 ----
  	    tree result = *to_p;
  
  	    ret = gimplify_expr (&result, pre_p, post_p,
! 				 is_gimple_lvalue, fb_lvalue);
  	    if (ret != GS_ERROR)
  	      ret = GS_OK;
  
*** gcc/config/sparc/erc32.h.orig	Fri Apr  4 18:17:47 2008
--- gcc/config/sparc/erc32.h	Fri Apr  4 18:18:50 2008
*************** along with GCC; see the file COPYING.  I
*** 19,28 ****
  the Free Software Foundation, 51 Franklin Street, Fifth Floor,
  Boston, MA 02110-1301, USA.  */
  
! /* Use the required linker script file */
  
  #undef LINK_SPEC
! #define LINK_SPEC "-T erc32.ld%s"
  
  /* Make the BSP and the C library available */
  
--- 19,28 ----
  the Free Software Foundation, 51 Franklin Street, Fifth Floor,
  Boston, MA 02110-1301, USA.  */
  
! /* Use the required linker script file (if none has been specified) */
  
  #undef LINK_SPEC
! #define LINK_SPEC "%{!T:-T erc32.ld%s}"
  
  /* Make the BSP and the C library available */
  
*** gcc/config/sparc/leon.h.orig	Fri Apr  4 18:17:54 2008
--- gcc/config/sparc/leon.h	Fri Apr  4 18:19:31 2008
*************** along with GCC; see the file COPYING.  I
*** 19,28 ****
  the Free Software Foundation, 51 Franklin Street, Fifth Floor,
  Boston, MA 02110-1301, USA.  */
  
! /* Use the required linker script file */
  
  #undef LINK_SPEC
! #define LINK_SPEC "-T leon.ld%s"
  
  /* Make the BSP and the C library available */
  
--- 19,28 ----
  the Free Software Foundation, 51 Franklin Street, Fifth Floor,
  Boston, MA 02110-1301, USA.  */
  
! /* Use the required linker script file (if none has been specified) */
  
  #undef LINK_SPEC
! #define LINK_SPEC "%{!T:-T leon.ld%s}"
  
  /* Make the BSP and the C library available */
  
*** gcc/config/rs6000/linux.h.old	2006-02-11 03:09:24.000000000 +0100
--- gcc/config/rs6000/linux.h	2008-04-10 11:48:13.876915302 +0200
***************
*** 119,122 ****
--- 119,125 ----
  #define TARGET_THREAD_SSP_OFFSET	-0x7008
  #endif
  
+ /* Define this to be nonzero if static stack checking is supported.  */
+ #define STACK_CHECK_STATIC_BUILTIN 1
+ 
  #define POWERPC_LINUX
*** gcc/dwarf2out.c.old	2008-04-09 15:58:42.000000000 +0200
--- gcc/dwarf2out.c	2008-04-11 14:55:59.000000000 +0200
***************
*** 10011,10019 ****
       tends to produce unresolved symbols; see debug/5770 and c++/6381.  */
    /* Aggregate, vector, and complex types may contain constructors that may
       result in code being generated when expand_expr is called, so we can't
!      handle them here.  Integer and float are useful and safe types to handle
!      here.  */
!   else if ((INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type))
  	   && initializer_constant_valid_p (init, type) == null_pointer_node)
      {
        rtl = expand_expr (init, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);
--- 10011,10021 ----
       tends to produce unresolved symbols; see debug/5770 and c++/6381.  */
    /* Aggregate, vector, and complex types may contain constructors that may
       result in code being generated when expand_expr is called, so we can't
!      handle them here.  Integer, pointers and float are useful and safe types
!      to handle here.  */
!   else if ((INTEGRAL_TYPE_P (type)
! 	    || SCALAR_FLOAT_TYPE_P (type)
! 	    || POINTER_TYPE_P (type))
  	   && initializer_constant_valid_p (init, type) == null_pointer_node)
      {
        rtl = expand_expr (init, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);
***************
*** 10212,10218 ****
    /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,
       and will have been substituted directly into all expressions that use it.
       C does not have such a concept, but C++ and other languages do.  */
!   if (!rtl && TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))
      rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));
  
    if (rtl)
--- 10214,10222 ----
    /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,
       and will have been substituted directly into all expressions that use it.
       C does not have such a concept, but C++ and other languages do.  */
!   if (!rtl 
!       && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)
!       && DECL_INITIAL (decl))
      rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));
  
    if (rtl)
***************
*** 10284,10289 ****
--- 10288,10294 ----
      return;
  
    gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL
+ 	      || TREE_CODE (decl) == CONST_DECL
  	      || TREE_CODE (decl) == RESULT_DECL);
  	     
    /* See if we possibly have multiple locations for this variable.  We expect
***************
*** 13158,13168 ****
      case ERROR_MARK:
        break;
  
-     case CONST_DECL:
-       /* The individual enumerators of an enum type get output when we output
- 	 the Dwarf representation of the relevant enum type itself.  */
-       break;
- 
      case FUNCTION_DECL:
        /* Don't output any DIEs to represent mere function declarations,
  	 unless they are class members or explicit block externs.  */
--- 13163,13168 ----
***************
*** 13250,13255 ****
--- 13250,13261 ----
  	gen_label_die (decl, context_die);
        break;
  
+     case CONST_DECL:
+       /* The individual enumerators of an enum type get output when we output
+ 	 the Dwarf representation of the relevant enum type itself.  */
+       if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)
+ 	break;
+ 
      case VAR_DECL:
      case RESULT_DECL:
        /* If we are in terse mode, don't generate any DIEs to represent any
***************
*** 13488,13493 ****
--- 13494,13505 ----
  	context_die = NULL;
        break;
  
+     case CONST_DECL:
+       if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)
+ 	return;
+ 
+       /* ... fall through ...  */
+ 
      case VAR_DECL:
        /* Ignore this VAR_DECL if it refers to a file-scope extern data object
  	 declaration and if the declaration was never even referenced from
*** gcc/dwarf2out.c.old	2008-04-14 10:22:03.000000000 +0200
--- gcc/dwarf2out.c	2008-04-14 10:38:57.000000000 +0200
***************
*** 9182,9187 ****
--- 9182,9190 ----
        }
        break;
  
+     case CONST_DECL:
+       return loc_descriptor_from_tree_1 (DECL_INITIAL (loc), want_address);
+ 
      case INDIRECT_REF:
        ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);
        have_address = 1;
***************
*** 9246,9251 ****
--- 9249,9257 ----
  	return 0;
        break;
  
+     case COMPLEX_CST:
+       return 0;
+ 
      case CONSTRUCTOR:
        {
  	/* Get an RTL for this, if something has been emitted.  */
*** gcc/configure.orig	Tue Apr 22 15:28:28 2008
--- gcc/configure	Tue Apr 22 15:28:17 2008
***************
*** 7043,7048 ****
--- 7043,7049 ----
  fi;
  
  subdirs=
+ gcc_subdirs=
  for lang in ${srcdir}/*/config-lang.in
  do
  	case $lang in
***************
*** 7058,7064 ****
  	  fi
  	  case ",$enable_languages," in
  	  *,$lang_alias,*)
! 	    subdirs="$subdirs `echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`" ;;
  	  esac
  	  ;;
  	esac
--- 7059,7071 ----
  	  fi
  	  case ",$enable_languages," in
  	  *,$lang_alias,*)
!             alternate_gcc_subdir=`sed -n -e 's,^gcc_subdir=['"'"'"'"]\(.*\)["'"'"'"'].*$,\1,p' -e 's,^gcc_subdir=\([^   ]*\).*$,\1,p' $lang`
!             if  [ "$alternate_gcc_subdir" != "" ]; then
!                 gcc_subdirs="$gcc_subdirs $alternate_gcc_subdir"
!             else
!                 gcc_subdirs="$gcc_subdirs `echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
!             fi
!             subdirs="$subdirs `echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
  	  esac
  	  ;;
  	esac
***************
*** 7492,7498 ****
  else
      ac_prog_version=`$MAKEINFO --version 2>&1 |
                     sed -n 's/^.*GNU texinfo.* \([0-9][0-9.]*\).*$/\1/p'`
!   echo "configure:7495: version of makeinfo is $ac_prog_version" >&5
    case $ac_prog_version in
      '')     gcc_cv_prog_makeinfo_modern=no;;
      4.[2-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*)
--- 7499,7505 ----
  else
      ac_prog_version=`$MAKEINFO --version 2>&1 |
                     sed -n 's/^.*GNU texinfo.* \([0-9][0-9.]*\).*$/\1/p'`
!   echo "configure:7514: version of makeinfo is $ac_prog_version" >&5
    case $ac_prog_version in
      '')     gcc_cv_prog_makeinfo_modern=no;;
      4.[2-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*)
***************
*** 16363,16377 ****
  lang_tree_files=
  for subdir in . $subdirs
  do
! 	if test -f $srcdir/$subdir/lang.opt; then
! 	    lang_opt_files="$lang_opt_files $srcdir/$subdir/lang.opt"
! 	fi
! 	if test -f $srcdir/$subdir/lang-specs.h; then
! 	    lang_specs_files="$lang_specs_files $srcdir/$subdir/lang-specs.h"
! 	fi
! 	if test -f $srcdir/$subdir/$subdir-tree.def; then
! 	    lang_tree_files="$lang_tree_files $srcdir/$subdir/$subdir-tree.def"
! 	fi
  done
  
  # These (without "all_") are set in each config-lang.in.
--- 16370,16394 ----
  lang_tree_files=
  for subdir in . $subdirs
  do
!         gcc_subdir=
! 
!         if test -f ${srcdir}/$subdir/config-lang.in; then
!         . ${srcdir}/$subdir/config-lang.in
!         fi
! 
!         if test "$gcc_subdir" = ""; then
!            gcc_subdir="$subdir"
!         fi
! 
!         if test -f $srcdir/$gcc_subdir/lang.opt; then
!             lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
!         fi
!         if test -f $srcdir/$gcc_subdir/lang-specs.h; then
!             lang_specs_files="$lang_specs_files $srcdir/$gcc_subdir/lang-specs.h"
!         fi
!         if test -f $srcdir/$gcc_subdir/$subdir-tree.def; then
!             lang_tree_files="$lang_tree_files $srcdir/$gcc_subdir/$subdir-tree.def"
!         fi
  done
  
  # These (without "all_") are set in each config-lang.in.
***************
*** 16408,16422 ****
  		stagestuff=
  		outputs=
  		gtfiles=
  		. ${srcdir}/$s/config-lang.in
  		if test "x$language" = x
  		then
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 		all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$s/Make-lang.in"
! 		if test -f ${srcdir}/$s/Makefile.in
! 		then all_lang_makefiles="$s/Makefile"
  		fi
  		all_languages="$all_languages $language"
  		if test "x$boot_language" = xyes
--- 16425,16446 ----
  		stagestuff=
  		outputs=
  		gtfiles=
+ 		gcc_subdir=
  		. ${srcdir}/$s/config-lang.in
  		if test "x$language" = x
  		then
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 
!                 if test "$gcc_subdir" = ""; then
!                    gcc_subdir="$s"
!                 fi
! 
!                 all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
! 
!                 if test -f ${srcdir}/$gcc_subdir/Makefile.in
!                 then all_lang_makefiles="$gcc_subdir/Makefile"
  		fi
  		all_languages="$all_languages $language"
  		if test "x$boot_language" = xyes
*** gcc/configure.ac.orig	Tue Apr 22 15:28:28 2008
--- gcc/configure.ac	Tue Apr 22 15:28:17 2008
***************
*** 765,770 ****
--- 765,771 ----
  [enable_languages=c])
  
  subdirs=
+ gcc_subdirs=
  for lang in ${srcdir}/*/config-lang.in
  do
  	case $lang in
***************
*** 781,787 ****
  	  fi
  	  case ",$enable_languages," in
  	  *,$lang_alias,*)
! 	    subdirs="$subdirs `echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`" ;;
  	  esac
  	  ;;
  changequote([,])dnl
--- 782,794 ----
  	  fi
  	  case ",$enable_languages," in
  	  *,$lang_alias,*)
!             alternate_gcc_subdir=`sed -n -e 's,^gcc_subdir=['"'"'"'"]\(.*\)["'"'"'"'].*$,\1,p' -e 's,^gcc_subdir=\([^   ]*\).*$,\1,p' $lang`
!             if  [ "$alternate_gcc_subdir" != "" ]; then
!                 gcc_subdirs="$gcc_subdirs $alternate_gcc_subdir"
!             else
!                 gcc_subdirs="$gcc_subdirs `echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
!             fi
!             subdirs="$subdirs `echo $lang | sed -e 's,^.*/\([^/]*\)/config-lang.in$,\1,'`"
  	  esac
  	  ;;
  changequote([,])dnl
***************
*** 3266,3280 ****
  lang_tree_files=
  for subdir in . $subdirs
  do
! 	if test -f $srcdir/$subdir/lang.opt; then
! 	    lang_opt_files="$lang_opt_files $srcdir/$subdir/lang.opt"
! 	fi
! 	if test -f $srcdir/$subdir/lang-specs.h; then
! 	    lang_specs_files="$lang_specs_files $srcdir/$subdir/lang-specs.h"
! 	fi
! 	if test -f $srcdir/$subdir/$subdir-tree.def; then
! 	    lang_tree_files="$lang_tree_files $srcdir/$subdir/$subdir-tree.def"
! 	fi
  done
  
  # These (without "all_") are set in each config-lang.in.
--- 3273,3297 ----
  lang_tree_files=
  for subdir in . $subdirs
  do
!         gcc_subdir=
! 
!         if test -f ${srcdir}/$subdir/config-lang.in; then
!         . ${srcdir}/$subdir/config-lang.in
!         fi
! 
!         if test "$gcc_subdir" = ""; then
!            gcc_subdir="$subdir"
!         fi
! 
!         if test -f $srcdir/$gcc_subdir/lang.opt; then
!             lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
!         fi
!         if test -f $srcdir/$gcc_subdir/lang-specs.h; then
!             lang_specs_files="$lang_specs_files $srcdir/$gcc_subdir/lang-specs.h"
!         fi
!         if test -f $srcdir/$gcc_subdir/$subdir-tree.def; then
!             lang_tree_files="$lang_tree_files $srcdir/$gcc_subdir/$subdir-tree.def"
!         fi
  done
  
  # These (without "all_") are set in each config-lang.in.
***************
*** 3311,3325 ****
  		stagestuff=
  		outputs=
  		gtfiles=
  		. ${srcdir}/$s/config-lang.in
  		if test "x$language" = x
  		then
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 		all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$s/Make-lang.in"
! 		if test -f ${srcdir}/$s/Makefile.in
! 		then all_lang_makefiles="$s/Makefile"
  		fi
  		all_languages="$all_languages $language"
  		if test "x$boot_language" = xyes
--- 3328,3349 ----
  		stagestuff=
  		outputs=
  		gtfiles=
+ 		gcc_subdir=
  		. ${srcdir}/$s/config-lang.in
  		if test "x$language" = x
  		then
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 
!                 if test "$gcc_subdir" = ""; then
!                    gcc_subdir="$s"
!                 fi
! 
!                 all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
! 
!                 if test -f ${srcdir}/$gcc_subdir/Makefile.in
!                 then all_lang_makefiles="$gcc_subdir/Makefile"
  		fi
  		all_languages="$all_languages $language"
  		if test "x$boot_language" = xyes
*** gcc/gengtype.c.orig	Tue Apr 22 15:28:28 2008
--- gcc/gengtype.c	Tue Apr 22 15:28:17 2008
***************
*** 986,991 ****
--- 986,992 ----
  
  static outf_p create_file (const char *, const char *);
  static const char * get_file_basename (const char *);
+ static const char * get_file_gtfilename (const char *);
  
  /* Create and return an outf_p for a new file for NAME, to be called
     ONAME.  */
***************
*** 1097,1133 ****
  get_file_basename (const char *f)
  {
    const char *basename;
    unsigned i;
  
    basename = strrchr (f, '/');
  
    if (!basename)
!     return f;
! 
!   basename++;
  
    for (i = 1; i < NUM_BASE_FILES; i++)
      {
        const char * s1;
        const char * s2;
        int l1;
        int l2;
!       s1 = basename - strlen (lang_dir_names [i]) - 1;
        s2 = lang_dir_names [i];
        l1 = strlen (s1);
        l2 = strlen (s2);
!       if (l1 >= l2 && IS_DIR_SEPARATOR (s1[-1]) && !memcmp (s1, s2, l2))
          {
-           basename -= l2 + 1;
-           if ((basename - f - 1) != srcdir_len)
- 	    fatal ("filename `%s' should be preceded by $srcdir", f);
            break;
          }
      }
  
!   return basename;
  }
- 
  /* Return a bitmap which has bit `1 << BASE_FILE_<lang>' set iff
     INPUT_FILE is used by <lang>.
  
--- 1098,1158 ----
  get_file_basename (const char *f)
  {
    const char *basename;
+   unsigned f_length;
+ 
+   basename = f;
+ 
+   f_length = strlen (f);
+   if (f_length > srcdir_len && IS_DIR_SEPARATOR (f[srcdir_len]) && memcmp (basename, srcdir, srcdir_len) == 0)
+      { basename += srcdir_len + 1;
+      }
+   return basename;
+ }
+ 
+ static const char *
+ get_file_gtfilename (const char *f)
+ {
+   const char *basename;
+   const char *srcdir_relative_path;
+   char *s, *result;
    unsigned i;
  
    basename = strrchr (f, '/');
  
    if (!basename)
!     basename = f;
!   else
!     basename++;
  
+   srcdir_relative_path = get_file_basename (f);
+  
    for (i = 1; i < NUM_BASE_FILES; i++)
      {
        const char * s1;
        const char * s2;
        int l1;
        int l2;
!       s1 = srcdir_relative_path;
        s2 = lang_dir_names [i];
        l1 = strlen (s1);
        l2 = strlen (s2);
!       if (l1 > l2 && IS_DIR_SEPARATOR (s1[l2]) && memcmp (s1, s2, l2) == 0)
          {
            break;
          }
      }
  
!   if (i >= NUM_BASE_FILES)
!      result = s = xasprintf ("gt-%s", basename);
!   else  
!      result = s = xasprintf ("gt-%s-%s", lang_dir_names [i], basename);
! 
!   for (; *s != '.'; s++)
!         if (! ISALNUM (*s) && *s != '-')
!           *s = '-';
!       memcpy (s, ".h", sizeof (".h"));
!   return result;
  }
  /* Return a bitmap which has bit `1 << BASE_FILE_<lang>' set iff
     INPUT_FILE is used by <lang>.
  
***************
*** 1212,1224 ****
        || (len > 2 && memcmp (basename+len-2, ".y", 2) == 0)
        || (len > 3 && memcmp (basename+len-3, ".in", 3) == 0))
      {
!       char *s;
! 
!       output_name = s = xasprintf ("gt-%s", basename);
!       for (; *s != '.'; s++)
! 	if (! ISALNUM (*s) && *s != '-')
! 	  *s = '-';
!       memcpy (s, ".h", sizeof (".h"));
        for_name = basename;
      }
    /* Some headers get used by more than one front-end; hence, it
--- 1237,1243 ----
        || (len > 2 && memcmp (basename+len-2, ".y", 2) == 0)
        || (len > 3 && memcmp (basename+len-3, ".in", 3) == 0))
      {
!       output_name = get_file_gtfilename (input_file); 
        for_name = basename;
      }
    /* Some headers get used by more than one front-end; hence, it
***************
*** 1245,1251 ****
    else 
      {
        size_t i;
- 
        for (i = 0; i < NUM_BASE_FILES; i++)
  	if (memcmp (basename, lang_dir_names[i], strlen (lang_dir_names[i])) == 0
  	    && basename[strlen(lang_dir_names[i])] == '/')
--- 1264,1269 ----
*** gcc/dwarf2out.c.ori	Wed Apr 23 12:50:03 2008
--- gcc/dwarf2out.c	Wed Apr 23 15:25:10 2008
*************** static void add_artificial_attribute_for
*** 4136,4142 ****
  static void add_descriptive_attribute_for_type (dw_die_ref, tree, dw_die_ref);
  static void add_comp_dir_attribute (dw_die_ref);
  static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);
! static void add_subscript_info (dw_die_ref, tree);
  static void add_byte_size_attribute (dw_die_ref, tree);
  static void add_bit_offset_attribute (dw_die_ref, tree);
  static void add_bit_size_attribute (dw_die_ref, tree);
--- 4136,4142 ----
  static void add_descriptive_attribute_for_type (dw_die_ref, tree, dw_die_ref);
  static void add_comp_dir_attribute (dw_die_ref);
  static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);
! static void add_subscript_info (dw_die_ref, tree, bool);
  static void add_byte_size_attribute (dw_die_ref, tree);
  static void add_bit_offset_attribute (dw_die_ref, tree);
  static void add_bit_size_attribute (dw_die_ref, tree);
*************** add_bound_info (dw_die_ref subrange_die,
*** 10677,10712 ****
      }
  }
  
! /* Note that the block of subscript information for an array type also
!    includes information about the element type of type given array type.  */
  
  static void
! add_subscript_info (dw_die_ref type_die, tree type)
  {
- #ifndef MIPS_DEBUGGING_INFO
    unsigned dimension_number;
- #endif
    tree lower, upper;
    dw_die_ref subrange_die;
  
-   /* The GNU compilers represent multidimensional array types as sequences of
-      one dimensional array types whose element types are themselves array
-      types.  Here we squish that down, so that each multidimensional array
-      type gets only one array_type DIE in the Dwarf debugging info. The draft
-      Dwarf specification say that we are allowed to do this kind of
-      compression in C (because there is no difference between an array or
-      arrays and a multidimensional array in C) but for other source languages
-      (e.g. Ada) we probably shouldn't do this.  */
- 
-   /* ??? The SGI dwarf reader fails for multidimensional arrays with a
-      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].
-      We work around this by disabling this feature.  See also
-      gen_array_type_die.  */
- #ifndef MIPS_DEBUGGING_INFO
    for (dimension_number = 0;
!        TREE_CODE (type) == ARRAY_TYPE;
         type = TREE_TYPE (type), dimension_number++)
- #endif
      {
        tree domain = TYPE_DOMAIN (type);
  
--- 10677,10697 ----
      }
  }
  
! /* Add subscript info to TYPE_DIE, describing an array TYPE, collapsing
!    possibly nested array subscripts in a flat sequence if COLLAPSE_P is true.
!    Note that the block of subscript information for an array type also
!    includes information about the element type of the given array type.  */
  
  static void
! add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)
  {
    unsigned dimension_number;
    tree lower, upper;
    dw_die_ref subrange_die;
  
    for (dimension_number = 0;
!        TREE_CODE (type) == ARRAY_TYPE && (dimension_number == 0 || collapse_p);
         type = TREE_TYPE (type), dimension_number++)
      {
        tree domain = TYPE_DOMAIN (type);
  
*************** gen_array_type_die (tree type, dw_die_re
*** 11211,11223 ****
  {
    dw_die_ref scope_die = scope_die_for (type, context_die);
    dw_die_ref array_die;
    tree element_type;
  
-   /* ??? The SGI dwarf reader fails for array of array of enum types unless
-      the inner array type comes before the outer array type.  Thus we must
-      call gen_type_die before we call new_die.  See below also.  */
  #ifdef MIPS_DEBUGGING_INFO
    gen_type_die (TREE_TYPE (type), context_die);
  #endif
  
    array_die = new_die (DW_TAG_array_type, scope_die, type);
--- 11196,11224 ----
  {
    dw_die_ref scope_die = scope_die_for (type, context_die);
    dw_die_ref array_die;
+ 
+   /* GNU compilers represent multidimensional array types as sequences of one
+      dimensional array types whose element types are themselves array types.
+      We sometimes squish that down to a single array_type DIE with multiple
+      subscripts in the Dwarf debugging info.  The draft Dwarf specification
+      say that we are allowed to do this kind of compression in C, because
+      there is no difference between an array of arrays and a multidimensional
+      array.  We don't do this for Ada to remain as close as possible to the
+      actual representation, which is especially important against the language
+      flexibilty wrt arrays of variable size.  */
+ 
+   bool collapse_nested_arrays = !is_ada ();
    tree element_type;
+   
+   /* ??? The SGI dwarf reader fails for array of array of enum types
+      (e.g. const enum machine_mode insn_operand_mode[2][10]) unless the inner
+      array type comes before the outer array type.  We thus call gen_type_die
+      before we new_die and must prevent nested array types collapsing for this
+      target.  */
  
  #ifdef MIPS_DEBUGGING_INFO
    gen_type_die (TREE_TYPE (type), context_die);
+   collapse_nested_arrays = false;
  #endif
  
    array_die = new_die (DW_TAG_array_type, scope_die, type);
*************** gen_array_type_die (tree type, dw_die_re
*** 11252,11270 ****
      add_AT_flag (array_die, DW_AT_declaration, 1);
    else
  #endif
!     add_subscript_info (array_die, type);
  
!   /* Add representation of the type of the elements of this array type.  */
    element_type = TREE_TYPE (type);
! 
!   /* ??? The SGI dwarf reader fails for multidimensional arrays with a
!      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].
!      We work around this by disabling this feature.  See also
!      add_subscript_info.  */
  #ifndef MIPS_DEBUGGING_INFO
-   while (TREE_CODE (element_type) == ARRAY_TYPE)
-     element_type = TREE_TYPE (element_type);
- 
    gen_type_die (element_type, context_die);
  #endif
  
--- 11253,11268 ----
      add_AT_flag (array_die, DW_AT_declaration, 1);
    else
  #endif
!     add_subscript_info (array_die, type, collapse_nested_arrays);
  
!   /* Add representation of the type of the elements of this array type and
!      emit the corresponding DIE if we haven't done it already.  */  
    element_type = TREE_TYPE (type);
!   if (collapse_nested_arrays)
!     while (TREE_CODE (element_type) == ARRAY_TYPE)
!       element_type = TREE_TYPE (element_type);
!   
  #ifndef MIPS_DEBUGGING_INFO
    gen_type_die (element_type, context_die);
  #endif
  
*** gcc/tree-sra.c.0	2008-04-27 23:20:27.555692968 +0200
--- gcc/tree-sra.c	2008-04-27 23:46:17.679038400 +0200
*************** sra_type_can_be_decomposed_p (tree type)
*** 250,255 ****
--- 250,256 ----
  	    {
  	      /* Reject incorrectly represented bit fields.  */
  	      if (DECL_BIT_FIELD (t)
+ 		  && INTEGRAL_TYPE_P (TREE_TYPE (t))
  		  && (tree_low_cst (DECL_SIZE (t), 1)
  		      != TYPE_PRECISION (TREE_TYPE (t))))
  		goto fail;
*** gcc/expr.c.0	2008-05-06 23:39:52.919290840 +0200
--- gcc/expr.c	2008-05-07 00:11:27.697240808 +0200
*************** expand_expr_real_1 (tree exp, rtx target
*** 7671,7696 ****
        return REDUCE_BIT_FIELD (op0);
  
      case VIEW_CONVERT_EXPR:
!       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);
  
        /* If the input and output modes are both the same, we are done.  */
!       if (TYPE_MODE (type) == GET_MODE (op0))
  	;
        /* If neither mode is BLKmode, and both modes are the same size
  	 then we can use gen_lowpart.  */
!       else if (TYPE_MODE (type) != BLKmode && GET_MODE (op0) != BLKmode
! 	       && GET_MODE_SIZE (TYPE_MODE (type))
! 		   == GET_MODE_SIZE (GET_MODE (op0)))
  	{
  	  if (GET_CODE (op0) == SUBREG)
  	    op0 = force_reg (GET_MODE (op0), op0);
! 	  op0 = gen_lowpart (TYPE_MODE (type), op0);
  	}
        /* If both modes are integral, then we can convert from one to the
  	 other.  */
!       else if (SCALAR_INT_MODE_P (GET_MODE (op0))
! 	       && SCALAR_INT_MODE_P (TYPE_MODE (type)))
! 	op0 = convert_modes (TYPE_MODE (type), GET_MODE (op0), op0, 
  			     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));
        /* As a last resort, spill op0 to memory, and reload it in a 
  	 different mode.  */
--- 7671,7759 ----
        return REDUCE_BIT_FIELD (op0);
  
      case VIEW_CONVERT_EXPR:
!       op0 = NULL_RTX;
! 
!       /* If we are converting to BLKmode, try to avoid an intermediate
! 	 temporary by fetching an inner memory reference.  */
!       if (mode == BLKmode
! 	  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST
! 	  && TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != BLKmode
! 	  && handled_component_p (TREE_OPERAND (exp, 0)))
!       {
! 	enum machine_mode mode1;
! 	HOST_WIDE_INT bitsize, bitpos;
! 	tree offset;
! 	int unsignedp;
! 	int volatilep = 0;
! 	tree tem
! 	  = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, &bitpos,
! 				 &offset, &mode1, &unsignedp, &volatilep,
! 				 true);
! 	rtx orig_op0;
! 
! 	/* ??? We should work harder and deal with non-zero offsets.  */
! 	if (!offset
! 	    && (bitpos % BITS_PER_UNIT) == 0
! 	    && bitsize >= 0
! 	    && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) == 0)
! 	  {
! 	    /* See the normal_inner_ref case for the rationale.  */
! 	    orig_op0
! 	      = expand_expr (tem,
! 			     (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE
! 			      && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))
! 				  != INTEGER_CST)
! 			      && modifier != EXPAND_STACK_PARM
! 			      ? target : NULL_RTX),
! 			     VOIDmode,
! 			     (modifier == EXPAND_INITIALIZER
! 			      || modifier == EXPAND_CONST_ADDRESS
! 			      || modifier == EXPAND_STACK_PARM)
! 			     ? modifier : EXPAND_NORMAL);
! 
! 	    if (MEM_P (orig_op0))
! 	      {
! 		op0 = orig_op0;
! 
! 		/* Get a reference to just this component.  */
! 		if (modifier == EXPAND_CONST_ADDRESS
! 		    || modifier == EXPAND_SUM
! 		    || modifier == EXPAND_INITIALIZER)
! 		  op0 = adjust_address_nv (op0, mode, bitpos / BITS_PER_UNIT);
! 		else
! 		  op0 = adjust_address (op0, mode, bitpos / BITS_PER_UNIT);
! 
! 		if (op0 == orig_op0)
! 		  op0 = copy_rtx (op0);
! 
! 		set_mem_attributes (op0, TREE_OPERAND (exp, 0), 0);
! 		if (REG_P (XEXP (op0, 0)))
! 		  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));
! 
! 		MEM_VOLATILE_P (op0) |= volatilep;
! 	      }
! 	  }
!       }
! 
!       if (!op0)
! 	op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);
  
        /* If the input and output modes are both the same, we are done.  */
!       if (mode == GET_MODE (op0))
  	;
        /* If neither mode is BLKmode, and both modes are the same size
  	 then we can use gen_lowpart.  */
!       else if (mode != BLKmode && GET_MODE (op0) != BLKmode
! 	       && GET_MODE_SIZE (mode) == GET_MODE_SIZE (GET_MODE (op0)))
  	{
  	  if (GET_CODE (op0) == SUBREG)
  	    op0 = force_reg (GET_MODE (op0), op0);
! 	  op0 = gen_lowpart (mode, op0);
  	}
        /* If both modes are integral, then we can convert from one to the
  	 other.  */
!       else if (SCALAR_INT_MODE_P (GET_MODE (op0)) && SCALAR_INT_MODE_P (mode))
! 	op0 = convert_modes (mode, GET_MODE (op0), op0, 
  			     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));
        /* As a last resort, spill op0 to memory, and reload it in a 
  	 different mode.  */
*************** expand_expr_real_1 (tree exp, rtx target
*** 7724,7745 ****
  
  	  if (TYPE_ALIGN_OK (type))
  	    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));
! 	  else if (TYPE_MODE (type) != BLKmode && STRICT_ALIGNMENT
! 		   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (TYPE_MODE (type)))
  	    {
  	      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));
  	      HOST_WIDE_INT temp_size
  		= MAX (int_size_in_bytes (inner_type),
! 		       (HOST_WIDE_INT) GET_MODE_SIZE (TYPE_MODE (type)));
! 	      rtx new = assign_stack_temp_for_type (TYPE_MODE (type),
! 						    temp_size, 0, type);
  	      rtx new_with_op0_mode = adjust_address (new, GET_MODE (op0), 0);
  
  	      gcc_assert (!TREE_ADDRESSABLE (exp));
  
  	      if (GET_MODE (op0) == BLKmode)
  		emit_block_move (new_with_op0_mode, op0,
! 				 GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))),
  				 (modifier == EXPAND_STACK_PARM
  				  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));
  	      else
--- 7787,7808 ----
  
  	  if (TYPE_ALIGN_OK (type))
  	    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));
! 	  else if (STRICT_ALIGNMENT
! 		   && mode != BLKmode
! 		   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode))
  	    {
  	      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));
  	      HOST_WIDE_INT temp_size
  		= MAX (int_size_in_bytes (inner_type),
! 		       (HOST_WIDE_INT) GET_MODE_SIZE (mode));
! 	      rtx new = assign_stack_temp_for_type (mode, temp_size, 0, type);
  	      rtx new_with_op0_mode = adjust_address (new, GET_MODE (op0), 0);
  
  	      gcc_assert (!TREE_ADDRESSABLE (exp));
  
  	      if (GET_MODE (op0) == BLKmode)
  		emit_block_move (new_with_op0_mode, op0,
! 				 GEN_INT (GET_MODE_SIZE (mode)),
  				 (modifier == EXPAND_STACK_PARM
  				  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));
  	      else
*************** expand_expr_real_1 (tree exp, rtx target
*** 7748,7754 ****
  	      op0 = new;
  	    }
  
! 	  op0 = adjust_address (op0, TYPE_MODE (type), 0);
  	}
  
        return op0;
--- 7811,7817 ----
  	      op0 = new;
  	    }
  
! 	  op0 = adjust_address (op0, mode, 0);
  	}
  
        return op0;
*** gcc/gimplify.c.0	2008-05-13 22:21:57.000000000 +0200
--- gcc/gimplify.c	2008-05-14 12:16:39.159413816 +0200
*************** Software Foundation, 51 Franklin Street,
*** 28,33 ****
--- 28,34 ----
  #include "tree.h"
  #include "rtl.h"
  #include "varray.h"
+ #include "pointer-set.h"
  #include "tree-gimple.h"
  #include "tree-inline.h"
  #include "diagnostic.h"
*************** annotate_all_with_locus (tree *stmt_p, l
*** 686,692 ****
      }
  }
  
! /* Similar to copy_tree_r() but do not copy SAVE_EXPR or TARGET_EXPR nodes.
     These nodes model computations that should only be done once.  If we
     were to unshare something like SAVE_EXPR(i++), the gimplification
     process would create wrong code.  */
--- 687,693 ----
      }
  }
  
! /* Similar to copy_tree_r but do not copy SAVE_EXPR or TARGET_EXPR nodes.
     These nodes model computations that should only be done once.  If we
     were to unshare something like SAVE_EXPR(i++), the gimplification
     process would create wrong code.  */
*************** static tree
*** 695,776 ****
  mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)
  {
    enum tree_code code = TREE_CODE (*tp);
!   /* Don't unshare types, decls, constants and SAVE_EXPR nodes.  */
!   if (TREE_CODE_CLASS (code) == tcc_type
!       || TREE_CODE_CLASS (code) == tcc_declaration
!       || TREE_CODE_CLASS (code) == tcc_constant
!       || code == SAVE_EXPR || code == TARGET_EXPR
!       /* We can't do anything sensible with a BLOCK used as an expression,
! 	 but we also can't just die when we see it because of non-expression
! 	 uses.  So just avert our eyes and cross our fingers.  Silly Java.  */
!       || code == BLOCK)
!     *walk_subtrees = 0;
!   else
      {
!       gcc_assert (code != BIND_EXPR);
!       copy_tree_r (tp, walk_subtrees, data);
      }
  
    return NULL_TREE;
  }
  
  /* Callback for walk_tree to unshare most of the shared trees rooted at
     *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),
!    then *TP is deep copied by calling copy_tree_r.
! 
!    This unshares the same trees as copy_tree_r with the exception of
!    SAVE_EXPR nodes.  These nodes model computations that should only be
!    done once.  If we were to unshare something like SAVE_EXPR(i++), the
!    gimplification process would create wrong code.  */
  
  static tree
! copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,
! 		  void *data ATTRIBUTE_UNUSED)
  {
!   tree t = *tp;
!   enum tree_code code = TREE_CODE (t);
  
!   /* Skip types, decls, and constants.  But we do want to look at their
!      types and the bounds of types.  Mark them as visited so we properly
!      unmark their subtrees on the unmark pass.  If we've already seen them,
!      don't look down further.  */
!   if (TREE_CODE_CLASS (code) == tcc_type
!       || TREE_CODE_CLASS (code) == tcc_declaration
!       || TREE_CODE_CLASS (code) == tcc_constant)
      {
!       if (TREE_VISITED (t))
! 	*walk_subtrees = 0;
        else
! 	TREE_VISITED (t) = 1;
      }
  
    /* If this node has been visited already, unshare it and don't look
       any deeper.  */
!   else if (TREE_VISITED (t))
      {
!       walk_tree (tp, mostly_copy_tree_r, NULL, NULL);
        *walk_subtrees = 0;
      }
  
!   /* Otherwise, mark the tree as visited and keep looking.  */
    else
!     TREE_VISITED (t) = 1;
  
    return NULL_TREE;
  }
  
  static tree
! unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,
! 		  void *data ATTRIBUTE_UNUSED)
  {
!   if (TREE_VISITED (*tp))
      TREE_VISITED (*tp) = 0;
    else
      *walk_subtrees = 0;
  
    return NULL_TREE;
  }
  
  /* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the
     bodies of any nested functions if we are unsharing the entire body of
     FNDECL.  */
--- 696,815 ----
  mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)
  {
    enum tree_code code = TREE_CODE (*tp);
! 
!   /* Do not copy SAVE_EXPR or TARGET_EXPR nodes themselves, but copy
!      their subtrees if we can make sure to do it only once.  */
!   if (code == SAVE_EXPR || code == TARGET_EXPR)
      {
!       if (data && !pointer_set_insert (data, *tp))
! 	;
!       else
! 	*walk_subtrees = 0;
      }
  
+   /* Stop at types, decls, constants like copy_tree_r.  */
+   else if (TREE_CODE_CLASS (code) == tcc_type
+ 	   || TREE_CODE_CLASS (code) == tcc_declaration
+ 	   || TREE_CODE_CLASS (code) == tcc_constant
+ 	   /* Cope with the statement expression extension.  */
+ 	   || code == BIND_EXPR
+ 	   /* We can't do anything sensible with a BLOCK used as an
+ 	      expression, but we also can't just die when we see it
+ 	      because of non-expression uses.  So we avert our eyes
+ 	      and cross our fingers.  Silly Java.  */
+ 	   || code == BLOCK)
+     *walk_subtrees = 0;
+ 
+   /* Leave the bulk of the work to copy_tree_r itself.  */
+   else
+     copy_tree_r (tp, walk_subtrees, NULL);
+ 
    return NULL_TREE;
  }
  
  /* Callback for walk_tree to unshare most of the shared trees rooted at
     *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),
!    then *TP is deep copied by calling mostly_copy_tree_r.  */
  
  static tree
! copy_if_shared_r (tree *tp, int *walk_subtrees, void *data)
  {
!   enum tree_code code = TREE_CODE (*tp);
  
!   /* Do not unshare SAVE_EXPR or TARGET_EXPR nodes themselves, but unshare
!      their subtrees if we can make sure to do it only once.  */
!   if (code == SAVE_EXPR || code == TARGET_EXPR)
      {
!       if (data && !pointer_set_insert (data, *tp))
! 	;
        else
! 	*walk_subtrees = 0;
      }
  
    /* If this node has been visited already, unshare it and don't look
       any deeper.  */
!   else if (TREE_VISITED (*tp))
      {
!       walk_tree (tp, mostly_copy_tree_r, data, NULL);
        *walk_subtrees = 0;
      }
  
!   /* Otherwise, mark the node as visited and keep looking.  */
    else
!     TREE_VISITED (*tp) = 1;
  
    return NULL_TREE;
  }
  
+ /* Unshare most of the shared trees rooted at *TP. */
+ 
+ static inline void
+ copy_if_shared (tree *tp)
+ {
+   struct pointer_set_t *visited = pointer_set_create ();
+   walk_tree (tp, copy_if_shared_r, visited, NULL);
+   pointer_set_destroy (visited);
+ }
+ 
+ /* Callback for walk_tree to unmark the visited trees rooted at *TP.
+    Subtrees are walked until the first unvisited node is encountered.  */
+ 
  static tree
! unmark_visited_r (tree *tp, int *walk_subtrees, void *data)
  {
!   enum tree_code code = TREE_CODE (*tp);
! 
!   /* Do not unmark SAVE_EXPR or TARGET_EXPR nodes themselves, but unmark
!      their subtrees if we can make sure to do it only once.  */
!   if (code == SAVE_EXPR || code == TARGET_EXPR)
!     {
!       if (data && !pointer_set_insert (data, *tp))
! 	;
!       else
! 	*walk_subtrees = 0;
!     }
! 
!   /* If this node has been visited, unmark it and keep looking.  */
!   else if (TREE_VISITED (*tp))
      TREE_VISITED (*tp) = 0;
+ 
+   /* Otherwise, don't look any deeper.  */
    else
      *walk_subtrees = 0;
  
    return NULL_TREE;
  }
  
+ /* Unmark the visited trees rooted at *TP.  */
+ 
+ static inline void
+ unmark_visited (tree *tp)
+ {
+   struct pointer_set_t *visited = pointer_set_create ();
+   walk_tree (tp, unmark_visited_r, visited, NULL);
+   pointer_set_destroy (visited);
+ }
+ 
  /* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the
     bodies of any nested functions if we are unsharing the entire body of
     FNDECL.  */
*************** unshare_body (tree *body_p, tree fndecl)
*** 780,786 ****
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   walk_tree (body_p, copy_if_shared_r, NULL, NULL);
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
--- 819,826 ----
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   copy_if_shared (body_p);
! 
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
*************** unvisit_body (tree *body_p, tree fndecl)
*** 793,799 ****
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   walk_tree (body_p, unmark_visited_r, NULL, NULL);
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
--- 833,840 ----
  {
    struct cgraph_node *cgn = cgraph_node (fndecl);
  
!   unmark_visited (body_p);
! 
    if (body_p == &DECL_SAVED_TREE (fndecl))
      for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)
        unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);
*************** unvisit_body (tree *body_p, tree fndecl)
*** 804,811 ****
  static void
  unshare_all_trees (tree t)
  {
!   walk_tree (&t, copy_if_shared_r, NULL, NULL);
!   walk_tree (&t, unmark_visited_r, NULL, NULL);
  }
  
  /* Unconditionally make an unshared copy of EXPR.  This is used when using
--- 845,852 ----
  static void
  unshare_all_trees (tree t)
  {
!   copy_if_shared (&t);
!   unmark_visited (&t);
  }
  
  /* Unconditionally make an unshared copy of EXPR.  This is used when using
*** gcc/Makefile.in.0	2008-05-13 22:22:03.000000000 +0200
--- gcc/Makefile.in	2008-05-14 10:41:08.679579168 +0200
*************** gimplify.o : gimplify.c $(CONFIG_H) $(SY
*** 1958,1964 ****
     $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \
     $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \
     coretypes.h except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) output.h \
!    $(GGC_H) gt-gimplify.h $(HASHTAB_H) real.h $(TARGET_H) toplev.h
  gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
     $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \
     $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
--- 1958,1965 ----
     $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \
     $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \
     coretypes.h except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) output.h \
!    $(GGC_H) gt-gimplify.h $(HASHTAB_H) real.h $(TARGET_H) toplev.h \
!    pointer-set.h
  gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
     $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \
     $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
*** gcc/fold-const.c.0	2008-05-16 11:25:28.709692112 +0200
--- gcc/fold-const.c	2008-05-16 11:26:19.404985256 +0200
*************** fold_unary (enum tree_code code, tree ty
*** 6845,6852 ****
        /* Convert (T)(x & c) into (T)x & (T)c, if c is an integer
  	 constants (if x has signed type, the sign bit cannot be set
  	 in c).  This folds extension into the BIT_AND_EXPR.  */
!       if (INTEGRAL_TYPE_P (type)
! 	  && TREE_CODE (type) != BOOLEAN_TYPE
  	  && TREE_CODE (op0) == BIT_AND_EXPR
  	  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST)
  	{
--- 6845,6851 ----
        /* Convert (T)(x & c) into (T)x & (T)c, if c is an integer
  	 constants (if x has signed type, the sign bit cannot be set
  	 in c).  This folds extension into the BIT_AND_EXPR.  */
!       if (TREE_CODE (type) == INTEGER_TYPE
  	  && TREE_CODE (op0) == BIT_AND_EXPR
  	  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST)
  	{
*** gcc/config/avr/avr.c.old	Sun Jul  8 03:35:16 2007
--- gcc/config/avr/avr.c	Mon May 19 16:12:05 2008
***************
*** 687,694 ****
  		      AS1 (ldi, r26) ",lo8(" HOST_WIDE_INT_PRINT_DEC ")" CR_TAB
  		      AS1 (ldi, r27) ",hi8(" HOST_WIDE_INT_PRINT_DEC ")" CR_TAB), size, size);
  
!       fputs ((AS2 (ldi,r30,pm_lo8(1f)) CR_TAB
! 	      AS2 (ldi,r31,pm_hi8(1f)) CR_TAB), file);
        
        prologue_size += 4;
        
--- 687,694 ----
  		      AS1 (ldi, r26) ",lo8(" HOST_WIDE_INT_PRINT_DEC ")" CR_TAB
  		      AS1 (ldi, r27) ",hi8(" HOST_WIDE_INT_PRINT_DEC ")" CR_TAB), size, size);
  
!       fputs ((AS2 (ldi,r30,lo8(gs(1f))) CR_TAB
! 	      AS2 (ldi,r31,hi8(gs(1f))) CR_TAB), file);
        
        prologue_size += 4;
        
*** gcc/config/avr/avr.c.old	Sun Jul  8 03:35:16 2007
--- gcc/config/avr/avr.c	Tue May 20 15:42:51 2008
***************
*** 121,126 ****
--- 121,129 ----
  /* Enhanced core: use "movw", "mul", ...  */
  int avr_enhanced_p = 0;
  
+ /* PC is 3 bytes (noticed by call/rcall).  */
+ int avr_3bytes_pc_p = 0;
+ 
  /* Assembler only.  */
  int avr_asm_only_p = 0;
  
***************
*** 128,143 ****
    int asm_only;
    int enhanced;
    int mega;
    const char *const macro;
  };
  
  static const struct base_arch_s avr_arch_types[] = {
!   { 1, 0, 0, NULL },  /* unknown device specified */
!   { 1, 0, 0, "__AVR_ARCH__=1" },
!   { 0, 0, 0, "__AVR_ARCH__=2" },
!   { 0, 0, 1, "__AVR_ARCH__=3" },
!   { 0, 1, 0, "__AVR_ARCH__=4" },
!   { 0, 1, 1, "__AVR_ARCH__=5" }
  };
  
  struct mcu_type_s {
--- 131,148 ----
    int asm_only;
    int enhanced;
    int mega;
+   int is_3bytes_pc;
    const char *const macro;
  };
  
  static const struct base_arch_s avr_arch_types[] = {
!   { 1, 0, 0, 0, NULL },  /* unknown device specified */
!   { 1, 0, 0, 0, "__AVR_ARCH__=1" },
!   { 0, 0, 0, 0, "__AVR_ARCH__=2" },
!   { 0, 0, 1, 0, "__AVR_ARCH__=3" },
!   { 0, 1, 0, 0, "__AVR_ARCH__=4" },
!   { 0, 1, 1, 0, "__AVR_ARCH__=5" },
!   { 0, 1, 1, 1, "__AVR_ARCH__=6" }
  };
  
  struct mcu_type_s {
***************
*** 207,212 ****
--- 212,219 ----
    { "atmega128", 5, "__AVR_ATmega128__" },
    { "at90can128", 5, "__AVR_AT90CAN128__" },
    { "at94k",     5, "__AVR_AT94K__" },
+     /* AVR 6.  */
+   { "avr6",      6, NULL },
      /* Assembler only.  */
    { "avr1",      1, NULL },
    { "at90s1200", 1, "__AVR_AT90S1200__" },
***************
*** 287,292 ****
--- 294,300 ----
    base = &avr_arch_types[t->arch];
    avr_asm_only_p = base->asm_only;
    avr_enhanced_p = base->enhanced;
+   avr_3bytes_pc_p = base->is_3bytes_pc;
    avr_mega_p = base->mega;
    avr_base_arch_macro = base->macro;
    avr_extra_arch_macro = t->macro;
***************
*** 446,454 ****
    else
      {
        int offset = frame_pointer_needed ? 2 : 0;
  
        offset += avr_regs_to_save (NULL);
!       return get_frame_size () + 2 + 1 + offset;
      }
  }
  
--- 454,463 ----
    else
      {
        int offset = frame_pointer_needed ? 2 : 0;
+       int avr_pc_size = avr_3bytes_pc_p ? 3 : 2;
  
        offset += avr_regs_to_save (NULL);
!       return get_frame_size () + (avr_pc_size) + 1 + offset;
      }
  }
  
*** gcc/expr.c.0	2008-05-22 18:00:04.052187856 +0200
--- gcc/expr.c	2008-05-22 18:00:13.170801616 +0200
*************** highest_pow2_factor (tree exp)
*** 6234,6239 ****
--- 6234,6246 ----
  	}
        break;
  
+     case BIT_AND_EXPR:
+       /* The highest power of two of a bit-and expression is the maximum of
+ 	 that of its operands.  We typically get here for a complex LHS and
+ 	 a constant negative power of two on the RHS to force an explicit
+ 	 alignment, so don't bother looking at the LHS.  */
+       return highest_pow2_factor (TREE_OPERAND (exp, 1));
+ 
      case NON_LVALUE_EXPR:  case NOP_EXPR:  case CONVERT_EXPR:
      case SAVE_EXPR:
        return highest_pow2_factor (TREE_OPERAND (exp, 0));
*** gcc/builtins.c.0	2008-06-13 12:08:43.620396128 +0200
--- gcc/builtins.c	2008-06-13 12:09:25.398044960 +0200
*************** get_memory_rtx (tree exp, tree len)
*** 1087,1105 ****
  	  while (TREE_CODE (inner) == COMPONENT_REF)
  	    {
  	      tree field = TREE_OPERAND (inner, 1);
- 	      gcc_assert (! DECL_BIT_FIELD (field));
  	      gcc_assert (TREE_CODE (mem_expr) == COMPONENT_REF);
  	      gcc_assert (field == TREE_OPERAND (mem_expr, 1));
  
  	      if (length >= 0
! 		  && TYPE_SIZE_UNIT (TREE_TYPE (inner))
! 		  && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (inner)), 0))
  		{
  		  HOST_WIDE_INT size
! 		    = tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (inner)), 0);
! 		  /* If we can prove the memory starting at XEXP (mem, 0)
! 		     and ending at XEXP (mem, 0) + LENGTH will fit into
! 		     this field, we can keep that COMPONENT_REF in MEM_EXPR.  */
  		  if (offset <= size
  		      && length <= size
  		      && offset + length <= size)
--- 1087,1113 ----
  	  while (TREE_CODE (inner) == COMPONENT_REF)
  	    {
  	      tree field = TREE_OPERAND (inner, 1);
  	      gcc_assert (TREE_CODE (mem_expr) == COMPONENT_REF);
  	      gcc_assert (field == TREE_OPERAND (mem_expr, 1));
  
+ 	      /* Bitfields are generally not byte-addressable.  */
+ 	      gcc_assert (!DECL_BIT_FIELD (field)
+ 			  || ((tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)
+ 			       % BITS_PER_UNIT) == 0
+ 			      && host_integerp (DECL_SIZE (field), 0)
+ 			      && (TREE_INT_CST_LOW (DECL_SIZE (field))
+ 				  % BITS_PER_UNIT) == 0));
+ 
+ 	      /* If we can prove that the memory starting at XEXP (mem, 0) and
+ 		 ending at XEXP (mem, 0) + LENGTH will fit into this field, we
+ 		 can keep the COMPONENT_REF in MEM_EXPR.  But be careful with
+ 		 fields without DECL_SIZE_UNIT like flexible array members.  */
  	      if (length >= 0
! 		  && DECL_SIZE_UNIT (field)
! 		  && host_integerp (DECL_SIZE_UNIT (field), 0))
  		{
  		  HOST_WIDE_INT size
! 		    = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field));
  		  if (offset <= size
  		      && length <= size
  		      && offset + length <= size)
*************** get_memory_rtx (tree exp, tree len)
*** 1108,1114 ****
  
  	      if (offset >= 0
  		  && host_integerp (DECL_FIELD_OFFSET (field), 0))
! 		offset += tree_low_cst (DECL_FIELD_OFFSET (field), 0)
  			  + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)
  			    / BITS_PER_UNIT;
  	      else
--- 1116,1122 ----
  
  	      if (offset >= 0
  		  && host_integerp (DECL_FIELD_OFFSET (field), 0))
! 		offset += TREE_INT_CST_LOW (DECL_FIELD_OFFSET (field))
  			  + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)
  			    / BITS_PER_UNIT;
  	      else
*** gcc/tree-pretty-print.c.old	2005-11-19 19:38:34.000000000 +0100
--- gcc/tree-pretty-print.c	2008-06-12 12:06:43.000000000 +0200
***************
*** 663,669 ****
        if (DECL_NAME (node))
  	dump_decl_name (buffer, node, flags);
        else if (LABEL_DECL_UID (node) != -1)
!         pp_printf (buffer, "<L" HOST_WIDE_INT_PRINT_DEC ">",
  		   LABEL_DECL_UID (node));
        else
          pp_printf (buffer, "<D%u>", DECL_UID (node));
--- 663,669 ----
        if (DECL_NAME (node))
  	dump_decl_name (buffer, node, flags);
        else if (LABEL_DECL_UID (node) != -1)
!         pp_printf (buffer, "<L%d>",
  		   LABEL_DECL_UID (node));
        else
          pp_printf (buffer, "<D%u>", DECL_UID (node));
*** gcc/tree-ssa-forwprop.c.0	2008-06-27 17:55:43.950332984 +0200
--- gcc/tree-ssa-forwprop.c	2008-06-27 18:11:21.078867792 +0200
*************** forward_propagate_into_cond_1 (tree cond
*** 210,217 ****
       from an SSA_NAME, then it is interesting to us as we
       can adjust the constant in the conditional and thus
       eliminate the arithmetic operation.  */
!   if (TREE_CODE (def_rhs) == PLUS_EXPR
!       || TREE_CODE (def_rhs) == MINUS_EXPR)
      {
        tree op0 = TREE_OPERAND (def_rhs, 0);
        tree op1 = TREE_OPERAND (def_rhs, 1);
--- 210,218 ----
       from an SSA_NAME, then it is interesting to us as we
       can adjust the constant in the conditional and thus
       eliminate the arithmetic operation.  */
!   if (cond_code != SSA_NAME
!       && (TREE_CODE (def_rhs) == PLUS_EXPR
! 	  || TREE_CODE (def_rhs) == MINUS_EXPR))
      {
        tree op0 = TREE_OPERAND (def_rhs, 0);
        tree op1 = TREE_OPERAND (def_rhs, 1);
*** gcc/config/sparc/sparc.h.0	2008-06-30 20:44:49.281272416 +0200
--- gcc/config/sparc/sparc.h	2008-06-30 20:45:36.448101968 +0200
*************** enum reg_class { NO_REGS, FPCC_REGS, I64
*** 1057,1068 ****
     SImode loads to floating-point registers are not zero-extended.
     The definition for LOAD_EXTEND_OP specifies that integer loads
     narrower than BITS_PER_WORD will be zero-extended.  As a result,
!    we inhibit changes from SImode unless they are to a mode that is
!    identical in size.  */
  
  #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)		\
    (TARGET_ARCH64						\
!    && (FROM) == SImode						\
     && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)		\
     ? reg_classes_intersect_p (CLASS, FP_REGS) : 0)
  
--- 1057,1068 ----
     SImode loads to floating-point registers are not zero-extended.
     The definition for LOAD_EXTEND_OP specifies that integer loads
     narrower than BITS_PER_WORD will be zero-extended.  As a result,
!    we inhibit changes from SImode and SFmode unless they are to a
!    mode that is identical in size.  */
  
  #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)		\
    (TARGET_ARCH64						\
!    && ((FROM) == SImode || (FROM) == SFmode)			\
     && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)		\
     ? reg_classes_intersect_p (CLASS, FP_REGS) : 0)
  
*** gcc/dwarf2out.c.0	2008-07-01 11:31:29.377534544 +0200
--- gcc/dwarf2out.c	2008-07-01 11:31:45.541077312 +0200
*************** is_subrange_type (tree type)
*** 8292,8298 ****
      return false;
  
    if (TREE_CODE (subtype) != INTEGER_TYPE
!       && TREE_CODE (subtype) != ENUMERAL_TYPE)
      return false;
  
    if (TREE_CODE (type) == TREE_CODE (subtype)
--- 8292,8299 ----
      return false;
  
    if (TREE_CODE (subtype) != INTEGER_TYPE
!       && TREE_CODE (subtype) != ENUMERAL_TYPE
!       && TREE_CODE (subtype) != BOOLEAN_TYPE)
      return false;
  
    if (TREE_CODE (type) == TREE_CODE (subtype)
*** gcc/dbxout.c.0	2008-07-07 21:32:14.956523304 +0200
--- gcc/dbxout.c	2008-07-07 21:37:10.384611408 +0200
*************** dbxout_reg_parms (tree parms)
*** 3317,3327 ****
  	        if (declared_type == passed_type)
  	          dbxout_symbol_location (parms, TREE_TYPE (parms),
  	                                  0, DECL_INCOMING_RTL (parms));
! 	        else if (! BYTES_BIG_ENDIAN
! 	                 && ((TREE_CODE (declared_type) == INTEGER_TYPE)
! 	                     || (TREE_CODE (declared_type) == ENUMERAL_TYPE))
! 	                 && (GET_MODE_SIZE (TYPE_MODE (declared_type))
! 	                      <= GET_MODE_SIZE (TYPE_MODE (passed_type))))
  	          dbxout_symbol_location (parms, TREE_TYPE (parms),
                                            0, DECL_INCOMING_RTL (parms));
  	      }
--- 3317,3328 ----
  	        if (declared_type == passed_type)
  	          dbxout_symbol_location (parms, TREE_TYPE (parms),
  	                                  0, DECL_INCOMING_RTL (parms));
! 	        else if (!BYTES_BIG_ENDIAN
! 	                 && (TREE_CODE (declared_type) == INTEGER_TYPE
! 	                     || TREE_CODE (declared_type) == ENUMERAL_TYPE
! 	                     || TREE_CODE (declared_type) == BOOLEAN_TYPE)
! 	                 && GET_MODE_SIZE (TYPE_MODE (declared_type))
! 	                      <= GET_MODE_SIZE (TYPE_MODE (passed_type)))
  	          dbxout_symbol_location (parms, TREE_TYPE (parms),
                                            0, DECL_INCOMING_RTL (parms));
  	      }
*** gcc/tree-nested.c.0	2008-07-08 12:13:25.034277584 +0200
--- gcc/tree-nested.c	2008-07-08 12:14:06.609957120 +0200
*************** walk_stmts (struct walk_stmt_info *wi, t
*** 702,707 ****
--- 702,708 ----
        break;
  
      case COND_EXPR:
+       wi->val_only = true;
        walk_tree (&COND_EXPR_COND (t), wi->callback, wi, NULL);
        walk_stmts (wi, &COND_EXPR_THEN (t));
        walk_stmts (wi, &COND_EXPR_ELSE (t));
*** gcc/configure.ac.0	2008-07-09 10:08:43.421072792 +0200
--- gcc/configure.ac	2008-07-09 10:08:54.334413712 +0200
*************** AC_DEFINE_UNQUOTED(CONFIG_SJLJ_EXCEPTION
*** 1185,1190 ****
--- 1185,1196 ----
  AC_ARG_WITH(system-libunwind,
  [  --with-system-libunwind use installed libunwind])
  
+ # config.gcc also contains tests of with_system_libunwind.
+ if test x$with_system_libunwind = xyes; then
+         AC_DEFINE(HAVE_GETIPINFO, 1,
+ [Define to 1 if system unwind library has _Unwind_GetIPInfo.])
+ fi
+ 
  # --------------------------------------------------------
  # Build, host, and target specific configuration fragments
  # --------------------------------------------------------
*************** if test x$enable___cxa_atexit = xyes || 
*** 1378,1383 ****
--- 1384,1403 ----
    fi
  fi
  
+ use_getipinfo=yes
+ if test x$with_system_libunwind = xyes; then
+    if test x$host = x$target; then
+      AC_SEARCH_LIBS(_Unwind_GetIPInfo, unwind,, [use_getipinfo=no])
+    fi
+ fi
+ GCC_TARGET_TEMPLATE(HAVE_GETIPINFO)
+ if test x$use_getipinfo = xyes; then
+    AC_DEFINE(HAVE_GETIPINFO, 1,
+ 	[Define to 1 if system unwind library has _Unwind_GetIPInfo.])
+ else
+    echo "The system unwind library does not support _Unwind_GetIPInfo."
+ fi
+ 
  # Look for a file containing extra machine modes.
  if test -n "$extra_modes" && test -f $srcdir/config/$extra_modes; then
    extra_modes_file='$(srcdir)'/config/${extra_modes}
*** gcc/configure.0	2008-07-09 10:09:16.405058464 +0200
--- gcc/configure	2008-07-09 10:09:56.212006888 +0200
*************** if test "${gcc_cv_prog_makeinfo_modern+s
*** 7499,7505 ****
  else
      ac_prog_version=`$MAKEINFO --version 2>&1 |
                     sed -n 's/^.*GNU texinfo.* \([0-9][0-9.]*\).*$/\1/p'`
!   echo "configure:7514: version of makeinfo is $ac_prog_version" >&5
    case $ac_prog_version in
      '')     gcc_cv_prog_makeinfo_modern=no;;
      4.[2-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*)
--- 7499,7505 ----
  else
      ac_prog_version=`$MAKEINFO --version 2>&1 |
                     sed -n 's/^.*GNU texinfo.* \([0-9][0-9.]*\).*$/\1/p'`
!   echo "configure:7502: version of makeinfo is $ac_prog_version" >&5
    case $ac_prog_version in
      '')     gcc_cv_prog_makeinfo_modern=no;;
      4.[2-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*)
*************** if test "${with_system_libunwind+set}" =
*** 11943,11948 ****
--- 11943,11957 ----
  
  fi;
  
+ # config.gcc also contains tests of with_system_libunwind.
+ if test x$with_system_libunwind = xyes; then
+ 
+ cat >>confdefs.h <<\_ACEOF
+ #define HAVE_GETIPINFO 1
+ _ACEOF
+ 
+ fi
+ 
  # --------------------------------------------------------
  # Build, host, and target specific configuration fragments
  # --------------------------------------------------------
*************** _ACEOF
*** 12238,12243 ****
--- 12247,12396 ----
    fi
  fi
  
+ use_getipinfo=yes
+ if test x$with_system_libunwind = xyes; then
+    if test x$host = x$target; then
+      echo "$as_me:$LINENO: checking for library containing _Unwind_GetIPInfo" >&5
+ echo $ECHO_N "checking for library containing _Unwind_GetIPInfo... $ECHO_C" >&6
+ if test "${ac_cv_search__Unwind_GetIPInfo+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   ac_func_search_save_LIBS=$LIBS
+ ac_cv_search__Unwind_GetIPInfo=no
+ cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ 
+ /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char _Unwind_GetIPInfo ();
+ int
+ main ()
+ {
+ _Unwind_GetIPInfo ();
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+   (eval $ac_link) 2>conftest.er1
+   ac_status=$?
+   grep -v '^ *+' conftest.er1 >conftest.err
+   rm -f conftest.er1
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+ 	 { ac_try='test -z "$ac_c_werror_flag"
+ 			 || test ! -s conftest.err'
+   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; } &&
+ 	 { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_search__Unwind_GetIPInfo="none required"
+ else
+   echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ fi
+ rm -f conftest.err conftest.$ac_objext \
+       conftest$ac_exeext conftest.$ac_ext
+ if test "$ac_cv_search__Unwind_GetIPInfo" = no; then
+   for ac_lib in unwind; do
+     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+     cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ 
+ /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char _Unwind_GetIPInfo ();
+ int
+ main ()
+ {
+ _Unwind_GetIPInfo ();
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+   (eval $ac_link) 2>conftest.er1
+   ac_status=$?
+   grep -v '^ *+' conftest.er1 >conftest.err
+   rm -f conftest.er1
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+ 	 { ac_try='test -z "$ac_c_werror_flag"
+ 			 || test ! -s conftest.err'
+   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; } &&
+ 	 { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_search__Unwind_GetIPInfo="-l$ac_lib"
+ break
+ else
+   echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ fi
+ rm -f conftest.err conftest.$ac_objext \
+       conftest$ac_exeext conftest.$ac_ext
+   done
+ fi
+ LIBS=$ac_func_search_save_LIBS
+ fi
+ echo "$as_me:$LINENO: result: $ac_cv_search__Unwind_GetIPInfo" >&5
+ echo "${ECHO_T}$ac_cv_search__Unwind_GetIPInfo" >&6
+ if test "$ac_cv_search__Unwind_GetIPInfo" != no; then
+   test "$ac_cv_search__Unwind_GetIPInfo" = "none required" || LIBS="$ac_cv_search__Unwind_GetIPInfo $LIBS"
+ 
+ else
+   use_getipinfo=no
+ fi
+ 
+    fi
+ fi
+ 
+ if test x$use_getipinfo = xyes; then
+ 
+ cat >>confdefs.h <<\_ACEOF
+ #define HAVE_GETIPINFO 1
+ _ACEOF
+ 
+ else
+    echo "The system unwind library does not support _Unwind_GetIPInfo."
+ fi
+ 
  # Look for a file containing extra machine modes.
  if test -n "$extra_modes" && test -f $srcdir/config/$extra_modes; then
    extra_modes_file='$(srcdir)'/config/${extra_modes}
*** gcc/config.in.0	2008-07-09 10:09:23.583967104 +0200
--- gcc/config.in	2008-07-09 10:10:11.306712144 +0200
***************
*** 768,773 ****
--- 768,776 ----
  #endif
  
  
+ /* Define to 1 if system unwind library has _Unwind_GetIPInfo. */
+ #undef HAVE_GETIPINFO
+ 
  /* Define to 1 if you have the `getrlimit' function. */
  #ifndef USED_FOR_TARGET
  #undef HAVE_GETRLIMIT
*** gcc/unwind-compat.c.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/unwind-compat.c	2008-07-05 18:49:01.000000000 +0200
***************
*** 1,5 ****
  /* Backward compatibility unwind routines.
!    Copyright (C) 2004, 2005
     Free Software Foundation, Inc.
  
     This file is part of GCC.
--- 1,5 ----
  /* Backward compatibility unwind routines.
!    Copyright (C) 2004, 2005, 2006
     Free Software Foundation, Inc.
  
     This file is part of GCC.
*************** _Unwind_GetIP (struct _Unwind_Context *c
*** 136,141 ****
--- 136,148 ----
  }
  symver (_Unwind_GetIP, GCC_3.0);
  
+ _Unwind_Ptr
+ _Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)
+ {
+   *ip_before_insn = 0;
+   return __libunwind_Unwind_GetIP (context);
+ }
+ 
  extern void *__libunwind_Unwind_GetLanguageSpecificData
    (struct _Unwind_Context *);
  
*** gcc/unwind-dw2.c.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/unwind-dw2.c	2008-07-05 18:49:01.000000000 +0200
***************
*** 1,5 ****
  /* DWARF2 exception handling and frame unwind runtime interface routines.
!    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
     Free Software Foundation, Inc.
  
     This file is part of GCC.
--- 1,5 ----
  /* DWARF2 exception handling and frame unwind runtime interface routines.
!    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
     Free Software Foundation, Inc.
  
     This file is part of GCC.
*************** struct _Unwind_Context
*** 71,76 ****
--- 71,77 ----
    void *lsda;
    struct dwarf_eh_bases bases;
    _Unwind_Word args_size;
+   char signal_frame;
  };
  
  /* Byte size of every register managed by these routines.  */
*************** _Unwind_GetIP (struct _Unwind_Context *c
*** 207,212 ****
--- 208,223 ----
    return (_Unwind_Ptr) context->ra;
  }
  
+ /* Retrieve the return address and flag whether that IP is before
+    or after first not yet fully executed instruction.  */
+ 
+ inline _Unwind_Ptr
+ _Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)
+ {
+   *ip_before_insn = context->signal_frame != 0;
+   return (_Unwind_Ptr) context->ra;
+ }
+ 
  /* Overwrite the return address for CONTEXT with VAL.  */
  
  inline void
*************** extract_cie_info (const struct dwarf_cie
*** 327,332 ****
--- 338,350 ----
  	  aug += 1;
  	}
  
+       /* "S" indicates a signal frame.  */
+       else if (aug[0] == 'S')
+ 	{
+ 	  fs->signal_frame = 1;
+ 	  aug += 1;
+ 	}
+ 
        /* Otherwise we have an unknown augmentation string.
  	 Bail unless we saw a 'z' prefix.  */
        else
*************** execute_cfa_program (const unsigned char
*** 761,768 ****
       a different stack configuration that we are not interested in.  We
       assume that the call itself is unwind info-neutral; if not, or if
       there are delay instructions that adjust the stack, these must be
!      reflected at the point immediately before the call insn.  */
!   while (insn_ptr < insn_end && fs->pc < context->ra)
      {
        unsigned char insn = *insn_ptr++;
        _Unwind_Word reg, utmp;
--- 779,788 ----
       a different stack configuration that we are not interested in.  We
       assume that the call itself is unwind info-neutral; if not, or if
       there are delay instructions that adjust the stack, these must be
!      reflected at the point immediately before the call insn.
!      In signal frames, return address is after last completed instruction,
!      so we add 1 to return address to make the comparison <=.  */
!   while (insn_ptr < insn_end && fs->pc < context->ra + context->signal_frame)
      {
        unsigned char insn = *insn_ptr++;
        _Unwind_Word reg, utmp;
*************** uw_frame_state_for (struct _Unwind_Conte
*** 974,980 ****
    if (context->ra == 0)
      return _URC_END_OF_STACK;
  
!   fde = _Unwind_Find_FDE (context->ra - 1, &context->bases);
    if (fde == NULL)
      {
  #ifdef MD_FALLBACK_FRAME_STATE_FOR
--- 994,1001 ----
    if (context->ra == 0)
      return _URC_END_OF_STACK;
  
!   fde = _Unwind_Find_FDE (context->ra + context->signal_frame - 1,
! 			  &context->bases);
    if (fde == NULL)
      {
  #ifdef MD_FALLBACK_FRAME_STATE_FOR
*************** uw_update_context_1 (struct _Unwind_Cont
*** 1192,1197 ****
--- 1213,1220 ----
  	break;
        }
  
+   context->signal_frame = fs->signal_frame;
+ 
  #ifdef MD_FROB_UPDATE_CONTEXT
    MD_FROB_UPDATE_CONTEXT (context, fs);
  #endif
*** gcc/unwind-dw2.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/unwind-dw2.h	2008-07-05 18:49:01.000000000 +0200
*************** typedef struct
*** 83,88 ****
--- 83,89 ----
    unsigned char fde_encoding;
    unsigned char lsda_encoding;
    unsigned char saw_z;
+   unsigned char signal_frame;
    void *eh_ptr;
  } _Unwind_FrameState;
  
*** gcc/unwind-c.c.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/unwind-c.c	2008-07-09 10:08:54.352410976 +0200
*************** PERSONALITY_FUNCTION (int version,
*** 127,132 ****
--- 127,133 ----
    lsda_header_info info;
    const unsigned char *language_specific_data, *p, *action_record;
    _Unwind_Ptr landing_pad, ip;
+   int ip_before_insn = 0;
  
  #ifdef __ARM_EABI_UNWINDER__
    if ((state & _US_ACTION_MASK) != _US_UNWIND_FRAME_STARTING)
*************** PERSONALITY_FUNCTION (int version,
*** 156,162 ****
  
    /* Parse the LSDA header.  */
    p = parse_lsda_header (context, language_specific_data, &info);
!   ip = _Unwind_GetIP (context) - 1;
    landing_pad = 0;
  
  #ifdef __USING_SJLJ_EXCEPTIONS__
--- 157,169 ----
  
    /* Parse the LSDA header.  */
    p = parse_lsda_header (context, language_specific_data, &info);
! #ifdef HAVE_GETIPINFO
!   ip = _Unwind_GetIPInfo (context, &ip_before_insn);
! #else
!   ip = _Unwind_GetIP (context);
! #endif
!   if (! ip_before_insn)
!     --ip;
    landing_pad = 0;
  
  #ifdef __USING_SJLJ_EXCEPTIONS__
*** gcc/unwind-sjlj.c.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/unwind-sjlj.c	2008-07-05 18:49:01.000000000 +0200
*************** _Unwind_GetIP (struct _Unwind_Context *c
*** 214,219 ****
--- 214,226 ----
    return context->fc->call_site + 1;
  }
  
+ _Unwind_Ptr
+ _Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)
+ {
+   *ip_before_insn = 0;
+   return context->fc->call_site + 1;
+ }
+ 
  /* Set the return landing pad index in CONTEXT.  */
  
  void
*** gcc/unwind-generic.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/unwind-generic.h	2008-07-05 18:49:01.000000000 +0200
***************
*** 1,5 ****
  /* Exception handling and frame unwind runtime interface routines.
!    Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.
  
     This file is part of GCC.
  
--- 1,5 ----
  /* Exception handling and frame unwind runtime interface routines.
!    Copyright (C) 2001, 2003, 2004, 2006 Free Software Foundation, Inc.
  
     This file is part of GCC.
  
*************** extern _Unwind_Word _Unwind_GetGR (struc
*** 155,160 ****
--- 155,161 ----
  extern void _Unwind_SetGR (struct _Unwind_Context *, int, _Unwind_Word);
  
  extern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);
+ extern _Unwind_Ptr _Unwind_GetIPInfo (struct _Unwind_Context *, int *);
  extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);
  
  /* @@@ Retrieve the CFA of the given context.  */
*** gcc/libgcc-std.ver.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/libgcc-std.ver	2008-07-05 18:49:01.000000000 +0200
*************** GCC_4.0.0 {
*** 256,258 ****
--- 256,263 ----
  %inherit GCC_4.1.0 GCC_4.0.0
  GCC_4.1.0 {
  }
+ 
+ %inherit GCC_4.2.0 GCC_4.1.0
+ GCC_4.2.0 {
+   _Unwind_GetIPInfo
+ }
*** gcc/config/alpha/osf5-unwind.h.0	2008-07-10 12:10:00.617790936 +0200
--- gcc/config/alpha/osf5-unwind.h	2008-07-10 12:11:14.997483504 +0200
*************** alpha_fallback_frame_state (struct _Unwi
*** 344,349 ****
--- 344,350 ----
    fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;
    fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset
      = (void *) &sigctx->sc_pc - (void *) k_cfa;
+   fs->signal_frame = 1;
  
    return _URC_NO_REASON;
  }
*** gcc/config/arm/unwind-arm.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/arm/unwind-arm.h	2008-07-05 18:49:01.000000000 +0200
***************
*** 1,5 ****
  /* Header file for the ARM EABI unwinder
!    Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
     Contributed by Paul Brook
  
     This file is free software; you can redistribute it and/or modify it
--- 1,5 ----
  /* Header file for the ARM EABI unwinder
!    Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
     Contributed by Paul Brook
  
     This file is free software; you can redistribute it and/or modify it
*************** extern "C" {
*** 253,258 ****
--- 253,261 ----
  #define _Unwind_GetIP(context) \
    (_Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)
  
+ #define _Unwind_GetIP(context, ip_before_insn) \
+   (*ip_before_insn = 0, _Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)
+ 
    static inline void
    _Unwind_SetGR (_Unwind_Context *context, int regno, _Unwind_Word val)
      {
*** gcc/config/i386/linux-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/i386/linux-unwind.h	2008-07-07 13:45:28.000000000 +0200
***************
*** 1,5 ****
  /* DWARF2 EH unwinding support for AMD x86-64 and x86.
!    Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
  This file is part of GCC.
  
--- 1,5 ----
  /* DWARF2 EH unwinding support for AMD x86-64 and x86.
!    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
  
  This file is part of GCC.
  
*************** x86_64_fallback_frame_state (struct _Unw
*** 100,105 ****
--- 100,106 ----
    fs->regs.reg[16].how = REG_SAVED_OFFSET;
    fs->regs.reg[16].loc.offset = (long)&sc->rip - new_cfa;
    fs->retaddr_column = 16;
+   fs->signal_frame = 1;
    return _URC_NO_REASON;
  }
  
*************** x86_fallback_frame_state (struct _Unwind
*** 172,179 ****
--- 173,200 ----
    fs->regs.reg[8].how = REG_SAVED_OFFSET;
    fs->regs.reg[8].loc.offset = (long)&sc->REG_NAME(eip) - new_cfa;
    fs->retaddr_column = 8;
+   fs->signal_frame = 1;
    return _URC_NO_REASON;
  }
+ 
+ #define MD_FROB_UPDATE_CONTEXT x86_frob_update_context
+ 
+ /* Fix up for kernels that have vDSO, but don't have S flag in it.  */
+ 
+ static void
+ x86_frob_update_context (struct _Unwind_Context *context,
+ 			 _Unwind_FrameState *fs)
+ {
+   unsigned char *pc = context->ra;
+ 
+   /* movl $__NR_rt_sigreturn,%eax ; {int $0x80 | syscall}  */
+   if (*(unsigned char *)(pc+0) == 0xb8
+       && *(unsigned int *)(pc+1) == 173
+       && (*(unsigned short *)(pc+5) == 0x80cd
+ 	  || *(unsigned short *)(pc+5) == 0x050f))
+     context->signal_frame = 1;
+ }
+ 
  #endif /* not glibc 2.0 */
  #endif /* ifdef __x86_64__  */
  #endif /* ifdef inhibit_libc  */
*** gcc/config/i386/freebsd-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/i386/freebsd-unwind.h	2008-07-05 18:49:01.000000000 +0200
*************** x86_freebsd_fallback_frame_state
*** 87,91 ****
--- 87,92 ----
      (FS)->regs.reg[8].how = REG_SAVED_OFFSET;
      (FS)->regs.reg[8].loc.offset = (long)&sc_->sc_eip - new_cfa_;
      (FS)->retaddr_column = 8;
+     (FS)->signal_frame = 1;
      return _URC_NO_REASON;
  }
*** gcc/config/i386/sol2-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/i386/sol2-unwind.h	2008-07-05 18:49:01.000000000 +0200
*************** sol2_fallback_frame_state (struct _Unwin
*** 146,151 ****
--- 146,152 ----
    fs->regs.reg[8].how = REG_SAVED_OFFSET;
    fs->regs.reg[8].loc.offset = (long)&mctx->gregs[EIP] - new_cfa;
    fs->retaddr_column = 8;
+   fs->signal_frame = 1;
  
    if (eh_debug)
      printf ("FALLBACK - ncfa = 0x%p, nip = 0x%p\n",
*** gcc/config/i386/win32-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/i386/win32-unwind.h	2008-07-07 12:16:39.000000000 +0200
*************** x86_fallback_frame_state (struct _Unwind
*** 196,211 ****
        fs->regs.reg[DWFR(GCC_EDI)].loc.offset = (long)&proc_ctx->Edi - new_cfa;
        fs->regs.reg[DWFR(GCC_EBP)].how = REG_SAVED_OFFSET;
        fs->regs.reg[DWFR(GCC_EBP)].loc.offset = (long)&proc_ctx->Ebp - new_cfa;
- 
-       fs->regs.reg[9].how = REG_SAVED_OFFSET;
-       fs->regs.reg[9].loc.offset = (long)&proc_ctx->Eip - new_cfa;
- 
-       /* Set the return address to Eip + 1.  As we can be called multiple
- 	 times we use another register for this.  */
-       proc_ctx->Dr0 = proc_ctx->Eip + 1;
        fs->regs.reg[DW_EIP].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DW_EIP].loc.offset = (long)&proc_ctx->Dr0 - new_cfa;
        fs->retaddr_column = DW_EIP;
  
        return _URC_NO_REASON;
      }
--- 196,205 ----
        fs->regs.reg[DWFR(GCC_EDI)].loc.offset = (long)&proc_ctx->Edi - new_cfa;
        fs->regs.reg[DWFR(GCC_EBP)].how = REG_SAVED_OFFSET;
        fs->regs.reg[DWFR(GCC_EBP)].loc.offset = (long)&proc_ctx->Ebp - new_cfa;
        fs->regs.reg[DW_EIP].how = REG_SAVED_OFFSET;
!       fs->regs.reg[DW_EIP].loc.offset = (long)&proc_ctx->Eip - new_cfa;
        fs->retaddr_column = DW_EIP;
+       fs->signal_frame = 1;
  
        return _URC_NO_REASON;
      }
*************** x86_fallback_frame_state (struct _Unwind
*** 231,236 ****
--- 225,231 ----
        fs->regs.reg[DW_EIP].how = REG_SAVED_OFFSET;
        fs->regs.reg[DW_EIP].loc.offset = 0;
        fs->retaddr_column = DW_EIP;
+       fs->signal_frame = 1;
  
        return _URC_NO_REASON;
      }
*** gcc/config/ia64/unwind-ia64.c.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/ia64/unwind-ia64.c	2008-07-05 18:49:01.000000000 +0200
*************** _Unwind_GetIP (struct _Unwind_Context *c
*** 1707,1712 ****
--- 1707,1719 ----
    return context->rp;
  }
  
+ inline _Unwind_Ptr
+ _Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)
+ {
+   *ip_before_insn = 0;
+   return context->rp;
+ }
+ 
  /* Overwrite the return address for CONTEXT with VAL.  */
  
  inline void
*** gcc/config/mips/iris6-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/mips/iris6-unwind.h	2008-07-07 12:28:45.000000000 +0200
*************** mips_fallback_frame_state (struct _Unwin
*** 131,145 ****
      }
  
    /* State the rules to find the kernel's code "return address", which is the
!      address of the active instruction when the signal was caught.  Cheat two
!      call clobbered register slots (that we don't care restoring properly) to
!      account for the unwinder's adjustments caused by it expecting to have a
!      call return address at hand.  */
!   sigctx->sc_regs [CTX_T0] = sigctx->sc_pc + 4;
  
-   fs->retaddr_column = CTX_T1;
-   fs->regs.reg[CTX_T1].how = REG_SAVED_OFFSET;
-   fs->regs.reg[CTX_T1].loc.offset = SIGCTX_GREG_ADDR (CTX_T0, sigctx) - k_cfa;
-    
    return _URC_NO_REASON;
  }
--- 131,141 ----
      }
  
    /* State the rules to find the kernel's code "return address", which is the
!      address of the active instruction when the signal was caught.  */
!   fs->retaddr_column = CTX_T0;
!   fs->regs.reg[CTX_T0].how = REG_SAVED_OFFSET;
!   fs->regs.reg[CTX_T0].loc.offset = (void *)&sigctx->sc_pc - k_cfa;
!   fs->signal_frame = 1;
  
    return _URC_NO_REASON;
  }
*** gcc/config/pa/hpux-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/pa/hpux-unwind.h	2008-07-05 18:49:01.000000000 +0200
*************** pa_fallback_frame_state (struct _Unwind_
*** 308,313 ****
--- 308,314 ----
  
        fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
        UPDATE_FS_FOR_PC (fs, DWARF_ALT_FRAME_RETURN_COLUMN);
+       fs->signal_frame = 1;
  
        return _URC_NO_REASON;
      }
*** gcc/config/rs6000/aix-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/rs6000/aix-unwind.h	2008-07-05 18:49:01.000000000 +0200
*************** ppc_aix_fallback_frame_state (struct _Un
*** 194,199 ****
--- 194,200 ----
  
    fs->retaddr_column = RETURN_COLUMN;
    REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->iar, new_cfa);
+   fs->signal_frame = 1;
  
    /* Honor FP Ever Used ...   */
    if (mctx->fpeu)
*** gcc/config/rs6000/linux-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/rs6000/linux-unwind.h	2008-07-05 18:49:01.000000000 +0200
***************
*** 1,5 ****
  /* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.
!    Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
     This file is part of GCC.
  
--- 1,5 ----
  /* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.
!    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
  
     This file is part of GCC.
  
*************** struct gcc_ucontext
*** 89,114 ****
  
  enum { SIGNAL_FRAMESIZE = 128 };
  
- /* If the current unwind info (FS) does not contain explicit info
-    saving R2, then we have to do a minor amount of code reading to
-    figure out if it was saved.  The big problem here is that the
-    code that does the save/restore is generated by the linker, so
-    we have no good way to determine at compile time what to do.  */
- 
- #define MD_FROB_UPDATE_CONTEXT frob_update_context
- 
- static void
- frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
- {
-   if (fs->regs.reg[2].how == REG_UNSAVED)
-     {
-       unsigned int *insn
- 	= (unsigned int *) _Unwind_GetGR (context, LINK_REGISTER_REGNUM);
-       if (*insn == 0xE8410028)
- 	_Unwind_SetGRPtr (context, 2, context->cfa + 40);
-     }
- }
- 
  /* If PC is at a sigreturn trampoline, return a pointer to the
     regs.  Otherwise return NULL.  */
  
--- 89,94 ----
*************** ppc_fallback_frame_state (struct _Unwind
*** 275,280 ****
--- 255,261 ----
    fs->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;
    fs->regs.reg[ARG_POINTER_REGNUM].loc.offset = (long) &regs->nip - new_cfa;
    fs->retaddr_column = ARG_POINTER_REGNUM;
+   fs->signal_frame = 1;
  
    if (hwcap == 0)
      {
*************** ppc_fallback_frame_state (struct _Unwind
*** 325,327 ****
--- 306,351 ----
  
    return _URC_NO_REASON;
  }
+ 
+ #define MD_FROB_UPDATE_CONTEXT frob_update_context
+ 
+ static void
+ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
+ {
+   const unsigned int *pc = (const unsigned int *) context->ra;
+ 
+   /* Fix up for 2.6.12 - 2.6.16 Linux kernels that have vDSO, but don't
+      have S flag in it.  */
+ #ifdef __powerpc64__
+   /* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */
+   /* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */
+   if (pc[0] == 0x38210000 + SIGNAL_FRAMESIZE
+       && (pc[1] == 0x38000077 || pc[1] == 0x380000AC)
+       && pc[2] == 0x44000002)
+     context->signal_frame = 1;
+ #else
+   /* li r0, 0x7777; sc  (sigreturn old)  */
+   /* li r0, 0x0077; sc  (sigreturn new)  */
+   /* li r0, 0x6666; sc  (rt_sigreturn old)  */
+   /* li r0, 0x00AC; sc  (rt_sigreturn new)  */
+   if ((pc[0] == 0x38007777 || pc[0] == 0x38000077
+        || pc[0] == 0x38006666 || pc[0] == 0x380000AC)
+       && pc[1] == 0x44000002)
+     context->signal_frame = 1;
+ #endif
+ 
+ #ifdef __powerpc64__
+   if (fs->regs.reg[2].how == REG_UNSAVED)
+     {
+       /* If the current unwind info (FS) does not contain explicit info
+ 	 saving R2, then we have to do a minor amount of code reading to
+ 	 figure out if it was saved.  The big problem here is that the
+ 	 code that does the save/restore is generated by the linker, so
+ 	 we have no good way to determine at compile time what to do.  */
+       unsigned int *insn
+ 	= (unsigned int *) _Unwind_GetGR (context, LINK_REGISTER_REGNUM);
+       if (*insn == 0xE8410028)
+ 	_Unwind_SetGRPtr (context, 2, context->cfa + 40);
+     }
+ #endif
+ }
*** gcc/config/rs6000/vxworks-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/rs6000/vxworks-unwind.h	2008-07-05 18:49:01.000000000 +0200
*************** ppc_vxworks_fallback_frame_state (struct
*** 147,152 ****
--- 147,153 ----
  
    fs->retaddr_column = RETURN_COLUMN;
    REGISTER_CFA_OFFSET_FOR (fs, RETURN_COLUMN, &mctx->pc, new_cfa);
+   fs->signal_frame = 1;
  
    return _URC_NO_REASON;
  }
*** gcc/config/s390/linux-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/s390/linux-unwind.h	2008-07-05 18:49:01.000000000 +0200
***************
*** 1,5 ****
  /* DWARF2 EH unwinding support for S/390 Linux.
!    Copyright (C) 2004, 2005 Free Software Foundation, Inc.
  
  This file is part of GCC.
  
--- 1,5 ----
  /* DWARF2 EH unwinding support for S/390 Linux.
!    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
  
  This file is part of GCC.
  
*************** s390_fallback_frame_state (struct _Unwin
*** 113,139 ****
    fs->regs.reg[32].how = REG_SAVED_OFFSET;
    fs->regs.reg[32].loc.offset = (long)&regs->psw_addr - new_cfa;
    fs->retaddr_column = 32;
! 
!   /* If we got a SIGSEGV or a SIGBUS, the PSW address points *to*
!      the faulting instruction, not after it.  This causes the logic
!      in unwind-dw2.c that decrements the RA to determine the correct
!      CFI region to get confused.  To fix that, we *increment* the RA
!      here in that case.  Note that we cannot modify the RA in place,
!      and the frame state wants a *pointer*, not a value; thus we put
!      the modified RA value into the unused register 33 slot of FS and
!      have the register 32 save address point to that slot.
! 
!      Unfortunately, for regular signals on old kernels, we don't know
!      the signal number.  We default to not fiddling with the RA;
!      that can fail in rare cases.  Upgrade your kernel.  */
! 
!   if (signo && (*signo == 11 || *signo == 7))
!     {
!       fs->regs.reg[33].loc.exp =
! 	(unsigned char *)regs->psw_addr + 1;
!       fs->regs.reg[32].loc.offset =
! 	(long)&fs->regs.reg[33].loc.exp - new_cfa;
!     }
  
    return _URC_NO_REASON;
  }
--- 113,123 ----
    fs->regs.reg[32].how = REG_SAVED_OFFSET;
    fs->regs.reg[32].loc.offset = (long)&regs->psw_addr - new_cfa;
    fs->retaddr_column = 32;
!   /* SIGILL, SIGFPE and SIGTRAP are delivered with psw_addr
!      after the faulting instruction rather than before it.
!      Don't set FS->signal_frame in that case.  */
!   if (!signo || (*signo != 4 && *signo != 5 && *signo != 8))
!     fs->signal_frame = 1;
  
    return _URC_NO_REASON;
  }
*** gcc/config/sparc/sol2-unwind.h.0	2008-07-05 18:48:28.000000000 +0200
--- gcc/config/sparc/sol2-unwind.h	2008-07-08 10:31:39.000000000 +0200
*************** Boston, MA 02110-1301, USA.  */
*** 36,42 ****
  
  /* 64-bit SPARC version */
  #define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state
- #define MD_FROB_UPDATE_CONTEXT sparc64_frob_update_context
  
  static _Unwind_Reason_Code
  sparc64_fallback_frame_state (struct _Unwind_Context *context,
--- 36,41 ----
*************** sparc64_fallback_frame_state (struct _Un
*** 44,53 ****
  {
    void *pc = context->ra;
    void *this_cfa = context->cfa;
!   void *new_cfa;
    int regs_off;
    int fpu_save_off;
-   void **ra_location;
    unsigned char fpu_save;
    int i;
  
--- 43,51 ----
  {
    void *pc = context->ra;
    void *this_cfa = context->cfa;
!   void *new_cfa, *ra_location, *shifted_ra_location;
    int regs_off;
    int fpu_save_off;
    unsigned char fpu_save;
    int i;
  
*************** sparc64_fallback_frame_state (struct _Un
*** 66,81 ****
      = {0x9de3bf50, 0x90100018, 0x92100019, 0x9fc6c000,
         0x9410001a, 0x81c7e008, 0x81e80000};
  
!   if ((unsigned long)pc & 3)
      {
-       /* Ugh.  The PC is not a multiple of 4 as it should be on SPARC,
- 	 so the pattern matching code just below will make unaligned
- 	 loads, possibly throwing us in an infinite loop from there.
- 	 Hope for the best and pretend that we are responsible for
- 	 having done that as part of the adjustment of the context in
- 	 the signal handler.  Which means that we are in the context
- 	 of a frame-less function from which a signal was raised.  */
- 
        /* The CFA is by definition unmodified in this case.  */
        fs->cfa_how = CFA_REG_OFFSET;
        fs->cfa_reg = __builtin_dwarf_sp_column ();
--- 64,72 ----
      = {0x9de3bf50, 0x90100018, 0x92100019, 0x9fc6c000,
         0x9410001a, 0x81c7e008, 0x81e80000};
  
!   /* Deal with frame-less function from which a signal was raised.  */
!   if (context->signal_frame)
      {
        /* The CFA is by definition unmodified in this case.  */
        fs->cfa_how = CFA_REG_OFFSET;
        fs->cfa_reg = __builtin_dwarf_sp_column ();
*************** sparc64_fallback_frame_state (struct _Un
*** 114,119 ****
--- 105,111 ----
         both have this minimal stack.  The ucontext_t structure is after
         this offset.  */
      regs_off = 176 + 176;
+ 
    /* Look for the __sighndlr pattern.  */
    else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
  	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
*************** sparc64_fallback_frame_state (struct _Un
*** 147,156 ****
  	   sigacthandler frame.  The ucontext_t structure is after this
  	   offset.  */
  	regs_off = 176 + 304 + 176;
!     }  
    else
-     /* Exit if the pattern at the return address does not match the
-        previous three patterns.  */
      return _URC_END_OF_STACK;
  
    /* FPU information can be extracted from the ucontext_t structure 
--- 139,149 ----
  	   sigacthandler frame.  The ucontext_t structure is after this
  	   offset.  */
  	regs_off = 176 + 304 + 176;
!     }
! 
!   /* Exit if the pattern at the return address does not match the
!      previous three patterns.  */
    else
      return _URC_END_OF_STACK;
  
    /* FPU information can be extracted from the ucontext_t structure 
*************** sparc64_fallback_frame_state (struct _Un
*** 220,234 ****
      }
  
    /* State the rules to find the kernel's code "return address", which is
!      the address of the active instruction when the signal was caught.  */
    ra_location = this_cfa + regs_off + (8*10) + (REG_PC*8);
    fs->retaddr_column = 0;
    fs->regs.reg[0].how = REG_SAVED_OFFSET;
!   fs->regs.reg[0].loc.offset = (void *)ra_location - new_cfa;
  
    return _URC_NO_REASON;
  }
  
  static void
  sparc64_frob_update_context (struct _Unwind_Context *context,
  			     _Unwind_FrameState *fs)
--- 213,234 ----
      }
  
    /* State the rules to find the kernel's code "return address", which is
!      the address of the active instruction when the signal was caught.
!      On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we
!      need to preventively subtract it from the purported return address.  */
    ra_location = this_cfa + regs_off + (8*10) + (REG_PC*8);
+   shifted_ra_location = this_cfa + regs_off + (8*10) + (REG_Y*8);
+   *(void **)shifted_ra_location = *(void **)ra_location - 8;
    fs->retaddr_column = 0;
    fs->regs.reg[0].how = REG_SAVED_OFFSET;
!   fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;
!   fs->signal_frame = 1;
  
    return _URC_NO_REASON;
  }
  
+ #define MD_FROB_UPDATE_CONTEXT sparc64_frob_update_context
+ 
  static void
  sparc64_frob_update_context (struct _Unwind_Context *context,
  			     _Unwind_FrameState *fs)
*************** sparc64_frob_update_context (struct _Unw
*** 240,246 ****
    if (fs->cfa_reg == __builtin_dwarf_sp_column ()
        && fs->cfa_how == CFA_REG_OFFSET
        && fs->cfa_offset != 0
!       && fs->retaddr_column != 0)
      context->cfa -= 2047;
  }
  
--- 240,246 ----
    if (fs->cfa_reg == __builtin_dwarf_sp_column ()
        && fs->cfa_how == CFA_REG_OFFSET
        && fs->cfa_offset != 0
!       && !fs->signal_frame)
      context->cfa -= 2047;
  }
  
*************** sparc_fallback_frame_state (struct _Unwi
*** 255,264 ****
  {
    void *pc = context->ra;
    void *this_cfa = context->cfa;
!   void *new_cfa;
    int regs_off;
    int fpu_save_off;
-   void **ra_location;
    unsigned char fpu_save;
    int i;
  
--- 255,263 ----
  {
    void *pc = context->ra;
    void *this_cfa = context->cfa;
!   void *new_cfa, *ra_location, *shifted_ra_location;
    int regs_off;
    int fpu_save_off;
    unsigned char fpu_save;
    int i;
  
*************** sparc_fallback_frame_state (struct _Unwi
*** 279,294 ****
      = {0x9de3bfa0, 0x90100018, 0x92100019, 0x9fc6c000,
         0x9410001a, 0x81c7e008, 0x81e80000};
  
!   if ((unsigned long)pc & 3)
      {
-       /* Ugh.  The PC is not a multiple of 4 as it should be on SPARC,
- 	 so the pattern matching code just below will make unaligned
- 	 loads, possibly throwing us in an infinite loop from there.
- 	 Hope for the best and pretend that we are responsible for
- 	 having done that as part of the adjustment of the context in
- 	 the signal handler.  Which means that we are in the context
- 	 of a frame-less function from which a signal was raised.  */
- 
        /* The CFA is by definition unmodified in this case.  */
        fs->cfa_how = CFA_REG_OFFSET;
        fs->cfa_reg = __builtin_dwarf_sp_column ();
--- 278,286 ----
      = {0x9de3bfa0, 0x90100018, 0x92100019, 0x9fc6c000,
         0x9410001a, 0x81c7e008, 0x81e80000};
  
!   /* Deal with frame-less function from which a signal was raised.  */
!   if (context->signal_frame)
      {
        /* The CFA is by definition unmodified in this case.  */
        fs->cfa_how = CFA_REG_OFFSET;
        fs->cfa_reg = __builtin_dwarf_sp_column ();
*************** sparc_fallback_frame_state (struct _Unwi
*** 319,324 ****
--- 311,317 ----
         returning structs, and 24 bytes to store at least six argument
         to callees.  The ucontext_t structure is after this offset.  */
      regs_off = 96 + 96;
+ 
    /* Look for the __libthread_segvhdlr pattern.  */
    else if (    *(unsigned int *)(pc-(4*6)) == segvhdlr_pattern[0]
  	    && *(unsigned int *)(pc-(4*5)) == segvhdlr_pattern[1]
*************** sparc_fallback_frame_state (struct _Unwi
*** 338,344 ****
         __libthread_segvhdlr).  The ucontext_t structure is after this
         offset.  */
      regs_off = 96 + 96 + 128 + 216;
!     /* Look for the __sighndlr pattern.  */
    else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
  	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
  	    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]
--- 331,338 ----
         __libthread_segvhdlr).  The ucontext_t structure is after this
         offset.  */
      regs_off = 96 + 96 + 128 + 216;
! 
!   /* Look for the __sighndlr pattern.  */
    else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]
  	    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]
  	    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]
*************** sparc_fallback_frame_state (struct _Unwi
*** 382,390 ****
  	   structure is after this offset.  */
  	regs_off = 96 + 96 + 216;
      }
    else
-     /* Exit if the pattern at the return address does not match the
-        previous three patterns.  */
      return _URC_END_OF_STACK;
  
    /* FPU information can be extracted from the ucontext_t structure
--- 376,385 ----
  	   structure is after this offset.  */
  	regs_off = 96 + 96 + 216;
      }
+ 
+   /* Exit if the pattern at the return address does not match the
+      previous three patterns.  */
    else
      return _URC_END_OF_STACK;
  
    /* FPU information can be extracted from the ucontext_t structure
*************** sparc_fallback_frame_state (struct _Unwi
*** 444,458 ****
  	  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;
  	  fs->regs.reg[i + 32].loc.offset
  	    = this_cfa + fpu_save_off + (i*4) - new_cfa;
!         }
      }
  
    /* State the rules to find the kernel's code "return address", which is
!      the address of the active instruction when the signal was caught.  */
    ra_location = this_cfa + regs_off + (4*10) + (REG_PC*4);
    fs->retaddr_column = 0;
    fs->regs.reg[0].how = REG_SAVED_OFFSET;
!   fs->regs.reg[0].loc.offset = (void *)ra_location - new_cfa;
  
    return _URC_NO_REASON;
  };
--- 439,458 ----
  	  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;
  	  fs->regs.reg[i + 32].loc.offset
  	    = this_cfa + fpu_save_off + (i*4) - new_cfa;
! 	}
      }
  
    /* State the rules to find the kernel's code "return address", which is
!      the address of the active instruction when the signal was caught.
!      On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we
!      need to preventively subtract it from the purported return address.  */
    ra_location = this_cfa + regs_off + (4*10) + (REG_PC*4);
+   shifted_ra_location = this_cfa + regs_off + (4*10) + (REG_Y*4);
+   *(void **)shifted_ra_location = *(void **)ra_location - 8;
    fs->retaddr_column = 0;
    fs->regs.reg[0].how = REG_SAVED_OFFSET;
!   fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;
!   fs->signal_frame = 1;
  
    return _URC_NO_REASON;
  };
*** gcc/builtins.def.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/builtins.def	2008-08-11 11:58:57.000000000 +0200
***************
*** 1,6 ****
  /* This file contains the definitions and documentation for the
     builtins used in the GNU compiler.
!    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005
     Free Software Foundation, Inc.
  
  This file is part of GCC.
--- 1,6 ----
  /* This file contains the definitions and documentation for the
     builtins used in the GNU compiler.
!    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
     Free Software Foundation, Inc.
  
  This file is part of GCC.
***************
*** 699,704 ****
--- 699,708 ----
  DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_ENTER, "profile_func_enter")
  DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, "profile_func_exit")
  
+ /* TLS emulation.  */
+ DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, "__emutls_get_address", BT_FN_PTR_PTR, ATTR_CONST_NOTHROW_NONNULL)
+ DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON, "__emutls_register_common", BT_FN_VOID_PTR_WORD_WORD_PTR, ATTR_NOTHROW_LIST)
+ 
  /* Synchronization Primitives.  The "_N" version is the one that the user
     is supposed to be using.  It's overloaded, and is resolved to one of the
     "_1" through "_8" versions, plus some extra casts.  */
*** gcc/builtin-types.def.old	2005-11-19 19:38:36.000000000 +0100
--- gcc/builtin-types.def	2008-08-11 11:57:59.000000000 +0200
***************
*** 71,77 ****
  DEF_PRIMITIVE_TYPE (BT_ULONGLONG, long_long_unsigned_type_node)
  DEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)
  DEF_PRIMITIVE_TYPE (BT_UINTMAX, uintmax_type_node)
! DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 0))
  DEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)
  DEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)
  DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE, long_double_type_node)
--- 71,77 ----
  DEF_PRIMITIVE_TYPE (BT_ULONGLONG, long_long_unsigned_type_node)
  DEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)
  DEF_PRIMITIVE_TYPE (BT_UINTMAX, uintmax_type_node)
! DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 1))
  DEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)
  DEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)
  DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE, long_double_type_node)
***************
*** 332,337 ****
--- 332,339 ----
  		     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE, BT_SIZE)
  DEF_FUNCTION_TYPE_4 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,
  		     BT_INT, BT_FILEPTR, BT_INT, BT_CONST_STRING, BT_VALIST_ARG)
+ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,
+ 		     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)
  
  DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,
  		     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,
*** gcc/c-decl.c.old	2008-08-11 10:55:42.000000000 +0200
--- gcc/c-decl.c	2008-08-11 11:19:26.000000000 +0200
***************
*** 4788,4801 ****
  	  }
  
  	if (threadp)
! 	  {
! 	    if (targetm.have_tls)
! 	      DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
! 	    else
! 	      /* A mere warning is sure to result in improper semantics
! 		 at runtime.  Don't bother to allow this to compile.  */
! 	      error ("thread-local storage not supported for this target");
! 	  }
        }
  
      /* Record `register' declaration for warnings on &
--- 4788,4794 ----
  	  }
  
  	if (threadp)
! 	  DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
        }
  
      /* Record `register' declaration for warnings on &
*** gcc/config/sparc/sol2.h.old	2008-08-11 10:55:42.000000000 +0200
--- gcc/config/sparc/sol2.h	2008-08-11 11:19:32.000000000 +0200
***************
*** 83,89 ****
      {								\
        HOST_WIDE_INT size;					\
  								\
!       if (DECL_THREAD_LOCAL_P (DECL))				\
  	ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "tls_object");	\
        else							\
  	ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");	\
--- 83,89 ----
      {								\
        HOST_WIDE_INT size;					\
  								\
!       if (targetm.have_tls && DECL_THREAD_LOCAL_P (DECL))	\
  	ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "tls_object");	\
        else							\
  	ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");	\
*** gcc/cp/decl.c.old	2007-08-21 03:34:48.000000000 +0200
--- gcc/cp/decl.c	2008-08-11 11:19:26.000000000 +0200
***************
*** 6240,6253 ****
      }
  
    if (declspecs->specs[(int)ds_thread])
!     {
!       if (targetm.have_tls)
! 	DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
!       else
! 	/* A mere warning is sure to result in improper semantics
! 	   at runtime.  Don't bother to allow this to compile.  */
! 	error ("thread-local storage not supported for this target");
!     }
  
    if (TREE_PUBLIC (decl))
      {
--- 6240,6246 ----
      }
  
    if (declspecs->specs[(int)ds_thread])
!     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
  
    if (TREE_PUBLIC (decl))
      {
***************
*** 8382,8396 ****
  		DECL_EXTERNAL (decl) = 1;
  
  		if (thread_p)
! 		  {
! 		    if (targetm.have_tls)
! 		      DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
! 		    else
! 		      /* A mere warning is sure to result in improper
! 			 semantics at runtime.  Don't bother to allow this to
! 			 compile.  */
! 		      error ("thread-local storage not supported for this target");
! 		  }
  	      }
  	    else
  	      {
--- 8375,8381 ----
  		DECL_EXTERNAL (decl) = 1;
  
  		if (thread_p)
! 		  DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
  	      }
  	    else
  	      {
*** gcc/dwarf2out.c.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/dwarf2out.c	2008-08-11 11:19:26.000000000 +0200
***************
*** 9106,9112 ****
  	  rtx rtl;
  
  	  /* If this is not defined, we have no way to emit the data.  */
! 	  if (!targetm.asm_out.output_dwarf_dtprel)
  	    return 0;
  
  	  /* The way DW_OP_GNU_push_tls_address is specified, we can only
--- 9106,9112 ----
  	  rtx rtl;
  
  	  /* If this is not defined, we have no way to emit the data.  */
! 	  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)
  	    return 0;
  
  	  /* The way DW_OP_GNU_push_tls_address is specified, we can only
*** gcc/emutls.c.old	1970-01-01 01:00:00.000000000 +0100
--- gcc/emutls.c	2008-08-11 11:19:32.000000000 +0200
***************
*** 0 ****
--- 1,193 ----
+ /* TLS emulation.
+    Copyright (C) 2006 Free Software Foundation, Inc.
+    Contributed by Jakub Jelinek <jakub@redhat.com>.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 2, or (at your option) any later
+ version.
+ 
+ In addition to the permissions in the GNU General Public License, the
+ Free Software Foundation gives you unlimited permission to link the
+ compiled version of this file into combinations with other programs,
+ and to distribute those combinations without any restriction coming
+ from the use of this file.  (The General Public License restrictions
+ do apply in other respects; for example, they cover modification of
+ the file, and distribution when not linked into a combine
+ executable.)
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to the Free
+ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301, USA.  */
+ 
+ #include "tconfig.h"
+ #include "tsystem.h"
+ #include "coretypes.h"
+ #include "tm.h"
+ #include "gthr.h"
+ 
+ typedef unsigned int word __attribute__((mode(word)));
+ typedef unsigned int pointer __attribute__((mode(pointer)));
+ 
+ struct __emutls_object
+ {
+   word size;
+   word align;
+   union {
+     pointer offset;
+     void *ptr;
+   } loc;
+   void *templ;
+ };
+ 
+ #ifdef __GTHREADS
+ #ifdef __GTHREAD_MUTEX_INIT
+ static __gthread_mutex_t emutls_mutex = __GTHREAD_MUTEX_INIT;
+ #else
+ static __gthread_mutex_t emutls_mutex;
+ #endif
+ static __gthread_key_t emutls_key;
+ static pointer emutls_size;
+ 
+ static void
+ emutls_destroy (void *ptr)
+ {
+   void ***arr = (void ***) ptr;
+   unsigned long int size = (unsigned long int) arr[0];
+   ++arr;
+   while (--size)
+     {
+       if (*arr)
+ 	free ((*arr)[-1]);
+       ++arr;
+     }
+   free (ptr);
+ }
+ 
+ static void
+ emutls_init (void)
+ {
+ #ifndef __GTHREAD_MUTEX_INIT
+   __GTHREAD_MUTEX_INIT_FUNCTION (&emutls_mutex);
+ #endif
+   if (__gthread_key_create (&emutls_key, emutls_destroy) != 0)
+     abort ();
+ }
+ #endif
+ 
+ static void *
+ emutls_alloc (struct __emutls_object *obj)
+ {
+   void *ptr;
+   void *ret;
+ 
+   /* We could use here posix_memalign if available and adjust
+      emutls_destroy accordingly.  */
+   if (obj->align <= sizeof (void *))
+     {
+       ptr = malloc (obj->size + sizeof (void *));
+       if (ptr == NULL)
+ 	abort ();
+       ((void **) ptr)[0] = ptr;
+       ret = ptr + sizeof (void *);
+     }
+   else
+     {
+       ptr = malloc (obj->size + sizeof (void *) + obj->align - 1);
+       if (ptr == NULL)
+ 	abort ();
+       ret = (void *) (((pointer) (ptr + sizeof (void *) + obj->align - 1))
+ 		      & ~(pointer)(obj->align - 1));
+       ((void **) ret)[-1] = ptr;
+     }
+ 
+   if (obj->templ)
+     memcpy (ret, obj->templ, obj->size);
+   else
+     memset (ret, 0, obj->size);
+ 
+   return ret;
+ }
+ 
+ void *
+ __emutls_get_address (struct __emutls_object *obj)
+ {
+   if (! __gthread_active_p ())
+     {
+       if (__builtin_expect (obj->loc.ptr == NULL, 0))
+ 	obj->loc.ptr = emutls_alloc (obj);
+       return obj->loc.ptr;
+     }
+ 
+ #ifndef __GTHREADS
+   abort ();
+ #else
+   pointer offset;
+ 
+   if (__builtin_expect (obj->loc.offset == 0, 0))
+     {
+       static __gthread_once_t once = __GTHREAD_ONCE_INIT;
+       __gthread_once (&once, emutls_init);
+       __gthread_mutex_lock (&emutls_mutex);
+       offset = ++emutls_size;
+       obj->loc.offset = offset;
+       __gthread_mutex_unlock (&emutls_mutex);
+     }
+   else
+     offset = obj->loc.offset;
+ 
+   void **arr = (void **) __gthread_getspecific (emutls_key);
+   if (__builtin_expect (arr == NULL, 0))
+     {
+       pointer size = offset + 32;
+       arr = calloc (size, sizeof (void *));
+       if (arr == NULL)
+ 	abort ();
+       arr[0] = (void *) size;
+       __gthread_setspecific (emutls_key, (void *) arr);
+     }
+   else if (__builtin_expect (offset >= (pointer) arr[0], 0))
+     {
+       pointer orig_size = (pointer) arr[0];
+       pointer size = orig_size * 2;
+       if (offset >= size)
+ 	size = offset + 32;
+       arr = realloc (arr, size * sizeof (void *));
+       if (arr == NULL)
+ 	abort ();
+       memset (arr + orig_size, 0, (size - orig_size) * sizeof (void *));
+       __gthread_setspecific (emutls_key, (void *) arr);
+     }
+ 
+   void *ret = arr[offset];
+   if (__builtin_expect (ret == NULL, 0))
+     {
+       ret = emutls_alloc (obj);
+       arr[offset] = ret;
+     }
+   return ret;
+ #endif
+ }
+ 
+ void
+ __emutls_register_common (struct __emutls_object *obj,
+ 			  word size, word align, void *templ)
+ {
+   if (obj->size < size)
+     {
+       obj->size = size;
+       obj->templ = NULL;
+     }
+   if (obj->align < align)
+     obj->align = align;
+   if (templ && size == obj->size)
+     obj->templ = templ;
+ }
*** gcc/expr.c.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/expr.c	2008-08-11 11:19:26.000000000 +0200
***************
*** 6272,6277 ****
--- 6272,6290 ----
     return MAX (factor, talign);
  }
  
+ /* Return &VAR expression for emulated thread local VAR.  */
+ 
+ static tree
+ emutls_var_address (tree var)
+ {
+   tree emuvar = emutls_decl (var);
+   tree fn = built_in_decls [BUILT_IN_EMUTLS_GET_ADDRESS];
+   tree arg = build_fold_addr_expr_with_type (emuvar, ptr_type_node);
+   tree arglist = build_tree_list (NULL_TREE, arg);
+   tree call = build_function_call_expr (fn, arglist);
+   return fold_convert (build_pointer_type (TREE_TYPE (var)), call);
+ }
+ 
  /* Expands variable VAR.  */
  
  void
***************
*** 6386,6391 ****
--- 6399,6416 ----
        inner = TREE_OPERAND (exp, 0);
        break;
  
+     case VAR_DECL:
+       /* TLS emulation hook - replace __thread VAR's &VAR with
+ 	 __emutls_get_address (&_emutls.VAR).  */
+       if (! targetm.have_tls
+ 	  && TREE_CODE (exp) == VAR_DECL
+ 	  && DECL_THREAD_LOCAL_P (exp))
+ 	{
+ 	  exp = emutls_var_address (exp);
+ 	  return expand_expr (exp, target, tmode, modifier);
+ 	}
+       /* Fall through.  */
+ 
      default:
        /* If the object is a DECL, then expand it for its rtl.  Don't bypass
  	 expand_expr, as that can have various side effects; LABEL_DECLs for
***************
*** 6751,6756 ****
--- 6776,6791 ----
  	  && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))
  	layout_decl (exp, 0);
  
+       /* TLS emulation hook - replace __thread vars with
+ 	 *__emutls_get_address (&_emutls.var).  */
+       if (! targetm.have_tls
+ 	  && TREE_CODE (exp) == VAR_DECL
+ 	  && DECL_THREAD_LOCAL_P (exp))
+ 	{
+ 	  exp = build_fold_indirect_ref (emutls_var_address (exp));
+ 	  return expand_expr_real_1 (exp, target, tmode, modifier, NULL);
+ 	}
+ 
        /* ... fall through ...  */
  
      case FUNCTION_DECL:
*** gcc/libgcc-std.ver.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/libgcc-std.ver	2008-08-11 12:06:34.000000000 +0200
***************
*** 260,263 ****
--- 260,265 ----
  %inherit GCC_4.2.0 GCC_4.1.0
  GCC_4.2.0 {
    _Unwind_GetIPInfo
+   __emutls_get_address
+   __emutls_register_common
  }
*** gcc/Makefile.in.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/Makefile.in	2008-08-11 12:04:57.000000000 +0200
***************
*** 559,565 ****
  
  # Additional sources to handle exceptions; overridden by targets as needed.
  LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
!    $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
  LIB2ADDEHSTATIC = $(LIB2ADDEH)
  LIB2ADDEHSHARED = $(LIB2ADDEH)
  LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h
--- 559,565 ----
  
  # Additional sources to handle exceptions; overridden by targets as needed.
  LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
!    $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c $(srcdir)/emutls.c
  LIB2ADDEHSTATIC = $(LIB2ADDEH)
  LIB2ADDEHSHARED = $(LIB2ADDEH)
  LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h
***************
*** 1335,1343 ****
  	LIBGCOV='$(LIBGCOV)' \
  	LIB2ADD='$(LIB2ADD)' \
  	LIB2ADD_ST='$(LIB2ADD_ST)' \
! 	LIB2ADDEH='$(LIB2ADDEH)' \
! 	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC)' \
! 	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED)' \
  	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
  	LIB2_SIDITI_CONV_FUNCS='$(LIB2_SIDITI_CONV_FUNCS)' \
  	LIBUNWIND='$(LIBUNWIND)' \
--- 1335,1343 ----
  	LIBGCOV='$(LIBGCOV)' \
  	LIB2ADD='$(LIB2ADD)' \
  	LIB2ADD_ST='$(LIB2ADD_ST)' \
! 	LIB2ADDEH='$(LIB2ADDEH) $(srcdir)/emutls.c' \
! 	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC) $(srcdir)/emutls.c' \
! 	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED) $(srcdir)/emutls.c' \
  	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
  	LIB2_SIDITI_CONV_FUNCS='$(LIB2_SIDITI_CONV_FUNCS)' \
  	LIBUNWIND='$(LIBUNWIND)' \
***************
*** 1375,1381 ****
  	tsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
  	$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \
  	$(srcdir)/config/$(LIB1ASMSRC) \
! 	$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c gcov-iov.h
  
  libgcov.a: libgcc.a; @true
  
--- 1375,1381 ----
  	tsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
  	$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \
  	$(srcdir)/config/$(LIB1ASMSRC) \
! 	$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c $(srcdir)/emutls.c gcov-iov.h
  
  libgcov.a: libgcc.a; @true
  
*** gcc/output.h.old	2008-08-11 10:55:42.000000000 +0200
--- gcc/output.h	2008-08-11 11:19:32.000000000 +0200
***************
*** 232,237 ****
--- 232,240 ----
  /* Emit any pending weak declarations.  */
  extern void weak_finish (void);
  
+ /* Emit any pending emutls declarations and initializations.  */
+ extern void emutls_finish (void);
+ 
  /* Decode an `asm' spec for a declaration as a register name.
     Return the register number, or -1 if nothing specified,
     or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,
*** gcc/toplev.c.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/toplev.c	2008-08-11 11:54:29.000000000 +0200
***************
*** 1024,1031 ****
    if (flag_mudflap)
      mudflap_finish_file ();
  
!   /* Write out any pending weak symbol declarations.  */
  
    weak_finish ();
  
    /* Do dbx symbols.  */
--- 1024,1034 ----
    if (flag_mudflap)
      mudflap_finish_file ();
  
!   /* Likewise for emulated thread-local storage.  */
!   if (!targetm.have_tls)
!     emutls_finish ();
  
+   /* Write out any pending weak symbol declarations.  */
    weak_finish ();
  
    /* Do dbx symbols.  */
*** gcc/tree.h.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/tree.h	2008-08-11 11:19:06.000000000 +0200
***************
*** 4165,4170 ****
--- 4165,4171 ----
  extern void process_pending_assemble_externals (void);
  extern void finish_aliases_1 (void);
  extern void finish_aliases_2 (void);
+ extern tree emutls_decl (tree);
  
  /* In stmt.c */
  extern void expand_computed_goto (tree);
*** gcc/tree-ssa-address.c.old	2005-11-19 19:38:37.000000000 +0100
--- gcc/tree-ssa-address.c	2008-08-11 11:19:26.000000000 +0200
***************
*** 1,5 ****
  /* Memory address lowering and addressing mode selection.
!    Copyright (C) 2004 Free Software Foundation, Inc.
     
  This file is part of GCC.
     
--- 1,5 ----
  /* Memory address lowering and addressing mode selection.
!    Copyright (C) 2004, 2006 Free Software Foundation, Inc.
     
  This file is part of GCC.
     
***************
*** 134,143 ****
        act_elem = symbol;
        if (offset)
  	{
! 	  act_elem = gen_rtx_CONST (Pmode,
! 				    gen_rtx_PLUS (Pmode, act_elem, offset));
  	  if (offset_p)
! 	    *offset_p = &XEXP (XEXP (act_elem, 0), 1);
  	}
  
        if (*addr)
--- 134,148 ----
        act_elem = symbol;
        if (offset)
  	{
! 	  act_elem = gen_rtx_PLUS (Pmode, act_elem, offset);
! 
  	  if (offset_p)
! 	    *offset_p = &XEXP (act_elem, 1);
! 
! 	  if (GET_CODE (symbol) == SYMBOL_REF
! 	      || GET_CODE (symbol) == LABEL_REF
! 	      || GET_CODE (symbol) == CONST)
! 	    act_elem = gen_rtx_CONST (Pmode, act_elem);
  	}
  
        if (*addr)
*** gcc/varasm.c.old	2008-08-11 10:55:43.000000000 +0200
--- gcc/varasm.c	2008-08-11 12:25:32.000000000 +0200
***************
*** 53,58 ****
--- 53,59 ----
  #include "cgraph.h"
  #include "cfglayout.h"
  #include "basic-block.h"
+ #include "tree-iterator.h"
  
  #ifdef XCOFF_DEBUGGING_INFO
  #include "xcoffout.h"		/* Needed for external data
***************
*** 169,174 ****
--- 170,412 ----
  EXTRA_SECTION_FUNCTIONS
  #endif
  
+ /* TLS emulation.  */
+ 
+ static GTY ((if_marked ("tree_map_marked_p"), param_is (struct tree_map)))
+      htab_t emutls_htab;
+ static GTY (()) tree emutls_object_type;
+ 
+ #ifndef NO_DOT_IN_LABEL
+ # define EMUTLS_VAR_PREFIX	"__emutls_v."
+ # define EMUTLS_TMPL_PREFIX	"__emutls_t."
+ #elif !defined NO_DOLLAR_IN_LABEL
+ # define EMUTLS_VAR_PREFIX	"__emutls_v$"
+ # define EMUTLS_TMPL_PREFIX	"__emutls_t$"
+ #else
+ # define EMUTLS_VAR_PREFIX	"__emutls_v_"
+ # define EMUTLS_TMPL_PREFIX	"__emutls_t_"
+ #endif
+ 
+ /* Create an identifier for the struct __emutls_object, given an identifier
+    of the DECL_ASSEMBLY_NAME of the original object.  */
+ 
+ static tree
+ get_emutls_object_name (tree name)
+ {
+   char *toname = alloca (strlen (IDENTIFIER_POINTER (name))
+ 			 + sizeof (EMUTLS_VAR_PREFIX));
+   strcpy (toname, EMUTLS_VAR_PREFIX);
+   strcpy (toname + sizeof (EMUTLS_VAR_PREFIX) - 1, IDENTIFIER_POINTER (name));
+ 
+   return get_identifier (toname);
+ }
+ 
+ /* Create the structure for struct __emutls_object.  This should match the
+    structure at the top of emutls.c, modulo the union there.  */
+ 
+ static tree
+ get_emutls_object_type (void)
+ {
+   tree type, type_name, field, next_field, word_type_node;
+ 
+   type = emutls_object_type;
+   if (type)
+     return type;
+ 
+   emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);
+   type_name = get_identifier ("__emutls_object");
+   type_name = build_decl (TYPE_DECL, type_name, type);
+   TYPE_NAME (type) = type_name;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("__templ"), ptr_type_node);
+   DECL_CONTEXT (field) = type;
+   next_field = field;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("__offset"), ptr_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+   next_field = field;
+ 
+   word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);
+   field = build_decl (FIELD_DECL, get_identifier ("__align"), word_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+   next_field = field;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("__size"), word_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+ 
+   TYPE_FIELDS (type) = field;
+   layout_type (type);
+ 
+   return type;
+ }
+ 
+ /* Create a read-only variable like DECL, with the same DECL_INITIAL.
+    This will be used for initializing the emulated tls data area.  */
+ 
+ static tree
+ get_emutls_init_templ_addr (tree decl)
+ {
+   tree name, to;
+   char *toname;
+ 
+   if (!DECL_INITIAL (decl))
+     return null_pointer_node;
+ 
+   name = DECL_ASSEMBLER_NAME (decl);
+   toname = alloca (strlen (IDENTIFIER_POINTER (name))
+ 		   + sizeof (EMUTLS_TMPL_PREFIX));
+   strcpy (toname, EMUTLS_TMPL_PREFIX);
+   strcpy (toname + sizeof (EMUTLS_TMPL_PREFIX) - 1, IDENTIFIER_POINTER (name));
+   name = get_identifier (toname);
+ 
+   to = build_decl (VAR_DECL, name, TREE_TYPE (decl));
+   SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
+ 
+   DECL_ARTIFICIAL (to) = 1;
+   TREE_USED (to) = TREE_USED (decl);
+   TREE_READONLY (to) = 1;
+   DECL_IGNORED_P (to) = 1;
+   DECL_CONTEXT (to) = DECL_CONTEXT (decl);
+   DECL_WEAK (to) = DECL_WEAK (decl);
+   if (DECL_ONE_ONLY (decl))
+     {
+       make_decl_one_only (to);
+       TREE_STATIC (to) = TREE_STATIC (decl);
+       TREE_PUBLIC (to) = TREE_PUBLIC (decl);
+       DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);
+     }
+   else
+     TREE_STATIC (to) = 1;
+ 
+   DECL_INITIAL (to) = DECL_INITIAL (decl);
+   DECL_INITIAL (decl) = NULL;
+ 
+   cgraph_varpool_finalize_decl (to);
+   return build_fold_addr_expr (to);
+ }
+ 
+ /* When emulating tls, we use a control structure for use by the runtime.
+    Create and return this structure.  */
+ 
+ tree
+ emutls_decl (tree decl)
+ {
+   tree name, to;
+   struct tree_map *h, in;
+   void **loc;
+ 
+   if (targetm.have_tls || decl == NULL || decl == error_mark_node
+       || TREE_CODE (decl) != VAR_DECL || ! DECL_THREAD_LOCAL_P (decl))
+     return decl;
+ 
+   /* Look up the object in the hash; return the control structure if
+      it has already been created.  */
+   if (! emutls_htab)
+     emutls_htab = htab_create_ggc (512, tree_map_hash, tree_map_eq, 0);
+ 
+   name = DECL_ASSEMBLER_NAME (decl);
+ 
+   /* Note that we use the hash of the decl's name, rather than a hash
+      of the decl's pointer.  In emutls_finish we iterate through the
+      hash table, and we want this traversal to be predictable.  */
+   in.hash = htab_hash_string (IDENTIFIER_POINTER (name));
+   in.from = decl;
+   loc = htab_find_slot_with_hash (emutls_htab, &in, in.hash, INSERT);
+   h = *loc;
+   if (h != NULL)
+     to = h->to;
+   else
+     {
+       to = build_decl (VAR_DECL, get_emutls_object_name (name),
+ 		       get_emutls_object_type ());
+ 
+       h = ggc_alloc (sizeof (struct tree_map));
+       h->hash = in.hash;
+       h->from = decl;
+       h->to = to;
+       *(struct tree_map **) loc = h;
+ 
+       DECL_ARTIFICIAL (to) = 1;
+       DECL_IGNORED_P (to) = 1;
+       TREE_READONLY (to) = 0;
+ 
+       SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
+       if (DECL_ONE_ONLY (decl))
+ 	make_decl_one_only (to);
+       DECL_CONTEXT (to) = DECL_CONTEXT (decl);
+     }
+ 
+   /* Note that these fields may need to be updated from time to time from
+      the original decl.  Consider:
+ 	extern __thread int i;
+ 	int foo() { return i; }
+ 	__thread int i = 1;
+      in which I goes from external to locally defined and initialized.  */
+ 
+   TREE_STATIC (to) = TREE_STATIC (decl);
+   TREE_USED (to) = TREE_USED (decl);
+   TREE_PUBLIC (to) = TREE_PUBLIC (decl);
+   DECL_EXTERNAL (to) = DECL_EXTERNAL (decl);
+   DECL_COMMON (to) = DECL_COMMON (decl);
+   DECL_WEAK (to) = DECL_WEAK (decl);
+   DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);
+ 
+   return to;
+ }
+ 
+ static int
+ emutls_common_1 (void **loc, void *xstmts)
+ {
+   struct tree_map *h = *(struct tree_map **) loc;
+   tree args, x, *pstmts = (tree *) xstmts;
+   tree word_type_node;
+ 
+   if (! DECL_COMMON (h->from)
+       || (DECL_INITIAL (h->from)
+ 	  && DECL_INITIAL (h->from) != error_mark_node))
+     return 1;
+ 
+   word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);
+ 
+   /* The idea was to call get_emutls_init_templ_addr here, but if we
+      do this and there is an initializer, -fanchor_section loses,
+      because it would be too late to ensure the template is
+      output.  */
+   x = null_pointer_node;
+   args = tree_cons (NULL, x, NULL);
+   x = build_int_cst (word_type_node, DECL_ALIGN_UNIT (h->from));
+   args = tree_cons (NULL, x, args);
+   x = fold_convert (word_type_node, DECL_SIZE_UNIT (h->from));
+   args = tree_cons (NULL, x, args);
+   x = build_fold_addr_expr (h->to);
+   args = tree_cons (NULL, x, args);
+ 
+   x = built_in_decls[BUILT_IN_EMUTLS_REGISTER_COMMON];
+   x = build_function_call_expr (x, args);
+ 
+   append_to_statement_list (x, pstmts);
+   return 1;
+ }
+ 
+ void
+ emutls_finish (void)
+ {
+   tree body = NULL_TREE;
+ 
+   if (emutls_htab == NULL)
+     return;
+ 
+   htab_traverse_noresize (emutls_htab, emutls_common_1, &body);
+   if (body == NULL_TREE)
+     return;
+ 
+   cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);
+ }
+ 
+ 
  static void
  initialize_cold_section_name (void)
  {
***************
*** 1603,1608 ****
--- 1841,1893 ----
    int reloc = 0;
    rtx decl_rtl;
  
+   if (! targetm.have_tls
+       && TREE_CODE (decl) == VAR_DECL
+       && DECL_THREAD_LOCAL_P (decl))
+     {
+       tree to = emutls_decl (decl);
+ 
+       /* If this variable is defined locally, then we need to initialize the
+          control structure with size and alignment information.  We do this
+ 	 at the last moment because tentative definitions can take a locally
+ 	 defined but uninitialized variable and initialize it later, which
+ 	 would result in incorrect contents.  */
+       if (! DECL_EXTERNAL (to)
+ 	  && (! DECL_COMMON (to)
+ 	      || (DECL_INITIAL (decl)
+ 		  && DECL_INITIAL (decl) != error_mark_node)))
+ 	{
+ 	  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);
+ 	  constructor_elt *elt;
+ 	  tree type = TREE_TYPE (to);
+ 	  tree field = TYPE_FIELDS (type);
+ 
+ 	  elt = VEC_quick_push (constructor_elt, v, NULL);
+ 	  elt->index = field;
+ 	  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
+ 
+ 	  elt = VEC_quick_push (constructor_elt, v, NULL);
+ 	  field = TREE_CHAIN (field);
+ 	  elt->index = field;
+ 	  elt->value = build_int_cst (TREE_TYPE (field),
+ 				      DECL_ALIGN_UNIT (decl));
+ 
+ 	  elt = VEC_quick_push (constructor_elt, v, NULL);
+ 	  field = TREE_CHAIN (field);
+ 	  elt->index = field;
+ 	  elt->value = null_pointer_node;
+ 
+ 	  elt = VEC_quick_push (constructor_elt, v, NULL);
+ 	  field = TREE_CHAIN (field);
+ 	  elt->index = field;
+ 	  elt->value = get_emutls_init_templ_addr (decl);
+ 
+ 	  DECL_INITIAL (to) = build_constructor (type, v);
+ 	}
+ 
+       decl = to;
+     }
+ 
    if (lang_hooks.decls.prepare_assemble_variable)
      lang_hooks.decls.prepare_assemble_variable (decl);
  
***************
*** 4942,4947 ****
--- 5227,5240 ----
      {
        ultimate_transparent_alias_target (&target);
  
+       if (!targetm.have_tls
+ 	  && TREE_CODE (decl) == VAR_DECL
+ 	  && DECL_THREAD_LOCAL_P (decl))
+ 	{
+ 	  decl = emutls_decl (decl);
+ 	  target = get_emutls_object_name (target);
+ 	}
+ 
        if (!TREE_SYMBOL_REFERENCED (target))
  	weakref_targets = tree_cons (decl, target, weakref_targets);
  
***************
*** 4959,4964 ****
--- 5252,5265 ----
        return;
      }
  
+   if (!targetm.have_tls
+       && TREE_CODE (decl) == VAR_DECL
+       && DECL_THREAD_LOCAL_P (decl))
+     {
+       decl = emutls_decl (decl);
+       target = get_emutls_object_name (target);
+     }
+ 
  #ifdef ASM_OUTPUT_DEF
    /* Make name accessible from other files, if appropriate.  */
  
***************
*** 5789,5795 ****
      flags |= SYMBOL_FLAG_FUNCTION;
    if (targetm.binds_local_p (decl))
      flags |= SYMBOL_FLAG_LOCAL;
!   if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))
      flags |= DECL_TLS_MODEL (decl) << SYMBOL_FLAG_TLS_SHIFT;
    else if (targetm.in_small_data_p (decl))
      flags |= SYMBOL_FLAG_SMALL;
--- 6090,6097 ----
      flags |= SYMBOL_FLAG_FUNCTION;
    if (targetm.binds_local_p (decl))
      flags |= SYMBOL_FLAG_LOCAL;
!   if (targetm.have_tls && TREE_CODE (decl) == VAR_DECL
!       && DECL_THREAD_LOCAL_P (decl))
      flags |= DECL_TLS_MODEL (decl) << SYMBOL_FLAG_TLS_SHIFT;
    else if (targetm.in_small_data_p (decl))
      flags |= SYMBOL_FLAG_SMALL;
*** gcc/builtins.def.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/builtins.def	2008-08-12 10:34:27.000000000 +0200
***************
*** 700,707 ****
  DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, "profile_func_exit")
  
  /* TLS emulation.  */
! DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, "__emutls_get_address", BT_FN_PTR_PTR, ATTR_CONST_NOTHROW_NONNULL)
! DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON, "__emutls_register_common", BT_FN_VOID_PTR_WORD_WORD_PTR, ATTR_NOTHROW_LIST)
  
  /* Synchronization Primitives.  The "_N" version is the one that the user
     is supposed to be using.  It's overloaded, and is resolved to one of the
--- 700,715 ----
  DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, "profile_func_exit")
  
  /* TLS emulation.  */
! DEF_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, targetm.emutls.get_address,
! 	     BUILT_IN_NORMAL,
! 	     BT_FN_PTR_PTR,  BT_FN_PTR_PTR,
! 	     true, true, true, ATTR_CONST_NOTHROW_NONNULL, false,
! 	     !targetm.have_tls)
! DEF_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON,
! 	     targetm.emutls.register_common, BUILT_IN_NORMAL,
! 	     BT_FN_VOID_PTR_WORD_WORD_PTR, BT_FN_VOID_PTR_WORD_WORD_PTR,
! 	     true, true, true, ATTR_NOTHROW_LIST, false,
! 	     !targetm.have_tls)
  
  /* Synchronization Primitives.  The "_N" version is the one that the user
     is supposed to be using.  It's overloaded, and is resolved to one of the
*** gcc/c-common.c.old	2007-03-20 02:33:57.000000000 +0100
--- gcc/c-common.c	2008-08-12 11:19:48.000000000 +0200
***************
*** 4673,4678 ****
--- 4673,4685 ----
  		     *node);
  	      *no_add_attrs = true;
  	    }
+ 	  else if (TREE_CODE (decl) == VAR_DECL
+ 		   && !targetm.have_tls && targetm.emutls.tmpl_section
+ 		   && DECL_THREAD_LOCAL_P (decl))
+ 	    {
+ 	      error ("section of %q+D cannot be overridden", *node);
+ 	      *no_add_attrs = true;
+ 	    }
  	  else
  	    DECL_SECTION_NAME (decl) = TREE_VALUE (args);
  	}
*** gcc/config/i386/i386.c.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/config/i386/i386.c	2008-08-12 11:00:36.000000000 +0200
***************
*** 1752,1757 ****
--- 1752,1760 ----
  	  /* We don't split these for medium model.  Place them into
  	     default sections and hope for best.  */
  	  break;
+ 	case SECCAT_EMUTLS_VAR:
+ 	case SECCAT_EMUTLS_TMPL:
+ 	  gcc_unreachable ();
  	}
        if (sname)
  	{
***************
*** 1790,1805 ****
  	case SECCAT_DATA_REL_LOCAL:
  	case SECCAT_DATA_REL_RO:
  	case SECCAT_DATA_REL_RO_LOCAL:
!           prefix = one_only ? ".gnu.linkonce.ld." : ".ldata.";
  	  break;
  	case SECCAT_BSS:
!           prefix = one_only ? ".gnu.linkonce.lb." : ".lbss.";
  	  break;
  	case SECCAT_RODATA:
  	case SECCAT_RODATA_MERGE_STR:
  	case SECCAT_RODATA_MERGE_STR_INIT:
  	case SECCAT_RODATA_MERGE_CONST:
!           prefix = one_only ? ".gnu.linkonce.lr." : ".lrodata.";
  	  break;
  	case SECCAT_SRODATA:
  	case SECCAT_SDATA:
--- 1793,1808 ----
  	case SECCAT_DATA_REL_LOCAL:
  	case SECCAT_DATA_REL_RO:
  	case SECCAT_DATA_REL_RO_LOCAL:
!           prefix = one_only ? ".ld" : ".ldata";
  	  break;
  	case SECCAT_BSS:
!           prefix = one_only ? ".lb" : ".lbss";
  	  break;
  	case SECCAT_RODATA:
  	case SECCAT_RODATA_MERGE_STR:
  	case SECCAT_RODATA_MERGE_STR_INIT:
  	case SECCAT_RODATA_MERGE_CONST:
!           prefix = one_only ? ".lr" : ".lrodata";
  	  break;
  	case SECCAT_SRODATA:
  	case SECCAT_SDATA:
***************
*** 1811,1833 ****
  	  /* We don't split these for medium model.  Place them into
  	     default sections and hope for best.  */
  	  break;
  	}
        if (prefix)
  	{
! 	  const char *name;
! 	  size_t nlen, plen;
  	  char *string;
- 	  plen = strlen (prefix);
  
  	  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
  	  name = targetm.strip_name_encoding (name);
- 	  nlen = strlen (name);
  
! 	  string = alloca (nlen + plen + 1);
! 	  memcpy (string, prefix, plen);
! 	  memcpy (string + plen, name, nlen + 1);
  
! 	  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
  	  return;
  	}
      }
--- 1814,1841 ----
  	  /* We don't split these for medium model.  Place them into
  	     default sections and hope for best.  */
  	  break;
+ 	case SECCAT_EMUTLS_VAR:
+ 	  prefix = targetm.emutls.var_section;
+ 	  break;
+ 	case SECCAT_EMUTLS_TMPL:
+ 	  prefix = targetm.emutls.tmpl_section;
+ 	  break;
  	}
        if (prefix)
  	{
! 	  const char *name, *linkonce;
  	  char *string;
  
  	  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
  	  name = targetm.strip_name_encoding (name);
  	  
! 	  /* If we're using one_only, then there needs to be a .gnu.linkonce
!      	     prefix to the section name.  */
! 	  linkonce = one_only ? ".gnu.linkonce" : "";
!   
! 	  string = ACONCAT ((linkonce, prefix, ".", name, NULL));
  	  
! 	  DECL_SECTION_NAME (decl) = build_string (strlen (string), string);
  	  return;
  	}
      }
*** gcc/config/t-vxworks.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/config/t-vxworks	2008-08-12 11:29:11.000000000 +0200
***************
*** 25,27 ****
--- 25,31 ----
  LIBGCC2_INCLUDES="-I$(SYSTEM_HEADER_DIR)"
  
  EXTRA_MULTILIB_PARTS = 
+ 
+ vxworks.o: $(srcdir)/config/vxworks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+ 	$(TARGET_H) toplev.h output.h $(TM_H)
+ 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
*** gcc/config/vxworks.c.old	1970-01-01 01:00:00.000000000 +0100
--- gcc/config/vxworks.c	2008-08-12 11:57:37.000000000 +0200
***************
*** 0 ****
--- 1,157 ----
+ /* Common VxWorks target definitions for GNU compiler.
+    Copyright (C) 2007
+    Free Software Foundation, Inc.
+    Contributed by CodeSourcery, Inc.
+ 
+ This file is part of GCC.
+ 
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 2, or (at your option) any later
+ version.
+ 
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to the Free
+ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301, USA.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "coretypes.h"
+ #include "target.h"
+ #include "toplev.h"
+ #include "output.h"
+ #include "tm.h"
+ #include "tree.h"
+ 
+ /* Like default_named_section_asm_out_constructor, except that even
+    constructors with DEFAULT_INIT_PRIORITY must go in a numbered
+    section on VxWorks.  The VxWorks runtime uses a clever trick to get
+    the sentinel entry (-1) inserted at the beginning of the .ctors
+    segment.  This trick will not work if we ever generate any entries
+    in plain .ctors sections; we must always use .ctors.PRIORITY.  */
+ 
+ void
+ vxworks_asm_out_constructor (rtx symbol, int priority)
+ {
+   char section[16];
+ 
+   sprintf (section, ".ctors.%.5u",
+ 	   /* Invert the numbering so the linker puts us in the proper
+ 	      order; constructors are run from right to left, and the
+ 	      linker sorts in increasing order.  */
+ 	   MAX_INIT_PRIORITY - priority);
+   named_section_flags (section, SECTION_WRITE);
+   assemble_align (POINTER_SIZE);
+   assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);
+ }
+ 
+ /* See comment for vxworks_asm_out_constructor.  */
+ 
+ void
+ vxworks_asm_out_destructor (rtx symbol, int priority)
+ {
+   char section[16];
+   
+   sprintf (section, ".dtors.%.5u",
+ 	   /* Invert the numbering so the linker puts us in the proper
+ 	      order; constructors are run from right to left, and the
+ 	      linker sorts in increasing order.  */
+ 	   MAX_INIT_PRIORITY - priority);
+   named_section_flags (section, SECTION_WRITE);
+   assemble_align (POINTER_SIZE);
+   assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);
+ }
+ 
+ /* Return the list of FIELD_DECLs that make up an emulated TLS
+    variable's control object.  TYPE is the structure these are fields
+    of and *NAME will be filled in with the structure tag that should
+    be used.  */
+ 
+ static tree
+ vxworks_emutls_var_fields (tree type, tree *name)
+ {
+   tree field, next_field;
+   
+   *name = get_identifier ("__tls_var");
+   
+   field = build_decl (FIELD_DECL, get_identifier ("size"),
+ 		      unsigned_type_node);
+   DECL_CONTEXT (field) = type;
+   next_field = field;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("module_id"),
+ 		      unsigned_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+   next_field = field;
+ 
+   field = build_decl (FIELD_DECL, get_identifier ("offset"),
+ 		      unsigned_type_node);
+   DECL_CONTEXT (field) = type;
+   TREE_CHAIN (field) = next_field;
+ 
+   return field;
+ }
+ 
+ /* Return the CONSTRUCTOR to initialize an emulated TLS control
+    object.  VAR is the control object.  DECL is the TLS object itself
+    and TMPL_ADDR is the address (an ADDR_EXPR) of the initializer for
+    that object.  */
+ 
+ static tree
+ vxworks_emutls_var_init (tree var, tree decl, tree tmpl_addr)
+ {
+   VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 3);
+   constructor_elt *elt;
+   
+   tree type = TREE_TYPE (var);
+   tree field = TYPE_FIELDS (type);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   elt->index = field;
+   elt->value = fold_convert (TREE_TYPE (field), tmpl_addr);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = build_int_cst (TREE_TYPE (field), 0);
+   
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
+   
+   return build_constructor (type, v);
+ }
+ 
+ /* Do VxWorks-specific parts of OVERRIDE_OPTIONS.  */
+ 
+ void
+ vxworks_override_options (void)
+ {
+   /* We don't support __thread via target hooks.  */
+   targetm.have_tls = false;
+   targetm.emutls.get_address = "__builtin___tls_lookup";
+   targetm.emutls.register_common = NULL;
+   targetm.emutls.var_section = ".tls_vars";
+   targetm.emutls.tmpl_section = ".tls_data";
+   targetm.emutls.var_prefix = "__tls__";
+   targetm.emutls.tmpl_prefix = "";
+   targetm.emutls.var_fields = vxworks_emutls_var_fields;
+   targetm.emutls.var_init = vxworks_emutls_var_init;
+   targetm.emutls.var_align_fixed = true;
+   targetm.emutls.debug_form_tls_address = true;
+   
+   /* We can use .ctors/.dtors sections only in RTP mode.  */
+   targetm.have_ctors_dtors = TARGET_VXWORKS_RTP;
+ 
+   /* PIC is only supported for RTPs.  */
+   if (flag_pic && !TARGET_VXWORKS_RTP)
+     error ("PIC is only supported for RTPs");
+ }
*** gcc/config/vxworks.h.old	2005-11-19 19:38:31.000000000 +0100
--- gcc/config/vxworks.h	2008-08-12 11:31:28.000000000 +0200
***************
*** 79,97 ****
  #define	VXWORKS_STARTFILE_SPEC "%{mrtp:%{!shared:crt0.o%s}}"
  #define VXWORKS_ENDFILE_SPEC ""
  
! /* We can use .ctors/.dtors sections only in RTP mode.
!    Unfortunately this must be an integer constant expression;
!    fix up in override_options.  */
  #undef VXWORKS_OVERRIDE_OPTIONS
! #define VXWORKS_OVERRIDE_OPTIONS do { \
!   targetm.have_ctors_dtors = TARGET_VXWORKS_RTP; \
! } while (0)
  
! /* The VxWorks runtime uses a clever trick to get the sentinel entry
!    (-1) inserted at the beginning of the .ctors segment.  This trick
!    will not work if we ever generate any entries in plain .ctors
!    sections; we must always use .ctors.PRIORITY.  */
! #define ALWAYS_NUMBER_CTORS_SECTIONS 1
  
  /* The name of the symbol for the table of GOTs in a particular
     RTP.  */
--- 79,97 ----
  #define	VXWORKS_STARTFILE_SPEC "%{mrtp:%{!shared:crt0.o%s}}"
  #define VXWORKS_ENDFILE_SPEC ""
  
! /* Do VxWorks-specific parts of OVERRIDE_OPTIONS.  */
  #undef VXWORKS_OVERRIDE_OPTIONS
! #define VXWORKS_OVERRIDE_OPTIONS vxworks_override_options ()
! extern void vxworks_override_options (void);
  
! /* VxWorks requires special handling of constructors and destructors.
!    All VxWorks configurations must use these functions.  */
! #undef TARGET_ASM_CONSTRUCTOR
! #define TARGET_ASM_CONSTRUCTOR vxworks_asm_out_constructor
! #undef TARGET_ASM_DESTRUCTOR
! #define TARGET_ASM_DESTRUCTOR vxworks_asm_out_destructor
! extern void vxworks_asm_out_constructor (rtx symbol, int priority);
! extern void vxworks_asm_out_destructor (rtx symbol, int priority);
  
  /* The name of the symbol for the table of GOTs in a particular
     RTP.  */
*** gcc/config.gcc.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/config.gcc	2008-08-12 11:19:48.000000000 +0200
***************
*** 543,548 ****
--- 543,549 ----
    tm_file="${tm_file} elfos.h svr4.h"
    xm_defines=POSIX
    extra_options="${extra_options} vxworks.opt"
+   extra_objs=vxworks.o
    case ${enable_threads} in
      no) ;;
      "" | yes | vxworks) thread_file='vxworks' ;;
*** gcc/coretypes.h.old	2005-11-19 19:38:38.000000000 +0100
--- gcc/coretypes.h	2008-08-12 10:34:27.000000000 +0200
***************
*** 55,61 ****
     to it, so it's here.  */
  enum tls_model {
    TLS_MODEL_NONE,
!   TLS_MODEL_GLOBAL_DYNAMIC,
    TLS_MODEL_LOCAL_DYNAMIC,
    TLS_MODEL_INITIAL_EXEC,
    TLS_MODEL_LOCAL_EXEC
--- 55,63 ----
     to it, so it's here.  */
  enum tls_model {
    TLS_MODEL_NONE,
!   TLS_MODEL_EMULATED,
!   TLS_MODEL_REAL,
!   TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
    TLS_MODEL_LOCAL_DYNAMIC,
    TLS_MODEL_INITIAL_EXEC,
    TLS_MODEL_LOCAL_EXEC
*** gcc/doc/tm.texi.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/doc/tm.texi	2008-08-12 10:34:23.000000000 +0200
***************
*** 48,53 ****
--- 48,54 ----
  * Floating Point::      Handling floating point for cross-compilers.
  * Mode Switching::      Insertion of mode-switching instructions.
  * Target Attributes::   Defining target-specific uses of @code{__attribute__}.
+ * Emulated TLS::        Emulated TLS support.
  * MIPS Coprocessors::   MIPS coprocessor support and how to customize it.
  * PCH Target::          Validity checking for precompiled headers.
  * C++ ABI::             Controlling C++ ABI changes.
***************
*** 8629,8634 ****
--- 8630,8713 ----
  target specific attribute attached to it, it will not be inlined.
  @end deftypefn
  
+ @node Emulated TLS
+ @section Emulating TLS
+ @cindex Emulated TLS
+ 
+ For targets whose psABI does not provide Thread Local Storage via
+ specific relocations and instruction sequences, an emulation layer is
+ used.  A set of target hooks allows this emulation layer to be
+ configured for the requirements of a particular target.  For instance
+ the psABI may infact specify TLS support in terms of an emulation
+ layer.
+ 
+ The emulation layer works by creating a control object for every TLS
+ object.  To access the TLS object, a lookup function is provided
+ which, when given the address of the control object, will return the
+ address of the current thread's instance of the TLS object.
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_GET_ADDRESS
+ Contains the name of the helper function that uses a TLS control
+ object to locate a TLS instance.  The default causes libgcc's
+ emulated TLS helper function to be used.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_REGISTER_COMMON
+ Contains the name of the helper function that should be used at
+ program startup to register TLS objects that are implicitly
+ initialized to zero.  If this is @code{NULL}, all TLS objects will
+ have explicit initializers.  The default causes libgcc's emulated TLS
+ registration function to be used.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_SECTION
+ Contains the name of the section in which TLS control variables should
+ be placed.  The default of @code{NULL} allows these to be placed in
+ any section.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_SECTION
+ Contains the name of the section in which TLS initializers should be
+ placed.  The default of @code{NULL} allows these to be placed in any
+ section.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_PREFIX
+ Contains the prefix to be prepended to TLS control variable names.
+ The default of @code{NULL} uses a target-specific prefix.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_PREFIX
+ Contains the prefix to be prepended to TLS initializer objects.  The
+ default of @code{NULL} uses a target-specific prefix.
+ @end deftypevr
+ 
+ @deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_FIELDS (tree @var{type}, tree *@var{name})
+ Specifies a function that generates the FIELD_DECLs for a TLS control
+ object type.  @var{type} is the RECORD_TYPE the fields are for and
+ @var{name} should be filled with the structure tag, if the default of
+ @code{__emutls_object} is unsuitable.  The default creates a type suitable
+ for libgcc's emulated TLS function.
+ @end deftypefn
+ 
+ @deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_INIT (tree @var{var}, tree @var{decl}, tree @var{tmpl_addr})
+ Specifies a function that generates the CONSTRUCTOR to initialize a
+ TLS control object.  @var{var} is the TLS control object, @var{decl}
+ is the TLS object and @var{tmpl_addr} is the address of the
+ initializer.  The default initializes libgcc's emulated TLS control object.
+ @end deftypefn
+ 
+ @deftypevr {Target Hook} {bool} TARGET_EMUTLS_VAR_ALIGN_FIXED
+ Specifies whether the alignment of TLS control variable objects is
+ fixed and should not be increased as some backends may do to optimize
+ single objects.  The default is false.
+ @end deftypevr
+ 
+ @deftypevr {Target Hook} {bool} TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
+ Specifies whether a DWARF @code{DW_OP_form_tls_address} location descriptor
+ may be used to describe emulated TLS control objects.
+ @end deftypevr
+ 
  @node MIPS Coprocessors
  @section Defining coprocessor specifics for MIPS targets.
  @cindex MIPS coprocessor-definition macros
*** gcc/dwarf2.h.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/dwarf2.h	2008-08-12 11:05:09.000000000 +0200
***************
*** 521,526 ****
--- 521,527 ----
      DW_OP_call2 = 0x98,
      DW_OP_call4 = 0x99,
      DW_OP_call_ref = 0x9a,
+     DW_OP_form_tls_address = 0x9b,
      /* GNU extensions.  */
      DW_OP_GNU_push_tls_address = 0xe0,
      /* HP extensions.  */
*** gcc/dwarf2out.c.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/dwarf2out.c	2008-08-12 10:34:27.000000000 +0200
***************
*** 9104,9118 ****
        if (DECL_THREAD_LOCAL_P (loc))
  	{
  	  rtx rtl;
  
! 	  /* If this is not defined, we have no way to emit the data.  */
! 	  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)
  	    return 0;
  
! 	  /* The way DW_OP_GNU_push_tls_address is specified, we can only
! 	     look up addresses of objects in the current module.  */
  	  if (DECL_EXTERNAL (loc))
  	    return 0;
  
  	  rtl = rtl_for_decl_location (loc);
  	  if (rtl == NULL_RTX)
--- 9104,9135 ----
        if (DECL_THREAD_LOCAL_P (loc))
  	{
  	  rtx rtl;
+ 	  unsigned first_op;
+ 	  unsigned second_op;
  
! 	  if (targetm.have_tls)
! 	    {
! 	      /* If this is not defined, we have no way to emit the
! 	         data.  */
! 	      if (!targetm.asm_out.output_dwarf_dtprel)
  		return 0;
  
! 	       /* The way DW_OP_GNU_push_tls_address is specified, we
! 	     	  can only look up addresses of objects in the current
! 	     	  module.  */
  	      if (DECL_EXTERNAL (loc))
  		return 0;
+ 	      first_op = INTERNAL_DW_OP_tls_addr;
+ 	      second_op = DW_OP_GNU_push_tls_address;
+ 	    }
+ 	  else
+ 	    {
+ 	      if (!targetm.emutls.debug_form_tls_address)
+ 		return 0;
+ 	      loc = emutls_decl (loc);
+ 	      first_op = DW_OP_addr;
+ 	      second_op = DW_OP_form_tls_address;
+ 	    }
  	  
  	  rtl = rtl_for_decl_location (loc);
  	  if (rtl == NULL_RTX)
***************
*** 9124,9134 ****
  	  if (! CONSTANT_P (rtl))
  	    return 0;
  
! 	  ret = new_loc_descr (INTERNAL_DW_OP_tls_addr, 0, 0);
  	  ret->dw_loc_oprnd1.val_class = dw_val_class_addr;
  	  ret->dw_loc_oprnd1.v.val_addr = rtl;
  
! 	  ret1 = new_loc_descr (DW_OP_GNU_push_tls_address, 0, 0);
  	  add_loc_descr (&ret, ret1);
  
  	  have_address = 1;
--- 9141,9151 ----
  	  if (! CONSTANT_P (rtl))
  	    return 0;
  
! 	  ret = new_loc_descr (first_op, 0, 0);
  	  ret->dw_loc_oprnd1.val_class = dw_val_class_addr;
  	  ret->dw_loc_oprnd1.v.val_addr = rtl;
  	  
! 	  ret1 = new_loc_descr (second_op, 0, 0);
  	  add_loc_descr (&ret, ret1);
  
  	  have_address = 1;
*** gcc/output.h.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/output.h	2008-08-12 11:38:25.000000000 +0200
***************
*** 552,558 ****
  
    SECCAT_BSS,
    SECCAT_SBSS,
!   SECCAT_TBSS
  };
  
  
--- 552,561 ----
  
    SECCAT_BSS,
    SECCAT_SBSS,
!   SECCAT_TBSS,
! 
!   SECCAT_EMUTLS_VAR,
!   SECCAT_EMUTLS_TMPL
  };
  
  
*** gcc/target-def.h.old	2008-08-12 10:31:31.000000000 +0200
--- gcc/target-def.h	2008-08-12 10:58:32.000000000 +0200
***************
*** 547,552 ****
--- 547,607 ----
      TARGET_CXX_ADJUST_CLASS_AT_DEFINITION	\
    }
  
+ /* EMUTLS specific */
+ #ifndef TARGET_EMUTLS_GET_ADDRESS
+ #define TARGET_EMUTLS_GET_ADDRESS "__builtin___emutls_get_address"
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_REGISTER_COMMON
+ #define TARGET_EMUTLS_REGISTER_COMMON "__builtin___emutls_register_common"
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_SECTION
+ #define TARGET_EMUTLS_VAR_SECTION NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_TMPL_SECTION
+ #define TARGET_EMUTLS_TMPL_SECTION NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_PREFIX
+ #define TARGET_EMUTLS_VAR_PREFIX NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_TMPL_PREFIX
+ #define TARGET_EMUTLS_TMPL_PREFIX NULL
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_FIELDS
+ #define TARGET_EMUTLS_VAR_FIELDS default_emutls_var_fields
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_INIT
+ #define TARGET_EMUTLS_VAR_INIT default_emutls_var_init
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_VAR_ALIGN_FIXED
+ #define TARGET_EMUTLS_VAR_ALIGN_FIXED false
+ #endif
+ 
+ #ifndef TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS
+ #define TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS false
+ #endif
+ 
+ #define TARGET_EMUTLS				\
+   {						\
+     TARGET_EMUTLS_GET_ADDRESS,  		\
+     TARGET_EMUTLS_REGISTER_COMMON,  		\
+     TARGET_EMUTLS_VAR_SECTION,  		\
+     TARGET_EMUTLS_TMPL_SECTION,  		\
+     TARGET_EMUTLS_VAR_PREFIX,  			\
+     TARGET_EMUTLS_TMPL_PREFIX,  		\
+     TARGET_EMUTLS_VAR_FIELDS,			\
+     TARGET_EMUTLS_VAR_INIT,			\
+     TARGET_EMUTLS_VAR_ALIGN_FIXED,		\
+     TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS	\
+   }
+ 
  /* The whole shebang.  */
  #define TARGET_INITIALIZER			\
  {						\
***************
*** 618,623 ****
--- 673,679 ----
    TARGET_INVALID_UNARY_OP,			\
    TARGET_INVALID_BINARY_OP,			\
    TARGET_CXX,					\
+   TARGET_EMUTLS,				\
    TARGET_UNWIND_TABLES_DEFAULT,			\
    TARGET_HAVE_NAMED_SECTIONS,			\
    TARGET_HAVE_CTORS_DTORS,			\
*** gcc/target.h.old	2008-08-12 10:31:31.000000000 +0200
--- gcc/target.h	2008-08-12 10:36:44.000000000 +0200
***************
*** 684,689 ****
--- 684,717 ----
      void (*adjust_class_at_definition) (tree type);
    } cxx;
  
+   /* Functions and data for emulated TLS support.  */
+   struct emutls {
+     /* Name of the address and common functions.  */
+     const char *get_address;
+     const char *register_common;
+ 
+     /* Prefixes for proxy variable and template.  */
+     const char *var_section;
+     const char *tmpl_section;
+ 
+     /* Prefixes for proxy variable and template.  */
+     const char *var_prefix;
+     const char *tmpl_prefix;
+ 
+     /* Function to generate field definitions of the proxy variable.  */
+     tree (*var_fields) (tree, tree *);
+ 
+     /* Function to initialize a proxy variable.  */
+     tree (*var_init) (tree, tree, tree);
+ 
+     /* Whether we are allowed to alter the usual alignment of the
+        proxy variable.  */
+     bool var_align_fixed;
+ 
+     /* Whether we can emit debug information for TLS vars.  */
+     bool debug_form_tls_address;
+   } emutls;
+ 
    /* True if unwinding tables should be generated by default.  */
    bool unwind_tables_default;
  
*** gcc/targhooks.h.old	2006-01-12 03:09:34.000000000 +0100
--- gcc/targhooks.h	2008-08-12 10:35:22.000000000 +0200
***************
*** 70,72 ****
--- 70,74 ----
  extern bool hook_bool_rtx_commutative_p (rtx, int);
  extern rtx default_function_value (tree, tree, bool);
  extern rtx default_internal_arg_pointer (void);
+ extern tree default_emutls_var_fields (tree, tree *);
+ extern tree default_emutls_var_init (tree, tree, tree);
*** gcc/tree.h.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/tree.h	2008-08-12 10:34:23.000000000 +0200
***************
*** 2630,2636 ****
  /* In a VAR_DECL, nonzero if the data should be allocated from
     thread-local storage.  */
  #define DECL_THREAD_LOCAL_P(NODE) \
!   (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model != TLS_MODEL_NONE)
  
  struct tree_var_decl GTY(())
  {
--- 2630,2636 ----
  /* In a VAR_DECL, nonzero if the data should be allocated from
     thread-local storage.  */
  #define DECL_THREAD_LOCAL_P(NODE) \
!   (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL)
  
  struct tree_var_decl GTY(())
  {
*** gcc/varasm.c.old	2008-08-12 10:31:32.000000000 +0200
--- gcc/varasm.c	2008-08-12 11:51:25.000000000 +0200
***************
*** 49,54 ****
--- 49,55 ----
  #include "tm_p.h"
  #include "debug.h"
  #include "target.h"
+ #include "targhooks.h"
  #include "tree-mudflap.h"
  #include "cgraph.h"
  #include "cfglayout.h"
***************
*** 175,234 ****
  static GTY ((if_marked ("tree_map_marked_p"), param_is (struct tree_map)))
       htab_t emutls_htab;
  static GTY (()) tree emutls_object_type;
! 
! #ifndef NO_DOT_IN_LABEL
! # define EMUTLS_VAR_PREFIX	"__emutls_v."
! # define EMUTLS_TMPL_PREFIX	"__emutls_t."
! #elif !defined NO_DOLLAR_IN_LABEL
! # define EMUTLS_VAR_PREFIX	"__emutls_v$"
! # define EMUTLS_TMPL_PREFIX	"__emutls_t$"
  #else
! # define EMUTLS_VAR_PREFIX	"__emutls_v_"
! # define EMUTLS_TMPL_PREFIX	"__emutls_t_"
  #endif
  
! /* Create an identifier for the struct __emutls_object, given an identifier
!    of the DECL_ASSEMBLY_NAME of the original object.  */
  
  static tree
! get_emutls_object_name (tree name)
  {
!   char *toname = alloca (strlen (IDENTIFIER_POINTER (name))
! 			 + sizeof (EMUTLS_VAR_PREFIX));
!   strcpy (toname, EMUTLS_VAR_PREFIX);
!   strcpy (toname + sizeof (EMUTLS_VAR_PREFIX) - 1, IDENTIFIER_POINTER (name));
  
    return get_identifier (toname);
  }
  
! /* Create the structure for struct __emutls_object.  This should match the
!    structure at the top of emutls.c, modulo the union there.  */
  
  static tree
! get_emutls_object_type (void)
  {
!   tree type, type_name, field, next_field, word_type_node;
! 
!   type = emutls_object_type;
!   if (type)
!     return type;
  
!   emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);
!   type_name = get_identifier ("__emutls_object");
!   type_name = build_decl (TYPE_DECL, type_name, type);
!   TYPE_NAME (type) = type_name;
  
    field = build_decl (FIELD_DECL, get_identifier ("__templ"), ptr_type_node);
    DECL_CONTEXT (field) = type;
    next_field = field;
  
!   field = build_decl (FIELD_DECL, get_identifier ("__offset"), ptr_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
  
    word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);
!   field = build_decl (FIELD_DECL, get_identifier ("__align"), word_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
--- 176,240 ----
  static GTY ((if_marked ("tree_map_marked_p"), param_is (struct tree_map)))
       htab_t emutls_htab;
  static GTY (()) tree emutls_object_type;
! /* Emulated TLS objects have the TLS model TLS_MODEL_EMULATED.  This
!    macro can be used on them to distinguish the control variable from
!    the initialization template.  */
! #define DECL_EMUTLS_VAR_P(D)  (TREE_TYPE (D) == emutls_object_type)
! 
! #if !defined (NO_DOT_IN_LABEL)
! # define EMUTLS_SEPARATOR	"."
! #elif !defined (NO_DOLLAR_IN_LABEL)
! # define EMUTLS_SEPARATOR	"$"
  #else
! # define EMUTLS_SEPARATOR	"_"
  #endif
  
! /* Create an IDENTIFIER_NODE by prefixing PREFIX to the
!    IDENTIFIER_NODE NAME's name.  */
  
  static tree
! prefix_name (const char *prefix, tree name)
  {
!   unsigned plen = strlen (prefix);
!   unsigned nlen = strlen (IDENTIFIER_POINTER (name));
!   char *toname = alloca (plen + nlen + 1);
! 
!   memcpy (toname, prefix, plen);
!   memcpy (toname + plen, IDENTIFIER_POINTER (name), nlen + 1);
  
    return get_identifier (toname);
  }
  
! /* Create an identifier for the struct __emutls_object, given an identifier
!    of the DECL_ASSEMBLY_NAME of the original object.  */
  
  static tree
! get_emutls_object_name (tree name)
  {
!   const char *prefix = (targetm.emutls.var_prefix
! 			? targetm.emutls.var_prefix
! 			: "__emutls_v" EMUTLS_SEPARATOR);
!   return prefix_name (prefix, name);
! }
  
! tree
! default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)
! {
!   tree word_type_node, field, next_field;
  
    field = build_decl (FIELD_DECL, get_identifier ("__templ"), ptr_type_node);
    DECL_CONTEXT (field) = type;
    next_field = field;
  
!   field = build_decl (FIELD_DECL, get_identifier ("__offset"),
! 		      ptr_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
  
    word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);
!   field = build_decl (FIELD_DECL, get_identifier ("__align"),
! 		      word_type_node);
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
    next_field = field;
***************
*** 237,242 ****
--- 243,270 ----
    DECL_CONTEXT (field) = type;
    TREE_CHAIN (field) = next_field;
  
+   return field;
+ }
+ 
+ /* Create the structure for struct __emutls_object.  This should match the
+    structure at the top of emutls.c, modulo the union there.  */
+ 
+ static tree
+ get_emutls_object_type (void)
+ {
+   tree type, type_name, field;
+ 
+   type = emutls_object_type;
+   if (type)
+     return type;
+ 
+   emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);
+   type_name = NULL;
+   field = targetm.emutls.var_fields (type, &type_name);
+   if (!type_name)
+     type_name = get_identifier ("__emutls_object");
+   type_name = build_decl (TYPE_DECL, type_name, type);
+   TYPE_NAME (type) = type_name;
    TYPE_FIELDS (type) = field;
    layout_type (type);
  
***************
*** 250,275 ****
  get_emutls_init_templ_addr (tree decl)
  {
    tree name, to;
-   char *toname;
  
!   if (!DECL_INITIAL (decl))
      return null_pointer_node;
  
    name = DECL_ASSEMBLER_NAME (decl);
!   toname = alloca (strlen (IDENTIFIER_POINTER (name))
! 		   + sizeof (EMUTLS_TMPL_PREFIX));
!   strcpy (toname, EMUTLS_TMPL_PREFIX);
!   strcpy (toname + sizeof (EMUTLS_TMPL_PREFIX) - 1, IDENTIFIER_POINTER (name));
!   name = get_identifier (toname);
  
    to = build_decl (VAR_DECL, name, TREE_TYPE (decl));
    SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
! 
    DECL_ARTIFICIAL (to) = 1;
    TREE_USED (to) = TREE_USED (decl);
    TREE_READONLY (to) = 1;
    DECL_IGNORED_P (to) = 1;
    DECL_CONTEXT (to) = DECL_CONTEXT (decl);
    DECL_WEAK (to) = DECL_WEAK (decl);
    if (DECL_ONE_ONLY (decl))
      {
--- 278,307 ----
  get_emutls_init_templ_addr (tree decl)
  {
    tree name, to;
  
!   if (targetm.emutls.register_common && !DECL_INITIAL (decl)
!       && !DECL_SECTION_NAME (decl))
      return null_pointer_node;
  
    name = DECL_ASSEMBLER_NAME (decl);
!   if (!targetm.emutls.tmpl_prefix || targetm.emutls.tmpl_prefix[0])
!     {
!       const char *prefix = (targetm.emutls.tmpl_prefix
! 			    ? targetm.emutls.tmpl_prefix
! 			    : "__emutls_t" EMUTLS_SEPARATOR);
!       name = prefix_name (prefix, name);
!     }
  
    to = build_decl (VAR_DECL, name, TREE_TYPE (decl));
    SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
!   DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;
    DECL_ARTIFICIAL (to) = 1;
    TREE_USED (to) = TREE_USED (decl);
    TREE_READONLY (to) = 1;
    DECL_IGNORED_P (to) = 1;
    DECL_CONTEXT (to) = DECL_CONTEXT (decl);
+   DECL_SECTION_NAME (to) = DECL_SECTION_NAME (decl);
+ 
    DECL_WEAK (to) = DECL_WEAK (decl);
    if (DECL_ONE_ONLY (decl))
      {
***************
*** 329,342 ****
        h->to = to;
        *(struct tree_map **) loc = h;
  
        DECL_ARTIFICIAL (to) = 1;
        DECL_IGNORED_P (to) = 1;
        TREE_READONLY (to) = 0;
- 
        SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
        if (DECL_ONE_ONLY (decl))
  	make_decl_one_only (to);
        DECL_CONTEXT (to) = DECL_CONTEXT (decl);
      }
  
    /* Note that these fields may need to be updated from time to time from
--- 361,378 ----
        h->to = to;
        *(struct tree_map **) loc = h;
  
+       DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;
        DECL_ARTIFICIAL (to) = 1;
        DECL_IGNORED_P (to) = 1;
        TREE_READONLY (to) = 0;
        SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));
        if (DECL_ONE_ONLY (decl))
  	make_decl_one_only (to);
        DECL_CONTEXT (to) = DECL_CONTEXT (decl);
+       if (targetm.emutls.var_align_fixed)
+ 	/* If we're not allowed to change the proxy object's
+ 	   alignment, pretend it's been set by the user.  */
+ 	DECL_USER_ALIGN (to) = 1;
      }
  
    /* Note that these fields may need to be updated from time to time from
***************
*** 394,399 ****
--- 430,437 ----
  void
  emutls_finish (void)
  {
+   if (!targetm.emutls.register_common)
+     {
    tree body = NULL_TREE;
  
    if (emutls_htab == NULL)
***************
*** 404,412 ****
      return;
  
    cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);
  }
  
- 
  static void
  initialize_cold_section_name (void)
  {
--- 442,450 ----
  	return;
  
        cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);
+     }
  }
  
  static void
  initialize_cold_section_name (void)
  {
***************
*** 1822,1827 ****
--- 1860,1899 ----
    return true;
  }
  
+ /* Initialize emulated tls object TO, which refers to TLS variable
+    DECL and is initialized by PROXY.  */
+ 
+ tree
+ default_emutls_var_init (tree to, tree decl, tree proxy)
+ {
+   VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);
+   constructor_elt *elt;
+   tree type = TREE_TYPE (to);
+   tree field = TYPE_FIELDS (type);
+ 
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   elt->index = field;
+   elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
+ 
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = build_int_cst (TREE_TYPE (field),
+ 			      DECL_ALIGN_UNIT (decl));
+ 
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = null_pointer_node;
+ 
+   elt = VEC_quick_push (constructor_elt, v, NULL);
+   field = TREE_CHAIN (field);
+   elt->index = field;
+   elt->value = proxy;
+ 
+   return build_constructor (type, v);
+ }
+ 
  /* Assemble everything that is needed for a variable or function declaration.
     Not used for automatic variables, and not used for function definitions.
     Should not be called for variables of incomplete structure type.
***************
*** 1856,1889 ****
  	  && (! DECL_COMMON (to)
  	      || (DECL_INITIAL (decl)
  		  && DECL_INITIAL (decl) != error_mark_node)))
! 	{
! 	  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);
! 	  constructor_elt *elt;
! 	  tree type = TREE_TYPE (to);
! 	  tree field = TYPE_FIELDS (type);
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  elt->index = field;
! 	  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  field = TREE_CHAIN (field);
! 	  elt->index = field;
! 	  elt->value = build_int_cst (TREE_TYPE (field),
! 				      DECL_ALIGN_UNIT (decl));
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  field = TREE_CHAIN (field);
! 	  elt->index = field;
! 	  elt->value = null_pointer_node;
! 
! 	  elt = VEC_quick_push (constructor_elt, v, NULL);
! 	  field = TREE_CHAIN (field);
! 	  elt->index = field;
! 	  elt->value = get_emutls_init_templ_addr (decl);
! 
! 	  DECL_INITIAL (to) = build_constructor (type, v);
! 	}
  
        decl = to;
      }
--- 1928,1935 ----
  	  && (! DECL_COMMON (to)
  	      || (DECL_INITIAL (decl)
  		  && DECL_INITIAL (decl) != error_mark_node)))
! 	  DECL_INITIAL (to) = targetm.emutls.var_init
! 	    (to, decl, get_emutls_init_templ_addr (decl));
  
        decl = to;
      }
***************
*** 2016,2021 ****
--- 2062,2072 ----
        if (DECL_COMMON (decl))
  	sorry ("thread-local COMMON data not implemented");
      }
+   /* This cannot be common bss for an emulated TLS object without a
+      register_common hook.  */
+   else if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED
+ 	   && !targetm.emutls.register_common)
+     ;
    else if (DECL_INITIAL (decl) == 0
  	   || DECL_INITIAL (decl) == error_mark_node
  	   || (flag_zero_initialized_in_bss
***************
*** 5817,5827 ****
      ret = SECCAT_RODATA;
  
    /* There are no read-only thread-local sections.  */
!   if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))
      {
        /* Note that this would be *just* SECCAT_BSS, except that there's
  	 no concept of a read-only thread-local-data section.  */
!       if (ret == SECCAT_BSS
  	  || (flag_zero_initialized_in_bss
  	      && initializer_zerop (DECL_INITIAL (decl))))
  	ret = SECCAT_TBSS;
--- 5868,5891 ----
      ret = SECCAT_RODATA;
  
    /* There are no read-only thread-local sections.  */
!   if (TREE_CODE (decl) == VAR_DECL && DECL_TLS_MODEL (decl))
!     {
!       if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED)
! 	{
! 	  if (DECL_EMUTLS_VAR_P (decl))
! 	    {
! 	      if (targetm.emutls.var_section)
! 		ret = SECCAT_EMUTLS_VAR;
! 	    }
! 	  else
  	    {
+ 	      if (targetm.emutls.tmpl_prefix)
+ 		ret = SECCAT_EMUTLS_TMPL;
+ 	    }
+ 	}
        /* Note that this would be *just* SECCAT_BSS, except that there's
  	 no concept of a read-only thread-local-data section.  */
!       else if (ret == SECCAT_BSS
  	       || (flag_zero_initialized_in_bss
  		   && initializer_zerop (DECL_INITIAL (decl))))
  	ret = SECCAT_TBSS;
***************
*** 5936,5941 ****
--- 6000,6011 ----
      case SECCAT_TBSS:
        sname = ".tbss";
        break;
+     case SECCAT_EMUTLS_VAR:
+       sname = targetm.emutls.var_section;
+       break;
+     case SECCAT_EMUTLS_TMPL:
+       sname = targetm.emutls.tmpl_section;
+       break;
      default:
        gcc_unreachable ();
      }
***************
*** 5959,6027 ****
  {
    /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
    bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;
!   const char *prefix, *name;
!   size_t nlen, plen;
    char *string;
  
    switch (categorize_decl_for_section (decl, reloc, shlib))
      {
      case SECCAT_TEXT:
!       prefix = one_only ? ".gnu.linkonce.t." : ".text.";
        break;
      case SECCAT_RODATA:
      case SECCAT_RODATA_MERGE_STR:
      case SECCAT_RODATA_MERGE_STR_INIT:
      case SECCAT_RODATA_MERGE_CONST:
!       prefix = one_only ? ".gnu.linkonce.r." : ".rodata.";
        break;
      case SECCAT_SRODATA:
!       prefix = one_only ? ".gnu.linkonce.s2." : ".sdata2.";
        break;
      case SECCAT_DATA:
!       prefix = one_only ? ".gnu.linkonce.d." : ".data.";
        break;
      case SECCAT_DATA_REL:
!       prefix = one_only ? ".gnu.linkonce.d.rel." : ".data.rel.";
        break;
      case SECCAT_DATA_REL_LOCAL:
!       prefix = one_only ? ".gnu.linkonce.d.rel.local." : ".data.rel.local.";
        break;
      case SECCAT_DATA_REL_RO:
!       prefix = one_only ? ".gnu.linkonce.d.rel.ro." : ".data.rel.ro.";
        break;
      case SECCAT_DATA_REL_RO_LOCAL:
!       prefix = one_only ? ".gnu.linkonce.d.rel.ro.local."
! 	       : ".data.rel.ro.local.";
        break;
      case SECCAT_SDATA:
!       prefix = one_only ? ".gnu.linkonce.s." : ".sdata.";
        break;
      case SECCAT_BSS:
!       prefix = one_only ? ".gnu.linkonce.b." : ".bss.";
        break;
      case SECCAT_SBSS:
!       prefix = one_only ? ".gnu.linkonce.sb." : ".sbss.";
        break;
      case SECCAT_TDATA:
!       prefix = one_only ? ".gnu.linkonce.td." : ".tdata.";
        break;
      case SECCAT_TBSS:
!       prefix = one_only ? ".gnu.linkonce.tb." : ".tbss.";
        break;
      default:
        gcc_unreachable ();
      }
-   plen = strlen (prefix);
  
    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
    name = targetm.strip_name_encoding (name);
-   nlen = strlen (name);
  
!   string = alloca (nlen + plen + 1);
!   memcpy (string, prefix, plen);
!   memcpy (string + plen, name, nlen + 1);
  
!   DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
  }
  
  void
--- 6029,6101 ----
  {
    /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
    bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;
!   const char *prefix, *name, *linkonce;
    char *string;
  
    switch (categorize_decl_for_section (decl, reloc, shlib))
      {
      case SECCAT_TEXT:
!       prefix = one_only ? ".t" : ".text";
        break;
      case SECCAT_RODATA:
      case SECCAT_RODATA_MERGE_STR:
      case SECCAT_RODATA_MERGE_STR_INIT:
      case SECCAT_RODATA_MERGE_CONST:
!       prefix = one_only ? ".r" : ".rodata";
        break;
      case SECCAT_SRODATA:
!       prefix = one_only ? ".s2" : ".sdata2";
        break;
      case SECCAT_DATA:
!       prefix = one_only ? ".d" : ".data";
        break;
      case SECCAT_DATA_REL:
!       prefix = one_only ? ".d.rel" : ".data.rel";
        break;
      case SECCAT_DATA_REL_LOCAL:
!       prefix = one_only ? ".d.rel.local" : ".data.rel.local";
        break;
      case SECCAT_DATA_REL_RO:
!       prefix = one_only ? ".d.rel.ro" : ".data.rel.ro";
        break;
      case SECCAT_DATA_REL_RO_LOCAL:
!       prefix = one_only ? ".d.rel.ro.local" : ".data.rel.ro.local";
        break;
      case SECCAT_SDATA:
!       prefix = one_only ? ".s" : ".sdata";
        break;
      case SECCAT_BSS:
!       prefix = one_only ? ".b" : ".bss";
        break;
      case SECCAT_SBSS:
!       prefix = one_only ? ".sb" : ".sbss";
        break;
      case SECCAT_TDATA:
!       prefix = one_only ? ".td" : ".tdata";
        break;
      case SECCAT_TBSS:
!       prefix = one_only ? ".tb" : ".tbss";
!       break;
!     case SECCAT_EMUTLS_VAR:
!       prefix = targetm.emutls.var_section;
!       break;
!     case SECCAT_EMUTLS_TMPL:
!       prefix = targetm.emutls.tmpl_section;
        break;
      default:
        gcc_unreachable ();
      }
  
    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
    name = targetm.strip_name_encoding (name);
  
!   /* If we're using one_only, then there needs to be a .gnu.linkonce
!      prefix to the section name.  */
!   linkonce = one_only ? ".gnu.linkonce" : "";
! 
!   string = ACONCAT ((linkonce, prefix, ".", name, NULL));
  
!   DECL_SECTION_NAME (decl) = build_string (strlen (string), string);
  }
  
  void
*** gcc/final.c.0	2008-09-03 19:21:18.000000000 +0200
--- gcc/final.c	2008-09-03 23:46:28.000000000 +0200
*************** output_alternate_entry_point (FILE *file
*** 1667,1672 ****
--- 1667,1695 ----
      }
  }
  
+ /* Return true if INSN is a line note that is not the final one.  */
+ 
+ static bool
+ non_final_line_note (rtx insn)
+ {
+   if (!NOTE_P (insn))
+     return false;
+ 
+   if (NOTE_LINE_NUMBER (insn) <= 0)
+     return false;
+ 
+ #ifdef USE_MAPPED_LOCATION
+   if (NOTE_SOURCE_LOCATION (insn) == cfun->function_end_locus)
+     return false;
+ #else
+   if (NOTE_LINE_NUMBER (insn) == cfun->function_end_locus.line
+       && !strcmp (NOTE_SOURCE_FILE (insn), cfun->function_end_locus.file))
+     return false;
+ #endif
+ 
+   return true;
+ }
+ 
  /* The final scan for one insn, INSN.
     Args are same as in `final', except that INSN
     is the insn being scanned.
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1754,1760 ****
  	  if ((*seen & (SEEN_EMITTED | SEEN_BB)) == SEEN_BB)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_BB;
--- 1777,1785 ----
  	  if ((*seen & (SEEN_EMITTED | SEEN_BB)) == SEEN_BB)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      /* Do not force a source line if there is already one.  */
! 	      if (!non_final_line_note (NEXT_INSN (insn)))
! 		force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_BB;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1778,1784 ****
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
--- 1803,1811 ----
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      /* Do not force a source line if there is already one.  */
! 	      if (!non_final_line_note (NEXT_INSN (insn)))
! 		force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1796,1802 ****
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
--- 1823,1831 ----
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
  	      *seen |= SEEN_EMITTED;
! 	      /* Do not force a source line if there is already one.  */
! 	      if (!non_final_line_note (NEXT_INSN (insn)))
! 		force_source_line = true;
  	    }
  	  else
  	    *seen |= SEEN_NOTE;
*** config.sub.old	Fri Sep 12 13:23:16 2008
--- config.sub	Wed Sep 10 15:49:38 2008
*************** case $os in
*** 212,217 ****
--- 212,220 ----
  	-isc*)
  		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
+ 	-lynx*5)
+ 		os=-lynxos5
+ 		;;
  	-lynx*)
  		os=-lynxos
  		;;
*** gcc/varasm.c.0	2008-09-17 10:19:01.000000000 +0200
--- gcc/varasm.c	2008-09-17 22:34:54.000000000 +0200
*************** initializer_constant_valid_p (tree value
*** 4091,4110 ****
  	return op0;
        }
  
-     case VIEW_CONVERT_EXPR:
      case NON_LVALUE_EXPR:
        return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
  
      case CONVERT_EXPR:
      case NOP_EXPR:
        {
! 	tree src;
! 	tree src_type;
! 	tree dest_type;
! 
! 	src = TREE_OPERAND (value, 0);
! 	src_type = TREE_TYPE (src);
! 	dest_type = TREE_TYPE (value);
  
  	/* Allow conversions between pointer types, floating-point
  	   types, and offset types.  */
--- 4091,4127 ----
  	return op0;
        }
  
      case NON_LVALUE_EXPR:
        return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
  
+     case VIEW_CONVERT_EXPR:
+       {
+ 	tree src = TREE_OPERAND (value, 0);
+ 	tree src_type = TREE_TYPE (src);
+ 	tree dest_type = TREE_TYPE (value);
+ 
+ 	/* Allow view-conversions from aggregate to non-aggregate type only
+ 	   if the bit pattern is fully preserved afterwards; otherwise, the
+ 	   RTL expander won't be able to apply a subsequent transformation
+ 	   to the underlying constructor.  */
+ 	if (AGGREGATE_TYPE_P (src_type) && !AGGREGATE_TYPE_P (dest_type))
+ 	  {
+ 	    if (TYPE_MODE (endtype) == TYPE_MODE (dest_type))
+ 	      return initializer_constant_valid_p (src, endtype);
+ 	    else
+ 	      return NULL_TREE;
+ 	  }
+ 
+ 	/* Allow all other kinds of view-conversion.  */
+ 	return initializer_constant_valid_p (src, endtype);
+       }
+ 
      case CONVERT_EXPR:
      case NOP_EXPR:
        {
! 	tree src = TREE_OPERAND (value, 0);
! 	tree src_type = TREE_TYPE (src);
! 	tree dest_type = TREE_TYPE (value);
  
  	/* Allow conversions between pointer types, floating-point
  	   types, and offset types.  */
*** gcc/tree-inline.c.0	2008-09-17 12:39:30.000000000 +0200
--- gcc/tree-inline.c	2008-09-17 12:40:15.000000000 +0200
*************** estimate_num_insns_1 (tree *tp, int *wal
*** 1885,1892 ****
      case POSTDECREMENT_EXPR:
      case POSTINCREMENT_EXPR:
  
-     case SWITCH_EXPR:
- 
      case ASM_EXPR:
  
      case REALIGN_LOAD_EXPR:
--- 1885,1890 ----
*************** estimate_num_insns_1 (tree *tp, int *wal
*** 1899,1904 ****
--- 1887,1901 ----
        *count += 1;
        break;
  
+     case SWITCH_EXPR:
+       /* Take into account cost of the switch + guess 2 conditional jumps for
+          each case label.  
+ 
+ 	 TODO: once the switch expansion logic is sufficiently separated, we can
+ 	 do better job on estimating cost of the switch.  */
+       *count += TREE_VEC_LENGTH (SWITCH_LABELS (x)) * 2;
+       break;
+ 
      /* Few special cases of expensive operations.  This is useful
         to avoid inlining on functions having too many of these.  */
      case TRUNC_DIV_EXPR:
*** gcc/fold-const.c.0	2008-09-26 13:00:59.000000000 +0200
--- gcc/fold-const.c	2008-09-26 13:03:00.000000000 +0200
*************** div_and_round_double (enum tree_code cod
*** 809,815 ****
  	if (hden < 0)
  	  neg_double (lden, hden, &labs_den, &habs_den);
  
! 	/* If (2 * abs (lrem) >= abs (lden)) */
  	mul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,
  		    labs_rem, habs_rem, &ltwice, &htwice);
  
--- 809,815 ----
  	if (hden < 0)
  	  neg_double (lden, hden, &labs_den, &habs_den);
  
! 	/* If (2 * abs (lrem) >= abs (lden)), adjust the quotient.  */
  	mul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,
  		    labs_rem, habs_rem, &ltwice, &htwice);
  
*************** div_and_round_double (enum tree_code cod
*** 817,823 ****
  	     < (unsigned HOST_WIDE_INT) htwice)
  	    || (((unsigned HOST_WIDE_INT) habs_den
  		 == (unsigned HOST_WIDE_INT) htwice)
! 		&& (labs_den < ltwice)))
  	  {
  	    if (*hquo < 0)
  	      /* quo = quo - 1;  */
--- 817,823 ----
  	     < (unsigned HOST_WIDE_INT) htwice)
  	    || (((unsigned HOST_WIDE_INT) habs_den
  		 == (unsigned HOST_WIDE_INT) htwice)
! 		&& (labs_den <= ltwice)))
  	  {
  	    if (*hquo < 0)
  	      /* quo = quo - 1;  */
*** gcc/tree.c~	Mon Sep 29 14:54:32 2008
--- gcc/tree.c	Mon Sep 29 14:55:07 2008
*************** contains_placeholder_p (tree exp)
*** 2102,2107 ****
--- 2102,2111 ----
  		  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1))
  		  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 2)));
  
+	case SAVE_EXPR:
+	  /* save_expr () never wraps anything containing a placeholder */
+	  return 0;
+
  	case CALL_EXPR:
  	  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1));
  
*** gcc/tree-ssa.c.0	2008-09-29 12:32:33.000000000 +0200
--- gcc/tree-ssa.c	2008-09-29 12:35:39.000000000 +0200
*************** tree_ssa_useless_type_conversion (tree e
*** 964,972 ****
    /* If we have an assignment that merely uses a NOP_EXPR to change
       the top of the RHS to the type of the LHS and the type conversion
       is "safe", then strip away the type conversion so that we can
!      enter LHS = RHS into the const_and_copies table.  */
    if (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR
!       || TREE_CODE (expr) == VIEW_CONVERT_EXPR
        || TREE_CODE (expr) == NON_LVALUE_EXPR)
      return tree_ssa_useless_type_conversion_1 (TREE_TYPE (expr),
  					       TREE_TYPE (TREE_OPERAND (expr,
--- 964,978 ----
    /* If we have an assignment that merely uses a NOP_EXPR to change
       the top of the RHS to the type of the LHS and the type conversion
       is "safe", then strip away the type conversion so that we can
!      enter LHS = RHS into the const_and_copies table.  However,
!      VIEW_CONVERT_EXPRs from a non-base to a base integral type are
!      not useless since their purpose is to suppress VRP.  */
    if (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR
!       || (TREE_CODE (expr) == VIEW_CONVERT_EXPR
! 	  && !(INTEGRAL_TYPE_P (TREE_TYPE (expr))
! 	       && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)))
! 	       && !TREE_TYPE (TREE_TYPE (expr))
! 	       && TREE_TYPE (TREE_TYPE (TREE_OPERAND (expr, 0)))))
        || TREE_CODE (expr) == NON_LVALUE_EXPR)
      return tree_ssa_useless_type_conversion_1 (TREE_TYPE (expr),
  					       TREE_TYPE (TREE_OPERAND (expr,
*** gcc/common.opt.ori	Wed Oct  1 11:49:24 2008
--- gcc/common.opt	Wed Oct  1 11:50:25 2008
*************** fshared-data
*** 799,804 ****
--- 799,808 ----
  Common Report Var(flag_shared_data)
  Mark data as shared rather than private
  
+ fpreserve-control-flow
+ Common Report Var(flag_preserve_control_flow) Init(0)
+ Preserve explicit control flow as much as possible.  Default off.
+ 
  fshow-column
  Common C ObjC C++ ObjC++ Report Var(flag_show_column) Init(1)
  Show column numbers in diagnostics, when available.  Default on
*** gcc/doc/invoke.texi.ori	Wed Oct  1 11:49:24 2008
--- gcc/doc/invoke.texi	Wed Oct  1 11:50:25 2008
*************** Future versions of GCC may provide finer
*** 5710,5715 ****
--- 5710,5723 ----
  using C99's @code{FENV_ACCESS} pragma.  This command line option
  will be used to specify the default state for @code{FENV_ACCESS}.
  
+ @item -fpreserve-control-flow
+ @opindex preserve-control-flow
+ Preserve the user level expressed control flow down to assembly code.
+ This typically disables a number of expression folding or phi-node
+ optimizations as well as passes like if-conversion, which is useful to
+ help infering source condition/decision coverage from binary instruction
+ and branch coverage.  This is not enabled by default.
+ 
  @item -fsignaling-nans
  @opindex fsignaling-nans
  Compile code assuming that IEEE signaling NaNs may generate user-visible
*** gcc/tree-ssa-phiopt.c.ori	Wed Oct  1 11:49:24 2008
--- gcc/tree-ssa-phiopt.c	Wed Oct  1 11:50:25 2008
*************** abs_replacement (basic_block cond_bb, ba
*** 987,998 ****
  }
  
  
! /* Always do these optimizations if we have SSA
!    trees to work on.  */
  static bool
  gate_phiopt (void)
  {
!   return 1;
  }
  
  struct tree_opt_pass pass_phiopt =
--- 987,997 ----
  }
  
  
! /* Run phi-node optimizers unless we are to preseve control flow.  */
  static bool
  gate_phiopt (void)
  {
!   return !flag_preserve_control_flow;
  }
  
  struct tree_opt_pass pass_phiopt =
*** gcc/opts.c.ori	Wed Oct  1 11:49:24 2008
--- gcc/opts.c	Wed Oct  1 11:50:25 2008
*************** handle_options (unsigned int argc, const
*** 713,718 ****
--- 713,725 ----
  	  error ("unrecognized command line option \"%s\"", opt);
  	}
      }
+ 
+   /* Disable control-flow altering passes when requested to do so.  */
+   if (flag_preserve_control_flow)
+     {
+       flag_if_conversion = 0;
+       flag_if_conversion2 = 0;
+     }
  }
  
  /* Parse command line options and set default flag values.  Do minimal
*** gcc/fold-const.c.ori	Wed Oct  1 11:49:24 2008
--- gcc/fold-const.c	Wed Oct  1 11:50:26 2008
*************** combine_comparisons (enum tree_code code
*** 2308,2318 ****
  
    switch (code)
      {
!     case TRUTH_AND_EXPR: case TRUTH_ANDIF_EXPR:
        compcode = lcompcode & rcompcode;
        break;
  
!     case TRUTH_OR_EXPR: case TRUTH_ORIF_EXPR:
        compcode = lcompcode | rcompcode;
        break;
  
--- 2308,2326 ----
  
    switch (code)
      {
!     case TRUTH_ANDIF_EXPR:
!       if (flag_preserve_control_flow)
! 	return NULL_TREE;
!       /* Fall through.  */
!     case TRUTH_AND_EXPR:
        compcode = lcompcode & rcompcode;
        break;
  
!     case TRUTH_ORIF_EXPR:
!       if (flag_preserve_control_flow)
! 	return NULL_TREE;
!       /* Fall through.  */
!     case TRUTH_OR_EXPR:
        compcode = lcompcode | rcompcode;
        break;
  
*************** fold_range_test (enum tree_code code, tr
*** 4608,4613 ****
--- 4616,4625 ----
    tree rhs = make_range (op1, &in1_p, &low1, &high1);
    tree tem;
  
+   if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)
+       && flag_preserve_control_flow)
+     return NULL_TREE;
+ 
    /* If this is an OR operation, invert both sides; we will invert
       again at the end.  */
    if (or_op)
*************** fold_truthop (enum tree_code code, tree 
*** 4816,4821 ****
--- 4828,4837 ----
  	}
      }
  
+   if ((code == TRUTH_ORIF_EXPR || code == TRUTH_ANDIF_EXPR)
+       && flag_preserve_control_flow)
+     return NULL_TREE;
+ 
    code = ((code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR)
  	  ? TRUTH_AND_EXPR : TRUTH_OR_EXPR);
  
*************** fold_binary (enum tree_code code, tree t
*** 8894,8903 ****
  	 ANDIF and ORIF operators.  If B contains side effects, this
  	 might change the truth-value of A.  */
        if (TREE_CODE (arg0) == TREE_CODE (arg1)
! 	  && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR
! 	      || TREE_CODE (arg0) == TRUTH_ORIF_EXPR
! 	      || TREE_CODE (arg0) == TRUTH_AND_EXPR
! 	      || TREE_CODE (arg0) == TRUTH_OR_EXPR)
  	  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
  	{
  	  tree a00 = TREE_OPERAND (arg0, 0);
--- 8910,8920 ----
  	 ANDIF and ORIF operators.  If B contains side effects, this
  	 might change the truth-value of A.  */
        if (TREE_CODE (arg0) == TREE_CODE (arg1)
! 	  && (((TREE_CODE (arg0) == TRUTH_ANDIF_EXPR
! 		|| TREE_CODE (arg0) == TRUTH_ORIF_EXPR )
! 	       && !flag_preserve_control_flow)
! 	      || (TREE_CODE (arg0) == TRUTH_AND_EXPR
! 		  || TREE_CODE (arg0) == TRUTH_OR_EXPR))
  	  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
  	{
  	  tree a00 = TREE_OPERAND (arg0, 0);
*** gcc/doc/gcov.texi.ori	Wed Oct  1 11:49:24 2008
--- gcc/doc/gcov.texi	Wed Oct  1 11:50:26 2008
*************** included in the gfdl(7) man page.
*** 38,45 ****
  test code coverage in your programs.
  
  @menu
! * Gcov Intro::         	        Introduction to gcov.
! * Invoking Gcov::       	How to use gcov.
  * Gcov and Optimization::       Using gcov with GCC optimization.
  * Gcov Data Files::             The files used by gcov.
  * Cross-profiling::             Data file relocation.
--- 38,46 ----
  test code coverage in your programs.
  
  @menu
! * Gcov Intro::                  Introduction to gcov.
! * Invoking Gcov::               How to use gcov.
! * Precise Decision Coverage::   Doing precise decision coverage with gcov.
  * Gcov and Optimization::       Using gcov with GCC optimization.
  * Gcov Data Files::             The files used by gcov.
  * Cross-profiling::             Data file relocation.
*************** the file doesn't match the executable (d
*** 447,452 ****
--- 448,502 ----
  counts) it will ignore the contents of the file.  It then adds in the
  new execution counts and finally writes the data to the file.
  
+ @node Precise Decision Coverage
+ @section Precise Decision Coverage
+ 
+ @command{gcov} can genuinely perform decision coverage by using option
+ @option{-b} (ie showing that each branch was taken).  But you can even
+ go further, showing that each individual subcondition is covered and can
+ modify the global decision.  For example:
+ 
+ @smallexample
+ int is_cond (int a, int b, int c)
+ @{
+   return (a >= 0) || (b == 0 && c != 0);
+ @}
+ @end smallexample
+ 
+ You have to write testcases (the minimum is 4 here) to show that each
+ argument can make the function returning 0.
+ 
+ In principle, you can achieve this result with @command{gcov} by using a
+ particular coding style: always use short-circuit boolean operators.
+ This is a very natural coding style in C as the boolean operators
+ @code{||} and @code{&&} are short-circuit operators.
+ 
+ A consequence of the short-circuit operator is that a decision is made
+ for each individual subcondition.  With a properly written test harness,
+ the result of @samp{gcov -b -c} on the previous example can be:
+ 
+ @smallexample
+         -:    1:int is_cond (int a, int b, int c)
+ function is_cond called 4 returned 100% blocks executed 100%
+         4:    2:@{
+         4:    3:  return (a >= 0) || (b == 0 && c != 0);
+ branch  0 taken 3 (fallthrough)
+ branch  1 taken 1
+ branch  2 taken 2 (fallthrough)
+ branch  3 taken 1
+ branch  4 taken 1 (fallthrough)
+ branch  5 taken 1
+         -:    4:@}
+ @end smallexample
+ 
+ There are 3 decisions and thus 6 branches (1 for the true path and one for
+ the false path).  And with the 4 tests all the branches were taken.
+ 
+ By default, GCC optimizers may defeat this approach by performing
+ transformations that break the low level control flow representativity
+ of the source level expressed control.  @option{-fpreserve-control-flow}
+ was introduced to disable such transformations.
+ 
  @node Gcov and Optimization
  @section Using @command{gcov} with GCC Optimization
  
*** gcc/tree.h.0	2008-10-02 10:38:17.000000000 +0200
--- gcc/tree.h	2008-09-30 06:30:00.000000000 +0200
*************** struct tree_decl_minimal GTY(())
*** 2128,2134 ****
    (DECL_COMMON_CHECK (NODE)->decl_common.debug_expr_is_from)
  
  /* Nonzero for a given ..._DECL node means that the name of this node should
!    be ignored for symbolic debug purposes.  */ 
  #define DECL_IGNORED_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)
  
  /* Nonzero for a given ..._DECL node means that this node represents an
--- 2128,2135 ----
    (DECL_COMMON_CHECK (NODE)->decl_common.debug_expr_is_from)
  
  /* Nonzero for a given ..._DECL node means that the name of this node should
!    be ignored for symbolic debug purposes.  Moreover, for a FUNCTION_DECL,
!    the body of the function should also be ignored.  */
  #define DECL_IGNORED_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)
  
  /* Nonzero for a given ..._DECL node means that this node represents an
*** gcc/dbxout.c.0	2008-10-02 10:49:03.000000000 +0200
--- gcc/dbxout.c	2008-10-02 15:55:32.000000000 +0200
*************** dbxout_finish_complex_stabs (tree sym, S
*** 917,929 ****
  #if defined (DBX_DEBUGGING_INFO)
  
  static void
! dbxout_function_end (tree decl)
  {
    char lscope_label_name[100];
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions || DECL_IGNORED_P (decl))
      return;
  
    function_section (current_function_decl);
--- 917,929 ----
  #if defined (DBX_DEBUGGING_INFO)
  
  static void
! dbxout_function_end (tree decl ATTRIBUTE_UNUSED)
  {
    char lscope_label_name[100];
  
    /* The N_FUN tag at the end of the function is a GNU extension,
       which may be undesirable.  */
!   if (!use_gnu_debug_info_extensions)
      return;
  
    function_section (current_function_decl);
*************** dbxout_begin_function (tree decl)
*** 3497,3505 ****
  {
    int saved_tree_used1;
  
-   if (DECL_IGNORED_P (decl))
-     return;
- 
    saved_tree_used1 = TREE_USED (decl);
    TREE_USED (decl) = 1;
    if (DECL_NAME (DECL_RESULT (decl)) != 0)
--- 3497,3502 ----
*** gcc/final.c.0	2008-10-02 14:59:16.000000000 +0200
--- gcc/final.c	2008-10-02 16:06:57.000000000 +0200
*************** asm_insn_count (rtx body)
*** 1371,1376 ****
--- 1371,1390 ----
  }
  #endif
  
+ /* Return true if DWARF2 debug info can be emitted for DECL.  */
+ 
+ static bool
+ dwarf2_debug_info_emitted_p (tree decl)
+ {
+   if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG)
+     return false;
+ 
+   if (DECL_IGNORED_P (decl))
+     return false;
+ 
+   return true;
+ }
+ 
  /* Output assembler code for the start of a function,
     and initialize some of the variables in this file
     for the new function.  The label for the function and associated
*************** final_start_function (rtx first ATTRIBUT
*** 1394,1403 ****
  
    high_block_linenum = high_function_linenum = last_linenum;
  
!   (*debug_hooks->begin_prologue) (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO) || defined (TARGET_UNWIND_INFO)
!   if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG)
      dwarf2out_begin_prologue (0, NULL);
  #endif
  
--- 1408,1418 ----
  
    high_block_linenum = high_function_linenum = last_linenum;
  
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->begin_prologue (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO) || defined (TARGET_UNWIND_INFO)
!   if (!dwarf2_debug_info_emitted_p (current_function_decl))
      dwarf2out_begin_prologue (0, NULL);
  #endif
  
*************** final_end_function (void)
*** 1522,1538 ****
  {
    app_disable ();
  
!   (*debug_hooks->end_function) (high_function_linenum);
  
    /* Finally, output the function epilogue:
       code to restore the stack frame and return to the caller.  */
    targetm.asm_out.function_epilogue (asm_out_file, get_frame_size ());
  
    /* And debug output.  */
!   (*debug_hooks->end_epilogue) (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO)
!   if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG
        && dwarf2out_do_frame ())
      dwarf2out_end_epilogue (last_linenum, last_filename);
  #endif
--- 1537,1555 ----
  {
    app_disable ();
  
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->end_function (high_function_linenum);
  
    /* Finally, output the function epilogue:
       code to restore the stack frame and return to the caller.  */
    targetm.asm_out.function_epilogue (asm_out_file, get_frame_size ());
  
    /* And debug output.  */
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->end_epilogue (last_linenum, last_filename);
  
  #if defined (DWARF2_UNWIND_INFO)
!   if (!dwarf2_debug_info_emitted_p (current_function_decl)
        && dwarf2out_do_frame ())
      dwarf2out_end_epilogue (last_linenum, last_filename);
  #endif
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1742,1764 ****
  
  	  if (last_text_section == in_text)
  	    {
! 	      (*debug_hooks->switch_text_section) ();
  #if defined (DWARF2_UNWIND_INFO)
! 	        if (write_symbols != DWARF2_DEBUG 
! 		    && write_symbols != VMS_AND_DWARF2_DEBUG
! 	 	    && dwarf2out_do_frame ())
! 	 	  dwarf2out_switch_text_section ();
  #endif
  	      unlikely_text_section ();
  	    }
  	  else
  	    {
! 	      (*debug_hooks->switch_text_section) ();
  #if defined (DWARF2_UNWIND_INFO)
! 	        if (write_symbols != DWARF2_DEBUG
! 		    && write_symbols != VMS_AND_DWARF2_DEBUG
! 	 	    && dwarf2out_do_frame ())
! 	 	  dwarf2out_switch_text_section ();
  #endif
  	      text_section ();
  	    }
--- 1759,1781 ----
  
  	  if (last_text_section == in_text)
  	    {
! 	      if (!DECL_IGNORED_P (current_function_decl))
! 		debug_hooks->switch_text_section ();
  #if defined (DWARF2_UNWIND_INFO)
! 	      if (!dwarf2_debug_info_emitted_p (current_function_decl)
! 		  && dwarf2out_do_frame ())
! 		dwarf2out_switch_text_section ();
  #endif
  	      unlikely_text_section ();
  	    }
  	  else
  	    {
! 	      if (!DECL_IGNORED_P (current_function_decl))
! 		debug_hooks->switch_text_section ();
  #if defined (DWARF2_UNWIND_INFO)
! 	      if (!dwarf2_debug_info_emitted_p (current_function_decl)
! 		  && dwarf2out_do_frame ())
! 		dwarf2out_switch_text_section ();
  #endif
  	      text_section ();
  	    }
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1818,1824 ****
  
  	case NOTE_INSN_FUNCTION_BEG:
  	  app_disable ();
! 	  (*debug_hooks->end_prologue) (last_linenum, last_filename);
  
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
--- 1835,1842 ----
  
  	case NOTE_INSN_FUNCTION_BEG:
  	  app_disable ();
! 	  if (!DECL_IGNORED_P (current_function_decl))
! 	    debug_hooks->end_prologue (last_linenum, last_filename);
  
  	  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)
  	    {
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1846,1852 ****
  	      high_block_linenum = last_linenum;
  
  	      /* Output debugging info about the symbol-block beginning.  */
! 	      (*debug_hooks->begin_block) (last_linenum, n);
  
  	      /* Mark this block as output.  */
  	      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;
--- 1864,1871 ----
  	      high_block_linenum = last_linenum;
  
  	      /* Output debugging info about the symbol-block beginning.  */
! 	      if (!DECL_IGNORED_P (current_function_decl))
! 		debug_hooks->begin_block (last_linenum, n);
  
  	      /* Mark this block as output.  */
  	      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1868,1874 ****
  	      --block_depth;
  	      gcc_assert (block_depth >= 0);
  
! 	      (*debug_hooks->end_block) (high_block_linenum, n);
  	    }
  	  break;
  
--- 1887,1894 ----
  	      --block_depth;
  	      gcc_assert (block_depth >= 0);
  
! 	      if (!DECL_IGNORED_P (current_function_decl))
! 		debug_hooks->end_block (high_block_linenum, n);
  	    }
  	  break;
  
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1880,1886 ****
  	  break;
  
  	case NOTE_INSN_VAR_LOCATION:
! 	  (*debug_hooks->var_location) (insn);
  	  break;
  
  	case 0:
--- 1900,1907 ----
  	  break;
  
  	case NOTE_INSN_VAR_LOCATION:
! 	  if (!DECL_IGNORED_P (current_function_decl))
! 	    debug_hooks->var_location (insn);
  	  break;
  
  	case 0:
*************** final_scan_insn (rtx insn, FILE *file, i
*** 1950,1957 ****
  	}
  #endif
  
!       if (LABEL_NAME (insn))
! 	(*debug_hooks->label) (insn);
  
        if (app_on)
  	{
--- 1971,1978 ----
  	}
  #endif
  
!       if (!DECL_IGNORED_P (current_function_decl) && LABEL_NAME (insn))
! 	debug_hooks->label (insn);
  
        if (app_on)
  	{
*************** final_scan_insn (rtx insn, FILE *file, i
*** 2113,2122 ****
  	  }
  	/* Output this line note if it is the first or the last line
  	   note in a row.  */
! 	if (notice_source_line (insn))
! 	  {
! 	    (*debug_hooks->source_line) (last_linenum, last_filename);
! 	  }
  
  	if (GET_CODE (body) == ASM_INPUT)
  	  {
--- 2134,2142 ----
  	  }
  	/* Output this line note if it is the first or the last line
  	   note in a row.  */
! 	if (!DECL_IGNORED_P (current_function_decl)
! 	    && notice_source_line (insn))
! 	  debug_hooks->source_line (last_linenum, last_filename);
  
  	if (GET_CODE (body) == ASM_INPUT)
  	  {
*************** rest_of_handle_final (void)
*** 4009,4015 ****
       *will* be routed past here.  */
  
    timevar_push (TV_SYMOUT);
!   (*debug_hooks->function_decl) (current_function_decl);
    timevar_pop (TV_SYMOUT);
  }
  
--- 4029,4036 ----
       *will* be routed past here.  */
  
    timevar_push (TV_SYMOUT);
!   if (!DECL_IGNORED_P (current_function_decl))
!     debug_hooks->function_decl (current_function_decl);
    timevar_pop (TV_SYMOUT);
  }
  
*** gcc/varasm.c.0	2008-10-02 14:59:44.000000000 +0200
--- gcc/varasm.c	2008-10-02 15:55:32.000000000 +0200
*************** assemble_start_function (tree decl, cons
*** 1619,1625 ****
    ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);
  #endif
  
!   (*debug_hooks->begin_function) (decl);
  
    /* Make function name accessible from other files, if appropriate.  */
  
--- 1619,1626 ----
    ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);
  #endif
  
!   if (!DECL_IGNORED_P (decl))
!     (*debug_hooks->begin_function) (decl);
  
    /* Make function name accessible from other files, if appropriate.  */
  
*** gcc/config/rs6000/xcoff.h.0	2008-10-02 14:57:55.000000000 +0200
--- gcc/config/rs6000/xcoff.h	2008-10-02 16:09:59.000000000 +0200
*************** toc_section (void)					\
*** 249,255 ****
    putc ('.', FILE);						\
    RS6000_OUTPUT_BASENAME (FILE, NAME);				\
    fputs (":\n", FILE);						\
!   if (write_symbols != NO_DEBUG)				\
      xcoffout_declare_function (FILE, DECL, NAME);		\
  }
  
--- 249,255 ----
    putc ('.', FILE);						\
    RS6000_OUTPUT_BASENAME (FILE, NAME);				\
    fputs (":\n", FILE);						\
!   if (write_symbols != NO_DEBUG && !DECL_IGNORED_P (DECL))	\
      xcoffout_declare_function (FILE, DECL, NAME);		\
  }
  
*** gcc/dbxout.c.0	2008-10-06 21:25:37.000000000 +0200
--- gcc/dbxout.c	2008-10-06 21:25:59.000000000 +0200
*************** dbxout_symbol (tree decl, int local ATTR
*** 2705,2713 ****
        }
  
      case PARM_DECL:
!       /* Parm decls go in their own separate chains
! 	 and are output by dbxout_reg_parms and dbxout_parms.  */
!       gcc_unreachable ();
  
      case RESULT_DECL:
      case VAR_DECL:
--- 2705,2717 ----
        }
  
      case PARM_DECL:
!       if (DECL_HAS_VALUE_EXPR_P (decl))
! 	decl = DECL_VALUE_EXPR (decl);
! 
!       /* PARM_DECLs go in their own separate chain and are output by
! 	 dbxout_reg_parms and dbxout_parms, except for those that are
! 	 disguised VAR_DECLs like Out parameters in Ada.  */
!       gcc_assert (TREE_CODE (decl) == VAR_DECL);
  
      case RESULT_DECL:
      case VAR_DECL:
*** gcc/tree.h.0	2008-10-12 10:25:51.000000000 +0200
--- gcc/tree.h	2008-10-11 09:31:00.000000000 +0200
*************** extern tree get_unwidened (tree, tree);
*** 3786,3791 ****
--- 3786,3795 ----
  
  extern tree get_narrower (tree, int *);
  
+ /* Return 1 if T is an expression that get_inner_reference handles.  */
+ 
+ extern int handled_component_p (tree);
+ 
  /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,
     look for nested component-refs or array-refs at constant positions
     and find the ultimate containing object, which is returned.  */
*************** extern tree get_inner_reference (tree, H
*** 3794,3815 ****
  				 tree *, enum machine_mode *, int *, int *,
  				 bool);
  
- /* Return 1 if T is an expression that get_inner_reference handles.  */
- 
- extern int handled_component_p (tree);
- 
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF.  */
  
  extern tree array_ref_element_size (tree);
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  extern tree array_ref_low_bound (tree);
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  extern tree array_ref_up_bound (tree);
  
--- 3798,3815 ----
  				 tree *, enum machine_mode *, int *, int *,
  				 bool);
  
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  extern tree array_ref_element_size (tree);
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  extern tree array_ref_low_bound (tree);
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  extern tree array_ref_up_bound (tree);
  
*** gcc/expr.c.0	2008-10-12 10:25:52.000000000 +0200
--- gcc/expr.c	2008-10-12 10:29:49.000000000 +0200
*************** get_inner_reference (tree exp, HOST_WIDE
*** 5678,5684 ****
  }
  
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF.  */
  
  tree
  array_ref_element_size (tree exp)
--- 5678,5684 ----
  }
  
  /* Return a tree of sizetype representing the size, in bytes, of the element
!    of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  tree
  array_ref_element_size (tree exp)
*************** array_ref_element_size (tree exp)
*** 5705,5711 ****
  }
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  tree
  array_ref_low_bound (tree exp)
--- 5705,5711 ----
  }
  
  /* Return a tree representing the lower bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  tree
  array_ref_low_bound (tree exp)
*************** array_ref_low_bound (tree exp)
*** 5726,5732 ****
  }
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF.  */
  
  tree
  array_ref_up_bound (tree exp)
--- 5726,5732 ----
  }
  
  /* Return a tree representing the upper bound of the array mentioned in
!    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
  
  tree
  array_ref_up_bound (tree exp)
*** gcc/tree-ssa-loop-ivopts.c.0	2008-10-12 10:25:52.000000000 +0200
--- gcc/tree-ssa-loop-ivopts.c	2008-10-12 10:29:49.000000000 +0200
*************** static bool
*** 680,686 ****
  idx_contains_abnormal_ssa_name_p (tree base, tree *index,
  				  void *data ATTRIBUTE_UNUSED)
  {
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))
  	return false;
--- 680,686 ----
  idx_contains_abnormal_ssa_name_p (tree base, tree *index,
  				  void *data ATTRIBUTE_UNUSED)
  {
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))
  	return false;
*************** idx_find_step (tree base, tree *idx, voi
*** 1404,1411 ****
       reference out of the loop (in order to take its address in strength
       reduction).  In order for this to work we need both lower bound
       and step to be loop invariants.  */
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        step = array_ref_element_size (base);
        lbound = array_ref_low_bound (base);
  
--- 1404,1416 ----
       reference out of the loop (in order to take its address in strength
       reduction).  In order for this to work we need both lower bound
       and step to be loop invariants.  */
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
+       /* Moreover, for a range, the size needs to be invariant as well.  */
+       if (TREE_CODE (base) == ARRAY_RANGE_REF
+ 	  && !expr_invariant_in_loop_p (loop, TYPE_SIZE (TREE_TYPE (base))))
+ 	return false;
+ 
        step = array_ref_element_size (base);
        lbound = array_ref_low_bound (base);
  
*************** idx_find_step (tree base, tree *idx, voi
*** 1426,1432 ****
    if (!iv->step)
      return true;
  
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        step = array_ref_element_size (base);
  
--- 1431,1437 ----
    if (!iv->step)
      return true;
  
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        step = array_ref_element_size (base);
  
*************** idx_record_use (tree base, tree *idx,
*** 1466,1472 ****
  		void *data)
  {
    find_interesting_uses_op (data, *idx);
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        find_interesting_uses_op (data, array_ref_element_size (base));
        find_interesting_uses_op (data, array_ref_low_bound (base));
--- 1471,1477 ----
  		void *data)
  {
    find_interesting_uses_op (data, *idx);
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        find_interesting_uses_op (data, array_ref_element_size (base));
        find_interesting_uses_op (data, array_ref_low_bound (base));
*************** strip_offset_1 (tree expr, bool inside_a
*** 1873,1878 ****
--- 1878,1884 ----
        return fold_convert (orig_type, expr);
  
      case ARRAY_REF:
+     case ARRAY_RANGE_REF:
        if (!inside_addr)
  	return orig_expr;
  
*************** idx_remove_ssa_names (tree base, tree *i
*** 5479,5485 ****
    if (TREE_CODE (*idx) == SSA_NAME)
      *idx = SSA_NAME_VAR (*idx);
  
!   if (TREE_CODE (base) == ARRAY_REF)
      {
        op = &TREE_OPERAND (base, 2);
        if (*op
--- 5485,5491 ----
    if (TREE_CODE (*idx) == SSA_NAME)
      *idx = SSA_NAME_VAR (*idx);
  
!   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
      {
        op = &TREE_OPERAND (base, 2);
        if (*op
*** gcc/calls.c.0	2008-10-26 19:54:48.000000000 +0100
--- gcc/calls.c	2008-10-26 19:54:53.000000000 +0100
*************** restore_fixed_argument_area (rtx save_ar
*** 869,881 ****
  static void
  store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)
  {
    int i, j;
  
    for (i = 0; i < num_actuals; i++)
      if (args[i].reg != 0 && ! args[i].pass_on_stack
  	&& args[i].mode == BLKmode
! 	&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))
! 	    < (unsigned int) MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))
        {
  	int bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
  	int endian_correction = 0;
--- 869,882 ----
  static void
  store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)
  {
+   const unsigned int ralign = MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD);
    int i, j;
  
    for (i = 0; i < num_actuals; i++)
      if (args[i].reg != 0 && ! args[i].pass_on_stack
  	&& args[i].mode == BLKmode
! 	&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value)) < ralign
! 	    || (MEM_P (args[i].value) && MEM_ALIGN (args[i].value) < ralign)))
        {
  	int bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
  	int endian_correction = 0;
*** gcc/config/i386/i386.c.0	2008-10-29 22:43:50.000000000 +0100
--- gcc/config/i386/i386.c	2008-10-29 22:43:55.000000000 +0100
*************** classify_argument (enum machine_mode mod
*** 2804,2810 ****
  	    /* The partial classes are now full classes.  */
  	    if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)
  	      subclasses[0] = X86_64_SSE_CLASS;
! 	    if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)
  	      subclasses[0] = X86_64_INTEGER_CLASS;
  	    
  	    for (i = 0; i < words; i++)
--- 2804,2811 ----
  	    /* The partial classes are now full classes.  */
  	    if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)
  	      subclasses[0] = X86_64_SSE_CLASS;
! 	    if (subclasses[0] == X86_64_INTEGERSI_CLASS
! 		&& !((bit_offset % 64) == 0 && bytes == 4))
  	      subclasses[0] = X86_64_INTEGER_CLASS;
  	    
  	    for (i = 0; i < words; i++)
*** gcc/tree-ssa-loop-im.c.0	2008-11-05 20:22:26.000000000 +0100
--- gcc/tree-ssa-loop-im.c	2008-11-05 20:25:17.000000000 +0100
*************** movement_possibility (tree stmt)
*** 260,266 ****
  
    rhs = TREE_OPERAND (stmt, 1);
  
!   if (TREE_SIDE_EFFECTS (rhs))
      return MOVE_IMPOSSIBLE;
  
    if (TREE_CODE (lhs) != SSA_NAME
--- 260,267 ----
  
    rhs = TREE_OPERAND (stmt, 1);
  
!   if (TREE_SIDE_EFFECTS (rhs)
!       || tree_could_throw_p (rhs))
      return MOVE_IMPOSSIBLE;
  
    if (TREE_CODE (lhs) != SSA_NAME
*** gcc/tree-ssa-pre.c.0	2008-11-05 20:22:37.000000000 +0100
--- gcc/tree-ssa-pre.c	2008-11-05 20:28:10.000000000 +0100
*************** compute_avail (void)
*** 2292,2298 ****
  	  if (TREE_CODE (stmt) == MODIFY_EXPR
  	      && !ann->has_volatile_ops
  	      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME
! 	      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (stmt, 0)))
  	    {
  	      tree lhs = TREE_OPERAND (stmt, 0);
  	      tree rhs = TREE_OPERAND (stmt, 1);
--- 2292,2299 ----
  	  if (TREE_CODE (stmt) == MODIFY_EXPR
  	      && !ann->has_volatile_ops
  	      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME
! 	      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (stmt, 0))
! 	      && !tree_could_throw_p (stmt))
  	    {
  	      tree lhs = TREE_OPERAND (stmt, 0);
  	      tree rhs = TREE_OPERAND (stmt, 1);
*** gcc/tree.h.ori	Thu Nov  6 10:45:33 2008
--- gcc/tree.h	Thu Nov  6 10:45:38 2008
*************** struct tree_vec GTY(())
*** 1259,1264 ****
--- 1259,1269 ----
      _ce___->value = VALUE; \
    } while (0)
  
+ /* True if NODE, a FIELD_DECL, is to be processed as a bitfield for
+    constructor output purposes.  */
+ #define CONSTRUCTOR_BITFIELD_P(NODE) \
+   ((DECL_BIT_FIELD (FIELD_DECL_CHECK (NODE)) && DECL_MODE (NODE) != BLKmode))
+ 
  /* A single element of a CONSTRUCTOR. VALUE holds the actual value of the
     element. INDEX can optionally design the position of VALUE: in arrays,
     it is the index where VALUE has to be placed; in structures, it is the
*** gcc/varasm.c.ori	Thu Nov  6 10:45:33 2008
--- gcc/varasm.c	Thu Nov  6 10:48:01 2008
*************** output_constructor (tree exp, unsigned H
*** 4667,4675 ****
  	    }
  	}
        else if (!recurse
! 	       && (!field
! 		   || !DECL_BIT_FIELD (field)
! 		   || DECL_MODE (field) == BLKmode))
  	{
  	  /* An element that is not a true bit-field or part of one.  */
  
--- 4667,4673 ----
  	    }
  	}
        else if (!recurse
! 	       && (!field || !CONSTRUCTOR_BITFIELD_P (field)))
  	{
  	  /* An element that is not a true bit-field or part of one.  */
  
*** gcc/ipa-inline.c.0	2008-11-06 09:10:36.000000000 +0100
--- gcc/ipa-inline.c	2008-11-06 15:45:47.000000000 +0100
*************** cgraph_estimate_growth (struct cgraph_no
*** 221,238 ****
  {
    int growth = 0;
    struct cgraph_edge *e;
    if (node->global.estimated_growth != INT_MIN)
      return node->global.estimated_growth;
  
    for (e = node->callers; e; e = e->next_caller)
!     if (e->inline_failed)
!       growth += (cgraph_estimate_size_after_inlining (1, e->caller, node)
! 		 - e->caller->global.insns);
  
!   /* ??? Wrong for self recursive functions or cases where we decide to not
!      inline for different reasons, but it is not big deal as in that case
!      we will keep the body around, but we will also avoid some inlining.  */
!   if (!node->needed && !DECL_EXTERNAL (node->decl))
      growth -= node->global.insns;
  
    node->global.estimated_growth = growth;
--- 221,245 ----
  {
    int growth = 0;
    struct cgraph_edge *e;
+   bool self_recursive = false;
+ 
    if (node->global.estimated_growth != INT_MIN)
      return node->global.estimated_growth;
  
    for (e = node->callers; e; e = e->next_caller)
!     {
!       if (e->caller == node)
!         self_recursive = true;
!       if (e->inline_failed)
! 	growth += (cgraph_estimate_size_after_inlining (1, e->caller, node)
! 		   - e->caller->global.insns);
!     }
  
!   /* ??? Wrong for non-trivially self recursive functions or cases where
!      we decide to not inline for different reasons, but it is not big deal
!      as in that case we will keep the body around, but we will also avoid
!      some inlining.  */
!   if (!node->needed && !DECL_EXTERNAL (node->decl) && !self_recursive)
      growth -= node->global.insns;
  
    node->global.estimated_growth = growth;
*** gcc/dbxout.c.0	2009-04-28 17:11:46.000000000 +0200
--- gcc/dbxout.c	2009-05-10 13:13:33.000000000 +0200
*************** dbxout_type (tree type, int full)
*** 1691,1696 ****
--- 1691,1703 ----
        vector_type = true;
      }
  
+   /* If this is a subtype that should not be emitted as a subrange type,
+      use the base type.  */
+   if (TREE_CODE (type) == INTEGER_TYPE
+       && TREE_TYPE (type) != NULL_TREE
+       && !subrange_type_for_debug_p (type))
+     type = TREE_TYPE (type);
+ 
    /* If there was an input error and we don't really have a type,
       avoid crashing and write something that is at least valid
       by assuming `int'.  */
*** gcc/dwarf2out.c.0	2009-04-28 17:11:46.000000000 +0200
--- gcc/dwarf2out.c	2009-05-10 13:13:33.000000000 +0200
*************** static void output_file_names (void);
*** 4097,4103 ****
  static dw_die_ref base_type_die (tree);
  static tree root_type (tree);
  static int is_base_type (tree);
- static bool is_subrange_type (tree);
  static dw_die_ref subrange_type_die (tree, dw_die_ref);
  static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);
  static int type_is_enum (tree);
--- 4097,4102 ----
*************** base_type_die (tree type)
*** 8129,8134 ****
--- 8128,8138 ----
    if (TREE_CODE (type) == ERROR_MARK || TREE_CODE (type) == VOID_TYPE)
      return 0;
  
+   /* If this is a subtype that should not be emitted as a subrange type,
+      use the base type.  See subrange_type_for_debug_p.  */
+   if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != NULL_TREE)
+     type = TREE_TYPE (type);
+ 
    if (name)
      {
        if (TREE_CODE (name) == TYPE_DECL)
*************** simple_type_size_in_bits (tree type)
*** 8275,8336 ****
      return TYPE_ALIGN (type);
  }
  
- /* Return true if the debug information for the given type should be
-    emitted as a subrange type.  */
- 
- static inline bool
- is_subrange_type (tree type)
- {
-   tree subtype = TREE_TYPE (type);
- 
-   /* Subrange types are identified by the fact that they are integer
-      types, and that they have a subtype which is either an integer type
-      or an enumeral type.  */
- 
-   if (TREE_CODE (type) != INTEGER_TYPE
-       || subtype == NULL_TREE)
-     return false;
- 
-   if (TREE_CODE (subtype) != INTEGER_TYPE
-       && TREE_CODE (subtype) != ENUMERAL_TYPE
-       && TREE_CODE (subtype) != BOOLEAN_TYPE)
-     return false;
- 
-   if (TREE_CODE (type) == TREE_CODE (subtype)
-       && int_size_in_bytes (type) == int_size_in_bytes (subtype)
-       && TYPE_MIN_VALUE (type) != NULL
-       && TYPE_MIN_VALUE (subtype) != NULL
-       && tree_int_cst_equal (TYPE_MIN_VALUE (type), TYPE_MIN_VALUE (subtype))
-       && TYPE_MAX_VALUE (type) != NULL
-       && TYPE_MAX_VALUE (subtype) != NULL
-       && tree_int_cst_equal (TYPE_MAX_VALUE (type), TYPE_MAX_VALUE (subtype)))
-     {
-       /* The type and its subtype have the same representation.  If in
-          addition the two types also have the same name, then the given
-          type is not a subrange type, but rather a plain base type.  */
-       /* FIXME: brobecker/2004-03-22:
-          Sizetype INTEGER_CSTs nodes are canonicalized.  It should
-          therefore be sufficient to check the TYPE_SIZE node pointers
-          rather than checking the actual size.  Unfortunately, we have
-          found some cases, such as in the Ada "integer" type, where
-          this is not the case.  Until this problem is solved, we need to
-          keep checking the actual size.  */
-       tree type_name = TYPE_NAME (type);
-       tree subtype_name = TYPE_NAME (subtype);
- 
-       if (type_name != NULL && TREE_CODE (type_name) == TYPE_DECL)
-         type_name = DECL_NAME (type_name);
- 
-       if (subtype_name != NULL && TREE_CODE (subtype_name) == TYPE_DECL)
-         subtype_name = DECL_NAME (subtype_name);
- 
-       if (type_name == subtype_name)
-         return false;
-     }
- 
-   return true;
- }
- 
  /*  Given a pointer to a tree node for a subrange type, return a pointer
      to a DIE that describes the given type.  */
  
--- 8279,8284 ----
*************** modified_type_die (tree type, int is_con
*** 8478,8484 ****
  #endif
  	  item_type = TREE_TYPE (type);
  	}
!       else if (is_subrange_type (type))
          mod_type_die = subrange_type_die (type, context_die);
        else if (is_base_type (type))
  	mod_type_die = base_type_die (type);
--- 8426,8434 ----
  #endif
  	  item_type = TREE_TYPE (type);
  	}
!       else if (code == INTEGER_TYPE
! 	       && TREE_TYPE (type) != NULL_TREE
! 	       && subrange_type_for_debug_p (type))
          mod_type_die = subrange_type_die (type, context_die);
        else if (is_base_type (type))
  	mod_type_die = base_type_die (type);
*** gcc/tree.c.0	2009-04-28 17:11:46.000000000 +0200
--- gcc/tree.c	2009-05-10 13:15:17.000000000 +0200
*************** build_range_type (tree type, tree lowval
*** 5184,5189 ****
--- 5184,5228 ----
      return itype;
  }
  
+ /* Return true if the debug information for TYPE, a subtype, should be emitted
+    as a subrange type.  Sometimes doing so unnecessarily obfuscates the debug
+    information and doesn't reflect the source code.  */
+ 
+ bool
+ subrange_type_for_debug_p (tree type)
+ {
+   tree base_type = TREE_TYPE (type);
+ 
+   /* Subrange types have a base type which is an integral type.  */
+   if (!INTEGRAL_TYPE_P (base_type))
+     return false;
+ 
+   /* If the type and its base type have the same representation and the same
+      name, then the type is not a subrange but a copy of the base type.  */
+   if ((TREE_CODE (base_type) == INTEGER_TYPE
+        || TREE_CODE (base_type) == BOOLEAN_TYPE)
+       && int_size_in_bytes (type) == int_size_in_bytes (base_type)
+       && tree_int_cst_equal (TYPE_MIN_VALUE (type),
+ 			     TYPE_MIN_VALUE (base_type))
+       && tree_int_cst_equal (TYPE_MAX_VALUE (type),
+ 			     TYPE_MAX_VALUE (base_type)))
+     {
+       tree type_name = TYPE_NAME (type);
+       tree base_type_name = TYPE_NAME (base_type);
+ 
+       if (type_name && TREE_CODE (type_name) == TYPE_DECL)
+ 	type_name = DECL_NAME (type_name);
+ 
+       if (base_type_name && TREE_CODE (base_type_name) == TYPE_DECL)
+ 	base_type_name = DECL_NAME (base_type_name);
+ 
+       if (type_name == base_type_name)
+ 	return false;
+     }
+ 
+   return true;
+ }
+ 
  /* Just like build_index_type, but takes lowval and highval instead
     of just highval (maxval).  */
  
*** gcc/tree.h.0	2009-04-28 17:11:46.000000000 +0200
--- gcc/tree.h	2009-05-10 13:13:33.000000000 +0200
*************** extern void build_common_tree_nodes_2 (i
*** 4039,4044 ****
--- 4039,4045 ----
  extern void build_common_builtin_nodes (void);
  extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);
  extern tree build_range_type (tree, tree, tree);
+ extern bool subrange_type_for_debug_p (tree);
  extern HOST_WIDE_INT int_cst_value (tree);
  extern tree tree_fold_gcd (tree, tree);
  extern tree build_addr (tree, tree);
*** gcc/opts.c.ori	Mon Dec  8 10:33:08 2008
--- gcc/opts.c	Mon Dec  8 10:33:14 2008
*************** handle_options (unsigned int argc, const
*** 719,724 ****
--- 719,730 ----
      {
        flag_if_conversion = 0;
        flag_if_conversion2 = 0;
+       
+       /* -fpreserve-control-flow is in principle orthogonal to the
+ 	 optimization level.  We haven't yet investigated much at -O > 1,
+ 	 however, so ...  */
+       if (optimize > 1)
+ 	inform ("-fpreserve-control-flow is not supported for -O > 1");
      }
  }
  
*** gcc/fold-const.c.0	2009-02-09 17:41:35.000000000 +0100
--- gcc/fold-const.c	2009-02-09 17:44:24.000000000 +0100
*************** make_range (tree exp, int *pin_p, tree *
*** 3962,3969 ****
  static tree
  build_range_check (tree type, tree exp, int in_p, tree low, tree high)
  {
!   tree etype = TREE_TYPE (exp);
!   tree value;
  
  #ifdef HAVE_canonicalize_funcptr_for_compare
    /* Disable this optimization for function pointer expressions
--- 3962,3969 ----
  static tree
  build_range_check (tree type, tree exp, int in_p, tree low, tree high)
  {
!   tree etype = TREE_TYPE (exp), value;
!   enum tree_code code;
  
  #ifdef HAVE_canonicalize_funcptr_for_compare
    /* Disable this optimization for function pointer expressions
*************** build_range_check (tree type, tree exp, 
*** 4042,4062 ****
  
    /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).
       This requires wrap-around arithmetics for the type of the expression.  */
!   switch (TREE_CODE (etype))
      {
      case INTEGER_TYPE:
        /* There is no requirement that LOW be within the range of ETYPE
  	 if the latter is a subtype.  It must, however, be within the base
  	 type of ETYPE.  So be sure we do the subtraction in that type.  */
!       if (TREE_TYPE (etype))
! 	etype = TREE_TYPE (etype);
!       break;
  
!     case ENUMERAL_TYPE:
!     case BOOLEAN_TYPE:
!     case CHAR_TYPE:
!       etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
! 					      TYPE_UNSIGNED (etype));
        break;
  
      default:
--- 4042,4067 ----
  
    /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).
       This requires wrap-around arithmetics for the type of the expression.  */
!   code = TREE_CODE (etype);
!   switch (code)
      {
      case INTEGER_TYPE:
+     case ENUMERAL_TYPE:
+     case BOOLEAN_TYPE:
+     case CHAR_TYPE:
        /* There is no requirement that LOW be within the range of ETYPE
  	 if the latter is a subtype.  It must, however, be within the base
  	 type of ETYPE.  So be sure we do the subtraction in that type.  */
!       if (code == INTEGER_TYPE && TREE_TYPE (etype))
! 	{
! 	  etype = TREE_TYPE (etype);
! 	  /* But not in an enumeral or boolean type though.  */
! 	  code = TREE_CODE (etype);
! 	}
  
!       if (code != INTEGER_TYPE)
! 	etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
! 						TYPE_UNSIGNED (etype));
        break;
  
      default:
*** gcc/tree-ssa-sink.c.0	2009-02-11 23:15:53.000000000 +0100
--- gcc/tree-ssa-sink.c	2009-02-11 23:16:07.000000000 +0100
*************** statement_sink_location (tree stmt, basi
*** 319,324 ****
--- 319,325 ----
    ann = stmt_ann (stmt);
    if (stmt_ends_bb_p (stmt)
        || TREE_SIDE_EFFECTS (rhs)
+       || tree_could_trap_p (rhs)
        || TREE_CODE (rhs) == EXC_PTR_EXPR
        || TREE_CODE (rhs) == FILTER_EXPR
        || is_hidden_global_store (stmt)
*** gcc/expr.c.0	2009-03-10 09:22:47.000000000 +0100
--- gcc/expr.c	2009-03-10 09:26:04.000000000 +0100
*************** target_align (tree target)
*** 5804,5809 ****
--- 5804,5812 ----
    switch (TREE_CODE (target))
      {
      case BIT_FIELD_REF:
+       /* ??? We could probably do better from the bit position here.  */
+       return 1;
+ 
      case COMPONENT_REF:
        this_align = DECL_ALIGN (TREE_OPERAND (target, 1));
        outer_align = target_align (TREE_OPERAND (target, 0));
*** gcc/gimplify.c.0	2009-03-18 12:48:34.000000000 +0100
--- gcc/gimplify.c	2009-03-18 12:49:24.000000000 +0100
*************** gimplify_init_constructor (tree *expr_p,
*** 2995,3001 ****
  	    else
  	      align = TYPE_ALIGN (type);
  
! 	    if (size > 0 && !can_move_by_pieces (size, align))
  	      {
  		tree new = create_tmp_var_raw (type, "C");
  
--- 2995,3005 ----
  	    else
  	      align = TYPE_ALIGN (type);
  
! 	    /* Do a block move either if the size is so small as to make
! 	       each individual move a sub-unit move on average, or if it
! 	       is so large as to make individual moves inefficient.  */
! 	    if (size > 0 && (size < num_type_elements
! 			     || !can_move_by_pieces (size, align)))
  	      {
  		tree new = create_tmp_var_raw (type, "C");
  
*** gcc/stor-layout.c.0	2009-04-06 19:56:54.000000000 +0200
--- gcc/stor-layout.c	2009-04-06 19:57:47.000000000 +0200
*************** initialize_sizetypes (bool signed_p)
*** 2196,2209 ****
  void
  set_sizetype (tree type)
  {
    int oprecision = TYPE_PRECISION (type);
    /* The *bitsizetype types use a precision that avoids overflows when
       calculating signed sizes / offsets in bits.  However, when
       cross-compiling from a 32 bit to a 64 bit host, we are limited to 64 bit
       precision.  */
!   int precision = MIN (oprecision + BITS_PER_UNIT_LOG + 1,
! 		       2 * HOST_BITS_PER_WIDE_INT);
!   tree t;
  
    gcc_assert (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));
  
--- 2196,2212 ----
  void
  set_sizetype (tree type)
  {
+   tree t;
    int oprecision = TYPE_PRECISION (type);
    /* The *bitsizetype types use a precision that avoids overflows when
       calculating signed sizes / offsets in bits.  However, when
       cross-compiling from a 32 bit to a 64 bit host, we are limited to 64 bit
       precision.  */
!   int precision = oprecision + BITS_PER_UNIT_LOG + 1;
!   precision
!     = GET_MODE_PRECISION (smallest_mode_for_size (precision, MODE_INT));
!   if (precision > HOST_BITS_PER_WIDE_INT * 2)
!     precision = HOST_BITS_PER_WIDE_INT * 2;
  
    gcc_assert (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));
  
*** gcc/dwarf2out.c.0	2009-04-14 19:03:29.000000000 +0200
--- gcc/dwarf2out.c	2009-04-14 19:08:01.000000000 +0200
*************** field_byte_offset (tree decl)
*** 9553,9566 ****
  
    gcc_assert (TREE_CODE (decl) == FIELD_DECL);
  
-   type = field_type (decl);
-   field_size_tree = DECL_SIZE (decl);
- 
-   /* The size could be unspecified if there was an error, or for
-      a flexible array member.  */
-   if (! field_size_tree)
-     field_size_tree = bitsize_zero_node;
- 
    /* We cannot yet cope with fields whose positions are variable, so
       for now, when we see such things, we simply return 0.  Someday, we may
       be able to handle such cases, but it will be damn difficult.  */
--- 9553,9558 ----
*************** field_byte_offset (tree decl)
*** 9569,9582 ****
  
    bitpos_int = int_bit_position (decl);
  
!   /* If we don't know the size of the field, pretend it's a full word.  */
    if (host_integerp (field_size_tree, 1))
      field_size_in_bits = tree_low_cst (field_size_tree, 1);
    else
!     field_size_in_bits = BITS_PER_WORD;
  
-   type_size_in_bits = simple_type_size_in_bits (type);
-   type_align_in_bits = simple_type_align_in_bits (type);
    decl_align_in_bits = simple_decl_align_in_bits (decl);
  
    /* The GCC front-end doesn't make any attempt to keep track of the starting
--- 9561,9583 ----
  
    bitpos_int = int_bit_position (decl);
  
!   type = field_type (decl);
!   type_size_in_bits = simple_type_size_in_bits (type);
!   type_align_in_bits = simple_type_align_in_bits (type);
! 
!   field_size_tree = DECL_SIZE (decl);
! 
!   /* The size could be unspecified if there was an error, or for
!      a flexible array member.  */
!   if (!field_size_tree)
!     field_size_tree = bitsize_zero_node;
! 
!   /* If the size of the field is not constant, use the type size.  */
    if (host_integerp (field_size_tree, 1))
      field_size_in_bits = tree_low_cst (field_size_tree, 1);
    else
!     field_size_in_bits = type_size_in_bits;
  
    decl_align_in_bits = simple_decl_align_in_bits (decl);
  
    /* The GCC front-end doesn't make any attempt to keep track of the starting
