\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename arm95.info
@settitle Ada95 Reference Manual
@setchapternewpage odd
@finalout
@c %**end of header

@c **********************************************************
@c THIS FILE IS NOT SUITABLE FOR PRODUCING A PRINTED MANUAL !
@c **********************************************************

@c version 1.0

@ifinfo
@center ADA REFERENCE MANUAL

@center Language and Standard Libraries

@center Version 6.0
@center 21 December 1994

@center Copyright (C) 1992,1993,1994,1995  Intermetrics, Inc.

@center This copyright is assigned to the U.S. Government.
@center All rights reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy. Compiled copies of standard library units and
examples need not contain this copyright notice so long as the notice is
included in all copies of source code and documentation.
@end ifinfo

@c ===========================================================================
@node Top, Foreword, (dir), (dir)

@ifinfo
@center ADA REFERENCE MANUAL

@center Language and Standard Libraries

@center Version 6.0
@end ifinfo

@menu
* Foreword::     Information about this standard
* Introduction:: Introduction to the standard

* 1::  General
* 2::  Lexical Elements
* 3::  Declarations and Types
* 4::  Names and Expressions
* 5::  Statements
* 6::  Subprograms
* 7::  Packages
* 8::  Visibility Rules
* 9::  Tasks and Synchronization
* 10:: Program Structure and Compilation Issues
* 11:: Exceptions
* 12:: Generic Units
* 13:: Representation Issues

ANNEXES

* A:: Predefined Language Environment
* B:: Interface to Other Languages
* C:: Systems Programming
* D:: Real-Time Systems
* E:: Distributed Systems
* F:: Information Systems
* G:: Numerics
* H:: Safety and Security
* J:: Obsolescent Features
* K:: Language-Defined Attributes
* L:: Language-Defined Pragmas
* M:: Implementation-Defined Characteristics
* N:: Glossary
* P:: Syntax Summary

* Index::

 --- The Detailed Node Listing ---

* Foreword::

* Introduction::
* Design Goals::
* Language Summary::
* Program Units::
* Declarations and Statements::
* Data Types::
* Other Facilities::
* Language Changes::
* Instructions for Comment Submission::
* Acknowledgements::

* 1::       General
* 1.1::     Scope
* 1.1.1::   Extent
* 1.1.2::   Structure
* 1.1.3::   Conformity of an Implementation with the Standard
* 1.1.4::   Method of Description and Syntax Notation
* 1.1.5::   Classification of Errors
* 1.2::     Normative References
* 1.3::     Definitions

* 2::       Lexical Elements
* 2.1::     Character Set
* 2.2::     Lexical Elements, Separators, and Delimiters
* 2.3::     Identifiers
* 2.4::     Numeric Literals
* 2.4.1::   Decimal Literals
* 2.4.2::   Based Literals
* 2.5::     Character Literals
* 2.6::     String Literals
* 2.7::     Comments
* 2.8::     Pragmas
* 2.9::     Reserved Words

* 3::       Declarations and Types
* 3.1::     Declarations
* 3.2::     Types and Subtypes
* 3.2.1::   Type Declarations
* 3.2.2::   Subtype Declarations
* 3.2.3::   Classification of Operations
* 3.3::     Objects and Named Numbers
* 3.3.1::   Object Declarations
* 3.3.2::   Number Declarations
* 3.4::     Derived Types and Classes
* 3.4.1::   Derivation Classes
* 3.5::     Scalar Types
* 3.5.1::   Enumeration Types
* 3.5.2::   Character Types
* 3.5.3::   Boolean Types
* 3.5.4::   Integer Types
* 3.5.5::   Operations of Discrete Types
* 3.5.6::   Real Types
* 3.5.7::   Floating Point Types
* 3.5.8::   Operations of Floating Point Types
* 3.5.9::   Fixed Point Types
* 3.5.10::  Operations of Fixed Point Types
* 3.6::     Array Types
* 3.6.1::   Index Constraints and Discrete Ranges
* 3.6.2::   Operations of Array Types
* 3.6.3::   String Types
* 3.7::     Discriminants
* 3.7.1::   Discriminant Constraints
* 3.7.2::   Operations of Discriminated Types
* 3.8::     Record Types
* 3.8.1::   Variant Parts and Discrete Choices
* 3.9::     Tagged Types and Type Extensions
* 3.9.1::   Type Extensions
* 3.9.2::   Dispatching Operations of Tagged Types
* 3.9.3::   Abstract Types and Subprograms
* 3.10::    Access Types
* 3.10.1::  Incomplete Type Declarations
* 3.10.2::  Operations of Access Types
* 3.11::    Declarative Parts
* 3.11.1::  Completions of Declarations

* 4::       Names and Expressions
* 4.1::     Names
* 4.1.1::   Indexed Components
* 4.1.2::   Slices
* 4.1.3::   Selected Components
* 4.1.4::   Attributes
* 4.2::     Literals
* 4.3::     Aggregates
* 4.3.1::   Record Aggregates
* 4.3.2::   Extension Aggregates
* 4.3.3::   Array Aggregates
* 4.4::     Expressions
* 4.5::     Operators and Expression Evaluation
* 4.5.1::   Logical Operators and Short-circuit Control Forms
* 4.5.2::   Relational Operators and Membership Tests
* 4.5.3::   Binary Adding Operators
* 4.5.4::   Unary Adding Operators
* 4.5.5::   Multiplying Operators
* 4.5.6::   Highest Precedence Operators
* 4.6::     Type Conversions
* 4.7::     Qualified Expressions
* 4.8::     Allocators
* 4.9::     Static Expressions and Static Subtypes
* 4.9.1::   Statically Matching Constraints and Subtypes

* 5::       Statements
* 5.1::     Simple and Compound Statements - Sequences of Statements
* 5.2::     Assignment Statements
* 5.3::     If Statements
* 5.4::     Case Statements
* 5.5::     Loop Statements
* 5.6::     Block Statements
* 5.7::     Exit Statements
* 5.8::     Goto Statements

* 6::       Subprograms
* 6.1::     Subprogram Declarations
* 6.2::     Formal Parameter Modes
* 6.3::     Subprogram Bodies
* 6.3.1::   Conformance Rules
* 6.3.2::   Inline Expansion of Subprograms
* 6.4::     Subprogram Calls
* 6.4.1::   Parameter Associations
* 6.5::     Return Statements
* 6.6::     Overloading of Operators

* 7::       Packages
* 7.1::     Package Specifications and Declarations
* 7.2::     Package Bodies
* 7.3::     Private Types and Private Extensions
* 7.3.1::   Private Operations
* 7.4::     Deferred Constants
* 7.5::     Limited Types
* 7.6::     User-Defined Assignment and Finalization
* 7.6.1::   Completion and Finalization

* 8::       Visibility Rules
* 8.1::     Declarative Region
* 8.2::     Scope of Declarations
* 8.3::     Visibility
* 8.4::     Use Clauses
* 8.5::     Renaming Declarations
* 8.5.1::   Object Renaming Declarations
* 8.5.2::   Exception Renaming Declarations
* 8.5.3::   Package Renaming Declarations
* 8.5.4::   Subprogram Renaming Declarations
* 8.5.5::   Generic Renaming Declarations
* 8.6::     The Context of Overload Resolution

* 9::       Tasks and Synchronization
* 9.1::     Task Units and Task Objects
* 9.2::     Task Execution - Task Activation
* 9.3::     Task Dependence - Termination of Tasks
* 9.4::     Protected Units and Protected Objects
* 9.5::     Intertask Communication
* 9.5.1::   Protected Subprograms and Protected Actions
* 9.5.2::   Entries and Accept Statements
* 9.5.3::   Entry Calls
* 9.5.4::   Requeue Statements
* 9.6::     Delay Statements, Duration, and Time
* 9.7::     Select Statements
* 9.7.1::   Selective Accept
* 9.7.2::   Timed Entry Calls
* 9.7.3::   Conditional Entry Calls
* 9.7.4::   Asynchronous Transfer of Control
* 9.8::     Abort of a Task - Abort of a Sequence of Statements
* 9.9::     Task and Entry Attributes
* 9.10::    Shared Variables
* 9.11::    Example of Tasking and Synchronization

* 10::      Program Structure and Compilation Issues
* 10.1::    Separate Compilation
* 10.1.1::  Compilation Units - Library Units
* 10.1.2::  Context Clauses - With Clauses
* 10.1.3::  Subunits of Compilation Units
* 10.1.4::  The Compilation Process
* 10.1.5::  Pragmas and Program Units
* 10.1.6::  Environment-Level Visibility Rules
* 10.2::    Program Execution
* 10.2.1::  Elaboration Control

* 11::      Exceptions
* 11.1::    Exception Declarations
* 11.2::    Exception Handlers
* 11.3::    Raise Statements
* 11.4::    Exception Handling
* 11.4.1::  The Package Exceptions
* 11.4.2::  Example of Exception Handling
* 11.5::    Suppressing Checks
* 11.6::    Exceptions and Optimization

* 12::      Generic Units
* 12.1::    Generic Declarations
* 12.2::    Generic Bodies
* 12.3::    Generic Instantiation
* 12.4::    Formal Objects
* 12.5::    Formal Types
* 12.5.1::  Formal Private and Derived Types
* 12.5.2::  Formal Scalar Types
* 12.5.3::  Formal Array Types
* 12.5.4::  Formal Access Types
* 12.6::    Formal Subprograms
* 12.7::    Formal Packages
* 12.8::    Example of a Generic Package

* 13::      Representation Issues
* 13.1::    Representation Items
* 13.2::    Pragma Pack
* 13.3::    Representation Attributes
* 13.4::    Enumeration Representation Clauses
* 13.5::    Record Layout
* 13.5.1::  Record Representation Clauses
* 13.5.2::  Storage Place Attributes
* 13.5.3::  Bit Ordering
* 13.6::    Change of Representation
* 13.7::    The Package System
* 13.7.1::  The Package System.Storage_Elements
* 13.7.2::  The Package System.Address_To_Access_Conversions
* 13.8::    Machine Code Insertions
* 13.9::    Unchecked Type Conversions
* 13.9.1::  Data Validity
* 13.9.2::  The Valid Attribute
* 13.10::   Unchecked Access Value Creation
* 13.11::   Storage Management
* 13.11.1:: The Max_Size_In_Storage_Elements Attribute
* 13.11.2:: Unchecked Storage Deallocation
* 13.11.3:: Pragma Controlled
* 13.12::   Pragma Restrictions
* 13.13::   Streams
* 13.13.1:: The Package Streams
* 13.13.2:: Stream-Oriented Attributes
* 13.14::   Freezing Rules

ANNEXES

* A::       Predefined Language Environment
* A.1::     The Package Standard
* A.2::     The Package Ada
* A.3::     Character Handling
* A.3.1::   The Package Characters
* A.3.2::   The Package Characters.Handling
* A.3.3::   The Package Characters.Latin_1
* A.4::     String Handling
* A.4.1::   The Package Strings
* A.4.2::   The Package Strings.Maps
* A.4.3::   Fixed-Length String Handling
* A.4.4::   Bounded-Length String Handling
* A.4.5::   Unbounded-Length String Handling
* A.4.6::   String-Handling Sets and Mappings
* A.4.7::   Wide_String Handling
* A.5::     The Numerics Packages
* A.5.1::   Elementary Functions
* A.5.2::   Random Number Generation
* A.5.3::   Attributes of Floating Point Types
* A.5.4::   Attributes of Fixed Point Types
* A.6::     Input-Output
* A.7::     External Files and File Objects
* A.8::     Sequential and Direct Files
* A.8.1::   The Generic Package Sequential_IO
* A.8.2::   File Management
* A.8.3::   Sequential Input-Output Operations
* A.8.4::   The Generic Package Direct_IO
* A.8.5::   Direct Input-Output Operations
* A.9::     The Generic Package Storage_IO
* A.10::    Text Input-Output
* A.10.1::  The Package Text_IO
* A.10.2::  Text File Management
* A.10.3::  Default Input, Output, and Error Files
* A.10.4::  Specification of Line and Page Lengths
* A.10.5::  Operations on Columns, Lines, and Pages
* A.10.6::  Get and Put Procedures
* A.10.7::  Input-Output of Characters and Strings
* A.10.8::  Input-Output for Integer Types
* A.10.9::  Input-Output for Real Types
* A.10.10:: Input-Output for Enumeration Types
* A.11::    Wide Text Input-Output
* A.12::    Stream Input-Output
* A.12.1::  The Package Streams.Stream_IO
* A.12.2::  The Package Text_IO.Text_Streams
* A.12.3::  The Package Wide_Text_IO.Text_Streams
* A.13::    Exceptions in Input-Output
* A.14::    File Sharing
* A.15::    The Package Command_Line

* B::       Interface to Other Languages
* B.1::     Interfacing Pragmas
* B.2::     The Package Interfaces
* B.3::     Interfacing with C
* B.3.1::   The Package Interfaces.C.Strings
* B.3.2::   The Generic Package Interfaces.C.Pointers
* B.4::     Interfacing with COBOL
* B.5::     Interfacing with Fortran

* C::       Systems Programming
* C.1::     Access to Machine Operations
* C.2::     Required Representation Support
* C.3::     Interrupt Support
* C.3.1::   Protected Procedure Handlers
* C.3.2::   The Package Interrupts
* C.4::     Preelaboration Requirements
* C.5::     Pragma Discard_Names
* C.6::     Shared Variable Control
* C.7::     Task Identification and Attributes
* C.7.1::   The Package Task_Identification
* C.7.2::   The Package Task_Attributes

* D::       Real-Time Systems
* D.1::     Task Priorities
* D.2::     Priority Scheduling
* D.2.1::   The Task Dispatching Model
* D.2.2::   The Standard Task Dispatching Policy
* D.3::     Priority Ceiling Locking
* D.4::     Entry Queuing Policies
* D.5::     Dynamic Priorities
* D.6::     Preemptive Abort
* D.7::     Tasking Restrictions
* D.8::     Monotonic Time
* D.9::     Delay Accuracy
* D.10::    Synchronous Task Control
* D.11::    Asynchronous Task Control
* D.12::    Other Optimizations and Determinism Rules

* E::       Distributed Systems
* E.1::     Partitions
* E.2::     Categorization of Library Units
* E.2.1::   Shared Passive Library Units
* E.2.2::   Remote Types Library Units
* E.2.3::   Remote Call Interface Library Units
* E.3::     Consistency of a Distributed System
* E.4::     Remote Subprogram Calls
* E.4.1::   Pragma Asynchronous
* E.4.2::   Example of Use of a Remote Access-to-Class-Wide Type
* E.5::     Partition Communication Subsystem

* F::       Information Systems
* F.1::     Machine_Radix Attribute Definition Clause
* F.2::     The Package Decimal
* F.3::     Edited Output for Decimal Types
* F.3.1::   Picture String Formation
* F.3.2::   Edited Output Generation
* F.3.3::   The Package Text_IO.Editing
* F.3.4::   The Package Wide_Text_IO.Editing

* G::       Numerics
* G.1::     Complex Arithmetic
* G.1.1::   Complex Types
* G.1.2::   Complex Elementary Functions
* G.1.3::   Complex Input-Output
* G.1.4::   The Package Wide_Text_IO.Complex_IO
* G.2::     Numeric Performance Requirements
* G.2.1::   Model of Floating Point Arithmetic
* G.2.2::   Model-Oriented Attributes of Floating Point Types
* G.2.3::   Model of Fixed Point Arithmetic
* G.2.4::   Accuracy Requirements for the Elementary Functions
* G.2.5::   Performance Requirements for Random Number Generation
* G.2.6::   Accuracy Requirements for Complex Arithmetic

* H::       Safety and Security
* H.1::     Pragma Normalize_Scalars
* H.2::     Documentation of Implementation Decisions
* H.3::     Reviewable Object Code
* H.3.1::   Pragma Reviewable
* H.3.2::   Pragma Inspection_Point
* H.4::     Safety and Security Restrictions

* J::       Obsolescent Features
* J.1::     Renamings of Ada 83 Library Units
* J.2::     Allowed Replacements of Characters
* J.3::     Reduced Accuracy Subtypes
* J.4::     The Constrained Attribute
* J.5::     ASCII
* J.6::     Numeric_Error
* J.7::     At Clauses
* J.7.1::   Interrupt Entries
* J.8::     Mod Clauses
* J.9::     The Storage_Size Attribute

* K::       Language-Defined Attributes

* L::       Language-Defined Pragmas

* M::       Implementation-Defined Characteristics

* N::       Glossary

* P::       Syntax Summary

* Index::
* Index.Operators::
* Index.Digits::
* Index.A::
* Index.B::
* Index.C::
* Index.D::
* Index.E::
* Index.F::
* Index.G::
* Index.H::
* Index.I::
* Index.J::
* Index.K::
* Index.L::
* Index.M::
* Index.N::
* Index.O::
* Index.P::
* Index.Q::
* Index.R::
* Index.S::
* Index.T::
* Index.U::
* Index.V::
* Index.W::
* Index.X::
* Index.Y::
@end menu

@titlepage
@c ===========================================================================
@center @titlefont{Ada Reference Manual}
@center V6.0 dated 21.12.94
@sp 3
Copyright @copyright 1992,1993,1994,1995  Intermetrics, Inc.
@sp 1
This copyright is assigned to the U.S. Government. All rights reserved.
@sp 1
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy. Compiled copies of standard library units and
examples need not contain this copyright notice so long as the notice is
included in all copies of source code and documentation.
@page
@c ===========================================================================
@center @b{INTERNATIONAL STANDARD} ISO/IEC 8652:1995(E)
@sp 1
@sc{international organization for standardization}
@sp 0
@sc{international electrotechnical commission}
@sp 1
@center INFORMATION TECHNOLOGY -- PROGRAMMING LANGUAGES -- ADA
@sp 1
[Revision of first edition (ISO 8652:1987)]
@sp 1
@center @b{Ada Reference Manual}
@sp 1
@center Language and Standard Libraries
@sp 1
@center Version 6.0
@center 21 December 1994
@sp 1
Copyright @copyright 1992,1993,1994,1995  Intermetrics, Inc.
@end titlepage

@node Foreword, Introduction, Top, Top

@unnumbered Foreword
@enumerate
@item
ISO (the International Organization for Standardization) and IEC (the
International Electrotechnical Commission) form the specialized system
for worldwide standardization. National bodies that are members of ISO
or IEC participate in the development of International Standards through
technical committees established by the respective organization to deal
with particular fields of technical activity. ISO and IEC technical
committees collaborate in fields of mutual interest. Other
international organizations, governmental and non-governmental, in
liaison with ISO and IEC, also take part in the work.

@item
In the field of information technology, ISO and IEC have established a
joint technical committee, ISO/IEC JTC 1. Draft International Standards
adopted by the joint technical committee are circulated to national
bodies for voting. Publication as an International Standard requires
approval by at least 75 % of the national bodies casting a vote.

@item
International Standard ISO/IEC 8652 was prepared by Joint Technical
Committee ISO/IEC JTC 1, Information Technology.

@item
This second edition cancels and replaces the first edition (ISO
8652:1987), of which it constitutes a technical revision.

@item
Annexes A to J form an integral part of this International Standard.
Annexes K to P are for information only.
@end enumerate

@c ===========================================================================
@node Introduction, Design Goals, Foreword, Top
@unnumbered Introduction

@enumerate
@item
This is the Ada Reference Manual.

@item
Other available Ada documents include:

@enumerate 3
@item
Rationale for the Ada Programming Language -- 1995 edition, which gives
an introduction to the new features of Ada, and explains the rationale
behind them. Programmers should read this first.

@item
Changes to Ada -- 1987 to 1995. This document lists in detail the
changes made to the 1987 edition of the standard.

@item
The Annotated Ada Reference Manual (AARM). The AARM contains all of the
text in the RM95, plus various annotations. It is intended primarily for
compiler writers, validation test writers, and others who wish to study
the fine details. The annotations include detailed rationale for
individual rules and explanations of some of the more arcane
interactions among the rules.
@end enumerate
@end enumerate

@menu
* Design Goals::                        Design Goals
* Language Summary::                    Language Summary
* Program Units::                       Program Units
* Declarations and Statements::         Declarations and Statements
* Data Types::                          Data Types
* Other Facilities::                    Other Facilities
* Language Changes::                    Language Changes
* Instructions for Comment Submission:: Instructions for Comment Submission
* Acknowledgements::                    Acknowledgements
@end menu

@c ---------------------------------------------------------------------------
@node Design Goals, Language Summary, Introduction, Introduction
@section Design Goals

@enumerate 6
@item
Ada was originally designed with three overriding concerns: program
reliability and maintenance, programming as a human activity, and
efficiency. This revision to the language was designed to provide
greater flexibility and extensibility, additional control over storage
management and synchronization, and standardized packages oriented
toward supporting important application areas, while at the same time
retaining the original emphasis on reliability, maintainability, and
efficiency.

@item
The need for languages that promote reliability and simplify maintenance
is well established. Hence emphasis was placed on program readability
over ease of writing. For example, the rules of the language require
that program variables be explicitly declared and that their type be
specified. Since the type of a variable is invariant, compilers can
ensure that operations on variables are compatible with the properties
intended for objects of the type. Furthermore, error-prone notations
have been avoided, and the syntax of the language avoids the use of
encoded forms in favor of more English-like constructs. Finally, the
language offers support for separate compilation of program units in a
way that facilitates program development and maintenance, and which
provides the same degree of checking between units as within a unit.

@item
Concern for the human programmer was also stressed during the design.
Above all, an attempt was made to keep to a relatively small number of
underlying concepts integrated in a consistent and systematic way while
continuing to avoid the pitfalls of excessive involution. The design
especially aims to provide language constructs that correspond
intuitively to the normal expectations of users.

@item
Like many other human activities, the development of programs is
becoming ever more decentralized and distributed. Consequently, the
ability to assemble a program from independently produced software
components continues to be a central idea in the design. The concepts of
packages, of private types, and of generic units are directly related to
this idea, which has ramifications in many other aspects of the
language. An allied concern is the maintenance of programs to match
changing requirements; type extension and the hierarchical library
enable a program to be modified while minimizing disturbance to existing
tested and trusted components.

@item
No language can avoid the problem of efficiency. Languages that require
over-elaborate compilers, or that lead to the inefficient use of storage
or execution time, force these inefficiencies on all machines and on all
programs. Every construct of the language was examined in the light of
present implementation techniques. Any proposed construct whose
implementation was unclear or that required excessive machine resources
was rejected.
@end enumerate

@c ---------------------------------------------------------------------------
@node Language Summary, Program Units, Design Goals, Introduction
@section Language Summary

@enumerate 11
@item
An Ada program is composed of one or more program units. Program units
may be subprograms (which define executable algorithms), packages (which
define collections of entities), task units (which define concurrent
computations), protected units (which define operations for the
coordinated sharing of data between tasks), or generic units (which
define parameterized forms of packages and subprograms). Each program
unit normally consists of two parts: a specification, containing the
information that must be visible to other units, and a body, containing
the implementation details, which need not be visible to other units.
Most program units can be compiled separately.

@item
This distinction of the specification and body, and the ability to
compile units separately, allows a program to be designed, written, and
tested as a set of largely independent software components.

@item
An Ada program will normally make use of a library of program units of
general utility. The language provides means whereby individual
organizations can construct their own libraries. All libraries are
structured in a hierarchical manner; this enables the logical
decomposition of a subsystem into individual components. The text of a
separately compiled program unit must name the library units it
requires.
@end enumerate

@c ---------------------------------------------------------------------------
@node Program Units, Declarations and Statements, Language Summary, Introduction
@section Program Units

@enumerate 15
@item
A subprogram is the basic unit for expressing an algorithm. There are
two kinds of subprograms: procedures and functions. A procedure is the
means of invoking a series of actions. For example, it may read data,
update variables, or produce some output. It may have parameters, to
provide a controlled means of passing information between the procedure
and the point of call. A function is the means of invoking the
computation of a value. It is similar to a procedure, but in addition
will return a result.

@item
A package is the basic unit for defining a collection of logically
related entities. For example, a package can be used to define a set of
type declarations and associated operations. Portions of a package can
be hidden from the user, thus allowing access only to the logical
properties expressed by the package specification.

@item
Subprogram and package units may be compiled separately and arranged in
hierarchies of parent and child units giving fine control over
visibility of the logical properties and their detailed implementation.

@item
A task unit is the basic unit for defining a task whose sequence of
actions may be executed concurrently with those of other tasks. Such
tasks may be implemented on multicomputers, multiprocessors, or with
interleaved execution on a single processor. A task unit may define
either a single executing task or a task type permitting the creation of
any number of similar tasks.

@item
A protected unit is the basic unit for defining protected operations for
the coordinated use of data shared between tasks. Simple mutual
exclusion is provided automatically, and more elaborate sharing
protocols can be defined. A protected operation can either be a
subprogram or an entry. A protected entry specifies a Boolean expression
(an entry barrier) that must be true before the body of the entry is
executed. A protected unit may define a single protected object or a
protected type permitting the creation of several similar objects.
@end enumerate

@c ---------------------------------------------------------------------------
@node Declarations and Statements, Data Types, Program Units, Introduction
@section Declarations and Statements

@enumerate 21
@item
The body of a program unit generally contains two parts: a declarative
part, which defines the logical entities to be used in the program unit,
and a sequence of statements, which defines the execution of the program
unit.

@item
The declarative part associates names with declared entities. For
example, a name may denote a type, a constant, a variable, or an
exception. A declarative part also introduces the names and parameters
of other nested subprograms, packages, task units, protected units, and
generic units to be used in the program unit.

@item
The sequence of statements describes a sequence of actions that are to
be performed. The statements are executed in succession (unless a
transfer of control causes execution to continue from another place).

@item
An assignment statement changes the value of a variable. A procedure
call invokes execution of a procedure after associating any actual
parameters provided at the call with the corresponding formal
parameters.

@item
Case statements and if statements allow the selection of an enclosed
sequence of statements based on the value of an expression or on the
value of a condition.

@item
The loop statement provides the basic iterative mechanism in the
language. A loop statement specifies that a sequence of statements is to
be executed repeatedly as directed by an iteration scheme, or until an
exit statement is encountered.

@item
A block statement comprises a sequence of statements preceded by the
declaration of local entities used by the statements.

@item
Certain statements are associated with concurrent execution. A delay
statement delays the execution of a task for a specified duration or
until a specified time. An entry call statement is written as a
procedure call statement; it requests an operation on a task or on a
protected object, blocking the caller until the operation can be
performed. A called task may accept an entry call by executing a
corresponding accept statement, which specifies the actions then to be
performed as part of the rendezvous with the calling task. An entry call
on a protected object is processed when the corresponding entry barrier
evaluates to true, whereupon the body of the entry is executed. The
requeue statement permits the provision of a service as a number of
related activities with preference control. One form of the select
statement allows a selective wait for one of several alternative
rendezvous. Other forms of the select statement allow conditional or
timed entry calls and the asynchronous transfer of control in response
to some triggering event.

@item
Execution of a program unit may encounter error situations in which
normal program execution cannot continue. For example, an arithmetic
computation may exceed the maximum allowed value of a number, or an
attempt may be made to access an array component by using an incorrect
index value. To deal with such error situations, the statements of a
program unit can be textually followed by exception handlers that
specify the actions to be taken when the error situation arises.
Exceptions can be raised explicitly by a raise statement.
@end enumerate

@c ---------------------------------------------------------------------------
@node Data Types, Other Facilities, Declarations and Statements, Introduction
@section Data Types

@enumerate 31
@item
Every object in the language has a type, which characterizes a set of
values and a set of applicable operations. The main classes of types are
elementary types (comprising enumeration, numeric, and access types) and
composite types (including array and record types).

@item
An enumeration type defines an ordered set of distinct enumeration
literals, for example a list of states or an alphabet of characters. The
enumeration types Boolean, Character, and Wide_Character are predefined.

@item
Numeric types provide a means of performing exact or approximate
numerical computations. Exact computations use integer types, which
denote sets of consecutive integers. Approximate computations use either
fixed point types, with absolute bounds on the error, or floating point
types, with relative bounds on the error. The numeric types Integer,
Float, and Duration are predefined.

@item
Composite types allow definitions of structured objects with related
components. The composite types in the language include arrays and
records. An array is an object with indexed components of the same type.
A record is an object with named components of possibly different types.
Task and protected types are also forms of composite types. The array
types String and Wide_String are predefined.

@item
Record, task, and protected types may have special components called
discriminants which parameterize the type. Variant record structures
that depend on the values of discriminants can be defined within a
record type.

@item
Access types allow the construction of linked data structures. A value
of an access type represents a reference to an object declared as
aliased or to an object created by the evaluation of an allocator.
Several variables of an access type may designate the same object, and
components of one object may designate the same or other objects. Both
the elements in such linked data structures and their relation to other
elements can be altered during program execution. Access types also
permit references to subprograms to be stored, passed as parameters, and
ultimately dereferenced as part of an indirect call.

@item
Private types permit restricted views of a type. A private type can be
defined in a package so that only the logically necessary properties are
made visible to the users of the type. The full structural details that
are externally irrelevant are then only available within the package and
any child units.

@item
From any type a new type may be defined by derivation. A type, together
with its derivatives (both direct and indirect) form a derivation class.
Class-wide operations may be defined that accept as a parameter an
operand of any type in a derivation class. For record and private types,
the derivatives may be extensions of the parent type. Types that support
these object-oriented capabilities of class-wide operations and type
extension must be tagged, so that the specific type of an operand within
a derivation class can be identified at run time. When an operation of a
tagged type is applied to an operand whose specific type is not known
until run time, implicit dispatching is performed based on the tag of
the operand.

@item
The concept of a type is further refined by the concept of a subtype,
whereby a user can constrain the set of allowed values of a type.
Subtypes can be used to define subranges of scalar types, arrays with a
limited set of index values, and records and private types with
particular discriminant values.
@end enumerate

@c ---------------------------------------------------------------------------
@node Other Facilities, Language Changes, Data Types, Introduction
@section Other Facilities

@enumerate 41
@item
Representation clauses can be used to specify the mapping between types
and features of an underlying machine. For example, the user can specify
that objects of a given type must be represented with a given number of
bits, or that the components of a record are to be represented using a
given storage layout. Other features allow the controlled use of low
level, nonportable, or implementation-dependent aspects, including the
direct insertion of machine code.

@item
The predefined environment of the language provides for input-output and
other capabilities (such as string manipulation and random number
generation) by means of standard library packages. Input-output is
supported for values of user-defined as well as of predefined types.
Standard means of representing values in display form are also provided.
Other standard library packages are defined in annexes of the standard
to support systems with specialized requirements.

@item
Finally, the language provides a powerful means of parameterization of
program units, called generic program units. The generic parameters can
be types and subprograms (as well as objects and packages) and so allow
general algorithms and data structures to be defined that are applicable
to all types of a given class.
@end enumerate

@c ---------------------------------------------------------------------------
@node Language Changes, Instructions for Comment Submission, Other Facilities, Introduction
@section Language Changes

@enumerate 44
@item
This International Standard replaces the first edition of 1987. In this
edition, the following major language changes have been incorporated:

@enumerate 45
@item
Support for standard 8-bit and 16-bit character sets. @xref{2},
@ref{3.5.2}, @ref{3.6.3}, @ref{A.1}, @ref{A.3}, and @ref{A.4}.

@item
Object-oriented programming with run-time polymorphism. See the
discussions of classes, derived types, tagged types, record extensions,
and private extensions in clauses  @ref{3.4}, @ref{3.9}, and
@ref{7.3}. See also the new forms of generic formal parameters that are
allowed by @ref{12.5.1, ``Formal Private and Derived Types''}, and
@ref{12.7, ``Formal Packages''}.

@item
Access types have been extended to allow an access value to designate a
subprogram or an object declared by an object declaration (as opposed to
just a heap-allocated object) (@pxref{3.10}).

@item
Efficient data-oriented synchronization is provided via protected types.
@xref{9}.

@item
The library units of a library may be organized into a hierarchy of
parent and child units (@pxref{10}).

@item
Additional support has been added for interfacing to other languages.
@xref{B}.

@item
The Specialized Needs Annexes have been added to provide specific
support for certain application areas:

@enumerate 52
@item
Annex C, ``Systems Programming''

@item
Annex D, ``Real-Time Systems''

@item
Annex E, ``Distributed Systems''

@item
Annex F, ``Information Systems''

@item
Annex G, ``Numerics''

@item
Annex H, ``Safety and Security''
@end enumerate
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node Instructions for Comment Submission, Acknowledgements, Language Changes, Introduction
@section Instructions for Comment Submission

@enumerate 58
@item
Informal comments on this International Standard may be sent via e-mail
to ada-comment@@sw-eng.falls-church.va.us. If appropriate, the Project
Editor will initiate the defect correction procedure.

@item
Comments should use the following format:

@item
@example
!topic Title summarizing comment
!reference RM95-ss.ss(pp)
!from Author Name yy-mm-dd
!keywords keywords related to topic
!discussion

text of discussion
@end example

@item
where ss.ss is the section, clause or subclause number, pp is the
paragraph number where applicable, and yy-mm-dd is the date the comment
was sent. The date is optional, as is the !keywords line.

@item
Multiple comments per e-mail message are acceptable. Please use a
descriptive ``Subject'' in your e-mail message.

@item
When correcting typographical errors or making minor wording
suggestions, please put the correction directly as the topic of the
comment; use square brackets [ ] to indicate text to be omitted and
curly braces @{ @} to indicate text to be added, and provide enough
context to make the nature of the suggestion self-evident or put
additional information in the body of the comment, for example:

@item
@example
!topic [c]@{C@}haracter
!topic it[']s meaning is not defined
@end example

@item
Formal requests for interpretations and for reporting defects in this
International Standard may be made in accordance with the ISO/IEC JTC1
Directives and the ISO/IEC JTC1/SC22 policy for interpretations.
National Bodies may submit a Defect Report to ISO/IEC JTC1/SC22 for
resolution under the JTC1 procedures. A response will be provided and,
if appropriate, a Technical Corrigendum will be issued in accordance
with the procedures.
@end enumerate

@c ---------------------------------------------------------------------------
@node Acknowledgements, 1, Instructions for Comment Submission, Introduction
@section Acknowledgements

@enumerate 66
@item
This International Standard was prepared by the Ada 9X Mapping/Revision
Team based at Intermetrics, Inc., which has included: W. Carlson,
Program Manager; T. Taft, Technical Director; J. Barnes (consultant); B.
Brosgol (consultant); R. Duff (Oak Tree Software); M. Edwards; C.
Garrity; R. Hilliard; O. Pazy (consultant); D. Rosenfeld; L. Shafer; W.
White; M. Woodger.

@item
The following consultants to the Ada 9X Project contributed to the
Specialized Needs Annexes: T. Baker (Real-Time/Systems Programming --
SEI, FSU); K. Dritz (Numerics -- Argonne National Laboratory); A.
Gargaro (Distributed Systems -- Computer Sciences); J. Goodenough
(Real-Time/Systems Programming -- SEI); J. McHugh (Secure Systems --
consultant); B. Wichmann (Safety-Critical Systems -- NPL: UK).

@item
This work was regularly reviewed by the Ada 9X Distinguished Reviewers
and the members of the Ada 9X Rapporteur Group (XRG): E. Ploedereder,
Chairman of DRs and XRG (University of Stuttgart: Germany); B. Bardin
(Hughes); J. Barnes (consultant: UK); B. Brett (DEC); B. Brosgol
(consultant); R. Brukardt (RR Software); N. Cohen (IBM); R. Dewar (NYU);
G. Dismukes (TeleSoft); A. Evans (consultant); A. Gargaro (Computer
Sciences); M. Gerhardt (ESL); J. Goodenough (SEI); S. Heilbrunner
(University of Salzburg: Austria); P. Hilfinger (UC/Berkeley); B.
Kaellberg (CelsiusTech: Sweden); M. Kamrad II (Unisys); J. van Katwijk
(Delft University of Technology: The Netherlands); V. Kaufman (Russia);
P. Kruchten (Rational); R. Landwehr (CCI: Germany); C. Lester
(Portsmouth Polytechnic: UK); L. Mansson (TELIA Research: Sweden); S.
Michell (Multiprocessor Toolsmiths: Canada); M. Mills (US Air Force); D.
Pogge (US Navy); K. Power (Boeing); O. Roubine (Verdix: France); A.
Strohmeier (Swiss Fed Inst of Technology: Switzerland); W. Taylor
(consultant: UK); J. Tokar (Tartan); E. Vasilescu (Grumman); J. Vladik
(Prospeks s.r.o.: Czech Republic); S. Van Vlierberghe (OFFIS: Belgium).

@item
Other valuable feedback influencing the revision process was provided by
the Ada 9X Language Precision Team (Odyssey Research Associates), the
Ada 9X User/Implementer Teams (AETECH, Tartan, TeleSoft), the Ada 9X
Implementation Analysis Team (New York University) and the Ada
community-at-large.

@item
Special thanks go to R. Mathis, Convenor of ISO/IEC JTC1/SC22 Working
Group 9.

@item
The Ada 9X Project was sponsored by the Ada Joint Program Office.
Christine M. Anderson at the Air Force Phillips Laboratory (Kirtland
AFB, NM) was the project manager. Changes

@item
The International Standard is the same as this version of the Reference
Manual, except:

@enumerate 73
@item
This list of Changes is not included in the International Standard.

@item
The ``Acknowledgements'' page is not included in the International
Standard.

@item
The text in the running headers and footers on each page is slightly
different in the International Standard.

@item
The title page(s) are different in the International Standard.

@item
This document is formatted for 8.5-by-11-inch paper, whereas the
International Standard is formatted for A4 paper (210-by-297mm); thus,
the page breaks are in different places.
@end enumerate
@end enumerate

@c ===========================================================================
@node 1, 1.1, Acknowledgements, Top
@chapter General

@enumerate
@item
Ada is a programming language designed to support the construction of
long-lived, highly reliable software systems. The language includes
facilities to define packages of related types, objects, and operations.
The packages may be parameterized and the types may be extended to
support the construction of libraries of reusable, adaptable software
components. The operations may be implemented as subprograms using
conventional sequential control structures, or as entries that include
synchronization of concurrent threads of control as part of their
invocation. The language treats modularity in the physical sense as
well, with a facility to support separate compilation.

@item
The language includes a complete facility for the support of real-time,
concurrent programming. Errors can be signaled as exceptions and handled
explicitly. The language also covers systems programming; this requires
precise control over the representation of data and access to
system-dependent properties. Finally, a predefined environment of
standard packages is provided, including facilities for, among others,
input-output, string manipulation, numeric elementary functions, and
random number generation.
@end enumerate

@menu
* 1.1:: Scope
* 1.2:: Normative References
* 1.3:: Definitions

 --- The Detailed Node Listing ---

* 1::     General
* 1.1::   Scope
* 1.1.1:: Extent
* 1.1.2:: Structure
* 1.1.3:: Conformity of an Implementation with the Standard
* 1.1.4:: Method of Description and Syntax Notation
* 1.1.5:: Classification of Errors
* 1.2::   Normative References
* 1.3::   Definitions
@end menu

@c ---------------------------------------------------------------------------
@node 1.1, 1.1.1, 1, 1
@section Scope

@enumerate
@item
This International Standard specifies the form and meaning of programs
written in Ada. Its purpose is to promote the portability of Ada
programs to a variety of data processing systems.
@end enumerate

@menu
* 1.1.1:: Extent
* 1.1.2:: Structure
* 1.1.3:: Conformity of an Implementation with the Standard
* 1.1.4:: Method of Description and Syntax Notation
* 1.1.5:: Classification of Errors
@end menu

@c ---------------------------------------------------------------------------
@node 1.1.1, 1.1.2, 1.1, 1.1
@subsection Extent

@enumerate
@item
This International Standard specifies:

@enumerate 2
@item
The form of a program written in Ada;

@item
The effect of translating and executing such a program;

@item
The manner in which program units may be combined to form Ada programs;

@item
The language-defined library units that a conforming implementation is
required to supply;

@item
The permissible variations within the standard, and the manner in
which they are to be documented;

@item
Those violations of the standard that a conforming implementation is
required to detect, and the effect of attempting to translate or execute
a program containing such violations;

@item
Those violations of the standard that a conforming implementation is not
required to detect.
@end enumerate
@end enumerate

@enumerate 9
@item
This International Standard does not specify:

@enumerate 10
@item
The means whereby a program written in Ada is transformed into object
code executable by a processor;

@item
The means whereby translation or execution of programs is invoked and
the executing units are controlled;

@item
The size or speed of the object code, or the relative execution speed of
different language constructs;

The form or contents of any listings produced by implementations; in
particular, the form or contents of error or warning messages;

@item
The effect of unspecified execution.

@item
The size of a program or program unit that will exceed the capacity of a
particular conforming implementation.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node 1.1.2, 1.1.3, 1.1.1, 1.1
@subsection Structure

@enumerate
@item
This International Standard contains thirteen sections, fourteen
annexes, and an index.

@item
The core of the Ada language consists of:

@enumerate 3
@item
Sections 1 through 13

@item
Annex A, ``Predefined Language Environment''

@item
Annex B, ``Interface to Other Languages''

@item
Annex J, ``Obsolescent Features''
@end enumerate
@end enumerate

@enumerate 7
@item
The following Specialized Needs Annexes define features that are needed
by certain application areas:

@enumerate 8
@item
Annex C, ``Systems Programming''

@item
Annex D, ``Real-Time Systems''

@item
Annex E, ``Distributed Systems''

@item
Annex F, ``Information Systems''

@item
Annex G, ``Numerics''

@item
Annex H, ``Safety and Security''
@end enumerate
@end enumerate

@enumerate 14
@item
The core language and the Specialized Needs Annexes are normative,
except that the material in each of the items listed below is
informative:

@enumerate 15
@item
Text under a NOTES or Examples heading.

@item
Each clause or subclause whose title starts with the word ``Example'' or
``Examples''.
@end enumerate
@end enumerate

@enumerate 17
@item
All implementations shall conform to the core language. In addition, an
implementation may conform separately to one or more Specialized Needs
Annexes.

@item
The following Annexes are informative:

@enumerate 19
@item
Annex K, ``Language-Defined Attributes''

@item
Annex L, ``Language-Defined Pragmas''

@item
Annex M, ``Implementation-Defined Characteristics''

@item
Annex N, ``Glossary''

@item
Annex P, ``Syntax Summary''
@end enumerate
@end enumerate

@enumerate 24
@item
Each section is divided into clauses and subclauses that have a common
structure. Each section, clause, and subclause first introduces its
subject. After the introductory text, text is labeled with the following
headings:

@need 1000
@sp 1
@center @emph{Syntax}

@item
Syntax rules (indented).

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Compile-time rules that are used in name resolution, including overload
resolution.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
Rules that are enforced at compile time. A construct is legal if it
obeys all of the Legality Rules.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A definition of the compile-time effect of each construct.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
Rules that are enforced before running a partition. A partition is legal
if its compilation units are legal and it obeys all of the
Post-Compilation Rules.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A definition of the run-time effect of each construct.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
Situations that result in bounded (run-time) errors, see @ref{1.1.5}.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
Situations that result in erroneous execution, see @ref{1.1.5}.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
Additional requirements for conforming implementations.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
Documentation requirements for conforming implementations.

@need 1000
@sp 1
@center @emph{Metrics}

@item
Metrics that are specified for the time/space properties of the
execution of certain language constructs.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
Additional permissions given to the implementer.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Optional advice given to the implementer. The word ``should'' is used to
indicate that the advice is a recommendation, not a requirement. It is
implementation defined whether or not a given recommendation is obeyed.

NOTES

@item
(1) Notes emphasize consequences of the rules described in the
    (sub)clause or elsewhere. This material is informative.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples illustrate the possible forms of the constructs described. This
material is informative.
@end enumerate

@c ---------------------------------------------------------------------------
@node 1.1.3, 1.1.4, 1.1.2, 1.1
@subsection Conformity of an Implementation with the Standard
@need 1000
@sp 1
@center @emph{Implementation Requirements}
@enumerate
@item
A conforming implementation shall:

@enumerate 2
@item
Translate and correctly execute legal programs written in Ada, provided
that they are not so large as to exceed the capacity of the
implementation;

@item
Identify all programs or program units that are so large as to exceed
the capacity of the implementation (or raise an appropriate exception at
run time);

@item
Identify all programs or program units that contain errors whose
detection is required by this International Standard;

@item
Supply all language-defined library units required by this International
Standard;

@item
Contain no variations except those explicitly permitted by this
International Standard, or those that are impossible or impractical to
avoid given the implementation's execution environment;

@item
Specify all such variations in the manner prescribed by this
International Standard.
@end enumerate
@end enumerate

@enumerate 8
@item
The external effect of the execution of an Ada program is defined in
terms of its interactions with its external environment. The following
are defined as external interactions:

@enumerate 9
@item
Any interaction with an external file, see @ref{A.7},

@item
The execution of certain code_statements, see @ref{13.8}, which
code_statements cause external interactions is implementation defined.

@item
Any call on an imported subprogram, see @ref{B}, including any parameters
passed to it;

@item
Any result returned or exception propagated from a main subprogram
(@pxref{10.2}) or an exported subprogram, see @ref{B}, to an external caller;

@item
Any read or update of an atomic or volatile object, see @ref{C.6},

@item
The values of imported and exported objects, see @ref{B}, at the time of
any other interaction with the external environment.
@end enumerate
@end enumerate

@enumerate 15
@item
A conforming implementation of this International Standard shall produce
for the execution of a given Ada program a set of interactions with the
external environment whose order and timing are consistent with the
definitions and requirements of this International Standard for the
semantics of the given program.

@item
An implementation that conforms to this Standard shall support each
capability required by the core language as specified. In addition, an
implementation that conforms to this Standard may conform to one or more
Specialized Needs Annexes (or to none). Conformance to a Specialized
Needs Annex means that each capability required by the Annex is provided
as specified.

@item
An implementation conforming to this International Standard may provide
additional attributes, library units, and pragmas. However, it shall not
provide any attribute, library unit, or pragma having the same name as
an attribute, library unit, or pragma (respectively) specified in a
Specialized Needs Annex unless the provided construct is either as
specified in the Specialized Needs Annex or is more limited in
capability than that required by the Annex. A program that attempts to
use an unsupported capability of an Annex shall either be identified by
the implementation before run time or shall raise an exception at run
time.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
Certain aspects of the semantics are defined to be either implementation
defined or unspecified. In such cases, the set of possible effects is
specified, and the implementation may choose any effect in the set.
Implementations shall document their behavior in implementation-defined
situations, but documentation is not required for unspecified
situations. The implementation-defined characteristics are summarized in
Annex M.

@item
The implementation may choose to document implementation-defined
behavior either by documenting what happens in general, or by providing
some mechanism for the user to determine what happens in a particular
case.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If an implementation detects the use of an unsupported Specialized Needs
Annex feature at run time, it should raise Program_Error if feasible.

@item
If an implementation wishes to provide implementation-defined extensions
to the functionality of a language-defined library unit, it should
normally do so by adding children to the library unit.

NOTES

@item
(2) The above requirements imply that an implementation conforming to
this Standard may support some of the capabilities required by a
Specialized Needs Annex without supporting all required capabilities.
@end enumerate

@c ---------------------------------------------------------------------------
@node 1.1.4, 1.1.5, 1.1.3, 1.1
@subsection Method of Description and Syntax Notation
@enumerate
@item
The form of an Ada program is described by means of a context-free
syntax together with context-dependent requirements expressed by
narrative rules.

@item
The meaning of Ada programs is described by means of narrative rules
defining both the effects of each construct and the composition rules
for constructs.

@item
The context-free syntax of the language is described using a simple
variant of Backus-Naur Form. In particular:

@enumerate 4
@item
Lower case words in a sans-serif font, some containing embedded
underlines, are used to denote syntactic categories, for example:

@item
@example
case_statement
@end example

@item
Boldface words are used to denote reserved words, for example:

@item
@example
array
@end example

@item
Square brackets enclose optional items. Thus the two following rules are
equivalent.

@item
@example
return_statement ::= return [expression];
return_statement ::= return; | return expression;
@end example

@item
Curly brackets enclose a repeated item. The item may appear zero or more
times; the repetitions occur from left to right as with an equivalent
left-recursive rule. Thus the two following rules are equivalent.

@item
@example
term ::= factor @{multiplying_operator factor@}
term ::= factor | term multiplying_operator factor
@end example

@item
A vertical line separates alternative items unless it occurs immediately
after an opening curly bracket, in which case it stands for itself:

@item
@example
constraint ::= scalar_constraint | composite_constraint
discrete_choice_list ::= discrete_choice @{| discrete_choice@}
@end example

@item
If the name of any syntactic category starts with an italicized part, it
is equivalent to the category name without the italicized part. The
italicized part is intended to convey some semantic information. For
example subtype_name and task_name are both equivalent to name alone.
@end enumerate
@end enumerate

@enumerate 15
@item
A syntactic category is a nonterminal in the grammar defined in BNF
under ``Syntax.'' Names of syntactic categories are set in a different
font, like_this.

@item
A construct is a piece of text (explicit or implicit) that is an
instance of a syntactic category defined under ``Syntax.''

@item
A constituent of a construct is the construct itself, or any construct
appearing within it.

@item
Whenever the run-time semantics defines certain actions to happen in an
arbitrary order, this means that the implementation shall arrange for
these actions to occur in a way that is equivalent to some sequential
order, following the rules that result from that sequential order. When
evaluations are defined to happen in an arbitrary order, with conversion
of the results to some subtypes, or with some run-time checks, the
evaluations, conversions, and checks may be arbitrarily interspersed, so
long as each expression is evaluated before converting or checking its
value. Note that the effect of a program can depend on the order chosen
by the implementation. This can happen, for example, if two actual
parameters of a given call have side effects.

NOTES

@item
(3) The syntax rules describing structured constructs are presented in a
form that corresponds to the recommended paragraphing. For example, an
if_statement is defined as:

@item
@example
if_statement ::=
   if condition then
      sequence_of_statements
   @{elsif condition then
      sequence_of_statements@}
   [else
      sequence_of_statements]
   end if;
@end example

@item
(4) The line breaks and indentation in the syntax rules indicate the
recommended line breaks and indentation in the corresponding constructs.
The preferred places for other line breaks are after semicolons.
@end enumerate

@c ---------------------------------------------------------------------------
@node 1.1.5, 1.2, 1.1.4, 1.1
@subsection Classification of Errors
@need 1000
@sp 1
@center @emph{Implementation Requirements}
@enumerate
@item
The language definition classifies errors into several different
categories:

@enumerate 2
@item
Errors that are required to be detected prior to run time by every Ada
implementation;

@enumerate 3
@item
These errors correspond to any violation of a rule given in this
International Standard, other than those listed below. In particular,
violation of any rule that uses the terms shall, allowed, permitted,
legal, or illegal belongs to this category. Any program that contains
such an error is not a legal Ada program; on the other hand, the fact
that a program is legal does not mean, per se, that the program is free
from other forms of error.

@item
The rules are further classified as either compile time
rules, or post compilation rules, depending on whether a
violation has to be detected at the time a compilation unit is
submitted to the compiler, or may be postponed until the time a
compilation unit is incorporated into a partition of a program.
@end enumerate
@end enumerate

@enumerate 5
@item
Errors that are required to be detected at run time by the execution of
an Ada program;

@enumerate 6
@item
The corresponding error situations are associated with the names of the
predefined exceptions. Every Ada compiler is required to generate code
that raises the corresponding exception if such an error situation
arises during program execution. If such an error situation is certain
to arise in every execution of a construct, then an implementation is
allowed (although not required) to report this fact at compilation time.
@end enumerate
@end enumerate

@enumerate 7
@item
Bounded errors;

@enumerate 8
@item
The language rules define certain kinds of errors that need not be
detected either prior to or during run time, but if not detected, the
range of possible effects shall be bounded. The errors of this
category are called bounded errors. The possible effects of a given
bounded error are specified for each such error, but in any case one
possible effect of a bounded error is the raising of the exception
Program_Error.
@end enumerate
@end enumerate

@enumerate 9
@item
Erroneous execution.

@enumerate 10
@item
In addition to bounded errors, the language rules define
certain kinds of errors as leading to erroneous execution. Like
bounded errors, the implementation need not detect such errors
either prior to or during run time. Unlike bounded errors, there
is no language-specified bound on the possible effect of
erroneous execution; the effect is in general not predictable.
@end enumerate
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}
@enumerate 11
@item
An implementation may provide nonstandard modes of operation. Typically
these modes would be selected by a pragma or by a command line switch
when the compiler is invoked. When operating in a nonstandard mode, the
implementation may reject compilation_units that do not conform to
additional requirements associated with the mode, such as an excessive
number of warnings or violation of coding style guidelines. Similarly,
in a nonstandard mode, the implementation may apply special
optimizations or alternative algorithms that are only meaningful for
programs that satisfy certain criteria specified by the implementation.
In any case, an implementation shall support a standard mode that
conforms to the requirements of this International Standard; in
particular, in the standard mode, all legal compilation_units shall be
accepted.

@need 1000
@sp 1
@center @emph{Implementation Advice}
@item
If an implementation detects a bounded error or erroneous execution, it
should raise Program_Error.
@end enumerate

@c ---------------------------------------------------------------------------
@node 1.2, 1.3, 1.1.5, 1
@section Normative References
@enumerate
@item
The following standards contain provisions which, through reference in
this text, constitute provisions of this International Standard. At the
time of publication, the editions indicated were valid. All standards
are subject to revision, and parties to agreements based on this
International Standard are encouraged to investigate the possibility of
applying the most recent editions of the standards indicated below.
Members of IEC and ISO maintain registers of currently valid
International Standards.

@item
ISO/IEC 646:1991, Information technology -- ISO 7-bit coded character
set for information interchange.

@item
ISO/IEC 1539:1991, Information technology -- Programming languages --
FORTRAN.

@item
ISO 1989:1985, Programming languages -- COBOL.

@item
ISO/IEC 6429:1992, Information technology -- Control functions for coded
graphic character sets.

@item
ISO/IEC 8859-1:1987, Information processing -- 8-bit single-byte coded
character sets -- Part 1: Latin alphabet No. 1.

@item
ISO/IEC 9899:1990, Programming languages -- C.

@item
ISO/IEC 10646-1:1993, Information technology -- Universal Multiple-Octet
Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual
Plane.
@end enumerate

@c ---------------------------------------------------------------------------
@node 1.3, 2, 1.2, 1
@section Definitions
@enumerate
@item
Terms are defined throughout this International Standard, indicated by
italic type. Terms explicitly defined in this International Standard are
not to be presumed to refer implicitly to similar terms defined
elsewhere. Terms not defined in this International Standard are to be
interpreted according to the Webster's Third New International
Dictionary of the English Language. Informal descriptions of some terms
are also given in Annex N, ``Glossary''.
@end enumerate

@c ===========================================================================
@node 2, 2.1, 1.3, Top
@chapter Lexical Elements
@enumerate
@item
The text of a program consists of the texts of one or more compilations.
The text of a compilation is a sequence of lexical elements, each
composed of characters; the rules of composition are given in this
section. Pragmas, which provide certain information for the compiler,
are also described in this section.
@end enumerate

@menu
* 2.1:: Character Set
* 2.2:: Lexical Elements, Separators, and Delimiters
* 2.3:: Identifiers
* 2.4:: Numeric Literals
* 2.5:: Character Literals
* 2.6:: String Literals
* 2.7:: Comments
* 2.8:: Pragmas
* 2.9:: Reserved Words

 --- The Detailed Node Listing ---

* 2::     Lexical Elements
* 2.1::   Character Set
* 2.2::   Lexical Elements, Separators, and Delimiters
* 2.3::   Identifiers
* 2.4::   Numeric Literals
* 2.4.1:: Decimal Literals
* 2.4.2:: Based Literals
* 2.5::   Character Literals
* 2.6::   String Literals
* 2.7::   Comments
* 2.8::   Pragmas
* 2.9::   Reserved Words
@end menu

@c ---------------------------------------------------------------------------
@node 2.1, 2.2, 2, 2
@section Character Set
@enumerate
@item
The only characters allowed outside of comments are the
graphic_characters and format_effectors.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
character ::=
     graphic_character
   | format_effector
   | other_control_function
@end example
@item
@example
graphic_character ::=
     identifier_letter
   | digit
   | space_character
   | special_character
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The character repertoire for the text of an Ada program consists of the
collection of characters called the Basic Multilingual Plane (BMP) of
the ISO 10646 Universal Multiple-Octet Coded Character Set, plus a set
of format_ effectors and, in comments only, a set of
other_control_functions; the coded representation for these characters
is implementation defined (it need not be a representation defined
within ISO-10646-1).

@item
The description of the language definition in this International
Standard uses the graphic symbols defined for Row 00: Basic Latin and
Row 00: Latin-1 Supplement of the ISO 10646 BMP; these correspond to the
graphic symbols of ISO 8859-1 (Latin-1); no graphic symbols are used in
this International Standard for characters outside of Row 00 of the BMP.
The actual set of graphic symbols used by an implementation for the
visual representation of the text of an Ada program is not specified.

@item
The categories of characters are defined as follows:

@item
identifier_letter

@example
upper_case_identifier_letter | lower_case_identifier_letter
@end example

@item
upper_case_identifier_letter

@example
Any character of Row 00 of ISO 10646 BMP whose name begins ``Latin
Capital Letter''.
@end example

@item
lower_case_identifier_letter

@example
Any character of Row 00 of ISO 10646 BMP whose name begins
``Latin Small Letter''.
@end example

@item
digit

@example
One of the characters 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.
@end example

@item
space_character

@example
The character of ISO 10646 BMP named ``Space''.
@end example

@item
special_character

@example
Any character of the ISO 10646 BMP that is not reserved for a
control function, and is not the space_character, an
identifier_letter, or a digit.
@end example

@item
format_effector

@example
The control functions of ISO 6429 called character tabulation
(HT), line tabulation (VT), carriage return (CR), line feed (LF),
and form feed (FF).
@end example

@item
other_control_function

@example
Any control function, other than a format_effector, that is
allowed in a comment; the set of other_control_functions allowed
in comments is implementation defined.
@end example

@item
The following names are used when referring to certain special_characters:

@example
symbol   name                   symbol   name

  "      quotation mark           :      colon
  #      number sign              ;      semicolon
  &      ampersand                <      less-than sign
  '      apostrophe, tick         =      equals sign
  (      left parenthesis         >      greater-than sign
  )      right parenthesis        _      low line, underline
  *      asterisk, multiply       |      vertical line
  +      plus sign                [      left square bracket
  ,      comma                    ]      right square bracket
  -      hyphen-minus, minus      @{      left curly bracket
  .      full stop, dot, point    @}      right curly bracket
  /      solidus, divide
@end example

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
In a nonstandard mode, the implementation may support a different
character repertoire; in particular, the set of characters that are
considered identifier_letters can be extended or changed to conform to
local conventions.

NOTES

@item
(1) Every code position of ISO 10646 BMP that is not reserved for a
control function is defined to be a graphic_character by this
International Standard. This includes all code positions other than
0000 - 001F, 007F - 009F, and FFFE - FFFF.

@item
(2) The language does not specify the source representation of programs.
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.2, 2.3, 2.1, 2
@section Lexical Elements, Separators, and Delimiters

@need 1000
@sp 1
@center @emph{Static Semantics}
@enumerate
@item
The text of a program consists of the texts of one or more compilations.
The text of each compilation is a sequence of separate lexical elements.
Each lexical element is formed from a sequence of characters, and is
either a delimiter, an identifier, a reserved word, a numeric_literal, a
character_ literal, a string_literal, or a comment. The meaning of a
program depends only on the particular sequences of lexical elements
that form its compilations, excluding comments.

@item
The text of a compilation is divided into lines. In general, the
representation for an end of line is implementation defined. However, a
sequence of one or more format_effectors other than character tabulation
(HT) signifies at least one end of line.

@item
In some cases an explicit separator is required to separate adjacent
lexical elements. A separator is any of a space character, a format
effector, or the end of a line, as follows:

@enumerate 4
@item
A space character is a separator except within a comment, a
string_literal, or a character_literal.

@item
Character tabulation (HT) is a separator except within a comment.

@item
The end of a line is always a separator.
@end enumerate
@end enumerate

@enumerate 7
@item
One or more separators are allowed between any two adjacent lexical
elements, before the first of each compilation, or after the last. At
least one separator is required between an identifier, a reserved word,
or a numeric_literal and an adjacent identifier, reserved word, or
numeric_literal.

@item
A delimiter is either one of the following special characters

@item
@example
&    '    (    )    *    +    ,    -
.    /    :    ;    <    =    >    |
@end example

@item
or one of the following compound delimiters each composed of two
adjacent special characters

@item
@example
=>    ..    **    :=    /=    >=    <=    <<    >>    <>
@end example

@item
Each of the special characters listed for single character delimiters is
a single delimiter except if this character is used as a character of a
compound delimiter, or as a character of a comment, string_literal,
character_literal, or numeric_literal.

@item
The following names are used when referring to compound delimiters:

@item
@example
delimiter     name

   =>                       arrow
   ..                       double dot
   **                       double star, exponentiate
   :=                       assignment (pronounced: ``becomes'')
   /=                       inequality (pronounced: ``not equal'')
   >=                       greater than or equal
   <=                       less than or equal
   <<                       left label bracket
   >>                       right label bracket
   <>                       box
@end example

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
An implementation shall support lines of at least 200 characters in
length, not counting any characters used to signify the end of a line.
An implementation shall support lexical elements of at least 200
characters in length. The maximum supported line length and lexical
element length are implementation defined.
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.3, 2.4, 2.2, 2
@section Identifiers
@enumerate
@item
Identifiers are used as names.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
identifier ::= identifier_letter @{[underline] letter_or_digit@}
@end example

@item
@example
letter_or_digit ::= identifier_letter | digit
@end example

@enumerate 4
@item
An identifier shall not be a reserved word.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 5
@item
All characters of an identifier are significant, including any underline
character. Identifiers differing only in the use of corresponding upper
and lower case letters are considered the same.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
In a nonstandard mode, an implementation may support other upper/lower
case equivalence rules for identifiers, to accommodate local
conventions.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of identifiers:

@item
@example
Count      X    Get_Symbol   Ethelyn   Marion

Snobol_4   X1   Page_Count    Store_Next_Item
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.4, 2.4.1, 2.3, 2
@section Numeric Literals

@enumerate
@item
There are two kinds of numeric_literals, real literals and integer
literals. A real literal is a numeric_literal that includes a point; an
integer literal is a numeric_literal without a point.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
numeric_literal ::= decimal_literal | based_literal
@end example

NOTES

@item
(3) The type of an integer literal is universal_integer. The type of a
real literal is universal_real.
@end enumerate

@menu
* 2.4.1:: Decimal Literals
* 2.4.2:: Based Literals
@end menu

@c ---------------------------------------------------------------------------
@node 2.4.1, 2.4.2, 2.4, 2.4
@subsection Decimal Literals

@enumerate
@item
A decimal_literal is a numeric_literal in the conventional decimal
notation (that is, the base is ten).

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
decimal_literal ::= numeral [.numeral] [exponent]
@end example

@item
@example
numeral ::= digit @{[underline] digit@}
@end example

@item
@example
exponent ::= E [+] numeral | E - numeral
@end example

@enumerate 5
@item
An exponent for an integer literal shall not have a minus sign.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 6
@item
An underline character in a numeric_literal does not affect its meaning.
The letter E of an exponent can be written either in lower case or in
upper case, with the same meaning.

@item
An exponent indicates the power of ten by which the value of the
decimal_literal without the exponent is to be multiplied to obtain the
value of the decimal_literal with the exponent.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of decimal literals:

@item
@example
12        0      1E6    123_456           --  integer literals

12.0      0.0    0.456  3.14159_26        --  real literals
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.4.2, 2.5, 2.4.1, 2.4
@subsection Based Literals

@enumerate
@item
A based_literal is a numeric_literal expressed in a form that specifies
the base explicitly.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
based_literal ::= base # based_numeral [.based_numeral] # [exponent]
@end example

@item
@example
base ::= numeral
@end example

@item
@example
based_numeral ::=
   extended_digit @{[underline] extended_digit@}
@end example

@item
@example
extended_digit ::= digit | A | B | C | D | E | F
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The base (the numeric value of the decimal numeral preceding the first
#) shall be at least two and at most sixteen. The extended_digits A
through F represent the digits ten through fifteen, respectively. The
value of each extended_digit of a based_literal shall be less than the
base.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The conventional meaning of based notation is assumed. An exponent
indicates the power of the base by which the value of the based_literal
without the exponent is to be multiplied to obtain the value of the
based_literal with the exponent. The base and the exponent, if any, are
in decimal notation.

@item
The extended_digits A through F can be written either in lower case or
in upper case, with the same meaning.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of based literals:

@item
@example
2#1111_1111#   16#FF#       016#0ff#
--  integer literals of value 255

16#E#E1        2#1110_0000#
--  integer literals of value 224

16#F.FF#E+2    2#1.1111_1111_1110#E11
--  real literals of value 4095.0
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.5, 2.6, 2.4.2, 2
@section Character Literals

@enumerate
@item
A character_literal is formed by enclosing a graphic character between
two apostrophe characters.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
character_literal ::= 'graphic_character'
@end example

NOTES

@item
(4) A character_literal is an enumeration literal of a character type.
(@pxref{3.5.2}).

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of character literals:

@item
@example
'A'     '*'     '''     ' '
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.6, 2.7, 2.5, 2
@section String Literals

@enumerate
@item
A string_literal is formed by a sequence of graphic characters (possibly
none) enclosed between two quotation marks used as string brackets. They
are used to represent operator_symbols  (@pxref{6.1}) values of a string
type (@pxref{4.2}) and array subaggregates (@pxref{4.3.3}).

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
string_literal ::= "@{string_element@}"
@end example

@item
@example
string_element ::= "" | non_quotation_mark_graphic_character
@end example

@enumerate 4
@item
A string_element is either a pair of quotation marks (""), or a single
graphic_character other than a quotation mark.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 5
@item
The sequence of characters of a string_literal is formed from the
sequence of string_elements between the bracketing quotation marks, in
the given order, with a string_element that is "" becoming a single
quotation mark in the sequence of characters, and any other
string_element being reproduced in the sequence.

@item
A null string literal is a string_literal with no string_elements
between the quotation marks.

NOTES

@item
(5) An end of line cannot appear in a string_literal.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of string literals:

@item
@example

"Message of the day:"

""                           --  a null string literal
" "   "A"   """"             --  three string literals of length 1

"Characters such as $, %, and @} are allowed in string literals"
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.7, 2.8, 2.6, 2
@section Comments

@enumerate
@item
A comment starts with two adjacent hyphens and extends up to the end of
the line.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
comment ::= --@{non_end_of_line_character@}
@end example

@enumerate 3
@item
A comment may appear on any line of a program.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 4
@item
The presence or absence of comments has no influence on whether a
program is legal or illegal. Furthermore, comments do not influence the
meaning of a program; their sole purpose is the enlightenment of the
human reader.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of comments:

@item
@example
--  the last sentence above echoes the Algol 68 report

end;  --  processing of Line is complete

--  a long comment may be split onto
--  two or more consecutive lines

----------------  the first two hyphens start the comment
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.8, 2.9, 2.7, 2
@section Pragmas

@enumerate
@item
A pragma is a compiler directive. There are language-defined pragmas
that give instructions for optimization, listing control, etc. An
implementation may support additional (implementation-defined) pragmas.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
pragma ::=
   pragma identifier [(pragma_argument_association
      @{, pragma_argument_association@})];
@end example

@item
@example
pragma_argument_association ::=
     [pragma_argument_identifier =>] name
   | [pragma_argument_identifier =>] expression
@end example

@enumerate 4
@item
In a pragma, any pragma_argument_associations without a
pragma_argument_identifier shall precede any associations with a
pragma_argument_identifier.

@item
Pragmas are only allowed at the following places in a program:

@enumerate 6
@item
After a semicolon delimiter, but not within a formal_part or
discriminant_part.

@item
At any place where the syntax rules allow a construct defined by a
syntactic category whose name ends with "declaration", "statement",
"clause", or "alternative", or one of the syntactic categories variant
or exception_handler; but not in place of such a construct. Also at any
place where a compilation_unit would be allowed.
@end enumerate
@end enumerate

@enumerate 8
@item
Additional syntax rules and placement restrictions exist for specific
pragmas.
@end enumerate
@end enumerate

@enumerate 9
@item
The name of a pragma is the identifier following the reserved word
pragma. The name or expression of a pragma_argument_association is a
pragma argument.

@item
An identifier specific to a pragma is an identifier that is used in a
pragma argument with special meaning for that pragma.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If an implementation does not recognize the name of a pragma, then it
has no effect on the semantics of the program. Inside such a pragma, the
only rules that apply are the Syntax Rules.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Any pragma that appears at the place of an executable construct is
executed. Unless otherwise specified for a particular pragma, this
execution consists of the evaluation of each evaluable pragma argument
in an arbitrary order.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall give a warning message for an unrecognized
pragma name.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may provide implementation-defined pragmas; the name
of an implementation-defined pragma shall differ from those of the
language-defined pragmas.

@item
An implementation may ignore an unrecognized pragma even if it violates
some of the Syntax Rules, if detecting the syntax error is too complex.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Normally, implementation-defined pragmas should have no semantic effect
for error-free programs; that is, if the implementation-defined pragmas
are removed from a working program, the program should still be legal,
and should still have the same semantics.

@item
Normally, an implementation should not define pragmas that can make an
illegal program legal, except as follows:

@enumerate 18
@item
A pragma used to complete a declaration, such as a pragma Import;

@item
A pragma used to configure the environment by adding, removing, or
replacing library_items.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate 20
@item
The forms of List, Page, and Optimize pragmas are as follows:

@item
pragma List(identifier);

@item
pragma Page;

@item
pragma Optimize(identifier);

@enumerate 24
@item
Other pragmas are defined throughout this International Standard, and
are summarized in Annex L.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 25
@item
A pragma List takes one of the identifiers On or Off as the single
argument. This pragma is allowed anywhere a pragma is allowed. It
specifies that listing of the compilation is to be continued or
suspended until a List pragma with the opposite argument is given within
the same compilation. The pragma itself is always listed if the compiler
is producing a listing.

@item
A pragma Page is allowed anywhere a pragma is allowed. It specifies that
the program text which follows the pragma should start on a new page (if
the compiler is currently producing a listing).

@item
A pragma Optimize takes one of the identifiers Time, Space, or Off as
the single argument. This pragma is allowed anywhere a pragma is
allowed, and it applies until the end of the immediately enclosing
declarative region, or for a pragma at the place of a compilation_unit,
to the end of the compilation. It gives advice to the implementation as
to whether time or space is the primary optimization criterion, or that
optional optimizations should be turned off. It is implementation
defined how this advice is followed.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of pragmas:

@item
@example
pragma List(Off);         -- turn off listing generation
pragma Optimize(Off);     -- turn off optional optimizations
pragma Inline(Set_Mask);  -- generate code for Set_Mask inline

pragma Suppress(Range_Check, On => Index);
-- turn off range checking on Index
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 2.9, 3, 2.8, 2
@section Reserved Words

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate
@enumerate 2
@item
The following are the reserved words (ignoring upper/lower case
distinctions):

@example
abort          else           new            return
abs            elsif          not            reverse
abstract       end            null
accept         entry                         select
access         exception                     separate
aliased        exit           of             subtype
all                           or
and            for            others         tagged
array          function       out            task
at                                           terminate
               generic        package        then
begin          goto           pragma         type
body                          private
               if             procedure
case           in             protected      until
constant       is                            use
                              raise
declare                       range          when
delay          limited        record         while
delta          loop           rem            with
digits                        renames
do             mod            requeue        xor
@end example
@end enumerate
@end enumerate
@enumerate 3

NOTES

@item
(6) The reserved words appear in lower case boldface in this
International Standard, except when used in the designator of an
attribute (@pxref{4.1.4}). Lower case boldface is also used for a reserved
word in a string_literal used as an operator_symbol. This is merely a
convention -- programs may be written in whatever typeface is desired
and available.
@end enumerate

@c ===========================================================================
@node 3, 3.1, 2.9, Top
@chapter Declarations and Types

@enumerate
@item
This section describes the types in the language and the rules for
declaring constants, variables, and named numbers.
@end enumerate

@menu
* 3.1::  Declarations
* 3.2::  Types and Subtypes
* 3.3::  Objects and Named Numbers
* 3.4::  Derived Types and Classes
* 3.5::  Scalar Types
* 3.6::  Array Types
* 3.7::  Discriminants
* 3.8::  Record Types
* 3.9::  Tagged Types and Type Extensions
* 3.10:: Access Types
* 3.11:: Declarative Parts

 --- The Detailed Node Listing ---

* 3.1::    Declarations
* 3.2::    Types and Subtypes
* 3.2.1::  Type Declarations
* 3.2.2::  Subtype Declarations
* 3.2.3::  Classification of Operations
* 3.3::    Objects and Named Numbers
* 3.3.1::  Object Declarations
* 3.3.2::  Number Declarations
* 3.4::    Derived Types and Classes
* 3.4.1::  Derivation Classes
* 3.5::    Scalar Types
* 3.5.1::  Enumeration Types
* 3.5.2::  Character Types
* 3.5.3::  Boolean Types
* 3.5.4::  Integer Types
* 3.5.5::  Operations of Discrete Types
* 3.5.6::  Real Types
* 3.5.7::  Floating Point Types
* 3.5.8::  Operations of Floating Point Types
* 3.5.9::  Fixed Point Types
* 3.5.10:: Operations of Fixed Point Types
* 3.6::    Array Types
* 3.6.1::  Index Constraints and Discrete Ranges
* 3.6.2::  Operations of Array Types
* 3.6.3::  String Types
* 3.7::    Discriminants
* 3.7.1::  Discriminant Constraints
* 3.7.2::  Operations of Discriminated Types
* 3.8::    Record Types
* 3.8.1::  Variant Parts and Discrete Choices
* 3.9::    Tagged Types and Type Extensions
* 3.9.1::  Type Extensions
* 3.9.2::  Dispatching Operations of Tagged Types
* 3.9.3::  Abstract Types and Subprograms
* 3.10::   Access Types
* 3.10.1:: Incomplete Type Declarations
* 3.10.2:: Operations of Access Types
* 3.11::   Declarative Parts
* 3.11.1:: Completions of Declarations
@end menu

@c ---------------------------------------------------------------------------
@node 3.1, 3.2, 3, 3
@section Declarations

@enumerate
@item
The language defines several kinds of named entities that are declared
by declarations. The entity's name is defined by the declaration,
usually by a defining_identifier, but sometimes by a
defining_character_literal or defining_operator_symbol.

@item
There are several forms of declaration. A basic_declaration is a form of
declaration defined as follows.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
basic_declaration ::=
     type_declaration         | subtype_declaration
   | object_declaration       | number_declaration
   | subprogram_declaration   | abstract_subprogram_declaration
   | package_declaration      | renaming_declaration
   | exception_declaration    | generic_declaration
   | generic_instantiation
@end example

@item
@example
defining_identifier ::= identifier
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A declaration is a language construct that associates a name with (a
view of) an entity. A declaration may appear explicitly in the program
text (an explicit declaration), or may be supposed to occur at a given
place in the text as a consequence of the semantics of another construct
(an implicit declaration).

@item
Each of the following is defined to be a declaration: any
basic_declaration; an enumeration_literal_specification; a
discriminant_specification; a component_declaration; a
loop_parameter_specification; a parameter_specification; a
subprogram_body; an entry_declaration; an entry_index_specification; a
choice_parameter_specification; a generic_formal_parameter_declaration.

@item
All declarations contain a definition for a view of an entity. A view
consists of an identification of the entity (the entity of the view),
plus view-specific characteristics that affect the use of the entity
through that view (such as mode of access to an object, formal parameter
names and defaults for a subprogram, or visibility to components of a
type). In most cases, a declaration also contains the definition for the
entity itself (a renaming_declaration is an example of a declaration
that does not define a new entity, but instead defines a view of an
existing entity, see @ref{8.5}.)

@item
For each declaration, the language rules define a certain region of text
called the scope of the declaration (@pxref{8.2}). Most declarations
associate an identifier with a declared entity. Within its scope, and
only there, there are places where it is possible to use the identifier
to refer to the declaration, the view it defines, and the associated
entity; these places are defined by the visibility rules (@pxref{8.3}). At
such places the identifier is said to be a name of the entity (the
direct_name or selector_name); the name is said to denote the
declaration, the view, and the associated entity (@pxref{8.6}). The
declaration is said to declare the name, the view, and in most cases,
the entity itself.

@item
As an alternative to an identifier, an enumeration literal can be
declared with a character_literal as its name (@pxref{3.5.1}) and a
function can be declared with an operator_symbol as its name (@pxref{6.1}).

@item
The syntax rules use the terms defining_identifier,
defining_character_literal, and defining_operator_symbol for the
defining occurrence of a name; these are collectively called defining
names. The terms direct_name and selector_name are used for usage
occurrences of identifiers, character_literals, and operator_symbols.
These are collectively called usage names.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The process by which a construct achieves its run-time effect is called
execution. This process is also called elaboration for declarations and
evaluation for expressions. One of the terms execution, elaboration, or
evaluation is defined by this International Standard for each construct
that has a run-time effect.

NOTES

@item
(1) At compile time, the declaration of an entity declares the entity.
At run time, the elaboration of the declaration creates the entity.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.2, 3.2.1, 3.1, 3
@section Types and Subtypes

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
A type is characterized by a set of values, and a set of primitive
operations which implement the fundamental aspects of its semantics. An
object of a given type is a run-time entity that contains (has) a value
of the type.

@item
Types are grouped into classes of types, reflecting the similarity of
their values and primitive operations. There exist several
language-defined classes of types (see NOTES below). Elementary types
are those whose values are logically indivisible; composite types are
those whose values are composed of component values.

@item
The elementary types are the scalar types (discrete and real) and the
access types (whose values provide access to objects or subprograms).
Discrete types are either integer types or are defined by enumeration of
their values (enumeration types). Real types are either floating point
types or fixed point types.

@item
The composite types are the record types, record extensions, array
types, task types, and protected types. A private type or private
extension represents a partial view, see @ref{7.3}, of a type, providing
support for data abstraction. A partial view is a composite type.

@item
Certain composite types (and partial views thereof) have special
components called discriminants whose values affect the presence,
constraints, or initialization of other components. Discriminants can be
thought of as parameters of the type.

@item
The term subcomponent is used in this International Standard in place of
the term component to indicate either a component, or a component of
another subcomponent. Where other subcomponents are excluded, the term
component is used instead. Similarly, a part of an object or value is
used to mean the whole object or value, or any set of its subcomponents.

@item
The set of possible values for an object of a given type can be
subjected to a condition that is called a constraint (the case of a null
constraint that specifies no restriction is also included); the rules
for which values satisfy a given kind of constraint are given in
@ref{3.5} for range_constraints, @ref{3.6.1}, for index_constraints,
and @ref{3.7.1}, for discriminant_constraints.

@item
A subtype of a given type is a combination of the type, a constraint on
values of the type, and certain attributes specific to the subtype. The
given type is called the type of the subtype. Similarly, the associated
constraint is called the constraint of the subtype. The set of values of
a subtype consists of the values of its type that satisfy its
constraint. Such values belong to the subtype.

@item
A subtype is called an unconstrained subtype if its type has unknown
discriminants, or if its type allows range, index, or discriminant
constraints, but the subtype does not impose such a constraint;
otherwise, the subtype is called a constrained subtype (since it has no
unconstrained characteristics).

NOTES

@item
(2) Any set of types that is closed under derivation (@pxref{3.4}) can be
called a ``class'' of types. However, only certain classes are used in
the description of the rules of the language -- generally those that
have their own particular set of primitive operations (@pxref{3.2.3}) or
that correspond to a set of types that are matched by a given kind of
generic formal type (@pxref{12.5}). The following are examples of
``interesting'' language-defined classes: elementary, scalar, discrete,
enumeration, character, boolean, integer, signed integer, modular, real,
floating point, fixed point, ordinary fixed point, decimal fixed point,
numeric, access, access-to-object, access-to-subprogram, composite,
array, string, (untagged) record, tagged, task, protected, nonlimited.
Special syntax is provided to define types in each of these classes.

@enumerate 11
@item
These language-defined classes are organized like this:

@item
@example
all types
   elementary
      scalar
         discrete
            enumeration
               character
               boolean
               other enumeration
            integer
               signed integer
               modular integer
         real
            floating point
            fixed point
               ordinary fixed point
               decimal fixed point
      access
         access-to-object
         access-to-subprogram
   composite
      array
         string
         other array
      untagged record
      tagged
      task
      protected
@end example

@item
The classes ``numeric'' and ``nonlimited'' represent other
classification dimensions and do not fit into the above strictly
hierarchical picture.
@end enumerate
@end enumerate

@menu
* 3.2.1:: Type Declarations
* 3.2.2:: Subtype Declarations
* 3.2.3:: Classification of Operations
@end menu

@c ---------------------------------------------------------------------------
@node 3.2.1, 3.2.2, 3.2, 3.2
@subsection Type Declarations

@enumerate
@item
A type_declaration declares a type and its first subtype.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
type_declaration ::=
     full_type_declaration
   | incomplete_type_declaration
   | private_type_declaration
   | private_extension_declaration
@end example

@item
@example
full_type_declaration ::=
     type defining_identifier [known_discriminant_part]
       is type_definition;
   | task_type_declaration
   | protected_type_declaration
@end example

@item
@example
type_definition ::=
     enumeration_type_definition | integer_type_definition
   | real_type_definition        | array_type_definition
   | record_type_definition      | access_type_definition
   | derived_type_definition
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A given type shall not have a subcomponent whose type is the given type
itself.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The defining_identifier of a type_declaration denotes the first subtype
of the type. The known_discriminant_part, if any, defines the
discriminants of the type (@pxref{3.7, ``Discriminants''}). The remainder
of the type_ declaration defines the remaining characteristics of (the
view of) the type.

@item
A type defined by a type_declaration is a named type; such a type has
one or more nameable subtypes. Certain other forms of declaration also
include type definitions as part of the declaration for an object
(including a parameter or a discriminant). The type defined by such a
declaration is anonymous -- it has no nameable subtypes. For explanatory
purposes, this International Standard sometimes refers to an anonymous
type by a pseudo-name, written in italics, and uses such pseudo-names at
places where the syntax normally requires an identifier. For a named
type whose first subtype is T, this International Standard sometimes
refers to the type of T as simply ``the type T.''

@item
A named type that is declared by a full_type_declaration, or an
anonymous type that is defined as part of declaring an object of the
type, is called a full type. The type_definition, task_definition,
protected_definition, or access_definition that defines a full type is
called a full type definition. Types declared by other forms of
type_declaration are not separate types; they are partial or incomplete
views of some full type.

@item
The definition of a type implicitly declares certain predefined
operators that operate on the type, according to what classes the type
belongs, as specified in @ref{4.5, ``Operators and Expression
Evaluation''}.

@item
The predefined types (for example the types Boolean, Wide_Character,
Integer, root_integer, and universal_integer) are the types that are
defined in a predefined library package called Standard; this package
also includes the (implicit) declarations of their predefined operators.
The package Standard is described in @ref{A.1}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a full_type_declaration consists of the elaboration
of the full type definition. Each elaboration of a full type definition
creates a distinct type and its first subtype.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of type definitions:

@item
@example
(White, Red, Yellow, Green, Blue, Brown, Black)
range 1 .. 72
array(1 .. 10) of Integer
@end example

@item
Examples of type declarations:

@item
@example
type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);
type Column is range 1 .. 72;
type Table  is array(1 .. 10) of Integer;
@end example

NOTES

@item
(3) Each of the above examples declares a named type. The identifier
given denotes the first subtype of the type. Other named subtypes of the
type can be declared with subtype_declarations (@pxref{3.2.2}). Although
names do not directly denote types, a phrase like ``the type Column'' is
sometimes used in this International Standard to refer to the type of
Column, where Column denotes the first subtype of the type. For an
example of the definition of an anonymous type, see the declaration of
the array Color_Table in @ref{3.3.1}, its type is anonymous -- it has
no nameable subtypes.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.2.2, 3.2.3, 3.2.1, 3.2
@subsection Subtype Declarations

@enumerate
@item
A subtype_declaration declares a subtype of some previously declared
type, as defined by a subtype_indication.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
subtype_declaration ::=
   subtype defining_identifier is subtype_indication;
@end example

@item
@example
subtype_indication ::=  subtype_mark [constraint]
@end example

@item
@example
subtype_mark ::= subtype_name
@end example

@item
@example
constraint ::= scalar_constraint | composite_constraint
@end example

@item
@example
scalar_constraint ::=
   range_constraint | digits_constraint | delta_constraint
@end example

@item
@example
composite_constraint ::=
   index_constraint | discriminant_constraint
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
A subtype_mark shall resolve to denote a subtype. The type determined by
a subtype_mark is the type of the subtype denoted by the subtype_mark.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a subtype_declaration consists of the elaboration of
the subtype_indication. The elaboration of a subtype_indication creates
a new subtype. If the subtype_indication does not include a constraint,
the new subtype has the same (possibly null) constraint as that denoted
by the subtype_mark. The elaboration of a subtype_indication that
includes a constraint proceeds as follows:

@enumerate 10
@item
The constraint is first elaborated.

@item
A check is then made that the constraint is compatible with the subtype
denoted by the subtype_mark.
@end enumerate
@end enumerate

@enumerate 12
@item
The condition imposed by a constraint is the condition obtained after
elaboration of the constraint. The rules defining compatibility are
given for each form of constraint in the appropriate subclause. These
rules are such that if a constraint is compatible with a subtype, then
the condition imposed by the constraint cannot contradict any condition
already imposed by the subtype on its values. The exception
Constraint_Error is raised if any check of compatibility fails.

NOTES

@item
(4) A scalar_constraint may be applied to a subtype of an appropriate
scalar type, see @ref{3.5}, see @ref{3.5.9}, and @ref{J.3}, even if the
subtype is already constrained. On the other hand, a
composite_constraint may be applied to a composite subtype (or an
access-to-composite subtype) only if the composite subtype is
unconstrained, see @ref{3.6.1} and @ref{3.7.1}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of subtype declarations:

@item
@example
subtype Rainbow   is Color range Red .. Blue;  -- see @ref{3.2.1}
subtype Red_Blue  is Rainbow;
subtype Int       is Integer;
subtype Small_Int is Integer range -10 .. 10;
subtype Up_To_K   is Column range 1 .. K;      -- see @ref{3.2.1}
subtype Square    is Matrix(1 .. 10, 1 .. 10); -- see @ref{3.6}
subtype Male      is Person(Sex => M);         -- see @ref{3.10.1}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.2.3, 3.3, 3.2.2, 3.2
@subsection Classification of Operations

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
An operation operates on a type T if it yields a value of type T, if it
has an operand whose expected type, see @ref{8.6}, is T, or if it has an
access parameter, see @ref{6.1} designating T. A predefined operator, or
other language-defined operation such as assignment or a membership
test, that operates on a type, is called a predefined operation of the
type. The primitive operations of a type are the predefined operations
of the type, plus any user-defined primitive subprograms.

@item
The primitive subprograms of a specific type are defined as follows:

@enumerate 3
@item
The predefined operators of the type, see @ref{4.5},

@item
For a derived type, the inherited, see @ref{3.4}, user-defined subprograms;

@item
For an enumeration type, the enumeration literals (which are considered
parameterless functions --  see @ref{3.5.1}.);

@item
For a specific type declared immediately within a package_specification,
any subprograms (in addition to the enumeration literals) that are
explicitly declared immediately within the same package_specification
and that operate on the type;

@item
Any subprograms not covered above that are explicitly declared
immediately within the same declarative region as the type and that
override, see @ref{8.3}, other implicitly declared primitive subprograms of
the type.
@end enumerate
@end enumerate

@enumerate 8
@item
A primitive subprogram whose designator is an operator_symbol is called
a primitive operator.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.3, 3.3.1, 3.2.3, 3
@section Objects and Named Numbers

@enumerate
@item
Objects are created at run time and contain a value of a given type. An
object can be created and initialized as part of elaborating a
declaration, evaluating an allocator, aggregate, or function_call, or
passing a parameter by copy. Prior to reclaiming the storage for an
object, it is finalized if necessary, see @ref{7.6.1}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
All of the following are objects:

@enumerate 3
@item
the entity declared by an object_declaration;

@item
a formal parameter of a subprogram, entry, or generic subprogram;

@item
a generic formal object;

@item
a loop parameter;

@item
a choice parameter of an exception_handler;

@item
an entry index of an entry_body;

@item
the result of dereferencing an access-to-object value, see @ref{4.1},

@item
the result of evaluating a function_call (or the equivalent operator
invocation --  see @ref{6.6},

@item
the result of evaluating an aggregate;

@item
a component, slice, or view conversion of another object.
@end enumerate
@end enumerate

@enumerate 13
@item
An object is either a constant object or a variable object. The value of
a constant object cannot be changed between its initialization and its
finalization, whereas the value of a variable object can be changed.
Similarly, a view of an object is either a constant or a variable. All
views of a constant object are constant. A constant view of a variable
object cannot be used to modify the value of the variable. The terms
constant and variable by themselves refer to constant and variable views
of objects.

@item
The value of an object is read when the value of any part of the object
is evaluated, or when the value of an enclosing object is evaluated. The
value of a variable is updated when an assignment is performed to any
part of the variable, or when an assignment is performed to an enclosing
object.

@item
Whether a view of an object is constant or variable is determined by the
definition of the view. The following (and no others) represent
constants:

@enumerate 16
@item
an object declared by an object_declaration with the reserved word
constant;

@item
a formal parameter or generic formal object of mode in;

@item
a discriminant;

@item
a loop parameter, choice parameter, or entry index;

@item
the dereference of an access-to-constant value;

@item
he result of evaluating a function_call or an aggregate;

@item
a selected_component, indexed_component, slice, or view conversion of a
constant.
@end enumerate
@end enumerate

@enumerate 23
@item
At the place where a view of an object is defined, a nominal subtype is
associated with the view. The object's actual subtype (that is, its
subtype) can be more restrictive than the nominal subtype of the view;
it always is if the nominal subtype is an indefinite subtype. A subtype
is an indefinite subtype if it is an unconstrained array subtype, or if
it has unknown discriminants or unconstrained discriminants without
defaults (@pxref{3.7}) otherwise the subtype is a definite subtype (all
elementary subtypes are definite subtypes). A class-wide subtype is
defined to have unknown discriminants, and is therefore an indefinite
subtype. An indefinite subtype does not by itself provide enough
information to create an object; an additional constraint or explicit
initialization expression is necessary (@pxref{3.3.1}). A component cannot
have an indefinite nominal subtype.

@item
A named number provides a name for a numeric value known at compile
time. It is declared by a number_declaration.

NOTES

@item
(5) A constant cannot be the target of an assignment operation, nor be
passed as an in out or out parameter, between its initialization and
finalization, if any.

@item
(6) The nominal and actual subtypes of an elementary object are always
the same. For a discriminated or array object, if the nominal subtype is
constrained then so is the actual subtype.
@end enumerate

@menu
* 3.3.1:: Object Declarations
* 3.3.2:: Number Declarations
@end menu

@c ---------------------------------------------------------------------------
@node 3.3.1, 3.3.2, 3.3, 3.3
@subsection Object Declarations

@enumerate
@item
An object_declaration declares a stand-alone object with a given nominal
subtype and, optionally, an explicit initial value given by an
initialization expression. For an array, task, or protected object, the
object_declaration may include the definition of the (anonymous) type of
the object.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
object_declaration ::=
    defining_identifier_list : [aliased] [constant]
      subtype_indication [:= expression];
  | defining_identifier_list : [aliased] [constant]
      array_type_definition [:= expression];
  | single_task_declaration
  | single_protected_declaration
@end example

@item
@example
defining_identifier_list ::=
   defining_identifier @{, defining_identifier@}
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For an object_declaration with an expression following the compound
delimiter :=, the type expected for the expression is that of the
object. This expression is called the initialization expression.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An object_declaration without the reserved word constant declares a
variable object. If it has a subtype_indication or an
array_type_definition that defines an indefinite subtype, then there
shall be an initialization expression. An initialization expression
shall not be given if the object is of a limited type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An object_declaration with the reserved word constant declares a
constant object. If it has an initialization expression, then it is
called a full constant declaration. Otherwise it is called a deferred
constant declaration. The rules for deferred constant declarations are
given in clause (@pxref{7.4}). The rules for full constant declarations are
given in this subclause.

@item
Any declaration that includes a defining_identifier_list with more than
one defining_identifier is equivalent to a series of declarations each
containing one defining_identifier from the list, with the rest of the
text of the declaration copied for each declaration in the series, in
the same order as the list. The remainder of this International Standard
relies on this equivalence; explanations are given for declarations with
a single defining_identifier.

@item
The subtype_indication or full type definition of an object_declaration
defines the nominal subtype of the object. The object_declaration
declares an object of the type of the nominal subtype.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
If a composite object declared by an object_declaration has an
unconstrained nominal subtype, then if this subtype is indefinite or the
object is constant or aliased, see @ref{3.10}, the actual subtype of this
object is constrained. The constraint is determined by the bounds or
discriminants (if any) of its initial value; the object is said to be
constrained by its initial value. In the case of an aliased object, this
initial value may be either explicit or implicit; in the other cases, an
explicit initial value is required. When not constrained by its initial
value, the actual and nominal subtypes of the object are the same. If
its actual subtype is constrained, the object is called a constrained
object.

@item
For an object_declaration without an initialization expression, any
initial values for the object or its subcomponents are determined by the
implicit initial values defined for its nominal subtype, as follows:

@enumerate 11
@item
The implicit initial value for an access subtype is the null value of
the access type.

@item
The implicit initial (and only) value for each discriminant of a
constrained discriminated subtype is defined by the subtype.

@item
For a (definite) composite subtype, the implicit initial value of each
component with a default_expression is obtained by evaluation of this
expression and conversion to the component's nominal subtype (which
might raise Constraint_Error --  see @ref{4.6, ``Type Conversions''}.),
unless the component is a discriminant of a constrained subtype (the
previous case), or is in an excluded variant, see @ref{3.8.1}. For each
component that does not have a default_expression, any implicit initial
values are those determined by the component's nominal subtype.

@item
For a protected or task subtype, there is an implicit component (an
entry queue) corresponding to each entry, with its implicit initial
value being an empty queue.
@end enumerate
@end enumerate

@enumerate 15
@item
The elaboration of an object_declaration proceeds in the following
sequence of steps:

@enumerate 16
@item
The subtype_indication, array_type_definition, single_task_declaration,
or single_protected_declaration is first elaborated. This creates the
nominal subtype (and the anonymous type in the latter three cases).

@item
If the object_declaration includes an initialization expression, the
(explicit) initial value is obtained by evaluating the expression and
converting it to the nominal subtype (which might raise Constraint_Error
--  see @ref{4.6}.).

@item
The object is created, and, if there is not an initialization
expression, any per-object expressions, see @ref{3.8} are evaluated and any
implicit initial values for the object or for its subcomponents are
obtained as determined by the nominal subtype.

@item
Any initial values (whether explicit or implicit) are assigned to the
object or to the corresponding subcomponents. As described in
@ref{5.2}, and @ref{7.6}, Initialize and Adjust procedures can be
called.
@end enumerate
@end enumerate

@enumerate 20
@item
For the third step above, the object creation and any elaborations and
evaluations are performed in an arbitrary order, except that if the
default_expression for a discriminant is evaluated to obtain its initial
value, then this evaluation is performed before that of the
default_expression for any component that depends on the discriminant,
and also before that of any default_expression that includes the name of
the discriminant. The evaluations of the third step and the assignments
of the fourth step are performed in an arbitrary order, except that each
evaluation is performed before the resulting value is assigned.

@item
There is no implicit initial value defined for a scalar subtype. In the
absence of an explicit initialization, a newly created scalar object
might have a value that does not belong to its subtype (see @ref{13.9.1}
and @ref{H.1}).

NOTES

@item
(7) Implicit initial values are not defined for an indefinite subtype,
because if an object's nominal subtype is indefinite, an explicit
initial value is required.

@item
(8) As indicated above, a stand-alone object is an object declared by an
object_declaration. Similar definitions apply to ``stand-alone
constant'' and ``stand-alone variable.'' A subcomponent of an object is
not a stand-alone object, nor is an object that is created by an
allocator. An object declared by a loop_parameter_specification,
parameter_specification, entry_index_specification,
choice_parameter_specification, or a formal_object_declaration is not
called a stand-alone object.

@item
(9) The type of a stand-alone object cannot be abstract, see @ref{3.9.3}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a multiple object declaration:

@item
@example
--  the multiple object declaration
@end example

@item
@example
John, Paul : Person_Name := new Person(Sex => M); --  see @ref{3.10.1}
@end example

@item
@example
--  is equivalent to the two single object
--  declarations in the order given
@end example

@item
@example
John : Person_Name := new Person(Sex => M);
Paul : Person_Name := new Person(Sex => M);
@end example

@item
Examples of variable declarations:

@item
@example
Count, Sum  : Integer;
Size        : Integer range 0 .. 10_000 := 0;
Sorted      : Boolean := False;
Color_Table : array(1 .. Max) of Color;
Option      : Bit_Vector(1 .. 10) := (others => True);
Hello       : constant String := "Hi, world.";
@end example

@item
Examples of constant declarations:

@item
@example
Limit     : constant Integer := 10_000;
Low_Limit : constant Integer := Limit/10;
Tolerance : constant Real := Dispersion(1.15);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.3.2, 3.4, 3.3.1, 3.3
@subsection Number Declarations

@enumerate
@item
A number_declaration declares a named number.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
number_declaration ::=
   defining_identifier_list : constant := static_expression;
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The static_expression given for a number_declaration is expected to be
of any numeric type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The static_expression given for a number declaration shall be a static
expression, as defined by clause (@pxref{4.9}).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The named number denotes a value of type universal_integer if the type
of the static_expression is an integer type. The named number denotes a
value of type universal_real if the type of the static_expression is a
real type.

@item
The value denoted by the named number is the value of the
static_expression, converted to the corresponding universal type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a number_declaration has no effect.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of number declarations:

@item
@example
Two_Pi        : constant := 2.0*Ada.Numerics.Pi;
-- a real number, see @ref{A.5}
@end example

@item
@example
Max           : constant := 500;     -- an integer number
Max_Line_Size : constant := Max/6;   -- the integer 83
Power_16      : constant := 2**16;   -- the integer 65_536
One, Un, Eins : constant := 1;       -- three different names for 1
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.4, 3.4.1, 3.3.2, 3
@section Derived Types and Classes

@enumerate
@item
A derived_type_definition defines a new type (and its first subtype)
whose characteristics are derived from those of a parent type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
derived_type_definition ::= [abstract] new
  parent_subtype_indication [record_extension_part]
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The parent_subtype_indication defines the parent subtype; its type is
the parent type.

@item
A type shall be completely defined, see @ref{3.11.1}, prior to being
specified as the parent type in a derived_type_definition -- the
full_type_declarations for the parent type and any of its subcomponents
have to precede the derived_type_definition.

@item
If there is a record_extension_part, the derived type is called a record
extension of the parent type. A record_extension_part shall be provided
if and only if the parent type is a tagged type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The first subtype of the derived type is unconstrained if a
known_discriminant_part is provided in the declaration of the derived
type, or if the parent subtype is unconstrained. Otherwise, the
constraint of the first subtype corresponds to that of the parent
subtype in the following sense: it is the same as that of the parent
subtype except that for a range constraint (implicit or explicit), the
value of each bound of its range is replaced by the corresponding value
of the derived type.

@item
The characteristics of the derived type are defined as follows:

@enumerate 8
@item
Each class of types that includes the parent type also includes the
derived type.

@item
If the parent type is an elementary type or an array type, then the set
of possible values of the derived type is a copy of the set of possible
values of the parent type. For a scalar type, the base range of the
derived type is the same as that of the parent type.

@item
If the parent type is a composite type other than an array type, then
the components, protected subprograms, and entries that are declared for
the derived type are as follows:

@enumerate 11
@item
The discriminants specified by a new known_discriminant_part, if there
is one; otherwise, each discriminant of the parent type (implicitly
declared in the same order with the same specifications) -- in the
latter case, the discriminants are said to be inherited, or if unknown
in the parent, are also unknown in the derived type;

@item
Each nondiscriminant component, entry, and protected subprogram of the
parent type, implicitly declared in the same order with the same
declarations; these components, entries, and protected subprograms are
said to be inherited;

@item
Each component declared in a record_extension_part, if any.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 14
@item
Declarations of components, protected subprograms, and entries, whether
implicit or explicit, occur immediately within the declarative region of
the type, in the order indicated above, following the parent
subtype_indication.

@item
The derived type is limited if and only if the parent type is limited.

@item
For each predefined operator of the parent type, there is a
corresponding predefined operator of the derived type.

@item
For each user-defined primitive subprogram (other than a user-defined
equality operator -- see below) of the parent type that already exists
at the place of the derived_type_definition, there exists a
corresponding inherited primitive subprogram of the derived type with
the same defining name. Primitive user-defined equality operators of the
parent type are also inherited by the derived type, except when the
derived type is a nonlimited record extension, and the inherited
operator would have a profile that is type conformant with the profile
of the corresponding predefined equality operator; in this case, the
user-defined equality operator is not inherited, but is rather
incorporated into the implementation of the predefined equality operator
of the record extension, see @ref{4.5.2}.

@item
The profile of an inherited subprogram (including an inherited
enumeration literal) is obtained from the profile of the corresponding
(user-defined) primitive subprogram of the parent type, after systematic
replacement of each subtype of its profile, see @ref{6.1}, that is of the
parent type with a corresponding subtype of the derived type. For a
given subtype of the parent type, the corresponding subtype of the
derived type is defined as follows:

@enumerate 19
@item
If the declaration of the derived type has neither a
known_discriminant_part nor a record_extension_part, then the
corresponding subtype has a constraint that corresponds (as defined
above for the first subtype of the derived type) to that of the given
subtype.

@item
If the derived type is a record extension, then the corresponding
subtype is the first subtype of the derived type.

@item
If the derived type has a new known_discriminant_part but is not a
record extension, then the corresponding subtype is constrained to those
values that when converted to the parent type belong to the given
subtype, see @ref{4.6}.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 22
@item
The same formal parameters have default_expressions in the profile of
the inherited subprogram. Any type mismatch due to the systematic
replacement of the parent type by the derived type is handled as part of
the normal type conversion associated with parameter passing --
see @ref{6.4.1}.
@end enumerate
@end enumerate

@enumerate 23
@item
If a primitive subprogram of the parent type is visible at the place of
the derived_type_definition, then the corresponding inherited subprogram
is implicitly declared immediately after the derived_type_definition.
Otherwise, the inherited subprogram is implicitly declared later or not
at all, as explained in @ref{7.3.1}.

@item
A derived type can also be defined by a private_extension_declaration
(@pxref{7.3}) or a formal_derived_type_definition, see @ref{12.5.1}. Such a
derived type is a partial view of the corresponding full or actual type.

@item
All numeric types are derived types, in that they are implicitly derived
from a corresponding root numeric type (see @ref{3.5.4}, and @ref{3.5.6}).

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a derived_type_definition creates the derived type
and its first subtype, and consists of the elaboration of the
subtype_indication and the record_extension_part, if any. If the
subtype_indication depends on a discriminant, then only those
expressions that do not depend on a discriminant are evaluated.

@item
For the execution of a call on an inherited subprogram, a call on the
corresponding primitive subprogram of the parent type is performed; the
normal conversion of each actual parameter to the subtype of the
corresponding formal parameter, see @ref{6.4.1} performs any necessary type
conversion as well. If the result type of the inherited subprogram is
the derived type, the result of calling the parent's subprogram is
converted to the derived type.

NOTES

@item
(10) Classes are closed under derivation -- any class that contains a
type also contains its derivatives. Operations available for a given
class of types are available for the derived types in that class.

@item
(11) Evaluating an inherited enumeration literal is equivalent to
evaluating the corresponding enumeration literal of the parent type, and
then converting the result to the derived type. This follows from their
equivalence to parameterless functions.

@item
(12) A generic subprogram is not a subprogram, and hence cannot be a
primitive subprogram and cannot be inherited by a derived type. On the
other hand, an instance of a generic subprogram can be a primitive
subprogram, and hence can be inherited.

@item
(13) If the parent type is an access type, then the parent and the
derived type share the same storage pool; there is a null access value
for the derived type and it is the implicit initial value for the type
(@pxref{3.10}).

@item
(14) If the parent type is a boolean type, the predefined relational
operators of the derived type deliver a result of the predefined type
Boolean, see @ref{4.5.2}. If the parent type is an integer type, the right
operand of the predefined exponentiation operator is of the predefined
type Integer, see @ref{4.5.6}.

@item
(15) Any discriminants of the parent type are either all inherited, or
completely replaced with a new set of discriminants.

@item
(16) For an inherited subprogram, the subtype of a formal parameter of
the derived type need not have any value in common with the first
subtype of the derived type.

@item
(17) If the reserved word abstract is given in the declaration of a
type, the type is abstract, see @ref{3.9.3}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of derived type declarations:

@item
@example
type Local_Coordinate is new Coordinate;   --  two different types
type Midweek is new Day range Tue .. Thu;  --  see @ref{3.5.1}
type Counter is new Positive;              --  same range as Positive
@end example

@item
@example
type Special_Key is new Key_Manager.Key;   --  see @ref{7.3.1}
  -- the inherited subprograms have the following specifications:
  --         procedure Get_Key(K : out Special_Key);
  --         function "<"(X,Y : Special_Key) return Boolean;
@end example
@end enumerate

@menu
* 3.4.1:: Derivation Classes
@end menu

@c ---------------------------------------------------------------------------
@node 3.4.1, 3.5, 3.4, 3.4
@subsection Derivation Classes

@enumerate
@item
In addition to the various language-defined classes of types, types can
be grouped into derivation classes.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A derived type is derived from its parent type directly; it is derived
indirectly from any type from which its parent type is derived. The
derivation class of types for a type T (also called the class rooted at
T) is the set consisting of T (the root type of the class) and all types
derived from T (directly or indirectly) plus any associated universal or
class-wide types (defined below).

@item
Every type is either a specific type, a class-wide type, or a universal
type. A specific type is one defined by a type_declaration, a
formal_type_declaration, or a full type definition embedded in a
declaration for an object. Class-wide and universal types are implicitly
defined, to act as representatives for an entire class of types, as
follows:

@item
Class-wide types

@enumerate 5
Class-wide types are defined for (and belong to) each derivation class
rooted at a tagged type, see @ref{3.9}. Given a subtype S of a tagged type
T, S'Class is the subtype_mark for a corresponding subtype of the tagged
class-wide type T'Class. Such types are called ``class-wide'' because
when a formal parameter is defined to be of a class-wide type T'Class,
an actual parameter of any type in the derivation class rooted at T is
acceptable, see @ref{8.6}.

@item
The set of values for a class-wide type T'Class is the discriminated
union of the set of values of each specific type in the derivation class
rooted at T (the tag acts as the implicit discriminant --  see @ref{3.9}.).
Class-wide types have no primitive subprograms of their own. However, as
explained in @ref{3.9.2}, operands of a class-wide type T'Class can be
used as part of a dispatching call on a primitive subprogram of the type
T. The only components (including discriminants) of T'Class that are
visible are those of T. If S is a first subtype, then S'Class is a first
subtype.
@end enumerate
@end enumerate

@enumerate 6
@item
Universal types

@enumerate 7
Universal types are defined for (and belong to) the integer, real, and
fixed point classes, and are referred to in this standard as
respectively, universal_integer, universal_real, and universal_fixed.
These are analogous to class-wide types for these language-defined
numeric classes. As with class-wide types, if a formal parameter is of a
universal type, then an actual parameter of any type in the
corresponding class is acceptable. In addition, a value of a universal
type (including an integer or real numeric_literal) is ``universal'' in
that it is acceptable where some particular type in the class is
expected, see @ref{8.6}.

@item
The set of values of a universal type is the undiscriminated union of
the set of values possible for any definable type in the associated
class. Like class-wide types, universal types have no primitive
subprograms of their own. However, their ``universality'' allows them to
be used as operands with the primitive subprograms of any type in the
corresponding class.
@end enumerate
@end enumerate

@enumerate 8
@item
The integer and real numeric classes each have a specific root type in
addition to their universal type, named respectively root_integer and
root_real.

@item
A class-wide or universal type is said to cover all of the types in its
class. A specific type covers only itself.

@item
A specific type T2 is defined to be a descendant of a type T1 if T2 is
the same as T1, or if T2 is derived (directly or indirectly) from T1. A
class-wide type T2'Class is defined to be a descendant of type T1 if T2
is a descendant of T1. Similarly, the universal types are defined to be
descendants of the root types of their classes. If a type T2 is a
descendant of a type T1, then T1 is called an ancestor of T2. The
ultimate ancestor of a type is the ancestor of the type that is not a
descendant of any other type.

@item
An inherited component (including an inherited discriminant) of a
derived type is inherited from a given ancestor of the type if the
corresponding component was inherited by each derived type in the chain
of derivations going back to the given ancestor.

NOTES

@item
(18) Because operands of a universal type are acceptable to the
predefined operators of any type in their class, ambiguity can result.
For universal_integer and universal_real, this potential ambiguity is
resolved by giving a preference, see @ref{8.6} to the predefined operators
of the corresponding root types (root_integer and root_real,
respectively). Hence, in an apparently ambiguous expression like

@item
@example
1 + 4 < 7
@end example

@item
where each of the literals is of type universal_integer, the predefined
operators of root_integer will be preferred over those of other specific
integer types, thereby resolving the ambiguity.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5, 3.5.1, 3.4.1, 3
@section Scalar Types

@enumerate
@item
Scalar types comprise enumeration types, integer types, and real types.
Enumeration types and integer types are called discrete types; each
value of a discrete type has a position number which is an integer
value. Integer types and real types are called numeric types. All scalar
types are ordered, that is, all relational operators are predefined for
their values.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
range_constraint ::= range range
@end example

@item
@example
range ::=
     range_attribute_reference
   | simple_expression .. simple_expression
@end example

@item
A range has a lower bound and an upper bound and specifies a subset of
the values of some scalar type (the type of the range). A range with
lower bound L and upper bound R is described by ``L .. R''. If R is less
than L, then the range is a null range, and specifies an empty set of
values. Otherwise, the range specifies the values of the type from the
lower bound to the upper bound, inclusive. A value belongs to a range if
it is of the type of the range, and is in the subset of values specified
by the range. A value satisfies a range constraint if it belongs to the
associated range. One range is included in another if all values that
belong to the first range also belong to the second.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For a subtype_indication containing a range_constraint, either directly
or as part of some other scalar_constraint, the type of the range shall
resolve to that of the type determined by the subtype_mark of the
subtype_indication. For a range of a given type, the simple_expressions
of the range (likewise, the simple_expressions of the equivalent range
for a range_attribute_reference) are expected to be of the type of the
range.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The base range of a scalar type is the range of finite values of the
type that can be represented in every unconstrained object of the type;
it is also the range supported at a minimum for intermediate values
during the evaluation of expressions involving predefined operators of
the type.

@item
A constrained scalar subtype is one to which a range constraint applies.
The range of a constrained scalar subtype is the range associated with
the range constraint of the subtype. The range of an unconstrained
scalar subtype is the base range of its type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A range is compatible with a scalar subtype if and only if it is either
a null range or each bound of the range belongs to the range of the
subtype. A range_constraint is compatible with a scalar subtype if and
only if its range is compatible with the subtype.

@item
The elaboration of a range_constraint consists of the evaluation of the
range. The evaluation of a range determines a lower bound and an upper
bound. If simple_expressions are given to specify bounds, the evaluation
of the range evaluates these simple_expressions in an arbitrary order,
and converts them to the type of the range. If a
range_attribute_reference is given, the evaluation of the range consists
of the evaluation of the range_attribute_reference.

@item
Attributes

@item
For every scalar subtype S, the following attributes are defined:

@item
S'First

@example
S'First denotes the lower bound of the range of S. The value
of this attribute is of the type of S.
@end example

@item
S'Last

@example
S'Last denotes the upper bound of the range of S. The value
of this attribute is of the type of S.
@end example

@item
S'Range

@example
S'Range is equivalent to the range S'First .. S'Last.
@end example

@item
S'Base

@example
S'Base denotes an unconstrained subtype of the type of
S. This unconstrained subtype is called the base subtype of
the type.
@end example

@item
S'Min

@enumerate 17
S'Min denotes a function with the following specification:

@item
@example
function S'Min(Left, Right : S'Base)
  return S'Base
@end example

@item
The function returns the lesser of the values of the two parameters.
@end enumerate
@end enumerate

@enumerate 19
@item
S'Max

@enumerate 20
S'Max denotes a function with the following specification:

@item
@example
function S'Max(Left, Right : S'Base)
  return S'Base
@end example

@item
The function returns the greater of the values of the two parameters.
@end enumerate
@end enumerate

@enumerate 22
@item
S'Succ

@enumerate 23
S'Succ denotes a function with the following specification:

@item
@example
function S'Succ(Arg : S'Base)
  return S'Base
@end example

@item
For an enumeration type, the function returns the value whose position
number is one more than that of the value of Arg; Constraint_Error is
raised if there is no such value of the type. For an integer type, the
function returns the result of adding one to the value of Arg. For a
fixed point type, the function returns the result of adding small to the
value of Arg. For a floating point type, the function returns the
machine number (as defined in @ref{3.5.7}.) immediately above the value
of Arg; Constraint_Error is raised if there is no such machine number.
@end enumerate
@end enumerate

@enumerate 25
@item
S'Pred

@enumerate 26
S'Pred denotes a function with the following specification:

@item
@example
function S'Pred(Arg : S'Base)
  return S'Base
@end example

@item
For an enumeration type, the function returns the value whose position
number is one less than that of the value of Arg; Constraint_Error is
raised if there is no such value of the type. For an integer type, the
function returns the result of subtracting one from the value of Arg.
For a fixed point type, the function returns the result of subtracting
small from the value of Arg. For a floating point type, the function
returns the machine number (as defined in @ref{3.5.7}.) immediately
below the value of Arg; Constraint_Error is raised if there is no such
machine number.
@end enumerate
@end enumerate

@enumerate 28
@item
S'Wide_Image

@enumerate 29
S'Wide_Image denotes a function with the following
specification:

@item
@example
function S'Wide_Image(Arg : S'Base)
  return Wide_String
@end example

@item
The function returns an image of the value of Arg, that is, a sequence
of characters representing the value in display form. The lower bound of
the result is one.

@item
The image of an integer value is the corresponding decimal literal,
without underlines, leading zeros, exponent, or trailing spaces, but
with a single leading character that is either a minus sign or a space.

@item
The image of an enumeration value is either the corresponding identifier
in upper case or the corresponding character literal (including the two
apostrophes); neither leading nor trailing spaces are included. For a
nongraphic character (a value of a character type that has no
enumeration literal associated with it), the result is a corresponding
language-defined or implementation-defined name in upper case (for
example, the image of the nongraphic character identified as nul is
``NUL'' -- the quotes are not part of the image).

@item
The image of a floating point value is a decimal real literal best
approximating the value (rounded away from zero if halfway between) with
a single leading character that is either a minus sign or a space, a
single digit (that is nonzero unless the value is zero), a decimal
point, S'Digits-1, see @ref{3.5.8}, digits after the decimal point (but one
if S'Digits is one), an upper case E, the sign of the exponent (either +
or -), and two or more digits (with leading zeros if necessary)
representing the exponent. If S'Signed_Zeros is True, then the leading
character is a minus sign for a negatively signed zero.

@item
The image of a fixed point value is a decimal real literal best
approximating the value (rounded away from zero if halfway between) with
a single leading character that is either a minus sign or a space, one
or more digits before the decimal point (with no redundant leading
zeros), a decimal point, and S'Aft, see @ref{3.5.10}, digits after the
decimal point.
@end enumerate
@end enumerate

@enumerate 35
@item
S'Image

@enumerate 36
S'Image denotes a function with the following specification:

@item
@example
function S'Image(Arg : S'Base)
  return String
@end example

@item
The function returns an image of the value of Arg as a String. The lower
bound of the result is one. The image has the same sequence of graphic
characters as that defined for S'Wide_Image if all the graphic
characters are defined in Character; otherwise the sequence of
characters is implementation defined (but no shorter than that of
S'Wide_Image for the same value of Arg).
@end enumerate
@end enumerate

@enumerate 38
@item
S'Wide_Width

@example
S'Wide_Width denotes the maximum length of a Wide_String
returned by S'Wide_Image over all values of the subtype S. It
denotes zero for a subtype that has a null range. Its type
is universal_integer.
@end example

@item
S'Width

@example
S'Width denotes the maximum length of a String returned by
S'Image over all values of the subtype S. It denotes
zero for a subtype that has a null range. Its type is
universal_integer.
@end example

@item
S'Wide_Value

@enumerate 41
S'Wide_Value denotes a function with the following
specification:

@item
@example
function S'Wide_Value(Arg : Wide_String)
  return S'Base
@end example

@item
This function returns a value given an image of the value as a
Wide_String, ignoring any leading or trailing spaces.

@item
For the evaluation of a call on S'Wide_Value for an enumeration subtype
S, if the sequence of characters of the parameter (ignoring leading and
trailing spaces) has the syntax of an enumeration literal and if it
corresponds to a literal of the type of S (or corresponds to the result
of S'Wide_Image for a nongraphic character of the type), the result is
the corresponding enumeration value; otherwise Constraint_Error is
raised.

@item
For the evaluation of a call on S'Wide_Value (or S'Value) for an integer
subtype S, if the sequence of characters of the parameter (ignoring
leading and trailing spaces) has the syntax of an integer literal, with
an optional leading sign character (plus or minus for a signed type;
only plus for a modular type), and the corresponding numeric value
belongs to the base range of the type of S, then that value is the
result; otherwise Constraint_Error is raised.

@item
For the evaluation of a call on S'Wide_Value (or S'Value) for a real
subtype S, if the sequence of characters of the parameter (ignoring
leading and trailing spaces) has the syntax of one of the following:

@enumerate 47
@item
numeric_literal

@item
numeral.[exponent]

@item
.numeral[exponent]

@item
base#based_numeral.#[exponent]

@item
base#.based_numeral#[exponent]
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 51
@item
with an optional leading sign character (plus or minus), and if the
corresponding numeric value belongs to the base range of the type of S,
then that value is the result; otherwise Constraint_Error is raised. The
sign of a zero value is preserved (positive if none has been specified)
if S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 52
@item
S'Value

@enumerate 53
S'Value denotes a function with the following specification:

@item
@example
function S'Value(Arg : String)
  return S'Base
@end example

@item
This function returns a value given an image of the value as a String,
ignoring any leading or trailing spaces.

@item
For the evaluation of a call on S'Value for an enumeration subtype S, if
the sequence of characters of the parameter (ignoring leading and
trailing spaces) has the syntax of an enumeration literal and if it
corresponds to a literal of the type of S (or corresponds to the result
of S'Image for a value of the type), the result is the corresponding
enumeration value; otherwise Constraint_Error is raised. For a numeric
subtype S, the evaluation of a call on S'Value with Arg of type String
is equivalent to a call on S'Wide_Value for a corresponding Arg of type
Wide_String.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 56
@item
An implementation may extend the Wide_Value, Value, Wide_Image, and
Image attributes of a floating point type to support special values such
as infinities and NaNs.

NOTES

@item
(19) The evaluation of S'First or S'Last never raises an exception. If a
scalar subtype S has a nonnull range, S'First and S'Last belong to this
range. These values can, for example, always be assigned to a variable
of subtype S.

@item
(20) For a subtype of a scalar type, the result delivered by the
attributes Succ, Pred, and Value might not belong to the subtype;
similarly, the actual parameters of the attributes Succ, Pred, and Image
need not belong to the subtype.

@item
(21) For any value V (including any nongraphic character) of an
enumeration subtype S, S'Value(S'Image(V)) equals V, as does
S'Wide_Value(S'Wide_Image(V)). Neither expression ever raises
Constraint_Error.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of ranges:

@item
@example
-10 .. 10
X .. X + 1
0.0 .. 2.0*Pi
Red .. Green     --  see @ref{3.5.1}
1 .. 0           -- a null range
Table'Range      -- a range attribute reference, see @ref{3.6}
@end example

@item
Examples of range constraints:

@item
@example
range -999.0 .. +999.0
range S'First+1 .. S'Last-1
@end example
@end enumerate

@menu
* 3.5.1::  Enumeration Types
* 3.5.2::  Character Types
* 3.5.3::  Boolean Types
* 3.5.4::  Integer Types
* 3.5.5::  Operations of Discrete Types
* 3.5.6::  Real Types
* 3.5.7::  Floating Point Types
* 3.5.8::  Operations of Floating Point Types
* 3.5.9::  Fixed Point Types
* 3.5.10:: Operations of Fixed Point Types
@end menu

@c ---------------------------------------------------------------------------
@node 3.5.1, 3.5.2, 3.5, 3.5
@subsection Enumeration Types

@enumerate
@item
An enumeration_type_definition defines an enumeration type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
enumeration_type_definition ::=
   (enumeration_literal_specification
     @{, enumeration_literal_specification@})
@end example

@item
@example
enumeration_literal_specification ::=
   defining_identifier | defining_character_literal
@end example

@item
@example
defining_character_literal ::= character_literal
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The defining_identifiers and defining_character_literals listed in an
enumeration_type_definition shall be distinct.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Each enumeration_literal_specification is the explicit declaration of
the corresponding enumeration literal: it declares a parameterless
function, whose defining name is the defining_identifier or
defining_character_literal, and whose result type is the enumeration
type.

@item
Each enumeration literal corresponds to a distinct value of the
enumeration type, and to a distinct position number. The position number
of the value of the first listed enumeration literal is zero; the
position number of the value of each subsequent enumeration literal is
one more than that of its predecessor in the list.

@item
The predefined order relations between values of the enumeration type
follow the order of corresponding position numbers.

@item
If the same defining_identifier or defining_character_literal is
specified in more than one enumeration_type_definition, the
corresponding enumeration literals are said to be overloaded. At any
place where an overloaded enumeration literal occurs in the text of a
program, the type of the enumeration literal has to be determinable from
the context, see @ref{8.6}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of an enumeration_type_definition creates the
enumeration type and its first subtype, which is constrained to the base
range of the type.

@item
When called, the parameterless function associated with an enumeration
literal returns the corresponding value of the enumeration type.

NOTES

@item
(22) If an enumeration literal occurs in a context that does not
otherwise suffice to determine the type of the literal, then
qualification by the name of the enumeration type is one way to resolve
the ambiguity, see @ref{4.7}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of enumeration types and subtypes:

@item
@example
type Day    is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
type Suit   is (Clubs, Diamonds, Hearts, Spades);
type Gender is (M, F);
type Level  is (Low, Medium, Urgent);
type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);
type Light  is (Red, Amber, Green); -- Red and Green are overloaded
@end example

@item
@example
type Hexa   is ('A', 'B', 'C', 'D', 'E', 'F');
type Mixed  is ('A', 'B', '*', B, None, '?', '%');
@end example

@item
@example
subtype Weekday is Day   range Mon .. Fri;
subtype Major   is Suit  range Hearts .. Spades;
subtype Rainbow is Color range Red .. Blue;
--  the Color Red, not the Light
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.2, 3.5.3, 3.5.1, 3.5
@subsection Character Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
An enumeration type is said to be a character type if at least one of
its enumeration literals is a character_literal.

@item
The predefined type Character is a character type whose values
correspond to the 256 code positions of Row 00 (also known as Latin-1)
of the ISO 10646 Basic Multilingual Plane (BMP). Each of the graphic
characters of Row 00 of the BMP has a corresponding character_literal in
Character. Each of the nongraphic positions of Row 00 (0000-001F and
007F-009F) has a corresponding language-defined name, which is not
usable as an enumeration literal, but which is usable with the
attributes (Wide_)Image and (Wide_)Value; these names are given in the
definition of type Character in @ref{A.1, ``The Package Standard''},
but are set in italics.

@item
The predefined type Wide_Character is a character type whose values
correspond to the 65536 code positions of the ISO 10646 Basic
Multilingual Plane (BMP). Each of the graphic characters of the BMP has
a corresponding character_literal in Wide_Character. The first 256
values of Wide_Character have the same character_literal or
language-defined name as defined for Character. The last 2 values of
Wide_Character correspond to the nongraphic positions FFFE and FFFF of
the BMP, and are assigned the language-defined names FFFE and FFFF. As
with the other language-defined names for nongraphic characters, the
names FFFE and FFFF are usable only with the attributes (Wide_)Image and
(Wide_)Value; they are not usable as enumeration literals. All other
values of Wide_Character are considered graphic characters, and have a
corresponding character_literal.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
In a nonstandard mode, an implementation may provide other
interpretations for the predefined types Character and Wide_Character,
to conform to local conventions.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If an implementation supports a mode with alternative interpretations
for Character and Wide_Character, the set of graphic characters of
Character should nevertheless remain a proper subset of the set of
graphic characters of Wide_Character. Any character set
``localizations'' should be reflected in the results of the subprograms
defined in the language-defined package Characters.Handling, see @ref{A.3},
available in such a mode. In a mode with an alternative interpretation
of Character, the implementation should also support a corresponding
change in what is a legal identifier_letter.

NOTES

@item
(23) The language-defined library package Characters.Latin_1
(@ref{A.3.3}) includes the declaration of constants denoting control
characters, lower case characters, and special characters of the
predefined type Character.

@item
(24) A conventional character set such as EBCDIC can be declared as a
character type; the internal codes of the characters can be specified by
an enumeration_representation_clause as explained in clause (@pxref{13.4}).

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a character type:

@item
@example
type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M');
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.3, 3.5.4, 3.5.2, 3.5
@subsection Boolean Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
There is a predefined enumeration type named Boolean, declared in the
visible part of package Standard. It has the two enumeration literals
False and True ordered with the relation False < True. Any descendant of
the predefined type Boolean is called a boolean type.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.4, 3.5.5, 3.5.3, 3.5
@subsection Integer Types

@enumerate
@item
An integer_type_definition defines an integer type; it defines either a
signed integer type, or a modular integer type. The base range of a
signed integer type includes at least the values of the specified range.
A modular type is an integer type with all arithmetic modulo a specified
positive modulus; such a type corresponds to an unsigned type with
wrap-around semantics.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
integer_type_definition ::=
   signed_integer_type_definition | modular_type_definition
@end example

@item
@example
signed_integer_type_definition ::=
   range static_simple_expression .. static_simple_expression
@end example

@item
@example
modular_type_definition ::= mod static_expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Each simple_expression in a signed_integer_type_definition is expected
to be of any integer type; they need not be of the same type. The
expression in a modular_type_definition is likewise expected to be of
any integer type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The simple_expressions of a signed_integer_type_definition shall be
static, and their values shall be in the range System.Min_Int ..
System.Max_Int.

@item
The expression of a modular_type_definition shall be static, and its
value (the modulus) shall be positive, and shall be no greater than
System.Max_Binary_Modulus if a power of 2, or no greater than
System.Max_Nonbinary_Modulus if not.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The set of values for a signed integer type is the (infinite) set of
mathematical integers, though only values of the base range of the type
are fully supported for run-time operations. The set of values for a
modular integer type are the values from 0 to one less than the modulus,
inclusive.

@item
A signed_integer_type_definition defines an integer type whose base
range includes at least the values of the simple_expressions and is
symmetric about zero, excepting possibly an extra negative value. A
signed_integer_type_definition also defines a constrained first subtype
of the type, with a range whose bounds are given by the values of the
simple_expressions, converted to the type being defined.

@item
A modular_type_definition defines a modular type whose base range is
from zero to one less than the given modulus. A modular_type_definition
also defines a constrained first subtype of the type with a range that
is the same as the base range of the type.

@item
There is a predefined signed integer subtype named Integer, declared in
the visible part of package Standard. It is constrained to the base
range of its type.

@item
Integer has two predefined subtypes, declared in the visible part of
package Standard:

@item
@example
subtype Natural  is Integer range 0 .. Integer'Last;
subtype Positive is Integer range 1 .. Integer'Last;
@end example

@item
A type defined by an integer_type_definition is implicitly derived from
root_integer, an anonymous predefined (specific) integer type, whose
base range is System.Min_Int .. System.Max_Int. However, the base range
of the new type is not inherited from root_integer, but is instead
determined by the range or modulus specified by the
integer_type_definition. Integer literals are all of the type
universal_integer, the universal type, see @ref{3.4.1}, for the class
rooted at root_integer, allowing their use with the operations of any
integer type.

@item
The position number of an integer value is equal to the value.

@item
For every modular subtype S, the following attribute is defined:

@item
S'Modulus

@example
S'Modulus yields the modulus of the type of S, as a value of
the type universal_integer.
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of an integer_type_definition creates the integer type
and its first subtype.

@item
For a modular type, if the result of the execution of a predefined
operator, see @ref{4.5} is outside the base range of the type, the result
is reduced modulo the modulus of the type to a value that is within the
base range of the type.

@item
For a signed integer type, the exception Constraint_Error is raised by
the execution of an operation that cannot deliver the correct result
because it is outside the base range of the type. For any integer type,
Constraint_Error is raised by the operators "/", "rem", and "mod" if the
right operand is zero.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
In an implementation, the range of Integer shall include the range
-2**15+1 .. +2**15-1.

@item
If Long_Integer is predefined for an implementation, then its range
shall include the range -2**31+1 .. +2**31-1.

@item
System.Max_Binary_Modulus shall be at least 2**16.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
For the execution of a predefined operation of a signed integer type,
the implementation need not raise Constraint_Error if the result is
outside the base range of the type, so long as the correct result is
produced.

@item
An implementation may provide additional predefined signed integer
types, declared in the visible part of Standard, whose first subtypes
have names of the form Short_Integer, Long_Integer, Short_Short_Integer,
Long_Long_Integer, etc. Different predefined integer types are allowed
to have the same base range. However, the range of Integer should be no
wider than that of Long_Integer. Similarly, the range of Short_Integer
(if provided) should be no wider than Integer. Corresponding
recommendations apply to any other predefined integer types. There need
not be a named integer type corresponding to each distinct base range
supported by an implementation. The range of each first subtype should
be the base range of its type.

@item
An implementation may provide nonstandard integer types, descendants of
root_integer that are declared outside of the specification of package
Standard, which need not have all the standard characteristics of a type
defined by an integer_type_definition. For example, a nonstandard
integer type might have an asymmetric base range or it might not be
allowed as an array or loop index (a very long integer). Any type
descended from a nonstandard integer type is also nonstandard. An
implementation may place arbitrary restrictions on the use of such
types; it is implementation defined whether operators that are
predefined for ``any integer type'' are defined for a particular
nonstandard integer type. In any case, such types are not permitted as
explicit_generic_actual_parameters for formal scalar types --
see @ref{12.5.2}.

@item
For a one's complement machine, the high bound of the base range of a
modular type whose modulus is one less than a power of 2 may be equal to
the modulus, rather than one less than the modulus. It is implementation
defined for which powers of 2, if any, this permission is exercised.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An implementation should support Long_Integer in addition to Integer if
the target machine supports 32-bit (or longer) arithmetic. No other
named integer subtypes are recommended for package Standard. Instead,
appropriate named integer subtypes should be provided in the library
package Interfaces, see @ref{B.2}.

@item
An implementation for a two's complement machine should support modular
types with a binary modulus up to System.Max_Int*2+2. An implementation
should support a nonbinary modulus up to Integer'Last.

NOTES

@item
(25) Integer literals are of the anonymous predefined integer type
universal_integer. Other integer types have no literals. However, the
overload resolution rules, see @ref{8.6, ``The Context of Overload
Resolution''}, allow expressions of the type universal_integer whenever
an integer type is expected.

@item
(26) The same arithmetic operators are predefined for all signed integer
types defined by a signed_integer_type_definition, see @ref{4.5,
``Operators and Expression Evaluation''}. For modular types, these same
operators are predefined, plus bit-wise logical operators (and, or, xor,
and not). In addition, for the unsigned types declared in the
language-defined package Interfaces, see @ref{B.2}, functions are defined
that provide bit-wise shifting and rotating.

@item
(27) Modular types match a generic_formal_parameter_declaration of the
form "type T is mod <>;"; signed integer types match "type T is range
<>;", see @ref{12.5.2}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of integer types and subtypes:

@item
@example
type Page_Num  is range 1 .. 2_000;
type Line_Size is range 1 .. Max_Line_Size;
@end example

@item
@example
subtype Small_Int   is Integer   range -10 .. 10;
subtype Column_Ptr  is Line_Size range 1 .. 10;
subtype Buffer_Size is Integer   range 0 .. Max;
@end example

@item
@example
type Byte        is mod 256; -- an unsigned byte
type Hash_Index  is mod 97;  -- modulus is prime
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.5, 3.5.6, 3.5.4, 3.5
@subsection Operations of Discrete Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
For every discrete subtype S, the following attributes are defined:

@item
S'Pos

@enumerate 3
S'Pos denotes a function with the following specification:

@item
@example
function S'Pos(Arg : S'Base)
  return universal_integer
@end example

@item
This function returns the position number of the value of Arg, as a
value of type universal_integer.
@end enumerate
@end enumerate

@enumerate 5
@item
S'Val

@enumerate 6
S'Val denotes a function with the following specification:

@item
@example
function S'Val(Arg : universal_integer)
  return S'Base
@end example

@item
This function returns a value of the type of S whose position number
equals the value of Arg. For the evaluation of a call on S'Val, if there
is no value in the base range of its type with the given position
number, Constraint_Error is raised.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 8
@item
For the evaluation of a call on S'Pos for an enumeration subtype, if the
value of the operand does not correspond to the internal code for any
enumeration literal of its type (perhaps due to an uninitialized
variable), then the implementation should raise Program_Error. This is
particularly important for enumeration types with noncontiguous internal
codes specified by an enumeration_representation_clause.

NOTES

@item
(28) Indexing and loop iteration use values of discrete types.

@item
(29) The predefined operations of a discrete type include the assignment
operation, qualification, the membership tests, and the relational
operators; for a boolean type they include the short-circuit control
forms and the logical operators; for an integer type they include type
conversion to and from other numeric types, as well as the binary and
unary adding operators - and +, the multiplying operators, the unary
operator abs, and the exponentiation operator. The assignment operation
is described in @ref{5.2}. The other predefined operations are described in
Section @ref{4}.

@item
(30) As for all types, objects of a discrete type have Size and Address
attributes, see @ref{13.3}.

@item
(31) For a subtype of a discrete type, the result delivered by the
attribute Val might not belong to the subtype; similarly, the actual
parameter of the attribute Pos need not belong to the subtype. The
following relations are satisfied (in the absence of an exception) by
these attributes:

@item
@example
S'Val(S'Pos(X)) = X
S'Pos(S'Val(N)) = N
@end example

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of attributes of discrete subtypes:

@item
@example
--  For the types and subtypes declared in subclause
--  see @ref{3.5.1}, the following hold:
@end example

@item
@example
--  Color'First   = White,   Color'Last   = Black
--  Rainbow'First = Red,     Rainbow'Last = Blue
@end example

@item
@example
--  Color'Succ(Blue) = Rainbow'Succ(Blue) = Brown
--  Color'Pos(Blue)  = Rainbow'Pos(Blue)  = 4
--  Color'Val(0)     = Rainbow'Val(0)     = White
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.6, 3.5.7, 3.5.5, 3.5
@subsection Real Types

@enumerate
@item
Real types provide approximations to the real numbers, with relative
bounds on errors for floating point types, and with absolute bounds for
fixed point types.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
real_type_definition ::=
   floating_point_definition | fixed_point_definition
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A type defined by a real_type_definition is implicitly derived from
root_real, an anonymous predefined (specific) real type. Hence, all real
types, whether floating point or fixed point, are in the derivation
class rooted at root_real.

@item
Real literals are all of the type universal_real, the universal type
(@pxref{3.4.1}) for the class rooted at root_real, allowing their use with
the operations of any real type. Certain multiplying operators have a
result type of universal_fixed, see @ref{4.5.5}, the universal type for the
class of fixed point types, allowing the result of the multiplication or
division to be used where any specific fixed point type is expected.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a real_type_definition consists of the elaboration of
the floating_point_definition or the fixed_point_definition.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
An implementation shall perform the run-time evaluation of a use of a
predefined operator of root_real with an accuracy at least as great as
that of any floating point type definable by a
floating_point_definition.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
For the execution of a predefined operation of a real type, the
implementation need not raise Constraint_Error if the result is outside
the base range of the type, so long as the correct result is produced,
or the Machine_Overflows attribute of the type is false, see @ref{G.2}.

@item
An implementation may provide nonstandard real types, descendants of
root_real that are declared outside of the specification of package
Standard, which need not have all the standard characteristics of a type
defined by a real_type_definition. For example, a nonstandard real type
might have an asymmetric or unsigned base range, or its predefined
operations might wrap around or ``saturate'' rather than overflow
(modular or saturating arithmetic), or it might not conform to the
accuracy model, see @ref{G.2}. Any type descended from a nonstandard real
type is also nonstandard. An implementation may place arbitrary
restrictions on the use of such types; it is implementation defined
whether operators that are predefined for ``any real type'' are defined
for a particular nonstandard real type. In any case, such types are not
permitted as explicit_generic_actual_parameters for formal scalar types
--  see @ref{12.5.2}.

NOTES

@item
(32) As stated, real literals are of the anonymous predefined real type
universal_real. Other real types have no literals. However, the
overload resolution rules, see @ref{8.6}, allow expressions of the type
universal_real whenever a real type is expected.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.7, 3.5.8, 3.5.6, 3.5
@subsection Floating Point Types

@enumerate
@item
For floating point types, the error bound is specified as a relative
precision by giving the required minimum number of significant decimal
digits.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
floating_point_definition ::=
   digits static_expression [real_range_specification]
@end example

@item
@example
real_range_specification ::=
   range static_simple_expression .. static_simple_expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The requested decimal precision, which is the minimum number of
significant decimal digits required for the floating point type, is
specified by the value of the expression given after the reserved word
digits. This expression is expected to be of any integer type.

@item
Each simple_expression of a real_range_specification is expected to be
of any real type; the types need not be the same.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The requested decimal precision shall be specified by a static
expression whose value is positive and no greater than
System.Max_Base_Digits. Each simple_expression of a
real_range_specification shall also be static. If the
real_range_specification is omitted, the requested decimal precision
shall be no greater than System.Max_Digits.

@item
A floating_point_definition is illegal if the implementation does not
support a floating point type that satisfies the requested decimal
precision and range.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The set of values for a floating point type is the (infinite) set of
rational numbers. The machine numbers of a floating point type are the
values of the type that can be represented exactly in every
unconstrained variable of the type. The base range, see @ref{3.5}, of a
floating point type is symmetric around zero, except that it can include
some extra negative values in some implementations.

@item
The base decimal precision of a floating point type is the number of
decimal digits of precision representable in objects of the type. The
safe range of a floating point type is that part of its base range for
which the accuracy corresponding to the base decimal precision is
preserved by all predefined operations.

@item
A floating_point_definition defines a floating point type whose base
decimal precision is no less than the requested decimal precision. If a
real_range_specification is given, the safe range of the floating point
type (and hence, also its base range) includes at least the values of
the simple expressions given in the real_range_specification. If a
real_range_specification is not given, the safe (and base) range of the
type includes at least the values of the range -10.0**(4*D) ..
+10.0**(4*D) where D is the requested decimal precision. The safe range
might include other values as well. The attributes Safe_First and
Safe_Last give the actual bounds of the safe range.

@item
A floating_point_definition also defines a first subtype of the type. If
a real_range_specification is given, then the subtype is constrained to
a range whose bounds are given by a conversion of the values of the
simple_expressions of the real_range_specification to the type being
defined. Otherwise, the subtype is unconstrained.

@item
There is a predefined, unconstrained, floating point subtype named
Float, declared in the visible part of package Standard.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a floating_point_definition creates the floating
point type and its first subtype.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
In an implementation that supports floating point types with 6 or more
digits of precision, the requested decimal precision for Float shall be
at least 6.

@item
If Long_Float is predefined for an implementation, then its requested
decimal precision shall be at least 11.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation is allowed to provide additional predefined floating
point types, declared in the visible part of Standard, whose
(unconstrained) first subtypes have names of the form Short_Float,
Long_Float, Short_Short_Float, Long_Long_Float, etc. Different
predefined floating point types are allowed to have the same base
decimal precision. However, the precision of Float should be no greater
than that of Long_Float. Similarly, the precision of Short_Float (if
provided) should be no greater than Float. Corresponding recommendations
apply to any other predefined floating point types. There need not be a
named floating point type corresponding to each distinct base decimal
precision supported by an implementation.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An implementation should support Long_Float in addition to Float if the
target machine supports 11 or more digits of precision. No other named
floating point subtypes are recommended for package Standard. Instead,
appropriate named floating point subtypes should be provided in the
library package Interfaces, see @ref{B.2}.

NOTES

@item
(33) If a floating point subtype is unconstrained, then assignments to
variables of the subtype involve only Overflow_Checks, never
Range_Checks.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of floating point types and subtypes:

@item
@example
type Coefficient is digits 10 range -1.0 .. 1.0;
@end example

@item
@example
type Real is digits 8;
type Mass is digits 7 range 0.0 .. 1.0E35;
@end example

@item
@example
subtype Probability is Real range 0.0 .. 1.0;
--  a subtype with a smaller range
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.8, 3.5.9, 3.5.7, 3.5
@subsection Operations of Floating Point Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following attribute is defined for every floating point subtype S:

@item
S'Digits

@example
S'Digits denotes the requested decimal precision for the
subtype S. The value of this attribute is of the type
universal_integer. The requested decimal precision of the
base subtype of a floating point type T is defined to be the
largest value of d for which ceiling(d * log(10) /
log(T'Machine_Radix)) + 1 <= T'Model_Mantissa.
@end example

NOTES

@item
(34) The predefined operations of a floating point type include the
assignment operation, qualification, the membership tests, and explicit
conversion to and from other numeric types. They also include the
relational operators and the following predefined arithmetic operators:
the binary and unary adding operators - and +, certain multiplying
operators, the unary operator abs, and the exponentiation operator.

@item
(35) As for all types, objects of a floating point type have Size and
Address attributes, see @ref{13.3}. Other attributes of floating point types
are defined in @ref{A.5.3}.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.9, 3.5.10, 3.5.8, 3.5
@subsection Fixed Point Types

@enumerate
@item
A fixed point type is either an ordinary fixed point type, or a decimal
fixed point type. The error bound of a fixed point type is specified as
an absolute value, called the delta of the fixed point type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
fixed_point_definition ::=
   ordinary_fixed_point_definition | decimal_fixed_point_definition
@end example

@item
@example
ordinary_fixed_point_definition ::=
   delta static_expression real_range_specification
@end example

@item
@example
decimal_fixed_point_definition ::=
   delta static_expression digits static_expression
     [real_range_specification]
@end example

@item
@example
digits_constraint ::=
   digits static_expression [range_constraint]
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For a type defined by a fixed_point_definition, the delta of the type is
specified by the value of the expression given after the reserved word
delta; this expression is expected to be of any real type. For a type
defined by a decimal_fixed_point_definition (a decimal fixed point
type), the number of significant decimal digits for its first subtype
(the digits of the first subtype) is specified by the expression given
after the reserved word digits; this expression is expected to be of any
integer type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
In a fixed_point_definition or digits_constraint, the expressions given
after the reserved words delta and digits shall be static; their values
shall be positive.

@item
The set of values of a fixed point type comprise the integral multiples
of a number called the small of the type. For a type defined by an
ordinary_fixed_point_definition (an ordinary fixed point type), the
small may be specified by an attribute_definition_clause, see @ref{13.3},
if so specified, it shall be no greater than the delta of the type. If
not specified, the small of an ordinary fixed point type is an
implementation-defined power of two less than or equal to the delta.

@item
For a decimal fixed point type, the small equals the delta; the delta
shall be a power of 10. If a real_range_specification is given, both
bounds of the range shall be in the range -(10**digits-1)*delta ..
+(10**digits-1)*delta.

@item
A fixed_point_definition is illegal if the implementation does not
support a fixed point type with the given small and specified range or
digits.

@item
For a subtype_indication with a digits_constraint, the subtype_mark
shall denote a decimal fixed point subtype.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The base range, see @ref{3.5} of a fixed point type is symmetric around
zero, except possibly for an extra negative value in some
implementations.

@item
An ordinary_fixed_point_definition defines an ordinary fixed point type
whose base range includes at least all multiples of small that are
between the bounds specified in the real_range_specification. The base
range of the type does not necessarily include the specified bounds
themselves. An ordinary_fixed_point_definition also defines a
constrained first subtype of the type, with each bound of its range
given by the closer to zero of:

@enumerate 14
@item
the value of the conversion to the fixed point type of the corresponding
expression of the real_range_specification;

@item
the corresponding bound of the base range.
@end enumerate
@end enumerate

@enumerate 16
@item
A decimal_fixed_point_definition defines a decimal fixed point type
whose base range includes at least the range -(10**digits-1)*delta ..
+(10**digits-1)*delta. A decimal_fixed_point_definition also defines a
constrained first subtype of the type. If a real_range_specification is
given, the bounds of the first subtype are given by a conversion of the
values of the expressions of the real_range_specification. Otherwise,
the range of the first subtype is -(10**digits-1)*delta ..
+(10**digits-1)*delta.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a fixed_point_definition creates the fixed point type
and its first subtype.

@item
For a digits_constraint on a decimal fixed point subtype with a given
delta, if it does not have a range_constraint, then it specifies an
implicit range -(10**D-1)*delta .. +(10**D-1)*delta, where D is the
value of the expression. A digits_constraint is compatible with a
decimal fixed point subtype if the value of the expression is no greater
than the digits of the subtype, and if it specifies (explicitly or
implicitly) a range that is compatible with the subtype.

@item
The elaboration of a digits_constraint consists of the elaboration of
the range_constraint, if any. If a range_constraint is given, a check is
made that the bounds of the range are both in the range -(10**D-1)*delta
.. +(10**D-1)*delta, where D is the value of the (static) expression
given after the reserved word digits. If this check fails,
Constraint_Error is raised.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall support at least 24 bits of precision
(including the sign bit) for fixed point types.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
Implementations are permitted to support only smalls that are a power of
two. In particular, all decimal fixed point type declarations can be
disallowed. Note however that conformance with the Information Systems
Annex requires support for decimal smalls, and decimal fixed point type
declarations with digits up to at least 18.

NOTES

@item
(36) The base range of an ordinary fixed point type need not include
the specified bounds themselves so that the range specification can be
given in a natural way, such as:

@item
@example
type Fraction is delta 2.0**(-15) range -1.0 .. 1.0;
@end example

@item
With 2's complement hardware, such a type could have a signed 16-bit
representation, using 1 bit for the sign and 15 bits for fraction,
resulting in a base range of -1.0 .. 1.0-2.0**(-15).

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of fixed point types and subtypes:

@item
@example
type Volt is delta 0.125 range 0.0 .. 255.0;
@end example

@item
@example
--  A pure fraction which requires all the available
--  space in a word can be declared as the type Fraction:

type Fraction is delta System.Fine_Delta range -1.0 .. 1.0;
--  Fraction'Last = 1.0 - System.Fine_Delta
@end example

@item
@example
type Money is delta 0.01 digits 15;  -- decimal fixed point
subtype Salary is Money digits 10;
  -- Money'Last = 10.0**13 - 0.01, Salary'Last = 10.0**8 - 0.01
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.5.10, 3.6, 3.5.9, 3.5
@subsection Operations of Fixed Point Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following attributes are defined for every fixed point subtype S:

@item
S'Small

@example
S'Small denotes the small of the type of S. The value of
this attribute is of the type universal_real. Small may
be specified for nonderived fixed point types via an
attribute_definition_clause, see @ref{13.3}; the expression
of such a clause shall be static.
@end example

@item
S'Delta

@example
S'Delta denotes the delta of the fixed point subtype S. The
value of this attribute is of the type universal_real.
@end example

@item
S'Fore

@example
S'Fore yields the minimum number of characters needed
before the decimal point for the decimal representation
of any value of the subtype S, assuming that the
representation does not include an exponent, but
includes a one-character prefix that is either a minus
sign or a space. (This minimum number does not include
superfluous zeros or underlines, and is at least 2.) The
value of this attribute is of the type
universal_integer.
@end example

@item
S'Aft

@example
S'Aft yields the number of decimal digits needed after the
decimal point to accommodate the delta of the subtype S,
unless the delta of the subtype S is greater than 0.1, in
which case the attribute yields the value one. (S'Aft is the
smallest positive integer N for which (10**N)*S'Delta is
greater than or equal to one.) The value of this attribute
is of the type universal_integer.
@end example

@item
The following additional attributes are defined for every decimal fixed
point subtype S:

@item
S'Digits

@example
S'Digits denotes the digits of the decimal fixed point
subtype S, which corresponds to the number of decimal digits
that are representable in objects of the subtype. The value
of this attribute is of the type universal_integer. Its
value is determined as follows:
@end example

@enumerate 8
@item
For a first subtype or a subtype defined by a subtype_indication with a
digits_constraint, the digits is the value of the expression given after
the reserved word digits;

@item
For a subtype defined by a subtype_indication without a
digits_constraint, the digits of the subtype is the same as that of the
subtype denoted by the subtype_mark in the subtype_indication.

@item
The digits of a base subtype is the largest integer D such that the
range -(10**D-1)*delta .. +(10**D-1)*delta is included in the base range
of the type.
@end enumerate
@end enumerate

@enumerate 11
@item
S'Scale

@example
S'Scale denotes the scale of the subtype S, defined as the
value N such that S'Delta = 10.0**(-N). The scale indicates
the position of the point relative to the rightmost
significant digits of values of subtype S. The value of this
attribute is of the type universal_integer.
@end example

@item
S'Round

@enumerate 13
S'Round denotes a function with the following specification:

@item
@example
function S'Round(X : universal_real)
  return S'Base
@end example

@item
The function returns the value obtained by rounding X (away from 0, if X
is midway between two values of the type of S).
@end enumerate
@end enumerate
@enumerate 15

NOTES

@item
(37) All subtypes of a fixed point type will have the same value for the
Delta attribute, in the absence of delta_constraints, see @ref{J.3}.

@item
(38) S'Scale is not always the same as S'Aft for a decimal subtype; for
example, if S'Delta = 1.0 then S'Aft is 1 while S'Scale is 0.

@item
(39) The predefined operations of a fixed point type include the
assignment operation, qualification, the membership tests, and explicit
conversion to and from other numeric types. They also include the
relational operators and the following predefined arithmetic operators:
the binary and unary adding operators - and +, multiplying operators,
and the unary operator abs.

@item
(40) As for all types, objects of a fixed point type have Size and
Address attributes, see @ref{13.3}. Other attributes of fixed point types
are defined in @ref{A.5.4}.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.6, 3.6.1, 3.5.10, 3
@section Array Types

@enumerate
@item
An array object is a composite object consisting of components which all
have the same subtype. The name for a component of an array uses one or
more index values belonging to specified discrete types. The value of an
array object is a composite value consisting of the values of the
components.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
array_type_definition ::=
   unconstrained_array_definition | constrained_array_definition
@end example

@item
@example
unconstrained_array_definition ::=
   array(index_subtype_definition @{, index_subtype_definition@})
     of component_definition
@end example

@item
@example
index_subtype_definition ::= subtype_mark range <>
@end example

@item
@example
constrained_array_definition ::=
   array (discrete_subtype_definition
     @{, discrete_subtype_definition@}) of component_definition
@end example

@item
@example
discrete_subtype_definition ::= discrete_subtype_indication | range
@end example

@item
@example
component_definition ::= [aliased] subtype_indication
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For a discrete_subtype_definition that is a range, the range shall
resolve to be of some specific discrete type; which discrete type shall
be determined without using any context other than the bounds of the
range itself (plus the preference for root_integer --  see @ref{8.6}.).

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
Each index_subtype_definition or discrete_subtype_definition in an
array_type_definition defines an index subtype; its type (the index
type) shall be discrete.

@item
The subtype defined by the subtype_indication of a component_definition
(the component subtype) shall be a definite subtype.

@item
Within the definition of a nonlimited composite type (or a limited
composite type that later in its immediate scope becomes nonlimited --
@ref{7.3.1}, and @ref{7.5}.), if a component_definition contains the
reserved word aliased and the type of the component is discriminated,
then the nominal subtype of the component shall be constrained.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An array is characterized by the number of indices (the dimensionality
of the array), the type and position of each index, the lower and upper
bounds for each index, and the subtype of the components. The order of
the indices is significant.

@item
A one-dimensional array has a distinct component for each possible index
value. A multidimensional array has a distinct component for each
possible sequence of index values that can be formed by selecting one
value for each index position (in the given order). The possible values
for a given index are all the values between the lower and upper bounds,
inclusive; this range of values is called the index range. The bounds of
an array are the bounds of its index ranges. The length of a dimension
of an array is the number of values of the index range of the dimension
(zero for a null range). The length of a one-dimensional array is the
length of its only dimension.

@item
An array_type_definition defines an array type and its first subtype.
For each object of this array type, the number of indices, the type and
position of each index, and the subtype of the components are as in the
type definition; the values of the lower and upper bounds for each index
belong to the corresponding index subtype of its type, except for null
arrays, see @ref{3.6.1}.

@item
An unconstrained_array_definition defines an array type with an
unconstrained first subtype. Each index_subtype_definition defines the
corresponding index subtype to be the subtype denoted by the
subtype_mark. The compound delimiter <> (called a box) of an
index_subtype_definition stands for an undefined range (different
objects of the type need not have the same bounds).

@item
A constrained_array_definition defines an array type with a constrained
first subtype. Each discrete_subtype_definition defines the
corresponding index subtype, as well as the corresponding index range
for the constrained first subtype. The constraint of the first subtype
consists of the bounds of the index ranges.

@item
The discrete subtype defined by a discrete_subtype_definition is either
that defined by the subtype_indication, or a subtype determined by the
range as follows:

@enumerate 18
@item
If the type of the range resolves to root_integer, then the
discrete_subtype_definition defines a subtype of the predefined type
Integer with bounds given by a conversion to Integer of the bounds of
the range;

@item
Otherwise, the discrete_subtype_definition defines a subtype of
the type of the range, with the bounds given by the range.
@end enumerate
@end enumerate

@enumerate 20
@item
The component_definition of an array_type_definition defines the nominal
subtype of the components. If the reserved word aliased appears in the
component_definition, then each component of the array is aliased,
see @ref{3.10}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of an array_type_definition creates the array type and
its first subtype, and consists of the elaboration of any
discrete_subtype_definitions and the component_definition.

@item
The elaboration of a discrete_subtype_definition creates the discrete
subtype, and consists of the elaboration of the subtype_indication or
the evaluation of the range. The elaboration of a component_definition
in an array_type_definition consists of the elaboration of the
subtype_indication. The elaboration of any discrete_subtype_definitions
and the elaboration of the component_definition are performed in an
arbitrary order.

NOTES

@item
(41) All components of an array have the same subtype. In particular,
for an array of components that are one-dimensional arrays, this means
that all components have the same bounds and hence the same length.

@item
(42) Each elaboration of an array_type_definition creates a distinct
array type. A consequence of this is that each object whose
object_declaration contains an array_type_definition is of its own
unique type.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of type declarations with unconstrained array definitions:

@item
@example
type Vector     is array(Integer  range <>) of Real;

type Matrix     is array(Integer  range <>, Integer range <>)
  of Real;

type Bit_Vector is array(Integer  range <>) of Boolean;

type Roman      is array(Positive range <>) of
  Roman_Digit;  --  see @ref{3.5.2}

@end example

@item
Examples of type declarations with constrained array definitions:

@item
@example
type Table    is array(1 .. 10) of Integer;
type Schedule is array(Day) of Boolean;
type Line     is array(1 .. Max_Line_Size) of Character;
@end example

@item
Examples of object declarations with array type definitions:

@item
@example
Grid : array(1 .. 80, 1 .. 100) of Boolean;
Mix  : array(Color range Red .. Green) of Boolean;
Page : array(Positive range <>) of Line :=  --  an array of arrays
  (1 | 50  => Line'(1 | Line'Last => '+', others => '-'),
  --  see @ref{4.3.3}
   2 .. 49 => Line'(1 | Line'Last => '|', others => ' '));
    -- Page is constrained by its initial value to (1..50)
@end example
@end enumerate

@menu
* 3.6.1:: Index Constraints and Discrete Ranges
* 3.6.2:: Operations of Array Types
* 3.6.3:: String Types
@end menu

@c ---------------------------------------------------------------------------
@node 3.6.1, 3.6.2, 3.6, 3.6
@subsection Index Constraints and Discrete Ranges

@enumerate
@item
An index_constraint determines the range of possible values for every
index of an array subtype, and thereby the corresponding array bounds.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
index_constraint ::= (discrete_range @{, discrete_range@})
@end example

@item
@example
discrete_range ::= discrete_subtype_indication | range
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The type of a discrete_range is the type of the subtype defined by the
subtype_indication, or the type of the range. For an index_constraint,
each discrete_range shall resolve to be of the type of the corresponding
index.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An index_constraint shall appear only in a subtype_indication whose
subtype_mark denotes either an unconstrained array subtype, or an
unconstrained access subtype whose designated subtype is an
unconstrained array subtype; in either case, the index_constraint shall
provide a discrete_range for each index of the array type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A discrete_range defines a range whose bounds are given by the range, or
by the range of the subtype defined by the subtype_indication.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
An index_constraint is compatible with an unconstrained array subtype if
and only if the index range defined by each discrete_range is
compatible, see @ref{3.5}, with the corresponding index subtype. If any of
the discrete_ranges defines a null range, any array thus constrained is
a null array, having no components. An array value satisfies an
index_constraint if at each index position the array value and the
index_constraint have the same index bounds.

@item
The elaboration of an index_constraint consists of the evaluation of the
discrete_range(s), in an arbitrary order. The evaluation of a
discrete_range consists of the elaboration of the subtype_indication or
the evaluation of the range.

NOTES

@item
(43) The elaboration of a subtype_indication consisting of a
subtype_mark followed by an index_constraint checks the compatibility of
the index_constraint with the subtype_mark, see @ref{3.2.2}.

@item
(44) Even if an array value does not satisfy the index constraint of an
array subtype, Constraint_Error is not raised on conversion to the array
subtype, so long as the length of each dimension of the array value and
the array subtype match (@pxref{4.6}).

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of array declarations including an index constraint:

@item
@example
Board     : Matrix(1 .. 8,  1 .. 8);  --  see @ref{3.6}
Rectangle : Matrix(1 .. 20, 1 .. 30);
Inverse   : Matrix(1 .. N,  1 .. N);  --  N need not be static
@end example

@item
@example
Filter    : Bit_Vector(0 .. 31);
@end example

@item
Example of array declaration with a constrained array subtype:

@item
@example
My_Schedule : Schedule;
--  all arrays of type Schedule have the same bounds
@end example

@item
Example of record type with a component that is an array:

@item
@example
type Var_Line(Length : Natural) is
   record
      Image : String(1 .. Length);
   end record;
@end example

@item
@example
Null_Line : Var_Line(0);  --  Null_Line.Image is a null array
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.6.2, 3.6.3, 3.6.1, 3.6
@subsection Operations of Array Types

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate
@item
The argument N used in the attribute_designators for the N-th dimension
of an array shall be a static expression of some integer type. The value
of N shall be positive (nonzero) and no greater than the dimensionality
of the array.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following attributes are defined for a prefix A that is of an array
type (after any implicit dereference), or denotes a constrained array
subtype:

@item
A'First

@example
A'First denotes the lower bound of the first index range; its
type is the corresponding index type.
@end example

@item
A'First(N)

@example
A'First(N) denotes the lower bound of the N-th index range;
its type is the corresponding index type.
@end example

@item
A'Last

@example
A'Last denotes the upper bound of the first index range; its
type is the corresponding index type.
@end example

@item
A'Last(N)

@example
A'Last(N) denotes the upper bound of the N-th index range;
its type is the corresponding index type.
@end example

@item
A'Range

@example
A'Range is equivalent to the range A'First .. A'Last, except
that the prefix A is only evaluated once.
@end example

@item
A'Range(N)

@example
A'Range(N) is equivalent to the range A'First(N) ..
A'Last(N), except that the prefix A is only evaluated once.
@end example

@item
A'Length

@example
A'Length denotes the number of values of the first index
range (zero for a null range); its type is universal_integer.
@end example

@item
A'Length(N)

@example
A'Length(N) denotes the number of values of the N-th index
range (zero for a null range); its type is universal_integer.
@end example

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An implementation should normally represent multidimensional arrays in
row-major order, consistent with the notation used for multidimensional
array aggregates, see @ref{4.3.3}. However, if a pragma Convention(Fortran,
...) applies to a multidimensional array type, then column-major order
should be used instead, see @ref{B.5, ``Interfacing with Fortran''}.

NOTES

@item
(45) The attribute_references A'First and A'First(1) denote the same
value. A similar relation exists for the attribute_references A'Last,
A'Range, and A'Length. The following relation is satisfied (except for a
null array) by the above attributes if the index type is an integer
type:

@item
@example
A'Length(N) = A'Last(N) - A'First(N) + 1
@end example

@item
(46) An array type is limited if its component type is limited, see @ref{7.5}.

@item
(47) The predefined operations of an array type include the membership
tests, qualification, and explicit conversion. If the array type is not
limited, they also include assignment and the predefined equality
operators. For a one-dimensional array type, they include the predefined
concatenation operators (if nonlimited) and, if the component type is
discrete, the predefined relational operators; if the component type is
boolean, the predefined logical operators are also included.

@item
(48) A component of an array can be named with an indexed_component. A
value of an array type can be specified with an array_aggregate, unless
the array type is limited. For a one-dimensional array type, a slice of
the array can be named; also, string literals are defined if the
component type is a character type.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples (using arrays declared in the examples of subclause @ref{3.6.1}):

@item
@example
--  Filter'First       =   0
--  Filter'Last        =  31
--  Filter'Length      =  32
--  Rectangle'Last(1)  =  20
--  Rectangle'Last(2)  =  30
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.6.3, 3.7, 3.6.2, 3.6
@subsection String Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
A one-dimensional array type whose component type is a character type is
called a string type.

@item
There are two predefined string types, String and Wide_String, each
indexed by values of the predefined subtype Positive; these are declared
in the visible part of package Standard:

@item
@example
subtype Positive is Integer range 1 .. Integer'Last;
@end example

@item
@example
type String is array(Positive range <>) of Character;
type Wide_String is array(Positive range <>) of Wide_Character;
@end example

NOTES

@item
(49) String literals, see @ref{2.6}, and @ref{4.2}, are defined for all
string types. The concatenation operator & is predefined for string
types, as for all nonlimited one-dimensional array types. The ordering
operators <, <=, >, and >= are predefined for string types, as for all
one-dimensional discrete array types; these ordering operators
correspond to lexicographic order, see @ref{4.5.2}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of string objects:

@item
@example
Stars      : String(1 .. 120) := (1 .. 120 => '*' );
Question   : constant String  := "How many characters?";
--  Question'First = 1, Question'Last = 20
--  Question'Length = 20 (the number of characters)
@end example

@item
@example
Ask_Twice  : String  := Question & Question;
--  constrained to (1..40)

Ninety_Six : constant Roman   := "XCVI";
--  see @ref{3.5.2}, and @ref{3.6}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.7, 3.7.1, 3.6.3, 3
@section Discriminants

@enumerate
@item
A composite type (other than an array type) can have discriminants,
which parameterize the type. A known_discriminant_part specifies the
discriminants of a composite type. A discriminant of an object is a
component of the object, and is either of a discrete type or an access
type. An unknown_discriminant_part in the declaration of a partial view
of a type specifies that the discriminants of the type are unknown for
the given view; all subtypes of such a partial view are indefinite
subtypes.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
discriminant_part ::=
   unknown_discriminant_part | known_discriminant_part
@end example

@item
@example
unknown_discriminant_part ::= (<>)
@end example

@item
@example
known_discriminant_part ::=
   (discriminant_specification @{; discriminant_specification@})
@end example

@item
@example
discriminant_specification ::=
     defining_identifier_list : subtype_mark
       [:= default_expression]
   | defining_identifier_list : access_definition
       [:= default_expression]
@end example

@item
@example
default_expression ::= expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for the default_expression of a
discriminant_specification is that of the corresponding discriminant.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A known_discriminant_part is only permitted in a declaration for a
composite type that is not an array type (this includes generic formal
types); a type declared with a known_discriminant_part is called a
discriminated type, as is a type that inherits (known) discriminants.

@item
The subtype of a discriminant may be defined by a subtype_mark, in which
case the subtype_mark shall denote a discrete or access subtype, or it
may be defined by an access_definition (in which case the subtype_mark
of the access_definition may denote any kind of subtype). A discriminant
that is defined by an access_definition is called an access discriminant
and is of an anonymous general access-to-variable type whose designated
subtype is denoted by the subtype_mark of the access_definition.

@item
A discriminant_specification for an access discriminant shall appear
only in the declaration for a task or protected type, or for a type with
the reserved word limited in its (full) definition or in that of one of
its ancestors. In addition to the places where Legality Rules normally
apply, see @ref{12.3}, this rule applies also in the private part of an
instance of a generic unit.

@item
Default_expressions shall be provided either for all or for none of the
discriminants of a known_discriminant_part. No default_expressions are
permitted in a known_discriminant_part in a declaration of a tagged type
or a generic formal type.

@item
For a type defined by a derived_type_definition, if a
known_discriminant_part is provided in its declaration, then:

@enumerate 13
@item
The parent subtype shall be constrained;

@item
If the parent type is not a tagged type, then each discriminant of the
derived type shall be used in the constraint defining the parent
subtype;

@item
If a discriminant is used in the constraint defining the parent subtype,
the subtype of the discriminant shall be statically compatible
(@pxref{4.9.1}) with the subtype of the corresponding parent discriminant.
@end enumerate
@end enumerate

@enumerate 16
@item
The type of the default_expression, if any, for an access discriminant
shall be convertible to the anonymous access type of the discriminant
(@pxref{4.6}).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A discriminant_specification declares a discriminant; the subtype_mark
denotes its subtype unless it is an access discriminant, in which case
the discriminant's subtype is the anonymous access-to-variable subtype
defined by the access_definition.

@item
For a type defined by a derived_type_definition, each discriminant of
the parent type is either inherited, constrained to equal some new
discriminant of the derived type, or constrained to the value of an
expression. When inherited or constrained to equal some new
discriminant, the parent discriminant and the discriminant of the
derived type are said to correspond. Two discriminants also correspond
if there is some common discriminant to which they both correspond. A
discriminant corresponds to itself as well. If a discriminant of a
parent type is constrained to a specific value by a
derived_type_definition, then that discriminant is said to be specified
by that derived_type_definition.

@item
A constraint that appears within the definition of a discriminated type
depends on a discriminant of the type if it names the discriminant as a
bound or discriminant value. A component_definition depends on a
discriminant if its constraint depends on the discriminant, or on a
discriminant that corresponds to it.

@item
A component depends on a discriminant if:

@enumerate 21
@item
Its component_definition depends on the discriminant; or

@item
It is declared in a variant_part that is governed by the discriminant;
or

@item
It is a component inherited as part of a derived_type_definition, and
the constraint of the parent_subtype_indication depends on the
discriminant; or

@item
It is a subcomponent of a component that depends on the
discriminant.
@end enumerate
@end enumerate

@enumerate 25
@item
Each value of a discriminated type includes a value for each component
of the type that does not depend on a discriminant; this includes the
discriminants themselves. The values of discriminants determine which
other component values are present in the value of the discriminated
type.

@item
A type declared with a known_discriminant_part is said to have known
discriminants; its first subtype is unconstrained. A type declared with
an unknown_discriminant_part is said to have unknown discriminants. A
type declared without a discriminant_part has no discriminants, unless
it is a derived type; if derived, such a type has the same sort of
discriminants (known, unknown, or none) as its parent (or ancestor)
type. A tagged class-wide type also has unknown discriminants. Any
subtype of a type with unknown discriminants is an unconstrained and
indefinite subtype, see @ref{3.2}, and @ref{3.3}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
An access_definition is elaborated when the value of a corresponding
access discriminant is defined, either by evaluation of its
default_expression or by elaboration of a discriminant_constraint. The
elaboration of an access_definition creates the anonymous access type.
When the expression defining the access discriminant is evaluated, it is
converted to this anonymous access type, see @ref{4.6}.

NOTES

@item
(50) If a discriminated type has default_expressions for its
discriminants, then unconstrained variables of the type are permitted,
and the values of the discriminants can be changed by an assignment to
such a variable. If defaults are not provided for the discriminants,
then all variables of the type are constrained, either by explicit
constraint or by their initial value; the values of the discriminants of
such a variable cannot be changed after initialization.

@item
(51) The default_expression for a discriminant of a type is evaluated
when an object of an unconstrained subtype of the type is created.

@item
(52) Assignment to a discriminant of an object (after its
initialization) is not allowed, since the name of a discriminant is a
constant; neither assignment_statements nor assignments inherent in
passing as an in out or out parameter are allowed. Note however that the
value of a discriminant can be changed by assigning to the enclosing
object, presuming it is an unconstrained variable.

@item
(53) A discriminant that is of a named access type is not called an
access discriminant; that term is used only for discriminants defined by
an access_definition.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of discriminated types:

@item
@example
type Buffer(Size : Buffer_Size := 100) is  --  see @ref{3.5.4}
   record
      Pos   : Buffer_Size := 0;
      Value : String(1 .. Size);
   end record;
@end example

@item
@example
type Matrix_Rec(Rows, Columns : Integer) is
   record
      Mat : Matrix(1 .. Rows, 1 .. Columns);  --  see @ref{3.6}
   end record;
@end example

@item
@example
type Square(Side : Integer) is new
  Matrix_Rec(Rows => Side, Columns => Side);
@end example

@item
@example
type Double_Square(Number : Integer) is
   record
      Left  : Square(Number);
      Right : Square(Number);
   end record;
@end example

@example
type Item(Number : Positive) is
   record
      Content : Integer;
      --  no component depends on the discriminant
   end record;
@end example
@end enumerate

@menu
* 3.7.1:: Discriminant Constraints
* 3.7.2:: Operations of Discriminated Types
@end menu

@c ---------------------------------------------------------------------------
@node 3.7.1, 3.7.2, 3.7, 3.7
@subsection Discriminant Constraints

@enumerate
@item
A discriminant_constraint specifies the values of the discriminants for
a given discriminated type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
discriminant_constraint ::=
   (discriminant_association @{, discriminant_association@})
@end example

@item
@example
discriminant_association ::=
   [discriminant_selector_name
     @{| discriminant_selector_name@} =>] expression
@end example

@enumerate 4
@item
A discriminant_association is said to be named if it has one or more
discriminant_selector_names; it is otherwise said to be positional. In
a discriminant_constraint, any positional associations shall precede any
named associations.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 5
@item
Each selector_name of a named discriminant_association shall resolve to
denote a discriminant of the subtype being constrained; the
discriminants so named are the associated discriminants of the named
association. For a positional association, the associated discriminant
is the one whose discriminant_specification occurred in the
corresponding position in the known_discriminant_part that defined the
discriminants of the subtype being constrained.

@item
The expected type for the expression in a discriminant_association is
that of the associated discriminant(s).

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A discriminant_constraint is only allowed in a subtype_indication whose
subtype_mark denotes either an unconstrained discriminated subtype, or
an unconstrained access subtype whose designated subtype is an
unconstrained discriminated subtype.

@item
A named discriminant_association with more than one selector_name is
allowed only if the named discriminants are all of the same type. A
discriminant_constraint shall provide exactly one value for each
discriminant of the subtype being constrained.

@item
The expression associated with an access discriminant shall be of a type
convertible to the anonymous access type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A discriminant_constraint is compatible with an unconstrained
discriminated subtype if each discriminant value belongs to the subtype
of the corresponding discriminant.

@item
A composite value satisfies a discriminant constraint if and only if
each discriminant of the composite value has the value imposed by the
discriminant constraint.

@item
For the elaboration of a discriminant_constraint, the expressions in the
discriminant_associations are evaluated in an arbitrary order and
converted to the type of the associated discriminant (which might raise
Constraint_Error --  see @ref{4.6}.); the expression of a named association
is evaluated (and converted) once for each associated discriminant. The
result of each evaluation and conversion is the value imposed by the
constraint for the associated discriminant.

NOTES

@item
(54) The rules of the language ensure that a discriminant of an object
always has a value, either from explicit or implicit initialization.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples (using types declared above in clause @ref{3.7}):

@item
@example
Large   : Buffer(200);  --  constrained, always 200 characters
                        --   (explicit discriminant value)
Message : Buffer;       --  unconstrained, initially 100 characters
                        --   (default discriminant value)
Basis   : Square(5);    --  constrained, always 5 by 5
Illegal : Square;       --  illegal, a Square has to be constrained
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.7.2, 3.8, 3.7.1, 3.7
@subsection Operations of Discriminated Types

@enumerate
@item
If a discriminated type has default_expressions for its discriminants,
then unconstrained variables of the type are permitted, and the
discriminants of such a variable can be changed by assignment to the
variable. For a formal parameter of such a type, an attribute is
provided to determine whether the corresponding actual parameter is
constrained or unconstrained.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a prefix A that is of a discriminated type (after any implicit
dereference), the following attribute is defined:

@item
A'Constrained

@example
Yields the value True if A denotes a constant, a value, or a
constrained variable, and False otherwise.
@end example

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
The execution of a construct is erroneous if the construct has a
constituent that is a name denoting a subcomponent that depends on
discriminants, and the value of any of these discriminants is changed by
this execution between evaluating the name and the last use (within this
execution) of the subcomponent denoted by the name.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.8, 3.8.1, 3.7.2, 3
@section Record Types

@enumerate
@item
A record object is a composite object consisting of named components.
The value of a record object is a composite value consisting of the
values of the components.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
record_type_definition ::=
   [[abstract] tagged] [limited] record_definition
@end example

@item
@example
record_definition ::=
     record
        component_list
     end record
   | null record
@end example

@item
@example
component_list ::=
     component_item @{component_item@}
   | @{component_item@} variant_part
   |  null;
@end example

@item
@example
component_item ::= component_declaration | representation_clause
@end example

@item
@example
component_declaration ::=
   defining_identifier_list : component_definition
     [:= default_expression];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for the default_expression, if any, in a
component_declaration is the type of the component.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A default_expression is not permitted if the component is of a limited
type.

@item
Each component_declaration declares a component of the record type.
Besides components declared by component_declarations, the components of
a record type include any components declared by
discriminant_specifications of the record type declaration. The
identifiers of all components of a record type shall be distinct.

@item
Within a type_declaration, a name that denotes a component, protected
subprogram, or entry of the type is allowed only in the following cases:

@enumerate 11
@item
A name that denotes any component, protected subprogram, or entry is
allowed within a representation item that occurs within the declaration
of the composite type.

@item
A name that denotes a noninherited discriminant is allowed within the
declaration of the type, but not within the discriminant_part. If the
discriminant is used to define the constraint of a component, the bounds
of an entry family, or the constraint of the parent subtype in a
derived_type_definition then its name shall appear alone as a
direct_name (not as part of a larger expression or expanded name). A
discriminant shall not be used to define the constraint of a scalar
component.
@end enumerate
@end enumerate

@enumerate 13
@item
If the name of the current instance of a type, see @ref{8.6}, is used to
define the constraint of a component, then it shall appear as a
direct_name that is the prefix of an attribute_reference whose result is
of an access type, and the attribute_reference shall appear alone.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The component_definition of a component_declaration defines the
(nominal) subtype of the component. If the reserved word aliased appears
in the component_definition, then the component is aliased, see @ref{3.10}.

@item
If the component_list of a record type is defined by the reserved word
null and there are no discriminants, then the record type has no
components and all records of the type are null records. A
record_definition of null record is equivalent to record null; end
record.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a record_type_definition creates the record type and
its first subtype, and consists of the elaboration of the
record_definition. The elaboration of a record_definition consists of
the elaboration of its component_list, if any.

@item
The elaboration of a component_list consists of the elaboration of the
component_items and variant_part, if any, in the order in which they
appear. The elaboration of a component_declaration consists of the
elaboration of the component_definition.

@item
Within the definition of a composite type, if a component_definition or
discrete_subtype_definition, see @ref{9.5.2}, includes a name that denotes
a discriminant of the type, or that is an attribute_reference whose
prefix denotes the current instance of the type, the expression
containing the name is called a per-object expression, and the
constraint being defined is called a per-object constraint. For the
elaboration of a component_definition of a component_declaration, if the
constraint of the subtype_indication is not a per-object constraint,
then the subtype_indication is elaborated. On the other hand, if the
constraint is a per-object constraint, then the elaboration consists of
the evaluation of any included expression that is not part of a
per-object expression.

NOTES

@item
(55) A component_declaration with several identifiers is equivalent to a
sequence of single component_declarations, as explained in @ref{3.3.1}.

@item
(56) The default_expression of a record component is only evaluated upon
the creation of a default-initialized object of the record type
(presuming the object has the component, if it is in a variant_part --
see @ref{3.3.1}).

@item
(57) The subtype defined by a component_definition, see @ref{3.6}, has to
be a definite subtype.

@item
(58) If a record type does not have a variant_part, then the same
components are present in all values of the type.

@item
(59) A record type is limited if it has the reserved word limited in its
definition, or if any of its components are limited, see @ref{7.5}.

@item
(60) The predefined operations of a record type include membership
tests, qualification, and explicit conversion. If the record type is
nonlimited, they also include assignment and the predefined equality
operators.

@item
(61) A component of a record can be named with a selected_component. A
value of a record can be specified with a record_aggregate, unless the
record type is limited.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of record type declarations:

@item
@example
type Date is
   record
      Day   : Integer range 1 .. 31;
      Month : Month_Name;
      Year  : Integer range 0 .. 4000;
   end record;
@end example

@item
@example
type Complex is
   record
      Re : Real := 0.0;
      Im : Real := 0.0;
   end record;
@end example

@item
Examples of record variables:

@item
@example
Tomorrow, Yesterday : Date;
A, B, C : Complex;
@end example

@item
@example
-- both components of A, B, and C are implicitly initialized to zero
@end example
@end enumerate

@menu
* 3.8.1:: Variant Parts and Discrete Choices
@end menu

@c ---------------------------------------------------------------------------
@node 3.8.1, 3.9, 3.8, 3.8
@subsection Variant Parts and Discrete Choices

@enumerate
@item
A record type with a variant_part specifies alternative lists of
components. Each variant defines the components for the value or values
of the discriminant covered by its discrete_choice_list.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
variant_part ::=
   case discriminant_direct_name is
      variant
      @{variant@}
   end case;
@end example

@item
@example
variant ::=
   when discrete_choice_list =>
      component_list
@end example

@item
@example
discrete_choice_list ::= discrete_choice @{| discrete_choice@}
@end example

@item
@example
discrete_choice ::= expression | discrete_range | others
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The discriminant_direct_name shall resolve to denote a discriminant
(called the discriminant of the variant_part) specified in the
known_discriminant_part of the full_type_declaration that contains the
variant_part. The expected type for each discrete_choice in a variant is
the type of the discriminant of the variant_part.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The discriminant of the variant_part shall be of a discrete type.

@item
The expressions and discrete_ranges given as discrete_choices in a
variant_part shall be static. The discrete_choice others shall appear
alone in a discrete_choice_list, and such a discrete_choice_list, if it
appears, shall be the last one in the enclosing construct.

@item
A discrete_choice is defined to cover a value in the following cases:

@enumerate 10
@item
A discrete_choice that is an expression covers a value if the value
equals the value of the expression converted to the expected type.

@item
A discrete_choice that is a discrete_range covers all values (possibly
none) that belong to the range.

@item
The discrete_choice others covers all values of its expected type that
are not covered by previous discrete_choice_lists of the same construct.
@end enumerate
@end enumerate

@enumerate 13
@item
A discrete_choice_list covers a value if one of its discrete_choices
covers the value.

@item
The possible values of the discriminant of a variant_part shall be
covered as follows:

@enumerate 15
@item
If the discriminant is of a static constrained scalar subtype, then each
non-others discrete_choice shall cover only values in that subtype, and
each value of that subtype shall be covered by some discrete_choice
(either explicitly or by others);

@item
If the type of the discriminant is a descendant of a generic formal
scalar type then the variant_part shall have an others discrete_choice;

@item
Otherwise, each value of the base range of the type of the discriminant
shall be covered (either explicitly or by others).
@end enumerate
@end enumerate

@enumerate
@item
Two distinct discrete_choices of a variant_part shall not cover the same
value.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If the component_list of a variant is specified by null, the variant has
no components.

@item
The discriminant of a variant_part is said to govern the variant_part
and its variants. In addition, the discriminant of a derived type
governs a variant_part and its variants if it corresponds, see @ref{3.7},
to the discriminant of the variant_part.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A record value contains the values of the components of a particular
variant only if the value of the discriminant governing the variant is
covered by the discrete_choice_list of the variant. This rule applies in
turn to any further variant that is, itself, included in the
component_list of the given variant.

@item
The elaboration of a variant_part consists of the elaboration of the
component_list of each variant in the order in which they appear.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of record type with a variant part:

@item
@example
type Device is (Printer, Disk, Drum);
type State  is (Open, Closed);
@end example

@item
@example
type Peripheral(Unit : Device := Disk) is
   record
      Status : State;
      case Unit is
         when Printer =>
            Line_Count : Integer range 1 .. Page_Size;
         when others =>
            Cylinder   : Cylinder_Index;
            Track      : Track_Number;
         end case;
      end record;
@end example

@item
Examples of record subtypes:

@item
@example
subtype Drum_Unit is Peripheral(Drum);
subtype Disk_Unit is Peripheral(Disk);
@end example

@item
Examples of constrained record variables:

@item
@example
Writer   : Peripheral(Unit  => Printer);
Archive  : Disk_Unit;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.9, 3.9.1, 3.8.1, 3
@section Tagged Types and Type Extensions

@enumerate
@item
Tagged types and type extensions support object-oriented programming,
based on inheritance with extension and run-time polymorphism via
dispatching operations.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A record type or private type that has the reserved word tagged in its
declaration is called a tagged type. When deriving from a tagged type,
additional components may be defined. As for any derived type,
additional primitive subprograms may be defined, and inherited primitive
subprograms may be overridden. The derived type is called an extension
of the ancestor type, or simply a type extension. Every type extension
is also a tagged type, and is either a record extension or a private
extension of some other tagged type. A record extension is defined by a
derived_type_definition with a record_extension_part. A private
extension, which is a partial view of a record extension, can be
declared in the visible part of a package, see @ref{7.3}, or in a generic
formal part, see @ref{12.5.1}.

@item
An object of a tagged type has an associated (run-time) tag that
identifies the specific tagged type used to create the object
originally. The tag of an operand of a class-wide tagged type T'Class
controls which subprogram body is to be executed when a primitive
subprogram of type T is applied to the operand, see @ref{3.9.2}, using a
tag to control which body to execute is called dispatching.

@item
The tag of a specific tagged type identifies the full_type_declaration
of the type. If a declaration for a tagged type occurs within a
generic_package_declaration, then the corresponding type declarations in
distinct instances of the generic package are associated with distinct
tags. For a tagged type that is local to a generic package body, the
language does not specify whether repeated instantiations of the generic
body result in distinct tags.

@item
The following language-defined library package exists:

@item
@example
package Ada.Tags is
    type Tag is private;
@end example

@item
@example
    function Expanded_Name(T : Tag) return String;
    function External_Tag(T : Tag) return String;
    function Internal_Tag(External : String) return Tag;
@end example

@item
@example
    Tag_Error : exception;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Tags;
@end example

@item
The function Expanded_Name returns the full expanded name of the first
subtype of the specific type identified by the tag, in upper case,
starting with a root library unit. The result is implementation defined
if the type is declared within an unnamed block_statement.

@item
The function External_Tag returns a string to be used in an external
representation for the given tag. The call External_Tag(S'Tag) is
equivalent to the attribute_reference S'External_Tag, see @ref{13.3}.

@item
The function Internal_Tag returns the tag that corresponds to the given
external tag, or raises Tag_Error if the given string is not the
external tag for any specific type of the partition.

@item
For every subtype S of a tagged type T (specific or class-wide), the
following attributes are defined:

@item
S'Class

@example
S'Class denotes a subtype of the class-wide type (called
T'Class in this International Standard) for the class rooted
at T (or if S already denotes a class-wide subtype, then
S'Class is the same as S).
@end example

@enumerate 15
@item
S'Class is unconstrained. However, if S is constrained, then the values
of S'Class are only those that when converted to the type T belong to S.
@end enumerate
@end enumerate

@enumerate 16
@item
S'Tag

@example
S'Tag denotes the tag of the type T (or if T is class-wide,
the tag of the root type of the corresponding class). The
value of this attribute is of type Tag.
@end example

@item
Given a prefix X that is of a class-wide tagged type (after any implicit
dereference), the following attribute is defined:

@item
X'Tag

@example
X'Tag denotes the tag of X. The value of this attribute is of
type Tag.
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The tag associated with an object of a tagged type is determined as
follows:

@enumerate 20
@item
The tag of a stand-alone object, a component, or an aggregate of a
specific tagged type T identifies T.

@item
The tag of an object created by an allocator for an access type with a
specific designated tagged type T, identifies T.

@item
The tag of an object of a class-wide tagged type is that of its
initialization expression.

@item
The tag of the result returned by a function whose result type is a
specific tagged type T identifies T.

@item
The tag of the result returned by a function with a class-wide result
type is that of the return expression.
@end enumerate
@end enumerate

@enumerate 25
@item
The tag is preserved by type conversion and by parameter passing. The
tag of a value is the tag of the associated object, see @ref{6.2}.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The implementation of the functions in Ada.Tags may raise Tag_Error if
no specific type corresponding to the tag passed as a parameter exists
in the partition at the time the function is called.

NOTES

@item
(62) A type declared with the reserved word tagged should normally be
declared in a package_specification, so that new primitive subprograms
can be declared for it.

@item
(63) Once an object has been created, its tag never changes.

@item
(64) Class-wide types are defined to have unknown discriminants
(@pxref{3.7}). This means that objects of a class-wide type have to be
explicitly initialized (whether created by an object_declaration or an
allocator), and that aggregates have to be explicitly qualified with a
specific type when their expected type is class-wide.

@item
(65) If S denotes an untagged private type whose full type is tagged,
then S'Class is also allowed before the full type definition, but only
in the private part of the package in which the type is declared
(@pxref{7.3.1}). Similarly, the Class attribute is defined for incomplete
types whose full type is tagged, but only within the library unit in
which the incomplete type is declared, see @ref{3.10.1}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of tagged record types:

@item
@example
type Point is tagged
  record
    X, Y : Real := 0.0;
  end record;
@end example

@item
@example
type Expression is tagged null record;
  -- Components will be added by each extension
@end example
@end enumerate

@menu
* 3.9.1:: Type Extensions
* 3.9.2:: Dispatching Operations of Tagged Types
* 3.9.3:: Abstract Types and Subprograms
@end menu

@c ---------------------------------------------------------------------------
@node 3.9.1, 3.9.2, 3.9, 3.9
@subsection Type Extensions

@enumerate
@item
Every type extension is a tagged type, and is either a record extension
or a private extension of some other tagged type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
record_extension_part ::= with record_definition
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The parent type of a record extension shall not be a class-wide type. If
the parent type is nonlimited, then each of the components of the
record_extension_part shall be nonlimited. The accessibility level
(@pxref{3.10.2}) of a record extension shall not be statically deeper than
that of its parent type. In addition to the places where Legality Rules
normally apply, see @ref{12.3}, these rules apply also in the private part
of an instance of a generic unit.

@item
A type extension shall not be declared in a generic body if the parent
type is declared outside that body.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a record_extension_part consists of the elaboration
of the record_definition.

NOTES

@item
(66) The term ``type extension'' refers to a type as a whole. The term
``extension part'' refers to the piece of text that defines the
additional components (if any) the type extension has relative to its
specified ancestor type.

@item
(67) The accessibility rules imply that a tagged type declared in a
library package_specification can be extended only at library level or
as a generic formal. When the extension is declared immediately within a
package_body, primitive subprograms are inherited and are overridable,
but new primitive subprograms cannot be added.

@item
(68) A name that denotes a component (including a discriminant) of the
parent type is not allowed within the record_extension_part. Similarly,
a name that denotes a component defined within the record_extension_part
is not allowed within the record_extension_part. It is permissible to
use a name that denotes a discriminant of the record extension,
providing there is a new known_discriminant_part in the enclosing type
declaration. (The full rule is given in @ref{3.8}.)

@item
(69) Each visible component of a record extension has to have a unique
name, whether the component is (visibly) inherited from the parent type
or declared in the record_extension_part, see @ref{8.3}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of record extensions (of types defined above in @ref{3.9}.):

@item
@example
type Painted_Point is new Point with
  record
    Paint : Color := White;
  end record;
    -- Components X and Y are inherited
@end example

@item
@example
Origin : constant Painted_Point := (X | Y => 0.0, Paint => Black);
@end example

@item
@example
type Literal is new Expression with
  record                 -- a leaf in an Expression tree
    Value : Real;
  end record;
@end example

@item
@example
type Expr_Ptr is access all Expression'Class;
--  see @ref{3.10}
@end example

@item
@example
type Binary_Operation is new Expression with
  record       -- an internal node in an Expression tree
    Left, Right : Expr_Ptr;
  end record;
@end example

@item
@example
type Addition is new Binary_Operation with null record;
type Subtraction is new Binary_Operation with null record;
-- No additional components needed for these extensions
@end example

@item
@example
Tree : Expr_Ptr :=  -- A tree representation of ``5.0 + (13.0-7.0)''
   new Addition'(
      Left  => new Literal'(Value => 5.0),
      Right => new Subtraction'(
         Left  => new Literal'(Value => 13.0),
         Right => new Literal'(Value => 7.0)));
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.9.2, 3.9.3, 3.9.1, 3.9
@subsection Dispatching Operations of Tagged Types

@enumerate
@item
The primitive subprograms of a tagged type are called dispatching
operations. A dispatching operation can be called using a statically
determined controlling tag, in which case the body to be executed is
determined at compile time. Alternatively, the controlling tag can be
dynamically determined, in which case the call dispatches to a body that
is determined at run time; such a call is termed a dispatching call. As
explained below, the properties of the operands and the context of a
particular call on a dispatching operation determine how the controlling
tag is determined, and hence whether or not the call is a dispatching
call. Run-time polymorphism is achieved when a dispatching operation is
called by a dispatching call.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A call on a dispatching operation is a call whose name or prefix denotes
the declaration of a primitive subprogram of a tagged type, that is, a
dispatching operation. A controlling operand in a call on a dispatching
operation of a tagged type T is one whose corresponding formal parameter
is of type T or is of an anonymous access type with designated type T;
the corresponding formal parameter is called a controlling formal
parameter. If the controlling formal parameter is an access parameter,
the controlling operand is the object designated by the actual
parameter, rather than the actual parameter itself. If the call is to a
(primitive) function with result type T, then the call has a controlling
result -- the context of the call can control the dispatching.

@item
A name or expression of a tagged type is either statically tagged,
dynamically tagged, or tag indeterminate, according to whether, when
used as a controlling operand, the tag that controls dispatching is
determined statically by the operand's (specific) type, dynamically by
its tag at run time, or from context. A qualified_expression or
parenthesized expression is statically, dynamically, or indeterminately
tagged according to its operand. For other kinds of names and
expressions, this is determined as follows:

@enumerate 4
@item
The name or expression is statically tagged if it is of a specific
tagged type and, if it is a call with a controlling result, it has at
least one statically tagged controlling operand;

@item
The name or expression is dynamically tagged if it is of a class-wide
type, or it is a call with a controlling result and at least one
dynamically tagged controlling operand;

@item
The name or expression is tag indeterminate if it is a call with a
controlling result, all of whose controlling operands (if any) are tag
indeterminate.
@end enumerate
@end enumerate

@enumerate 7
@item
A type_conversion is statically or dynamically tagged according to
whether the type determined by the subtype_mark is specific or
class-wide, respectively. For a controlling operand that is designated
by an actual parameter, the controlling operand is statically or
dynamically tagged according to whether the designated type of the
actual parameter is specific or class-wide, respectively.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A call on a dispatching operation shall not have both dynamically tagged
and statically tagged controlling operands.

@item
If the expected type for an expression or name is some specific tagged
type, then the expression or name shall not be dynamically tagged unless
it is a controlling operand in a call on a dispatching operation.
Similarly, if the expected type for an expression is an anonymous
access-to-specific tagged type, then the expression shall not be of an
access-to-class-wide type unless it designates a controlling operand in
a call on a dispatching operation.

@item
In the declaration of a dispatching operation of a tagged type,
everywhere a subtype of the tagged type appears as a subtype of the
profile, see @ref{6.1}, it shall statically match the first subtype of the
tagged type. If the dispatching operation overrides an inherited
subprogram, it shall be subtype conformant with the inherited
subprogram. A dispatching operation shall not be of convention
Intrinsic. If a dispatching operation overrides the predefined equals
operator, then it shall be of convention Ada (either explicitly or by
default --  see @ref{6.3.1}.).

@item
The default_expression for a controlling formal parameter of a
dispatching operation shall be tag indeterminate. A controlling formal
parameter that is an access parameter shall not have a
default_expression.

@item
A given subprogram shall not be a dispatching operation of two or more
distinct tagged types.

@item
The explicit declaration of a primitive subprogram of a tagged type
shall occur before the type is frozen, see @ref{13.14}. For example, new
dispatching operations cannot be added after objects or values of the
type exist, nor after deriving a record extension from it, nor after a
body.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a call on a dispatching operation of a type T, the
controlling tag value determines which subprogram body is executed. The
controlling tag value is defined as follows:

@enumerate 15
@item
If one or more controlling operands are statically tagged, then the
controlling tag value is statically determined to be the tag of T.

@item
If one or more controlling operands are dynamically tagged, then the
controlling tag value is not statically determined, but is rather
determined by the tags of the controlling operands. If there is more
than one dynamically tagged controlling operand, a check is made that
they all have the same tag. If this check fails, Constraint_Error is
raised unless the call is a function_call whose name denotes the
declaration of an equality operator (predefined or user defined) that
returns Boolean, in which case the result of the call is defined to
indicate inequality, and no subprogram_body is executed. This check is
performed prior to evaluating any tag-indeterminate controlling
operands.

@item
If all of the controlling operands are tag-indeterminate, then:

@enumerate 18
@item
If the call has a controlling result and is itself a (possibly
parenthesized or qualified) controlling operand of an enclosing call on
a dispatching operation of type T, then its controlling tag value is
determined by the controlling tag value of this enclosing call;

@item
Otherwise, the controlling tag value is statically determined to be the
tag of type T.
@end enumerate
@end enumerate
@end enumerate

@enumerate 20
@item
For the execution of a call on a dispatching operation, the body
executed is the one for the corresponding primitive subprogram of the
specific type identified by the controlling tag value. The body for an
explicitly declared dispatching operation is the corresponding explicit
body for the subprogram. The body for an implicitly declared dispatching
operation that is overridden is the body for the overriding subprogram,
even if the overriding occurs in a private part. The body for an
inherited dispatching operation that is not overridden is the body of
the corresponding subprogram of the parent or ancestor type.

NOTES

@item
(70) The body to be executed for a call on a dispatching operation is
determined by the tag; it does not matter whether that tag is determined
statically or dynamically, and it does not matter whether the
subprogram's declaration is visible at the place of the call.

@item
(71) This subclause covers calls on primitive subprograms of a tagged
type. Rules for tagged type membership tests are described in 4.5.2.
Controlling tag determination for an assignment_statement is described
in @ref{5.2}.

@item
(72) A dispatching call can dispatch to a body whose declaration is not
visible at the place of the call.

@item
(73) A call through an access-to-subprogram value is never a dispatching
call, even if the access value designates a dispatching operation.
Similarly a call whose prefix denotes a subprogram_renaming_declaration
cannot be a dispatching call unless the renaming itself is the
declaration of a primitive subprogram.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.9.3, 3.10, 3.9.2, 3.9
@subsection Abstract Types and Subprograms

@enumerate
@item
An abstract type is a tagged type intended for use as a parent type for
type extensions, but which is not allowed to have objects of its own. An
abstract subprogram is a subprogram that has no body, but is intended to
be overridden at some point when inherited. Because objects of an
abstract type cannot be created, a dispatching call to an abstract
subprogram always dispatches to some overriding body.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An abstract type is a specific type that has the reserved word abstract
in its declaration. Only a tagged type is allowed to be declared
abstract.

@item
A subprogram declared by an abstract_subprogram_declaration, see @ref{6.1},
is an abstract subprogram. If it is a primitive subprogram of a tagged
type, then the tagged type shall be abstract.

@item
For a derived type, if the parent or ancestor type has an abstract
primitive subprogram, or a primitive function with a controlling result,
then:

@enumerate 5
@item
If the derived type is abstract or untagged, the inherited subprogram is
abstract.

@item
Otherwise, the subprogram shall be overridden with a nonabstract
subprogram; for a type declared in the visible part of a package, the
overriding may be either in the visible or the private part. However, if
the type is a generic formal type, the subprogram need not be overridden
for the formal type itself; a nonabstract version will necessarily be
provided by the actual type.
@end enumerate
@end enumerate

@enumerate 7
@item
A call on an abstract subprogram shall be a dispatching call;
nondispatching calls to an abstract subprogram are not allowed.

@item
The type of an aggregate, or of an object created by an
object_declaration or an allocator, or a generic formal object of mode
in, shall not be abstract. The type of the target of an assignment
operation, see @ref{5.2}, shall not be abstract. The type of a component
shall not be abstract. If the result type of a function is abstract,
then the function shall be abstract.

@item
If a partial view is not abstract, the corresponding full view shall not
be abstract. If a generic formal type is abstract, then for each
primitive subprogram of the formal that is not abstract, the
corresponding primitive subprogram of the actual shall not be abstract.

@item
For an abstract type declared in a visible part, an abstract primitive
subprogram shall not be declared in the private part, unless it is
overriding an abstract subprogram implicitly declared in the visible
part. For a tagged type declared in a visible part, a primitive function
with a controlling result shall not be declared in the private part,
unless it is overriding a function implicitly declared in the visible
part.

@item
A generic actual subprogram shall not be an abstract subprogram. The
prefix of an attribute_reference for the Access, Unchecked_Access, or
Address attributes shall not denote an abstract subprogram.

NOTES

@item
(74) Abstractness is not inherited; to declare an abstract type, the
reserved word abstract has to be used in the declaration of the type
extension.

@item
(75) A class-wide type is never abstract. Even if a class is rooted at
an abstract type, the class-wide type for the class is not abstract, and
an object of the class-wide type can be created; the tag of such an
object will identify some nonabstract type in the class.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of an abstract type representing a set of natural numbers:

@item
@example
package Sets is
    subtype Element_Type is Natural;
    type Set is abstract tagged null record;
    function Empty return Set is abstract;
    function Union(Left, Right : Set) return Set is abstract;
    function Intersection(Left, Right : Set) return Set is abstract;
    function Unit_Set(Element : Element_Type) return Set is abstract;
    procedure Take
      (Element : out Element_Type;
       From : in out Set) is abstract;
end Sets;
@end example

NOTES

@item
(76) Notes on the example:  Given the above abstract type, one could
then derive various (nonabstract) extensions of the type, representing
alternative implementations of a set. One might use a bit vector, but
impose an upper bound on the largest element representable, while
another might use a hash table, trading off space for flexibility.
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.10, 3.10.1, 3.9.3, 3
@section Access Types

@enumerate
@item
A value of an access type (an access value) provides indirect access to
the object or subprogram it designates. Depending on its type, an access
value can designate either subprograms, objects created by allocators
(@pxref{4.8}) or more generally aliased objects of an appropriate type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
access_type_definition ::=
     access_to_object_definition
   | access_to_subprogram_definition
@end example

@item
@example
access_to_object_definition ::=
    access [general_access_modifier] subtype_indication
@end example

@item
@example
general_access_modifier ::= all | constant
@end example

@item
@example
access_to_subprogram_definition ::=
     access [protected] procedure parameter_profile
   | access [protected] function  parameter_and_result_profile
@end example

@item
@example
access_definition ::= access subtype_mark
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
There are two kinds of access types, access-to-object types, whose
values designate objects, and access-to-subprogram types, whose values
designate subprograms. Associated with an access-to-object type is a
storage pool; several access types may share the same storage pool. A
storage pool is an area of storage used to hold dynamically allocated
objects (called pool elements) created by allocators; storage pools are
described further in @ref{13.11, ``Storage Management''}.

@item
Access-to-object types are further subdivided into pool-specific access
types, whose values can designate only the elements of their associated
storage pool, and general access types, whose values can designate the
elements of any storage pool, as well as aliased objects created by
declarations rather than allocators, and aliased subcomponents of other
objects.

@item
A view of an object is defined to be aliased if it is defined by an
object_declaration or component_definition with the reserved word
aliased, or by a renaming of an aliased view. In addition, the
dereference of an access-to-object value denotes an aliased view, as
does a view conversion, see @ref{4.6} of an aliased view. Finally, the
current instance of a limited type, and a formal parameter or generic
formal object of a tagged type are defined to be aliased. Aliased views
are the ones that can be designated by an access value. If the view
defined by an object_declaration is aliased, and the type of the object
has discriminants, then the object is constrained; if its nominal
subtype is unconstrained, then the object is constrained by its initial
value. Similarly, if the object created by an allocator has
discriminants, the object is constrained, either by the designated
subtype, or by its initial value.

@item
An access_to_object_definition defines an access-to-object type and its
first subtype; the subtype_indication defines the designated subtype of
the access type. If a general_access_modifier appears, then the access
type is a general access type. If the modifier is the reserved word
constant, then the type is an access-to-constant type; a designated
object cannot be updated through a value of such a type. If the modifier
is the reserved word all, then the type is an access-to-variable type; a
designated object can be both read and updated through a value of such a
type. If no general_access_modifier appears in the
access_to_object_definition, the access type is a pool-specific
access-to-variable type.

@item
An access_to_subprogram_definition defines an access-to-subprogram type
and its first subtype; the parameter_profile or
parameter_and_result_profile defines the designated profile of the
access type. There is a calling convention associated with the
designated profile; only subprograms with this calling convention can be
designated by values of the access type. By default, the calling
convention is ``protected'' if the reserved word protected appears, and
``Ada'' otherwise. See Annex @ref{B} for how to override this default.

@item
An access_definition defines an anonymous general access-to-variable
type; the subtype_mark denotes its designated subtype. An
access_definition is used in the specification of an access
discriminant, see @ref{3.7}, or an access parameter, see @ref{6.1}.

@item
For each (named) access type, there is a literal null which has a null
access value designating no entity at all. The null value of a named
access type is the default initial value of the type. Other values of an
access type are obtained by evaluating an attribute_reference for the
Access or Unchecked_Access attribute of an aliased view of an object or
non-intrinsic subprogram, or, in the case of a named access-to-object
type, an allocator, which returns an access value designating a newly
created object, see @ref{3.10.2}.

@item
All subtypes of an access-to-subprogram type are constrained. The first
subtype of a type defined by an access_type_definition or an
access_to_object_definition is unconstrained if the designated subtype
is an unconstrained array or discriminated type; otherwise it is
constrained.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A composite_constraint is compatible with an unconstrained access
subtype if it is compatible with the designated subtype. An access value
satisfies a composite_constraint of an access subtype if it equals the
null value of its type or if it designates an object whose value
satisfies the constraint.

@item
The elaboration of an access_type_definition creates the access type and
its first subtype. For an access-to-object type, this elaboration
includes the elaboration of the subtype_indication, which creates the
designated subtype.

@item
The elaboration of an access_definition creates an anonymous general
access-to-variable type (this happens as part of the initialization of
an access parameter or access discriminant).

NOTES

@item
(77) Access values are called ``pointers'' or ``references'' in some
other languages.

@item
(78) Each access-to-object type has an associated storage pool; several
access types can share the same pool. An object can be created in the
storage pool of an access type by an allocator, see @ref{4.8}, for the
access type. A storage pool (roughly) corresponds to what some other
languages call a ``heap.''. @xref{13.11}, for a discussion of pools.

@item
(79) Only index_constraints and discriminant_constraints can be applied
to access types, see @ref{3.6.1}, and @ref{3.7.1}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of access-to-object types:

@item
@example
type Peripheral_Ref is access Peripheral;  --  see @ref{3.8.1}
type Binop_Ptr is access all Binary_Operation'Class;
-- general access-to-class-wide, see @ref{3.9.1}
@end example

@item
Example of an access subtype:

@item
@example
subtype Drum_Ref is Peripheral_Ref(Drum);  --  see @ref{3.8.1}
@end example

@item
Example of an access-to-subprogram type:

@item
@example
type Message_Procedure is access
  procedure (M : in String := "Error!");
procedure Default_Message_Procedure(M : in String);
Give_Message : Message_Procedure := Default_Message_Procedure'Access;
...
procedure Other_Procedure(M : in String);
...
Give_Message := Other_Procedure'Access;
...
Give_Message("File not found.");
-- call with parameter (.all is optional)
Give_Message.all;
-- call with no parameters
@end example
@end enumerate

@menu
* 3.10.1:: Incomplete Type Declarations
* 3.10.2:: Operations of Access Types
@end menu

@c ---------------------------------------------------------------------------
@node 3.10.1, 3.10.2, 3.10, 3.10
@subsection Incomplete Type Declarations

@enumerate
@item
There are no particular limitations on the designated type of an access
type. In particular, the type of a component of the designated type can
be another access type, or even the same access type. This permits
mutually dependent and recursive access types. An
incomplete_type_declaration can be used to introduce a type to be used
as a designated type, while deferring its full definition to a
subsequent full_type_declaration.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
incomplete_type_declaration ::=
   type defining_identifier [discriminant_part];
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An incomplete_type_declaration requires a completion, which shall be a
full_type_declaration. If the incomplete_type_declaration occurs
immediately within either the visible part of a package_specification or
a declarative_part, then the full_type_declaration shall occur later and
immediately within this visible part or declarative_part. If the
incomplete_type_declaration occurs immediately within the private part
of a given package_specification, then the full_type_declaration shall
occur later and immediately within either the private part itself, or
the declarative_part of the corresponding package_body.

@item
If an incomplete_type_declaration has a known_discriminant_part, then a
full_type_declaration that completes it shall have a fully conforming
(explicit) known_discriminant_part, see @ref{6.3.1}. If an
incomplete_type_declaration has no discriminant_part (or an
unknown_discriminant_part), then a corresponding full_type_declaration
is nevertheless allowed to have discriminants, either explicitly, or
inherited via derivation.

@item
The only allowed uses of a name that denotes an
incomplete_type_declaration are as follows:

@enumerate 6
@item
as the subtype_mark in the subtype_indication of an
access_to_object_definition; the only form of constraint allowed in this
subtype_indication is a discriminant_constraint;

@item
as the subtype_mark defining the subtype of a parameter or result of an
access_to_subprogram_definition;

@item
as the subtype_mark in an access_definition;

@item
as the prefix of an attribute_reference whose attribute_designator is
Class; such an attribute_reference is similarly restricted to the uses
allowed here; when used in this way, the corresponding
full_type_declaration shall declare a tagged type, and the
attribute_reference shall occur in the same library unit as the
incomplete_type_declaration.
@end enumerate
@end enumerate

@enumerate 10
@item
A dereference (whether implicit or explicit --  see @ref{4.1}.) shall not be
of an incomplete type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An incomplete_type_declaration declares an incomplete type and its first
subtype; the first subtype is unconstrained if a known_discriminant_part
appears.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of an incomplete_type_declaration has no effect.

NOTES

@item
(80) Within a declarative_part, an incomplete_type_declaration and a
corresponding full_type_declaration cannot be separated by an
intervening body. This is because a type has to be completely defined
before it is frozen, and a body freezes all types declared prior to it
in the same declarative_part, see @ref{13.14}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a recursive type:

@item
@example
type Cell;  --  incomplete type declaration
type Link is access Cell;
@end example

@item
@example
type Cell is
   record
      Value  : Integer;
      Succ   : Link;
      Pred   : Link;
   end record;
@end example

@item
@example
Head   : Link  := new Cell'(0, null, null);
Next   : Link  := Head.Succ;
@end example

@item
Examples of mutually dependent access types:

@item
@example
type Person(<>);    -- incomplete type declaration
type Car;           -- incomplete type declaration
@end example

@item
@example
type Person_Name is access Person;
type Car_Name    is access all Car;
@end example

@item
@example
type Car is
   record
      Number  : Integer;
      Owner   : Person_Name;
   end record;
@end example

@item
@example
type Person(Sex : Gender) is
   record
      Name     : String(1 .. 20);
      Birth    : Date;
      Age      : Integer range 0 .. 130;
      Vehicle  : Car_Name;
      case Sex is
         when M => Wife    : Person_Name(Sex => F);
         when F => Husband : Person_Name(Sex => M);
      end case;
   end record;
@end example

@item
@example
My_Car, Your_Car, Next_Car : Car_Name := new Car;
--  see @ref{4.8}
George : Person_Name := new Person(M);
   ...
George.Vehicle := Your_Car;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.10.2, 3.11, 3.10.1, 3.10
@subsection Operations of Access Types

@enumerate
@item
The attribute Access is used to create access values designating aliased
objects and non-intrinsic subprograms. The ``accessibility'' rules
prevent dangling references (in the absence of uses of certain unchecked
features -- see @ref{13}.).

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For an attribute_reference with attribute_designator Access (or
Unchecked_Access --  see @ref{13.10}.), the expected type shall be a single
access type; the prefix of such an attribute_reference is never
interpreted as an implicit_dereference. If the expected type is an
access-to-subprogram type, then the expected profile of the prefix is
the designated profile of the access type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The accessibility rules, which prevent dangling references, are written
in terms of accessibility levels, which reflect the run-time nesting of
masters. As explained in @ref{7.6.1}, a master is the execution of a
task_body, a block_statement, a subprogram_body, an entry_body, or an
accept_statement. An accessibility level is deeper than another if it is
more deeply nested at run time. For example, an object declared local to
a called subprogram has a deeper accessibility level than an object
declared local to the calling subprogram. The accessibility rules for
access types require that the accessibility level of an object
designated by an access value be no deeper than that of the access type.
This ensures that the object will live at least as long as the access
type, which in turn ensures that the access value cannot later designate
an object that no longer exists. The Unchecked_Access attribute may be
used to circumvent the accessibility rules.

@item
A given accessibility level is said to be statically deeper than another
if the given level is known at compile time (as defined below) to be
deeper than the other for all possible executions. In most cases,
accessibility is enforced at compile time by Legality Rules. Run-time
accessibility checks are also used, since the Legality Rules do not
cover certain cases involving access parameters and generic packages.

@item
Each master, and each entity and view created by it, has an
accessibility level:

@enumerate 6
@item
The accessibility level of a given master is deeper than that of each
dynamically enclosing master, and deeper than that of each master upon
which the task executing the given master directly depends, see @ref{9.3}.

@item
An entity or view created by a declaration has the same accessibility
level as the innermost enclosing master, except in the cases of renaming
and derived access types described below. A parameter of a master has
the same accessibility level as the master.

@item
The accessibility level of a view of an object or subprogram defined by
a renaming_declaration is the same as that of the renamed view.

@item
The accessibility level of a view conversion is the same as that of the
operand.

@item
For a function whose result type is a return-by-reference type, the
accessibility level of the result object is the same as that of the
master that elaborated the function body. For any other function, the
accessibility level of the result object is that of the execution of the
called function.

@item
The accessibility level of a derived access type is the same as that of
its ultimate ancestor.

@item
The accessibility level of the anonymous access type of an access
discriminant is the same as that of the containing object or associated
constrained subtype.

@item
The accessibility level of the anonymous access type of an access
parameter is the same as that of the view designated by the actual. If
the actual is an allocator, this is the accessibility level of the
execution of the called subprogram.

@item
The accessibility level of an object created by an allocator is the same
as that of the access type.

@item
The accessibility level of a view of an object or subprogram denoted by
a dereference of an access value is the same as that of the access type.

@item
The accessibility level of a component, protected subprogram, or entry
of (a view of) a composite object is the same as that of (the view of)
the composite object.
@end enumerate
@end enumerate

@enumerate 17
@item
One accessibility level is defined to be statically deeper than another
in the following cases:

@enumerate 18
@item
For a master that is statically nested within another master, the
accessibility level of the inner master is statically deeper than that
of the outer master.

@item
The statically deeper relationship does not apply to the accessibility
level of the anonymous type of an access parameter; that is, such an
accessibility level is not considered to be statically deeper, nor
statically shallower, than any other.

@item
For determining whether one level is statically deeper than another when
within a generic package body, the generic package is presumed to be
instantiated at the same level as where it was declared; run-time checks
are needed in the case of more deeply nested instantiations.

@item
For determining whether one level is statically deeper than another when
within the declarative region of a type_declaration, the current
instance of the type is presumed to be an object created at a deeper
level than that of the type.
@end enumerate
@end enumerate

@enumerate 22
@item
The accessibility level of all library units is called the library
level; a library-level declaration or entity is one whose accessibility
level is the library level.

@item
The following attribute is defined for a prefix X that denotes an
aliased view of an object:

@item
X'Access

@example
X'Access yields an access value that designates the object
denoted by X. The type of X'Access is an access-to-object
type, as determined by the expected type. The expected type
shall be a general access type. X shall denote an aliased
view of an object, including possibly the current instance
(@pxref{8.6}) of a limited type within its definition, or a
formal parameter or generic formal object of a tagged type.
The view denoted by the prefix X shall satisfy the following
additional requirements, presuming the expected type for
X'Access is the general access type A:
@end example

@enumerate
@enumerate 25
@item
If A is an access-to-variable type, then the view shall be a variable;
on the other hand, if A is an access-to-constant type, the view may be
either a constant or a variable.

@item
The view shall not be a subcomponent that depends on discriminants of a
variable whose nominal subtype is unconstrained, unless this subtype is
indefinite, or the variable is aliased.

@item
If the designated type of A is tagged, then the type of the view shall
be covered by the designated type; if A's designated type is not tagged,
then the type of the view shall be the same, and either A's designated
subtype shall statically match the nominal subtype of the view, or the
designated subtype shall be discriminated and unconstrained;

@item
The accessibility level of the view shall not be statically deeper than
that of the access type A. In addition to the places where Legality
Rules normally apply, see @ref{12.3}, this rule applies also in the private
part of an instance of a generic unit.

@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 29
@item
A check is made that the accessibility level of X is not deeper than
that of the access type A. If this check fails, Program_Error is raised.

@item
If the nominal subtype of X does not statically match the designated
subtype of A, a view conversion of X to the designated subtype is
evaluated (which might raise Constraint_Error --  see @ref{4.6}.) and the
value of X'Access designates that view.

@end enumerate
@end enumerate

@enumerate 31
@item
The following attribute is defined for a prefix P that denotes a
subprogram:

@item
P'Access

@example
P'Access yields an access value that designates the
subprogram denoted by P. The type of P'Access is an
access-to-subprogram type (S), as determined by the expected
type. The accessibility level of P shall not be statically
deeper than that of S. In addition to the places where
Legality Rules normally apply, see @ref{12.3}, this rule applies
also in the private part of an instance of a generic unit.
The profile of P shall be subtype-conformant with the
designated profile of S, and shall not be Intrinsic. If
the subprogram denoted by P is declared within a generic
body, S shall be declared within the generic body.
@end example

NOTES

@item
(81) The Unchecked_Access attribute yields the same result as the Access
attribute for objects, but has fewer restrictions, see @ref{13.10}. There
are other predefined operations that yield access values: an allocator
can be used to create an object, and return an access value that
designates it, see @ref{4.8}, evaluating the literal null yields a null
access value that designates no entity at all, see @ref{4.2}.

@item
(82) The predefined operations of an access type also include the
assignment operation, qualification, and membership tests. Explicit
conversion is allowed between general access types with matching
designated subtypes; explicit conversion is allowed between
access-to-subprogram types with subtype conformant profiles, see @ref{4.6}.
Named access types have predefined equality operators; anonymous access
types do not, see @ref{4.5.2}.

@item
(83) The object or subprogram designated by an access value can be named
with a dereference, either an explicit_dereference or an
implicit_dereference (@pxref{4.1}).

@item
(84) A call through the dereference of an access-to-subprogram value is
never a dispatching call.

@item
(85) The accessibility rules imply that it is not possible to use the
Access attribute to implement ``downward closures'' -- that is, to pass
a more-nested subprogram as a parameter to a less-nested subprogram, as
might be desired for example for an iterator abstraction. Instead,
downward closures can be implemented using generic formal subprograms
(@pxref{12.6}). Note that Unchecked_Access is not allowed for subprograms.

@item
(86) Note that using an access-to-class-wide tagged type with a
dispatching operation is a potentially more structured alternative to
using an access-to-subprogram type.

@item
(87) An implementation may consider two access-to-subprogram values to
be unequal, even though they designate the same subprogram. This might
be because one points directly to the subprogram, while the other points
to a special prologue that performs an Elaboration_Check and then jumps
to the subprogram (@pxref{4.5.2}).

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of use of the Access attribute:

@item
@example
Martha : Person_Name := new Person(F);  --  see @ref{3.10.1}
Cars   : array (1..2) of aliased Car;
   ...
Martha.Vehicle := Cars(1)'Access;
George.Vehicle := Cars(2)'Access;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 3.11, 3.11.1, 3.10.2, 3
@section Declarative Parts

@enumerate
@item
A declarative_part contains declarative_items (possibly none).

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
declarative_part ::= @{declarative_item@}
@end example

@item
@example
declarative_item ::= basic_declarative_item | body
@end example

@item
@example
basic_declarative_item ::=
   basic_declaration | representation_clause | use_clause
@end example

@item
@example
body ::= proper_body | body_stub
@end example

@item
@example
proper_body ::=
   subprogram_body | package_body | task_body | protected_body
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a declarative_part consists of the elaboration of the
declarative_items, if any, in the order in which they are given in the
declarative_part.

@item
An elaborable construct is in the elaborated state after the normal
completion of its elaboration. Prior to that, it is not yet elaborated.

@item
For a construct that attempts to use a body, a check (Elaboration_Check)
is performed, as follows:

@enumerate 10
@item
For a call to a (non-protected) subprogram that has an explicit body, a
check is made that the subprogram_body is already elaborated. This check
and the evaluations of any actual parameters of the call are done in an
arbitrary order.

@item
For a call to a protected operation of a protected type (that has a body
-- no check is performed if a pragma Import applies to the protected
type), a check is made that the protected_body is already elaborated.
This check and the evaluations of any actual parameters of the call are
done in an arbitrary order.

@item
For the activation of a task, a check is made by the activator that the
task_body is already elaborated. If two or more tasks are being
activated together, see @ref{9.2}, as the result of the elaboration of a
declarative_part or the initialization for the object created by an
allocator, this check is done for all of them before activating any of
them.

@item
For the instantiation of a generic unit that has a body, a check is made
that this body is already elaborated. This check and the evaluation of
any explicit_generic_actual_parameters of the instantiation are done in
an arbitrary order.
@end enumerate
@end enumerate

@enumerate 14
@item
The exception Program_Error is raised if any of these checks fails.
@end enumerate

@menu
* 3.11.1:: Completions of Declarations
@end menu

@c ---------------------------------------------------------------------------
@node 3.11.1, 4, 3.11, 3.11
@subsection Completions of Declarations

@enumerate
@item
Declarations sometimes come in two parts. A declaration that requires a
second part is said to require completion. The second part is called the
completion of the declaration (and of the entity declared), and is
either another declaration, a body, or a pragma.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
A construct that can be a completion is interpreted as the completion of
a prior declaration only if:

@enumerate 3
@item
The declaration and the completion occur immediately within the same
declarative region;

@item
The defining name or defining_program_unit_name in the completion is the
same as in the declaration, or in the case of a pragma, the pragma
applies to the declaration;

@item
If the declaration is overloadable, then the completion either has a
type-conformant profile, or is a pragma.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 6
@item
An implicit declaration shall not have a completion. For any explicit
declaration that is specified to require completion, there shall be a
corresponding explicit completion.

@item
At most one completion is allowed for a given declaration. Additional
requirements on completions appear where each kind of completion is
defined.

@item
A type is completely defined at a place that is after its full type
definition (if it has one) and after all of its subcomponent types are
completely defined. A type shall be completely defined before it is
frozen, see @ref{13.14}, and @ref{7.3}.

NOTES

@item
(88) Completions are in principle allowed for any kind of explicit
declaration. However, for some kinds of declaration, the only allowed
completion is a pragma Import, and implementations are not required to
support pragma Import for every kind of entity.

@item
(89) There are rules that prevent premature uses of declarations that
have a corresponding completion. The Elaboration_Checks (@pxref{3.11})
prevent such uses at run time for subprograms, protected operations,
tasks, and generic units. The "Freezing Rules" (@pxref{13.14})
prevent, at compile time, premature uses of other entities such as
private types and deferred constants.
@end enumerate

@c ===========================================================================
@node 4, 4.1, 3.11.1, Top
@chapter Names and Expressions

@enumerate
@item
The rules applicable to the different forms of name and expression, and
to their evaluation, are given in this section.
@end enumerate

@menu
* 4.1:: Names
* 4.2:: Literals
* 4.3:: Aggregates
* 4.4:: Expressions
* 4.5:: Operators and Expression Evaluation
* 4.6:: Type Conversions
* 4.7:: Qualified Expressions
* 4.8:: Allocators
* 4.9:: Static Expressions and Static Subtypes

 --- The Detailed Node Listing ---

* 4.1::   Names
* 4.1.1:: Indexed Components
* 4.1.2:: Slices
* 4.1.3:: Selected Components
* 4.1.4:: Attributes
* 4.2::   Literals
* 4.3::   Aggregates
* 4.3.1:: Record Aggregates
* 4.3.2:: Extension Aggregates
* 4.3.3:: Array Aggregates
* 4.4::   Expressions
* 4.5::   Operators and Expression Evaluation
* 4.5.1:: Logical Operators and Short-circuit Control Forms
* 4.5.2:: Relational Operators and Membership Tests
* 4.5.3:: Binary Adding Operators
* 4.5.4:: Unary Adding Operators
* 4.5.5:: Multiplying Operators
* 4.5.6:: Highest Precedence Operators
* 4.6::   Type Conversions
* 4.7::   Qualified Expressions
* 4.8::   Allocators
* 4.9::   Static Expressions and Static Subtypes
* 4.9.1:: Statically Matching Constraints and Subtypes
@end menu

@c ---------------------------------------------------------------------------
@node 4.1, 4.1.1, 4, 4
@section Names

@enumerate
@item
Names can denote declared entities, whether declared explicitly or
implicitly, see @ref{3.1}. Names can also denote objects or subprograms
designated by access values; the results of type_conversions or
function_calls; subcomponents and slices of objects and values;
protected subprograms, single entries, entry families, and entries in
families of entries. Finally, names can denote attributes of any of the
foregoing.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
name ::=
     direct_name          | explicit_dereference
   | indexed_component    | slice
   | selected_component   | attribute_reference
   | type_conversion      | function_call
   | character_literal
@end example

@item
@example
direct_name ::= identifier | operator_symbol
@end example

@item
@example
prefix ::= name | implicit_dereference
@end example

@item
@example
explicit_dereference ::= name.all
@end example

@item
@example
implicit_dereference ::= name
@end example

@item
Certain forms of name (indexed_components, selected_components, slices,
and attributes) include a prefix that is either itself a name that
denotes some related entity, or an implicit_dereference of an access
value that designates some related entity.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The name in a dereference (either an implicit_dereference or an
explicit_dereference) is expected to be of any access type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If the type of the name in a dereference is some access-to-object type
T, then the dereference denotes a view of an object, the nominal subtype
of the view being the designated subtype of T.

@item
If the type of the name in a dereference is some access-to-subprogram
type S, then the dereference denotes a view of a subprogram, the profile
of the view being the designated profile of S.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The evaluation of a name determines the entity denoted by the name. This
evaluation has no other effect for a name that is a direct_name or a
character_literal.

@item
The evaluation of a name that has a prefix includes the evaluation of
the prefix. The evaluation of a prefix consists of the evaluation of the
name or the implicit_dereference. The prefix denotes the entity denoted
by the name or the implicit_dereference.

@item
The evaluation of a dereference consists of the evaluation of the name
and the determination of the object or subprogram that is designated by
the value of the name. A check is made that the value of the name is not
the null access value. Constraint_Error is raised if this check fails.
The dereference denotes the object or subprogram designated by the value
of the name.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of direct names:

@item
@example
Pi      -- the direct name of a number            (@pxref{3.3.2})
Limit   -- the direct name of a constant          (@pxref{3.3.1})
Count   -- the direct name of a scalar variable   (@pxref{3.3.1})
Board   -- the direct name of an array variable   (@pxref{3.6.1})
Matrix  -- the direct name of a type              (@pxref{3.6})
Random  -- the direct name of a function          (@pxref{6.1})
Error   -- the direct name of an exception        (@pxref{11.1})
@end example

@item
Examples of dereferences:

@item
@example
Next_Car.all    --  explicit dereference denoting the object
                --  designated by the access variable Next_Car,
                --  see @ref{3.10.1}
Next_Car.Owner  --  selected component with implicit dereference;
                --  same as Next_Car.all.Owner
@end example
@end enumerate

@menu
* 4.1.1:: Indexed Components
* 4.1.2:: Slices
* 4.1.3:: Selected Components
* 4.1.4:: Attributes
@end menu

@c ---------------------------------------------------------------------------
@node 4.1.1, 4.1.2, 4.1, 4.1
@subsection Indexed Components

@enumerate
@item
An indexed_component denotes either a component of an array or an entry
in a family of entries.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
indexed_component ::= prefix(expression @{, expression@})
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The prefix of an indexed_component with a given number of expressions
shall resolve to denote an array (after any implicit dereference) with
the corresponding number of index positions, or shall resolve to denote
an entry family of a task or protected object (in which case there shall
be only one expression).

@item
The expected type for each expression is the corresponding index type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
When the prefix denotes an array, the indexed_component denotes the
component of the array with the specified index value(s). The nominal
subtype of the indexed_component is the component subtype of the array
type.

@item
When the prefix denotes an entry family, the indexed_component denotes
the individual entry of the entry family with the specified index value.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of an indexed_component, the prefix and the
expressions are evaluated in an arbitrary order. The value of each
expression is converted to the corresponding index type. A check is made
that each index value belongs to the corresponding index range of the
array or entry family denoted by the prefix. Constraint_Error is raised
if this check fails.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of indexed components:

@item
@example
My_Schedule(Sat)
--  a component of a one-dimensional array   (see @pxref{3.6.1})

Page(10)
--  a component of a one-dimensional array   (see @pxref{3.6})

Board(M, J + 1)
--  a component of a two-dimensional array   (see @pxref{3.6.1})

Page(10)(20)
--  a component of a component               (see @pxref{3.6})

Request(Medium)
--  an entry in a family of entries          (see @pxref{9.1})

Next_Frame(L)(M, N)
--  a component of a function call           (see @pxref{6.1})
@end example

NOTES

@item
(1) Notes on the examples: Distinct notations are used for components of
multidimensional arrays (such as Board) and arrays of arrays (such as
Page). The components of an array of arrays are arrays and can therefore
be indexed. Thus Page(10)(20) denotes the 20th component of Page(10). In
the last example Next_Frame(L) is a function call returning an access
value that designates a two-dimensional array.
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.1.2, 4.1.3, 4.1.1, 4.1
@subsection Slices

@enumerate
@item
A slice denotes a one-dimensional array formed by a sequence of
consecutive components of a one-dimensional array. A slice of a variable
is a variable; a slice of a constant is a constant; a slice of a value
is a value.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
slice ::= prefix(discrete_range)
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The prefix of a slice shall resolve to denote a one-dimensional array
(after any implicit dereference).

@item
The expected type for the discrete_range of a slice is the index type of
the array type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A slice denotes a one-dimensional array formed by the sequence of
consecutive components of the array denoted by the prefix, corresponding
to the range of values of the index given by the discrete_range.

@item
The type of the slice is that of the prefix. Its bounds are those
defined by the discrete_range.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of a slice, the prefix and the discrete_range are
evaluated in an arbitrary order. If the slice is not a null slice (a
slice where the discrete_range is a null range), then a check is made
that the bounds of the discrete_range belong to the index range of the
array denoted by the prefix. Constraint_Error is raised if this check
fails.

NOTES

@item
(2) A slice is not permitted as the prefix of an Access
attribute_reference, even if the components or the array as a whole are
aliased (@pxref{3.10.2}).

@item
(3) For a one-dimensional array A, the slice A(N .. N) denotes an array
that has only one component; its type is the type of A. On the other
hand, A(N) denotes a component of the array A and has the corresponding
component type.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of slices:

@item
@example
Stars(1 .. 15)
--  a slice of 15 characters         (see @ref{3.6.3})

Page(10 .. 10 + Size)
--  a slice of 1 + Size components   (see @ref{3.6})

Page(L)(A .. B)
--  a slice of the array Page(L)     (see @ref{3.6})

Stars(1 .. 0)
--  a null slice                     (see @ref{3.6.3})

My_Schedule(Weekday)
--  bounds given by subtype          (see @ref{3.6.1}, and @ref{3.5.1})

Stars(5 .. 15)(K)
--  same as Stars(K)                 (see @ref{3.6.3})
--  provided that K is in 5 .. 15
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.1.3, 4.1.4, 4.1.2, 4.1
@subsection Selected Components

@enumerate
@item
Selected_components are used to denote components (including
discriminants), entries, entry families, and protected subprograms; they
are also used as expanded names as described below.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
selected_component ::= prefix . selector_name
@end example

@item
@example
selector_name ::= identifier | character_literal | operator_symbol
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
A selected_component is called an expanded name if, according to the
visibility rules, at least one possible interpretation of its prefix
denotes a package or an enclosing named construct (directly, not through
a subprogram_renaming_declaration or generic_renaming_declaration).

@item
A selected_component that is not an expanded name shall resolve to
denote one of the following:

@enumerate 6
@item
A component (including a discriminant):

@enumerate 7
@item
The prefix shall resolve to denote an object or value of some non-array
composite type (after any implicit dereference). The selector_name shall
resolve to denote a discriminant_specification of the type, or, unless
the type is a protected type, a component_declaration of the type. The
selected_component denotes the corresponding component of the object or
value.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 8
@item
A single entry, an entry family, or a protected subprogram:

@enumerate 9
@item
The prefix shall resolve to denote an object or value of some task or
protected type (after any implicit dereference). The selector_name shall
resolve to denote an entry_declaration or subprogram_declaration
occurring (implicitly or explicitly) within the visible part of that
type. The selected_component denotes the corresponding entry, entry
family, or protected subprogram.
@end enumerate
@end enumerate
@end enumerate

@enumerate 10
@item
An expanded name shall resolve to denote a declaration that occurs
immediately within a named declarative region, as follows:

@enumerate 11
@item
The prefix shall resolve to denote either a package (including the
current instance of a generic package, or a rename of a package), or an
enclosing named construct.

@item
The selector_name shall resolve to denote a declaration that occurs
immediately within the declarative region of the package or enclosing
construct (the declaration shall be visible at the place of the expanded
name --  see @ref{8.3}.). The expanded name denotes that declaration.

@item
If the prefix does not denote a package, then it shall be a direct_name
or an expanded name, and it shall resolve to denote a program unit
(other than a package), the current instance of a type, a
block_statement, a loop_statement, or an accept_statement (in the case
of an accept_statement or entry_body, no family index is allowed); the
expanded name shall occur within the declarative region of this
construct. Further, if this construct is a callable construct and the
prefix denotes more than one such enclosing callable construct, then the
expanded name is ambiguous, independently of the selector_name.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 14
@item
The evaluation of a selected_component includes the evaluation of the
prefix.

@item
For a selected_component that denotes a component of a variant, a check
is made that the values of the discriminants are such that the value or
object denoted by the prefix has this component. The exception
Constraint_Error is raised if this check fails.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of selected components:

@item
@example
Tomorrow.Month
--  a record component                    (see @ref{3.8})

Next_Car.Owner
--  a record component                    (see @ref{3.10.1})

Next_Car.Owner.Age
--  a record component                    (see @ref{3.10.1})
--  the previous two lines involve implicit dereferences

Writer.Unit
--  a record component (a discriminant)   (see @ref{3.8.1})

Min_Cell(H).Value
--  a record component of the result      (see @ref{6.1})
--  of the function call Min_Cell(H)

Control.Seize
--  an entry of a protected object        (see @ref{9.4})

Pool(K).Write
--  an entry of the task Pool(K)          (see @ref{9.4})
@end example

@item
Examples of expanded names:

@item
@example
Key_Manager."<"
--  an operator of the visible part of a package   (see @ref{7.3.1})

Dot_Product.Sum
--  a variable declared in a function body         (see @ref{6.1})

Buffer.Pool
--  a variable declared in a protected unit        (see @ref{9.11})

Buffer.Read
--  an entry of a protected unit                   (see @ref{9.11})

Swap.Temp
--  a variable declared in a block statement       (see @ref{5.6})

Standard.Boolean
--  the name of a predefined type                  (see @ref{A.1})
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.1.4, 4.2, 4.1.3, 4.1
@subsection Attributes

@enumerate
@item
An attribute is a characteristic of an entity that can be queried via an
attribute_reference or a range_attribute_reference.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
attribute_reference ::= prefix'attribute_designator
@end example

@item
@example
attribute_designator ::=
     identifier[(static_expression)]
   | Access | Delta | Digits
@end example

@item
@example
range_attribute_reference ::= prefix'range_attribute_designator
@end example

@item
@example
range_attribute_designator ::= Range[(static_expression)]
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
In an attribute_reference, if the attribute_designator is for an
attribute defined for (at least some) objects of an access type, then
the prefix is never interpreted as an implicit_dereference; otherwise
(and for all range_attribute_references), if the type of the name within
the prefix is of an access type, the prefix is interpreted as an
implicit_dereference. Similarly, if the attribute_designator is for an
attribute defined for (at least some) functions, then the prefix is
never interpreted as a parameterless function_call; otherwise (and for
all range_attribute_references), if the prefix consists of a name that
denotes a function, it is interpreted as a parameterless function_call.

@item
The expression, if any, in an attribute_designator or
range_attribute_designator is expected to be of any integer type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The expression, if any, in an attribute_designator or
range_attribute_designator shall be static.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An attribute_reference denotes a value, an object, a subprogram, or some
other kind of program entity.

@item
A range_attribute_reference X'Range(N) is equivalent to the range
X'First(N) .. X'Last(N), except that the prefix is only evaluated once.
Similarly, X'Range is equivalent to X'First .. X'Last, except that the
prefix is only evaluated once.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The evaluation of an attribute_reference (or range_attribute_reference)
consists of the evaluation of the prefix.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may provide implementation-defined attributes; the
identifier for an implementation-defined attribute shall differ from
those of the language-defined attributes.

NOTES

@item
(4) Attributes are defined throughout this International Standard, and
are summarized in @ref{K, ``Annex K.''}.

@item
(5) In general, the name in a prefix of an attribute_reference (or a
range_attribute_reference) has to be resolved without using any context.
However, in the case of the Access attribute, the expected type for the
prefix has to be a single access type, and if it is an
access-to-subprogram type, see @ref{3.10.2}, then the resolution of the
name can use the fact that the profile of the callable entity denoted by
the prefix has to be type conformant with the designated profile of the
access type.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of attributes:

@item
@example
Color'First
-- minimum value of the enumeration type Color    (see @ref{3.5.1})

Rainbow'Base'First
-- same as Color'First                            (see @ref{3.5.1})

Real'Digits
-- precision of the type Real                     (see @ref{3.5.7})

Board'Last(2)
-- upper bound of the second dimension of Board   (see @ref{3.6.1})

Board'Range(1)
-- index range of the first dimension of Board    (see @ref{3.6.1})

Pool(K)'Terminated
-- True if task Pool(K) is terminated             (see @ref{9.1})

Date'Size
-- number of bits for records of type Date        (see @ref{3.8})

Message'Address
-- address of the record variable Message         (see @ref{3.7.1})
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.2, 4.3, 4.1.4, 4
@section Literals

@enumerate
@item
A literal represents a value literally, that is, by means of notation
suited to its kind. A literal is either a numeric_literal, a
character_literal, the literal null, or a string_literal.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for a literal null shall be a single access type.

@item
For a name that consists of a character_literal, either its expected
type shall be a single character type, in which case it is interpreted
as a parameterless function_call that yields the corresponding value of
the character type, or its expected profile shall correspond to a
parameterless function with a character result type, in which case it is
interpreted as the name of the corresponding parameterless function
declared as part of the character type's definition, see @ref{3.5.1}. In
either case, the character_literal denotes the
enumeration_literal_specification.

@item
The expected type for a primary that is a string_literal shall be a
single string type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A character_literal that is a name shall correspond to a
defining_character_literal of the expected type, or of the result type
of the expected profile.

@item
For each character of a string_literal with a given expected string
type, there shall be a corresponding defining_character_literal of the
component type of the expected string type.

@item
A literal null shall not be of an anonymous access type, since such
types do not have a null value, see @ref{3.10}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An integer literal is of type universal_integer. A real literal is of
type universal_real.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The evaluation of a numeric literal, or the literal null, yields the
represented value.

@item
The evaluation of a string_literal that is a primary yields an array
value containing the value of each character of the sequence of
characters of the string_literal, as defined in @ref{2.6}. The bounds
of this array value are determined according to the rules for
positional_array_aggregates (@pxref{4.3.3}), except that for a null string
literal the upper bound is the predecessor of the lower bound.

@item
For the evaluation of a string_literal of type T, a check is made that
the value of each character of the string_literal belongs to the
component subtype of T. For the evaluation of a null string literal, a
check is made that its lower bound is greater than the lower bound of
the base range of the index type. The exception Constraint_Error is
raised if either of these checks fails.

NOTES

@item
(6) Enumeration literals that are identifiers rather than
character_literals follow the normal rules for identifiers when used in
a name, see @ref{4.1}, and @ref{4.1.3}. Character_literals used as
selector_names follow the normal rules for expanded names, see @ref{4.1.3}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of literals:

@item
@example
3.14159_26536    --  a real literal
1_345            --  an integer literal
'A'              --  a character literal
"Some Text"      --  a string literal
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.3, 4.3.1, 4.2, 4
@section Aggregates

@enumerate
@item
An aggregate combines component values into a composite value of an
array type, record type, or record extension.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
aggregate ::=
   record_aggregate | extension_aggregate | array_aggregate
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for an aggregate shall be a single nonlimited array
type, record type, or record extension.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An aggregate shall not be of a class-wide type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of an aggregate, an anonymous object is created and
values for the components or ancestor part are obtained (as described in
the subsequent subclause for each kind of the aggregate) and assigned
into the corresponding components or ancestor part of the anonymous
object. Obtaining the values and the assignments occur in an arbitrary
order. The value of the aggregate is the value of this object.

@item
If an aggregate is of a tagged type, a check is made that its value
belongs to the first subtype of the type. Constraint_Error is raised if
this check fails.
@end enumerate

@menu
* 4.3.1:: Record Aggregates
* 4.3.2:: Extension Aggregates
* 4.3.3:: Array Aggregates
@end menu

@c ---------------------------------------------------------------------------
@node 4.3.1, 4.3.2, 4.3, 4.3
@subsection Record Aggregates

@enumerate
@item
In a record_aggregate, a value is specified for each component of the
record or record extension value, using either a named or a positional
association.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
record_aggregate ::= (record_component_association_list)
@end example

@item
@example
record_component_association_list ::=
     record_component_association @{, record_component_association@}
   | null record
@end example

@item
@example
record_component_association ::=
   [ component_choice_list => ] expression
@end example

@item
@example
component_choice_list ::=
     component_selector_name @{| component_selector_name@}
   | others
@end example

@enumerate 6
@item
A record_component_association is a named component association if it
has a component_choice_list; otherwise, it is a positional component
association. Any positional component associations shall precede any
named component associations. If there is a named association with a
component_choice_list of others, it shall come last.

@item
In the record_component_association_list for a record_aggregate, if
there is only one association, it shall be a named association.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 8
@item
The expected type for a record_aggregate shall be a single nonlimited
record type or record extension.

@item
For the record_component_association_list of a record_aggregate, all
components of the composite value defined by the aggregate are needed;
for the association list of an extension_aggregate, only those
components not determined by the ancestor expression or subtype are
needed, see @ref{4.3.2}. Each selector_name in a
record_component_association shall denote a needed component (including
possibly a discriminant).

@item
The expected type for the expression of a record_component_association
is the type of the associated component(s); the associated component(s)
are as follows:

@enumerate 11
@item
For a positional association, the component (including possibly a
discriminant) in the corresponding relative position (in the declarative
region of the type), counting only the needed components;

@item
For a named association with one or more component_selector_names, the
named component(s);

@item
For a named association with the reserved word others, all needed
components that are not associated with some previous association.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 14
@item
If the type of a record_aggregate is a record extension, then it shall
be a descendant of a record type, through one or more record extensions
(and no private extensions).

@item
If there are no components needed in a given
record_component_association_list, then the reserved words null record
shall appear rather than a list of record_component_associations.

@item
Each record_component_association shall have at least one associated
component, and each needed component shall be associated with exactly
one record_component_association. If a record_component_association has
two or more associated components, all of them shall be of the same
type.

@item
If the components of a variant_part are needed, then the value of a
discriminant that governs the variant_part shall be given by a static
expression.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The evaluation of a record_aggregate consists of the evaluation of the
record_component_association_list.

@item
For the evaluation of a record_component_association_list, any
per-object constraints, see @ref{3.8}, for components specified in the
association list are elaborated and any expressions are evaluated and
converted to the subtype of the associated component. Any constraint
elaborations and expression evaluations (and conversions) occur in an
arbitrary order, except that the expression for a discriminant is
evaluated (and converted) prior to the elaboration of any per-object
constraint that depends on it, which in turn occurs prior to the
evaluation and conversion of the expression for the component with the
per-object constraint.

@item
The expression of a record_component_association is evaluated (and
converted) once for each associated component.

NOTES

@item
(7) For a record_aggregate with positional associations, expressions
specifying discriminant values appear first since the
known_discriminant_part is given first in the declaration of the type;
they have to be in the same order as in the known_discriminant_part.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a record aggregate with positional associations:

@item
@example
(4, July, 1776)  --  see @ref{3.8}
@end example

@item
Examples of record aggregates with named associations:

@item
@example
(Day => 4, Month => July, Year => 1776)
(Month => July, Day => 4, Year => 1776)
@end example

@item
@example
(Disk, Closed, Track => 5, Cylinder => 12)  --  see @ref{3.8.1}
(Unit => Disk, Status => Closed, Cylinder => 9, Track => 1)
@end example

@item
Example of component association with several choices:

@item
@example
(Value => 0, Succ|Pred => new Cell'(0, null, null))
--  see @ref{3.10.1}
@end example

@item
@example
--  The allocator is evaluated twice:
--  Succ and Pred designate different cells
@end example

@item
Examples of record aggregates for tagged types, see @ref{3.9}, and @ref{3.9.1}

@item
@example
Expression'(null record)
Literal'(Value => 0.0)
Painted_Point'(0.0, Pi/2.0, Paint => Red)
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.3.2, 4.3.3, 4.3.1, 4.3
@subsection Extension Aggregates

@enumerate
@item
An extension_aggregate specifies a value for a type that is a record
extension by specifying a value or subtype for an ancestor of the type,
followed by associations for any components not determined by the
ancestor_part.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
extension_aggregate ::=
   (ancestor_part with record_component_association_list)
@end example

@item
@example
ancestor_part ::= expression | subtype_mark
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for an extension_aggregate shall be a single
nonlimited type that is a record extension. If the ancestor_part is an
expression, it is expected to be of any nonlimited tagged type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If the ancestor_part is a subtype_mark, it shall denote a specific
tagged subtype. The type of the extension_aggregate shall be derived
from the type of the ancestor_part, through one or more record
extensions (and no private extensions).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For the record_component_association_list of an extension_aggregate, the
only components needed are those of the composite value defined by the
aggregate that are not inherited from the type of the ancestor_part,
plus any inherited discriminants if the ancestor_part is a subtype_mark
that denotes an unconstrained subtype.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of an extension_aggregate, the
record_component_association_list is evaluated. If the ancestor_part is
an expression, it is also evaluated; if the ancestor_part is a
subtype_mark, the components of the value of the aggregate not given by
the record_component_association_list are initialized by default as for
an object of the ancestor type. Any implicit initializations or
evaluations are performed in an arbitrary order, except that the
expression for a discriminant is evaluated prior to any other evaluation
or initialization that depends on it.

@item
If the type of the ancestor_part has discriminants that are not
inherited by the type of the extension_aggregate, then, unless the
ancestor_part is a subtype_mark that denotes an unconstrained subtype, a
check is made that each discriminant of the ancestor has the value
specified for a corresponding discriminant, either in the
record_component_association_list, or in the derived_type_definition for
some ancestor of the type of the extension_aggregate. Constraint_Error
is raised if this check fails.

NOTES

@item
(8) If all components of the value of the extension_aggregate are
determined by the ancestor_part, then the
record_component_association_list is required to be simply null record.

@item
(9) If the ancestor_part is a subtype_mark, then its type can be
abstract. If its type is controlled, then as the last step of evaluating
the aggregate, the Initialize procedure of the ancestor type is called,
unless the Initialize procedure is abstract, see @ref{7.6}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of extension aggregates (for types defined in @ref{3.9.1}.):

@item
@example
Painted_Point'(Point with Red)
(Point'(P) with Paint => Black)
@end example

@item
@example
(Expression with Left => 1.2, Right => 3.4)
Addition'(Binop with null record)
-- presuming Binop is of type Binary_Operation
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.3.3, 4.4, 4.3.2, 4.3
@subsection Array Aggregates

@enumerate
@item
In an array_aggregate, a value is specified for each component of an
array, either positionally or by its index. For a
positional_array_aggregate, the components are given in increasing-index
order, with a final others, if any, representing any remaining
components. For a named_array_aggregate, the components are identified
by the values covered by the discrete_choices.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
array_aggregate ::=
   positional_array_aggregate | named_array_aggregate
@end example

@item
@example
positional_array_aggregate ::=
     (expression, expression @{, expression@})
   | (expression @{, expression@}, others => expression)
@end example

@item
@example
named_array_aggregate ::=
   (array_component_association @{, array_component_association@})
@end example

@item
@example
array_component_association ::=
   discrete_choice_list => expression
@end example

@item
An n-dimensional array_aggregate is one that is written as n levels of
nested array_aggregates (or at the bottom level, equivalent
string_literals). For the multidimensional case (n >= 2) the
array_aggregates (or equivalent string_literals) at the n-1 lower levels
are called subaggregates of the enclosing n-dimensional array_aggregate.
The expressions of the bottom level subaggregates (or of the
array_aggregate itself if one-dimensional) are called the array
component expressions of the enclosing n-dimensional array_aggregate.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for an array_aggregate (that is not a subaggregate)
shall be a single nonlimited array type. The component type of this
array type is the expected type for each array component expression of
the array_aggregate.

@item
The expected type for each discrete_choice in any discrete_choice_list
of a named_array_aggregate is the type of the corresponding index; the
corresponding index for an array_aggregate that is not a subaggregate is
the first index of its type; for an (n-m)-dimensional subaggregate
within an array_aggregate of an n-dimensional type, the corresponding
index is the index in position m+1.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An array_aggregate of an n-dimensional array type shall be written as an
n-dimensional array_aggregate.

@item
An others choice is allowed for an array_aggregate only if an applicable
index constraint applies to the array_aggregate. An applicable index
constraint is a constraint provided by certain contexts where an
array_aggregate is permitted that can be used to determine the bounds of
the array value specified by the aggregate. Each of the following
contexts (and none other) defines an applicable index constraint:

@enumerate 11
@item
For an explicit_actual_parameter, an explicit_generic_actual_parameter,
the expression of a return_statement, the initialization expression in
an object_declaration, or a default_expression (for a parameter or a
component), when the nominal subtype of the corresponding formal
parameter, generic formal parameter, function result, object, or
component is a constrained array subtype, the applicable index
constraint is the constraint of the subtype;

@item
For the expression of an assignment_statement where the name denotes an
array variable, the applicable index constraint is the constraint of the
array variable;

@item
For the operand of a qualified_expression whose subtype_mark denotes a
constrained array subtype, the applicable index constraint is the
constraint of the subtype;

@item
For a component expression in an aggregate, if the component's nominal
subtype is a constrained array subtype, the applicable index constraint
is the constraint of the subtype;

@item
For a parenthesized expression, the applicable index constraint is that,
if any, defined for the expression.
@end enumerate
@end enumerate

@enumerate 16
@item
The applicable index constraint applies to an array_aggregate that
appears in such a context, as well as to any subaggregates thereof. In
the case of an explicit_actual_parameter (or default_expression) for a
call on a generic formal subprogram, no applicable index constraint is
defined.

@item
The discrete_choice_list of an array_component_association is allowed to
have a discrete_choice that is a nonstatic expression or that is a
discrete_range that defines a nonstatic or null range, only if it is the
single discrete_choice of its discrete_choice_list, and there is only
one array_component_association in the array_aggregate.

@item
In a named_array_aggregate with more than one discrete_choice, no two
discrete_choices are allowed to cover the same value, see @ref{3.8.1}, if
there is no others choice, the discrete_choices taken together shall
exactly cover a contiguous sequence of values of the corresponding index
type.

@item
A bottom level subaggregate of a multidimensional array_aggregate of a
given array type is allowed to be a string_literal only if the component
type of the array type is a character type; each character of such a
string_literal shall correspond to a defining_character_literal of the
component type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A subaggregate that is a string_literal is equivalent to one that is a
positional_array_aggregate of the same length, with each expression
being the character_literal for the corresponding character of the
string_literal.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The evaluation of an array_aggregate of a given array type proceeds in
two steps:

@enumerate 22
@item
Any discrete_choices of this aggregate and of its subaggregates are
evaluated in an arbitrary order, and converted to the corresponding
index type;

@item
The array component expressions of the aggregate are evaluated in an
arbitrary order and their values are converted to the component subtype
of the array type; an array component expression is evaluated once for
each associated component.
@end enumerate
@end enumerate

@enumerate 24
@item
The bounds of the index range of an array_aggregate (including a
subaggregate) are determined as follows:

@enumerate 25
@item
For an array_aggregate with an others choice, the bounds are those of
the corresponding index range from the applicable index constraint;

@item
For a positional_array_aggregate (or equivalent string_literal) without
an others choice, the lower bound is that of the corresponding index
range in the applicable index constraint, if defined, or that of the
corresponding index subtype, if not; in either case, the upper bound is
determined from the lower bound and the number of expressions (or the
length of the string_literal);

@item
For a named_array_aggregate without an others choice, the bounds are
determined by the smallest and largest index values covered by any
discrete_choice_list.
@end enumerate
@end enumerate

@enumerate 28
@item
For an array_aggregate, a check is made that the index range defined by
its bounds is compatible with the corresponding index subtype.

@item
For an array_aggregate with an others choice, a check is made that no
expression is specified for an index value outside the bounds determined
by the applicable index constraint.

@item
For a multidimensional array_aggregate, a check is made that all
subaggregates that correspond to the same index have the same bounds.

@item
The exception Constraint_Error is raised if any of the above checks
fail.

NOTES

@item
(10) In an array_aggregate, positional notation may only be used with
two or more expressions; a single expression in parentheses is
interpreted as a parenthesized_expression. A named_array_aggregate, such
as (1 => X), may be used to specify an array with a single component.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of array aggregates with positional associations:

@item
@example
(7, 9, 5, 1, 3, 2, 4, 8, 6, 0)
Table'(5, 8, 4, 1, others => 0)  --  see @ref{3.6}
@end example

@item
Examples of array aggregates with named associations:

@item
@example
(1 .. 5 => (1 .. 8 => 0.0))  --  two-dimensional
(1 .. N => new Cell)         --  N new cells, in particular for N = 0
@end example

@item
@example
Table'(2 | 4 | 10 => 1, others => 0)

Schedule'(Mon .. Fri => True,  others => False)
Schedule'(Wed | Sun  => False, others => True)
--  see @ref{3.6}

Vector'(1 => 2.5)
--  single-component vector
@end example

@item
Examples of two-dimensional array aggregates:

@item
@example
-- Three aggregates for the same value of subtype
--  Matrix(1..2,1..3), see @ref{3.6}
@end example

@item
@example
((1.1, 1.2, 1.3), (2.1, 2.2, 2.3))
(1 => (1.1, 1.2, 1.3), 2 => (2.1, 2.2, 2.3))
(1 => (1 => 1.1, 2 => 1.2, 3 => 1.3),
  2 => (1 => 2.1, 2 => 2.2, 3 => 2.3))
@end example

@item
Examples of aggregates as initial values:

@item
@example
A : Table := (7, 9, 5, 1, 3, 2, 4, 8, 6, 0);
-- A(1)=7, A(10)=0

B : Table := (2 | 4 | 10 => 1, others => 0);
-- B(1)=0, B(10)=1

C : constant Matrix := (1 .. 5 => (1 .. 8 => 0.0));
-- C'Last(1)=5, C'Last(2)=8
@end example

@item
@example
D : Bit_Vector(M .. N) := (M .. N => True);  --  see @ref{3.6}
E : Bit_Vector(M .. N) := (others => True);
F : String(1 .. 1) := (1 => 'F');
-- a one component aggregate: same as "F"
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.4, 4.5, 4.3.3, 4
@section Expressions

@enumerate
@item
An expression is a formula that defines the computation or retrieval of
a value. In this International Standard, the term ``expression'' refers
to a construct of the syntactic category expression or of any of the
other five syntactic categories defined below.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
expression ::=
     relation @{and relation@} | relation @{and then relation@}
   | relation @{or relation@}  | relation @{or else relation@}
   | relation @{xor relation@}
@end example

@item
@example
relation ::=
     simple_expression [relational_operator simple_expression]
   | simple_expression [not] in range
   | simple_expression [not] in subtype_mark
@end example

@item
@example
simple_expression ::=
   [unary_adding_operator] term @{binary_adding_operator term@}
@end example

@item
@example
term ::= factor @{multiplying_operator factor@}
@end example

@item
@example
factor ::= primary [** primary] | abs primary | not primary
@end example

@item
@example
primary ::=
     numeric_literal   | null
   | string_literal    | aggregate
   | name              | qualified_expression
   | allocator         | (expression)
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
A name used as a primary shall resolve to denote an object or a value.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Each expression has a type; it specifies the computation or retrieval of
a value of that type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The value of a primary that is a name denoting an object is the value of
the object.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
For the evaluation of a primary that is a name denoting an object of an
unconstrained numeric subtype, if the value of the object is outside the
base range of its type, the implementation may either raise
Constraint_Error or return the value of the object.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of primaries:

@item
@example
4.0                --  real literal
Pi                 --  named number
(1 .. 10 => 0)     --  array aggregate
Sum                --  variable
Integer'Last       --  attribute
Sine(X)            --  function call
Color'(Blue)       --  qualified expression
Real(M*N)          --  conversion
(Line_Count + 10)  --  parenthesized expression
@end example

@item
Examples of expressions:

@item
@example
Volume                      -- primary
not Destroyed               -- factor
2*Line_Count                -- term
-4.0                        -- simple expression
-4.0 + A                    -- simple expression
B**2 - 4.0*A*C              -- simple expression
Password(1 .. 3) = "Bwv"    -- relation
Count in Small_Int          -- relation
Count not in Small_Int      -- relation
Index = 0 or Item_Hit       -- expression
(Cold and Sunny) or Warm    -- expression (parentheses are required)
A**(B**C)                   -- expression (parentheses are required)
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.5, 4.5.1, 4.4, 4
@section Operators and Expression Evaluation

@enumerate
@item
The language defines the following six categories of operators (given in
order of increasing precedence). The corresponding operator_symbols, and
only those, can be used as designators in declarations of functions for
user-defined operators (@pxref{6.6, ``Overloading of Operators''}).

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
logical_operator            ::=  and | or  | xor
@end example

@item
@example
relational_operator         ::=  =   | /=  | <   | <= | > | >=
@end example

@item
@example
binary_adding_operator      ::=  +   | -   | &
@end example

@item
@example
unary_adding_operator       ::=  +   | -
@end example

@item
@example
multiplying_operator        ::=  *   | /   | mod | rem
@end example

@item
@example
highest_precedence_operator ::=  **  | abs | not
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a sequence of operators of the same precedence level, the operators
are associated with their operands in textual order from left to right.
Parentheses can be used to impose specific associations.

@item
For each form of type definition, certain of the above operators are
predefined; that is, they are implicitly declared immediately after the
type definition. For each such implicit operator declaration, the
parameters are called Left and Right for binary operators; the single
parameter is called Right for unary operators. An expression of the form
X op Y, where op is a binary operator, is equivalent to a function_call
of the form "op"(X, Y). An expression of the form op Y, where op is a
unary operator, is equivalent to a function_call of the form "op"(Y).
The predefined operators and their effects are described in subclauses
@ref{4.5.1} through @ref{4.5.6}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The predefined operations on integer types either yield the
mathematically correct result or raise the exception Constraint_Error.
For implementations that support the Numerics Annex, the predefined
operations on real types yield results whose accuracy is defined in
@ref{G, ``Annex G''}, or raise the exception Constraint_Error.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation of a predefined operator that delivers a result of an
integer or fixed point type may raise Constraint_Error only if the
result is outside the base range of the result type.

@item
The implementation of a predefined operator that delivers a result of a
floating point type may raise Constraint_Error only if the result is
outside the safe range of the result type.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
For a sequence of predefined operators of the same precedence level (and
in the absence of parentheses imposing a specific association), an
implementation may impose any association of the operators with operands
so long as the result produced is an allowed result for the
left-to-right association, but ignoring the potential for failure of
language-defined checks in either the left-to-right or chosen order of
association.

NOTES

@item
(11) The two operands of an expression of the form X op Y, where op is a
binary operator, are evaluated in an arbitrary order, as for any
function_call, see @ref{6.4}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of precedence:

@item
@example
not Sunny or Warm    --  same as (not Sunny) or Warm
X > 4.0 and Y > 0.0  --  same as (X > 4.0) and (Y > 0.0)
@end example

@item
@example
-4.0*A**2            --  same as -(4.0 * (A**2))
abs(1 + A) + B       --  same as (abs (1 + A)) + B
Y**(-3)              --  parentheses are necessary
A / B * C            --  same as (A/B)*C
A + (B + C)          --  evaluate B + C before adding it to A
@end example
@end enumerate

@menu
* 4.5.1:: Logical Operators and Short-circuit Control Forms
* 4.5.2:: Relational Operators and Membership Tests
* 4.5.3:: Binary Adding Operators
* 4.5.4:: Unary Adding Operators
* 4.5.5:: Multiplying Operators
* 4.5.6:: Highest Precedence Operators
@end menu

@c ---------------------------------------------------------------------------
@node 4.5.1, 4.5.2, 4.5, 4.5
@subsection Logical Operators and Short-circuit Control Forms

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate
@item
An expression consisting of two relations connected by and then or or
else (a short-circuit control form) shall resolve to be of some boolean
type; the expected type for both relations is that same boolean type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following logical operators are predefined for every boolean type T,
for every modular type T, and for every one-dimensional array type T
whose component type is a boolean type:

@item
@example
function "and"(Left, Right : T) return T
function "or" (Left, Right : T) return T
function "xor"(Left, Right : T) return T
@end example

@item
For boolean types, the predefined logical operators and, or, and xor
perform the conventional operations of conjunction, inclusive
disjunction, and exclusive disjunction, respectively.

@item
For modular types, the predefined logical operators are defined on a
bit-by-bit basis, using the binary representation of the value of the
operands to yield a binary representation for the result, where zero
represents False and one represents True. If this result is outside the
base range of the type, a final subtraction by the modulus is performed
to bring the result into the base range of the type.

@item
The logical operators on arrays are performed on a
component-by-component basis on matching components (as for equality --
see @ref{4.5.2}.), using the predefined logical operator for the component
type. The bounds of the resulting array are those of the left operand.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The short-circuit control forms and then and or else deliver the same
result as the corresponding predefined and and or operators for boolean
types, except that the left operand is always evaluated first, and the
right operand is not evaluated if the value of the left operand
determines the result.

@item
For the logical operators on arrays, a check is made that for each
component of the left operand there is a matching component of the right
operand, and vice versa. Also, a check is made that each component of
the result belongs to the component subtype. The exception
Constraint_Error is raised if either of the above checks fails.

NOTES

@item
(12) The conventional meaning of the logical operators is given by the
following truth table:

@item
@example
A      B      (A and B)  (A or B)  (A xor B)

True   True     True       True      False
True   False    False      True      True
False  True     False      True      True
False  False    False      False     False
@end example

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of logical operators:

@item
@example
Sunny or Warm
Filter(1 .. 10) and Filter(15 .. 24)   --  see @ref{3.6.1}
@end example

@item
Examples of short-circuit control forms:

@item
@example
Next_Car.Owner /= null and then Next_Car.Owner.Age > 25
--  see @ref{3.10.1}

N = 0 or else A(N) = Hit_Value
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.5.2, 4.5.3, 4.5.1, 4.5
@subsection Relational Operators and Membership Tests

@enumerate
@item
The equality operators = (equals) and /= (not equals) are predefined for
nonlimited types. The other relational_operators are the ordering
operators < (less than), <= (less than or equal), > (greater than), and
>= (greater than or equal). The ordering operators are predefined for
scalar types, and for discrete array types, that is, one-dimensional
array types whose components are of a discrete type.

@item
A membership test, using in or not in, determines whether or not a value
belongs to a given subtype or range, or has a tag that identifies a type
that is covered by a given type. Membership tests are allowed for all
types.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The tested type of a membership test is the type of the range or the
type determined by the subtype_mark. If the tested type is tagged, then
the simple_expression shall resolve to be of a type that covers or is
covered by the tested type; if untagged, the expected type for the
simple_expression is the tested type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
For a membership test, if the simple_expression is of a tagged
class-wide type, then the tested type shall be (visibly) tagged.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The result type of a membership test is the predefined type Boolean.

@item
The equality operators are predefined for every specific type T that is
not limited, and not an anonymous access type, with the following
specifications:

@item
@example
function "=" (Left, Right : T) return Boolean
function "/="(Left, Right : T) return Boolean
@end example

@item
The ordering operators are predefined for every specific scalar type T,
and for every discrete array type T, with the following specifications:

@item
@example
function "<" (Left, Right : T) return Boolean
function "<="(Left, Right : T) return Boolean
function ">" (Left, Right : T) return Boolean
function ">="(Left, Right : T) return Boolean
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For discrete types, the predefined relational operators are defined in
terms of corresponding mathematical operations on the position numbers
of the values of the operands.

@item
For real types, the predefined relational operators are defined in terms
of the corresponding mathematical operations on the values of the
operands, subject to the accuracy of the type.

@item
Two access-to-object values are equal if they designate the same object,
or if both are equal to the null value of the access type.

@item
Two access-to-subprogram values are equal if they are the result of the
same evaluation of an Access attribute_reference, or if both are equal
to the null value of the access type. Two access-to-subprogram values
are unequal if they designate different subprograms. It is unspecified
whether two access values that designate the same subprogram but are the
result of distinct evaluations of Access attribute_references are equal
or unequal.

@item
For a type extension, predefined equality is defined in terms of the
primitive (possibly user-defined) equals operator of the parent type and
of any tagged components of the extension part, and predefined equality
for any other components not inherited from the parent type.

@item
For a private type, if its full type is tagged, predefined equality is
defined in terms of the primitive equals operator of the full type; if
the full type is untagged, predefined equality for the private type is
that of its full type.

@item
For other composite types, the predefined equality operators (and
certain other predefined operations on composite types --  see @ref{4.5.1},
and @ref{4.6}.) are defined in terms of the corresponding operation on
matching components, defined as follows:

@enumerate 17
@item
For two composite objects or values of the same non-array type, matching
components are those that correspond to the same component_declaration
or discriminant_specification;

@item
For two one-dimensional arrays of the same type, matching components are
those (if any) whose index values match in the following sense: the
lower bounds of the index ranges are defined to match, and the
successors of matching indices are defined to match;

@item
For two multidimensional arrays of the same type, matching components
are those whose index values match in successive index positions.
@end enumerate
@end enumerate

@enumerate 20
@item
The analogous definitions apply if the types of the two objects or
values are convertible, rather than being the same.

@item
Given the above definition of matching components, the result of the
predefined equals operator for composite types (other than for those
composite types covered earlier) is defined as follows:

@enumerate 22
@item
If there are no components, the result is defined to be True;

@item
If there are unmatched components, the result is defined to be False;

@item
Otherwise, the result is defined in terms of the primitive equals
operator for any matching tagged components, and the predefined equals
for any matching untagged components.
@end enumerate
@end enumerate

@enumerate 25
@item
The predefined "/=" operator gives the complementary result to the
predefined "=" operator.

@item
For a discrete array type, the predefined ordering operators correspond
to lexicographic order using the predefined order relation of the
component type: A null array is lexicographically less than any array
having at least one component. In the case of nonnull arrays, the left
operand is lexicographically less than the right operand if the first
component of the left operand is less than that of the right; otherwise
the left operand is lexicographically less than the right operand only
if their first components are equal and the tail of the left operand is
lexicographically less than that of the right (the tail consists of the
remaining components beyond the first and can be null).

@item
For the evaluation of a membership test, the simple_expression and the
range (if any) are evaluated in an arbitrary order.

@item
A membership test using in yields the result True if:

@enumerate 29
@item
The tested type is scalar, and the value of the simple_expression
belongs to the given range, or the range of the named subtype; or

@item
The tested type is not scalar, and the value of the simple_ expression
satisfies any constraints of the named subtype, and, if the type of the
simple_expression is class-wide, the value has a tag that identifies a
type covered by the tested type.
@end enumerate
@end enumerate

@enumerate 31
@item
Otherwise the test yields the result False.

@item
A membership test using not in gives the complementary result to the
corresponding membership test using in.

NOTES

@item
(13) No exception is ever raised by a membership test, by a predefined
ordering operator, or by a predefined equality operator for an
elementary type, but an exception can be raised by the evaluation of the
operands. A predefined equality operator for a composite type can only
raise an exception if the type has a tagged part whose primitive equals
operator propagates an exception.

@item
(14) If a composite type has components that depend on discriminants,
two values of this type have matching components if and only if their
discriminants are equal. Two nonnull arrays have matching components if
and only if the length of each dimension is the same for both.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of expressions involving relational operators and membership
tests:

@item
@example
X /= Y
@end example

@item
@example
"" < "A" and "A" < "Aa"     --  True
"Aa" < "B" and "A" < "A  "  --  True
@end example

@item
@example
My_Car = null
-- true if My_Car has been set to null  (see @ref{3.10.1})

My_Car = Your_Car
-- true if we both share the same car

My_Car.all = Your_Car.all
-- true if the two cars are identical
@end example

@item
@example
N not in 1 .. 10
-- range membership test

Today in Mon .. Fri
-- range membership test

Today in Weekday
-- subtype membership test  (see @ref{3.5.1})

Archive in Disk_Unit
-- subtype membership test, see @ref{3.8.1}

Tree.all in Addition'Class
-- class membership test  (see @ref{3.9.1})
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.5.3, 4.5.4, 4.5.2, 4.5
@subsection Binary Adding Operators

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The binary adding operators + (addition) and - (subtraction) are
predefined for every specific numeric type T with their conventional
meaning. They have the following specifications:

@item
@example
function "+"(Left, Right : T) return T
function "-"(Left, Right : T) return T
@end example

@item
The concatenation operators & are predefined for every nonlimited,
one-dimensional array type T with component type C. They have the
following specifications:

@item
@example
function "&"(Left : T; Right : T) return T
function "&"(Left : T; Right : C) return T
function "&"(Left : C; Right : T) return T
function "&"(Left : C; Right : C) return T
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of a concatenation with result type T, if both
operands are of type T, the result of the concatenation is a
one-dimensional array whose length is the sum of the lengths of its
operands, and whose components comprise the components of the left
operand followed by the components of the right operand. If the left
operand is a null array, the result of the concatenation is the right
operand. Otherwise, the lower bound of the result is determined as
follows:

@enumerate 6
@item
If the ultimate ancestor of the array type was defined by a
constrained_array_definition, then the lower bound of the result is that
of the index subtype;

@item
If the ultimate ancestor of the array type was defined by an
unconstrained_array_definition, then the lower bound of the result is
that of the left operand.
@end enumerate
@end enumerate

@enumerate 8
@item
The upper bound is determined by the lower bound and the length. A check
is made that the upper bound of the result of the concatenation belongs
to the range of the index subtype, unless the result is a null array.
Constraint_Error is raised if this check fails.

@item
If either operand is of the component type C, the result of the
concatenation is given by the above rules, using in place of such an
operand an array having this operand as its only component (converted to
the component subtype) and having the lower bound of the index subtype
of the array type as its lower bound.

@item
The result of a concatenation is defined in terms of an assignment to an
anonymous object, as for any function call, see @ref{6.5}.

NOTES

@item
(15) As for all predefined operators on modular types, the binary adding
operators + and - on modular types include a final reduction modulo the
modulus if the result is outside the base range of the type.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of expressions involving binary adding operators:

@item
@example
Z + 0.1
--  Z has to be of a real type
@end example

@item
@example
"A" & "BCD"
--  concatenation of two string literals

'A' & "BCD"
--  concatenation of a character literal and a string literal

'A' & 'A'
--  concatenation of two character literals
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.5.4, 4.5.5, 4.5.3, 4.5
@subsection Unary Adding Operators

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The unary adding operators + (identity) and - (negation) are predefined
for every specific numeric type T with their conventional meaning. They
have the following specifications:

@item
@example
function "+"(Right : T) return T
function "-"(Right : T) return T
@end example

NOTES

@item
(16) For modular integer types, the unary adding operator -, when given
a nonzero operand, returns the result of subtracting the value of the
operand from the modulus; for a zero operand, the result is zero.
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.5.5, 4.5.6, 4.5.4, 4.5
@subsection Multiplying Operators

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The multiplying operators * (multiplication), / (division), mod
(modulus), and rem (remainder) are predefined for every specific integer
type T:

@item
@example
function "*"  (Left, Right : T) return T
function "/"  (Left, Right : T) return T
function "mod"(Left, Right : T) return T
function "rem"(Left, Right : T) return T
@end example

@item
Signed integer multiplication has its conventional meaning.

@item
Signed integer division and remainder are defined by the relation:

@item
@example
A = (A/B)*B + (A rem B)
@end example

@item
where (A rem B) has the sign of A and an absolute value less than the
absolute value of B. Signed integer division satisfies the identity:

@item
@example
(-A)/B = -(A/B) = A/(-B)
@end example

@item
The signed integer modulus operator is defined such that the result of A
mod B has the sign of B and an absolute value less than the absolute
value of B; in addition, for some signed integer value N, this result
satisfies the relation:

@item
@example
A = B*N + (A mod B)
@end example

@item
The multiplying operators on modular types are defined in terms of the
corresponding signed integer operators, followed by a reduction modulo
the modulus if the result is outside the base range of the type (which
is only possible for the "*" operator).

@item
Multiplication and division operators are predefined for every specific
floating point type T:

@item
@example
function "*"(Left, Right : T) return T
function "/"(Left, Right : T) return T
@end example

@item
The following multiplication and division operators, with an operand of
the predefined type Integer, are predefined for every specific fixed
point type T:

@item
@example
function "*"(Left : T; Right : Integer) return T
function "*"(Left : Integer; Right : T) return T
function "/"(Left : T; Right : Integer) return T
@end example

@item
All of the above multiplying operators are usable with an operand of an
appropriate universal numeric type. The following additional multiplying
operators for root_real are predefined, and are usable when both
operands are of an appropriate universal or root numeric type, and the
result is allowed to be of type root_real, as in a number_declaration:

@item
@example
function "*"(Left, Right : root_real) return root_real
function "/"(Left, Right : root_real) return root_real
@end example

@item
@example
function "*"(Left : root_real; Right : root_integer) return root_real
function "*"(Left : root_integer; Right : root_real) return root_real
function "/"(Left : root_real; Right : root_integer) return root_real
@end example

@item
Multiplication and division between any two fixed point types are
provided by the following two predefined operators:

@item
@example
function "*"(Left, Right : universal_fixed) return universal_fixed
function "/"(Left, Right : universal_fixed) return universal_fixed
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The above two fixed-fixed multiplying operators shall not be used in a
context where the expected type for the result is itself universal_fixed
-- the context has to identify some other numeric type to which the
result is to be converted, either explicitly or implicitly.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The multiplication and division operators for real types have their
conventional meaning. For floating point types, the accuracy of the
result is determined by the precision of the result type. For decimal
fixed point types, the result is truncated toward zero if the
mathematical result is between two multiples of the small of the
specific result type (possibly determined by context); for ordinary
fixed point types, if the mathematical result is between two multiples
of the small, it is unspecified which of the two is the result.

@item
The exception Constraint_Error is raised by integer division, rem, and
mod if the right operand is zero. Similarly, for a real type T with
T'Machine_Overflows True, division by zero raises Constraint_Error.

NOTES

@item
(17) For positive A and B, A/B is the quotient and A rem B is the
remainder when A is divided by B. The following relations are satisfied
by the rem operator:

@item
@example
  A  rem (-B) =   A rem B
(-A) rem   B  = -(A rem B)
@end example

@item
(18) For any signed integer K, the following identity holds:

@item
@example
  A mod B   =   (A + K*B) mod B
@end example

@item
The relations between signed integer division, remainder, and modulus
are illustrated by the following table:

@item
@example
  A    B  A/B  A rem B  A mod B    A   B  A/B  A rem B  A mod B
@end example

@item
@example
  10   5   2      0        0      -10  5   -2     0        0
  11   5   2      1        1      -11  5   -2    -1        4
  12   5   2      2        2      -12  5   -2    -2        3
  13   5   2      3        3      -13  5   -2    -3        2
  14   5   2      4        4      -14  5   -2    -4        1
@end example

@item
@example
  A    B  A/B  A rem B  A mod B    A   B  A/B  A rem B  A mod B
  10  -5   -2     0        0      -10 -5    2     0        0
  11  -5   -2     1       -4      -11 -5    2    -1       -1
  12  -5   -2     2       -3      -12 -5    2    -2       -2
  13  -5   -2     3       -2      -13 -5    2    -3       -3
  14  -5   -2     4       -1      -14 -5    2    -4       -4
@end example

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of expressions involving multiplying operators:

@item
@example
I : Integer := 1;
J : Integer := 2;
K : Integer := 3;
@end example

@item
@example
X : Real := 1.0;       --  see @ref{3.5.7}
Y : Real := 2.0;
@end example

@item
@example
F : Fraction := 0.25;  --  see @ref{3.5.9}
G : Fraction := 0.5;
@end example

@item
@example
Expression     Value  Result Type

I*J            2      same as I and J, that is, Integer
K/J            1      same as K and J, that is, Integer
K mod J        1      same as K and J, that is, Integer

X/Y            0.5    same as X and Y, that is, Real
F/2            0.125  same as F, that is, Fraction

3*F            0.75   same as F, that is, Fraction
0.75*G         0.375  universal_fixed, implicitly convertible
                      to any fixed point type
Fraction(F*G)  0.125  Fraction, as stated by the conversion
Real(J)*Y      4.0    Real, the type of both operands after
                      conversion of J
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.5.6, 4.6, 4.5.5, 4.5
@subsection Highest Precedence Operators

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The highest precedence unary operator abs (absolute value) is predefined
for every specific numeric type T, with the following specification:

@item
@example
function "abs"(Right : T) return T
@end example

@item
The highest precedence unary operator not (logical negation) is
predefined for every boolean type T, every modular type T, and for every
one-dimensional array type T whose components are of a boolean type,
with the following specification:

@item
@example
function "not"(Right : T) return T
@end example

@item
The result of the operator not for a modular type is defined as the
difference between the high bound of the base range of the type and the
value of the operand. For a binary modulus, this corresponds to a
bit-wise complement of the binary representation of the value of the
operand.

@item
The operator not that applies to a one-dimensional array of boolean
components yields a one-dimensional boolean array with the same bounds;
each component of the result is obtained by logical negation of the
corresponding component of the operand (that is, the component that has
the same index value). A check is made that each component of the result
belongs to the component subtype; the exception Constraint_Error is
raised if this check fails.

@item
The highest precedence exponentiation operator ** is predefined for
every specific integer type T with the following specification:

@item
@example
function "**"(Left : T; Right : Natural) return T
@end example

@item
Exponentiation is also predefined for every specific floating point type
as well as root_real, with the following specification (where T is
root_real or the floating point type):

@item
@example
function "**"(Left : T; Right : Integer'Base) return T
@end example

@item
The right operand of an exponentiation is the exponent. The expression
X**N with the value of the exponent N positive is equivalent to the
expression X*X*...X (with N-1 multiplications) except that the
multiplications are associated in an arbitrary order. With N equal to
zero, the result is one. With the value of N negative (only defined for
a floating point operand), the result is the reciprocal of the result
using the absolute value of N as the exponent.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The implementation of exponentiation for the case of a negative exponent
is allowed to raise Constraint_Error if the intermediate result of the
repeated multiplications is outside the safe range of the type, even
though the final result (after taking the reciprocal) would not be. (The
best machine approximation to the final result in this case would
generally be 0.0.)

NOTES

@item
(19) As implied by the specification given above for exponentiation of
an integer type, a check is made that the exponent is not negative.
Constraint_Error is raised if this check fails.
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.6, 4.7, 4.5.6, 4
@section Type Conversions

@enumerate
@item
Explicit type conversions, both value conversions and view conversions,
are allowed between closely related types as defined below. This clause
also defines rules for value and view conversions to a particular
subtype of a type, both explicit ones and those implicit in other
constructs.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
type_conversion ::=
     subtype_mark(expression)
   | subtype_mark(name)
@end example

@item
The target subtype of a type_conversion is the subtype denoted by the
subtype_mark. The operand of a type_conversion is the expression or name
within the parentheses; its type is the operand type.

@item
One type is convertible to a second type if a type_conversion with the
first type as operand type and the second type as target type is legal
according to the rules of this clause. Two types are convertible if each
is convertible to the other.

@item
A type_conversion whose operand is the name of an object is called a
view conversion if its target type is tagged, or if it appears as an
actual parameter of mode out or in out; other type_conversions are
called value conversions.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The operand of a type_conversion is expected to be of any type.

@item
The operand of a view conversion is interpreted only as a name; the
operand of a value conversion is interpreted as an expression.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If the target type is a numeric type, then the operand type shall be a
numeric type.

@item
If the target type is an array type, then the operand type shall be an
array type. Further:

@enumerate 10
@item
The types shall have the same dimensionality;

@item
Corresponding index types shall be convertible; and

@item
The component subtypes shall statically match.
@end enumerate
@end enumerate

@enumerate 13
@item
If the target type is a general access type, then the operand type shall
be an access-to-object type. Further:

@enumerate 14
@item
If the target type is an access-to-variable type, then the operand type
shall be an access-to-variable type;

@item
If the target designated type is tagged, then the operand designated
type shall be convertible to the target designated type;

@item
If the target designated type is not tagged, then the designated types
shall be the same, and either the designated subtypes shall statically
match or the target designated subtype shall be discriminated and
unconstrained; and

@item
The accessibility level of the operand type shall not be statically
deeper than that of the target type. In addition to the places where
Legality Rules normally apply, see @ref{12.3}, this rule applies also in
the private part of an instance of a generic unit.
@end enumerate
@end enumerate

@enumerate 18
@item
If the target type is an access-to-subprogram type, then the operand
type shall be an access-to-subprogram type. Further:

@enumerate 19
@item
The designated profiles shall be subtype-conformant.

@item
The accessibility level of the operand type shall not be statically
deeper than that of the target type. In addition to the places where
Legality Rules normally apply, see @ref{12.3}, this rule applies also in
the private part of an instance of a generic unit. If the operand type
is declared within a generic body, the target type shall be declared
within the generic body.
@end enumerate
@end enumerate

@enumerate 21
@item
If the target type is not included in any of the above four cases, there
shall be a type that is an ancestor of both the target type and the
operand type. Further, if the target type is tagged, then either:

@enumerate 22
@item
The operand type shall be covered by or descended from the target type;
or

@item
The operand type shall be a class-wide type that covers the target type.
@end enumerate
@end enumerate

@enumerate 24
@item
In a view conversion for an untagged type, the target type shall be
convertible (back) to the operand type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A type_conversion that is a value conversion denotes the value that is
the result of converting the value of the operand to the target subtype.

@item
A type_conversion that is a view conversion denotes a view of the object
denoted by the operand. This view is a variable of the target type if
the operand denotes a variable; otherwise it is a constant of the target
type.

@item
The nominal subtype of a type_conversion is its target subtype.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of a type_conversion that is a value conversion, the
operand is evaluated, and then the value of the operand is converted to
a corresponding value of the target type, if any. If there is no value
of the target type that corresponds to the operand value,
Constraint_Error is raised; this can only happen on conversion to a
modular type, and only when the operand value is outside the base range
of the modular type. Additional rules follow:

@enumerate 29
@item
Numeric Type Conversion

@enumerate 30
@item
If the target and the operand types are both integer types, then the
result is the value of the target type that corresponds to the same
mathematical integer as the operand.

@item
If the target type is a decimal fixed point type, then the result is
truncated (toward 0) if the value of the operand is not a multiple of
the small of the target type.

@item
If the target type is some other real type, then the result is within
the accuracy of the target type (see @ref{G.2, ``Numeric Performance
Requirements''}, for implementations that support the Numerics Annex).

@item
If the target type is an integer type and the operand type is real, the
result is rounded to the nearest integer (away from zero if exactly
halfway between two integers).
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 34
@item
Enumeration Type Conversion

@enumerate 35
@item
The result is the value of the target type with the same position number
as that of the operand value.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 36
@item
Array Type Conversion

@enumerate 37
@item
If the target subtype is a constrained array subtype, then a check is
made that the length of each dimension of the value of the operand
equals the length of the corresponding dimension of the target subtype.
The bounds of the result are those of the target subtype.

@item
If the target subtype is an unconstrained array subtype, then the bounds
of the result are obtained by converting each bound of the value of the
operand to the corresponding index type of the target type. For each
nonnull index range, a check is made that the bounds of the range belong
to the corresponding index subtype.

@item
In either array case, the value of each component of the result is that
of the matching component of the operand value, see @ref{4.5.2}.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 40
@item
Composite (Non-Array) Type Conversion

@enumerate 41
@item
The value of each nondiscriminant component of the result is that of the
matching component of the operand value.

@item
The tag of the result is that of the operand. If the operand type is
class-wide, a check is made that the tag of the operand identifies a
(specific) type that is covered by or descended from the target type.

@item
For each discriminant of the target type that corresponds to a
discriminant of the operand type, its value is that of the corresponding
discriminant of the operand value; if it corresponds to more than one
discriminant of the operand type, a check is made that all these
discriminants are equal in the operand value.

@item
For each discriminant of the target type that corresponds to a
discriminant that is specified by the derived_type_definition for some
ancestor of the operand type (or if class-wide, some ancestor of the
specific type identified by the tag of the operand), its value in the
result is that specified by the derived_type_definition.

@item
For each discriminant of the operand type that corresponds to a
discriminant that is specified by the derived_type_definition for some
ancestor of the target type, a check is made that in the operand value
it equals the value specified for it.

@item
For each discriminant of the result, a check is made that its value
belongs to its subtype.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 47
@item
Access Type Conversion

@enumerate 48
@item
For an access-to-object type, a check is made that the accessibility
level of the operand type is not deeper than that of the target type.

@item
If the target type is an anonymous access type, a check is made that the
value of the operand is not null; if the target is not an anonymous
access type, then the result is null if the operand value is null.

@item
If the operand value is not null, then the result designates the same
object (or subprogram) as is designated by the operand value, but viewed
as being of the target designated subtype (or profile); any checks
associated with evaluating a conversion to the target designated subtype
are performed.
@end enumerate
@end enumerate
@end enumerate

@enumerate 51
@item
After conversion of the value to the target type, if the target subtype
is constrained, a check is performed that the value satisfies this
constraint.

@item
For the evaluation of a view conversion, the operand name is evaluated,
and a new view of the object denoted by the operand is created, whose
type is the target type; if the target type is composite, checks are
performed as above for a value conversion.

@item
The properties of this new view are as follows:

@enumerate 54
@item
If the target type is composite, the bounds or discriminants (if any) of
the view are as defined above for a value conversion; each
nondiscriminant component of the view denotes the matching component of
the operand object; the subtype of the view is constrained if either the
target subtype or the operand object is constrained, or if the operand
type is a descendant of the target type, and has discriminants that were
not inherited from the target type;

@item
If the target type is tagged, then an assignment to the view assigns to
the corresponding part of the object denoted by the operand; otherwise,
an assignment to the view assigns to the object, after converting the
assigned value to the subtype of the object (which might raise
Constraint_Error);

@item
Reading the value of the view yields the result of converting the value
of the operand object to the target subtype (which might raise
Constraint_Error), except if the object is of an access type and the
view conversion is passed as an out parameter; in this latter case, the
value of the operand object is used to initialize the formal parameter
without checking against any constraint of the target subtype
(@pxref{6.4.1}).
@end enumerate
@end enumerate

@enumerate 57
@item
If an Accessibility_Check fails, Program_Error is raised. Any other
check associated with a conversion raises Constraint_Error if it fails.

@item
Conversion to a type is the same as conversion to an unconstrained
subtype of the type.

NOTES

@item
(20) In addition to explicit type_conversions, type conversions are
performed implicitly in situations where the expected type and the
actual type of a construct differ, as is permitted by the type
resolution rules, see @ref{8.6}. For example, an integer literal is of the
type universal_integer, and is implicitly converted when assigned to a
target of some specific integer type. Similarly, an actual parameter of
a specific tagged type is implicitly converted when the corresponding
formal parameter is of a class-wide type.

@item
Even when the expected and actual types are the same, implicit subtype
conversions are performed to adjust the array bounds (if any) of an
operand to match the desired target subtype, or to raise
Constraint_Error if the (possibly adjusted) value does not satisfy the
constraints of the target subtype.

@item
(21) A ramification of the overload resolution rules is that the operand
of an (explicit) type_conversion cannot be the literal null, an
allocator, an aggregate, a string_literal, a character_literal, or an
attribute_reference for an Access or Unchecked_Access attribute.
Similarly, such an expression enclosed by parentheses is not allowed. A
qualified_expression, see @ref{4.7}, can be used instead of such a
type_conversion.

@item
(22) The constraint of the target subtype has no effect for a
type_conversion of an elementary type passed as an out parameter. Hence,
it is recommended that the first subtype be specified as the target to
minimize confusion (a similar recommendation applies to renaming and
generic formal in out objects).

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of numeric type conversion:

@item
@example
Real(2*J)      --  value is converted to floating point
Integer(1.6)   --  value is 2
Integer(-0.4)  --  value is 0
@end example

@item
Example of conversion between derived types:

@item
@example
type A_Form is new B_Form;
@end example

@item
@example
X : A_Form;
Y : B_Form;
@end example

@item
@example
X := A_Form(Y);
Y := B_Form(X);  --  the reverse conversion
@end example

@item
Examples of conversions between array types:

@item
@example
type Sequence is array (Integer range <>) of Integer;
subtype Dozen is Sequence(1 .. 12);
Ledger : array(1 .. 100) of Integer;
@end example

@item
@example
Sequence(Ledger)            --  bounds are those of Ledger
Sequence(Ledger(31 .. 42))  --  bounds are 31 and 42
Dozen(Ledger(31 .. 42))     --  bounds are those of Dozen
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.7, 4.8, 4.6, 4
@section Qualified Expressions

@enumerate
@item
A qualified_expression is used to state explicitly the type, and to
verify the subtype, of an operand that is either an expression or an
aggregate.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
qualified_expression ::=
   subtype_mark'(expression) | subtype_mark'aggregate
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The operand (the expression or aggregate) shall resolve to be of the
type determined by the subtype_mark, or a universal type that covers it.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The evaluation of a qualified_expression evaluates the operand (and if
of a universal type, converts it to the type determined by the
subtype_mark) and checks that its value belongs to the subtype denoted
by the subtype_mark. The exception Constraint_Error is raised if this
check fails.

NOTES

@item
(23) When a given context does not uniquely identify an expected type, a
qualified_expression can be used to do so. In particular, if an
overloaded name or aggregate is passed to an overloaded subprogram, it
might be necessary to qualify the operand to resolve its type.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of disambiguating expressions using qualification:

@item
@example
type Mask is (Fix, Dec, Exp, Signif);
type Code is (Fix, Cla, Dec, Tnz, Sub);
@end example

@item
@example
Print (Mask'(Dec));  --  Dec is of type Mask
Print (Code'(Dec));  --  Dec is of type Code
@end example

@item
@example
for J in Code'(Fix) .. Code'(Dec) loop ...
-- qualification needed for either Fix or Dec

for J in Code range Fix .. Dec loop ...
-- qualification unnecessary

for J in Code'(Fix) .. Dec loop ...
-- qualification unnecessary for Dec
@end example

@item
@example
Dozen'(1 | 3 | 5 | 7 => 2, others => 0) --  see @ref{4.6}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.8, 4.9, 4.7, 4
@section Allocators

@enumerate
@item
The evaluation of an allocator creates an object and yields an access
value that designates the object.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
allocator ::=
   new subtype_indication | new qualified_expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for an allocator shall be a single access-to-object
type whose designated type covers the type determined by the
subtype_mark of the subtype_indication or qualified_expression.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An initialized allocator is an allocator with a qualified_expression. An
uninitialized allocator is one with a subtype_indication. In the
subtype_indication of an uninitialized allocator, a constraint is
permitted only if the subtype_mark denotes an unconstrained composite
subtype; if there is no constraint, then the subtype_mark shall denote a
definite subtype.

@item
If the type of the allocator is an access-to-constant type, the
allocator shall be an initialized allocator. If the designated type is
limited, the allocator shall be an uninitialized allocator.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If the designated type of the type of the allocator is elementary, then
the subtype of the created object is the designated subtype. If the
designated type is composite, then the created object is always
constrained; if the designated subtype is constrained, then it provides
the constraint of the created object; otherwise, the object is
constrained by its initial value (even if the designated subtype is
unconstrained with defaults).

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of an allocator, the elaboration of the
subtype_indication or the evaluation of the qualified_expression is
performed first. For the evaluation of an initialized allocator, an
object of the designated type is created and the value of the
qualified_expression is converted to the designated subtype and assigned
to the object.

@item
For the evaluation of an uninitialized allocator:

@enumerate 9
@item
If the designated type is elementary, an object of the designated
subtype is created and any implicit initial value is assigned;

@item
If the designated type is composite, an object of the designated type is
created with tag, if any, determined by the subtype_mark of the
subtype_indication; any per-object constraints on subcomponents are
elaborated and any implicit initial values for the subcomponents of the
object are obtained as determined by the subtype_indication and assigned
to the corresponding subcomponents. A check is made that the value of
the object belongs to the designated subtype. Constraint_Error is raised
if this check fails. This check and the initialization of the object are
performed in an arbitrary order.
@end enumerate
@end enumerate

@enumerate 11
@item
If the created object contains any tasks, they are activated
(@pxref{9.2}). Finally, an access value that designates the created object
is returned.

NOTES

@item
(24) Allocators cannot create objects of an abstract type (@pxref{3.9.3}).

@item
(25) If any part of the created object is controlled, the initialization
includes calls on corresponding Initialize or Adjust procedures
(@pxref{7.6}).

@item
(26) As explained in @ref{13.11, ``Storage Management''}, the storage
for an object allocated by an allocator comes from a storage pool
(possibly user defined). The exception Storage_Error is raised by an
allocator if there is not enough storage. Instances of
Unchecked_Deallocation may be used to explicitly reclaim storage.

@item
(27) Implementations are permitted, but not required, to provide garbage
collection, see @ref{13.11.3}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of allocators:

@item
@example
new Cell'(0, null, null)
-- initialized explicitly, see @ref{3.10.1}

new Cell'(Value => 0, Succ => null, Pred => null)
-- initialized explicitly

new Cell
-- not initialized
@end example

@item
@example
new Matrix(1 .. 10, 1 .. 20)
-- the bounds only are given

new Matrix'(1 .. 10 => (1 .. 20 => 0.0))
-- initialized explicitly
@end example

@item
@example
new Buffer(100)
-- the discriminant only is given

new Buffer'(Size => 80, Pos => 0, Value => (1 .. 80 => 'A'))
-- initialized explicitly
@end example

@item
@example
Expr_Ptr'(new Literal)
-- allocator for access-to-class-wide type, see @ref{3.9.1}

Expr_Ptr'(new Literal'(Expression with 3.5))
-- initialized explicitly
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 4.9, 4.9.1, 4.8, 4
@section Static Expressions and Static Subtypes

@enumerate
@item
Certain expressions of a scalar or string type are defined to be static.
Similarly, certain discrete ranges are defined to be static, and certain
scalar and string subtypes are defined to be static subtypes. Static
means determinable at compile time, using the declared properties or
values of the program entities.

@item
A static expression is a scalar or string expression that is one of the
following:

@enumerate 3
@item
a numeric_literal;

@item
a string_literal of a static string subtype;

@item
a name that denotes the declaration of a named number or a static
constant;

@item
a function_call whose function_name or function_prefix statically
denotes a static function, and whose actual parameters, if any (whether
given explicitly or by default), are all static expressions;

@item
an attribute_reference that denotes a scalar value, and whose prefix
denotes a static scalar subtype;

@item
an attribute_reference whose prefix statically denotes a statically
constrained array object or array subtype, and whose
attribute_designator is First, Last, or Length, with an optional
dimension;

@item
a type_conversion whose subtype_mark denotes a static scalar subtype,
and whose operand is a static expression;

@item
a qualified_expression whose subtype_mark denotes a static (scalar or
string) subtype, and whose operand is a static expression;

@item
a membership test whose simple_expression is a static expression, and
whose range is a static range or whose subtype_mark denotes a static
(scalar or string) subtype;

@item
a short-circuit control form both of whose relations are static
expressions;

@item
a static expression enclosed in parentheses.
@end enumerate
@end enumerate

@enumerate 14
@item
A name statically denotes an entity if it denotes the entity and:

@enumerate 15
@item
It is a direct_name, expanded name, or character_literal, and it denotes
a declaration other than a renaming_declaration; or

@item
It is an attribute_reference whose prefix statically denotes some
entity; or

@item
It denotes a renaming_declaration with a name that statically denotes
the renamed entity.
@end enumerate
@end enumerate

@enumerate 18
@item
A static function is one of the following:

@enumerate 19
@item
a predefined operator whose parameter and result types are all scalar
types none of which are descendants of formal scalar types;

@item
a predefined concatenation operator whose result type is a string type;

@item
an enumeration literal;

@item
a language-defined attribute that is a function, if the prefix denotes a
static scalar subtype, and if the parameter and result types are scalar.
@end enumerate
@end enumerate

@enumerate 23
@item
In any case, a generic formal subprogram is not a static function.

@item
A static constant is a constant view declared by a full constant
declaration or an object_renaming_declaration with a static nominal
subtype, having a value defined by a static scalar expression or by a
static string expression whose value has a length not exceeding the
maximum length of a string_literal in the implementation.

@item
A static range is a range whose bounds are static expressions, or a
range_attribute_reference that is equivalent to such a range. A static
discrete_range is one that is a static range or is a subtype_indication
that defines a static scalar subtype. The base range of a scalar type is
a static range, unless the type is a descendant of a formal scalar type.

@item
A static subtype is either a static scalar subtype or a static string
subtype. A static scalar subtype is an unconstrained scalar subtype
whose type is not a descendant of a formal scalar type, or a constrained
scalar subtype formed by imposing a compatible static constraint on a
static scalar subtype. A static string subtype is an unconstrained
string subtype whose index subtype and component subtype are static (and
whose type is not a descendant of a formal array type), or a constrained
string subtype formed by imposing a compatible static constraint on a
static string subtype. In any case, the subtype of a generic formal
object of mode in out, and the result subtype of a generic formal
function, are not static.

@item
The different kinds of static constraint are defined as follows:

@enumerate 28
@item
A null constraint is always static;

@item
A scalar constraint is static if it has no range_constraint, or one with
a static range;

@item
An index constraint is static if each discrete_range is static, and each
index subtype of the corresponding array type is static;

@item
A discriminant constraint is static if each expression of the constraint
is static, and the subtype of each discriminant is static.
@end enumerate
@end enumerate

@enumerate 32
@item
A subtype is statically constrained if it is constrained, and its
constraint is static. An object is statically constrained if its nominal
subtype is statically constrained, or if it is a static string constant.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A static expression is evaluated at compile time except when it is part
of the right operand of a static short-circuit control form whose value
is determined by its left operand. This evaluation is performed exactly,
without performing Overflow_Checks. For a static expression that is
evaluated:

@enumerate 34
@item
The expression is illegal if its evaluation fails a language-defined
check other than Overflow_Check.

@item
If the expression is not part of a larger static expression, then its
value shall be within the base range of its expected type. Otherwise,
the value may be arbitrarily large or small.

@item
If the expression is of type universal_real and its expected type is a
decimal fixed point type, then its value shall be a multiple of the
small of the decimal type.
@end enumerate
@end enumerate

@enumerate 37
@item
The last two restrictions above do not apply if the expected type is a
descendant of a formal scalar type (or a corresponding actual type in an
instance).

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
For a real static expression that is not part of a larger static
expression, and whose expected type is not a descendant of a formal
scalar type, the implementation shall round or truncate the value
(according to the Machine_Rounds attribute of the expected type) to the
nearest machine number of the expected type; if the value is exactly
half-way between two machine numbers, any rounding shall be performed
away from zero. If the expected type is a descendant of a formal scalar
type, no special rounding or truncating is required -- normal accuracy
rules apply, see @ref{G}.

NOTES

@item
(28) An expression can be static even if it occurs in a context where
staticness is not required.

@item
(29) A static (or run-time) type_conversion from a real type to an
integer type performs rounding. If the operand value is exactly half-way
between two integers, the rounding is performed away from zero.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of static expressions:

@item
@example
1 + 1       -- 2
abs(-10)*3  -- 30
@end example

@item
@example
Kilo : constant := 1000;
Mega : constant := Kilo*Kilo;   -- 1_000_000
Long : constant := Float'Digits*2;
@end example

@item
@example
Half_Pi    : constant := Pi/2;
--  see @ref{3.3.2}.

Deg_To_Rad : constant := Half_Pi/90;

Rad_To_Deg : constant := 1.0/Deg_To_Rad;
-- equivalent to 1.0/((3.14159_26536/2)/90)
@end example
@end enumerate

@menu
* 4.9.1:: Statically Matching Constraints and Subtypes
@end menu

@c ---------------------------------------------------------------------------
@node 4.9.1, 5, 4.9, 4.9
@subsection Statically Matching Constraints and Subtypes

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
A constraint statically matches another constraint if both are null
constraints, both are static and have equal corresponding bounds or
discriminant values, or both are nonstatic and result from the same
elaboration of a constraint of a subtype_indication or the same
evaluation of a range of a discrete_subtype_definition.

@item
A subtype statically matches another subtype of the same type if they
have statically matching constraints. Two anonymous access subtypes
statically match if their designated subtypes statically match.

@item
Two ranges of the same type statically match if both result from the
same evaluation of a range, or if both are static and have equal
corresponding bounds.

@item
A constraint is statically compatible with a scalar subtype if it
statically matches the constraint of the subtype, or if both are static
and the constraint is compatible with the subtype. A constraint is
statically compatible with an access or composite subtype if it
statically matches the constraint of the subtype, or if the subtype is
unconstrained. One subtype is statically compatible with a second
subtype if the constraint of the first is statically compatible with the
second subtype.
@end enumerate

@c ===========================================================================
@node 5, 5.1, 4.9.1, Top
@chapter Statements

@enumerate
@item
A statement defines an action to be performed upon its execution.

@item
This section describes the general rules applicable to all statements.
Some statements are discussed in later sections:
Procedure_call_statements and return_statements are described in
@ref{6, ``Subprograms''}. Entry_call_statements, requeue_statements,
delay_statements, accept_statements, select_statements, and
abort_statements are described in @ref{9, ``Tasks and
Synchronization''}. Raise_statements are described in @ref{11,
``Exceptions''}, and code_statements in @ref{13}. The remaining
forms of statements are presented in this section.
@end enumerate

@menu
* 5.1:: Simple and Compound Statements - Sequences of Statements
* 5.2:: Assignment Statements
* 5.3:: If Statements
* 5.4:: Case Statements
* 5.5:: Loop Statements
* 5.6:: Block Statements
* 5.7:: Exit Statements
* 5.8:: Goto Statements
@end menu

@c ---------------------------------------------------------------------------
@node 5.1, 5.2, 5, 5
@section Simple and Compound Statements - Sequences of Statements

@enumerate
@item
A statement is either simple or compound. A simple_statement encloses no
other statement. A compound_statement can enclose simple_statements and
other compound_statements.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
sequence_of_statements ::= statement @{statement@}
@end example

@item
@example
statement ::=
   @{label@} simple_statement | @{label@} compound_statement
@end example

@item
@example
simple_statement ::= null_statement
   | assignment_statement   | exit_statement
   | goto_statement         | procedure_call_statement
   | return_statement       | entry_call_statement
   | requeue_statement      | delay_statement
   | abort_statement        | raise_statement
   | code_statement
@end example

@item
@example
compound_statement ::=
     if_statement           | case_statement
   | loop_statement         | block_statement
   | accept_statement       | select_statement
@end example

@item
@example
null_statement ::= null;
@end example

@item
@example
label ::= <<label_statement_identifier>>
@end example

@item
@example
statement_identifier ::= direct_name
@end example

@enumerate 9
@item
The direct_name of a statement_identifier shall be an identifier (not an
operator_symbol).
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 10
@item
The direct_name of a statement_identifier shall resolve to denote its
corresponding implicit declaration (see below).

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
Distinct identifiers shall be used for all statement_identifiers that
appear in the same body, including inner block_statements but excluding
inner program units.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For each statement_identifier, there is an implicit declaration (with
the specified identifier) at the end of the declarative_part of the
innermost block_statement or body that encloses the
statement_identifier. The implicit declarations occur in the same order
as the statement_identifiers occur in the source text. If a usage name
denotes such an implicit declaration, the entity it denotes is the
label, loop_statement, or block_statement with the given
statement_identifier.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a null_statement has no effect.

@item
A transfer of control is the run-time action of an exit_statement,
return_statement, goto_statement, or requeue_statement, selection of a
terminate_alternative, raising of an exception, or an abort, which
causes the next action performed to be one other than what would
normally be expected from the other rules of the language. As explained
in @ref{7.6.1}, a transfer of control can cause the execution of
constructs to be completed and then left, which may trigger
finalization.

@item
The execution of a sequence_of_statements consists of the execution of
the individual statements in succession until the sequence_ is
completed.

NOTES

@item
(1) A statement_identifier that appears immediately within the
declarative region of a named loop_statement or an accept_statement is
nevertheless implicitly declared immediately within the declarative
region of the innermost enclosing body or block_statement; in other
words, the expanded name for a named statement is not affected by
whether the statement occurs inside or outside a named loop or an
accept_statement -- only nesting within block_statements is relevant to
the form of its expanded name.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of labeled statements:

@item
@example
<<Here>> <<Ici>> <<Aqui>> <<Hier>> null;
@end example

@item
@example
<<After>> X := 1;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.2, 5.3, 5.1, 5
@section Assignment Statements

@enumerate
@item
An assignment_statement replaces the current value of a variable with
the result of evaluating an expression.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
assignment_statement ::= variable_name := expression;
@end example

@item
The execution of an assignment_statement includes the evaluation of the
expression and the assignment of the value of the expression into the
target. An assignment operation (as opposed to an assignment_statement)
is performed in other contexts as well, including object initialization
and by-copy parameter passing. The target of an assignment operation is
the view of the object to which a value is being assigned; the target of
an assignment_statement is the variable denoted by the variable_name.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The variable_name of an assignment_statement is expected to be of any
nonlimited type. The expected type for the expression is the type of the
target.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The target denoted by the variable_name shall be a variable.

@item
If the target is of a tagged class-wide type T'Class, then the
expression shall either be dynamically tagged, or of type T and
tag-indeterminate, see @ref{3.9.2}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of an assignment_statement, the variable_name and the
expression are first evaluated in an arbitrary order.

@item
When the type of the target is class-wide:

@enumerate 9
@item
If the expression is tag-indeterminate, see @ref{3.9.2}, then the
controlling tag value for the expression is the tag of the target;

@item
Otherwise (the expression is dynamically tagged), a check is made that
the tag of the value of the expression is the same as that of the
target; if this check fails, Constraint_Error is raised.
@end enumerate
@end enumerate

@enumerate 11
@item
The value of the expression is converted to the subtype of the target.
The conversion might raise an exception, see @ref{4.6}.

@item
In cases involving controlled types, the target is finalized, and an
anonymous object might be used as an intermediate in the assignment, as
described in @ref{7.6.1, ``Completion and Finalization''}. In any case,
the converted value of the expression is then assigned to the target,
which consists of the following two steps:

@enumerate 13
@item
The value of the target becomes the converted value.

@item
If any part of the target is controlled, its value is adjusted as
explained in @ref{7.6}.
@end enumerate
@end enumerate
@enumerate 15

NOTES

@item
(2) The tag of an object never changes; in particular, an
assignment_statement does not change the tag of the target.

@item
(3) The values of the discriminants of an object designated by an access
value cannot be changed (not even by assigning a complete value to the
object itself) since such objects are always constrained; however,
subcomponents of such objects may be unconstrained.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of assignment statements:

@item
@example
Value := Max_Value - 1;
Shade := Blue;
@end example

@item
@example
Next_Frame(F)(M, N) := 2.5;  --  see @ref{4.1.1}
U := Dot_Product(V, W);      --  see @ref{6.3}
@end example

@item
@example
Writer := (Status => Open, Unit => Printer, Line_Count => 60);
--  see @ref{3.8.1}

Next_Car.all := (72074, null);
--  see @ref{3.10.1}
@end example

@item
Examples involving scalar subtype conversions:

@item
@example
I, J : Integer range 1 .. 10 := 5;
K    : Integer range 1 .. 20 := 15;
 ...
@end example

@item
@example
I := J;  --  identical ranges
K := J;  --  compatible ranges
J := K;  --  will raise Constraint_Error if K > 10
@end example

@item
Examples involving array subtype conversions:

@item
@example
A : String(1 .. 31);
B : String(3 .. 33);
 ...
@end example

@item
@example
A := B;  --  same number of components
@end example

@item
@example
A(1 .. 9)  := "tar sauce";
A(4 .. 12) := A(1 .. 9);  --  A(1 .. 12) = "tartar sauce"
@end example

NOTES

@item
(4) Notes on the examples: Assignment_statements are allowed even in the
case of overlapping slices of the same array, because the variable_name
and expression are both evaluated before copying the value into the
variable. In the above example, an implementation yielding A(1 .. 12) =
"tartartartar" would be incorrect.
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.3, 5.4, 5.2, 5
@section If Statements

@enumerate
@item
An if_statement selects for execution at most one of the enclosed
sequences_of_statements, depending on the (truth) value of one or more
corresponding conditions.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
if_statement ::=
    if condition then
       sequence_of_statements
    @{elsif condition then
       sequence_of_statements@}
    [else
       sequence_of_statements]
    end if;
@end example

@item
@example
condition ::= boolean_expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
A condition is expected to be of any boolean type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of an if_statement, the condition specified after if,
and any conditions specified after elsif, are evaluated in succession
(treating a final else as elsif True then), until one evaluates to True
or all conditions are evaluated and yield False. If a condition
evaluates to True, then the corresponding sequence_of_statements is
executed; otherwise none of them is executed.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of if statements:

@item
@example
if Month = December and Day = 31 then
   Month := January;
   Day   := 1;
   Year  := Year + 1;
end if;
@end example

@item
@example
if Line_Too_Short then
   raise Layout_Error;
elsif Line_Full then
   New_Line;
   Put(Item);
else
   Put(Item);
end if;
@end example

@item
@example
if My_Car.Owner.Vehicle /= My_Car then  --  see @ref{3.10.1}
   Report ("Incorrect data");
end if;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.4, 5.5, 5.3, 5
@section Case Statements

@enumerate
@item
A case_statement selects for execution one of a number of alternative
sequences_of_statements; the chosen alternative is defined by the value
of an expression.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
case_statement ::=
   case expression is
      case_statement_alternative
      @{case_statement_alternative@}
   end case;
@end example

@item
@example
case_statement_alternative ::=
   when discrete_choice_list =>
      sequence_of_statements
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expression is expected to be of any discrete type. The expected type
for each discrete_choice is the type of the expression.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The expressions and discrete_ranges given as discrete_choices of a
case_statement shall be static. A discrete_choice others, if present,
shall appear alone and in the last discrete_choice_list.

@item
The possible values of the expression shall be covered as follows:

@enumerate 7
@item
If the expression is a name (including a type_conversion or a
function_call) having a static and constrained nominal subtype, or is a
qualified_expression whose subtype_mark denotes a static and constrained
scalar subtype, then each non-others discrete_choice shall cover only
values in that subtype, and each value of that subtype shall be covered
by some discrete_choice (either explicitly or by others).

@item
If the type of the expression is root_integer, universal_integer, or a
descendant of a formal scalar type, then the case_statement shall have
an others discrete_choice.

@item
Otherwise, each value of the base range of the type of the expression
shall be covered (either explicitly or by others).
@end enumerate
@end enumerate

@enumerate 10
@item
Two distinct discrete_choices of a case_statement shall not cover the
same value.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a case_statement the expression is first evaluated.

@item
If the value of the expression is covered by the discrete_choice_list of
some case_statement_alternative, then the sequence_of_statements of the
_alternative is executed.

@item
Otherwise (the value is not covered by any discrete_choice_list, perhaps
due to being outside the base range), Constraint_Error is raised.

NOTES

@item
(5) The execution of a case_statement chooses one and only one
alternative. Qualification of the expression of a case_statement by a
static subtype can often be used to limit the number of choices that
need be given explicitly.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of case statements:

@item
@example
case Sensor is
   when Elevation  => Record_Elevation(Sensor_Value);
   when Azimuth    => Record_Azimuth  (Sensor_Value);
   when Distance   => Record_Distance (Sensor_Value);
   when others     => null;
end case;
@end example

@item
@example
case Today is
   when Mon        => Compute_Initial_Balance;
   when Fri        => Compute_Closing_Balance;
   when Tue .. Thu => Generate_Report(Today);
   when Sat .. Sun => null;
end case;
@end example

@item
@example
case Bin_Number(Count) is
   when 1      => Update_Bin(1);
   when 2      => Update_Bin(2);
   when 3 | 4  =>
      Empty_Bin(1);
      Empty_Bin(2);
   when others => raise Error;
end case;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.5, 5.6, 5.4, 5
@section Loop Statements

@enumerate
@item
A loop_statement includes a sequence_of_statements that is to be
executed repeatedly, zero or more times.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
loop_statement ::=
   [loop_statement_identifier:]
      [iteration_scheme] loop
         sequence_of_statements
      end loop [loop_identifier];
@end example

@item
@example
iteration_scheme ::= while condition
   | for loop_parameter_specification
@end example

@item
@example
loop_parameter_specification ::=
   defining_identifier in [reverse] discrete_subtype_definition
@end example

@enumerate 5
@item
If a loop_statement has a loop_statement_identifier, then the identifier
shall be repeated after the end loop; otherwise, there shall not be an
identifier after the end loop.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 6
@item
A loop_parameter_specification declares a loop parameter, which is an
object whose subtype is that defined by the discrete_subtype_definition.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a loop_statement, the sequence_of_statements is
executed repeatedly, zero or more times, until the loop_statement is
complete. The loop_statement is complete when a transfer of control
occurs that transfers control out of the loop, or, in the case of an
iteration_scheme, as specified below.

@item
For the execution of a loop_statement with a while iteration_scheme, the
condition is evaluated before each execution of the
sequence_of_statements; if the value of the condition is True, the
sequence_of_statements is executed; if False, the execution of the
loop_statement is complete.

@item
For the execution of a loop_statement with a for iteration_scheme, the
loop_parameter_specification is first elaborated. This elaboration
creates the loop parameter and elaborates the
discrete_subtype_definition. If the discrete_subtype_definition defines
a subtype with a null range, the execution of the loop_statement is
complete. Otherwise, the sequence_of_statements is executed once for
each value of the discrete subtype defined by the
discrete_subtype_definition (or until the loop is left as a consequence
of a transfer of control). Prior to each such iteration, the
corresponding value of the discrete subtype is assigned to the loop
parameter. These values are assigned in increasing order unless the
reserved word reverse is present, in which case the values are assigned
in decreasing order.

NOTES

@item
(6) A loop parameter is a constant; it cannot be updated within the
sequence_of_statements of the loop, see @ref{3.3}.

@item
(7) An object_declaration should not be given for a loop parameter,
since the loop parameter is automatically declared by the
loop_parameter_specification. The scope of a loop parameter extends from
the loop_parameter_specification to the end of the loop_statement, and
the visibility rules are such that a loop parameter is only visible
within the sequence_of_statements of the loop.

@item
(8) The discrete_subtype_definition of a for loop is elaborated just
once. Use of the reserved word reverse does not alter the discrete
subtype defined, so that the following iteration_schemes are not
equivalent; the first has a null range.

@item
@example
for J in reverse 1 ..  0
for J in 0 .. 1
@end example

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a loop statement without an iteration scheme:

@item
@example
loop
   Get(Current_Character);
   exit when Current_Character = '*';
end loop;
@end example

@item
Example of a loop statement with a while iteration scheme:

@item
@example
while Bid(N).Price < Cut_Off.Price loop
   Record_Bid(Bid(N).Price);
   N := N + 1;
end loop;
@end example

@item
Example of a loop statement with a for iteration scheme:

@item
@example
for J in Buffer'Range loop  --  works even with a null range
   if Buffer(J) /= Space then
      Put(Buffer(J));
   end if;
end loop;
@end example

@item
Example of a loop statement with a name:

@item
@example
Summation:
   while Next /= Head loop  --  see @ref{3.10.1}
      Sum  := Sum + Next.Value;
      Next := Next.Succ;
   end loop Summation;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.6, 5.7, 5.5, 5
@section Block Statements

@enumerate
@item
A block_statement encloses a handled_sequence_of_statements optionally
preceded by a declarative_part.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
block_statement ::=
   [block_statement_identifier:]
      [declare
         declarative_part]
      begin
         handled_sequence_of_statements
      end [block_identifier];
@end example

@enumerate 3
@item
If a block_statement has a block_statement_identifier, then the
identifier shall be repeated after the end; otherwise, there shall not
be an identifier after the end.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 4
@item
A block_statement that has no explicit declarative_part has an implicit
empty declarative_part.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a block_statement consists of the elaboration of its
declarative_part followed by the execution of its
handled_sequence_of_statements.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a block statement with a local variable:

@item
@example
Swap:
   declare
      Temp : Integer;
   begin
      Temp := V; V := U; U := Temp;
   end Swap;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.7, 5.8, 5.6, 5
@section Exit Statements

@enumerate
@item
An exit_statement is used to complete the execution of an enclosing
loop_statement; the completion is conditional if the exit_statement
includes a condition.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
exit_statement ::= exit [loop_name] [when condition];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The loop_name, if any, in an exit_statement shall resolve to denote a
loop_statement.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
Each exit_statement applies to a loop_statement; this is the
loop_statement being exited. An exit_statement with a name is only
allowed within the loop_statement denoted by the name, and applies to
that loop_statement. An exit_statement without a name is only allowed
within a loop_statement, and applies to the innermost enclosing one. An
exit_statement that applies to a given loop_statement shall not appear
within a body or accept_statement, if this construct is itself enclosed
by the given loop_statement.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of an exit_statement, the condition, if present, is
first evaluated. If the value of the condition is True, or if there is
no condition, a transfer of control is done to complete the
loop_statement. If the value of the condition is False, no transfer of
control takes place.

NOTES

@item
(9) Several nested loops can be exited by an exit_statement that names
the outer loop.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of loops with exit statements:

@item
@example
for N in 1 .. Max_Num_Items loop
   Get_New_Item(New_Item);
   Merge_Item(New_Item, Storage_File);
   exit when New_Item = Terminal_Item;
end loop;
@end example

@item
@example
Main_Cycle:
   loop
      --  initial statements
      exit Main_Cycle when Found;
      --  final statements
   end loop Main_Cycle;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 5.8, 6, 5.7, 5
@section Goto Statements

@enumerate
@item
A goto_statement specifies an explicit transfer of control from this
statement to a target statement with a given label.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
goto_statement ::= goto label_name;
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The label_name shall resolve to denote a label; the statement with that
label is the target statement.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The innermost sequence_of_statements that encloses the target statement
shall also enclose the goto_statement. Furthermore, if a goto_statement
is enclosed by an accept_statement or a body, then the target statement
shall not be outside this enclosing construct.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a goto_statement transfers control to the target
statement, completing the execution of any compound_statement that
encloses the goto_statement but does not enclose the target.

NOTES

@item
(10) The above rules allow transfer of control to a statement of an
enclosing sequence_of_statements but not the reverse. Similarly, they
prohibit transfers of control such as between alternatives of a
case_statement, if_statement, or select_statement; between
exception_handlers; or from an exception_handler of a
handled_sequence_of_statements back to its sequence_of_statements.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a loop containing a goto statement:

@item
@example
<<Sort>>
for I in 1 .. N-1 loop
   if A(I) > A(I+1) then
      Exchange(A(I), A(I+1));
      goto Sort;
   end if;
end loop;
@end example
@end enumerate

@c ===========================================================================
@node 6, 6.1, 5.8, Top
@chapter Subprograms

@enumerate
@item
A subprogram is a program unit or intrinsic operation whose execution is
invoked by a subprogram call. There are two forms of subprogram:
procedures and functions. A procedure call is a statement; a function
call is an expression and returns a value. The definition of a
subprogram can be given in two parts: a subprogram declaration defining
its interface, and a subprogram_body defining its execution. Operators
and enumeration literals are functions.

@item
A callable entity is a subprogram or entry, see @ref{9}. A callable entity
is invoked by a call; that is, a subprogram call or entry call. A
callable construct is a construct that defines the action of a call upon
a callable entity: a subprogram_body, entry_body, or accept_statement.
@end enumerate

@menu
* 6.1:: Subprogram Declarations
* 6.2:: Formal Parameter Modes
* 6.3:: Subprogram Bodies
* 6.4:: Subprogram Calls
* 6.5:: Return Statements
* 6.6:: Overloading of Operators

 --- The Detailed Node Listing ---

* 6.1::   Subprogram Declarations
* 6.2::   Formal Parameter Modes
* 6.3::   Subprogram Bodies
* 6.3.1:: Conformance Rules
* 6.3.2:: Inline Expansion of Subprograms
* 6.4::   Subprogram Calls
* 6.4.1:: Parameter Associations
* 6.5::   Return Statements
* 6.6::   Overloading of Operators
@end menu

@c ---------------------------------------------------------------------------
@node 6.1, 6.2, 6, 6
@section Subprogram Declarations

@enumerate
@item
A subprogram_declaration declares a procedure or function.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
subprogram_declaration ::= subprogram_specification;
@end example

@item
@example
abstract_subprogram_declaration ::=
   subprogram_specification is abstract;
@end example

@item
@example
subprogram_specification ::=
     procedure defining_program_unit_name parameter_profile
   | function defining_designator parameter_and_result_profile
@end example

@item
@example
designator ::= [parent_unit_name . ]identifier | operator_symbol
@end example

@item
@example
defining_designator ::=
   defining_program_unit_name | defining_operator_symbol
@end example

@item
@example
defining_program_unit_name ::=
   [parent_unit_name . ]defining_identifier
@end example

@enumerate 8
@item
The optional parent_unit_name is only allowed for library units
(@pxref{10.1.1}).
@end enumerate
@end enumerate

@enumerate 9
@item
@example
operator_symbol ::= string_literal
@end example

@enumerate 10
@item
The sequence of characters in an operator_symbol shall correspond to an
operator belonging to one of the six classes of operators defined in
clause @ref{4.5} (spaces are not allowed and the case of letters is not
significant).
@end enumerate
@end enumerate

@enumerate 11
@item
@example
defining_operator_symbol ::= operator_symbol
@end example

@item
@example
parameter_profile ::= [formal_part]
@end example

@item
@example
parameter_and_result_profile ::= [formal_part] return subtype_mark
@end example

@item
@example
formal_part ::=
   (parameter_specification @{; parameter_specification@{)
@end example

@item
@example
parameter_specification ::=
    defining_identifier_list : mode subtype_mark
      [:= default_expression]
  | defining_identifier_list : access_definition
      [:= default_expression]
@end example

@item
@example
mode ::= [in] | in out | out
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
A formal parameter is an object directly visible within a
subprogram_body that represents the actual parameter passed to the
subprogram in a call; it is declared by a parameter_specification. For a
formal parameter, the expected type for its default_expression, if any,
is that of the formal parameter.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The parameter mode of a formal parameter conveys the direction of
information transfer with the actual parameter: in, in out, or out. Mode
in is the default, and is the mode of a parameter defined by an
access_definition. The formal parameters of a function, if any, shall
have the mode in.

@item
A default_expression is only allowed in a parameter_specification for a
formal parameter of mode in.

@item
A subprogram_declaration or a generic_subprogram_declaration requires a
completion: a body, a renaming_declaration, see @ref{8.5}, or a pragma
Import, see @ref{B.1}. A completion is not allowed for an
abstract_subprogram_declaration.

@item
A name that denotes a formal parameter is not allowed within the
formal_part in which it is declared, nor within the formal_part of a
corresponding body or accept_statement.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The profile of (a view of) a callable entity is either a
parameter_profile or parameter_and_result_profile; it embodies
information about the interface to that entity -- for example, the
profile includes information about parameters passed to the callable
entity. All callable entities have a profile -- enumeration literals,
other subprograms, and entries. An access-to-subprogram type has a
designated profile. Associated with a profile is a calling convention. A
subprogram_declaration declares a procedure or a function, as indicated
by the initial reserved word, with name and profile as given by its
specification.

@item
The nominal subtype of a formal parameter is the subtype denoted by the
subtype_mark, or defined by the access_definition, in the
parameter_specification.

@item
An access parameter is a formal in parameter specified by an
access_definition. An access parameter is of an anonymous general
access-to-variable type, see @ref{3.10}. Access parameters allow
dispatching calls to be controlled by access values.

@item
The subtypes of a profile are:

@enumerate 26
@item
For any non-access parameters, the nominal subtype of the parameter.

@item
For any access parameters, the designated subtype of the parameter type.

@item
For any result, the result subtype.
@end enumerate
@end enumerate

@enumerate 29
@item
The types of a profile are the types of those subtypes.

@item
A subprogram declared by an abstract_subprogram_declaration is abstract;
a subprogram declared by a subprogram_declaration is not (@pxref{3.9.3,
``Abstract Types and Subprograms''}).

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a subprogram_declaration or an
abstract_subprogram_declaration has no effect.

NOTES

@item
(1) A parameter_specification with several identifiers is equivalent to
a sequence of single parameter_specifications, as explained in 3.3.

@item
(2) Abstract subprograms do not have bodies, and cannot be used in a
nondispatching call, see @ref{3.9.3, ``Abstract Types and Subprograms''}.

@item
(3) The evaluation of default_expressions is caused by certain calls, as
described in @ref{6.4.1}. They are not evaluated during the elaboration
of the subprogram declaration.

@item
(4) Subprograms can be called recursively and can be called concurrently
from multiple tasks.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of subprogram declarations:

@item
@example
procedure Traverse_Tree;
procedure Increment(X : in out Integer);
procedure Right_Indent(Margin : out Line_Size); --  see @ref{3.5.4}
procedure Switch(From, To : in out Link);       --  see @ref{3.10.1}
@end example

@item
@example
function Random return Probability;             --  see @ref{3.5.7}
@end example

@item
@example
function Min_Cell(X : Link) return Cell;        --  see @ref{3.10.1}
function Next_Frame(K : Positive) return Frame; --  see @ref{3.10}
function Dot_Product(Left, Right : Vector) return Real;
--  see @ref{3.6}
@end example

@item
@example
function "*"(Left, Right : Matrix) return Matrix;
--  see @ref{3.6}
@end example

@item
Examples of in parameters with default expressions:

@item
@example
procedure Print_Header
  (Pages  : in Natural;
   Header : in Line    :=  (1 .. Line'Last => ' '); --  see @ref{3.6}
   Center : in Boolean := True);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 6.2, 6.3, 6.1, 6
@section Formal Parameter Modes

@enumerate
@item
A parameter_specification declares a formal parameter of mode in, in
out, or out.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A parameter is passed either by copy or by reference. When a parameter
is passed by copy, the formal parameter denotes a separate object from
the actual parameter, and any information transfer between the two
occurs only before and after executing the subprogram. When a parameter
is passed by reference, the formal parameter denotes (a view of) the
object denoted by the actual parameter; reads and updates of the formal
parameter directly reference the actual parameter object.

@item
A type is a by-copy type if it is an elementary type, or if it is a
descendant of a private type whose full type is a by-copy type. A
parameter of a by-copy type is passed by copy.

@item
A type is a by-reference type if it is a descendant of one of the
following:

@enumerate 5
@item
a tagged type;

@item
a task or protected type;

@item
a nonprivate type with the reserved word limited in its declaration;

@item
a composite type with a subcomponent of a by-reference type;

@item
a private type whose full type is a by-reference type.
@end enumerate
@end enumerate

@enumerate 10
@item
A parameter of a by-reference type is passed by reference. Each value of
a by-reference type has an associated object. For a parenthesized
expression, qualified_expression, or type_conversion, this object is the
one associated with the operand.

@item
For parameters of other types, it is unspecified whether the parameter
is passed by copy or by reference.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
If one name denotes a part of a formal parameter, and a second name
denotes a part of a distinct formal parameter or an object that is not
part of a formal parameter, then the two names are considered distinct
access paths. If an object is of a type for which the parameter passing
mechanism is not specified, then it is a bounded error to assign to the
object via one access path, and then read the value of the object via a
distinct access path, unless the first access path denotes a part of a
formal parameter that no longer exists at the point of the second access
(due to leaving the corresponding callable construct). The possible
consequences are that Program_Error is raised, or the newly assigned
value is read, or some old value of the object is read.

NOTES

@item
(5) A formal parameter of mode in is a constant view, see @ref{3.3}, it
cannot be updated within the subprogram_body.
@end enumerate

@c ---------------------------------------------------------------------------
@node 6.3, 6.3.1, 6.2, 6
@section Subprogram Bodies

@enumerate
@item
A subprogram_body specifies the execution of a subprogram.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
subprogram_body ::=
   subprogram_specification is
      declarative_part
   begin
      handled_sequence_of_statements
   end [designator];
@end example

@enumerate 3
@item
If a designator appears at the end of a subprogram_body, it shall repeat
the defining_designator of the subprogram_specification.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 4
@item
In contrast to other bodies, a subprogram_body need not be the
completion of a previous declaration, in which case the body declares
the subprogram. If the body is a completion, it shall be the completion
of a subprogram_declaration or generic_subprogram_declaration. The
profile of a subprogram_body that completes a declaration shall conform
fully to that of the declaration.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A subprogram_body is considered a declaration. It can either complete a
previous declaration, or itself be the initial declaration of the
subprogram.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a non-generic subprogram_body has no other effect
than to establish that the subprogram can from then on be called without
failing the Elaboration_Check.

@item
The execution of a subprogram_body is invoked by a subprogram call. For
this execution the declarative_part is elaborated, and the
handled_sequence_of_statements is then executed.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of procedure body:

@item
@example
procedure Push(E : in Element_Type; S : in out Stack) is
begin
   if S.Index = S.Size then
      raise Stack_Overflow;
   else
      S.Index := S.Index + 1;
      S.Space(S.Index) := E;
   end if;
end Push;
@end example

@item
Example of a function body:

@item
@example
function Dot_Product(Left, Right : Vector) return Real is
   Sum : Real := 0.0;
begin
   Check(Left'First = Right'First and Left'Last = Right'Last);
   for J in Left'Range loop
      Sum := Sum + Left(J)*Right(J);
   end loop;
   return Sum;
end Dot_Product;
@end example
@end enumerate

@menu
* 6.3.1:: Conformance Rules
* 6.3.2:: Inline Expansion of Subprograms
@end menu

@c ---------------------------------------------------------------------------
@node 6.3.1, 6.3.2, 6.3, 6.3
@subsection Conformance Rules

@enumerate
@item
When subprogram profiles are given in more than one place, they are
required to conform in one of four ways: type conformance, mode
conformance, subtype conformance, or full conformance.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
As explained in @ref{B.1, ``Interfacing Pragmas''}, a convention can be
specified for an entity. For a callable entity or access-to-subprogram
type, the convention is called the calling convention. The following
conventions are defined by the language:

@enumerate 3
@item
The default calling convention for any subprogram not listed below is
Ada. A pragma Convention, Import, or Export may be used to override the
default calling convention, see @ref{B.1}.

@item
The Intrinsic calling convention represents subprograms that are ``built
in'' to the compiler. The default calling convention is Intrinsic for
the following:

@enumerate
@enumerate 5
@item
an enumeration literal;

@item
a "/=" operator declared implicitly due to the declaration of "="
(@pxref{6.6});

@item
any other implicitly declared subprogram unless it is a dispatching
operation of a tagged type;

@item
an inherited subprogram of a generic formal tagged type with unknown
discriminants;

@item
an attribute that is a subprogram;

@item
a subprogram declared immediately within a protected_body.
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 11
@item
The Access attribute is not allowed for Intrinsic subprograms.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 12
@item
The default calling convention is protected for a protected subprogram,
and for an access-to-subprogram type with the reserved word protected in
its definition.

@item
The default calling convention is entry for an entry.
@end enumerate
@end enumerate

@enumerate 14
@item
Of these four conventions, only Ada and Intrinsic are allowed as a
convention_identifier in a pragma Convention, Import, or Export.

@item
Two profiles are type conformant if they have the same number of
parameters, and both have a result if either does, and corresponding
parameter and result types are the same, or, for access parameters,
corresponding designated types are the same.

@item
Two profiles are mode conformant if they are type-conformant, and
corresponding parameters have identical modes, and, for access
parameters, the designated subtypes statically match.

@item
Two profiles are subtype conformant if they are mode-conformant,
corresponding subtypes of the profile statically match, and the
associated calling conventions are the same. The profile of a generic
formal subprogram is not subtype-conformant with any other profile.

@item
Two profiles are fully conformant if they are subtype-conformant, and
corresponding parameters have the same names and have
default_expressions that are fully conformant with one another.

@item
Two expressions are fully conformant if, after replacing each use of an
operator with the equivalent function_call:

@enumerate 20
@item
each constituent construct of one corresponds to an instance of the same
syntactic category in the other, except that an expanded name may
correspond to a direct_name (or character_literal) or to a different
expanded name in the other; and

@item
each direct_name, character_literal, and selector_name that is not part
of the prefix of an expanded name in one denotes the same declaration as
the corresponding direct_name, character_literal, or selector_name in
the other; and

@item
each primary that is a literal in one has the same value as the
corresponding literal in the other.
@end enumerate
@end enumerate

@enumerate 23
@item
Two known_discriminant_parts are fully conformant if they have the same
number of discriminants, and discriminants in the same positions have
the same names, statically matching subtypes, and default_expressions
that are fully conformant with one another.

@item
Two discrete_subtype_definitions are fully conformant if they are both
subtype_indications or are both ranges, the subtype_marks (if any)
denote the same subtype, and the corresponding simple_expressions of the
ranges (if any) fully conform.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may declare an operator declared in a language-defined
library unit to be intrinsic.
@end enumerate

@c ---------------------------------------------------------------------------
@node 6.3.2, 6.4, 6.3.1, 6.3
@subsection Inline Expansion of Subprograms

@enumerate
@item
Subprograms may be expanded in line at the call site.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Inline, which is a program unit pragma
(@pxref{10.1.5}) is as follows:

@item
@example
pragma Inline(name @{, name@{);
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The pragma shall apply to one or more callable entities or generic
subprograms.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If a pragma Inline applies to a callable entity, this indicates that
inline expansion is desired for all calls to that entity. If a pragma
Inline applies to a generic subprogram, this indicates that inline
expansion is desired for all calls to all instances of that generic
subprogram.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
For each call, an implementation is free to follow or to ignore the
recommendation expressed by the pragma.

NOTES

@item
(6) The name in a pragma Inline can denote more than one entity in the
case of overloading. Such a pragma applies to all of the denoted
entities.
@end enumerate

@c ---------------------------------------------------------------------------
@node 6.4, 6.4.1, 6.3.2, 6
@section Subprogram Calls

@enumerate
@item
A subprogram call is either a procedure_call_statement or a
function_call; it invokes the execution of the subprogram_body. The call
specifies the association of the actual parameters, if any, with formal
parameters of the subprogram.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
procedure_call_statement ::=
     procedure_name;
   | procedure_prefix actual_parameter_part;
@end example

@item
@example
function_call ::=
     function_name
   | function_prefix actual_parameter_part
@end example

@item
@example
actual_parameter_part ::=
   (parameter_association @{, parameter_association@{)
@end example

@item
@example
parameter_association ::=
   [formal_parameter_selector_name =>] explicit_actual_parameter
@end example

@item
@example
explicit_actual_parameter ::= expression | variable_name
@end example

@enumerate 7
@item
A parameter_association is named or positional according to whether or
not the formal_parameter_selector_name is specified. Any positional
associations shall precede any named associations. Named associations
are not allowed if the prefix in a subprogram call is an
attribute_reference.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 8
@item
The name or prefix given in a procedure_call_statement shall resolve to
denote a callable entity that is a procedure, or an entry renamed as
(viewed as) a procedure. The name or prefix given in a function_call
shall resolve to denote a callable entity that is a function. When there
is an actual_parameter_part, the prefix can be an implicit_dereference
of an access-to-subprogram value.

@item
A subprogram call shall contain at most one association for each formal
parameter. Each formal parameter without an association shall have a
default_expression (in the profile of the view denoted by the name or
prefix). This rule is an overloading rule, see @ref{8.6}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a subprogram call, the name or prefix of the call
is evaluated, and each parameter_association is evaluated, see @ref{6.4.1}.
If a default_expression is used, an implicit parameter_association is
assumed for this rule. These evaluations are done in an arbitrary order.
The subprogram_body is then executed. Finally, if the subprogram
completes normally, then after it is left, any necessary assigning back
of formal to actual parameters occurs, see @ref{6.4.1}.

@item
The exception Program_Error is raised at the point of a function_call if
the function completes normally without executing a return_statement.

@item
A function_call denotes a constant, as defined in @ref{6.5}, the
nominal subtype of the constant is given by the result subtype of the
function.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of procedure calls:

@item
@example
Traverse_Tree;                   --  see @ref{6.1}
Print_Header(128, Title, True);  --  see @ref{6.1}
@end example

@item
@example
Switch(From => X, To => Next);
--  see @ref{6.1}.

Print_Header(128, Header => Title, Center => True);
--  see @ref{6.1}.

Print_Header(Header => Title, Center => True, Pages => 128);
--  see @ref{6.1}.
@end example

@item
Examples of function calls:

@item
@example
Dot_Product(U, V)   --  see @ref{6.1}, and @ref{6.3}.
Clock               --  see @ref{9.6}.
F.all
--  presuming F is of an access-to-subprogram type
--  see @ref{3.10}.
@end example

@item
Examples of procedures with default expressions:

@item
@example
procedure Activate(Process : in Process_Name;
                   After   : in Process_Name := No_Process;
                   Wait    : in Duration := 0.0;
                   Prior   : in Boolean := False);
@end example

@item
@example
procedure Pair(Left, Right : in Person_Name := new Person);
--  see @ref{3.10.1}.
@end example

@item
Examples of their calls:

@item
@example
Activate(X);
Activate(X, After => Y);
Activate(X, Wait => 60.0, Prior => True);
Activate(X, Y, 10.0, False);
@end example

@item
@example
Pair;
Pair(Left => new Person, Right => new Person);
@end example

NOTES

@item
(7) If a default_expression is used for two or more parameters in a
multiple parameter_specification, the default_expression is evaluated
once for each omitted parameter. Hence in the above examples, the two
calls of Pair are equivalent.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of overloaded subprograms:

@item
@example
procedure Put(X : in Integer);
procedure Put(X : in String);
@end example

@item
@example
procedure Set(Tint   : in Color);
procedure Set(Signal : in Light);
@end example

@item
Examples of their calls:

@item
@example
Put(28);
Put("no possible ambiguity here");
@end example

@item
@example
Set(Tint   => Red);
Set(Signal => Red);
Set(Color'(Red));
@end example

@item
@example
--  Set(Red) would be ambiguous since Red may
--  denote a value either of type Color or of type Light
@end example
@end enumerate

@menu
* 6.4.1:: Parameter Associations
@end menu

@c ---------------------------------------------------------------------------
@node 6.4.1, 6.5, 6.4, 6.4
@subsection Parameter Associations

@enumerate
@item
A parameter association defines the association between an actual
parameter and a formal parameter.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The formal_parameter_selector_name of a parameter_association shall
resolve to denote a parameter_specification of the view being called.

@item
The actual parameter is either the explicit_actual_parameter given in a
parameter_association for a given formal parameter, or the corresponding
default_expression if no parameter_association is given for the formal
parameter. The expected type for an actual parameter is the type of the
corresponding formal parameter.

@item
If the mode is in, the actual is interpreted as an expression;
otherwise, the actual is interpreted only as a name, if possible.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If the mode is in out or out, the actual shall be a name that denotes a
variable.

@item
The type of the actual parameter associated with an access parameter
shall be convertible, see @ref{4.6}, to its anonymous access type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of a parameter_association:

@enumerate 8
@item
The actual parameter is first evaluated.

@item
For an access parameter, the access_definition is elaborated, which
creates the anonymous access type.

@item
For a parameter (of any mode) that is passed by reference, see @ref{6.2}, a
view conversion of the actual parameter to the nominal subtype of the
formal parameter is evaluated, and the formal parameter denotes that
conversion.

@item
For an in or in out parameter that is passed by copy, see @ref{6.2}, the
formal parameter object is created, and the value of the actual
parameter is converted to the nominal subtype of the formal parameter
and assigned to the formal.

@item
For an out parameter that is passed by copy, the formal parameter object
is created, and:

@enumerate 13
@item
For an access type, the formal parameter is initialized from the value
of the actual, without a constraint check;

@item
For a composite type with discriminants or that has implicit initial
values for any subcomponents, see @ref{3.3.1}, the behavior is as for an in
out parameter passed by copy.

@item
For any other type, the formal parameter is uninitialized. If composite,
a view conversion of the actual parameter to the nominal subtype of the
formal is evaluated (which might raise Constraint_Error), and the actual
subtype of the formal is that of the view conversion. If elementary, the
actual subtype of the formal is given by its nominal subtype.
@end enumerate
@end enumerate
@end enumerate

@enumerate 16
@item
A formal parameter of mode in out or out with discriminants is
constrained if either its nominal subtype or the actual parameter is
constrained.

@item
After normal completion and leaving of a subprogram, for each in out or
out parameter that is passed by copy, the value of the formal parameter
is converted to the subtype of the variable given as the actual
parameter and assigned to it. These conversions and assignments occur in
an arbitrary order.
@end enumerate

@c ---------------------------------------------------------------------------
@node 6.5, 6.6, 6.4.1, 6
@section Return Statements

@enumerate
@item
A return_statement is used to complete the execution of the innermost
enclosing subprogram_body, entry_body, or accept_statement.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
return_statement ::= return [expression];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expression, if any, of a return_statement is called the return
expression. The result subtype of a function is the subtype denoted by
the subtype_mark after the reserved word return in the profile of the
function. The expected type for a return expression is the result type
of the corresponding function.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A return_statement shall be within a callable construct, and it applies
to the innermost one. A return_statement shall not be within a body that
is within the construct to which the return_statement applies.

@item
A function body shall contain at least one return_statement that applies
to the function body, unless the function contains code_statements. A
return_statement shall include a return expression if and only if it
applies to a function body.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a return_statement, the expression (if any) is
first evaluated and converted to the result subtype.

@item
If the result type is class-wide, then the tag of the result is the tag
of the value of the expression.

@item
If the result type is a specific tagged type:

@enumerate 9
@item
If it is limited, then a check is made that the tag of the value of the
return expression identifies the result type. Constraint_Error is raised
if this check fails.

@item
If it is nonlimited, then the tag of the result is that of the
result type.
@end enumerate
@end enumerate

@enumerate 11
@item
A type is a return-by-reference type if it is a descendant of one of the
following:

@enumerate 12
@item
a tagged limited type;

@item
a task or protected type;

@item
a nonprivate type with the reserved word limited in its declaration;

@item
a composite type with a subcomponent of a return-by-reference type;

@item
a private type whose full type is a return-by-reference type.
@end enumerate
@end enumerate

@enumerate 17
@item
If the result type is a return-by-reference type, then a check is made
that the return expression is one of the following:

@enumerate 18
@item
a name that denotes an object view whose accessibility level is not
deeper than that of the master that elaborated the function body; or

@item
a parenthesized expression or qualified_expression whose operand is one
of these kinds of expressions.
@end enumerate
@end enumerate

@enumerate 20
@item
The exception Program_Error is raised if this check fails.

@item
For a function with a return-by-reference result type the result is
returned by reference; that is, the function call denotes a constant
view of the object associated with the value of the return expression.
For any other function, the result is returned by copy; that is, the
converted value is assigned into an anonymous constant created at the
point of the return_statement, and the function call denotes that
object.

@item
Finally, a transfer of control is performed which completes the
execution of the callable construct to which the return_statement
applies, and returns to the caller.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of return statements:

@item
@example
return;
-- in a procedure body, entry_body, or accept_statement

return Key_Value(Last_Index);
-- in a function body
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 6.6, 7, 6.5, 6
@section Overloading of Operators

@enumerate
@item
An operator is a function whose designator is an operator_symbol.
Operators, like other functions, may be overloaded.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Each use of a unary or binary operator is equivalent to a function_call
with function_prefix being the corresponding operator_symbol, and with
(respectively) one or two positional actual parameters being the
operand(s) of the operator (in order).

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The subprogram_specification of a unary or binary operator shall have
one or two parameters, respectively. A generic function instantiation
whose designator is an operator_symbol is only allowed if the
specification of the generic function has the corresponding number of
parameters.

@item
Default_expressions are not allowed for the parameters of an operator
(whether the operator is declared with an explicit
subprogram_specification or by a generic_instantiation).

@item
An explicit declaration of "/=" shall not have a result type of the
predefined type Boolean.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A declaration of "=" whose result type is Boolean implicitly declares a
declaration of "/=" that gives the complementary result.

NOTES

@item
(8) The operators "+" and "-" are both unary and binary operators, and
hence may be overloaded with both one- and two-parameter functions.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of user-defined operators:

@item
@example
function "+" (Left, Right : Matrix) return Matrix;
function "+" (Left, Right : Vector) return Vector;

--  assuming that A, B, and C are of the type Vector
--  the following two statements are equivalent:

A := B + C;
A := "+"(B, C);
@end example
@end enumerate

@c ===========================================================================
@node 7, 7.1, 6.6, Top
@chapter Packages

@enumerate
@item
Packages are program units that allow the specification of groups of
logically related entities. Typically, a package contains the
declaration of a type (often a private type or private extension) along
with the declarations of primitive subprograms of the type, which can be
called from outside the package, while their inner workings remain
hidden from outside users.
@end enumerate

@menu
* 7.1:: Package Specifications and Declarations
* 7.2:: Package Bodies
* 7.3:: Private Types and Private Extensions
* 7.4:: Deferred Constants
* 7.5:: Limited Types
* 7.6:: User-Defined Assignment and Finalization

 --- The Detailed Node Listing ---

* 7.1::   Package Specifications and Declarations
* 7.2::   Package Bodies
* 7.3::   Private Types and Private Extensions
* 7.3.1:: Private Operations
* 7.4::   Deferred Constants
* 7.5::   Limited Types
* 7.6::   User-Defined Assignment and Finalization
* 7.6.1:: Completion and Finalization

@end menu

@c ---------------------------------------------------------------------------
@node 7.1, 7.2, 7, 7
@section Package Specifications and Declarations

@enumerate
@item
A package is generally provided in two parts: a package_specification
and a package_body. Every package has a package_specification, but not
all packages have a package_body.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
package_declaration ::= package_specification;
@end example

@item
@example
package_specification ::=
   package defining_program_unit_name is
      @{basic_declarative_item@}
   [private
      @{basic_declarative_item@}]
   end [[parent_unit_name.]identifier]
@end example

@enumerate 4
@item
If an identifier or parent_unit_name.identifier appears at the end of a
package_specification, then this sequence of lexical elements shall
repeat the defining_program_unit_name.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 5
@item
A package_declaration or generic_package_declaration requires a
completion (a body) if it contains any declarative_item that requires a
completion, but whose completion is not in its package_specification.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The first list of declarative_items of a package_specification of a
package other than a generic formal package is called the visible part
of the package. The optional list of declarative_items after the
reserved word private (of any package_specification) is called the
private part of the package. If the reserved word private does not
appear, the package has an implicit empty private part.

@item
An entity declared in the private part of a package is visible only
within the declarative region of the package itself (including any child
units --  see @ref{10.1.1}. In contrast, expanded names denoting entities
declared in the visible part can be used even outside the package;
furthermore, direct visibility of such entities can be achieved by means
of use_clauses, see @ref{4.1.3}, and @ref{8.4}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a package_declaration consists of the elaboration of
its basic_declarative_items in the given order.

NOTES

@item
(1) The visible part of a package contains all the information that
another program unit is able to know about the package.

@item
(2) If a declaration occurs immediately within the specification of a
package, and the declaration has a corresponding completion that is a
body, then that body has to occur immediately within the body of the
package.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a package declaration:

@item
@example
package Rational_Numbers is
@end example

@item
@example
type Rational is
   record
      Numerator   : Integer;
      Denominator : Positive;
   end record;
@end example

@item
@example
   function "="(X,Y : Rational) return Boolean;
@end example

@item
@example
   function "/"  (X,Y : Integer)  return Rational;
   --  to construct a rational number
@end example

@item
@example
   function "+"  (X,Y : Rational) return Rational;
   function "-"  (X,Y : Rational) return Rational;
   function "*"  (X,Y : Rational) return Rational;
   function "/"  (X,Y : Rational) return Rational;
end Rational_Numbers;
@end example

@item
There are also many examples of package declarations in the predefined
language environment, see @ref{A, ``Annex A''}.
@end enumerate

@c ---------------------------------------------------------------------------
@node 7.2, 7.3, 7.1, 7
@section Package Bodies

@enumerate
@item
In contrast to the entities declared in the visible part of a package,
the entities declared in the package_body are visible only within the
package_body itself. As a consequence, a package with a package_body can
be used for the construction of a group of related subprograms in which
the logical operations available to clients are clearly isolated from
the internal entities.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
package_body ::=
   package body defining_program_unit_name is
      declarative_part
   [begin
      handled_sequence_of_statements]
   end [[parent_unit_name.]identifier];
@end example

@enumerate 3
@item
If an identifier or parent_unit_name.identifier appears at the end of a
package_body, then this sequence of lexical elements shall repeat the
defining_program_unit_name.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 4
@item
A package_body shall be the completion of a previous package_declaration
or generic_package_declaration. A library package_declaration or library
generic_package_declaration shall not have a body unless it requires a
body; pragma Elaborate_Body can be used to require a
library_unit_declaration to have a body, see @ref{10.2.1}, if it would not
otherwise require one.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
In any package_body without statements there is an implicit
null_statement. For any package_declaration without an explicit
completion, there is an implicit package_body containing a single
null_statement. For a noninstance, nonlibrary package, this body occurs
at the end of the declarative_part of the innermost enclosing program
unit or block_statement; if there are several such packages, the order
of the implicit package_bodies is unspecified. (For an instance, the
implicit package_body occurs at the place of the instantiation
(@pxref{12.3}). For a library package, the place is partially determined by
the elaboration dependences, see @ref{10,``Section 10''}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the elaboration of a nongeneric package_body, its declarative_part
is first elaborated, and its handled_sequence_of_statements is then
executed.

NOTES

@item
(3) A variable declared in the body of a package is only visible within
this body and, consequently, its value can only be changed within the
package_body. In the absence of local tasks, the value of such a
variable remains unchanged between calls issued from outside the package
to subprograms declared in the visible part. The properties of such a
variable are similar to those of a ``static'' variable of C.

@item
(4) The elaboration of the body of a subprogram explicitly declared in
the visible part of a package is caused by the elaboration of the body
of the package. Hence a call of such a subprogram by an outside program
unit raises the exception Program_Error if the call takes place before
the elaboration of the package_body, see @ref{3.11}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a package body, see @ref{7.1}

@item
@example
package body Rational_Numbers is
@end example

@item
@example
   procedure Same_Denominator (X,Y : in out Rational) is
   begin
      --  reduces X and Y to the same denominator:
      ...
   end Same_Denominator;
@end example

@item
@example
   function "="(X,Y : Rational) return Boolean is
      U : Rational := X;
      V : Rational := Y;
   begin
      Same_Denominator (U,V);
      return U.Numerator = V.Numerator;
   end "=";
@end example

@item
@example
   function "/" (X,Y : Integer) return Rational is
   begin
      if Y > 0 then
         return (Numerator => X,  Denominator => Y);
      else
         return (Numerator => -X, Denominator => -Y);
      end if;
   end "/";
@end example

@item
@example
   function "+" (X,Y : Rational) return Rational is ...  end "+";
   function "-" (X,Y : Rational) return Rational is ...  end "-";
   function "*" (X,Y : Rational) return Rational is ...  end "*";
   function "/" (X,Y : Rational) return Rational is ...  end "/";
@end example

@item
@example
end Rational_Numbers;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 7.3, 7.3.1, 7.2, 7
@section Private Types and Private Extensions

@enumerate
@item
The declaration (in the visible part of a package) of a type as a
private type or private extension serves to separate the characteristics
that can be used directly by outside program units (that is, the logical
properties) from other characteristics whose direct use is confined to
the package (the details of the definition of the type itself).
@xref{3.9.1}, for an overview of type extensions.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
private_type_declaration ::=
   type defining_identifier [discriminant_part] is
     [[abstract] tagged] [limited] private;
@end example

@item
@example
private_extension_declaration ::=
   type defining_identifier [discriminant_part] is
     [abstract] new ancestor_subtype_indication with private;
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A private_type_declaration or private_extension_declaration declares a
partial view of the type; such a declaration is allowed only as a
declarative_item of the visible part of a package, and it requires a
completion, which shall be a full_type_declaration that occurs as a
declarative_item of the private part of the package. The view of the
type declared by the full_type_declaration is called the full view. A
generic formal private type or a generic formal private extension is
also a partial view.

@item
A type shall be completely defined before it is frozen, see @ref{3.11.1},
and @ref{13.14}. Thus, neither the declaration of a variable of a
partial view of a type, nor the creation by an allocator of an object of
the partial view are allowed before the full declaration of the type.
Similarly, before the full declaration, the name of the partial view
cannot be used in a generic_instantiation or in a representation item.

@item
A private type is limited if its declaration includes the reserved word
limited; a private extension is limited if its ancestor type is limited.
If the partial view is nonlimited, then the full view shall be
nonlimited. If a tagged partial view is limited, then the full view
shall be limited. On the other hand, if an untagged partial view is
limited, the full view may be limited or nonlimited.

@item
If the partial view is tagged, then the full view shall be tagged. On
the other hand, if the partial view is untagged, then the full view may
be tagged or untagged. In the case where the partial view is untagged
and the full view is tagged, no derivatives of the partial view are
allowed within the immediate scope of the partial view; derivatives of
the full view are allowed.

@item
The ancestor subtype of a private_extension_declaration is the subtype
defined by the ancestor_subtype_indication; the ancestor type shall be a
specific tagged type. The full view of a private extension shall be
derived (directly or indirectly) from the ancestor type. In addition to
the places where Legality Rules normally apply, see @ref{12.3}, the
requirement that the ancestor be specific applies also in the private
part of an instance of a generic unit.

@item
If the declaration of a partial view includes a known_discriminant_part,
then the full_type_declaration shall have a fully conforming (explicit)
known_discriminant_part, see @ref{6.3.1, ``Conformance Rules''}. The
ancestor subtype may be unconstrained; the parent subtype of the full
view is required to be constrained, see @ref{3.7}.

@item
If a private extension inherits known discriminants from the ancestor
subtype, then the full view shall also inherit its discriminants from
the ancestor subtype, and the parent subtype of the full view shall be
constrained if and only if the ancestor subtype is constrained.

@item
If a partial view has unknown discriminants, then the
full_type_declaration may define a definite or an indefinite subtype,
with or without discriminants.

@item
If a partial view has neither known nor unknown discriminants, then the
full_type_declaration shall define a definite subtype.

@item
If the ancestor subtype of a private extension has constrained
discriminants, then the parent subtype of the full view shall impose a
statically matching constraint on those discriminants.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A private_type_declaration declares a private type and its first
subtype. Similarly, a private_extension_declaration declares a private
extension and its first subtype.

@item
A declaration of a partial view and the corresponding
full_type_declaration define two views of a single type. The declaration
of a partial view together with the visible part define the operations
that are available to outside program units; the declaration of the full
view together with the private part define other operations whose direct
use is possible only within the declarative region of the package
itself. Moreover, within the scope of the declaration of the full view,
the characteristics of the type are determined by the full view; in
particular, within its scope, the full view determines the classes that
include the type, which components, entries, and protected subprograms
are visible, what attributes and other predefined operations are
allowed, and whether the first subtype is static (@pxref{7.3.1}).

@item
A private extension inherits components (including discriminants unless
there is a new discriminant_part specified) and user-defined primitive
subprograms from its ancestor type, in the same way that a record
extension inherits components and user-defined primitive subprograms
from its parent type, see @ref{3.4}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a private_type_declaration creates a partial view of
a type. The elaboration of a private_extension_declaration elaborates
the ancestor_subtype_indication, and creates a partial view of a type.

NOTES

@item
(5) The partial view of a type as declared by a private_type_declaration
is defined to be a composite view (in 3.2). The full view of the type
might or might not be composite. A private extension is also composite,
as is its full view.

@item
(6) Declaring a private type with an unknown_discriminant_part is a way
of preventing clients from creating uninitialized objects of the type;
they are then forced to initialize each object by calling some operation
declared in the visible part of the package. If such a type is also
limited, then no objects of the type can be declared outside the scope
of the full_type_declaration, restricting all object creation to the
package defining the type. This allows complete control over all storage
allocation for the type. Objects of such a type can still be passed as
parameters, however.

@item
(7) The ancestor type specified in a private_extension_declaration and
the parent type specified in the corresponding declaration of a record
extension given in the private part need not be the same -- the parent
type of the full view can be any descendant of the ancestor type. In
this case, for a primitive subprogram that is inherited from the
ancestor type and not overridden, the formal parameter names and default
expressions (if any) come from the corresponding primitive subprogram of
the specified ancestor type, while the body comes from the corresponding
primitive subprogram of the parent type of the full view (@pxref{3.9.2}).

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of private type declarations:

@item
@example
type Key is private;
type File_Name is limited private;
@end example

@item
Example of a private extension declaration:

@item
@example
type List is new Ada.Finalization.Controlled with private;
@end example
@end enumerate

@menu
* 7.3.1:: Private Operations
@end menu

@c ---------------------------------------------------------------------------
@node 7.3.1, 7.4, 7.3, 7.3
@subsection Private Operations

@enumerate
@item
For a type declared in the visible part of a package or generic package,
certain operations on the type do not become visible until later in the
package -- either in the private part or the body. Such private
operations are available only inside the declarative region of the
package or generic package.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The predefined operators that exist for a given type are determined by
the classes to which the type belongs. For example, an integer type has
a predefined "+" operator. In most cases, the predefined operators of a
type are declared immediately after the definition of the type; the
exceptions are explained below. Inherited subprograms are also
implicitly declared immediately after the definition of the type, except
as stated below.

@item
For a composite type, the characteristics, see @ref{7.3} of the type are
determined in part by the characteristics of its component types. At the
place where the composite type is declared, the only characteristics of
component types used are those characteristics visible at that place. If
later within the immediate scope of the composite type additional
characteristics become visible for a component type, then any
corresponding characteristics become visible for the composite type. Any
additional predefined operators are implicitly declared at that place.

@item
The corresponding rule applies to a type defined by a
derived_type_definition, if there is a place within its immediate scope
where additional characteristics of its parent type become visible.

@item
For example, an array type whose component type is limited private
becomes nonlimited if the full view of the component type is nonlimited
and visible at some later place within the immediate scope of the array
type. In such a case, the predefined "=" operator is implicitly declared
at that place, and assignment is allowed after that place.

@item
Inherited primitive subprograms follow a different rule. For a
derived_type_definition, each inherited primitive subprogram is
implicitly declared at the earliest place, if any, within the immediate
scope of the type_declaration, but after the type_declaration, where the
corresponding declaration from the parent is visible. If there is no
such place, then the inherited subprogram is not declared at all. An
inherited subprogram that is not declared at all cannot be named in a
call and cannot be overridden, but for a tagged type, it is possible to
dispatch to it.

@item
For a private_extension_declaration, each inherited subprogram is
declared immediately after the private_extension_declaration if the
corresponding declaration from the ancestor is visible at that place.
Otherwise, the inherited subprogram is not declared for the private
extension, though it might be for the full type.

@item
The Class attribute is defined for tagged subtypes in 3.9. In addition,
for every subtype S of an untagged private type whose full view is
tagged, the following attribute is defined:

@item
S'Class

@example
Denotes the class-wide subtype corresponding to the full view
of S. This attribute is allowed only from the beginning of
the private part in which the full view is declared, until
the declaration of the full view. After the full view, the
Class attribute of the full view can be used.
@end example

NOTES

@item
(8) Because a partial view and a full view are two different views of
one and the same type, outside of the defining package the
characteristics of the type are those defined by the visible part.
Within these outside program units the type is just a private type or
private extension, and any language rule that applies only to another
class of types does not apply. The fact that the full declaration might
implement a private type with a type of a particular class (for example,
as an array type) is relevant only within the declarative region of the
package itself including any child units.

@item
The consequences of this actual implementation are, however, valid
everywhere. For example: any default initialization of components takes
place; the attribute Size provides the size of the full view;
finalization is still done for controlled components of the full view;
task dependence rules still apply to components that are task objects.

@item
(9) Partial views provide assignment (unless the view is limited),
membership tests, selected components for the selection of discriminants
and inherited components, qualification, and explicit conversion.

@item
(10) For a subtype S of a partial view, S'Size is defined, see @ref{13.3}.
For an object A of a partial view, the attributes A'Size and A'Address
are defined, see @ref{13.3}. The Position, First_Bit, and Last_Bit
attributes are also defined for discriminants and inherited components.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a type with private operations:

@item
@example
package Key_Manager is
   type Key is private;
   Null_Key : constant Key;
   -- a deferred constant declaration, see @ref{7.4}
   procedure Get_Key(K : out Key);
   function "<" (X, Y : Key) return Boolean;
private
   type Key is new Natural;
   Null_Key : constant Key := Key'First;
end Key_Manager;
@end example

@item
@example
package body Key_Manager is
   Last_Key : Key := Null_Key;
   procedure Get_Key(K : out Key) is
   begin
      Last_Key := Last_Key + 1;
      K := Last_Key;
   end Get_Key;
@end example

@item
@example
   function "<" (X, Y : Key) return Boolean is
   begin
      return Natural(X) < Natural(Y);
   end "<";
end Key_Manager;
@end example

NOTES

@item
(11) Notes on the example: Outside of the package Key_Manager, the
operations available for objects of type Key include assignment, the
comparison for equality or inequality, the procedure Get_Key and the
operator "<"; they do not include other relational operators such as
">=", or arithmetic operators.

@item
The explicitly declared operator "<" hides the predefined operator "<"
implicitly declared by the full_type_declaration. Within the body of the
function, an explicit conversion of X and Y to the subtype Natural is
necessary to invoke the "<" operator of the parent type. Alternatively,
the result of the function could be written as not (X >= Y), since the
operator ">=" is not redefined.

@item
The value of the variable Last_Key, declared in the package body,
remains unchanged between calls of the procedure Get_Key (See also the
NOTES of @ref{7.2})
@end enumerate

@c ---------------------------------------------------------------------------
@node 7.4, 7.5, 7.3.1, 7
@section Deferred Constants

@enumerate
@item
Deferred constant declarations may be used to declare constants in the
visible part of a package, but with the value of the constant given in
the private part. They may also be used to declare constants imported
from other languages, see @ref{B,``Annex B''}.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A deferred constant declaration is an object_declaration with the
reserved word constant but no initialization expression. The constant
declared by a deferred constant declaration is called a deferred
constant. A deferred constant declaration requires a completion, which
shall be a full constant declaration (called the full declaration of the
deferred constant), or a pragma Import (@pxref{B,``Annex B''}).

@item
A deferred constant declaration that is completed by a full constant
declaration shall occur immediately within the visible part of a
package_ specification. For this case, the following additional rules
apply to the corresponding full declaration:

@enumerate 4
@item
The full declaration shall occur immediately within the private part of
the same package;

@item
The deferred and full constants shall have the same type;

@item
If the subtype defined by the subtype_indication in the deferred
declaration is constrained, then the subtype defined by the
subtype_indication in the full declaration shall match it statically. On
the other hand, if the subtype of the deferred constant is
unconstrained, then the full declaration is still allowed to impose a
constraint. The constant itself will be constrained, like all constants;

@item
If the deferred constant declaration includes the reserved word aliased,
then the full declaration shall also.
@end enumerate
@end enumerate

@enumerate 8
@item
A deferred constant declaration that is completed by a pragma Import
need not appear in the visible part of a package_specification, and has
no full constant declaration.

@item
The completion of a deferred constant declaration shall occur before the
constant is frozen, see @ref{7.4}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a deferred constant declaration elaborates the
subtype_indication or (only allowed in the case of an imported constant)
the array_type_definition.

NOTES

@item
(12) The full constant declaration for a deferred constant that is of a
given private type or private extension is not allowed before the
corresponding full_type_declaration. This is a consequence of the
freezing rules for types, see @ref{13.14}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of deferred constant declarations:

@item
@example
Null_Key : constant Key;      --  see @ref{7.3.1}
@end example

@item
@example
CPU_Identifier : constant String(1..8);
pragma Import(Assembler, CPU_Identifier, Link_Name => "CPU_ID");
--  see @ref{B.1}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 7.5, 7.6, 7.4, 7
@section Limited Types

@enumerate
@item
A limited type is (a view of) a type for which the assignment operation
is not allowed. A nonlimited type is a (view of a) type for which the
assignment operation is allowed.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If a tagged record type has any limited components, then the reserved
word limited shall appear in its record_type_definition.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A type is limited if it is a descendant of one of the following:

@enumerate 4
@item
a type with the reserved word limited in its definition;

@item
a task or protected type;

@item
a composite type with a limited component.
@end enumerate
@end enumerate

@enumerate 7
@item
Otherwise, the type is nonlimited.

@item
There are no predefined equality operators for a limited type.

NOTES

@item
(13) The following are consequences of the rules for limited types:

@enumerate 10
@item
An initialization expression is not allowed in an object_declaration if
the type of the object is limited.

@item
A default expression is not allowed in a component_declaration if the
type of the record component is limited.

@item
An initialized allocator is not allowed if the designated type is
limited.

@item
A generic formal parameter of mode in must not be of a limited type.
@end enumerate
@end enumerate

@enumerate 14
@item
(14) Aggregates are not available for a limited composite type.
Concatenation is not available for a limited array type.

@item
(15) The rules do not exclude a default_expression for a formal
parameter of a limited type; they do not exclude a deferred constant of
a limited type if the full declaration of the constant is of a
nonlimited type.

@item
(16) As illustrated in @ref{7.3.1}, an untagged limited type can become
nonlimited under certain circumstances.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a package with a limited type:

@item
@example
package IO_Package is
   type File_Name is limited private;
@end example

@item
@example
   procedure Open (F : in out File_Name);
   procedure Close(F : in out File_Name);
   procedure Read (F : in File_Name; Item : out Integer);
   procedure Write(F : in File_Name; Item : in  Integer);
private
   type File_Name is
      limited record
         Internal_Name : Integer := 0;
      end record;
end IO_Package;
@end example

@item
@example
package body IO_Package is
   Limit : constant := 200;
   type File_Descriptor is record  ...  end record;
   Directory : array (1 .. Limit) of File_Descriptor;
   ...
   procedure Open (F : in out File_Name) is  ...  end;
   procedure Close(F : in out File_Name) is  ...  end;
   procedure Read (F : in File_Name; Item : out Integer) is ... end;
   procedure Write(F : in File_Name; Item : in  Integer) is ... end;
begin
   ...
end IO_Package;
@end example

NOTES

@item
(17) Notes on the example: In the example above, an outside subprogram
making use of IO_Package may obtain a file name by calling Open and
later use it in calls to Read and Write. Thus, outside the package, a
file name obtained from Open acts as a kind of password; its internal
properties (such as containing a numeric value) are not known and no
other operations (such as addition or comparison of internal names) can
be performed on a file name. Most importantly, clients of the package
cannot make copies of objects of type File_Name.

@item
This example is characteristic of any case where complete control over
the operations of a type is desired. Such packages serve a dual purpose.
They prevent a user from making use of the internal structure of the
type. They also implement the notion of an encapsulated data type where
the only operations on the type are those given in the package
specification.

@item
The fact that the full view of File_Name is explicitly declared limited
means that parameter passing and function return will always be by
reference, see @ref{6.2}, and @ref{6.5}.
@end enumerate

@c ---------------------------------------------------------------------------
@node 7.6, 7.6.1, 7.5, 7
@section User-Defined Assignment and Finalization

@enumerate
@item
Three kinds of actions are fundamental to the manipulation of objects:
initialization, finalization, and assignment. Every object is
initialized, either explicitly or by default, after being created (for
example, by an object_declaration or allocator). Every object is
finalized before being destroyed (for example, by leaving a
subprogram_body containing an object_declaration, or by a call to an
instance of Unchecked_Deallocation). An assignment operation is used as
part of assignment_statements, explicit initialization, parameter
passing, and other operations.

@item
Default definitions for these three fundamental operations are provided
by the language, but a controlled type gives the user additional control
over parts of these operations. In particular, the user can define, for
a controlled type, an Initialize procedure which is invoked immediately
after the normal default initialization of a controlled object, a
Finalize procedure which is invoked immediately before finalization of
any of the components of a controlled object, and an Adjust procedure
which is invoked as the last step of an assignment to a (nonlimited)
controlled object.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
package Ada.Finalization is
    pragma Preelaborate(Finalization);
@end example

@item
@example
    type Controlled is abstract tagged private;
@end example

@item
@example
    procedure Initialize(Object : in out Controlled);
    procedure Adjust                 (Object : in out Controlled);
    procedure Finalize               (Object : in out Controlled);
@end example

@item
@example
    type Limited_Controlled is abstract tagged limited private;
@end example

@item
@example
    procedure Initialize(Object : in out Limited_Controlled);
    procedure Finalize  (Object : in out Limited_Controlled);
private
    ... -- not specified by the language
end Ada.Finalization;
@end example

@item
A controlled type is a descendant of Controlled or Limited_Controlled.
The (default) implementations of Initialize, Adjust, and Finalize have
no effect. The predefined "=" operator of type Controlled always returns
True, since this operator is incorporated into the implementation of the
predefined equality operator of types derived from Controlled, as
explained in @ref{4.5.2}. The type Limited_Controlled is like
Controlled, except that it is limited and it lacks the primitive
subprogram Adjust.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
During the elaboration of an object_declaration, for every controlled
subcomponent of the object that is not assigned an initial value (as
defined in 3.3.1), Initialize is called on that subcomponent. Similarly,
if the object as a whole is controlled and is not assigned an initial
value, Initialize is called on the object. The same applies to the
evaluation of an allocator, as explained in @ref{4.8}.

@item
For an extension_aggregate whose ancestor_part is a subtype_mark,
Initialize is called on all controlled subcomponents of the ancestor
part; if the type of the ancestor part is itself controlled, the
Initialize procedure of the ancestor type is called, unless that
Initialize procedure is abstract.

@item
Initialize and other initialization operations are done in an arbitrary
order, except as follows. Initialize is applied to an object after
initialization of its subcomponents, if any (including both implicit
initialization and Initialize calls). If an object has a component with
an access discriminant constrained by a per-object expression,
Initialize is applied to this component after any components that do not
have such discriminants. For an object with several components with such
a discriminant, Initialize is applied to them in order of their
component_declarations. For an allocator, any task activations follow
all calls on Initialize.

@item
When a target object with any controlled parts is assigned a value,
either when created or in a subsequent assignment_statement, the
assignment operation proceeds as follows:

@enumerate 14
@item
The value of the target becomes the assigned value.

@item
The value of the target is adjusted.
@end enumerate
@end enumerate

@enumerate 16
@item
To adjust the value of a (nonlimited) composite object, the values of
the components of the object are first adjusted in an arbitrary order,
and then, if the object is controlled, Adjust is called. Adjusting the
value of an elementary object has no effect, nor does adjusting the
value of a composite object with no controlled parts.

@item
For an assignment_statement, after the name and expression have been
evaluated, and any conversion (including constraint checking) has been
done, an anonymous object is created, and the value is assigned into it;
that is, the assignment operation is applied. (Assignment includes value
adjustment.) The target of the assignment_statement is then finalized.
The value of the anonymous object is then assigned into the target of
the assignment_statement. Finally, the anonymous object is finalized. As
explained below, the implementation may eliminate the intermediate
anonymous object, so this description subsumes the one given in
@ref{5.2, ``Assignment Statements''}.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation is allowed to relax the above rules (for nonlimited
controlled types) in the following ways:

@enumerate 19
@item
For an assignment_statement that assigns to an object the value of that
same object, the implementation need not do anything.

@item
For an assignment_statement for a noncontrolled type, the implementation
may finalize and assign each component of the variable separately
(rather than finalizing the entire variable and assigning the entire new
value) unless a discriminant of the variable is changed by the
assignment.

@item
For an aggregate or function call whose value is assigned into a target
object, the implementation need not create a separate anonymous object
if it can safely create the value of the aggregate or function call
directly in the target object. Similarly, for an assignment_statement,
the implementation need not create an anonymous object if the value
being assigned is the result of evaluating a name denoting an object
(the source object) whose storage cannot overlap with the target. If the
source object might overlap with the target object, then the
implementation can avoid the need for an intermediary anonymous object
by exercising one of the above permissions and perform the assignment
one component at a time (for an overlapping array assignment), or not at
all (for an assignment where the target and the source of the assignment
are the same object). Even if an anonymous object is created, the
implementation may move its value to the target object as part of the
assignment without re-adjusting so long as the anonymous object has no
aliased subcomponents.
@end enumerate
@end enumerate

@menu
* 7.6.1:: Completion and Finalization
@end menu

@c ---------------------------------------------------------------------------
@node 7.6.1, 8, 7.6, 7.6
@subsection Completion and Finalization

@enumerate
@item
This subclause defines completion and leaving of the execution of
constructs and entities. A master is the execution of a construct that
includes finalization of local objects after it is complete (and after
waiting for any local tasks --  see @ref{9.3}.), but before leaving. Other
constructs and entities are left immediately upon completion.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a construct or entity is complete when the end of that
execution has been reached, or when a transfer of control, see @ref{5.1},
causes it to be abandoned. Completion due to reaching the end of
execution, or due to the transfer of control of an exit_, return_,
goto_, or requeue_statement or of the selection of a
terminate_alternative is normal completion. Completion is abnormal
otherwise -- when control is transferred out of a construct due to abort
or the raising of an exception.

@item
After execution of a construct or entity is complete, it is left,
meaning that execution continues with the next action, as defined for
the execution that is taking place. Leaving an execution happens
immediately after its completion, except in the case of a master: the
execution of a task_body, a block_statement, a subprogram_body, an
entry_body, or an accept_statement. A master is finalized after it is
complete, and before it is left.

@item
For the finalization of a master, dependent tasks are first awaited, as
explained in @ref{9.3}. Then each object whose accessibility level is
the same as that of the master is finalized if the object was
successfully initialized and still exists. These actions are performed
whether the master is left by reaching the last statement or via a
transfer of control. When a transfer of control causes completion of an
execution, each included master is finalized in order, from innermost
outward.

@item
For the finalization of an object:

@enumerate 6
@item
If the object is of an elementary type, finalization has no effect;

@item
If the object is of a controlled type, the Finalize procedure is called;

@item
If the object is of a protected type, the actions defined in @ref{9.4} are
performed;

@item
If the object is of a composite type, then after performing the above
actions, if any, every component of the object is finalized in an
arbitrary order, except as follows: if the object has a component with
an access discriminant constrained by a per-object expression, this
component is finalized before any components that do not have such
discriminants; for an object with several components with such a
discriminant, they are finalized in the reverse of the order of their
component_declarations.
@end enumerate
@end enumerate

@enumerate 10
@item
Immediately before an instance of Unchecked_Deallocation reclaims the
storage of an object, the object is finalized. If an instance of
Unchecked_Deallocation is never applied to an object created by an
allocator, the object will still exist when the corresponding master
completes, and it will be finalized then.

@item
The order in which the finalization of a master performs finalization of
objects is as follows: Objects created by declarations in the master are
finalized in the reverse order of their creation. For objects that were
created by allocators for an access type whose ultimate ancestor is
declared in the master, this rule is applied as though each such object
that still exists had been created in an arbitrary order at the first
freezing point, see @ref{13.14}, of the ultimate ancestor type.

@item
The target of an assignment statement is finalized before copying in the
new value, as explained in @ref{7.6}.

@item
The anonymous objects created by function calls and by aggregates are
finalized no later than the end of the innermost enclosing
declarative_item or statement; if that is a compound_statement, they are
finalized before starting the execution of any statement within the
compound_statement.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
It is a bounded error for a call on Finalize or Adjust to propagate an
exception. The possible consequences depend on what action invoked the
Finalize or Adjust operation:

@enumerate 15
@item
For a Finalize invoked as part of an assignment_statement, Program_Error
is raised at that point.

@item
For an Adjust invoked as part of an assignment operation, any other
adjustments due to be performed are performed, and then Program_Error is
raised.

@item
For a Finalize invoked as part of a call on an instance of
Unchecked_Deallocation, any other finalizations due to be performed are
performed, and then Program_Error is raised.

@item
For a Finalize invoked by the transfer of control of an exit_, return_,
goto_, or requeue_statement, Program_Error is raised no earlier than
after the finalization of the master being finalized when the exception
occurred, and no later than the point where normal execution would have
continued. Any other finalizations due to be performed up to that point
are performed before raising Program_Error.

@item
For a Finalize invoked by a transfer of control that is due to raising
an exception, any other finalizations due to be performed for the same
master are performed; Program_Error is raised immediately after leaving
the master.

@item
For a Finalize invoked by a transfer of control due to an abort or
selection of a terminate alternative, the exception is ignored; any
other finalizations due to be performed are performed.
@end enumerate
@end enumerate
@enumerate 21

NOTES

@item
(18) The rules in @ref{10, ``Section 10''}, imply that immediately
prior to partition termination, Finalize operations are applied to
library-level controlled objects (including those created by allocators
of library-level access types, except those already finalized). This
occurs after waiting for library-level tasks to terminate.

@item
(19) A constant is only constant between its initialization and
finalization. Both initialization and finalization are allowed to change
the value of a constant.

@item
(20) Abort is deferred during certain operations related to controlled
types, as explained in @ref{9.8}. Those rules prevent an abort from
causing a controlled object to be left in an ill-defined state.

@item
(21) The Finalize procedure is called upon finalization of a controlled
object, even if Finalize was called earlier, either explicitly or as
part of an assignment; hence, if a controlled type is visibly controlled
(implying that its Finalize primitive is directly callable), or is
nonlimited (implying that assignment is allowed), its Finalize procedure
should be designed to have no ill effect if it is applied a second time
to the same object.
@end enumerate

@c ===========================================================================
@node 8, 8.1, 7.6.1, Top
@chapter Visibility Rules

@enumerate
@item
The rules defining the scope of declarations and the rules defining
which identifiers, character_literals, and operator_symbols are visible
at (or from) various places in the text of the program are described in
this section. The formulation of these rules uses the notion of a
declarative region.

@item
As explained in @ref{3, Section 3}, a declaration declares a view of an
entity and associates a defining name with that view. The view comprises
an identification of the viewed entity, and possibly additional
properties. A usage name denotes a declaration. It also denotes the view
declared by that declaration, and denotes the entity of that view. Thus,
two different usage names might denote two different views of the same
entity; in this case they denote the same entity.
@end enumerate

@menu
* 8.1:: Declarative Region
* 8.2:: Scope of Declarations
* 8.3:: Visibility
* 8.4:: Use Clauses
* 8.5:: Renaming Declarations
* 8.6:: The Context of Overload Resolution

 --- The Detailed Node Listing ---

* 8.1::   Declarative Region
* 8.2::   Scope of Declarations
* 8.3::   Visibility
* 8.4::   Use Clauses
* 8.5::   Renaming Declarations
* 8.5.1:: Object Renaming Declarations
* 8.5.2:: Exception Renaming Declarations
* 8.5.3:: Package Renaming Declarations
* 8.5.4:: Subprogram Renaming Declarations
* 8.5.5:: Generic Renaming Declarations
* 8.6::   The Context of Overload Resolution
@end menu

@c ---------------------------------------------------------------------------
@node 8.1, 8.2, 8, 8
@section Declarative Region

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
For each of the following constructs, there is a portion of the program
text called its declarative region, within which nested declarations can
occur:

@enumerate 2
@item
any declaration, other than that of an enumeration type, that is not a
completion of a previous declaration;

@item
a block_statement;

@item
a loop_statement;

@item
an accept_statement;

@item
an exception_handler.
@end enumerate
@end enumerate

@enumerate 7
@item
The declarative region includes the text of the construct together with
additional text determined (recursively), as follows:

@enumerate 8
@item
If a declaration is included, so is its completion, if any.

@item
If the declaration of a library unit (including Standard --
see @ref{10.1.1}, is included, so are the declarations of any child units
(and their completions, by the previous rule). The child declarations
occur after the declaration.

@item
If a body_stub is included, so is the corresponding subunit.

@item
If a type_declaration is included, then so is a corresponding
record_representation_clause, if any.
@end enumerate
@end enumerate

@enumerate 12
@item
The declarative region of a declaration is also called the declarative
region of any view or entity declared by the declaration.

@item
A declaration occurs immediately within a declarative region if this
region is the innermost declarative region that encloses the declaration
(the immediately enclosing declarative region), not counting the
declarative region (if any) associated with the declaration itself.

@item
A declaration is local to a declarative region if the declaration occurs
immediately within the declarative region. An entity is local to a
declarative region if the entity is declared by a declaration that is
local to the declarative region.

@item
A declaration is global to a declarative region if the declaration
occurs immediately within another declarative region that encloses the
declarative region. An entity is global to a declarative region if the
entity is declared by a declaration that is global to the declarative
region.

NOTES

@item
(1) The children of a parent library unit are inside the parent's
declarative region, even though they do not occur inside the parent's
declaration or body. This implies that one can use (for example) "P.Q"
to refer to a child of P whose defining name is Q, and that after "use
P;" Q can refer (directly) to that child.

@item
(2) As explained above and in @ref{10.1.1, ``Compilation Units -
Library Units''}, all library units are descendants of Standard, and so
are contained in the declarative region of Standard. They are not inside
the declaration or body of Standard, but they are inside its declarative
region.

@item
(3) For a declarative region that comes in multiple parts, the text of
the declarative region does not contain any text that might appear
between the parts. Thus, when a portion of a declarative region is said
to extend from one place to another in the declarative region, the
portion does not contain any text that might appear between the parts of
the declarative region.
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.2, 8.3, 8.1, 8
@section Scope of Declarations

@enumerate
@item
For each declaration, the language rules define a certain portion of the
program text called the scope of the declaration. The scope of a
declaration is also called the scope of any view or entity declared by
the declaration. Within the scope of an entity, and only there, there
are places where it is legal to refer to the declared entity. These
places are defined by the rules of visibility and overloading.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The immediate scope of a declaration is a portion of the declarative
region immediately enclosing the declaration. The immediate scope starts
at the beginning of the declaration, except in the case of an
overloadable declaration, in which case the immediate scope starts just
after the place where the profile of the callable entity is determined
(which is at the end of the _specification for the callable entity, or
at the end of the generic_instantiation if an instance). The immediate
scope extends to the end of the declarative region, with the following
exceptions:

@enumerate 3
@item
The immediate scope of a library_item includes only its semantic
dependents.

@item
The immediate scope of a declaration in the private part of a library
unit does not include the visible part of any public descendant of that
library unit.
@end enumerate
@end enumerate

@enumerate 5
@item
The visible part of (a view of) an entity is a portion of the text of
its declaration containing declarations that are visible from outside.
The private part of (a view of) an entity that has a visible part
contains all declarations within the declaration of (the view of) the
entity, except those in the visible part; these are not visible from
outside. Visible and private parts are defined only for these kinds of
entities: callable entities, other program units, and composite types.

@enumerate 6
@item
The visible part of a view of a callable entity is its profile.

@item
The visible part of a composite type other than a task or protected type
consists of the declarations of all components declared (explicitly or
implicitly) within the type_declaration.

@item
The visible part of a generic unit includes the generic_formal_part. For
a generic package, it also includes the first list of
basic_declarative_items of the package_specification. For a generic
subprogram, it also includes the profile.

@item
The visible part of a package, task unit, or protected unit consists of
declarations in the program unit's declaration other than those
following the reserved word private, if any; see @ref{7.1}, and
@ref{12.7}, for packages, see @ref{9.1}, for task units, and @ref{9.4},
for protected units.
@end enumerate
@end enumerate

@enumerate 10
@item
The scope of a declaration always contains the immediate scope of the
declaration. In addition, for a given declaration that occurs
immediately within the visible part of an outer declaration, or is a
public child of an outer declaration, the scope of the given declaration
extends to the end of the scope of the outer declaration, except that
the scope of a library_item includes only its semantic dependents.

@item
The immediate scope of a declaration is also the immediate scope of the
entity or view declared by the declaration. Similarly, the scope of a
declaration is also the scope of the entity or view declared by the
declaration.

NOTES

@item
(4) There are notations for denoting visible declarations that are not
directly visible. For example, parameter_specifications are in the
visible part of a subprogram_declaration so that they can be used in
named-notation calls appearing outside the called subprogram. For
another example, declarations of the visible part of a package can be
denoted by expanded names appearing outside the package, and can be made
directly visible by a use_clause.
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.3, 8.4, 8.2, 8
@section Visibility

@enumerate
@item
The visibility rules, given below, determine which declarations are
visible and directly visible at each place within a program. The
visibility rules apply to both explicit and implicit declarations.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A declaration is defined to be directly visible at places where a name
consisting of only an identifier or operator_symbol is sufficient to
denote the declaration; that is, no selected_component notation or
special context (such as preceding => in a named association) is
necessary to denote the declaration. A declaration is defined to be
visible wherever it is directly visible, as well as at other places
where some name (such as a selected_component) can denote the
declaration.

@item
The syntactic category direct_name is used to indicate contexts where
direct visibility is required. The syntactic category selector_name is
used to indicate contexts where visibility, but not direct visibility,
is required.

@item
There are two kinds of direct visibility: immediate visibility and
use-visibility. A declaration is immediately visible at a place if it is
directly visible because the place is within its immediate scope. A
declaration is use-visible if it is directly visible because of a
use_clause, see @ref{8.4}. Both conditions can apply.

@item
A declaration can be hidden, either from direct visibility, or from all
visibility, within certain parts of its scope. Where hidden from all
visibility, it is not visible at all (neither using a direct_name nor a
selector_name). Where hidden from direct visibility, only direct
visibility is lost; visibility using a selector_name is still possible.

@item
Two or more declarations are overloaded if they all have the same
defining name and there is a place where they are all directly visible.

@item
The declarations of callable entities (including enumeration literals)
are overloadable, meaning that overloading is allowed for them.

@item
Two declarations are homographs if they have the same defining name,
and, if both are overloadable, their profiles are type conformant. An
inner declaration hides any outer homograph from direct visibility.

@item
Two homographs are not generally allowed immediately within the same
declarative region unless one overrides the other (see Legality Rules
below). A declaration overrides another homograph that occurs
immediately within the same declarative region in the following cases:

@enumerate 10
@item
An explicit declaration overrides an implicit declaration of a primitive
subprogram, regardless of which declaration occurs first;

@item
The implicit declaration of an inherited operator overrides that of a
predefined operator;

@item
An implicit declaration of an inherited subprogram overrides a previous
implicit declaration of an inherited subprogram.

@item
For an implicit declaration of a primitive subprogram in a generic unit,
there is a copy of this declaration in an instance. However, a whole new
set of primitive subprograms is implicitly declared for each type
declared within the visible part of the instance. These new declarations
occur immediately after the type declaration, and override the copied
ones. The copied ones can be called only from within the instance; the
new ones can be called only from outside the instance, although for
tagged types, the body of a new one can be executed by a call to an old
one.
@end enumerate
@end enumerate

@enumerate 14
@item
A declaration is visible within its scope, except where hidden from all
visibility, as follows:

@enumerate 15
@item
An overridden declaration is hidden from all visibility within the scope
of the overriding declaration.

@item
A declaration is hidden from all visibility until the end of the
declaration, except:

@enumerate 17
@item
For a record type or record extension, the declaration is hidden from
all visibility only until the reserved word record;

@item
For a package_declaration, task declaration, protected declaration,
generic_package_declaration, or subprogram_body, the declaration is
hidden from all visibility only until the reserved word is of the
declaration.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 19
@item
If the completion of a declaration is a declaration, then within the
scope of the completion, the first declaration is hidden from all
visibility. Similarly, a discriminant_specification or
parameter_specification is hidden within the scope of a corresponding
discriminant_specification or parameter_specification of a corresponding
completion, or of a corresponding accept_statement.

@item
The declaration of a library unit (including a
library_unit_renaming_declaration) is hidden from all visibility except
at places that are within its declarative region or within the scope of
a with_clause that mentions it. For each declaration or renaming of a
generic unit as a child of some parent generic package, there is a
corresponding declaration nested immediately within each instance of the
parent. Such a nested declaration is hidden from all visibility except
at places that are within the scope of a with_clause that mentions the
child.
@end enumerate
@end enumerate

@enumerate 21
@item
A declaration with a defining_identifier or defining_operator_symbol is
immediately visible (and hence directly visible) within its immediate
scope except where hidden from direct visibility, as follows:

@enumerate 22
@item
A declaration is hidden from direct visibility within the immediate
scope of a homograph of the declaration, if the homograph occurs within
an inner declarative region;

@item
A declaration is also hidden from direct visibility where hidden from
all visibility.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 24
@item
A direct_name shall resolve to denote a directly visible declaration
whose defining name is the same as the direct_name. A selector_name
shall resolve to denote a visible declaration whose defining name is the
same as the selector_name.

@item
These rules on visibility and direct visibility do not apply in a
context_clause, a parent_unit_name, or a pragma that appears at the
place of a compilation_unit. For those contexts, see the rules in
@ref{10.1.6, ``Environment-Level Visibility Rules''}.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An explicit declaration is illegal if there is a homograph occurring
immediately within the same declarative region that is visible at the
place of the declaration, and is not hidden from all visibility by the
explicit declaration. Similarly, the context_clause for a subunit is
illegal if it mentions (in a with_clause) some library unit, and there
is a homograph of the library unit that is visible at the place of the
corresponding stub, and the homograph and the mentioned library unit are
both declared immediately within the same declarative region. These
rules also apply to dispatching operations declared in the visible part
of an instance of a generic unit. However, they do not apply to other
overloadable declarations in an instance; such declarations may have
type conformant profiles in the instance, so long as the corresponding
declarations in the generic were not type conformant.

NOTES

@item
(5) Visibility for compilation units follows from the definition of the
environment in @ref{10.1.4}, except that it is necessary to apply a
with_clause to obtain visibility to a library_unit_declaration or
library_unit_renaming_declaration.

@item
(6) In addition to the visibility rules given above, the meaning of the
occurrence of a direct_name or selector_name at a given place in the
text can depend on the overloading rules, see @ref{8.6}.

@item
(7) Not all contexts where an identifier, character_literal, or
operator_symbol are allowed require visibility of a corresponding
declaration. Contexts where visibility is not required are identified by
using one of these three syntactic categories directly in a syntax rule,
rather than using direct_name or selector_name.
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.4, 8.5, 8.3, 8
@section Use Clauses

@enumerate
@item
A use_package_clause achieves direct visibility of declarations that
appear in the visible part of a package; a use_type_clause achieves
direct visibility of the primitive operators of a type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
use_clause ::= use_package_clause | use_type_clause
@end example

@item
@example
use_package_clause ::= use package_name @{, package_name@};
@end example

@item
@example
use_type_clause ::= use type subtype_mark @{, subtype_mark@};
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A package_name of a use_package_clause shall denote a package.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For each use_clause, there is a certain region of text called the scope
of the use_clause. For a use_clause within a context_clause of a
library_unit_declaration or library_unit_renaming_declaration, the scope
is the entire declarative region of the declaration. For a use_clause
within a context_clause of a body, the scope is the entire body and any
subunits (including multiply nested subunits). The scope does not
include context_clauses themselves.

@item
For a use_clause immediately within a declarative region, the scope is
the portion of the declarative region starting just after the use_clause
and extending to the end of the declarative region. However, the scope
of a use_clause in the private part of a library unit does not include
the visible part of any public descendant of that library unit.

@item
For each package denoted by a package_name of a use_package_clause whose
scope encloses a place, each declaration that occurs immediately within
the declarative region of the package is potentially use-visible at this
place if the declaration is visible at this place. For each type T or
T'Class determined by a subtype_mark of a use_type_clause whose scope
encloses a place, the declaration of each primitive operator of type T
is potentially use-visible at this place if its declaration is visible
at this place.

@item
A declaration is use-visible if it is potentially use-visible, except in
these naming-conflict cases:

@enumerate 10
@item
A potentially use-visible declaration is not use-visible if the place
considered is within the immediate scope of a homograph of the
declaration.

@item
Potentially use-visible declarations that have the same identifier are
not use-visible unless each of them is an overloadable declaration.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 12
@item
The elaboration of a use_clause has no effect.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a use clause in a context clause:

@item
@example
with Ada.Calendar; use Ada;
@end example

@item
@example
Example of a use type clause:
@end example

@item
@example
use type Rational_Numbers.Rational;  --  see @ref{7.1}
Two_Thirds: Rational_Numbers.Rational := 2/3;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.5, 8.5.1, 8.4, 8
@section Renaming Declarations

@enumerate
@item
A renaming_declaration declares another name for an entity, such as an
object, exception, package, subprogram, entry, or generic unit.
Alternatively, a subprogram_renaming_declaration can be the completion
of a previous subprogram_declaration.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
renaming_declaration ::=
      object_renaming_declaration
    | exception_renaming_declaration
    | package_renaming_declaration
    | subprogram_renaming_declaration
    | generic_renaming_declaration
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a renaming_declaration evaluates the name that
follows the reserved word renames and thereby determines the view and
entity denoted by this name (the renamed view and renamed entity). A
name that denotes the renaming_declaration denotes (a new view of) the
renamed entity.

NOTES

@item
(8) Renaming may be used to resolve name conflicts and to act as a
shorthand. Renaming with a different identifier or operator_symbol does
not hide the old name; the new name and the old name need not be visible
at the same places.

@item
(9) A task or protected object that is declared by an explicit
object_declaration can be renamed as an object. However, a single task
or protected object cannot be renamed since the corresponding type is
anonymous (meaning it has no nameable subtypes). For similar reasons, an
object of an anonymous array or access type cannot be renamed.

@item
(10) A subtype defined without any additional constraint can be used to
achieve the effect of renaming another subtype (including a task or
protected subtype) as in

@item
@example
subtype Mode is Ada.Text_IO.File_Mode;
@end example
@end enumerate

@menu
* 8.5.1:: Object Renaming Declarations
* 8.5.2:: Exception Renaming Declarations
* 8.5.3:: Package Renaming Declarations
* 8.5.4:: Subprogram Renaming Declarations
* 8.5.5:: Generic Renaming Declarations
@end menu

@c ---------------------------------------------------------------------------
@node 8.5.1, 8.5.2, 8.5, 8.5
@subsection Object Renaming Declarations

@enumerate
@item
An object_renaming_declaration is used to rename an object.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
object_renaming_declaration ::=
   defining_identifier : subtype_mark renames object_name;
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The type of the object_name shall resolve to the type determined by the
subtype_mark.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The renamed entity shall be an object.

@item
The renamed entity shall not be a subcomponent that depends on
discriminants of a variable whose nominal subtype is unconstrained,
unless this subtype is indefinite, or the variable is aliased. A slice
of an array shall not be renamed if this restriction disallows renaming
of the array.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An object_renaming_declaration declares a new view of the renamed object
whose properties are identical to those of the renamed view. Thus, the
properties of the renamed object are not affected by the
renaming_declaration. In particular, its value and whether or not it is
a constant are unaffected; similarly, the constraints that apply to an
object are not affected by renaming (any constraint implied by the
subtype_mark of the object_renaming_declaration is ignored).

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of renaming an object:

@item
@example
declare
   L : Person renames Leftmost_Person;  --  see @ref{3.10.1}
begin
   L.Age := L.Age + 1;
end;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.5.2, 8.5.3, 8.5.1, 8.5
@subsection Exception Renaming Declarations

@enumerate
@item
An exception_renaming_declaration is used to rename an exception.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
exception_renaming_declaration ::=
   defining_identifier : exception renames exception_name;
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The renamed entity shall be an exception.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An exception_renaming_declaration declares a new view of the renamed
exception.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of renaming an exception:

@item
@example
EOF : exception renames Ada.IO_Exceptions.End_Error;
--  see @ref{A.13}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.5.3, 8.5.4, 8.5.2, 8.5
@subsection Package Renaming Declarations

@enumerate
@item
A package_renaming_declaration is used to rename a package.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
package_renaming_declaration ::=
   package defining_program_unit_name renames package_name;
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The renamed entity shall be a package.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A package_renaming_declaration declares a new view of the renamed
package.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of renaming a package:

@item
@example
package TM renames Table_Manager;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.5.4, 8.5.5, 8.5.3, 8.5
@subsection Subprogram Renaming Declarations

@enumerate
@item
A subprogram_renaming_declaration can serve as the completion of a
subprogram_declaration; such a renaming_declaration is called a
renaming-as-body. A subprogram_renaming_declaration that is not a
completion is called a renaming-as-declaration, and is used to rename a
subprogram (possibly an enumeration literal) or an entry.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
subprogram_renaming_declaration ::=
   subprogram_specification renames callable_entity_name;
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected profile for the callable_entity_name is the profile given
in the subprogram_specification.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The profile of a renaming-as-declaration shall be mode-conformant with
that of the renamed callable entity.

@item
The profile of a renaming-as-body shall be subtype-conformant with that
of the renamed callable entity, and shall conform fully to that of the
declaration it completes. If the renaming-as-body completes that
declaration before the subprogram it declares is frozen, the subprogram
it declares takes its convention from the renamed subprogram; otherwise
the convention of the renamed subprogram shall not be Intrinsic.

@item
A name that denotes a formal parameter of the subprogram_specification
is not allowed within the callable_entity_name.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A renaming-as-declaration declares a new view of the renamed entity. The
profile of this new view takes its subtypes, parameter modes, and
calling convention from the original profile of the callable entity,
while taking the formal parameter names and default_expressions from the
profile given in the subprogram_renaming_declaration. The new view is a
function or procedure, never an entry.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For a call on a renaming of a dispatching subprogram that is overridden,
if the overriding occurred before the renaming, then the body executed
is that of the overriding declaration, even if the overriding
declaration is not visible at the place of the renaming; otherwise, the
inherited or predefined subprogram is called.

NOTES

@item
(11) A procedure can only be renamed as a procedure. A function whose
defining_designator is either an identifier or an operator_symbol can be
renamed with either an identifier or an operator_symbol; for renaming as
an operator, the subprogram specification given in the
renaming_declaration is subject to the rules given in @ref{6.6}, for
operator declarations. Enumeration literals can be renamed as functions;
similarly, attribute_references that denote functions (such as
references to Succ and Pred) can be renamed as functions. An entry can
only be renamed as a procedure; the new name is only allowed to appear
in contexts that allow a procedure name. An entry of a family can be
renamed, but an entry family cannot be renamed as a whole.

@item
(12) The operators of the root numeric types cannot be renamed because
the types in the profile are anonymous, so the corresponding
specifications cannot be written; the same holds for certain attributes,
such as Pos.

@item
(13) Calls with the new name of a renamed entry are
procedure_call_statements and are not allowed at places where the syntax
requires an entry_call_statement in conditional_ and timed_entry_calls,
nor in an asynchronous_select; similarly, the Count attribute is not
available for the new name.

@item
(14) The primitiveness of a renaming-as-declaration is determined by its
profile, and by where it occurs, as for any declaration of (a view of) a
subprogram; primitiveness is not determined by the renamed view. In
order to perform a dispatching call, the subprogram name has to denote a
primitive subprogram, not a non-primitive renaming of a primitive
subprogram.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of subprogram renaming declarations:

@item
@example
procedure My_Write(C : in Character) renames Pool(K).Write;
--  see @ref{4.1.3}
@end example

@item
@example
function Real_Plus(Left, Right : Real   ) return Real    renames "+";
function Int_Plus (Left, Right : Integer) return Integer renames "+";
@end example

@item
@example
function Rouge return Color renames Red;  --  see @ref{3.5.1}
function Rot   return Color renames Red;
function Rosso return Color renames Rouge;
@end example

@item
@example
function Next(X : Color) return Color renames Color'Succ;
--  see @ref{3.5.1}
@end example

@item
Example of a subprogram renaming declaration with new parameter names:

@item
@example
function "*" (X,Y : Vector) return Real renames Dot_Product;
--  see @ref{6.1}
@end example

@item
Example of a subprogram renaming declaration with a new default expression:

@item
@example
function Minimum(L : Link := Head) return Cell renames Min_Cell;
--  see @ref{6.1}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.5.5, 8.6, 8.5.4, 8.5
@subsection Generic Renaming Declarations

@enumerate
A generic_renaming_declaration is used to rename a generic unit.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
generic_renaming_declaration ::=
    generic package defining_program_unit_name renames
      generic_package_name;
  | generic procedure defining_program_unit_name renames
      generic_procedure_name;
  | generic function defining_program_unit_name renames
      generic_function_name;
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The renamed entity shall be a generic unit of the corresponding kind.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A generic_renaming_declaration declares a new view of the renamed
generic unit.

NOTES

@item
(15) Although the properties of the new view are the same as those of
the renamed view, the place where the generic_renaming_declaration
occurs may affect the legality of subsequent renamings and
instantiations that denote the generic_renaming_declaration, in
particular if the renamed generic unit is a library unit, see @ref{10.1.1}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of renaming a generic unit:

@item
@example
generic package Enum_IO renames Ada.Text_IO.Enumeration_IO;
--  see @ref{A.10.10}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 8.6, 9, 8.5.5, 8
@section The Context of Overload Resolution

@enumerate
@item
Because declarations can be overloaded, it is possible for an occurrence
of a usage name to have more than one possible interpretation; in most
cases, ambiguity is disallowed. This clause describes how the possible
interpretations resolve to the actual interpretation.

@item
Certain rules of the language (the Name Resolution Rules) are considered
``overloading rules''. If a possible interpretation violates an
overloading rule, it is assumed not to be the intended interpretation;
some other possible interpretation is assumed to be the actual
interpretation. On the other hand, violations of non-overloading rules
do not affect which interpretation is chosen; instead, they cause the
construct to be illegal. To be legal, there usually has to be exactly
one acceptable interpretation of a construct that is a ``complete
context'', not counting any nested complete contexts.

@item
The syntax rules of the language and the visibility rules given in
@ref{8.3}, determine the possible interpretations. Most type checking
rules (rules that require a particular type, or a particular class of
types, for example) are overloading rules. Various rules for the
matching of formal and actual parameters are overloading rules.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Overload resolution is applied separately to each complete context, not
counting inner complete contexts. Each of the following constructs is a
complete context:

@enumerate 5
@item
A context_item.

@item
declarative_item or declaration.

@item
A statement.

@item
A pragma_argument_association.

@item
The expression of a case_statement.
@end enumerate
@end enumerate

@enumerate 10
@item
An (overall) interpretation of a complete context embodies its meaning,
and includes the following information about the constituents of the
complete context, not including constituents of inner complete contexts:

@enumerate 11
@item
for each constituent of the complete context, to which syntactic
categories it belongs, and by which syntax rules; and

@item
for each usage name, which declaration it denotes (and, therefore, which
view and which entity it denotes); and

@item
for a complete context that is a declarative_item, whether or not it is
a completion of a declaration, and (if so) which declaration it
completes.
@end enumerate
@end enumerate

@enumerate 14
@item
A possible interpretation is one that obeys the syntax rules and the
visibility rules. An acceptable interpretation is a possible
interpretation that obeys the overloading rules, that is, those rules
that specify an expected type or expected profile, or specify how a
construct shall resolve or be interpreted.

@item
The interpretation of a constituent of a complete context is determined
from the overall interpretation of the complete context as a whole.
Thus, for example, ``interpreted as a function_call,'' means that the
construct's interpretation says that it belongs to the syntactic
category function_call.

@item
Each occurrence of a usage name denotes the declaration determined by
its interpretation. It also denotes the view declared by its denoted
declaration, except in the following cases:

@enumerate 17
@item
If a usage name appears within the declarative region of a
type_declaration and denotes that same type_declaration, then it denotes
the current instance of the type (rather than the type itself). The
current instance of a type is the object or value of the type that is
associated with the execution that evaluates the usage name.

@item
If a usage name appears within the declarative region of a
generic_declaration (but not within its generic_formal_part) and it
denotes that same generic_declaration, then it denotes the current
instance of the generic unit (rather than the generic unit itself). See
also @ref{12.3}.
@end enumerate
@end enumerate

@enumerate 19
@item
A usage name that denotes a view also denotes the entity of that view.

@item
The expected type for a given expression, name, or other construct
determines, according to the type resolution rules given below, the
types considered for the construct during overload resolution. The type
resolution rules provide support for class-wide programming, universal
numeric literals, dispatching operations, and anonymous access types:

@enumerate 21
@item
If a construct is expected to be of any type in a class of types, or of
the universal or class-wide type for a class, then the type of the
construct shall resolve to a type in that class or to a universal type
that covers the class.

@item
If the expected type for a construct is a specific type T, then the type
of the construct shall resolve either to T, or:

@enumerate 23
@item
to T'Class; or

@item
to a universal type that covers T; or

@item
when T is an anonymous access type, see @ref{3.10}, with designated type D,
to an access-to-variable type whose designated type is D'Class or is
covered by D.
@end enumerate
@end enumerate
@end enumerate

@enumerate 26
@item
In certain contexts, such as in a subprogram_renaming_declaration, the
Name Resolution Rules define an expected profile for a given name; in
such cases, the name shall resolve to the name of a callable entity
whose profile is type conformant with the expected profile.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
When the expected type for a construct is required to be a single type
in a given class, the type expected for the construct shall be
determinable solely from the context in which the construct appears,
excluding the construct itself, but using the requirement that it be in
the given class; the type of the construct is then this single expected
type. Furthermore, the context shall not be one that expects any type
in some class that contains types of the given class; in particular, the
construct shall not be the operand of a type_conversion.

@item
A complete context shall have at least one acceptable interpretation; if
there is exactly one, then that one is chosen.

@item
There is a preference for the primitive operators (and ranges) of the
root numeric types root_integer and root_real. In particular, if two
acceptable interpretations of a constituent of a complete context differ
only in that one is for a primitive operator (or range) of the type
root_integer or root_real, and the other is not, the interpretation
using the primitive operator (or range) of the root numeric type is
preferred.

@item
For a complete context, if there is exactly one overall acceptable
interpretation where each constituent's interpretation is the same as or
preferred (in the above sense) over those in all other overall
acceptable interpretations, then that one overall acceptable
interpretation is chosen. Otherwise, the complete context is ambiguous.

@item
A complete context other than a pragma_argument_association shall not be
ambiguous.

@item
A complete context that is a pragma_argument_association is allowed to
be ambiguous (unless otherwise specified for the particular pragma), but
only if every acceptable interpretation of the pragma argument is as a
name that statically denotes a callable entity. Such a name denotes all
of the declarations determined by its interpretations, and all of the
views declared by these declarations.

     NOTES

@item
(16) If a usage name has only one acceptable interpretation, then it
denotes the corresponding entity. However, this does not mean that the
usage name is necessarily legal since other requirements exist which are
not considered for overload resolution; for example, the fact that an
expression is static, whether an object is constant, mode and subtype
conformance rules, freezing rules, order of elaboration, and so on.

@item
Similarly, subtypes are not considered for overload resolution (the
violation of a constraint does not make a program illegal but raises an
exception during program execution).
@end enumerate

@c ===========================================================================
@node 9, 9.1, 8.6, Top
@chapter Tasks and Synchronization

@enumerate
@item
The execution of an Ada program consists of the execution of one or more
tasks. Each task represents a separate thread of control that proceeds
independently and concurrently between the points where it interacts
with other tasks. The various forms of task interaction are described in
this section, and include:

@enumerate 2
@item
the activation and termination of a task;

@item
a call on a protected subprogram of a protected object, providing
exclusive read-write access, or concurrent read-only access to shared
data;

@item
a call on an entry, either of another task, allowing for synchronous
communication with that task, or of a protected object, allowing for
asynchronous communication with one or more other tasks using that same
protected object;

@item
a timed operation, including a simple delay statement, a timed entry
call or accept, or a timed asynchronous select statement (see next
item);

@item
an asynchronous transfer of control as part of an asynchronous select
statement, where a task stops what it is doing and begins execution at a
different point in response to the completion of an entry call or the
expiration of a delay;

@item
an abort statement, allowing one task to cause the termination of
another task.
@end enumerate
@end enumerate

@enumerate 8
@item
In addition, tasks can communicate indirectly by reading and updating
(unprotected) shared variables, presuming the access is properly
synchronized through some other kind of task interaction.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The properties of a task are defined by a corresponding task declaration
and task_body, which together define a program unit called a task unit.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Over time, tasks proceed through various states. A task is initially
inactive; upon activation, and prior to its termination it is either
blocked (as part of some task interaction) or ready to run. While ready,
a task competes for the available execution resources that it requires
to run.

NOTES

@item
(1) Concurrent task execution may be implemented on multicomputers,
multiprocessors, or with interleaved execution on a single physical
processor. On the other hand, whenever an implementation can determine
that the required semantic effects can be achieved when parts of the
execution of a given task are performed by different physical processors
acting in parallel, it may choose to perform them in this way.
@end enumerate

@menu
* 9.1::  Task Units and Task Objects
* 9.2::  Task Execution - Task Activation
* 9.3::  Task Dependence - Termination of Tasks
* 9.4::  Protected Units and Protected Objects
* 9.5::  Intertask Communication
* 9.6::  Delay Statements, Duration, and Time
* 9.7::  Select Statements
* 9.8::  Abort of a Task - Abort of a Sequence of Statements
* 9.9::  Task and Entry Attributes
* 9.10:: Shared Variables
* 9.11:: Example of Tasking and Synchronization

 --- The Detailed Node Listing ---

* 9.1::   Task Units and Task Objects
* 9.2::   Task Execution - Task Activation
* 9.3::   Task Dependence - Termination of Tasks
* 9.4::   Protected Units and Protected Objects
* 9.5::   Intertask Communication
* 9.5.1:: Protected Subprograms and Protected Actions
* 9.5.2:: Entries and Accept Statements
* 9.5.3:: Entry Calls
* 9.5.4:: Requeue Statements
* 9.6::   Delay Statements, Duration, and Time
* 9.7::   Select Statements
* 9.7.1:: Selective Accept
* 9.7.2:: Timed Entry Calls
* 9.7.3:: Conditional Entry Calls
* 9.7.4:: Asynchronous Transfer of Control
* 9.8::   Abort of a Task - Abort of a Sequence of Statements
* 9.9::   Task and Entry Attributes
* 9.10::  Shared Variables
* 9.11::  Example of Tasking and Synchronization
@end menu

@c ---------------------------------------------------------------------------
@node 9.1, 9.2, 9, 9
@section Task Units and Task Objects

@enumerate
@item
A task unit is declared by a task declaration, which has a corresponding
task_body. A task declaration may be a task_type_declaration, in which
case it declares a named task type; alternatively, it may be a
single_task_declaration, in which case it defines an anonymous task
type, as well as declaring a named task object of that type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
task_type_declaration ::=
   task type defining_identifier [known_discriminant_part]
     [is task_definition];
@end example

@item
@example
single_task_declaration ::=
   task defining_identifier [is task_definition];
@end example

@item
@example
task_definition ::=
      @{task_item@}
   [ private
      @{task_item@}]
   end [task_identifier]
@end example

@item
@example
task_item ::= entry_declaration | representation_clause
@end example

@item
@example
task_body ::=
   task body defining_identifier is
      declarative_part
   begin
      handled_sequence_of_statements
   end [task_identifier];
@end example

@enumerate 7
@item
If a task_identifier appears at the end of a task_definition or
task_body, it shall repeat the defining_identifier.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 8
@item
A task declaration requires a completion, which shall be a task_body,
and every task_body shall be the completion of some task declaration.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A task_definition defines a task type and its first subtype. The first
list of task_items of a task_definition, together with the
known_discriminant_part, if any, is called the visible part of the task
unit. The optional list of task_items after the reserved word private is
called the private part of the task unit.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a task declaration elaborates the task_definition.
The elaboration of a single_task_declaration also creates an object of
an (anonymous) task type.

@item
The elaboration of a task_definition creates the task type and its first
subtype; it also includes the elaboration of the entry_declarations in
the given order.

@item
As part of the initialization of a task object, any
representation_clauses and any per-object constraints associated with
entry_declarations of the corresponding task_definition are elaborated
in the given order.

@item
The elaboration of a task_body has no effect other than to establish
that tasks of the type can from then on be activated without failing the
Elaboration_Check.

@item
The execution of a task_body is invoked by the activation of a task of
the corresponding type, see @ref{9.2}.

@item
The content of a task object of a given task type includes:

@enumerate 16
@item
The values of the discriminants of the task object, if any;

@item
An entry queue for each entry of the task object;

@item
A representation of the state of the associated task.

@end enumerate
@end enumerate
@enumerate 19

NOTES

@item
(2) Within the declaration or body of a task unit, the name of the task
unit denotes the current instance of the unit, see @ref{8.6}, rather than
the first subtype of the corresponding task type (and thus the name
cannot be used as a subtype_mark).

@item
(3) The notation of a selected_component can be used to denote a
discriminant of a task, see @ref{4.1.3}. Within a task unit, the name of a
discriminant of the task type denotes the corresponding discriminant of
the current instance of the unit.

@item
(4) A task type is a limited type, see @ref{7.5}, and hence has neither an
assignment operation nor predefined equality operators. If an
application needs to store and exchange task identities, it can do so by
defining an access type designating the corresponding task objects and
by using access values for identification purposes. Assignment is
available for such an access type as for any access type. Alternatively,
if the implementation supports the Systems Programming Annex, the
Identity attribute can be used for task identification, see @ref{C.7}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of declarations of task types:

@item
@example
task type Server is
   entry Next_Work_Item(WI : in Work_Item);
   entry Shut_Down;
end Server;
@end example

@item
@example
task type Keyboard_Driver(ID : Keyboard_ID := New_ID) is
   entry Read (C : out Character);
   entry Write(C : in  Character);
end Keyboard_Driver;
@end example

@item
Examples of declarations of single tasks:

@item
@example
task Controller is
   entry Request(Level)(D : Item);  --  a family of entries
end Controller;
@end example

@item
@example
task Parser is
   entry Next_Lexeme(L : in  Lexical_Element);
   entry Next_Action(A : out Parser_Action);
end;
@end example

@item
@example
task User;  --  has no entries
@end example

@item
Examples of task objects:

@item
@example
Agent    : Server;
Teletype : Keyboard_Driver(TTY_ID);
Pool     : array(1 .. 10) of Keyboard_Driver;
@end example

@item
Example of access type designating task objects:

@item
@example
type Keyboard is access Keyboard_Driver;
Terminal : Keyboard := new Keyboard_Driver(Term_ID);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.2, 9.3, 9.1, 9
@section Task Execution - Task Activation

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate
@item
The execution of a task of a given task type consists of the execution
of the corresponding task_body. The initial part of this execution is
called the activation of the task; it consists of the elaboration of the
declarative_part of the task_body. Should an exception be propagated by
the elaboration of its declarative_part, the activation of the task is
defined to have failed, and it becomes a completed task.

@item
A task object (which represents one task) can be created either as part
of the elaboration of an object_declaration occurring immediately within
some declarative region, or as part of the evaluation of an allocator.
All tasks created by the elaboration of object_declarations of a single
declarative region (including subcomponents of the declared objects) are
activated together. Similarly, all tasks created by the evaluation of a
single allocator are activated together. The activation of a task is
associated with the innermost allocator or object_declaration that is
responsible for its creation.

@item
For tasks created by the elaboration of object_declarations of a given
declarative region, the activations are initiated within the context of
the handled_sequence_of_statements (and its associated
exception_handlers if any --  see @ref{11.2}, just prior to executing the
statements of the _sequence. For a package without an explicit body or
an explicit handled_sequence_of_statements, an implicit body or an
implicit null_statement is assumed, as defined in @ref{7.2}.

@item
For tasks created by the evaluation of an allocator, the activations are
initiated as the last step of evaluating the allocator, after completing
any initialization for the object created by the allocator, and prior to
returning the new access value.

@item
The task that created the new tasks and initiated their activations (the
activator) is blocked until all of these activations complete
(successfully or not). Once all of these activations are complete, if
the activation of any of the tasks has failed (due to the propagation of
an exception), Tasking_Error is raised in the activator, at the place at
which it initiated the activations. Otherwise, the activator proceeds
with its execution normally. Any tasks that are aborted prior to
completing their activation are ignored when determining whether to
raise Tasking_Error.

@item
Should the task that created the new tasks never reach the point where
it would initiate the activations (due to an abort or the raising of an
exception), the newly created tasks become terminated and are never
activated.

NOTES

@item
(5) An entry of a task can be called before the task has been activated.

@item
(6) If several tasks are activated together, the execution of any of
these tasks need not await the end of the activation of the other tasks.

@item
(7) A task can become completed during its activation either because of
an exception or because it is aborted, see @ref{9.8}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of task activation:

@item
@example
procedure P is
   A, B : Server;    --  elaborate the task objects A, B
   C    : Server;    --  elaborate the task object C
begin
   --  the tasks A, B, C are activated together
   --  before the first statement
   ...
end;
@end example
@end enumerate


@c ---------------------------------------------------------------------------
@node 9.3, 9.4, 9.2, 9
@section Task Dependence - Termination of Tasks

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate
@item
Each task (other than an environment task --  see @ref{10.2}, depends on one
or more masters, see @ref{7.6.1}, as follows:

@enumerate 2
@item
If the task is created by the evaluation of an allocator for a given
access type, it depends on each master that includes the elaboration of
the declaration of the ultimate ancestor of the given access type.

@item
If the task is created by the elaboration of an object_declaration, it
depends on each master that includes this elaboration.
@end enumerate
@end enumerate

@enumerate 4
@item
Furthermore, if a task depends on a given master, it is defined to
depend on the task that executes the master, and (recursively) on any
master of that task.

@item
A task is said to be completed when the execution of its corresponding
task_body is completed. A task is said to be terminated when any
finalization of the task_body has been performed, see @ref{7.6.1}. The
first step of finalizing a master (including a task_body) is to wait for
the termination of any tasks dependent on the master. The task executing
the master is blocked until all the dependents have terminated. Any
remaining finalization is then performed and the master is left.

@item
Completion of a task (and the corresponding task_body) can occur when
the task is blocked at a select_statement with an an open
terminate_alternative, see @ref{9.7.1}, the open terminate_alternative is
selected if and only if the following conditions are satisfied:

@enumerate 7
@item
The task depends on some completed master;

@item
Each task that depends on the master considered is either already
terminated or similarly blocked at a select_statement with an open
terminate_alternative.
@end enumerate
@end enumerate

@enumerate 9
@item
When both conditions are satisfied, the task considered becomes
completed, together with all tasks that depend on the master considered
that are not yet completed.

NOTES

@item
(8) The full view of a limited private type can be a task type, or can
have subcomponents of a task type. Creation of an object of such a type
creates dependences according to the full type.

@item
(9) An object_renaming_declaration defines a new view of an existing
entity and hence creates no further dependence.

@item
(10) The rules given for the collective completion of a group of tasks
all blocked on select_statements with open terminate_alternatives ensure
that the collective completion can occur only when there are no
remaining active tasks that could call one of the tasks being
collectively completed.

@item
(11) If two or more tasks are blocked on select_statements with open
terminate_alternatives, and become completed collectively, their
finalization actions proceed concurrently.

@item
(12) The completion of a task can occur due to any of the following:

@enumerate 15
@item
the raising of an exception during the elaboration of the
declarative_part of the corresponding task_body;

@item
the completion of the handled_sequence_of_statements of the
corresponding task_body;

@item
the selection of an open terminate_alternative of a select_statement in
the corresponding task_body;

@item
the abort of the task.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Examples}

@enumerate 19
@item
Example of task dependence:

@item
@example
declare
   type Global is access Server; --  see @ref{9.1}
   A, B : Server;
   G    : Global;
begin
   --  activation of A and B
   declare
      type Local is access Server;
      X : Global := new Server;  --  activation of X.all
      L : Local  := new Server;  --  activation of L.all
      C : Server;
   begin
      --  activation of C
      G := X;  --  both G and X designate the same task object
      ...
   end;  --  await termination of C and L.all (but not X.all)
   ...
end;  --  await termination of A, B, and G.all
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.4, 9.5, 9.3, 9
@section Protected Units and Protected Objects

@enumerate
@item
A protected object provides coordinated access to shared data, through
calls on its visible protected operations, which can be protected
subprograms or protected entries. A protected unit is declared by a
protected declaration, which has a corresponding protected_body. A
protected declaration may be a protected_type_declaration, in which case
it declares a named protected type; alternatively, it may be a
single_protected_declaration, in which case it defines an anonymous
protected type, as well as declaring a named protected object of that
type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
protected_type_declaration ::=
   protected type defining_identifier [known_discriminant_part] is
     protected_definition;
@end example

@item
@example
single_protected_declaration ::=
   protected defining_identifier is protected_definition;
@end example

@item
@example
protected_definition ::=
      @{ protected_operation_declaration @}
   [ private
      @{ protected_element_declaration @} ]
   end [protected_identifier]
@end example

@item
@example
protected_operation_declaration ::=
     subprogram_declaration
   | entry_declaration
   | representation_clause
@end example

@item
@example
protected_element_declaration ::=
   protected_operation_declaration | component_declaration
@end example

@item
@example
protected_body ::=
   protected body defining_identifier is
      @{ protected_operation_item @}
   end [protected_identifier];
@end example

@item
@example
protected_operation_item ::=
     subprogram_declaration
   | subprogram_body
   | entry_body
   | representation_clause
@end example

@enumerate 9
@item
If a protected_identifier appears at the end of a protected_definition
or protected_body, it shall repeat the defining_identifier.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 10
@item
A protected declaration requires a completion, which shall be a
protected_body, and every protected_body shall be the completion of some
protected declaration.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A protected_definition defines a protected type and its first subtype.
The list of protected_operation_declarations of a protected_definition,
together with the known_discriminant_part, if any, is called the visible
part of the protected unit. The optional list of
protected_element_declarations after the reserved word private is called
the private part of the protected unit.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a protected declaration elaborates the
protected_definition. The elaboration of a single_protected_declaration
also creates an object of an (anonymous) protected type.

@item
The elaboration of a protected_definition creates the protected type and
its first subtype; it also includes the elaboration of the
component_declarations and protected_operation_declarations in the given
order.

@item
As part of the initialization of a protected object, any per-object
constraints, see @ref{3.8}, are elaborated.

@item
The elaboration of a protected_body has no other effect than to
establish that protected operations of the type can from then on be
called without failing the Elaboration_Check.

@item
The content of an object of a given protected type includes:

@enumerate 17
@item
The values of the components of the protected object, including
(implicitly) an entry queue for each entry declared for the protected
object;

@item
A representation of the state of the execution resource associated with
the protected object (one such resource is associated with each
protected object).
@end enumerate
@end enumerate

@enumerate 19
@item
The execution resource associated with a protected object has to be
acquired to read or update any components of the protected object; it
can be acquired (as part of a protected action --  see @ref{9.5.1}, either
for concurrent read-only access, or for exclusive read-write access.

@item
As the first step of the finalization of a protected object, each call
remaining on any entry queue of the object is removed from its queue and
Program_Error is raised at the place of the corresponding
entry_call_statement.

NOTES

@item
(13) Within the declaration or body of a protected unit, the name of the
protected unit denotes the current instance of the unit, see @ref{8.6},
rather than the first subtype of the corresponding protected type (and
thus the name cannot be used as a subtype_mark).

@item
(14) A selected_component can be used to denote a discriminant of a
protected object, see @ref{4.1.3}. Within a protected unit, the name of a
discriminant of the protected type denotes the corresponding
discriminant of the current instance of the unit.

@item
(15) A protected type is a limited type, see @ref{7.5}, and hence has
neither an assignment operation nor predefined equality operators.

@item
(16) The bodies of the protected operations given in the protected_body
define the actions that take place upon calls to the protected
operations.

@item
(17) The declarations in the private part are only visible within the
private part and the body of the protected unit.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of declaration of protected type and corresponding body:

@item
@example
protected type Resource is
   entry Seize;
   procedure Release;
private
   Busy : Boolean := False;
end Resource;
@end example

@item
@example
protected body Resource is
   entry Seize when not Busy is
   begin
      Busy := True;
   end Seize;
@end example

@item
@example
   procedure Release is
   begin
      Busy := False;
   end Release;
end Resource;
@end example

@item
Example of a single protected declaration and corresponding body:

@item
@example
protected Shared_Array is
   --  Index, Item, and Item_Array are global types
   function  Component    (N : in Index) return Item;
   procedure Set_Component(N : in Index; E : in  Item);
private
   Table : Item_Array(Index) := (others => Null_Item);
end Shared_Array;
@end example

@item
@example
protected body Shared_Array is
   function Component(N : in Index) return Item is
   begin
      return Table(N);
   end Component;
@end example

@item
@example
   procedure Set_Component(N : in Index; E : in Item) is
   begin
      Table(N) := E;
   end Set_Component;
end Shared_Array;
@end example

@item
Examples of protected objects:

@item
@example
Control  : Resource;
Flags    : array(1 .. 100) of Resource;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.5, 9.5.1, 9.4, 9
@section Intertask Communication

@enumerate
@item
The primary means for intertask communication is provided by calls on
entries and protected subprograms. Calls on protected subprograms allow
coordinated access to shared data objects. Entry calls allow for
blocking the caller until a given condition is satisfied (namely, that
the corresponding entry is open --  see @ref{9.5.3}.), and then
communicating data or control information directly with another task or
indirectly via a shared protected object.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Any call on an entry or on a protected subprogram identifies a target
object for the operation, which is either a task (for an entry call) or
a protected object (for an entry call or a protected subprogram call).
The target object is considered an implicit parameter to the operation,
and is determined by the operation name (or prefix) used in the call on
the operation, as follows:

@enumerate 3
@item
If it is a direct_name or expanded name that denotes the declaration (or
body) of the operation, then the target object is implicitly specified
to be the current instance of the task or protected unit immediately
enclosing the operation; such a call is defined to be an internal call;

@item
If it is a selected_component that is not an expanded name, then the
target object is explicitly specified to be the task or protected object
denoted by the prefix of the name; such a call is defined to be an
external call;

@item
If the name or prefix is a dereference (implicit or explicit) of an
access-to-protected-subprogram value, then the target object is
determined by the prefix of the Access attribute_reference that produced
the access value originally, and the call is defined to be an external
call;

@item
If the name or prefix denotes a subprogram_renaming_declaration, then
the target object is as determined by the name of the renamed entity.
@end enumerate
@end enumerate

@enumerate 7
@item
A corresponding definition of target object applies to a
requeue_statement, see @ref{9.5.4}, with a corresponding distinction
between an internal requeue and an external requeue.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Within the body of a protected operation, the current instance
(@pxref{8.6}) of the immediately enclosing protected unit is determined by
the target object specified (implicitly or explicitly) in the call (or
requeue) on the protected operation.

@item
Any call on a protected procedure or entry of a target protected object
is defined to be an update to the object, as is a requeue on such an
entry.
@end enumerate

@menu
* 9.5.1:: Protected Subprograms and Protected Actions
* 9.5.2:: Entries and Accept Statements
* 9.5.3:: Entry Calls
* 9.5.4:: Requeue Statements
@end menu

@c ---------------------------------------------------------------------------
@node 9.5.1, 9.5.2, 9.5, 9.5
@subsection Protected Subprograms and Protected Actions

@enumerate
@item
A protected subprogram is a subprogram declared immediately within a
protected_definition. Protected procedures provide exclusive read-write
access to the data of a protected object; protected functions provide
concurrent read-only access to the data.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Within the body of a protected function (or a function declared
immediately within a protected_body), the current instance of the
enclosing protected unit is defined to be a constant (that is, its
subcomponents may be read but not updated). Within the body of a
protected procedure (or a procedure declared immediately within a
protected_body), and within an entry_body, the current instance is
defined to be a variable (updating is permitted).

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a call on a protected subprogram, the evaluation of
the name or prefix and of the parameter associations, and any assigning
back of in out or out parameters, proceeds as for a normal subprogram
call, see @ref{6.4}. If the call is an internal call, see @ref{9.5}, the body
of the subprogram is executed as for a normal subprogram call. If the
call is an external call, then the body of the subprogram is executed as
part of a new protected action on the target protected object; the
protected action completes after the body of the subprogram is executed.
A protected action can also be started by an entry call, see @ref{9.5.3}.

@item
A new protected action is not started on a protected object while
another protected action on the same protected object is underway,
unless both actions are the result of a call on a protected function.
This rule is expressible in terms of the execution resource associated
with the protected object:

@enumerate 5
@item
Starting a protected action on a protected object corresponds to
acquiring the execution resource associated with the protected object,
either for concurrent read-only access if the protected action is for a
call on a protected function, or for exclusive read-write access
otherwise;

@item
Completing the protected action corresponds to releasing the associated
execution resource.
@end enumerate
@end enumerate

@enumerate 7
@item
After performing an operation on a protected object other than a call on
a protected function, but prior to completing the associated protected
action, the entry queues (if any) of the protected object are serviced
(@pxref{9.5.3}).

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
During a protected action, it is a bounded error to invoke an operation
that is potentially blocking. The following are defined to be
potentially blocking operations:

@enumerate 9
@item
a select_statement;

@item
an accept_statement;

@item
an entry_call_statement;

@item
a delay_statement;

@item
an abort_statement;

@item
task creation or activation;

@item
an external call on a protected subprogram (or an external requeue) with
the same target object as that of the protected action;

@item
a call on a subprogram whose body contains a potentially blocking
operation.
@end enumerate
@end enumerate

@enumerate 17
@item
If the bounded error is detected, Program_Error is raised. If not
detected, the bounded error might result in deadlock or a (nested)
protected action on the same target object.

@item
Certain language-defined subprograms are potentially blocking. In
particular, the subprograms of the language-defined input-output
packages that manipulate files (implicitly or explicitly) are
potentially blocking. Other potentially blocking subprograms are
identified where they are defined. When not specified as potentially
blocking, a language-defined subprogram is nonblocking.

NOTES

@item
(18) If two tasks both try to start a protected action on a protected
object, and at most one is calling a protected function, then only one
of the tasks can proceed. Although the other task cannot proceed, it is
not considered blocked, and it might be consuming processing resources
while it awaits its turn. There is no language-defined ordering or
queuing presumed for tasks competing to start a protected action -- on a
multiprocessor such tasks might use busy-waiting; for monoprocessor
considerations, see @ref{D.3, ``Priority Ceiling Locking''}.

@item
(19) The body of a protected unit may contain declarations and bodies
for local subprograms. These are not visible outside the protected unit.

@item
(20) The body of a protected function can contain internal calls on
other protected functions, but not protected procedures, because the
current instance is a constant. On the other hand, the body of a
protected procedure can contain internal calls on both protected
functions and procedures.

@item
(21) From within a protected action, an internal call on a protected
subprogram, or an external call on a protected subprogram with a
different target object is not considered a potentially blocking
operation.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of protected subprogram calls, see @ref{9.4}

@item
@example
Shared_Array.Set_Component(N, E);
E := Shared_Array.Component(M);
Control.Release;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.5.2, 9.5.3, 9.5.1, 9.5
@subsection Entries and Accept Statements

@enumerate
@item
Entry_declarations, with the corresponding entry_bodies or
accept_statements, are used to define potentially queued operations on
tasks and protected objects.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
entry_declaration ::=
   entry defining_identifier [(discrete_subtype_definition)]
     parameter_profile;
@end example

@item
@example
accept_statement ::=
   accept entry_direct_name [(entry_index)] parameter_profile
      [do handled_sequence_of_statements
   end [entry_identifier]];
@end example

@item
@example
entry_index ::= expression
@end example

@item
@example
entry_body ::=
   entry defining_identifier entry_body_formal_part entry_barrier is
      declarative_part
   begin
      handled_sequence_of_statements
   end [entry_identifier];
@end example

@item
@example
entry_body_formal_part ::=
   [(entry_index_specification)] parameter_profile
@end example

@item
@example
entry_barrier ::= when condition
@end example

@item
@example
entry_index_specification ::=
   for defining_identifier in discrete_subtype_definition
@end example

@enumerate 9
@item
If an entry_identifier appears at the end of an accept_statement, it
shall repeat the entry_direct_name. If an entry_identifier appears at
the end of an entry_body, it shall repeat the defining_identifier.

@item
An entry_declaration is allowed only in a protected or task declaration.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 11
@item
In an accept_statement, the expected profile for the entry_direct_name
is that of the entry_declaration; the expected type for an entry_index
is that of the subtype defined by the discrete_subtype_definition of the
corresponding entry_declaration.

@item
Within the handled_sequence_of_statements of an accept_statement, if a
selected_component has a prefix that denotes the corresponding
entry_declaration, then the entity denoted by the prefix is the
accept_statement, and the selected_component is interpreted as an
expanded name, see @ref{4.1.3}, the selector_name of the selected_component
has to be the identifier for some formal parameter of the
accept_statement.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An entry_declaration in a task declaration shall not contain a
specification for an access parameter, see @ref{3.10}.

@item
For an accept_statement, the innermost enclosing body shall be a
task_body, and the entry_direct_name shall denote an entry_declaration
in the corresponding task declaration; the profile of the
accept_statement shall conform fully to that of the corresponding
entry_declaration. An accept_statement shall have a parenthesized
entry_index if and only if the corresponding entry_declaration has a
discrete_subtype_definition.

@item
An accept_statement shall not be within another accept_statement that
corresponds to the same entry_declaration, nor within an
asynchronous_select inner to the enclosing task_body.

@item
An entry_declaration of a protected unit requires a completion, which
shall be an entry_body, and every entry_body shall be the completion of
an entry_declaration of a protected unit. The profile of the entry_body
shall conform fully to that of the corresponding declaration.

@item
An entry_body_formal_part shall have an entry_index_specification if and
only if the corresponding entry_declaration has a
discrete_subtype_definition. In this case, the
discrete_subtype_definitions of the entry_declaration and the
entry_index_specification shall fully conform to one another
(@pxref{6.3.1}).

@item
A name that denotes a formal parameter of an entry_body is not allowed
within the entry_barrier of the entry_body.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The parameter modes defined for parameters in the parameter_profile of
an entry_declaration are the same as for a subprogram_declaration and
have the same meaning, see @ref{6.2}.

@item
An entry_declaration with a discrete_subtype_definition, see @ref{3.6},
declares a family of distinct entries having the same profile, with one
such entry for each value of the entry index subtype defined by the
discrete_subtype_definition. A name for an entry of a family takes the
form of an indexed_component, where the prefix denotes the
entry_declaration for the family, and the index value identifies the
entry within the family. The term single entry is used to refer to any
entry other than an entry of an entry family.

@item
In the entry_body for an entry family, the entry_index_specification
declares a named constant whose subtype is the entry index subtype
defined by the corresponding entry_declaration; the value of the named
entry index identifies which entry of the family was called.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the elaboration of an entry_declaration for an entry family, if the
discrete_subtype_definition contains no per-object expressions
(@pxref{3.8}) then the discrete_subtype_definition is elaborated.
Otherwise, the elaboration of the entry_declaration consists of the
evaluation of any expression of the discrete_subtype_definition that is
not a per-object expression (or part of one). The elaboration of an
entry_declaration for a single entry has no effect.

@item
The actions to be performed when an entry is called are specified by the
corresponding accept_statements (if any) for an entry of a task unit,
and by the corresponding entry_body for an entry of a protected unit.

@item
For the execution of an accept_statement, the entry_index, if any, is
first evaluated and converted to the entry index subtype; this index
value identifies which entry of the family is to be accepted. Further
execution of the accept_statement is then blocked until a caller of the
corresponding entry is selected, see @ref{9.5.3}, whereupon the
handled_sequence_of_statements, if any, of the accept_statement is
executed, with the formal parameters associated with the corresponding
actual parameters of the selected entry call. Upon completion of the
handled_sequence_of_statements, the accept_statement completes and is
left. When an exception is propagated from the
handled_sequence_of_statements of an accept_statement, the same
exception is also raised by the execution of the corresponding
entry_call_statement.

@item
The above interaction between a calling task and an accepting task is
called a rendezvous. After a rendezvous, the two tasks continue their
execution independently.

@item
An entry_body is executed when the condition of the entry_barrier
evaluates to True and a caller of the corresponding single entry, or
entry of the corresponding entry family, has been selected
(@pxref{9.5.3}). For the execution of the entry_body, the declarative_part
of the entry_body is elaborated, and the handled_sequence_of_statements
of the body is executed, as for the execution of a subprogram_body. The
value of the named entry index, if any, is determined by the value of
the entry index specified in the entry_name of the selected entry call
(or intermediate requeue_statement --  see @ref{9.5.4}.

NOTES

@item
(22) A task entry has corresponding accept_statements (zero or more),
whereas a protected entry has a corresponding entry_body (exactly one).

@item
(23) A consequence of the rule regarding the allowed placements of
accept_statements is that a task can execute accept_statements only for
its own entries.

@item
(24) A return_statement, see @ref{6.5}, or a requeue_statement
(@pxref{9.5.4}) may be used to complete the execution of an
accept_statement or an entry_body.

@item
(25) The condition in the entry_barrier may reference anything visible
except the formal parameters of the entry. This includes the entry index
(if any), the components (including discriminants) of the protected
object, the Count attribute of an entry of that protected object, and
data global to the protected unit.

@item
The restriction against referencing the formal parameters within an
entry_barrier ensures that all calls of the same entry see the same
barrier value. If it is necessary to look at the parameters of an entry
call before deciding whether to handle it, the entry_barrier can be
``when True'' and the caller can be requeued (on some private entry)
when its parameters indicate that it cannot be handled immediately.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of entry declarations:

@item
@example
entry Read(V : out Item);
entry Seize;
entry Request(Level)(D : Item);  --  a family of entries
@end example

@item
Examples of accept statements:

@item
@example
accept Shut_Down;
@end example

@item
@example
accept Read(V : out Item) do
   V := Local_Item;
end Read;
@end example

@item
@example
accept Request(Low)(D : Item) do
   ...
end Request;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.5.3, 9.5.4, 9.5.2, 9.5
@subsection Entry Calls

@enumerate
@item
An entry_call_statement (an entry call) can appear in various contexts.
A simple entry call is a stand-alone statement that represents an
unconditional call on an entry of a target task or a protected object.
Entry calls can also appear as part of select_statements, see @ref{9.7}.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
entry_call_statement ::= entry_name [actual_parameter_part];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The entry_name given in an entry_call_statement shall resolve to denote
an entry. The rules for parameter associations are the same as for
subprogram calls, see @ref{6.4}, and @ref{6.4.1}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The entry_name of an entry_call_statement specifies (explicitly or
implicitly) the target object of the call, the entry or entry family,
and the entry index, if any, see @ref{9.5}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Under certain circumstances (detailed below), an entry of a task or
protected object is checked to see whether it is open or closed:

@enumerate 6
@item
An entry of a task is open if the task is blocked on an accept_statement
that corresponds to the entry, see @ref{9.5.2}, or on a selective_accept,
(see @ref{9.7.1}) with an open accept_alternative that corresponds to the
entry; otherwise it is closed.

@item
An entry of a protected object is open if the condition of the
entry_barrier of the corresponding entry_body evaluates to True;
otherwise it is closed. If the evaluation of the condition propagates an
exception, the exception Program_Error is propagated to all current
callers of all entries of the protected object.
@end enumerate
@end enumerate

@enumerate 8
@item
For the execution of an entry_call_statement, evaluation of the name and
of the parameter associations is as for a subprogram call, see @ref{6.4}.
The entry call is then issued: For a call on an entry of a protected
object, a new protected action is started on the object, see @ref{9.5.1}.
The named entry is checked to see if it is open; if open, the entry call
is said to be selected immediately, and the execution of the call
proceeds as follows:

@enumerate 9
@item
For a call on an open entry of a task, the accepting task becomes ready
and continues the execution of the corresponding accept_statement
(@pxref{9.5.2}).

@item
For a call on an open entry of a protected object, the corresponding
entry_body is executed, see @ref{9.5.2}, as part of the protected action.
@end enumerate
@end enumerate

@enumerate 11
@item
If the accept_statement or entry_body completes other than by a requeue
(@pxref{9.5.4}) return is made to the caller (after servicing the entry
queues -- see below); any necessary assigning back of formal to actual
parameters occurs, as for a subprogram call, see @ref{6.4.1}, such
assignments take place outside of any protected action.

@item
If the named entry is closed, the entry call is added to an entry queue
(as part of the protected action, for a call on a protected entry), and
the call remains queued until it is selected or cancelled; there is a
separate (logical) entry queue for each entry of a given task or
protected object (including each entry of an entry family).

@item
When a queued call is selected, it is removed from its entry queue.
Selecting a queued call from a particular entry queue is called
servicing the entry queue. An entry with queued calls can be serviced
under the following circumstances:

@enumerate 14
@item
When the associated task reaches a corresponding accept_statement, or a
selective_accept with a corresponding open accept_alternative;

@item
If after performing, as part of a protected action on the associated
protected object, an operation on the object other than a call on a
protected function, the entry is checked and found to be open.
@end enumerate
@end enumerate

@enumerate 16
@item
If there is at least one call on a queue corresponding to an open entry,
then one such call is selected according to the entry queuing policy in
effect (see below), and the corresponding accept_statement or entry_body
is executed as above for an entry call that is selected immediately.

@item
The entry queuing policy controls selection among queued calls both for
task and protected entry queues. The default entry queuing policy is to
select calls on a given entry queue in order of arrival. If calls from
two or more queues are simultaneously eligible for selection, the
default entry queuing policy does not specify which queue is serviced
first. Other entry queuing policies can be specified by pragmas
(@pxref{D.4}).

@item
For a protected object, the above servicing of entry queues continues
until there are no open entries with queued calls, at which point the
protected action completes.

@item
For an entry call that is added to a queue, and that is not the
triggering_statement of an asynchronous_select, see @ref{9.7.4}, the
calling task is blocked until the call is cancelled, or the call is
selected and a corresponding accept_statement or entry_body completes
without requeuing. In addition, the calling task is blocked during a
rendezvous.

@item
An attempt can be made to cancel an entry call upon an abort
(@pxref{9.8}) and as part of certain forms of select_statement,
see @ref{9.7.2}, @ref{9.7.3}, and @ref{9.7.4}. The cancellation does not
take place until a point (if any) when the call is on some entry queue,
and not protected from cancellation as part of a requeue, see @ref{9.5.4},
at such a point, the call is removed from the entry queue and the call
completes due to the cancellation. The cancellation of a call on an
entry of a protected object is a protected action, and as such cannot
take place while any other protected action is occurring on the
protected object. Like any protected action, it includes servicing of
the entry queues (in case some entry barrier depends on a Count
attribute).

@item
A call on an entry of a task that has already completed its execution
raises the exception Tasking_Error at the point of the call; similarly,
this exception is raised at the point of the call if the called task
completes its execution or becomes abnormal before accepting the call or
completing the rendezvous, see @ref{9.8}. This applies equally to a simple
entry call and to an entry call as part of a select_statement.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may perform the sequence of steps of a protected
action using any thread of control; it need not be that of the task that
started the protected action. If an entry_body completes without
requeuing, then the corresponding calling task may be made ready without
waiting for the entire protected action to complete.

@item
When the entry of a protected object is checked to see whether it is
open, the implementation need not reevaluate the condition of the
corresponding entry_barrier if no variable or attribute referenced by
the condition (directly or indirectly) has been altered by the execution
(or cancellation) of a protected procedure or entry call on the object
since the condition was last evaluated.

@item
An implementation may evaluate the conditions of all entry_barriers of a
given protected object any time any entry of the object is checked to
see if it is open.

@item
When an attempt is made to cancel an entry call, the implementation need
not make the attempt using the thread of control of the task (or
interrupt) that initiated the cancellation; in particular, it may use
the thread of control of the caller itself to attempt the cancellation,
even if this might allow the entry call to be selected in the interim.

NOTES

@item
(26) If an exception is raised during the execution of an entry_body, it
is propagated to the corresponding caller, see @ref{11.4}.

@item
(27) For a call on a protected entry, the entry is checked to see if it
is open prior to queuing the call, and again thereafter if its Count
attribute, see @ref{9.9}, is referenced in some entry barrier.

@item
(28) In addition to simple entry calls, the language permits timed,
conditional, and asynchronous entry calls, see @ref{9.7.2}, see @ref{9.7.3},
and @ref{9.7.4}.

@item
(29) The condition of an entry_barrier is allowed to be evaluated by an
implementation more often than strictly necessary, even if the
evaluation might have side effects. On the other hand, an implementation
need not reevaluate the condition if nothing it references was updated
by an intervening protected action on the protected object, even if the
condition references some global variable that might have been updated
by an action performed from outside of a protected action.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of entry calls:

@item
@example
Agent.Shut_Down;                     --  see @ref{9.1}
Parser.Next_Lexeme(E);               --  see @ref{9.1}
Pool(5).Read(Next_Char);             --  see @ref{9.1}
Controller.Request(Low)(Some_Item);  --  see @ref{9.1}
Flags(3).Seize;                      --  see @ref{9.4}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.5.4, 9.6, 9.5.3, 9.5
@subsection Requeue Statements

@enumerate
@item
A requeue_statement can be used to complete an accept_statement or
entry_body, while redirecting the corresponding entry call to a new (or
the same) entry queue. Such a requeue can be performed with or without
allowing an intermediate cancellation of the call, due to an abort or
the expiration of a delay.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
requeue_statement ::= requeue entry_name [with abort];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The entry_name of a requeue_statement shall resolve to denote an entry
(the target entry) that either has no parameters, or that has a profile
that is type conformant, see @ref{6.3.1}, with the profile of the innermost
enclosing entry_body or accept_statement.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A requeue_statement shall be within a callable construct that is either
an entry_body or an accept_statement, and this construct shall be the
innermost enclosing body or callable construct.

@item
If the target entry has parameters, then its profile shall be subtype
conformant with the profile of the innermost enclosing callable
construct.

@item
In a requeue_statement of an accept_statement of some task unit, either
the target object shall be a part of a formal parameter of the
accept_statement, or the accessibility level of the target object shall
not be equal to or statically deeper than any enclosing accept_statement
of the task unit. In a requeue_statement of an entry_body of some
protected unit, either the target object shall be a part of a formal
parameter of the entry_body, or the accessibility level of the target
object shall not be statically deeper than that of the
entry_declaration. Dynamic Semantics

@item
The execution of a requeue_statement proceeds by first evaluating the
entry_name, including the prefix identifying the target task or
protected object and the expression identifying the entry within an
entry family, if any. The entry_body or accept_statement enclosing the
requeue_statement is then completed, finalized, and left, see @ref{7.6.1}.

@item
For the execution of a requeue on an entry of a target task, after
leaving the enclosing callable construct, the named entry is checked to
see if it is open and the requeued call is either selected immediately
or queued, as for a normal entry call, see @ref{9.5.3}.

@item
For the execution of a requeue on an entry of a target protected object,
after leaving the enclosing callable construct:

@enumerate 10
@item
if the requeue is an internal requeue (that is, the requeue is back on
an entry of the same protected object --  see @ref{9.5}.), the call is added
to the queue of the named entry and the ongoing protected action
continues, see @ref{9.5.1};

@item
if the requeue is an external requeue (that is, the target protected
object is not implicitly the same as the current object --  see @ref{9.5}.),
a protected action is started on the target object and proceeds as for a
normal entry call, see @ref{9.5.3}.
@end enumerate
@end enumerate

@enumerate 12
@item
If the new entry named in the requeue_statement has formal parameters,
then during the execution of the accept_statement or entry_body
corresponding to the new entry, the formal parameters denote the same
objects as did the corresponding formal parameters of the callable
construct completed by the requeue. In any case, no parameters are
specified in a requeue_statement; any parameter passing is implicit.

@item
If the requeue_statement includes the reserved words with abort (it is a
requeue-with-abort), then:

@enumerate 14
@item
if the original entry call has been aborted, see @ref{9.8}, then the
requeue acts as an abort completion point for the call, and the call is
cancelled and no requeue is performed;

@item
if the original entry call was timed (or conditional), then the original
expiration time is the expiration time for the requeued call.
@end enumerate
@end enumerate

@enumerate 16
@item
If the reserved words with abort do not appear, then the call remains
protected against cancellation while queued as the result of the
requeue_statement.

NOTES

@item
(30) A requeue is permitted from a single entry to an entry of an entry
family, or vice-versa. The entry index, if any, plays no part in the
subtype conformance check between the profiles of the two entries; an
entry index is part of the entry_name for an entry of a family.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of requeue statements:

@item
@example
requeue Request(Medium) with abort;
--  requeue on a member of an entry family
--  of the current task, see @ref{9.1}
@end example

@item
@example
requeue Flags(I).Seize;
--  requeue on an entry of an array
--  component, see @ref{9.4}
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.6, 9.7, 9.5.4, 9
@section Delay Statements, Duration, and Time

@enumerate
@item
A delay_statement is used to block further execution until a specified
expiration time is reached. The expiration time can be specified either
as a particular point in time (in a delay_until_statement), or in
seconds from the current time (in a delay_relative_statement). The
language-defined package Calendar provides definitions for a type Time
and associated operations, including a function Clock that returns the
current time.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
delay_statement ::= delay_until_statement | delay_relative_statement
@end example

@item
@example
delay_until_statement ::= delay until delay_expression;
@end example

@item
@example
delay_relative_statement ::= delay delay_expression;
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for the delay_expression in a delay_relative_statement
is the predefined type Duration. The delay_expression in a
delay_until_statement is expected to be of any nonlimited type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
There can be multiple time bases, each with a corresponding clock, and a
corresponding time type. The type of the delay_expression in a
delay_until_statement shall be a time type -- either the type Time
defined in the language-defined package Calendar (see below), or some
other implementation-defined time type, see @ref{D.8}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
There is a predefined fixed point type named Duration, declared in the
visible part of package Standard; a value of type Duration is used to
represent the length of an interval of time, expressed in seconds. The
type Duration is not specific to a particular time base, but can be used
with any time base.

@item
A value of the type Time in package Calendar, or of some other
implementation-defined time type, represents a time as reported by a
corresponding clock.

@item
The following language-defined library package exists:

@item
@example
package Ada.Calendar is
  type Time is private;
@end example

@item
@example
  subtype Year_Number  is Integer range 1901 ..  2099;
  subtype Month_Number is Integer range 1 ..  12;
  subtype Day_Number   is Integer range 1 ..  31;
  subtype Day_Duration is Duration range 0.0 ..  86_400.0;
@end example

@item
@example
  function Clock return Time;
@end example

@item
@example
  function Year   (Date : Time) return Year_Number;
  function Month  (Date : Time) return Month_Number;
  function Day    (Date : Time) return Day_Number;
  function Seconds(Date : Time) return Day_Duration;
@end example

@item
@example
  procedure Split (Date  : in Time;
                   Year    : out Year_Number;
                   Month   : out Month_Number;
                   Day     : out Day_Number;
                   Seconds : out Day_Duration);
@end example

@item
@example
  function Time_Of(Year  : Year_Number;
                   Month   : Month_Number;
                   Day     : Day_Number;
                   Seconds : Day_Duration := 0.0)
   return Time;
@end example

@item
@example
  function "+" (Left : Time;   Right : Duration) return Time;
  function "+" (Left : Duration; Right : Time) return Time;
  function "-" (Left : Time;   Right : Duration) return Time;
  function "-" (Left : Time;   Right : Time) return Duration;
@end example

@item
@example
  function "<" (Left, Right : Time) return Boolean;
  function "<="(Left, Right : Time) return Boolean;
  function ">" (Left, Right : Time) return Boolean;
  function ">="(Left, Right : Time) return Boolean;
@end example

@item
@example
  Time_Error : exception;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Calendar;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a delay_statement, the delay_expression is first
evaluated. For a delay_until_statement, the expiration time for the
delay is the value of the delay_expression, in the time base associated
with the type of the expression. For a delay_relative_statement, the
expiration time is defined as the current time, in the time base
associated with relative delays, plus the value of the delay_expression
converted to the type Duration, and then rounded up to the next clock
tick. The time base associated with relative delays is as defined in
@ref{D.9, ``Delay Accuracy''}, or is implementation defined.

@item
The task executing a delay_statement is blocked until the expiration
time is reached, at which point it becomes ready again. If the
expiration time has already passed, the task is not blocked.

@item
If an attempt is made to cancel the delay_statement (as part of an
asynchronous_select or abort --  see @ref{9.7.4}, and @ref{9.8}, the
_statement is cancelled if the expiration time has not yet passed,
thereby completing the delay_statement.

@item
The time base associated with the type Time of package Calendar is
implementation defined. The function Clock of package Calendar returns a
value representing the current time for this time base. The
implementation-defined value of the named number System.Tick
(@pxref{13.7}) is an approximation of the length of the real-time interval
during which the value of Calendar.Clock remains constant.

@item
The functions Year, Month, Day, and Seconds return the corresponding
values for a given value of the type Time, as appropriate to an
implementation-defined timezone; the procedure Split returns all four
corresponding values. Conversely, the function Time_Of combines a year
number, a month number, a day number, and a duration, into a value of
type Time. The operators "+" and "-" for addition and subtraction of
times and durations, and the relational operators for times, have the
conventional meaning.

@item
If Time_Of is called with a seconds value of 86_400.0, the value
returned is equal to the value of Time_Of for the next day with a
seconds value of 0.0. The value returned by the function Seconds or
through the Seconds parameter of the procedure Split is always less than
86_400.0.

@item
The exception Time_Error is raised by the function Time_Of if the actual
parameters do not form a proper date. This exception is also raised by
the operators "+" and "-" if the result is not representable in the type
Time or Duration, as appropriate. This exception is also raised by the
function Year or the procedure Split if the year number of the given
date is outside of the range of the subtype Year_Number.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation of the type Duration shall allow representation of
time intervals (both positive and negative) up to at least 86400 seconds
(one day); Duration'Small shall not be greater than twenty milliseconds.
The implementation of the type Time shall allow representation of all
dates with year numbers in the range of Year_Number; it may allow
representation of other dates as well (both earlier and later).

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may define additional time types, see @ref{D.8}.

@item
An implementation may raise Time_Error if the value of a
delay_expression in a delay_until_statement of a select_statement
represents a time more than 90 days past the current time. The actual
limit, if any, is implementation-defined.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Whenever possible in an implementation, the value of Duration'Small
should be no greater than 100 microseconds.

@item
The time base for delay_relative_statements should be monotonic; it need
not be the same time base as used for Calendar.Clock.

NOTES

@item
(31) A delay_relative_statement with a negative value of the
delay_expression is equivalent to one with a zero value.

@item
(32) A delay_statement may be executed by the environment task;
consequently delay_statements may be executed as part of the elaboration
of a library_item or the execution of the main subprogram. Such
statements delay the environment task, see @ref{10.2}.

@item
(33) A delay_statement is an abort completion point and a potentially
blocking operation, even if the task is not actually blocked.

@item
(34) There is no necessary relationship between System.Tick (the
resolution of the clock of package Calendar) and Duration'Small (the
small of type Duration).

@item
(35) Additional requirements associated with delay_statements are given
in @ref{D.9, ``Delay Accuracy''}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a relative delay statement:

@item
@example
delay 3.0;  -- delay 3.0 seconds
@end example

@item
Example of a periodic task:

@item
@example
declare
   use Ada.Calendar;
   Next_Time : Time := Clock + Period;
                      -- Period is a global constant of type Duration
begin
   loop               -- repeated every Period seconds
      delay until Next_Time;
      ... -- perform some actions
      Next_Time := Next_Time + Period;
   end loop;
end;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.7, 9.7.1, 9.6, 9
@section Select Statements

@enumerate
@item
There are four forms of the select_statement. One form provides a
selective wait for one or more select_alternatives. Two provide timed
and conditional entry calls. The fourth provides asynchronous transfer
of control.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
select_statement ::=
     selective_accept
   | timed_entry_call
   | conditional_entry_call
   | asynchronous_select
@end example

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a select statement:

@item
@example
select
   accept Driver_Awake_Signal;
or
   delay 30.0*Seconds;
   Stop_The_Train;
end select;
@end example
@end enumerate

@menu
* 9.7.1:: Selective Accept
* 9.7.2:: Timed Entry Calls
* 9.7.3:: Conditional Entry Calls
* 9.7.4:: Asynchronous Transfer of Control
@end menu

@c ---------------------------------------------------------------------------
@node 9.7.1, 9.7.2, 9.7, 9.7
@subsection Selective Accept

@enumerate
@item
This form of the select_statement allows a combination of waiting for,
and selecting from, one or more alternatives. The selection may depend
on conditions associated with each alternative of the selective_accept.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
selective_accept ::=
   select
      [guard]
      select_alternative
 @{ or
      [guard]
      select_alternative @}
    [ else
      sequence_of_statements ]
    end select;
@end example

@item
@example
guard ::= when condition =>
@end example

@item
@example
select_alternative ::=
     accept_alternative
   | delay_alternative
   | terminate_alternative
@end example

@item
@example
accept_alternative ::=
   accept_statement [sequence_of_statements]
@end example

@item
@example
delay_alternative ::=
   delay_statement [sequence_of_statements]
@end example

@item
@example
terminate_alternative ::= terminate;
@end example

@enumerate 8
@item
A selective_accept shall contain at least one accept_alternative. In
addition, it can contain:

@enumerate 9
@item
a terminate_alternative (only one); or

@item
one or more delay_alternatives; or

@item
an else part (the reserved word else followed by a
sequence_of_statements).
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 12
@item
These three possibilities are mutually exclusive.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 13
@item
If a selective_accept contains more than one delay_alternative, then all
shall be delay_relative_statements, or all shall be
delay_until_statements for the same time type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A select_alternative is said to be open if it is not immediately
preceded by a guard, or if the condition of its guard evaluates to True.
It is said to be closed otherwise.

@item
For the execution of a selective_accept, any guard conditions are
evaluated; open alternatives are thus determined. For an open
delay_alternative, the delay_expression is also evaluated. Similarly,
for an open accept_alternative for an entry of a family, the entry_index
is also evaluated. These evaluations are performed in an arbitrary
order, except that a delay_expression or entry_index is not evaluated
until after evaluating the corresponding condition, if any. Selection
and execution of one open alternative, or of the else part, then
completes the execution of the selective_accept; the rules for this
selection are described below.

@item
Open accept_alternatives are first considered. Selection of one such
alternative takes place immediately if the corresponding entry already
has queued calls. If several alternatives can thus be selected, one of
them is selected according to the entry queuing policy in effect
(see @ref{9.5.3} and @ref{D.4}). When such an alternative is selected, the
selected call is removed from its entry queue and the
handled_sequence_of_statements (if any) of the corresponding
accept_statement is executed; after the rendezvous completes any
subsequent sequence_of_statements of the alternative is executed. If no
selection is immediately possible (in the above sense) and there is no
else part, the task blocks until an open alternative can be selected.

@item
Selection of the other forms of alternative or of an else part is
performed as follows:

@enumerate 18
@item
An open delay_alternative is selected when its expiration time is
reached if no accept_alternative or other delay_alternative can be
selected prior to the expiration time. If several delay_alternatives
have this same expiration time, one of them is selected according to the
queuing policy in effect, see @ref{D.4}, the default queuing policy chooses
arbitrarily among the delay_alternatives whose expiration time has
passed.

@item
The else part is selected and its sequence_of_statements is executed if
no accept_alternative can immediately be selected; in particular, if all
alternatives are closed.

@item
An open terminate_alternative is selected if the conditions stated at
the end of clause (@pxref{9.3}) are satisfied.
@end enumerate
@end enumerate

@enumerate 21
@item
The exception Program_Error is raised if all alternatives are closed and
there is no else part.

NOTES

@item
(36) A selective_accept is allowed to have several open
delay_alternatives. A selective_accept is allowed to have several open
accept_alternatives for the same entry.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a task body with a selective accept:

@item
@example
task body Server is
   Current_Work_Item : Work_Item;
begin
   loop
      select
         accept Next_Work_Item(WI : in Work_Item) do
            Current_Work_Item := WI;
          end;
          Process_Work_Item(Current_Work_Item);
      or
         accept Shut_Down;
         exit;       -- Premature shut down requested
      or
         terminate;  -- Normal shutdown at end of scope
      end select;
   end loop;
end Server;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.7.2, 9.7.3, 9.7.1, 9.7
@subsection Timed Entry Calls

@enumerate
@item
A timed_entry_call issues an entry call that is cancelled if the call
(or a requeue-with-abort of the call) is not selected before the
expiration time is reached.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
timed_entry_call ::=
   select
      entry_call_alternative
   or
      delay_alternative
   end select;
@end example

@item
@example
entry_call_alternative ::=
   entry_call_statement [sequence_of_statements]
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a timed_entry_call, the entry_name and the actual
parameters are evaluated, as for a simple entry call, see @ref{9.5.3}. The
expiration time, see @ref{9.6} for the call is determined by evaluating the
delay_expression of the delay_alternative; the entry call is then
issued.

@item
If the call is queued (including due to a requeue-with-abort), and not
selected before the expiration time is reached, an attempt to cancel the
call is made. If the call completes due to the cancellation, the
optional sequence_of_statements of the delay_alternative is executed; if
the entry call completes normally, the optional sequence_of_statements
of the entry_call_alternative is executed.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a timed entry call:

@item
@example
select
   Controller.Request(Medium)(Some_Item);
or
   delay 45.0;
   --  controller too busy, try something else
end select;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.7.3, 9.7.4, 9.7.2, 9.7
@subsection Conditional Entry Calls

@enumerate
@item
A conditional_entry_call issues an entry call that is then cancelled if
it is not selected immediately (or if a requeue-with-abort of the call
is not selected immediately).

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
conditional_entry_call ::=
   select
      entry_call_alternative
   else
      sequence_of_statements
   end select;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a conditional_entry_call is defined to be equivalent to
the execution of a timed_entry_call with a delay_alternative specifying
an immediate expiration time and the same sequence_of_statements as
given after the reserved word else.

NOTES

@item
(37) A conditional_entry_call may briefly increase the Count attribute
of the entry, even if the conditional call is not selected.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a conditional entry call:

@item
@example
procedure Spin(R : in Resource) is
begin
   loop
      select
         R.Seize;
         return;
      else
         null;  --  busy waiting
      end select;
   end loop;
end;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.7.4, 9.8, 9.7.3, 9.7
@subsection Asynchronous Transfer of Control

@enumerate
@item
An asynchronous select_statement provides asynchronous transfer of
control upon completion of an entry call or the expiration of a delay.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
asynchronous_select ::=
   select
      triggering_alternative
   then abort
      abortable_part
   end select;
@end example

@item
@example
triggering_alternative ::=
   triggering_statement [sequence_of_statements]
@end example

@item
@example
triggering_statement ::= entry_call_statement | delay_statement
@end example

@item
@example
abortable_part ::= sequence_of_statements
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of an asynchronous_select whose triggering_statement
is an entry_call_statement, the entry_name and actual parameters are
evaluated as for a simple entry call, see @ref{9.5.3}, and the entry call
is issued. If the entry call is queued (or requeued-with-abort), then
the abortable_part is executed. If the entry call is selected
immediately, and never requeued-with-abort, then the abortable_part is
never started.

@item
For the execution of an asynchronous_select whose triggering_statement
is a delay_statement, the delay_expression is evaluated and the
expiration time is determined, as for a normal delay_statement. If the
expiration time has not already passed, the abortable_part is executed.

@item
If the abortable_part completes and is left prior to completion of the
triggering_statement, an attempt to cancel the triggering_statement is
made. If the attempt to cancel succeeds, see @ref{9.5.3}, and @ref{9.6},
the asynchronous_select is complete.

@item
If the triggering_statement completes other than due to cancellation,
the abortable_part is aborted (if started but not yet completed --
see @ref{9.8}). If the triggering_statement completes normally, the
optional sequence_of_statements of the triggering_alternative is
executed after the abortable_part is left.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a main command loop for a command interpreter:

@item
@example
loop
    select
        Terminal.Wait_For_Interrupt;
        Put_Line("Interrupted");
    then abort
        -- This will be abandoned upon terminal interrupt
        Put_Line("-> ");
        Get_Line(Command, Last);
        Process_Command(Command(1..Last));
    end select;
end loop;
@end example

@item
Example of a time-limited calculation:

@item
@example
select
   delay 5.0;
   Put_Line("Calculation does not converge");
then abort
   -- This calculation should finish in 5.0 seconds;
   --  if not, it is assumed to diverge.
   Horribly_Complicated_Recursive_Function(X, Y);
end select;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.8, 9.9, 9.7.4, 9
@section Abort of a Task - Abort of a Sequence of Statements

@enumerate
@item
An abort_statement causes one or more tasks to become abnormal, thus
preventing any further interaction with such tasks. The completion of
the triggering_statement of an asynchronous_select causes a
sequence_of_statements to be aborted.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
abort_statement ::= abort task_name @{, task_name@};
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Each task_name is expected to be of any task type; they need not all be
of the same task type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of an abort_statement, the given task_names are
evaluated in an arbitrary order. Each named task is then aborted, which
consists of making the task abnormal and aborting the execution of the
corresponding task_body, unless it is already completed.

@item
When the execution of a construct is aborted (including that of a
task_body or of a sequence_of_statements), the execution of every
construct included within the aborted execution is also aborted, except
for executions included within the execution of an abort-deferred
operation; the execution of an abort-deferred operation continues to
completion without being affected by the abort; the following are the
abort-deferred operations:

@enumerate 6
@item
a protected action;

@item
waiting for an entry call to complete (after having initiated the
attempt to cancel it -- see below);

@item
waiting for the termination of dependent tasks;

@item
the execution of an Initialize procedure as the last step of the default
initialization of a controlled object;

@item
the execution of a Finalize procedure as part of the finalization of a
controlled object;

@item
an assignment operation to an object with a controlled part.
@end enumerate
@end enumerate

@enumerate 12
@item
The last three of these are discussed further in @ref{7.6}.

@item
When a master is aborted, all tasks that depend on that master are
aborted.

@item
The order in which tasks become abnormal as the result of an
abort_statement or the abort of a sequence_of_statements is not
specified by the language.

@item
If the execution of an entry call is aborted, an immediate attempt is
made to cancel the entry call, see @ref{9.5.3}. If the execution of a
construct is aborted at a time when the execution is blocked, other than
for an entry call, at a point that is outside the execution of an
abort-deferred operation, then the execution of the construct completes
immediately. For an abort due to an abort_statement, these immediate
effects occur before the execution of the abort_statement completes.
Other than for these immediate cases, the execution of a construct that
is aborted does not necessarily complete before the abort_statement
completes. However, the execution of the aborted construct completes no
later than its next abort completion point (if any) that occurs outside
of an abort-deferred operation; the following are abort completion
points for an execution:

@enumerate 16
@item
the point where the execution initiates the activation of another task;

@item
the end of the activation of a task;

@item
the start or end of the execution of an entry call, accept_statement,
delay_statement, or abort_statement;

@item
the start of the execution of a select_statement, or of the
sequence_of_statements of an exception_handler.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@enumerate 20
@item
An attempt to execute an asynchronous_select as part of the execution of
an abort-deferred operation is a bounded error. Similarly, an attempt to
create a task that depends on a master that is included entirely within
the execution of an abort-deferred operation is a bounded error. In both
cases, Program_Error is raised if the error is detected by the
implementation; otherwise the operations proceed as they would outside
an abort-deferred operation, except that an abort of the abortable_part
or the created task might or might not have an effect.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If an assignment operation completes prematurely due to an abort, the
assignment is said to be disrupted; the target of the assignment or its
parts can become abnormal, and certain subsequent uses of the object can
be erroneous, as explained in @ref{13.9.1}.

NOTES

@item
(38) An abort_statement should be used only in situations requiring
unconditional termination.

@item
(39) A task is allowed to abort any task it can name, including itself.

@item
(40) Additional requirements associated with abort are given in
@ref{D.6, ``Preemptive Abort''}.
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.9, 9.10, 9.8, 9
@section Task and Entry Attributes

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate
@item
For a prefix T that is of a task type (after any implicit dereference),
the following attributes are defined:

@item
T'Callable

@example
Yields the value True when the task denoted by T is callable,
and False otherwise; a task is callable unless it is
completed or abnormal. The value of this attribute is of the
predefined type Boolean.
@end example

@item
T'Terminated

@example
Yields the value True if the task denoted by T is terminated,
and False otherwise. The value of this attribute is of the
predefined type Boolean.
@end example

@item
For a prefix E that denotes an entry of a task or protected unit, the
following attribute is defined. This attribute is only allowed within
the body of the task or protected unit, but excluding, in the case of an
entry of a task unit, within any program unit that is, itself, inner to
the body of the task unit.

@item
E'Count

@example
Yields the number of calls presently queued on the entry E of
the current instance of the unit. The value of this
attribute is of the type universal_integer.
@end example

NOTES

@item
(41) For the Count attribute, the entry can be either a single entry or
an entry of a family. The name of the entry or entry family can be
either a direct_name or an expanded name.

@item
(42) Within task units, algorithms interrogating the attribute E'Count
should take precautions to allow for the increase of the value of this
attribute for incoming entry calls, and its decrease, for example with
timed_entry_calls. Also, a conditional_entry_call may briefly increase
this value, even if the conditional call is not accepted.

@item
(43) Within protected units, algorithms interrogating the attribute
E'Count in the entry_barrier for the entry E should take precautions to
allow for the evaluation of the condition of the barrier both before and
after queuing a given caller.
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.10, 9.11, 9.9, 9
@section Shared Variables

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
If two different objects, including nonoverlapping parts of the same
object, are independently addressable, they can be manipulated
concurrently by two different tasks without synchronization. Normally,
any two nonoverlapping objects are independently addressable. However,
if packing, record layout, or Component_Size is specified for a given
composite object, then it is implementation defined whether or not two
nonoverlapping parts of that composite object are independently
addressable.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Separate tasks normally proceed independently and concurrently with one
another. However, task interactions can be used to synchronize the
actions of two or more tasks to allow, for example, meaningful
communication by the direct updating and reading of variables shared
between the tasks. The actions of two different tasks are synchronized
in this sense when an action of one task signals an action of the other
task; an action A1 is defined to signal an action A2 under the following
circumstances:

@enumerate 3
@item
If A1 and A2 are part of the execution of the same task, and the
language rules require A1 to be performed before A2;

@item
If A1 is the action of an activator that initiates the activation of a
task, and A2 is part of the execution of the task that is activated;

@item
If A1 is part of the activation of a task, and A2 is the action of
waiting for completion of the activation;

@item
If A1 is part of the execution of a task, and A2 is the action of
waiting for the termination of the task;

@item
If A1 is the action of issuing an entry call, and A2 is part of the
corresponding execution of the appropriate entry_body or
accept_statement.

@item
If A1 is part of the execution of an accept_statement or entry_body, and
A2 is the action of returning from the corresponding entry call;

@item
If A1 is part of the execution of a protected procedure body or
entry_body for a given protected object, and A2 is part of a later
execution of an entry_body for the same protected object;

@item
If A1 signals some action that in turn signals A2.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@enumerate 11
@item
Given an action of assigning to an object, and an action of reading or
updating a part of the same object (or of a neighboring object if the
two are not independently addressable), then the execution of the
actions is erroneous unless the actions are sequential. Two actions are
sequential if one of the following is true:

@enumerate 12
@item
One action signals the other;

@item
Both actions occur as part of the execution of the same task;

@item
Both actions occur as part of protected actions on the same protected
object, and at most one of the actions is part of a call on a protected
function of the protected object.
@end enumerate
@end enumerate

@enumerate 15
@item
A pragma Atomic or Atomic_Components may also be used to ensure that
certain reads and updates are sequential --  see @ref{C.6}.
@end enumerate

@c ---------------------------------------------------------------------------
@node 9.11, 10, 9.10, 9
@section Example of Tasking and Synchronization

@need 1000
@sp 1
@center @emph{Examples}

@enumerate
@item
The following example defines a buffer protected object to smooth
variations between the speed of output of a producing task and the speed
of input of some consuming task. For instance, the producing task might
have the following structure:

@item
@example
task Producer;
@end example

@item
@example
task body Producer is
   Char : Character;
begin
   loop
      ... --  produce the next character Char
      Buffer.Write(Char);
      exit when Char = ASCII.EOT;
   end loop;
end Producer;
@end example

@item
and the consuming task might have the following structure:

@item
@example
task Consumer;
@end example

@item
@example
task body Consumer is
   Char : Character;
begin
   loop
      Buffer.Read(Char);
      exit when Char = ASCII.EOT;
      ... --  consume the character Char
   end loop;
end Consumer;
@end example

@item
The buffer object contains an internal pool of characters managed in a
round-robin fashion. The pool has two indices, an In_Index denoting the
space for the next input character and an Out_Index denoting the space
for the next output character.

@item
@example
protected Buffer is
   entry Read (C : out Character);
   entry Write(C : in  Character);
private
   Pool      : String(1 .. 100);
   Count     : Natural := 0;
   In_Index, Out_Index : Positive := 1;
end Buffer;
@end example

@item
@example
protected body Buffer is
   entry Write(C : in Character)
      when Count < Pool'Length is
   begin
      Pool(In_Index) := C;
      In_Index := (In_Index mod Pool'Length) + 1;
      Count    := Count + 1;
   end Write;
@end example

@item
@example
   entry Read(C : out Character)
      when Count > 0 is
   begin
      C := Pool(Out_Index);
      Out_Index := (Out_Index mod Pool'Length) + 1;
      Count     := Count - 1;
   end Read;
end Buffer;
@end example
@end enumerate

@c ===========================================================================
@node 10, 10.1, 9.11, Top
@chapter Program Structure and Compilation Issues

@enumerate
@item
The overall structure of programs and the facilities for separate
compilation are described in this section. A program is a set of
partitions, each of which may execute in a separate address space,
possibly on a separate computer.

@item
As explained below, a partition is constructed from library units.
Syntactically, the declaration of a library unit is a library_item, as
is the body of a library unit. An implementation may support a concept
of a program library (or simply, a ``library''), which contains
library_items and their subunits. Library units may be organized into a
hierarchy of children, grandchildren, and so on.

@item
This section has two clauses:  (@pxref{10.1, ``Separate Compilation''})
discusses compile-time issues related to separate compilation.
(@pxref{10.2, ``Program Execution''}) discusses issues related to what is
traditionally known as ``link time'' and ``run time'' -- building and
executing partitions.
@end enumerate

@menu
* 10.1:: Separate Compilation
* 10.2:: Program Execution

 --- The Detailed Node Listing ---

* 10.1::   Separate Compilation
* 10.1.1:: Compilation Units - Library Units
* 10.1.2:: Context Clauses - With Clauses
* 10.1.3:: Subunits of Compilation Units
* 10.1.4:: The Compilation Process
* 10.1.5:: Pragmas and Program Units
* 10.1.6:: Environment-Level Visibility Rules
* 10.2::   Program Execution
* 10.2.1:: Elaboration Control
@end menu

@c ---------------------------------------------------------------------------
@node 10.1, 10.1.1, 10, 10
@section Separate Compilation

@enumerate
@item
A program unit is either a package, a task unit, a protected unit, a
protected entry, a generic unit, or an explicitly declared subprogram
other than an enumeration literal. Certain kinds of program units can be
separately compiled. Alternatively, they can appear physically nested
within other program units.

@item
The text of a program can be submitted to the compiler in one or more
compilations. Each compilation is a succession of compilation_units. A
compilation_unit contains either the declaration, the body, or a
renaming of a program unit. The representation for a compilation is
implementation-defined.

@item
A library unit is a separately compiled program unit, and is always a
package, subprogram, or generic unit. Library units may have other
(logically nested) library units as children, and may have other program
units physically nested within them. A root library unit, together with
its children and grandchildren and so on, form a subsystem.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may impose implementation-defined restrictions on
compilations that contain multiple compilation_units.
@end enumerate

@menu
* 10.1.1:: Compilation Units - Library Units
* 10.1.2:: Context Clauses - With Clauses
* 10.1.3:: Subunits of Compilation Units
* 10.1.4:: The Compilation Process
* 10.1.5:: Pragmas and Program Units
* 10.1.6:: Environment-Level Visibility Rules
@end menu

@c ---------------------------------------------------------------------------
@node 10.1.1, 10.1.2, 10.1, 10.1
@subsection Compilation Units - Library Units

@enumerate
@item
A library_item is a compilation unit that is the declaration, body, or
renaming of a library unit. Each library unit (except Standard) has a
parent unit, which is a library package or generic library package. A
library unit is a child of its parent unit. The root library units are
the children of the predefined library package Standard.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
compilation ::= @{compilation_unit@}
@end example

@item
@example
compilation_unit ::=
     context_clause library_item
   | context_clause subunit
@end example

@item
@example
library_item ::= [private] library_unit_declaration
   | library_unit_body
   | [private] library_unit_renaming_declaration
@end example

@item
@example
library_unit_declaration ::=
     subprogram_declaration | package_declaration
   | generic_declaration    | generic_instantiation
@end example

@item
@example
library_unit_renaming_declaration ::=
     package_renaming_declaration
   | generic_renaming_declaration
   | subprogram_renaming_declaration
@end example

@item
@example
library_unit_body ::= subprogram_body | package_body
@end example

@item
@example
parent_unit_name ::= name
@end example

@item
A library unit is a program unit that is declared by a library_item.
When a program unit is a library unit, the prefix ``library'' is used to
refer to it (or ``generic library'' if generic), as well as to its
declaration and body, as in ``library procedure'', ``library
package_body'', or ``generic library package''. The term compilation
unit is used to refer to a compilation_unit. When the meaning is clear
from context, the term is also used to refer to the library_item of a
compilation_unit or to the proper_body of a subunit (that is, the
compilation_unit without the context_clause and the separate
(parent_unit_name)).

@item
The parent declaration of a library_item (and of the library unit) is
the declaration denoted by the parent_unit_name, if any, of the
defining_program_unit_name of the library_item. If there is no
parent_unit_name, the parent declaration is the declaration of Standard,
the library_item is a root library_item, and the library unit (renaming)
is a root library unit (renaming). The declaration and body of Standard
itself have no parent declaration. The parent unit of a library_item or
library unit is the library unit declared by its parent declaration.

@item
The children of a library unit occur immediately within the declarative
region of the declaration of the library unit. The ancestors of a
library unit are itself, its parent, its parent's parent, and so on.
(Standard is an ancestor of every library unit.) The descendant relation
is the inverse of the ancestor relation.

@item
A library_unit_declaration or a library_unit_renaming_declaration is
private if the declaration is immediately preceded by the reserved word
private; it is otherwise public. A library unit is private or public
according to its declaration. The public descendants of a library unit
are the library unit itself, and the public descendants of its public
children. Its other descendants are private descendants.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The parent unit of a library_item shall be a library package or generic
library package.

@item
If a defining_program_unit_name of a given declaration or body has a
parent_unit_name, then the given declaration or body shall be a
library_item. The body of a program unit shall be a library_item if and
only if the declaration of the program unit is a library_item. In a
library_unit_renaming_declaration, the (old) name shall denote a
library_item.

@item
A parent_unit_name (which can be used within a
defining_program_unit_name of a library_item and in the separate clause
of a subunit), and each of its prefixes, shall not denote a
renaming_declaration. On the other hand, a name that denotes a
library_unit_renaming_declaration is allowed in a with_clause and other
places where the name of a library unit is allowed.

@item
If a library package is an instance of a generic package, then every
child of the library package shall either be itself an instance or be a
renaming of a library unit.

@item
A child of a generic library package shall either be itself a generic
unit or be a renaming of some other child of the same generic unit. The
renaming of a child of a generic package shall occur only within the
declarative region of the generic package.

@item
A child of a parent generic package shall be instantiated or renamed
only within the declarative region of the parent generic.

@item
For each declaration or renaming of a generic unit as a child of some
parent generic package, there is a corresponding declaration nested
immediately within each instance of the parent. This declaration is
visible only within the scope of a with_clause that mentions the child
generic unit.

@item
A library subprogram shall not override a primitive subprogram.

@item
The defining name of a function that is a compilation unit shall not be
an operator_symbol.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A subprogram_renaming_declaration that is a
library_unit_renaming_declaration is a renaming-as-declaration, not a
renaming-as-body.

@item
There are two kinds of dependences among compilation units:

@enumerate 24
@item
The semantic dependences (see below) are the ones needed to check the
compile-time rules across compilation unit boundaries; a compilation
unit depends semantically on the other compilation units needed to
determine its legality. The visibility rules are based on the semantic
dependences.

@item
The elaboration dependences, see @ref{10.2}, determine the order of
elaboration of library_items.
@end enumerate
@end enumerate

@enumerate 26
@item
A library_item depends semantically upon its parent declaration. A
subunit depends semantically upon its parent body. A library_unit_body
depends semantically upon the corresponding library_unit_declaration, if
any. A compilation unit depends semantically upon each library_item
mentioned in a with_clause of the compilation unit. In addition, if a
given compilation unit contains an attribute_reference of a type defined
in another compilation unit, then the given compilation unit depends
semantically upon the other compilation unit. The semantic dependence
relationship is transitive.

NOTES

@item
(1) A simple program may consist of a single compilation unit. A
compilation need not have any compilation units; for example, its text
can consist of pragmas.

@item
(2) The designator of a library function cannot be an operator_symbol,
but a nonlibrary renaming_declaration is allowed to rename a library
function as an operator. Within a partition, two library subprograms are
required to have distinct names and hence cannot overload each other.
However, renaming_declarations are allowed to define overloaded names
for such subprograms, and a locally declared subprogram is allowed to
overload a library subprogram. The expanded name Standard.L can be used
to denote a root library unit L (unless the declaration of Standard is
hidden) since root library unit declarations occur immediately within
the declarative region of package Standard.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of library units:

@item
@example
package Rational_Numbers.IO is
   -- public child of Rational_Numbers, see @ref{7.1}
   procedure Put(R : in  Rational);
   procedure Get(R : out Rational);
end Rational_Numbers.IO;
@end example

@item
@example
private procedure Rational_Numbers.Reduce(R : in out Rational);
-- private child of Rational_Numbers
@end example

@item
@example
with Rational_Numbers.Reduce;   -- refer to a private child
package body Rational_Numbers is
   ...
end Rational_Numbers;
@end example

@item
@example
with Rational_Numbers.IO; use Rational_Numbers;
with Ada.Text_io;  --  see @ref{A.10}
procedure Main is  -- a root library procedure
   R : Rational;
begin
   R := 5/3;       -- construct a rational number, see @ref{7.1}
   Ada.Text_IO.Put("The answer is: ");
   IO.Put(R);
   Ada.Text_IO.New_Line;
end Main;
@end example

@item
@example
with Rational_Numbers.IO;
package Rational_IO renames Rational_Numbers.IO;
-- a library unit renaming declaration
@end example

@item
Each of the above library_items can be submitted to the compiler
separately.
@end enumerate

@c ---------------------------------------------------------------------------
@node 10.1.2, 10.1.3, 10.1.1, 10.1
@subsection Context Clauses - With Clauses

@enumerate
@item
A context_clause is used to specify the library_items whose names are
needed within a compilation unit.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
context_clause ::= @{context_item@}
@end example

@item
@example
context_item ::= with_clause | use_clause
@end example

@item
@example
with_clause ::= with library_unit_name @{, library_unit_name@};
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The scope of a with_clause that appears on a library_unit_declaration or
library_unit_renaming_declaration consists of the entire declarative
region of the declaration, which includes all children and subunits. The
scope of a with_clause that appears on a body consists of the body,
which includes all subunits.

@item
A library_item is mentioned in a with_clause if it is denoted by a
library_unit_name or a prefix in the with_clause.

@item
Outside its own declarative region, the declaration or renaming of a
library unit can be visible only within the scope of a with_clause that
mentions it. The visibility of the declaration or renaming of a library
unit otherwise follows from its placement in the environment.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If a with_clause of a given compilation_unit mentions a private child of
some library unit, then the given compilation_unit shall be either the
declaration of a private descendant of that library unit or the body or
subunit of a (public or private) descendant of that library unit.

NOTES

@item
(3) A library_item mentioned in a with_clause of a compilation unit is
visible within the compilation unit and hence acts just like an ordinary
declaration. Thus, within a compilation unit that mentions its
declaration, the name of a library package can be given in use_clauses
and can be used to form expanded names, a library subprogram can be
called, and instances of a generic library unit can be declared. If a
child of a parent generic package is mentioned in a with_clause, then
the corresponding declaration nested within each visible instance is
visible within the compilation unit.
@end enumerate

@c ---------------------------------------------------------------------------
@node 10.1.3, 10.1.4, 10.1.2, 10.1
@subsection Subunits of Compilation Units

@enumerate
@item
Subunits are like child units, with these (important) differences:
subunits support the separate compilation of bodies only (not
declarations); the parent contains a body_stub to indicate the existence
and place of each of its subunits; declarations appearing in the
parent's body can be visible within the subunits.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
body_stub ::=
     subprogram_body_stub
   | package_body_stub
   | task_body_stub
   | protected_body_stub
@end example

@item
@example
subprogram_body_stub ::= subprogram_specification is separate;
@end example

@item
@example
package_body_stub ::= package body defining_identifier is separate;
@end example

@item
@example
task_body_stub ::= task body defining_identifier is separate;
@end example

@item
@example
protected_body_stub ::=
   protected body defining_identifier is separate;
@end example

@item
@example
subunit ::= separate (parent_unit_name) proper_body
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The parent body of a subunit is the body of the program unit denoted by
its parent_unit_name. The term subunit is used to refer to a subunit and
also to the proper_body of a subunit.

@item
The parent body of a subunit shall be present in the current
environment, and shall contain a corresponding body_stub with the same
defining_identifier as the subunit.

@item
A package_body_stub shall be the completion of a package_declaration or
generic_package_declaration; a task_body_stub shall be the completion of
a task_declaration; a protected_body_stub shall be the completion of a
protected_declaration.

@item
In contrast, a subprogram_body_stub need not be the completion of a
previous declaration, in which case the _stub declares the subprogram.
If the _stub is a completion, it shall be the completion of a
subprogram_declaration or generic_subprogram_declaration. The profile of
a subprogram_body_stub that completes a declaration shall conform fully
to that of the declaration.

@item
A subunit that corresponds to a body_stub shall be of the same kind
(package_, subprogram_, task_, or protected_) as the body_stub. The
profile of a subprogram_body subunit shall be fully conformant to that
of the corresponding body_stub.

@item
A body_stub shall appear immediately within the declarative_part of a
compilation unit body. This rule does not apply within an instance of a
generic unit.

@item
The defining_identifiers of all body_stubs that appear immediately
within a particular declarative_part shall be distinct.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
For each body_stub, there shall be a subunit containing the
corresponding proper_body.

NOTES

@item
(4) The rules in @ref{10.1.4, ``The Compilation Process''}, say that a
body_stub is equivalent to the corresponding proper_body. This implies:

@enumerate 17
@item
Visibility within a subunit is the visibility that would be obtained at
the place of the corresponding body_stub (within the parent body) if the
context_clause of the subunit were appended to that of the parent body.

@item
The effect of the elaboration of a body_stub is to elaborate the
subunit.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Examples}

@enumerate 19
@item
The package Parent is first written without subunits:

@item
@example
package Parent is
    procedure Inner;
end Parent;
@end example

@item
@example
with Ada.Text_IO;
package body Parent is
    Variable : String := "Hello, there.";
    procedure Inner is
    begin
        Ada.Text_IO.Put_Line(Variable);
    end Inner;
end Parent;
@end example

@item
The body of procedure Inner may be turned into a subunit by rewriting
the package body as follows (with the declaration of Parent remaining
the same):

@item
@example
package body Parent is
    Variable : String := "Hello, there.";
    procedure Inner is separate;
end Parent;
@end example

@item
@example
with Ada.Text_IO;
separate(Parent)
procedure Inner is
begin
    Ada.Text_IO.Put_Line(Variable);
end Inner;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 10.1.4, 10.1.5, 10.1.3, 10.1
@subsection The Compilation Process

@enumerate
@item
Each compilation unit submitted to the compiler is compiled in the
context of an environment declarative_part (or simply, an environment),
which is a conceptual declarative_part that forms the outermost
declarative region of the context of any compilation. At run time, an
environment forms the declarative_part of the body of the environment
task of a partition, see @ref{10.2, ``Program Execution''}.

@item
The declarative_items of the environment are library_items appearing in
an order such that there are no forward semantic dependences. Each
included subunit occurs in place of the corresponding stub. The
visibility rules apply as if the environment were the outermost
declarative region, except that with_clauses are needed to make
declarations of library units visible, see @ref{10.1.2}.

@item
The mechanisms for creating an environment and for adding and replacing
compilation units within an environment are implementation defined.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
If a library_unit_body that is a subprogram_body is submitted to the
compiler, it is interpreted only as a completion if a
library_unit_declaration for a subprogram or a generic subprogram with
the same defining_program_unit_name already exists in the environment
(even if the profile of the body is not type conformant with that of the
declaration); otherwise the subprogram_body is interpreted as both the
declaration and body of a library subprogram.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
When a compilation unit is compiled, all compilation units upon which it
depends semantically shall already exist in the environment; the set of
these compilation units shall be consistent in the sense that the new
compilation unit shall not semantically depend (directly or indirectly)
on two different versions of the same compilation unit, nor on an
earlier version of itself.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The implementation may require that a compilation unit be legal before
inserting it into the environment.

@item
When a compilation unit that declares or renames a library unit is added
to the environment, the implementation may remove from the environment
any preexisting library_item with the same defining_program_unit_name.
When a compilation unit that is a subunit or the body of a library unit
is added to the environment, the implementation may remove from the
environment any preexisting version of the same compilation unit. When a
given compilation unit is removed from the environment, the
implementation may also remove any compilation unit that depends
semantically upon the given one. If the given compilation unit contains
the body of a subprogram to which a pragma Inline applies, the
implementation may also remove any compilation unit containing a call to
that subprogram.

NOTES

@item
(5) The rules of the language are enforced across compilation and
compilation unit boundaries, just as they are enforced within a single
compilation unit.

@item
(6) An implementation may support a concept of a library, which contains
library_items. If multiple libraries are supported, the implementation
has to define how a single environment is constructed when a compilation
unit is submitted to the compiler. Naming conflicts between different
libraries might be resolved by treating each library as the root of a
hierarchy of child library units.

@item
(7) A compilation unit containing an instantiation of a separately
compiled generic unit does not semantically depend on the body of the
generic unit. Therefore, replacing the generic body in the environment
does not result in the removal of the compilation unit containing the
instantiation.
@end enumerate

@c ---------------------------------------------------------------------------
@node 10.1.5, 10.1.6, 10.1.4, 10.1
@subsection Pragmas and Program Units

@enumerate
@item
This subclause discusses pragmas related to program units, library
units, and compilations.

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Certain pragmas are defined to be program unit pragmas. A name given as
the argument of a program unit pragma shall resolve to denote the
declarations or renamings of one or more program units that occur
immediately within the declarative region or compilation in which the
pragma immediately occurs, or it shall resolve to denote the declaration
of the immediately enclosing program unit (if any); the pragma applies
to the denoted program unit(s). If there are no names given as
arguments, the pragma applies to the immediately enclosing program unit.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A program unit pragma shall appear in one of these places:

@enumerate 4
@item
At the place of a compilation_unit, in which case the pragma shall
immediately follow in the same compilation (except for other pragmas) a
library_unit_declaration that is a subprogram_declaration,
generic_subprogram_declaration, or generic_instantiation, and the pragma
shall have an argument that is a name denoting that declaration.

@item
Immediately within the declaration of a program unit and before any
nested declaration, in which case the argument, if any, shall be a
direct_name that denotes the immediately enclosing program unit
declaration.

@item
At the place of a declaration other than the first, of a
declarative_part or program unit declaration, in which case the pragma
shall have an argument, which shall be a direct_name that denotes one or
more of the following (and nothing else): a subprogram_declaration, a
generic_subprogram_declaration, or a generic_instantiation, of the same
declarative_part or program unit declaration.
@end enumerate
@end enumerate

@enumerate 7
@item
Certain program unit pragmas are defined to be library unit pragmas. The
name, if any, in a library unit pragma shall denote the declaration of a
library unit.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
Certain pragmas are defined to be configuration pragmas; they shall
appear before the first compilation_unit of a compilation. They are
generally used to select a partition-wide or system-wide option. The
pragma applies to all compilation_units appearing in the compilation,
unless there are none, in which case it applies to all future
compilation_units compiled into the same environment.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may place restrictions on configuration pragmas, so
long as it allows them when the environment contains no library_items
other than those of the predefined environment.
@end enumerate

@c ---------------------------------------------------------------------------
@node 10.1.6, 10.2, 10.1.5, 10.1
@subsection Environment-Level Visibility Rules

@enumerate
@item
The normal visibility rules do not apply within a parent_unit_name or a
context_clause, nor within a pragma that appears at the place of a
compilation unit. The special visibility rules for those contexts are
given here.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Within the parent_unit_name at the beginning of a library_item, and
within a with_clause, the only declarations that are visible are those
that are library_items of the environment, and the only declarations
that are directly visible are those that are root library_items of the
environment. Notwithstanding the rules of  @ref{4.1.3}, an expanded name
in a with_clause may consist of a prefix that denotes a generic package
and a selector_name that denotes a child of that generic package (The
child is necessarily a generic unit, see @ref{10.1.1}.)

@item
Within a use_clause or pragma that is within a context_clause, each
library_item mentioned in a previous with_clause of the same
context_clause is visible, and each root library_item so mentioned is
directly visible. In addition, within such a use_clause, if a given
declaration is visible or directly visible, each declaration that occurs
immediately within the given declaration's visible part is also visible.
No other declarations are visible or directly visible.

@item
Within the parent_unit_name of a subunit, library_items are visible as
they are in the parent_unit_name of a library_item; in addition, the
declaration corresponding to each body_stub in the environment is also
visible.

@item
Within a pragma that appears at the place of a compilation unit, the
immediately preceding library_item and each of its ancestors is visible.
The ancestor root library_item is directly visible.
@end enumerate

@c ---------------------------------------------------------------------------
@node 10.2, 10.2.1, 10.1.6, 10
@section Program Execution

@enumerate
@item
An Ada program consists of a set of partitions, which can execute in
parallel with one another, possibly in a separate address space, and
possibly on a separate computer.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A partition is a program or part of a program that can be invoked from
outside the Ada implementation. For example, on many systems, a
partition might be an executable file generated by the system linker.
The user can explicitly assign library units to a partition. The
assignment is done in an implementation-defined manner. The compilation
units included in a partition are those of the explicitly assigned
library units, as well as other compilation units needed by those
library units. The compilation units needed by a given compilation unit
are determined as follows (unless specified otherwise via an
implementation-defined pragma, or by some other implementation-defined
means):

@enumerate 3
@item
A compilation unit needs itself;

@item
If a compilation unit is needed, then so are any compilation units upon
which it depends semantically;

@item
If a library_unit_declaration is needed, then so is any corresponding
library_unit_body;

@item
If a compilation unit with stubs is needed, then so are any
corresponding subunits.
@end enumerate
@end enumerate

@enumerate 7
@item
The user can optionally designate (in an implementation-defined manner)
one subprogram as the main subprogram for the partition. A main
subprogram, if specified, shall be a subprogram.

@item
Each partition has an anonymous environment task, which is an implicit
outermost task whose execution elaborates the library_items of the
environment declarative_part, and then calls the main subprogram, if
there is one. A partition's execution is that of its tasks.

@item
The order of elaboration of library units is determined primarily by the
elaboration dependences. There is an elaboration dependence of a given
library_item upon another if the given library_item or any of its
subunits depends semantically on the other library_item. In addition, if
a given library_item or any of its subunits has a pragma Elaborate or
Elaborate_All that mentions another library unit, then there is an
elaboration dependence of the given library_item upon the body of the
other library unit, and, for Elaborate_All only, upon each library_item
needed by the declaration of the other library unit.

@item
The environment task for a partition has the following structure:

@item
@example
task Environment_Task;
@end example

@item
@example
task body Environment_Task is
    ... (1) -- The environment declarative_part
            -- (that is, the sequence of library_items) goes here.
begin
    ... (2) -- Call the main subprogram, if there is one.
end Environment_Task;
@end example

@item
The environment declarative_part at (1) is a sequence of
declarative_items consisting of copies of the library_items included in
the partition. The order of elaboration of library_items is the order in
which they appear in the environment declarative_part:

@enumerate 14
@item
The order of all included library_items is such that there are no
forward elaboration dependences.

@item
Any included library_unit_declaration to which a pragma Elaborate_Body
applies is immediately followed by its library_unit_body, if included.

@item
All library_items declared pure occur before any that are not declared
pure.

@item
All preelaborated library_items occur before any that are not
preelaborated.
@end enumerate
@end enumerate

@enumerate 18
@item
There shall be a total order of the library_items that obeys the above
rules. The order is otherwise implementation defined.

@item
The full expanded names of the library units and subunits included in a
given partition shall be distinct.

@item
The sequence_of_statements of the environment task (see (2) above)
consists of either:

@enumerate
@enumerate 21
@item
A call to the main subprogram, if the partition has one. If the main
subprogram has parameters, they are passed; where the actuals come from
is implementation defined. What happens to the result of a main function
is also implementation defined.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 22
@item
or:

@enumerate 23
@item
A null_statement, if there is no main subprogram.
@end enumerate
@end enumerate
@end enumerate

@enumerate 24
@item
The mechanisms for building and running partitions are implementation
defined. These might be combined into one operation, as, for example, in
dynamic linking, or ``load-and-go'' systems.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a program consists of the execution of a set of
partitions. Further details are implementation defined. The execution of
a partition starts with the execution of its environment task, ends when
the environment task terminates, and includes the executions of all
tasks of the partition. The execution of the (implicit) task_body of the
environment task acts as a master for all other tasks created as part of
the execution of the partition. When the environment task completes
(normally or abnormally), it waits for the termination of all such
tasks, and then finalizes any remaining objects of the partition.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
Once the environment task has awaited the termination of all other tasks
of the partition, any further attempt to create a task (during
finalization) is a bounded error, and may result in the raising of
Program_Error either upon creation or activation of the task. If such a
task is activated, it is not specified whether the task is awaited prior
to termination of the environment task.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall ensure that all compilation units included in a
partition are consistent with one another, and are legal according to
the rules of the language.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The kind of partition described in this clause is known as an active
partition. An implementation is allowed to support other kinds of
partitions, with implementation-defined semantics.

@item
An implementation may restrict the kinds of subprograms it supports as
main subprograms. However, an implementation is required to support all
main subprograms that are public parameterless library procedures.

@item
If the environment task completes abnormally, the implementation may
abort any dependent tasks.

NOTES

@item
(8) An implementation may provide inter-partition communication
mechanism(s) via special packages and pragmas. Standard pragmas for
distribution and methods for specifying inter-partition communication
are defined in @ref{E, ``Distributed Systems''}. If no such mechanisms
are provided, then each partition is isolated from all others, and
behaves as a program in and of itself.

@item
(9) Partitions are not required to run in separate address spaces. For
example, an implementation might support dynamic linking via the
partition concept.

@item
(10) An order of elaboration of library_items that is consistent with
the partial ordering defined above does not always ensure that each
library_unit_body is elaborated before any other compilation unit whose
elaboration necessitates that the library_unit_body be already
elaborated (In particular, there is no requirement that the body of a
library unit be elaborated as soon as possible after the
library_unit_declaration is elaborated, unless the pragmas in subclause,
see @ref{10.2.1}, are used).

@item
(11) A partition (active or otherwise) need not have a main subprogram.
In such a case, all the work done by the partition would be done by
elaboration of various library_items, and by tasks created by that
elaboration. Passive partitions, which cannot have main subprograms, are
defined in @ref{E, ``Distributed Systems''}.
@end enumerate

@menu
* 10.2.1:: Elaboration Control
@end menu

@c ---------------------------------------------------------------------------
@node 10.2.1, 11, 10.2, 10.2
@subsection Elaboration Control

@enumerate
@item
This subclause defines pragmas that help control the elaboration order
of library_items.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Preelaborate is as follows:

@item
@example
pragma Preelaborate[(library_unit_name)];
@end example

@enumerate 4
@item
A pragma Preelaborate is a library unit pragma.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 5
@item
An elaborable construct is preelaborable unless its elaboration performs
any of the following actions:

@enumerate 6
@item
The execution of a statement other than a null_statement.

@item
A call to a subprogram other than a static function.

@item
The evaluation of a primary that is a name of an object, unless the name
is a static expression, or statically denotes a discriminant of an
enclosing type.

@item
The creation of a default-initialized object (including a component) of
a descendant of a private type, private extension, controlled type, task
type, or protected type with entry_declarations; similarly the
evaluation of an extension_aggregate with an ancestor subtype_mark
denoting a subtype of such a type.
@end enumerate
@end enumerate

@enumerate 10
@item
A generic body is preelaborable only if elaboration of a corresponding
instance body would not perform any such actions, presuming that the
actual for each formal private type (or extension) is a private type (or
extension), and the actual for each formal subprogram is a user-defined
subprogram.

@item
If a pragma Preelaborate (or pragma Pure -- see below) applies to a
library unit, then it is preelaborated. If a library unit is
preelaborated, then its declaration, if any, and body, if any, are
elaborated prior to all non-preelaborated library_items of the
partition. All compilation units of a preelaborated library unit shall
be preelaborable. In addition to the places where Legality Rules
normally apply, see @ref{12.3}, this rule applies also in the private part
of an instance of a generic unit. In addition, all compilation units of
a preelaborated library unit shall depend semantically only on
compilation units of other preelaborated library units.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
In an implementation, a type declared in a preelaborated package should
have the same representation in every elaboration of a given version of
the package, whether the elaborations occur in distinct executions of
the same program, or in executions of distinct programs or partitions
that include the given version.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Pure is as follows:

@item
@example
pragma Pure[(library_unit_name)];
@end example

@enumerate 15
@item
A pragma Pure is a library unit pragma.

@need 1000
@sp 1
@center @emph{Legality Rules}
@end enumerate
@end enumerate

@enumerate 16
@item
A pure library_item is a preelaborable library_item that does not
contain the declaration of any variable or named access type, except
within a subprogram, generic subprogram, task unit, or protected unit.

@item
A pragma Pure is used to declare that a library unit is pure. If a
pragma Pure applies to a library unit, then its compilation units shall
be pure, and they shall depend semantically only on compilation units of
other library units that are declared pure.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
If a library unit is declared pure, then the implementation is permitted
to omit a call on a library-level subprogram of the library unit if the
results are not needed after the call. Similarly, it may omit such a
call and simply reuse the results produced by an earlier call on the
same subprogram, provided that none of the parameters are of a limited
type, and the addresses and values of all by-reference actual
parameters, and the values of all by-copy-in actual parameters, are the
same as they were at the earlier call. This permission applies even if
the subprogram produces other side effects when called.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Elaborate, Elaborate_All, or Elaborate_Body is
as follows:

@item
@example
pragma Elaborate(library_unit_name@{, library_unit_name@});
@end example

@item
@example
pragma Elaborate_All(library_unit_name@{, library_unit_name@});
@end example

@item
@example
pragma Elaborate_Body[(library_unit_name)];
@end example

@enumerate 23
@item
A pragma Elaborate or Elaborate_All is only allowed within a
context_clause.

@item
A pragma Elaborate_Body is a library unit pragma.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 25
@item
If a pragma Elaborate_Body applies to a declaration, then the
declaration requires a completion (a body).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A pragma Elaborate specifies that the body of the named library unit is
elaborated before the current library_item. A pragma Elaborate_All
specifies that each library_item that is needed by the named library
unit declaration is elaborated before the current library_item. A pragma
Elaborate_Body specifies that the body of the library unit is elaborated
immediately after its declaration.

NOTES

@item
(12) A preelaborated library unit is allowed to have non-preelaborable
children.

@item
(13) A library unit that is declared pure is allowed to have impure
children.
@end enumerate

@c ===========================================================================
@node 11, 11.1, 10.2.1, Top
@chapter Exceptions

@enumerate
@item
This section defines the facilities for dealing with errors or other
exceptional situations that arise during program execution. An exception
represents a kind of exceptional situation; an occurrence of such a
situation (at run time) is called an exception occurrence. To raise an
exception is to abandon normal program execution so as to draw attention
to the fact that the corresponding situation has arisen. Performing some
actions in response to the arising of an exception is called handling
the exception.

@item
An exception_declaration declares a name for an exception. An exception
is raised initially either by a raise_statement or by the failure of a
language-defined check. When an exception arises, control can be
transferred to a user-provided exception_handler at the end of a
handled_sequence_of_statements, or it can be propagated to a dynamically
enclosing execution.
@end enumerate

@menu
* 11.1:: Exception Declarations
* 11.2:: Exception Handlers
* 11.3:: Raise Statements
* 11.4:: Exception Handling
* 11.5:: Suppressing Checks
* 11.6:: Exceptions and Optimization

 --- The Detailed Node Listing ---

* 11.1::   Exception Declarations
* 11.2::   Exception Handlers
* 11.3::   Raise Statements
* 11.4::   Exception Handling
* 11.4.1:: The Package Exceptions
* 11.4.2:: Example of Exception Handling
* 11.5::   Suppressing Checks
* 11.6::   Exceptions and Optimization
@end menu

@c ---------------------------------------------------------------------------
@node 11.1, 11.2, 11, 11
@section Exception Declarations

@enumerate
@item
An exception_declaration declares a name for an exception.

@need 1000
@sp 1
@center @emph{Syntax}

@item
exception_declaration ::= defining_identifier_list : exception;

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Each single exception_declaration declares a name for a different
exception. If a generic unit includes an exception_declaration, the
exception_declarations implicitly generated by different instantiations
of the generic unit refer to distinct exceptions (but all have the same
defining_identifier). The particular exception denoted by an exception
name is determined at compilation time and is the same regardless of how
many times the exception_declaration is elaborated.

@item
The predefined exceptions are the ones declared in the declaration of
package Standard: Constraint_Error, Program_Error, Storage_Error, and
Tasking_Error; one of them is raised when a language-defined check
fails.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of an exception_declaration has no effect.

@item
The execution of any construct raises Storage_Error if there is
insufficient storage for that execution. The amount of storage needed
for the execution of constructs is unspecified.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of user-defined exception declarations:

@item
@example
Singular            : exception;
Error               : exception;
Overflow, Underflow : exception;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 11.2, 11.3, 11.1, 11
@section Exception Handlers

@enumerate
@item
The response to one or more exceptions is specified by an exception_handler.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
handled_sequence_of_statements ::=
      sequence_of_statements
   [exception
      exception_handler
      @{exception_handler@}]
@end example

@item
@example
exception_handler ::=
  when [choice_parameter_specification:]
    exception_choice @{| exception_choice@} =>
     sequence_of_statements
@end example

@item
@example
choice_parameter_specification ::= defining_identifier
@end example

@item
@example
exception_choice ::= exception_name | others
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A choice with an exception_name covers the named exception. A choice
with others covers all exceptions not named by previous choices of the
same handled_sequence_of_statements. Two choices in different
exception_handlers of the same handled_sequence_of_statements shall not
cover the same exception.

@item
A choice with others is allowed only for the last handler of a
handled_sequence_of_statements and as the only choice of that handler.

@item
An exception_name of a choice shall not denote an exception declared in
a generic formal package.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A choice_parameter_specification declares a choice parameter, which is a
constant object of type Exception_Occurrence, see @ref{11.4.1}. During the
handling of an exception occurrence, the choice parameter, if any, of
the handler represents the exception occurrence that is being handled.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The execution of a handled_sequence_of_statements consists of the
execution of the sequence_of_statements. The optional handlers are used
to handle any exceptions that are propagated by the
sequence_of_statements.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of an exception handler:

@item
@example
begin
   Open(File, In_File, "input.txt");   --  see @ref{A.8.2}
exception
   when E : Name_Error =>
      Put("Cannot open input file : ");
      Put_Line(Exception_Message(E));  --  see @ref{11.4.1}
      raise;
end;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 11.3, 11.4, 11.2, 11
@section Raise Statements

@enumerate
@item
A raise_statement raises an exception.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
raise_statement ::= raise [exception_name];
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The name, if any, in a raise_statement shall denote an exception. A
raise_statement with no exception_name (that is, a re-raise statement)
shall be within a handler, but not within a body enclosed by that
handler.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
To raise an exception is to raise a new occurrence of that exception, as
explained in @ref{11.4}. For the execution of a raise_statement with an
exception_name, the named exception is raised. For the execution of a
re-raise statement, the exception occurrence that caused transfer of
control to the innermost enclosing handler is raised again.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of raise statements:

@item
@example
raise Ada.IO_Exceptions.Name_Error;  --  see @ref{A.13}
@end example

@item
@example
raise;
--  re-raise the current exception
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 11.4, 11.4.1, 11.3, 11
@section Exception Handling

@enumerate
@item
When an exception occurrence is raised, normal program execution is
abandoned and control is transferred to an applicable exception_handler,
if any. To handle an exception occurrence is to respond to the
exceptional event. To propagate an exception occurrence is to raise it
again in another context; that is, to fail to respond to the exceptional
event in the present context.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Within a given task, if the execution of construct a is defined by this
International Standard to consist (in part) of the execution of
construct b, then while b is executing, the execution of a is said to
dynamically enclose the execution of b. The innermost dynamically
enclosing execution of a given execution is the dynamically enclosing
execution that started most recently.

@item
When an exception occurrence is raised by the execution of a given
construct, the rest of the execution of that construct is abandoned;
that is, any portions of the execution that have not yet taken place are
not performed. The construct is first completed, and then left, as
explained in @ref{7.6.1}. Then:

@enumerate 4
@item
If the construct is a task_body, the exception does not propagate
further;

@item
If the construct is the sequence_of_statements of a
handled_sequence_of_statements that has a handler with a choice covering
the exception, the occurrence is handled by that handler;

@item
Otherwise, the occurrence is propagated to the innermost dynamically
enclosing execution, which means that the occurrence is raised again in
that context.
@end enumerate
@end enumerate

@enumerate 7
@item
When an occurrence is handled by a given handler, the
choice_parameter_specification, if any, is first elaborated, which
creates the choice parameter and initializes it to the occurrence. Then,
the sequence_of_statements of the handler is executed; this execution
replaces the abandoned portion of the execution of the
sequence_of_statements.

NOTES

@item
(1) Note that exceptions raised in a declarative_part of a body are not
handled by the handlers of the handled_sequence_of_statements of that
body.
@end enumerate

@menu
* 11.4.1:: The Package Exceptions
* 11.4.2:: Example of Exception Handling
@end menu

@c ---------------------------------------------------------------------------
@node 11.4.1, 11.4.2, 11.4, 11.4
@subsection The Package Exceptions

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined library package exists:

@item
@example
package Ada.Exceptions is
    type Exception_Id is private;
    Null_Id : constant Exception_Id;
    function Exception_Name(Id : Exception_Id) return String;
@end example

@item
@example
    type Exception_Occurrence is limited private;
    type Exception_Occurrence_Access is
      access all Exception_Occurrence;
    Null_Occurrence : constant Exception_Occurrence;
@end example

@item
@example
    procedure Raise_Exception
      (E       : in Exception_Id;
       Message : in String := "");
    function Exception_Message(X : Exception_Occurrence)
      return String;
    procedure Reraise_Occurrence(X : in Exception_Occurrence);
@end example

@item
@example
    function Exception_Identity(X : Exception_Occurrence)
      return Exception_Id;
    function Exception_Name(X : Exception_Occurrence)
      return String;
    --  Same as Exception_Name(Exception_Identity(X)).
    function Exception_Information(X : Exception_Occurrence)
      return String;
@end example

@item
@example
    procedure Save_Occurrence(Target : out Exception_Occurrence;
                              Source : in Exception_Occurrence);
    function Save_Occurrence(Source : Exception_Occurrence)
                             return Exception_Occurrence_Access;
private
   ... -- not specified by the language
end Ada.Exceptions;
@end example

@item
Each distinct exception is represented by a distinct value of type
Exception_Id. Null_Id does not represent any exception, and is the
default initial value of type Exception_Id. Each occurrence of an
exception is represented by a value of type Exception_Occurrence.
Null_Occurrence does not represent any exception occurrence, and is the
default initial value of type Exception_Occurrence.

@item
For a prefix E that denotes an exception, the following attribute is
defined:

@item
E'Identity

@example
E'Identity returns the unique identity of the exception. The
type of this attribute is Exception_Id.
@end example

@item
Raise_Exception raises a new occurrence of the identified exception. In
this case, Exception_Message returns the Message parameter of
Raise_Exception. For a raise_statement with an exception_name,
Exception_Message returns implementation-defined information about the
exception occurrence. Reraise_Occurrence reraises the specified
exception occurrence.

@item
Exception_Identity returns the identity of the exception of the
occurrence.

@item
The Exception_Name functions return the full expanded name of the
exception, in upper case, starting with a root library unit. For an
exception declared immediately within package Standard, the
defining_identifier is returned. The result is implementation defined if
the exception is declared within an unnamed block_statement.

@item
Exception_Information returns implementation-defined information about
the exception occurrence.

@item
Raise_Exception and Reraise_Occurrence have no effect in the case of
Null_Id or Null_Occurrence. Exception_Message, Exception_Identity,
Exception_Name, and Exception_Information raise Constraint_Error for a
Null_Id or Null_Occurrence.

@item
The Save_Occurrence procedure copies the Source to the Target. The
Save_Occurrence function uses an allocator of type
Exception_Occurrence_Access to create a new object, copies the Source to
this new object, and returns an access value designating this new
object; the result may be deallocated using an instance of
Unchecked_Deallocation.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation of the Write attribute, see @ref{13.13.2}, of
Exception_Occurrence shall support writing a representation of an
exception occurrence to a stream; the implementation of the Read
attribute of Exception_Occurrence shall support reconstructing an
exception occurrence from a stream (including one written in a different
partition).

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation of Exception_Name in a space-constrained environment
may return the defining_identifier instead of the full expanded name.

@item
The string returned by Exception_Message may be truncated (to no less
than 200 characters) by the Save_Occurrence procedure (not the
function), the Reraise_Occurrence procedure, and the re-raise statement.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Exception_Message (by default) and Exception_Information should produce
information useful for debugging. Exception_Message should be short
(about one line), whereas Exception_Information can be long.
Exception_Message should not include the Exception_Name.
Exception_Information should include both the Exception_Name and the
Exception_Message.
@end enumerate

@c ---------------------------------------------------------------------------
@node 11.4.2, 11.5, 11.4.1, 11.4
@subsection Example of Exception Handling

@need 1000
@sp 1
@center @emph{Examples}

@enumerate
@item
Exception handling may be used to separate the detection of an error
from the response to that error:

@item
@example
with Ada.Exceptions;
use Ada;
package File_System is
    type File_Handle is limited private;
@end example

@item
@example
    File_Not_Found : exception;
    procedure Open(F : in out File_Handle; Name : String);
    --  raises File_Not_Found if named file does not exist
@end example

@item
@example
    End_Of_File : exception;
    procedure Read(F : in out File_Handle; Data : out Data_Type);
    --  raises End_Of_File if the file is not open
@end example

@item
@example
    ...
end File_System;
@end example

@item
@example
package body File_System is
    procedure Open(F : in out File_Handle; Name : String) is
    begin
        if File_Exists(Name) then
            ...
        else
            Exceptions.Raise_Exception
              (File_Not_Found'Identity,
               "File not found: " & Name & ".");
        end if;
    end Open;
@end example

@item
@example
    procedure Read(F : in out File_Handle; Data : out Data_Type) is
    begin
        if F.Current_Position <= F.Last_Position then
            ...
        else
            raise End_Of_File;
        end if;
    end Read;
@end example

@item
@example
    ...
@end example

@item
@example
end File_System;
@end example

@item
@example
with Ada.Text_IO;
with Ada.Exceptions;
with File_System; use File_System;
use Ada;
procedure Main is
begin
    ... -- call operations in File_System
exception
    when End_Of_File =>
        Close(Some_File);
    when Not_Found_Error : File_Not_Found =>
        Text_IO.Put_Line
          (Exceptions.Exception_Message(Not_Found_Error));
    when The_Error : others =>
        Text_IO.Put_Line("Unknown error:");
        if Verbosity_Desired then
            Text_IO.Put_Line(Exceptions.Exception_Information
              (The_Error));
        else
            Text_IO.Put_Line(Exceptions.Exception_Name
              (The_Error));
            Text_IO.Put_Line(Exceptions.Exception_Message
              (The_Error));
        end if;
        raise;
end Main;
@end example

@item
In the above example, the File_System package contains information about
detecting certain exceptional situations, but it does not specify how to
handle those situations. Procedure Main specifies how to handle them;
other clients of File_System might have different handlers, even though
the exceptional situations arise from the same basic causes.
@end enumerate

@c ---------------------------------------------------------------------------
@node 11.5, 11.6, 11.4.2, 11
@section Suppressing Checks

@enumerate
@item
A pragma Suppress gives permission to an implementation to omit certain
language-defined checks.

@item
A language-defined check (or simply, a ``check'') is one of the
situations defined by this International Standard that requires a check
to be made at run time to determine whether some condition is true. A
check fails when the condition being checked is false, causing an
exception to be raised.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Suppress is as follows:

@item
@example
pragma Suppress(identifier [, [On =>] name]);
@end example

@enumerate 5
@item
A pragma Suppress is allowed only immediately within a declarative_part,
immediately within a package_specification, or as a configuration
pragma.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 6
@item
The identifier shall be the name of a check. The name (if present) shall
statically denote some entity.

@item
For a pragma Suppress that is immediately within a package_specification
and includes a name, the name shall denote an entity (or several
overloaded subprograms) declared immediately within the
package_specification.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A pragma Suppress gives permission to an implementation to omit the
named check from the place of the pragma to the end of the innermost
enclosing declarative region, or, if the pragma is given in a
package_specification and includes a name, to the end of the scope of
the named entity. If the pragma includes a name, the permission applies
only to checks performed on the named entity, or, for a subtype, on
objects and values of its type. Otherwise, the permission applies to all
entities. If permission has been given to suppress a given check, the
check is said to be suppressed.

@item
The following are the language-defined checks:

@enumerate 10
@item
The following checks correspond to situations in which the exception
Constraint_Error is raised upon failure.

@enumerate 11
@item
Access_Check

@example
When evaluating a dereference (explicit or
implicit), check that the value of the name is
not null. When passing an actual parameter to a
formal access parameter, check that the value of
the actual parameter is not null.
@end example

@item
Discriminant_Check

@example
Check that the discriminants of a composite value
have the values imposed by a discriminant
constraint. Also, when accessing a record
component, check that it exists for the current
discriminant values.
@end example

@item
Division_Check

@example
Check that the second operand is not zero for the
operations /, rem and mod.
@end example

@item
Index_Check

@example
Check that the bounds of an array value are equal
to the corresponding bounds of an index
constraint. Also, when accessing a component of
an array object, check for each dimension that
the given index value belongs to the range
defined by the bounds of the array object. Also,
when accessing a slice of an array object, check
that the given discrete range is compatible with
the range defined by the bounds of the array
object.
@end example

@item
Length_Check

@example
Check that two arrays have matching components,
in the case of array subtype conversions, and
logical operators for arrays of boolean
components.
@end example

@item
Overflow_Check

@example
Check that a scalar value is within the base
range of its type, in cases where the
implementation chooses to raise an exception
instead of returning the correct mathematical
result.
@end example

@item
Range_Check

@example
Check that a scalar value satisfies a range
constraint. Also, for the elaboration of a
subtype_indication, check that the constraint (if
present) is compatible with the subtype denoted
by the subtype_mark. Also, for an aggregate,
check that an index or discriminant value belongs
to the corresponding subtype. Also, check that
when the result of an operation yields an array,
the value of each component belongs to the
component subtype.
@end example

@item
Tag_Check

@example
Check that operand tags in a dispatching call are
all equal. Check for the correct tag on tagged
type conversions, for an assignment_statement,
and when returning a tagged limited object from a
function.
@end example
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 19
@item
The following checks correspond to situations in which the exception
Program_Error is raised upon failure.

@enumerate 20
@item
Elaboration_Check

@example
When a subprogram or protected entry is called, a
task activation is accomplished, or a generic
instantiation is elaborated, check that the body
of the corresponding unit has already been
elaborated.
@end example

@item
Accessibility_Check

@example
Check the accessibility level of an entity or
view.
@end example
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 22
@item
The following check corresponds to situations in which the exception
Storage_Error is raised upon failure.

@enumerate 23
@item
Storage_Check

@example
Check that evaluation of an allocator does not
require more space than is available for a
storage pool. Check that the space available for
a task or subprogram has not been exceeded.
@end example
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 24
@item
The following check corresponds to all situations in which any
predefined exception is raised.

@enumerate 25
@item
All_Checks

@example
Represents the union of all checks; suppressing
All_Checks suppresses all checks.
@end example
@end enumerate
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@enumerate 26
@item
If a given check has been suppressed, and the corresponding error
situation occurs, the execution of the program is erroneous.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation is allowed to place restrictions on Suppress pragmas.
An implementation is allowed to add additional check names, with
implementation-defined semantics. When Overflow_Check has been
suppressed, an implementation may also suppress an unspecified subset of
the Range_Checks.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The implementation should minimize the code executed for checks that
have been suppressed.

NOTES

@item
(2) There is no guarantee that a suppressed check is actually removed;
hence a pragma Suppress should be used only for efficiency reasons.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of suppressing checks:

@item
@example
pragma Suppress(Range_Check);
pragma Suppress(Index_Check, On => Table);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 11.6, 12, 11.5, 11
@section Exceptions and Optimization

@enumerate
@item
This clause gives permission to the implementation to perform certain
``optimizations'' that do not necessarily preserve the canonical
semantics.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The rest of this International Standard (outside this clause) defines
the canonical semantics of the language. The canonical semantics of a
given (legal) program determines a set of possible external effects that
can result from the execution of the program with given inputs.

@item
As explained in @ref{1.1.3, ``Conformity of an Implementation With the
Standard''}, the external effect of a program is defined in terms of its
interactions with its external environment. Hence, the implementation
can perform any internal actions whatsoever, in any order or in
parallel, so long as the external effect of the execution of the program
is one that is allowed by the canonical semantics, or by the rules of
this clause.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The following additional permissions are granted to the implementation:

@enumerate 5
@item
An implementation need not always raise an exception when a
language-defined check fails. Instead, the operation that failed the
check can simply yield an undefined result. The exception need be raised
by the implementation only if, in the absence of raising it, the value
of this undefined result would have some effect on the external
interactions of the program. In determining this, the implementation
shall not presume that an undefined result has a value that belongs to
its subtype, nor even to the base range of its type, if scalar. Having
removed the raise of the exception, the canonical semantics will in
general allow the implementation to omit the code for the check, and
some or all of the operation itself.

@item
If an exception is raised due to the failure of a language-defined
check, then upon reaching the corresponding exception_handler (or the
termination of the task, if none), the external interactions that have
occurred need reflect only that the exception was raised somewhere
within the execution of the sequence_of_statements with the handler (or
the task_body), possibly earlier (or later if the interactions are
independent of the result of the checked operation) than that defined by
the canonical semantics, but not within the execution of some
abort-deferred operation or independent subprogram that does not
dynamically enclose the execution of the construct whose check failed.
An independent subprogram is one that is defined outside the library
unit containing the construct whose check failed, and has no Inline
pragma applied to it. Any assignment that occurred outside of such
abort-deferred operations or independent subprograms can be disrupted by
the raising of the exception, causing the object or its parts to become
abnormal, and certain subsequent uses of the object to be erroneous, as
explained in @ref{13.9.1}.
@end enumerate
@end enumerate
@enumerate 7

NOTES

@item
(3) The permissions granted by this clause can have an effect on the
semantics of a program only if the program fails a language-defined
check.
@end enumerate

@c ===========================================================================
@node 12, 12.1, 11.6, Top
@chapter Generic Units

@enumerate
@item
A generic unit is a program unit that is either a generic subprogram or
a generic package. A generic unit is a template, which can be
parameterized, and from which corresponding (nongeneric) subprograms or
packages can be obtained. The resulting program units are said to be
instances of the original generic unit.

@item
A generic unit is declared by a generic_declaration. This form of
declaration has a generic_formal_part declaring any generic formal
parameters. An instance of a generic unit is obtained as the result of a
generic_instantiation with appropriate generic actual parameters for the
generic formal parameters. An instance of a generic subprogram is a
subprogram. An instance of a generic package is a package.

@item
Generic units are templates. As templates they do not have the
properties that are specific to their nongeneric counterparts. For
example, a generic subprogram can be instantiated but it cannot be
called. In contrast, an instance of a generic subprogram is a
(nongeneric) subprogram; hence, this instance can be called but it
cannot be used to produce further instances.
@end enumerate

@menu
* 12.1:: Generic Declarations
* 12.2:: Generic Bodies
* 12.3:: Generic Instantiation
* 12.4:: Formal Objects
* 12.5:: Formal Types
* 12.6:: Formal Subprograms
* 12.7:: Formal Packages
* 12.8:: Example of a Generic Package

 --- The Detailed Node Listing ---

* 12.1::   Generic Declarations
* 12.2::   Generic Bodies
* 12.3::   Generic Instantiation
* 12.4::   Formal Objects
* 12.5::   Formal Types
* 12.5.1:: Formal Private and Derived Types
* 12.5.2:: Formal Scalar Types
* 12.5.3:: Formal Array Types
* 12.5.4:: Formal Access Types
* 12.6::   Formal Subprograms
* 12.7::   Formal Packages
* 12.8::   Example of a Generic Package
@end menu

@c ---------------------------------------------------------------------------
@node 12.1, 12.2, 12, 12
@section Generic Declarations

@enumerate
@item
A generic_declaration declares a generic unit, which is either a generic
subprogram or a generic package. A generic_declaration includes a
generic_formal_part declaring any generic formal parameters. A generic
formal parameter can be an object; alternatively (unlike a parameter of
a subprogram), it can be a type, a subprogram, or a package.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
generic_declaration ::=
   generic_subprogram_declaration | generic_package_declaration
@end example

@item
@example
generic_subprogram_declaration ::=
   generic_formal_part subprogram_specification;
@end example

@item
@example
generic_package_declaration ::=
   generic_formal_part package_specification;
@end example

@item
@example
generic_formal_part ::=
   generic @{generic_formal_parameter_declaration | use_clause@}
@end example

@item
@example
generic_formal_parameter_declaration ::=
      formal_object_declaration
    | formal_type_declaration
    | formal_subprogram_declaration
    | formal_package_declaration
@end example

@enumerate 7
@item
The only form of subtype_indication allowed within a generic_formal_part
is a subtype_mark (that is, the subtype_indication shall not include an
explicit constraint). The defining name of a generic subprogram shall be
an identifier (not an operator_symbol).
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 8
@item
A generic_declaration declares a generic unit -- a generic package,
generic procedure or generic function, as appropriate.

@item
An entity is a generic formal entity if it is declared by a
generic_formal_parameter_declaration. ``Generic formal,'' or simply
``formal,'' is used as a prefix in referring to objects, subtypes (and
types), functions, procedures and packages, that are generic formal
entities, as well as to their respective declarations. Examples:
``generic formal procedure'' or a ``formal integer type declaration.''

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a generic_declaration has no effect.

NOTES

@item
(1) Outside a generic unit a name that denotes the generic_declaration
denotes the generic unit. In contrast, within the declarative region of
the generic unit, a name that denotes the generic_declaration denotes
the current instance.

@item
(2) Within a generic subprogram_body, the name of this program unit acts
as the name of a subprogram. Hence this name can be overloaded, and it
can appear in a recursive call of the current instance. For the same
reason, this name cannot appear after the reserved word new in a
(recursive) generic_instantiation.

@item
(3) A default_expression or default_name appearing in a
generic_formal_part is not evaluated during elaboration of the
generic_formal_part; instead, it is evaluated when used. (The usual
visibility rules apply to any name used in a default: the denoted
declaration therefore has to be visible at the place of the expression.)

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of generic formal parts:

@item
@example
generic     --  parameterless
@end example

@item
@example
generic
    Size : Natural;  --  formal object
@end example

@item
@example
generic
   Length : Integer := 200;
   --  formal object with a default expression
@end example

@item
@example
   Area : Integer := Length*Length;
   --  formal object with a default expression
@end example

@item
@example
generic
   type Item  is private;                        -- formal type
   type Index is (<>);                           -- formal type
   type Row   is array(Index range <>) of Item;  -- formal type
   with function "<"(X, Y : Item) return Boolean;
   --  formal subprogram
@end example

@item
Examples of generic declarations declaring generic subprograms Exchange
and Squaring:

@item
@example
generic
   type Elem is private;
procedure Exchange(U, V : in out Elem);
@end example

@item
@example
generic
   type Item is private;
   with function "*"(U, V : Item) return Item is <>;
function Squaring(X : Item) return Item;
@end example

@item
Example of a generic declaration declaring a generic package:

@item
@example
generic
   type Item   is private;
   type Vector is array (Positive range <>) of Item;
   with function Sum(X, Y : Item) return Item;
package On_Vectors is
   function Sum  (A, B : Vector) return Vector;
   function Sigma(A    : Vector) return Item;
   Length_Error : exception;
end On_Vectors;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.2, 12.3, 12.1, 12
@section Generic Bodies

@enumerate
@item
The body of a generic unit (a generic body) is a template for the
instance bodies. The syntax of a generic body is identical to that of a
nongeneric body.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The elaboration of a generic body has no other effect than to establish
that the generic unit can from then on be instantiated without failing
the Elaboration_Check. If the generic body is a child of a generic
package, then its elaboration establishes that each corresponding
declaration nested in an instance of the parent, see @ref{10.1.1}, can from
then on be instantiated without failing the Elaboration_Check.

NOTES

@item
(4) The syntax of generic subprograms implies that a generic subprogram
body is always the completion of a declaration.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a generic procedure body:

@item
@example
procedure Exchange(U, V : in out Elem) is  --  see @ref{12.1}
   T : Elem;  --  the generic formal type
begin
   T := U;
   U := V;
   V := T;
end Exchange;
@end example

@item
Example of a generic function body:

@item
@example
function Squaring(X : Item) return Item is  --  see @ref{12.1}
begin
   return X*X;  --  the formal operator "*"
end Squaring;
@end example

@item
Example of a generic package body:

@item
@example
package body On_Vectors is  --  see @ref{12.1}
@end example

@item
@example
   function Sum(A, B : Vector) return Vector is
      Result : Vector(A'Range); --  the formal type Vector
      Bias   : constant Integer := B'First - A'First;
   begin
      if A'Length /= B'Length then
         raise Length_Error;
      end if;
@end example

@item
@example
      for N in A'Range loop
         Result(N) := Sum(A(N), B(N + Bias));
         --  the formal function Sum
      end loop;
      return Result;
   end Sum;
@end example

@item
@example
   function Sigma(A : Vector) return Item is
      Total : Item := A(A'First); --  the formal type Item
   begin
      for N in A'First + 1 .. A'Last loop
         Total := Sum(Total, A(N)); --  the formal function Sum
      end loop;
      return Total;
   end Sigma;
end On_Vectors;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.3, 12.4, 12.2, 12
@section Generic Instantiation

@enumerate
@item
An instance of a generic unit is declared by a generic_instantiation.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
generic_instantiation ::=
     package defining_program_unit_name is
       new generic_package_name [generic_actual_part];
   | procedure defining_program_unit_name is
       new generic_procedure_name [generic_actual_part];
   | function defining_designator is
       new generic_function_name [generic_actual_part];
@end example

@item
@example
generic_actual_part ::=
   (generic_association @{, generic_association@})
@end example

@item
@example
generic_association ::=
   [generic_formal_parameter_selector_name =>]
      explicit_generic_actual_parameter
@end example

@item
@example
explicit_generic_actual_parameter ::= expression | variable_name
   | subprogram_name | entry_name | subtype_mark
   | package_instance_name
@end example

@enumerate 6
@item
A generic_association is named or positional according to whether or not
the generic_formal_parameter_selector_name is specified. Any positional
associations shall precede any named associations.
@end enumerate
@end enumerate

@enumerate 7
@item
The generic actual parameter is either the
explicit_generic_actual_parameter given in a
generic_parameter_association for each formal, or the corresponding
default_expression or default_name if no generic_parameter_association
is given for the formal. When the meaning is clear from context, the
term ``generic actual,'' or simply ``actual,'' is used as a synonym for
``generic actual parameter'' and also for the view denoted by one, or
the value of one.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
In a generic_instantiation for a particular kind of program unit
(package, procedure, or function), the name shall denote a generic unit
of the corresponding kind (generic package, generic procedure, or
generic function, respectively).

@item
The generic_formal_parameter_selector_name of a generic_association
shall denote a generic_formal_parameter_declaration of the generic unit
being instantiated. If two or more formal subprograms have the same
defining name, then named associations are not allowed for the
corresponding actuals.

@item
A generic_instantiation shall contain at most one generic_association
for each formal. Each formal without an association shall have a
default_expression or subprogram_default.

@item
In a generic unit Legality Rules are enforced at compile time of the
generic_declaration and generic body, given the properties of the
formals. In the visible part and formal part of an instance, Legality
Rules are enforced at compile time of the generic_instantiation, given
the properties of the actuals. In other parts of an instance, Legality
Rules are not enforced; this rule does not apply when a given rule
explicitly specifies otherwise.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A generic_instantiation declares an instance; it is equivalent to the
instance declaration (a package_declaration or subprogram_declaration)
immediately followed by the instance body, both at the place of the
instantiation.

@item
The instance is a copy of the text of the template. Each use of a formal
parameter becomes (in the copy) a use of the actual, as explained below.
An instance of a generic package is a package, that of a generic
procedure is a procedure, and that of a generic function is a function.

@item
The interpretation of each construct within a generic declaration or
body is determined using the overloading rules when that generic
declaration or body is compiled. In an instance, the interpretation of
each (copied) construct is the same, except in the case of a name that
denotes the generic_declaration or some declaration within the generic
unit; the corresponding name in the instance then denotes the
corresponding copy of the denoted declaration. The overloading rules do
not apply in the instance.

@item
In an instance, a generic_formal_parameter_declaration declares a view
whose properties are identical to those of the actual, except as
specified in @ref{12.4, ``Formal Objects''}, and @ref{12.6, ``Formal
Subprograms''}. Similarly, for a declaration within a
generic_formal_parameter_declaration, the corresponding declaration in
an instance declares a view whose properties are identical to the
corresponding declaration within the declaration of the actual.

@item
Implicit declarations are also copied, and a name that denotes an
implicit declaration in the generic denotes the corresponding copy in
the instance. However, for a type declared within the visible part of
the generic, a whole new set of primitive subprograms is implicitly
declared for use outside the instance, and may differ from the copied
set if the properties of the type in some way depend on the properties
of some actual type specified in the instantiation. For example, if the
type in the generic is derived from a formal private type, then in the
instance the type will inherit subprograms from the corresponding actual
type.

@item
These new implicit declarations occur immediately after the type
declaration in the instance, and override the copied ones. The copied
ones can be called only from within the instance; the new ones can be
called only from outside the instance, although for tagged types, the
body of a new one can be executed by a call to an old one.

@item
In the visible part of an instance, an explicit declaration overrides an
implicit declaration if they are homographs, as described in @ref{8.3}.
On the other hand, an explicit declaration in the private part of an
instance overrides an implicit declaration in the instance, only if the
corresponding explicit declaration in the generic overrides a
corresponding implicit declaration in the generic. Corresponding rules
apply to the other kinds of overriding described in @ref{8.3}.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
Recursive generic instantiation is not allowed in the following sense:
if a given generic unit includes an instantiation of a second generic
unit, then the instance generated by this instantiation shall not
include an instance of the first generic unit (whether this instance is
generated directly, or indirectly by intermediate instantiations).

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the elaboration of a generic_instantiation, each generic_association
is first evaluated. If a default is used, an implicit
generic_association is assumed for this rule. These evaluations are done
in an arbitrary order, except that the evaluation for a default actual
takes place after the evaluation for another actual if the default
includes a name that denotes the other one. Finally, the instance
declaration and body are elaborated.

@item
For the evaluation of a generic_association the generic actual parameter
is evaluated. Additional actions are performed in the case of a formal
object of mode in, see @ref{12.4}.

NOTES

@item
(5) If a formal type is not tagged, then the type is treated as an
untagged type within the generic body. Deriving from such a type in a
generic body is permitted; the new type does not get a new tag value,
even if the actual is tagged. Overriding operations for such a derived
type cannot be dispatched to from outside the instance.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of generic instantiations, see @ref{12.1}

@item
@example
procedure Swap is new Exchange(Elem => Integer);
procedure Swap is new Exchange(Character);
--  Swap is overloaded
function Square is new Squaring(Integer);
--  "*" of Integer used by default
function Square is new Squaring
  (Item => Matrix, "*" => Matrix_Product);
function Square is new Squaring
  (Matrix, Matrix_Product); -- same as previous
@end example

@item
@example
package Int_Vectors is new On_Vectors(Integer, Table, "+");
@end example

@item
Examples of uses of instantiated units:

@item
@example
Swap(A, B);
A := Square(A);
@end example

@item
@example
T : Table(1 .. 5) := (10, 20, 30, 40, 50);
N : Integer := Int_Vectors.Sigma(T);
--  150 (see @ref{12.2, ``Generic Bodies''}, for the body of Sigma)
@end example

@item
@example
use Int_Vectors;
M : Integer := Sigma(T);  --  150
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.4, 12.5, 12.3, 12
@section Formal Objects

@enumerate
@item
A generic formal object can be used to pass a value or variable to a
generic unit.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_object_declaration ::=
   defining_identifier_list : mode subtype_mark
     [:= default_expression];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for the default_expression, if any, of a formal object
is the type of the formal object.

@item
For a generic formal object of mode in, the expected type for the actual
is the type of the formal.

@item
For a generic formal object of mode in out, the type of the actual shall
resolve to the type of the formal.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If a generic formal object has a default_expression, then the mode shall
be in (either explicitly or by default); otherwise, its mode shall be
either in or in out.

@item
For a generic formal object of mode in, the actual shall be an
expression. For a generic formal object of mode in out, the actual shall
be a name that denotes a variable for which renaming is allowed
(@pxref{8.5.1}).

@item
The type of a generic formal object of mode in shall be nonlimited.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A formal_object_declaration declares a generic formal object. The
default mode is in. For a formal object of mode in, the nominal subtype
is the one denoted by the subtype_mark in the declaration of the formal.
For a formal object of mode in out, its type is determined by the
subtype_mark in the declaration; its nominal subtype is nonstatic, even
if the subtype_mark denotes a static subtype.

@item
In an instance, a formal_object_declaration of mode in declares a new
stand-alone constant object whose initialization expression is the
actual, whereas a formal_object_declaration of mode in out declares a
view whose properties are identical to those of the actual.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the evaluation of a generic_association for a formal object of mode
in, a constant object is created, the value of the actual parameter is
converted to the nominal subtype of the formal object, and assigned to
the object, including any value adjustment --  see @ref{7.6}.

NOTES

@item
(6) The constraints that apply to a generic formal object of mode in out
are those of the corresponding generic actual parameter (not those
implied by the subtype_mark that appears in the
formal_object_declaration). Therefore, to avoid confusion, it is
recommended that the name of a first subtype be used for the declaration
of such a formal object.
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.5, 12.5.1, 12.4, 12
@section Formal Types

@enumerate
@item
A generic formal subtype can be used to pass to a generic unit a subtype
whose type is in a certain class of types.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_type_declaration ::=
   type defining_identifier[discriminant_part] is
     formal_type_definition;
@end example

@item
@example
formal_type_definition ::=
     formal_private_type_definition
   | formal_derived_type_definition
   | formal_discrete_type_definition
   | formal_signed_integer_type_definition
   | formal_modular_type_definition
   | formal_floating_point_definition
   | formal_ordinary_fixed_point_definition
   | formal_decimal_fixed_point_definition
   | formal_array_type_definition
   | formal_access_type_definition
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
For a generic formal subtype, the actual shall be a subtype_mark; it
denotes the (generic) actual subtype.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A formal_type_declaration declares a (generic) formal type, and its
first subtype, the (generic) formal subtype.

@item
The form of a formal_type_definition determines a class to which the
formal type belongs. For a formal_private_type_definition the reserved
words tagged and limited indicate the class, see @ref{12.5.1}. For a
formal_derived_type_definition the class is the derivation class rooted
at the ancestor type. For other formal types, the name of the syntactic
category indicates the class; a formal_discrete_type_definition defines
a discrete type, and so on.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The actual type shall be in the class determined for the formal.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The formal type also belongs to each class that contains the determined
class. The primitive subprograms of the type are as for any type in the
determined class. For a formal type other than a formal derived type,
these are the predefined operators of the type; they are implicitly
declared immediately after the declaration of the formal type. In an
instance, the copy of such an implicit declaration declares a view of
the predefined operator of the actual type, even if this operator has
been overridden for the actual type. The rules specific to formal
derived types are given in @ref{12.5.1}.

NOTES

@item
(7) Generic formal types, like all types, are not named. Instead, a name
can denote a generic formal subtype. Within a generic unit, a generic
formal type is considered as being distinct from all other (formal or
nonformal) types.

@item
(8) A discriminant_part is allowed only for certain kinds of types, and
therefore only for certain kinds of generic formal types (@pxref{3.7}).

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of generic formal types:

@item
@example
type Item is private;
type Buffer(Length : Natural) is limited private;
@end example

@item
@example
type Enum  is (<>);
type Int   is range <>;
type Angle is delta <>;
type Mass  is digits <>;
@end example

@item
@example
type Table is array (Enum) of Item;
@end example

@item
Example of a generic formal part declaring a formal integer type:

@item
@example
generic
   type Rank is range <>;
   First  : Rank := Rank'First;
   Second : Rank := First + 1;
   --  the operator "+" of the type Rank
@end example
@end enumerate

@menu
* 12.5.1:: Formal Private and Derived Types
* 12.5.2:: Formal Scalar Types
* 12.5.3:: Formal Array Types
* 12.5.4:: Formal Access Types
@end menu

@c ---------------------------------------------------------------------------
@node 12.5.1, 12.5.2, 12.5, 12.5
@subsection Formal Private and Derived Types

@enumerate
@item
The class determined for a formal private type can be either limited or
nonlimited, and either tagged or untagged; no more specific class is
known for such a type. The class determined for a formal derived type is
the derivation class rooted at the ancestor type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_private_type_definition ::=
   [[abstract] tagged] [limited] private
@end example

@item
@example
formal_derived_type_definition ::=
   [abstract] new subtype_mark [with private]
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If a generic formal type declaration has a known_discriminant_part, then
it shall not include a default_expression for a discriminant.

@item
The ancestor subtype of a formal derived type is the subtype denoted by
the subtype_mark of the formal_derived_type_definition. For a formal
derived type declaration, the reserved words with private shall appear
if and only if the ancestor type is a tagged type; in this case the
formal derived type is a private extension of the ancestor type and the
ancestor shall not be a class-wide type. Similarly, the optional
reserved word abstract shall appear only if the ancestor type is a
tagged type.

@item
If the formal subtype is definite, then the actual subtype shall also be
definite.

@item
For a generic formal derived type with no discriminant_part:

@enumerate 8
@item
If the ancestor subtype is constrained, the actual subtype shall be
constrained, and shall be statically compatible with the ancestor;

@item
If the ancestor subtype is an unconstrained access or composite subtype,
the actual subtype shall be unconstrained.

@item
If the ancestor subtype is an unconstrained discriminated subtype, then
the actual shall have the same number of discriminants, and each
discriminant of the actual shall correspond to a discriminant of the
ancestor, in the sense of @ref{3.7}.
@end enumerate
@end enumerate

@enumerate 11
@item
The declaration of a formal derived type shall not have a
known_discriminant_part. For a generic formal private type with a
known_discriminant_part:

@enumerate 12
@item
The actual type shall be a type with the same number of discriminants.

@item
The actual subtype shall be unconstrained.

@item
The subtype of each discriminant of the actual type shall statically
match the subtype of the corresponding discriminant of the formal type.
@end enumerate
@end enumerate

@enumerate 15
@item
For a generic formal type with an unknown_discriminant_part, the actual
may, but need not, have discriminants, and may be definite or
indefinite.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The class determined for a formal private type is as follows:

@item
@example
Type Definition         Determined Class

limited private         the class of all types
private                 the class of all nonlimited types
tagged limited private  the class of all tagged types
tagged private          the class of all nonlimited tagged types
@end example

@item
The presence of the reserved word abstract determines whether the actual
type may be abstract.

@item
A formal private or derived type is a private or derived type,
respectively. A formal derived tagged type is a private extension. A
formal private or derived type is abstract if the reserved word abstract
appears in its declaration.

@item
If the ancestor type is a composite type that is not an array type, the
formal type inherits components from the ancestor type (including
discriminants if a new discriminant_part is not specified), as for a
derived type defined by a derived_type_definition, see @ref{3.4}.

@item
For a formal derived type, the predefined operators and inherited
user-defined subprograms are determined by the ancestor type, and are
implicitly declared at the earliest place, if any, within the immediate
scope of the formal type, where the corresponding primitive subprogram
of the ancestor is visible, see @ref{7.3.1}. In an instance, the copy of
such an implicit declaration declares a view of the corresponding
primitive subprogram of the ancestor, even if this primitive has been
overridden for the actual type. In the case of a formal private
extension, however, the tag of the formal type is that of the actual
type, so if the tag in a call is statically determined to be that of the
formal type, the body executed will be that corresponding to the actual
type.

@item
For a prefix S that denotes a formal indefinite subtype, the following
attribute is defined:

@item
S'Definite

@example
S'Definite yields True if the actual subtype corresponding to
S is definite; otherwise it yields False. The value of this
attribute is of the predefined type Boolean.
@end example

NOTES

@item
(9) In accordance with the general rule that the actual type shall
belong to the class determined for the formal, see @ref{12.5, ``Formal
Types''}.:

@enumerate 25
@item
If the formal type is nonlimited, then so shall be the actual;

@item
For a formal derived type, the actual shall be in the class rooted at
the ancestor subtype.
@end enumerate
@end enumerate

@enumerate 27
@item
(10) The actual type can be abstract only if the formal type is abstract
      (@pxref{3.9.3}).

@item
(11) If the formal has a discriminant_part, the actual can be either
definite or indefinite. Otherwise, the actual has to be definite.
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.5.2, 12.5.3, 12.5.1, 12.5
@subsection Formal Scalar Types

@enumerate
@item
A formal scalar type is one defined by any of the
formal_type_definitions in this subclause. The class determined for a
formal scalar type is discrete, signed integer, modular, floating point,
ordinary fixed point, or decimal.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_discrete_type_definition ::= (<>)
@end example

@item
@example
formal_signed_integer_type_definition ::= range <>
@end example

@item
@example
formal_modular_type_definition ::= mod <>
@end example

@item
@example
formal_floating_point_definition ::= digits <>
@end example

@item
@example
formal_ordinary_fixed_point_definition ::= delta <>
@end example

@item
@example
formal_decimal_fixed_point_definition ::= delta <> digits <>
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The actual type for a formal scalar type shall not be a nonstandard
numeric type.

NOTES

@item
(12) The actual type shall be in the class of types implied by the
syntactic category of the formal type definition, see @ref{12.5, ``Formal
Types''}. For example, the actual for a formal_modular_type_definition
shall be a modular type.
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.5.3, 12.5.4, 12.5.2, 12.5
@subsection Formal Array Types

@enumerate
@item
The class determined for a formal array type is the class of all array
types.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_array_type_definition ::= array_type_definition
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The only form of discrete_subtype_definition that is allowed within the
declaration of a generic formal (constrained) array subtype is a
subtype_mark.

@item
For a formal array subtype, the actual subtype shall satisfy the
following conditions:

@enumerate 5
@item
The formal array type and the actual array type shall have the same
dimensionality; the formal subtype and the actual subtype shall be
either both constrained or both unconstrained.

@item
For each index position, the index types shall be the same, and the
index subtypes (if unconstrained), or the index ranges (if constrained),
shall statically match, see @ref{4.9.1}.

@item
The component subtypes of the formal and actual array types shall
statically match.

@item
If the formal type has aliased components, then so shall the actual.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Examples}

@enumerate 9
@item
Example of formal array types:

@item
@example
--  given the generic package
@end example

@item
@example
generic
   type Item   is private;
   type Index  is (<>);
   type Vector is array (Index range <>) of Item;
   type Table  is array (Index) of Item;
package P is
   ...
end P;
@end example

@item
@example
--  and the types
@end example

@item
@example
type Mix    is array (Color range <>) of Boolean;
type Option is array (Color) of Boolean;
@end example

@item
@example
--  then Mix can match Vector and Option can match Table
@end example

@item
@example
package R is new P(Item   => Boolean, Index => Color,
                   Vector => Mix,     Table => Option);
@end example

@item
@example
--  Note that Mix cannot match Table and Option cannot match Vector
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.5.4, 12.6, 12.5.3, 12.5
@subsection Formal Access Types

@enumerate
@item
The class determined for a formal access type is the class of all access
types.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_access_type_definition ::= access_type_definition
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
For a formal access-to-object type, the designated subtypes of the
formal and actual types shall statically match.

@item
If and only if the general_access_modifier constant applies to the
formal, the actual shall be an access-to-constant type. If the
general_access_modifier all applies to the formal, then the actual shall
be a general access-to-variable type, see @ref{3.10}.

@item
For a formal access-to-subprogram subtype, the designated profiles of
the formal and the actual shall be mode-conformant, and the calling
convention of the actual shall be protected if and only if that of the
formal is protected.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of formal access types:

@item
@example
--  the formal types of the generic package
@end example

@item
@example
generic
   type Node is private;
   type Link is access Node;
package P is
   ...
end P;
@end example

@item
@example
--  can be matched by the actual types
@end example

@item
@example
type Car;
type Car_Name is access Car;
@end example

@item
@example
type Car is
   record
      Pred, Succ : Car_Name;
      Number     : License_Number;
      Owner      : Person;
   end record;
@end example

@item
@example
--  in the following generic instantiation
@end example

@item
@example
package R is new P(Node => Car, Link => Car_Name);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.6, 12.7, 12.5.4, 12
@section Formal Subprograms

@enumerate
@item
Formal subprograms can be used to pass callable entities to a generic
unit.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_subprogram_declaration ::=
   with subprogram_specification [is subprogram_default];
@end example

@item
@example
subprogram_default ::= default_name | <>
@end example

@item
@example
default_name ::= name
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected profile for the default_name, if any, is that of the formal
subprogram.

@item
For a generic formal subprogram, the expected profile for the actual is
that of the formal subprogram.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The profiles of the formal and any named default shall be
mode-conformant.

@item
The profiles of the formal and actual shall be mode-conformant.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A formal_subprogram_declaration declares a generic formal subprogram.
The types of the formal parameters and result, if any, of the formal
subprogram are those determined by the subtype_marks given in the
formal_subprogram_declaration; however, independent of the particular
subtypes that are denoted by the subtype_marks, the nominal subtypes of
the formal parameters and result, if any, are defined to be nonstatic,
and unconstrained if of an array type (no applicable index constraint is
provided in a call on a formal subprogram). In an instance, a
formal_subprogram_declaration declares a view of the actual. The profile
of this view takes its subtypes and calling convention from the original
profile of the actual entity, while taking the formal parameter names
and default_expressions from the profile given in the
formal_subprogram_declaration. The view is a function or procedure,
never an entry.

@item
If a generic unit has a subprogram_default specified by a box, and the
corresponding actual parameter is omitted, then it is equivalent to an
explicit actual parameter that is a usage name identical to the defining
name of the formal.

NOTES

@item
(13) The matching rules for formal subprograms state requirements that
are similar to those applying to subprogram_renaming_declarations
(@pxref{8.5.4}). In particular, the name of a parameter of the formal
subprogram need not be the same as that of the corresponding parameter
of the actual subprogram; similarly, for these parameters,
default_expressions need not correspond.

@item
(14) The constraints that apply to a parameter of a formal subprogram
are those of the corresponding formal parameter of the matching actual
subprogram (not those implied by the corresponding subtype_mark in the
_specification of the formal subprogram). A similar remark applies to
the result of a function. Therefore, to avoid confusion, it is
recommended that the name of a first subtype be used in any declaration
of a formal subprogram.

@item
(15) The subtype specified for a formal parameter of a generic formal
subprogram can be any visible subtype, including a generic formal
subtype of the same generic_formal_part.

@item
(16) A formal subprogram is matched by an attribute of a type if the
attribute is a function with a matching specification. An enumeration
literal of a given type matches a parameterless formal function whose
result type is the given type.

@item
(17) A default_name denotes an entity that is visible or directly
visible at the place of the generic_declaration; a box used as a default
is equivalent to a name that denotes an entity that is directly visible
at the place of the _instantiation.

@item
(18) The actual subprogram cannot be abstract, see @ref{3.9.3}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of generic formal subprograms:

@item
@example
with function "+"(X, Y : Item) return Item is <>;
with function Image(X : Enum) return String is Enum'Image;
with procedure Update is Default_Update;
@end example

@item
@example
--  given the generic procedure declaration
@end example

@item
@example
generic
   with procedure Action (X : in Item);
procedure Iterate(Seq : in Item_Sequence);
@end example

@item
@example
--  and the procedure
@end example

@item
@example
procedure Put_Item(X : in Item);
@end example

@item
@example
--  the following instantiation is possible
@end example

@item
@example
procedure Put_List is new Iterate(Action => Put_Item);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.7, 12.8, 12.6, 12
@section Formal Packages

@enumerate
@item
Formal packages can be used to pass packages to a generic unit. The
formal_package_declaration declares that the formal package is an
instance of a given generic package. Upon instantiation, the actual
package has to be an instance of that generic package.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
formal_package_declaration ::=
   with package defining_identifier is new
     generic_package_name formal_package_actual_part;
@end example

@item
@example
formal_package_actual_part ::= (<>) | [generic_actual_part]
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The generic_package_name shall denote a generic package (the template
for the formal package); the formal package is an instance of the
template.

@item
The actual shall be an instance of the template. If the
formal_package_actual_part is (<>), then the actual may be any instance
of the template; otherwise, each actual parameter of the actual instance
shall match the corresponding actual parameter of the formal package
(whether the actual parameter is given explicitly or by default), as
follows:

@enumerate 6
@item
For a formal object of mode in the actuals match if they are static
expressions with the same value, or if they statically denote the same
constant, or if they are both the literal null.

@item
For a formal subtype, the actuals match if they denote statically
matching subtypes.

@item
For other kinds of formals, the actuals match if they statically
denote the same entity.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 9
@item
A formal_package_declaration declares a generic formal package.

@item
The visible part of a formal package includes the first list of
basic_declarative_items of the package_specification. In addition, if
the formal_package_actual_part is (<>), it also includes the
generic_formal_part of the template for the formal package.
@end enumerate

@c ---------------------------------------------------------------------------
@node 12.8, 13, 12.7, 12
@section Example of a Generic Package

@enumerate
@item
The following example provides a possible formulation of stacks by means
of a generic package. The size of each stack and the type of the stack
elements are provided as generic formal parameters.

@need 1000
@sp 1
@center @emph{Examples}

@end enumerate
@enumerate 3
@item
@example
generic
   Size : Positive;
   type Item is private;
package Stack is
   procedure Push(E : in  Item);
   procedure Pop (E : out Item);
   Overflow, Underflow : exception;
end Stack;
@end example

@item
@example
package body Stack is
@end example

@item
@example
   type Table is array (Positive range <>) of Item;
   Space : Table(1 .. Size);
   Index : Natural := 0;
@end example

@item
@example
   procedure Push(E : in Item) is
   begin
      if Index >= Size then
         raise Overflow;
      end if;
      Index := Index + 1;
      Space(Index) := E;
   end Push;
@end example

@item
@example
   procedure Pop(E : out Item) is
   begin
      if Index = 0 then
         raise Underflow;
      end if;
      E := Space(Index);
      Index := Index - 1;
   end Pop;
@end example

@item
@example
end Stack;
@end example

@item
Instances of this generic package can be obtained as follows:

@item
@example
package Stack_Int  is new Stack(Size => 200, Item => Integer);
package Stack_Bool is new Stack(100, Boolean);
@end example

@item
Thereafter, the procedures of the instantiated packages can be called as
follows:

@item
@example
Stack_Int.Push(N);
Stack_Bool.Push(True);
@end example

@item
Alternatively, a generic formulation of the type Stack can be given as
follows (package body omitted):

@item
@example
generic
   type Item is private;
package On_Stacks is
   type Stack(Size : Positive) is limited private;
   procedure Push(S : in out Stack; E : in  Item);
   procedure Pop (S : in out Stack; E : out Item);
   Overflow, Underflow : exception;
private
   type Table is array (Positive range <>) of Item;
   type Stack(Size : Positive) is
      record
         Space : Table(1 .. Size);
         Index : Natural := 0;
      end record;
end On_Stacks;
@end example

@item
In order to use such a package, an instance has to be created and
thereafter stacks of the corresponding type can be declared:

@item
@example
declare
   package Stack_Real is new On_Stacks(Real); use Stack_Real;
   S : Stack(100);
begin
   ...
   Push(S, 2.54);
   ...
end;
@end example
@end enumerate

@c ===========================================================================
@node 13, 13.1, 12.8, Top
@chapter Representation Issues

@enumerate
@item
This section describes features for querying and controlling aspects of
representation and for interfacing to hardware.
@end enumerate

@menu
* 13.1::  Representation Items
* 13.2::  Pragma Pack
* 13.3::  Representation Attributes
* 13.4::  Enumeration Representation Clauses
* 13.5::  Record Layout
* 13.6::  Change of Representation
* 13.7::  The Package System
* 13.8::  Machine Code Insertions
* 13.9::  Unchecked Type Conversions
* 13.10:: Unchecked Access Value Creation
* 13.11:: Storage Management
* 13.12:: Pragma Restrictions
* 13.13:: Streams
* 13.14:: Freezing Rules

 --- The Detailed Node Listing ---

* 13.1::    Representation Items
* 13.2::    Pragma Pack
* 13.3::    Representation Attributes
* 13.4::    Enumeration Representation Clauses
* 13.5::    Record Layout
* 13.5.1::  Record Representation Clauses
* 13.5.2::  Storage Place Attributes
* 13.5.3::  Bit Ordering
* 13.6::    Change of Representation
* 13.7::    The Package System
* 13.7.1::  The Package System.Storage_Elements
* 13.7.2::  The Package System.Address_To_Access_Conversions
* 13.8::    Machine Code Insertions
* 13.9::    Unchecked Type Conversions
* 13.9.1::  Data Validity
* 13.9.2::  The Valid Attribute
* 13.10::   Unchecked Access Value Creation
* 13.11::   Storage Management
* 13.11.1:: The Max_Size_In_Storage_Elements Attribute
* 13.11.2:: Unchecked Storage Deallocation
* 13.11.3:: Pragma Controlled
* 13.12::   Pragma Restrictions
* 13.13::   Streams
* 13.13.1:: The Package Streams
* 13.13.2:: Stream-Oriented Attributes
* 13.14::   Freezing Rules
@end menu

@c ---------------------------------------------------------------------------
@node 13.1, 13.2, 13, 13
@section Representation Items

@enumerate
@item
There are three kinds of representation items: representation_clauses,
component_clauses, and representation pragmas. Representation items
specify how the types and other entities of the language are to be
mapped onto the underlying machine. They can be provided to give more
efficient representation or to interface with features that are outside
the domain of the language (for example, peripheral hardware).
Representation items also specify other specifiable properties of
entities. A representation item applies to an entity identified by a
local_name, which denotes an entity declared local to the current
declarative region, or a library unit declared immediately preceding a
representation pragma in a compilation.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
representation_clause ::=
     attribute_definition_clause
   | enumeration_representation_clause
   | record_representation_clause
   | at_clause
@end example

@item
@example
local_name ::=
     direct_name
   | direct_name'attribute_designator
   | library_unit_name
@end example

@enumerate 4
@item
A representation pragma is allowed only at places where a
representation_clause or compilation_unit is allowed.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 5
@item
In a representation item, if the local_name is a direct_name, then it
shall resolve to denote a declaration (or, in the case of a pragma, one
or more declarations) that occurs immediately within the same
declarative_region as the representation item. If the local_name has an
attribute_designator, then it shall resolve to denote an
implementation-defined component, see @ref{13.5.1}, or a class-wide type
implicitly declared immediately within the same declarative_region as
the representation item. A local_name that is a library_unit_name (only
permitted in a representation pragma) shall resolve to denote the
library_item that immediately precedes (except for other pragmas) the
representation pragma.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The local_name of a representation_clause or representation pragma shall
statically denote an entity (or, in the case of a pragma, one or more
entities) declared immediately preceding it in a compilation, or within
the same declarative_part, package_specification, task_definition,
protected_definition, or record_definition as the representation item.
If a local_name denotes a local callable entity, it may do so through a
local subprogram_renaming_declaration (as a way to resolve ambiguity in
the presence of overloading); otherwise, the local_name shall not denote
a renaming_declaration.

@item
The representation of an object consists of a certain number of bits
(the size of the object). These are the bits that are normally read or
updated by the machine code when loading, storing, or operating-on the
value of the object. This includes some padding bits, when the size of
the object is greater than the size of its subtype. Such padding bits
are considered to be part of the representation of the object, rather
than being gaps between objects, if these bits are normally read and
updated.

@item
A representation item directly specifies an aspect of representation of
the entity denoted by the local_name, except in the case of a
type-related representation item, whose local_name shall denote a first
subtype, and which directly specifies an aspect of the subtype's type. A
representation item that names a subtype is either subtype-specific
(Size and Alignment clauses) or type-related (all others).
Subtype-specific aspects may differ for different subtypes of the same
type.

@item
A representation item that directly specifies an aspect of a subtype or
type shall appear after the type is completely defined, see @ref{3.11.1},
and before the subtype or type is frozen, see @ref{13.14}. If a
representation item is given that directly specifies an aspect of an
entity, then it is illegal to give another representation item that
directly specifies the same aspect of the entity.

@item
For an untagged derived type, no type-related representation items are
allowed if the parent type is a by-reference type, or has any
user-defined primitive subprograms.

@item
Representation aspects of a generic formal parameter are the same as
those of the actual. A type-related representation item is not allowed
for a descendant of a generic formal untagged type.

@item
A representation item that specifies the Size for a given subtype, or
the size or storage place for an object (including a component) of a
given subtype, shall allow for enough storage space to accommodate any
value of the subtype.

@item
A representation item that is not supported by the implementation is
illegal, or raises an exception at run time.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If two subtypes statically match, then their subtype-specific aspects
(Size and Alignment) are the same.

@item
A derived type inherits each type-related aspect of its parent type that
was directly specified before the declaration of the derived type, or
(in the case where the parent is derived) that was inherited by the
parent type from the grandparent type. A derived subtype inherits each
subtype-specific aspect of its parent subtype that was directly
specified before the declaration of the derived type, or (in the case
where the parent is derived) that was inherited by the parent subtype
from the grandparent subtype, but only if the parent subtype statically
matches the first subtype of the parent type. An inherited aspect of
representation is overridden by a subsequent representation item that
specifies the same aspect of the type or subtype.

@item
Each aspect of representation of an entity is as follows:

@enumerate 17
@item
If the aspect is specified for the entity, meaning that it is either
directly specified or inherited, then that aspect of the entity is as
specified, except in the case of Storage_Size, which specifies a
minimum.

@item
If an aspect of representation of an entity is not specified, it is
chosen by default in an unspecified manner.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 19
@item
For the elaboration of a representation_clause, any evaluable constructs
within it are evaluated.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may interpret aspects of representation in an
implementation-defined manner. An implementation may place
implementation-defined restrictions on representation items. A
recommended level of support is specified for representation items and
related features in each subclause. These recommendations are changed to
requirements for implementations that support the Systems Programming
Annex, see @ref{C.2, ``Required Representation Support''}.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The recommended level of support for all representation items is
qualified as follows:

@enumerate 22
@item
An implementation need not support representation items containing
nonstatic expressions, except that an implementation should support a
representation item for a given entity if each nonstatic expression in
the representation item is a name that statically denotes a constant
declared before the entity.

@item
An implementation need not support a specification for the Size for a
given composite subtype, nor the size or storage place for an object
(including a component) of a given composite subtype, unless the
constraints on the subtype and its composite subcomponents (if any) are
all static constraints.

@item
An aliased component, or a component whose type is by-reference, should
always be allocated at an addressable location.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.2, 13.3, 13.1, 13
@section Pragma Pack

@enumerate
@item
A pragma Pack specifies that storage minimization should be the main
criterion when selecting the representation of a composite type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Pack is as follows:

@item
@example
pragma Pack(first_subtype_local_name);
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The first_subtype_local_name of a pragma Pack shall denote a composite
subtype.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A pragma Pack specifies the packing aspect of representation; the type
(or the extension part) is said to be packed. For a type extension, the
parent part is packed as for the parent type, and a pragma Pack causes
packing only of the extension part.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If a type is packed, then the implementation should try to minimize
storage allocated to objects of the type, possibly at the expense of
speed of accessing components, subject to reasonable complexity in
addressing calculations.

@item
The recommended level of support for pragma Pack is:

@enumerate 8
@item
For a packed record type, the components should be packed as tightly as
possible subject to the Sizes of the component subtypes, and subject to
any record_representation_clause that applies to the type; the
implementation may, but need not, reorder components or cross aligned
word boundaries to improve the packing. A component whose Size is
greater than the word size may be allocated an integral number of words.

@item
For a packed array type, if the component subtype's Size is less than or
equal to the word size, and Component_Size is not specified for the
type, Component_Size should be less than or equal to the Size of the
component subtype, rounded up to the nearest factor of the word size.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.3, 13.4, 13.2, 13
@section Representation Attributes

@enumerate
@item
The values of certain implementation-dependent characteristics can be
obtained by interrogating appropriate representation attributes. Some of
these attributes are specifiable via an attribute_definition_clause.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
attribute_definition_clause ::=
     for local_name'attribute_designator use expression;
   | for local_name'attribute_designator use name;
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For an attribute_definition_clause that specifies an attribute that
denotes a value, the form with an expression shall be used. Otherwise,
the form with a name shall be used.

@item
For an attribute_definition_clause that specifies an attribute that
denotes a value or an object, the expected type for the expression or
name is that of the attribute. For an attribute_definition_clause that
specifies an attribute that denotes a subprogram, the expected profile
for the name is the profile required for the attribute. For an
attribute_definition_clause that specifies an attribute that denotes
some other kind of entity, the name shall resolve to denote an entity of
the appropriate kind.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
An attribute_designator is allowed in an attribute_definition_clause
only if this International Standard explicitly allows it, or for an
implementation-defined attribute if the implementation allows it. Each
specifiable attribute constitutes an aspect of representation.

@item
For an attribute_definition_clause that specifies an attribute that
denotes a subprogram, the profile shall be mode conformant with the one
required for the attribute, and the convention shall be Ada. Additional
requirements are defined for particular attributes.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A Size clause is an attribute_definition_clause whose
attribute_designator is Size. Similar definitions apply to the other
specifiable attributes.

@item
A storage element is an addressable element of storage in the machine. A
word is the largest amount of storage that can be conveniently and
efficiently manipulated by the hardware, given the implementation's
run-time model. A word consists of an integral number of storage
elements.

@item
The following attributes are defined:

@item
For a prefix X that denotes an object, program unit, or label:

@item
X'Address

@example
Denotes the address of the first of the storage elements
allocated to X. For a program unit or label, this value
refers to the machine code associated with the corresponding
body or statement. The value of this attribute is of type
System.Address.
@end example

@item
@example
Address may be specified for stand-alone objects and for
program units via an attribute_definition_clause.
@end example

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If an Address is specified, it is the programmer's responsibility to
ensure that the address is valid; otherwise, program execution is
erroneous.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
For an array X, X'Address should point at the first component of the
array, and not at the array bounds.

@item
The recommended level of support for the Address attribute is:

@enumerate 16
@item
X'Address should produce a useful result if X is an object that is
aliased or of a by-reference type, or is an entity whose Address has
been specified.

@item
An implementation should support Address clauses for imported
subprograms.

@item
Objects (including subcomponents) that are aliased or of a by-reference
type should be allocated on storage element boundaries.

@item
If the Address of an object is specified, or it is imported or exported,
then the implementation should not perform optimizations based on
assumptions of no aliases.
@end enumerate
@end enumerate
@enumerate 20

NOTES

@item
(1) The specification of a link name in a pragma Export, see @ref{B.1} for
a subprogram or object is an alternative to explicit specification of
its link-time address, allowing a link-time directive to place the
subprogram or object within memory.

@item
(2) The rules for the Size attribute imply, for an aliased object X,
that if X'Size = Storage_Unit, then X'Address points at a storage
element containing all of the bits of X, and only the bits of X.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a prefix X that denotes a subtype or object:

@item
X'Alignment

@example
The Address of an object that is allocated under control of
the implementation is an integral multiple of the Alignment
of the object (that is, the Address modulo the Alignment is
zero). The offset of a record component is a multiple of the
Alignment of the component. For an object that is not
allocated under control of the implementation (that is, one
that is imported, that is allocated by a user-defined
allocator, whose Address has been specified, or is designated
by an access value returned by an instance of
Unchecked_Conversion), the implementation may assume that the
Address is an integral multiple of its Alignment. The
implementation shall not assume a stricter alignment.
@end example

@item
@example
The value of this attribute is of type
universal_integer, and nonnegative; zero means that the
object is not necessarily aligned on a storage element
boundary.
@end example

@item
@example
Alignment may be specified for first subtypes and
stand-alone objects via an attribute_definition_clause; the
expression of such a clause shall be static, and its value
nonnegative. If the Alignment of a subtype is specified,
then the Alignment of an object of the subtype is at least as
strict, unless the object's Alignment is also specified. The
Alignment of an object created by an allocator is that of the
designated subtype.
@end example

@item
@example
If an Alignment is specified for a composite subtype or
object, this Alignment shall be equal to the least common
multiple of any specified Alignments of the subcomponent
subtypes, or an integer multiple thereof.
@end example

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
Program execution is erroneous if an Address clause is given that
conflicts with the Alignment.

@item
If the Alignment is specified for an object that is not allocated under
control of the implementation, execution is erroneous if the object is
not aligned according to the Alignment.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The recommended level of support for the Alignment attribute for
subtypes is:

@enumerate 30
@item
An implementation should support specified Alignments that are factors
and multiples of the number of storage elements per word, subject to the
following:

@item
An implementation need not support specified Alignments for combinations
of Sizes and Alignments that cannot be easily loaded and stored by
available machine instructions.

@item
An implementation need not support specified Alignments that are greater
than the maximum Alignment the implementation ever returns by default.
@end enumerate
@end enumerate

@enumerate 33
@item
The recommended level of support for the Alignment attribute for objects
is:

@enumerate 34
@item
Same as above, for subtypes, but in addition:

@item
For stand-alone library-level objects of statically constrained
subtypes, the implementation should support all Alignments supported by
the target linker. For example, page alignment is likely to be supported
for such objects, but not for subtypes.
@end enumerate
@end enumerate
@enumerate 36

NOTES

@item
(3) Alignment is a subtype-specific attribute.

@item
(4) The Alignment of a composite object is always equal to the least
common multiple of the Alignments of its components, or a multiple
thereof.

@item
(5) A component_clause, Component_Size clause, or a pragma Pack can
override a specified Alignment.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a prefix X that denotes an object:

@item
X'Size

@example
Denotes the size in bits of the representation of the object.
The value of this attribute is of the type universal_integer.
@end example

@enumerate 41
@item
Size may be specified for stand-alone objects via an
attribute_definition_clause; the expression of such a clause
shall be static and its value nonnegative.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 42
@item
The recommended level of support for the Size attribute of objects is:

@enumerate 43
@item
A Size clause should be supported for an object if the specified Size is
at least as large as its subtype's Size, and corresponds to a size in
storage elements that is a multiple of the object's Alignment (if the
Alignment is nonzero).
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 44
@item
For every subtype S:

@item
S'Size

@example
If S is definite, denotes the size (in bits) that the
implementation would choose for the following objects of
subtype S:
@end example

@enumerate 46
@item
A record component of subtype S when the record type is packed.

@item
The formal parameter of an instance of Unchecked_Conversion that
converts from subtype S to some other subtype.

@item
If S is indefinite, the meaning is implementation defined. The value of
this attribute is of the type universal_integer. The Size of an object
is at least as large as that of its subtype, unless the object's Size is
determined by a Size clause, a component_clause, or a Component_Size
clause. Size may be specified for first subtypes via an
attribute_definition_clause; the expression of such a clause shall be
static and its value nonnegative.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@enumerate 49
@item
In an implementation, Boolean'Size shall be 1.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If the Size of a subtype is specified, and allows for efficient
independent addressability, see @ref{9.10}, on the target architecture,
then the Size of the following objects of the subtype should equal the
Size of the subtype:

@enumerate 51
@item
Aliased objects (including components).

@item
Unaliased components, unless the Size of the component is determined by
a component_clause or Component_Size clause.
@end enumerate
@end enumerate

@enumerate 53
@item
A Size clause on a composite subtype should not affect the internal
layout of components.

@item
The recommended level of support for the Size attribute of subtypes is:

@enumerate 55
@item
The Size (if not specified) of a static discrete or fixed point subtype
should be the number of bits needed to represent each value belonging to
the subtype using an unbiased representation, leaving space for a sign
bit only if the subtype contains negative values. If such a subtype is a
first subtype, then an implementation should support a specified Size
for it that reflects this representation.

@item
For a subtype implemented with levels of indirection, the Size should
include the size of the pointers, but not the size of what they point
at.
@end enumerate
@end enumerate
@enumerate 57

NOTES

@item
(6) Size is a subtype-specific attribute.

@item
(7) A component_clause or Component_Size clause can override a specified
Size. A pragma Pack cannot.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a prefix T that denotes a task object (after any implicit
dereference):

@item
T'Storage_Size

@example
Denotes the number of storage elements reserved for the task.
The value of this attribute is of the type universal_integer.
The Storage_Size includes the size of the task's stack, if
any. The language does not specify whether or not it
includes other storage associated with the task (such as the
``task control block'' used by some implementations.)  If a
pragma Storage_Size is given, the value of the Storage_Size
attribute is at least the value specified in the pragma.
@end example

@item
A pragma Storage_Size specifies the amount of storage to be reserved for
the execution of a task.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Storage_Size is as follows:

@item
@example
pragma Storage_Size(expression);
@end example

@enumerate 64
@item
A pragma Storage_Size is allowed only immediately within a
task_definition.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 65
@item
The expression of a pragma Storage_Size is expected to be of any integer
type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A pragma Storage_Size is elaborated when an object of the type defined
by the immediately enclosing task_definition is created. For the
elaboration of a pragma Storage_Size, the expression is evaluated; the
Storage_Size attribute of the newly created task object is at least the
value of the expression.

@item
At the point of task object creation, or upon task activation,
Storage_Error is raised if there is insufficient free storage to
accommodate the requested Storage_Size. Static Semantics

@item
For a prefix X that denotes an array subtype or array object (after any
implicit dereference):

@item
X'Component_Size

@example
Denotes the size in bits of components of the type of X. The
value of this attribute is of type universal_integer.
@end example

@enumerate 70
@item
Component_Size may be specified for array types via an
attribute_definition_clause; the expression of such a clause
shall be static, and its value nonnegative.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 71
@item
The recommended level of support for the Component_Size attribute is:

@enumerate 72
@item
An implementation need not support specified Component_Sizes that are
less than the Size of the component subtype.

@item
An implementation should support specified Component_Sizes that are
factors and multiples of the word size. For such Component_Sizes, the
array should contain no gaps between components. For other
Component_Sizes (if supported), the array should contain no gaps between
components when packing is also specified; the implementation should
forbid this combination in cases where it cannot support a no-gaps
representation.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 74
@item
For every subtype S of a tagged type T (specific or class-wide), the
following attribute is defined:

@item
S'External_Tag

@example
S'External_Tag denotes an external string representation for
S'Tag; it is of the predefined type String. External_Tag may
be specified for a specific tagged type via an
attribute_definition_clause; the expression of such a
clause shall be static. The default external tag
representation is implementation defined. @xref{3.9.2}, and
@ref{13.13.2}.
@end example

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
In an implementation, the default external tag for each specific tagged
type declared in a partition shall be distinct, so long as the type is
declared outside an instance of a generic body. If the compilation unit
in which a given tagged type is declared, and all compilation units on
which it semantically depends, are the same in two different partitions,
then the external tag for the type shall be the same in the two
partitions. What it means for a compilation unit to be the same in two
different partitions is implementation defined. At a minimum, if the
compilation unit is not recompiled between building the two different
partitions that include it, the compilation unit is considered the same
in the two partitions.

     NOTES

@item
(8) The following language-defined attributes are specifiable, at least
for some of the kinds of entities to which they apply: Address, Size,
Component_Size, Alignment, External_Tag, Small, Bit_Order, Storage_Pool,
Storage_Size, Write, Output, Read, Input, and Machine_Radix.

@item
(9) It follows from the general rules in @ref{13.1}, that if one writes
``for X'Size use Y;'' then the X'Size attribute_reference will return Y
(assuming the implementation allows the Size clause). The same is true
for all of the specifiable attributes except Storage_Size.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of attribute definition clauses:

@item
@example
Byte : constant := 8;
Page : constant := 2**12;
@end example

@item
@example
type Medium is range 0 .. 65_000;
for Medium'Size use 2*Byte;
for Medium'Alignment use 2;
Device_Register : Medium;
for Device_Register'Size use Medium'Size;
for Device_Register'Address use
  System.Storage_Elements.To_Address(16#FFFF_0020#);
@end example

@item
@example
type Short is delta 0.01 range -100.0 .. 100.0;
for Short'Size use 15;
@end example

@item
@example
for Car_Name'Storage_Size use
-- specify access type's storage pool size
  2000*((Car'Size/System.Storage_Unit) +1);
  -- approximately 2000 cars
@end example

@item
@example
function My_Read(Stream : access Ada.Streams.Root_Stream_Type'Class)
  return T;
for T'Read use My_Read;  --  see @ref{13.13.2}
@end example

     NOTES

@item
(10) Notes on the examples: In the Size clause for Short, fifteen bits
is the minimum necessary, since the type definition requires Short'Small
<= 2**(-7).
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.4, 13.5, 13.3, 13
@section Enumeration Representation Clauses

@enumerate
@item
An enumeration_representation_clause specifies the internal codes for
enumeration literals.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
enumeration_representation_clause ::=
   for first_subtype_local_name use enumeration_aggregate;
@end example

@item
@example
enumeration_aggregate ::= array_aggregate
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The enumeration_aggregate shall be written as a one-dimensional
array_aggregate, for which the index subtype is the unconstrained
subtype of the enumeration type, and each component expression is
expected to be of any integer type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The first_subtype_local_name of an enumeration_representation_clause
shall denote an enumeration subtype.

@item
The expressions given in the array_aggregate shall be static, and shall
specify distinct integer codes for each value of the enumeration type;
the associated integer codes shall satisfy the predefined ordering
relation of the type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An enumeration_representation_clause specifies the coding aspect of
representation. The coding consists of the internal code for each
enumeration literal, that is, the integral value used internally to
represent each literal.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
For nonboolean enumeration types, if the coding is not specified for the
type, then for each value of the type, the internal code shall be equal
to its position number.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The recommended level of support for enumeration_representation_clauses
is:

@enumerate 10
@item
An implementation should support at least the internal codes in the
range System.Min_Int..System.Max_Int. An implementation need not support
enumeration_representation_clauses for boolean types.
@end enumerate
@end enumerate
@enumerate 11

NOTES

@item
(11) Unchecked_Conversion may be used to query the internal codes used
for an enumeration type. The attributes of the type, such as Succ, Pred,
and Pos, are unaffected by the representation_clause. For example, Pos
always returns the position number, not the internal integer code that
might have been specified in a representation_clause.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of an enumeration representation clause:

@item
@example
type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);
@end example

@item
@example
for Mix_Code use
   (ADD => 1, SUB => 2, MUL => 3, LDA => 8, STA => 24, STZ =>33);
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.5, 13.5.1, 13.4, 13
@section Record Layout

@enumerate
@item
The (record) layout aspect of representation consists of the storage
places for some or all components, that is, storage place attributes of
the components. The layout can be specified with a
record_representation_clause.
@end enumerate

@menu
* 13.5.1:: Record Representation Clauses
* 13.5.2:: Storage Place Attributes
* 13.5.3:: Bit Ordering
@end menu

@c ---------------------------------------------------------------------------
@node 13.5.1, 13.5.2, 13.5, 13.5
@subsection Record Representation Clauses

@enumerate
@item
A record_representation_clause specifies the storage representation of
records and record extensions, that is, the order, position, and size of
components (including discriminants, if any).

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
record_representation_clause ::=
   for first_subtype_local_name use
      record [mod_clause]
         @{component_clause@}
      end record;
@end example

@item
@example
component_clause ::=
   component_local_name at position range first_bit .. last_bit;
@end example

@item
@example
position ::= static_expression
@end example

@item
@example
first_bit ::= static_simple_expression
@end example

@item
@example
last_bit ::= static_simple_expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Each position, first_bit, and last_bit is expected to be of any integer
type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The first_subtype_local_name of a record_representation_clause shall
denote a specific nonlimited record or record extension subtype.

@item
If the component_local_name is a direct_name, the local_name shall
denote a component of the type. For a record extension, the component
shall not be inherited, and shall not be a discriminant that corresponds
to a discriminant of the parent type. If the component_local_name has an
attribute_designator, the direct_name of the local_name shall denote
either the declaration of the type or a component of the type, and the
attribute_designator shall denote an implementation-defined implicit
component of the type.

@item
The position, first_bit, and last_bit shall be static expressions. The
value of position and first_bit shall be nonnegative. The value of
last_bit shall be no less than first_bit - 1.

@item
At most one component_clause is allowed for each component of the type,
including for each discriminant (component_clauses may be given for
some, all, or none of the components). Storage places within a
component_list shall not overlap, unless they are for components in
distinct variants of the same variant_part.

@item
A name that denotes a component of a type is not allowed within a
record_representation_clause for the type, except as the
component_local_name of a component_clause.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A record_representation_clause (without the mod_clause) specifies the
layout. The storage place attributes, see @ref{13.5.2}, are taken from the
values of the position, first_bit, and last_bit expressions after
normalizing those values so that first_bit is less than Storage_Unit.

@item
A record_representation_clause for a record extension does not override
the layout of the parent part; if the layout was specified for the
parent type, it is inherited by the record extension.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may generate implementation-defined components (for
example, one containing the offset of another component). An
implementation may generate names that denote such
implementation-defined components; such names shall be
implementation-defined attribute_references. An implementation may allow
such implementation-defined names to be used in record_
representation_clauses. An implementation can restrict such
component_clauses in any manner it sees fit.

@item
If a record_representation_clause is given for an untagged derived type,
the storage place attributes for all of the components of the derived
type may differ from those of the corresponding components of the parent
type, even for components whose storage place is not specified
explicitly in the record_representation_clause.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The recommended level of support for record_representation_clauses is:

@enumerate 18
@item
An implementation should support storage places that can be extracted
with a load, mask, shift sequence of machine code, and set with a load,
shift, mask, store sequence, given the available machine instructions
and run-time model.

@item
A storage place should be supported if its size is equal to the Size of
the component subtype, and it starts and ends on a boundary that obeys
the Alignment of the component subtype.

@item
If the default bit ordering applies to the declaration of a given type,
then for a component whose subtype's Size is less than the word size,
any storage place that does not cross an aligned word boundary should be
supported.

@item
An implementation may reserve a storage place for the tag field of a
tagged type, and disallow other components from overlapping that place.

@item
An implementation need not support a component_clause for a component of
an extension part if the storage place is not after the storage places
of all components of the parent type, whether or not those storage
places had been specified.
@end enumerate
@end enumerate
@enumerate 23

NOTES

@item
(12) If no component_clause is given for a component, then the choice of
the storage place for the component is left to the implementation. If
component_clauses are given for all components, the
record_representation_clause completely specifies the representation of
the type and will be obeyed exactly by the implementation.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of specifying the layout of a record type:

@item
@example
Word : constant := 4;  --  storage element is byte, 4 bytes per word
@end example

@item
@example
type State      is (A,M,W,P);
type Mode       is (Fix, Dec, Exp, Signif);
@end example

@item
@example
type Byte_Mask  is array (0..7)  of Boolean;
type State_Mask is array (State) of Boolean;
type Mode_Mask  is array (Mode)  of Boolean;
@end example

@item
@example
type Program_Status_Word is
  record
      System_Mask     : Byte_Mask;
      Protection_Key  : Integer range 0 .. 3;
      Machine_State   : State_Mask;
      Interrupt_Cause : Interruption_Code;
      Ilc             : Integer range 0 .. 3;
      Cc              : Integer range 0 .. 3;
      Program_Mask    : Mode_Mask;
      Inst_Address    : Address;
end record;
@end example

@item
@example
for Program_Status_Word use
  record
      System_Mask     at 0*Word range 0  .. 7;
      Protection_Key  at 0*Word range 10 .. 11; -- bits 8,9 unused
      Machine_State   at 0*Word range 12 .. 15;
      Interrupt_Cause at 0*Word range 16 .. 31;
      Ilc             at 1*Word range 0  .. 1;  -- second word
      Cc              at 1*Word range 2  .. 3;
      Program_Mask    at 1*Word range 4  .. 7;
      Inst_Address    at 1*Word range 8  .. 31;
  end record;
@end example

@item
@example
for Program_Status_Word'Size use 8*System.Storage_Unit;
for Program_Status_Word'Alignment use 8;
@end example

NOTES

@item
(13) Note on the example: The record_representation_clause defines the
record layout. The Size clause guarantees that (at least) eight storage
elements are used for objects of the type. The Alignment clause
guarantees that aliased, imported, or exported objects of the type will
have addresses divisible by eight.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.5.2, 13.5.3, 13.5.1, 13.5
@subsection Storage Place Attributes

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
For a component C of a composite, non-array object R, the storage place
attributes are defined:

@item
R.C'Position

@example
Denotes the same value as R.C'Address - R'Address. The value
of this attribute is of the type universal_integer.
@end example

@item
R.C'First_Bit

@example
Denotes the offset, from the start of the first of the
storage elements occupied by C, of the first bit occupied by
C. This offset is measured in bits. The first bit of a
storage element is numbered zero. The value of this
attribute is of the type universal_integer.
@end example

@item
R.C'Last_Bit

@example
Denotes the offset, from the start of the first of the
storage elements occupied by C, of the last bit occupied by
C. This offset is measured in bits. The value of this
attribute is of the type universal_integer.
@end example

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If a component is represented using some form of pointer (such as an
offset) to the actual data of the component, and this data is contiguous
with the rest of the object, then the storage place attributes should
reflect the place of the actual data, not the pointer. If a component is
allocated discontiguously from the rest of the object, then a warning
should be generated upon reference to one of its storage place
attributes.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.5.3, 13.6, 13.5.2, 13.5
@subsection Bit Ordering

@enumerate
@item
The Bit_Order attribute specifies the interpretation of the storage
place attributes.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A bit ordering is a method of interpreting the meaning of the storage
place attributes. High_Order_First (known in the vernacular as ``big
endian'') means that the first bit of a storage element (bit 0) is the
most significant bit (interpreting the sequence of bits that represent a
component as an unsigned integer value). Low_Order_First (known in the
vernacular as ``little endian'') means the opposite: the first bit is
the least significant.

@item
For every specific record subtype S, the following attribute is defined:

@item
S'Bit_Order

@example
Denotes the bit ordering for the type of S. The value of this
attribute is of type System.Bit_Order. Bit_Order may be
specified for specific record types via an
attribute_definition_clause; the expression of such a
clause shall be static.
@end example

@item
If Word_Size = Storage_Unit, the default bit ordering is implementation
defined. If Word_Size > Storage_Unit, the default bit ordering is the
same as the ordering of storage elements in a word, when interpreted as
an integer.

@item
The storage place attributes of a component of a type are interpreted
according to the bit ordering of the type.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The recommended level of support for the nondefault bit ordering is:

@enumerate 8
@item
If Word_Size = Storage_Unit, then the implementation should support the
nondefault bit ordering in addition to the default bit ordering.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.6, 13.7, 13.5.3, 13
@section Change of Representation

@enumerate
@item
A type_conversion, see @ref{4.6} can be used to convert between two
different representations of the same array or record. To convert an
array from one representation to another, two array types need to be
declared with matching component subtypes, and convertible index types.
If one type has packing specified and the other does not, then explicit
conversion can be used to pack or unpack an array.

@item
To convert a record from one representation to another, two record types
with a common ancestor type need to be declared, with no inherited
subprograms. Distinct representations can then be specified for the
record types, and explicit conversion between the types can be used to
effect a change in representation.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of change of representation:

@item
@example
-- Packed_Descriptor and Descriptor are two different types
-- with identical characteristics, apart from their
-- representation
@end example

@item
@example
type Descriptor is
    record
      -- components of a descriptor
    end record;
@end example

@item
@example
type Packed_Descriptor is new Descriptor;
@end example

@item
@example
for Packed_Descriptor use
    record
      -- component clauses for some or for all components
    end record;
@end example

@item
@example
--  Change of representation can now be accomplished
--  by explicit type conversions:
@end example

@item
@example
D : Descriptor;
P : Packed_Descriptor;
@end example

@item
@example
P := Packed_Descriptor(D);  -- pack D
D := Descriptor(P);         -- unpack P
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.7, 13.7.1, 13.6, 13
@section The Package System

@enumerate
@item
For each implementation there is a library package called System which
includes the definitions of certain configuration-dependent
characteristics.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
package System is
   pragma Preelaborate(System);
@end example

@item
@example
   type Name is implementation-defined-enumeration-type;
   System_Name : constant Name := implementation-defined;
@end example

@item
@example
   -- System-Dependent Named Numbers:
@end example

@item
@example
   Min_Int               : constant := root_integer'First;
   Max_Int               : constant := root_integer'Last;
@end example

@item
@example
   Max_Binary_Modulus    : constant := implementation-defined;
   Max_Nonbinary_Modulus : constant := implementation-defined;
@end example

@item
@example
   Max_Base_Digits       : constant := root_real'Digits;
   Max_Digits            : constant := implementation-defined;
@end example

@item
@example
   Max_Mantissa          : constant := implementation-defined;
   Fine_Delta            : constant := implementation-defined;
@end example

@item
@example
   Tick                  : constant := implementation-defined;
@end example

@item
@example
   -- Storage-related Declarations:
@end example

@item
@example
   type Address is implementation-defined;
   Null_Address : constant Address;
@end example

@item
@example
   Storage_Unit : constant := implementation-defined;
   Word_Size    : constant := implementation-defined * Storage_Unit;
   Memory_Size  : constant := implementation-defined;
@end example

@item
@example
   -- Address Comparison:
   function "<" (Left, Right : Address) return Boolean;
   function "<="(Left, Right : Address) return Boolean;
   function ">" (Left, Right : Address) return Boolean;
   function ">="(Left, Right : Address) return Boolean;
   function "=" (Left, Right : Address) return Boolean;
-- function "/=" (Left, Right : Address) return Boolean;
   -- "/=" is implicitly defined
   pragma Convention(Intrinsic, "<");
   ...
   -- and so on for all language-defined subprograms in this package
@end example

@item
@example
   -- Other System-Dependent Declarations:
   type Bit_Order is (High_Order_First, Low_Order_First);
   Default_Bit_Order : constant Bit_Order;
@end example

@item
@example
   -- Priority-related declarations, see @ref{D.1}.:
   subtype Any_Priority is Integer
     range implementation-defined;
   subtype Priority is Any_Priority
     range Any_Priority'First .. implementation-defined;
   subtype Interrupt_Priority is Any_Priority
     range Priority'Last+1 .. Any_Priority'Last;
@end example

@item
@example
   Default_Priority : constant Priority
     := (Priority'First + Priority'Last)/2;
@end example

@item
@example
private
   ... -- not specified by the language
end System;
@end example

@item
Name is an enumeration subtype. Values of type Name are the names of
alternative machine configurations handled by the implementation.
System_Name represents the current machine configuration.

@item
The named numbers Fine_Delta and Tick are of the type universal_real;
the others are of the type universal_integer.

@item
The meanings of the named numbers are:

@item
Min_Int

@example
The smallest (most negative) value allowed for the
expressions of a signed_integer_type_definition.
@end example

@item
Max_Int

@example
The largest (most positive) value allowed for the expressions
of a signed_integer_type_definition.
@end example

@item
Max_Binary_Modulus

@example
A power of two such that it, and all lesser positive powers
of two, are allowed as the modulus of a
modular_type_definition.
@end example

@item
Max_Nonbinary_Modulus

@example
A value such that it, and all lesser positive integers, are
allowed as the modulus of a modular_type_definition.
@end example

@item
Max_Base_Digits

@example
The largest value allowed for the requested decimal precision
in a floating_point_definition.
@end example

@item
Max_Digits

@example
The largest value allowed for the requested decimal precision
in a floating_point_definition that has no
real_range_specification. Max_Digits is less than or equal
to Max_Base_Digits.
@end example

@item
Max_Mantissa

@example
The largest possible number of binary digits in the mantissa
of machine numbers of a user-defined ordinary fixed point
type. (The mantissa is defined in @ref{G}.)
@end example

@item
Fine_Delta

@example
The smallest delta allowed in an
ordinary_fixed_point_definition that has the
real_range_specification range -1.0 .. 1.0.
@end example

@item
Tick

@example
A period in seconds approximating the real time interval
during which the value of Calendar.Clock remains constant.
@end example

@item
Storage_Unit

@example
The number of bits per storage element.
@end example

@item
Word_Size

@example
The number of bits per word.
@end example

@item
Memory_Size

@example
An implementation-defined value that is intended to reflect
the memory size of the configuration in storage elements.
@end example

@item
Address is of a definite, nonlimited type. Address represents machine
addresses capable of addressing individual storage elements.
Null_Address is an address that is distinct from the address of any
object or program unit.

@item
@xref{13.5.3}, for an explanation of Bit_Order and Default_Bit_Order.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may add additional implementation-defined declarations
to package System and its children. However, it is usually better for
the implementation to provide additional functionality via
implementation-defined children of System. Package System may be
declared pure.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Address should be of a private type.

NOTES

@item
(14) There are also some language-defined child packages of System
defined elsewhere.
@end enumerate

@menu
* 13.7.1:: The Package System.Storage_Elements
* 13.7.2:: The Package System.Address_To_Access_Conversions
@end menu

@c ---------------------------------------------------------------------------
@node 13.7.1, 13.7.2, 13.7, 13.7
@subsection The Package System.Storage_Elements

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined library package exists:

@item
@example
package System.Storage_Elements is
   pragma Preelaborate(System.Storage_Elements);
@end example

@item
@example
   type Storage_Offset is range implementation-defined;
@end example

@item
@example
   subtype Storage_Count is Storage_Offset
     range 0..Storage_Offset'Last;
@end example

@item
@example
   type Storage_Element is mod implementation-defined;
   for Storage_Element'Size use Storage_Unit;
   type Storage_Array is array
     (Storage_Offset range <>) of aliased Storage_Element;
   for Storage_Array'Component_Size use Storage_Unit;
@end example

@item
@example
   -- Address Arithmetic:
@end example

@item
@example
   function "+"(Left : Address; Right : Storage_Offset)
     return Address;
   function "+"(Left : Storage_Offset; Right : Address)
     return Address;
   function "-"(Left : Address; Right : Storage_Offset)
     return Address;
   function "-"(Left, Right : Address)
     return Storage_Offset;
@end example

@item
@example
   function "mod"(Left : Address; Right : Storage_Offset)
     return Storage_Offset;
@end example

@item
@example
   -- Conversion to/from integers:
@end example

@item
@example
   type Integer_Address is implementation-defined;
   function To_Address(Value : Integer_Address) return Address;
   function To_Integer(Value : Address) return Integer_Address;
@end example

@item
@example
   pragma Convention(Intrinsic, "+");
      -- ...and so on for all language-defined subprograms
      -- declared in this package.
end System.Storage_Elements;
@end example

@item
Storage_Element represents a storage element. Storage_Offset represents
an offset in storage elements. Storage_Count represents a number of
storage elements. Storage_Array represents a contiguous sequence of
storage elements.

@item
Integer_Address is a (signed or modular) integer subtype. To_Address and
To_Integer convert back and forth between this type and Address.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
Storage_Offset'Last shall be greater than or equal to Integer'Last or
the largest possible storage offset, whichever is smaller.
Storage_Offset'First shall be <= (-Storage_Offset'Last).

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
Package System.Storage_Elements may be declared pure.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Operations in System and its children should reflect the target
environment semantics as closely as is reasonable. For example, on most
machines, it makes sense for address arithmetic to ``wrap around.''
Operations that do not make sense should raise Program_Error.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.7.2, 13.8, 13.7.1, 13.7
@subsection The Package System.Address_To_Access_Conversions

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined generic library package exists:

@item
@example
generic
    type Object(<>) is limited private;
package System.Address_To_Access_Conversions is
   pragma Preelaborate(Address_To_Access_Conversions);
@end example

@item
@example
   type Object_Pointer is access all Object;
   function To_Pointer(Value : Address) return Object_Pointer;
   function To_Address(Value : Object_Pointer) return Address;
@end example

@item
@example
   pragma Convention(Intrinsic, To_Pointer);
   pragma Convention(Intrinsic, To_Address);
end System.Address_To_Access_Conversions;
@end example

@item
The To_Pointer and To_Address subprograms convert back and forth between
values of types Object_Pointer and Address. To_Pointer(X'Address) is
equal to X'Unchecked_Access for any X that allows Unchecked_Access.
To_Pointer(Null_Address) returns null. For other addresses, the behavior
is unspecified. To_Address(null) returns Null_Address (for null of the
appropriate type). To_Address(Y), where Y /= null, returns
Y.all'Address.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may place restrictions on instantiations of
Address_To_Access_Conversions.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.8, 13.9, 13.7.2, 13
@section Machine Code Insertions

@enumerate
@item
A machine code insertion can be achieved by a call to a subprogram whose
sequence_of_statements contains code_statements.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
code_statement ::= qualified_expression;
@end example

@enumerate 3
@item
A code_statement is only allowed in the handled_sequence_of_statements
of a subprogram_body. If a subprogram_body contains any code_statements,
then within this subprogram_body the only allowed form of statement is a
code_statement (labeled or not), the only allowed declarative_items are
use_clauses, and no exception_handler is allowed (comments and pragmas
are allowed as usual).
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 4
@item
The qualified_expression is expected to be of any type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The qualified_expression shall be of a type declared in package
System.Machine_Code.

@item
A code_statement shall appear only within the scope of a with_clause
that mentions package System.Machine_Code.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The contents of the library package System.Machine_Code (if provided)
are implementation defined. The meaning of code_statements is
implementation defined. Typically, each qualified_expression represents
a machine instruction or assembly directive.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may place restrictions on code_statements. An
implementation is not required to provide package System.Machine_Code.

NOTES

@item
(15) An implementation may provide implementation-defined pragmas
specifying register conventions and calling conventions.

@item
(16) Machine code functions are exempt from the rule that a
return_statement is required. In fact, return_statements are forbidden,
since only code_statements are allowed.

@item
(17) Intrinsic subprograms, see @ref{6.3.1, ``Conformance Rules''}, can
also be used to achieve machine code insertions. Interface to assembly
language can be achieved using the features in Annex B, see @ref{B,
``Interface to Other Languages''}.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a code statement:

@item
@example
M : Mask;
procedure Set_Mask; pragma Inline(Set_Mask);
@end example

@item
@example
procedure Set_Mask is
  use System.Machine_Code;
  -- assume ``with System.Machine_Code;'' appears somewhere above
begin
  SI_Format'(Code => SSM, B => M'Base_Reg, D => M'Disp);
  --  Base_Reg and Disp are implementation-defined attributes
end Set_Mask;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.9, 13.9.1, 13.8, 13
@section Unchecked Type Conversions

@enumerate
@item
An unchecked type conversion can be achieved by a call to an instance of
the generic function Unchecked_Conversion.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined generic library function exists:

@item
@example
generic
   type Source(<>) is limited private;
   type Target(<>) is limited private;
function Ada.Unchecked_Conversion(S : Source) return Target;
pragma Convention(Intrinsic, Ada.Unchecked_Conversion);
pragma Pure(Ada.Unchecked_Conversion);
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The size of the formal parameter S in an instance of
Unchecked_Conversion is that of its subtype. This is the actual subtype
passed to Source, except when the actual is an unconstrained composite
subtype, in which case the subtype is constrained by the bounds or
discriminants of the value of the actual expression passed to S.

@item
If all of the following are true, the effect of an unchecked conversion
is to return the value of an object of the target subtype whose
representation is the same as that of the source object S:

@enumerate 6
@item
S'Size = Target'Size.

@item
S'Alignment = Target'Alignment.

@item
The target subtype is not an unconstrained composite subtype.

@item
S and the target subtype both have a contiguous representation.

@item
The representation of S is a representation of an object of the
target subtype.
@end enumerate
@end enumerate

@enumerate 11
@item
Otherwise, the effect is implementation defined; in particular, the
result can be abnormal, see @ref{13.9.1}.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may return the result of an unchecked conversion by
reference, if the Source type is not a by-copy type. In this case, the
result of the unchecked conversion represents simply a different
(read-only) view of the operand of the conversion.

@item
An implementation may place restrictions on Unchecked_Conversion.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The Size of an array object should not include its bounds; hence, the
bounds should not be part of the converted data.

@item
The implementation should not generate unnecessary run-time checks to
ensure that the representation of S is a representation of the target
type. It should take advantage of the permission to return by reference
when possible. Restrictions on unchecked conversions should be avoided
unless required by the target environment.

@item
The recommended level of support for unchecked conversions is:

@enumerate 17
Unchecked conversions should be supported and should be reversible in
the cases where this clause defines the result. To enable meaningful use
of unchecked conversion, a contiguous representation should be used for
elementary subtypes, for statically constrained array subtypes whose
component subtype is one of the subtypes described in this paragraph,
and for record subtypes without discriminants whose component subtypes
are described in this paragraph.
@end enumerate
@end enumerate

@menu
* 13.9.1:: Data Validity
* 13.9.2:: The Valid Attribute
@end menu

@c ---------------------------------------------------------------------------
@node 13.9.1, 13.9.2, 13.9, 13.9
@subsection Data Validity

@enumerate
@item
Certain actions that can potentially lead to erroneous execution are not
directly erroneous, but instead can cause objects to become abnormal.
Subsequent uses of abnormal objects can be erroneous.

@item
A scalar object can have an invalid representation, which means that the
object's representation does not represent any value of the object's
subtype. The primary cause of invalid representations is uninitialized
variables.

@item
Abnormal objects and invalid representations are explained in this
subclause.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
When an object is first created, and any explicit or default
initializations have been performed, the object and all of its parts are
in the normal state. Subsequent operations generally leave them normal.
However, an object or part of an object can become abnormal in the
following ways:

@enumerate 5
@item
An assignment to the object is disrupted due to an abort, see @ref{9.8}, or
due to the failure of a language-defined check, see @ref{11.6}.

@item
The object is not scalar, and is passed to an in out or out parameter of
an imported procedure or language-defined input procedure, if after
return from the procedure the representation of the parameter does not
represent a value of the parameter's subtype.
@end enumerate
@end enumerate

@enumerate 7
@item
Whether or not an object actually becomes abnormal in these cases is not
specified. An abnormal object becomes normal again upon successful
completion of an assignment to the object as a whole.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
It is erroneous to evaluate a primary that is a name denoting an
abnormal object, or to evaluate a prefix that denotes an abnormal
object.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
If the representation of a scalar object does not represent a value of
the object's subtype (perhaps because the object was not initialized),
the object is said to have an invalid representation. It is a bounded
error to evaluate the value of such an object. If the error is detected,
either Constraint_Error or Program_Error is raised. Otherwise, execution
continues using the invalid representation. The rules of the language
outside this subclause assume that all objects have valid
representations. The semantics of operations on invalid representations
are as follows:

@enumerate 10
@item
If the representation of the object represents a value of the object's
type, the value of the type is used.

@item
If the representation of the object does not represent a value of the
object's type, the semantics of operations on such representations is
implementation-defined, but does not by itself lead to erroneous or
unpredictable execution, or to other objects becoming abnormal.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@enumerate 12
@item
A call to an imported function or an instance of Unchecked_Conversion is
erroneous if the result is scalar, and the result object has an invalid
representation.

@item
The dereference of an access value is erroneous if it does not designate
an object of an appropriate type or a subprogram with an appropriate
profile, if it designates a nonexistent object, or if it is an
access-to-variable value that designates a constant object. Such an
access value can exist, for example, because of Unchecked_Deallocation,
Unchecked_Access, or Unchecked_Conversion.

NOTES

@item
(18) Objects can become abnormal due to other kinds of actions that
directly update the object's representation; such actions are generally
considered directly erroneous, however.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.9.2, 13.10, 13.9.1, 13.9
@subsection The Valid Attribute

@enumerate
@item
The Valid attribute can be used to check the validity of data produced
by unchecked conversion, input, interface to foreign languages, and the
like.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a prefix X that denotes a scalar object (after any implicit
dereference), the following attribute is defined:

@item
X'Valid

@example
Yields True if and only if the object denoted by X is normal
and has a valid representation. The value of this attribute
is of the predefined type Boolean.
@end example

NOTES

@item
(19) Invalid data can be created in the following cases (not counting
erroneous or unpredictable execution):

@enumerate 5

@item
an uninitialized scalar object,

@item
the result of an unchecked conversion,

@item
input,

@item
interface to another language (including machine code),

@item
aborting an assignment,

@item
disrupting an assignment due to the failure of a language-defined check
(@pxref{11.6}) and

@item
use of an object whose Address has been specified.
@end enumerate
@end enumerate

@enumerate 12
@item
(20) X'Valid is not considered to be a read of X; hence, it is not an
error to check the validity of invalid data.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.10, 13.11, 13.9.2, 13
@section Unchecked Access Value Creation

@enumerate
@item
The attribute Unchecked_Access is used to create access values in an
unsafe manner -- the programmer is responsible for preventing ``dangling
references.''

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following attribute is defined for a prefix X that denotes an
aliased view of an object:

@item
X'Unchecked_Access

@example
All rules and semantics that apply to X'Access, see @ref{3.10.2},
apply also to X'Unchecked_Access, except that, for the
purposes of accessibility rules and checks, it is as if X
were declared immediately within a library package.
@end example

NOTES

@item
(21) This attribute is provided to support the situation where a local
object is to be inserted into a global linked data structure, when the
programmer knows that it will always be removed from the data structure
prior to exiting the object's scope. The Access attribute would be
illegal in this case, see @ref{3.10.2, ``Operations of Access Types''}.

@item
(22) There is no Unchecked_Access attribute for subprograms.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.11, 13.11.1, 13.10, 13
@section Storage Management

@enumerate
@item
Each access-to-object type has an associated storage pool. The storage
allocated by an allocator comes from the pool; instances of
Unchecked_Deallocation return storage to the pool. Several access types
can share the same pool.

@item
A storage pool is a variable of a type in the class rooted at
Root_Storage_Pool, which is an abstract limited controlled type. By
default, the implementation chooses a standard storage pool for each
access type. The user may define new pool types, and may override the
choice of pool for an access type by specifying Storage_Pool for the
type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
If Storage_Pool is specified for a given access type, Storage_Size shall
not be specified for it.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
with Ada.Finalization;
with System.Storage_Elements;
package System.Storage_Pools is
    pragma Preelaborate(System.Storage_Pools);
@end example

@item
@example
    type Root_Storage_Pool is
        abstract new
          Ada.Finalization.Limited_Controlled with private;
@end example

@item
@example
    procedure Allocate(
      Pool : in out Root_Storage_Pool;
      Storage_Address : out Address;
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
      Alignment : in Storage_Elements.Storage_Count) is abstract;
@end example

@item
@example
    procedure Deallocate(
      Pool : in out Root_Storage_Pool;
      Storage_Address : in Address;
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
      Alignment : in Storage_Elements.Storage_Count) is abstract;
@end example

@item
@example
    function Storage_Size(Pool : Root_Storage_Pool)
        return Storage_Elements.Storage_Count is abstract;
@end example

@item
@example
private
   ... -- not specified by the language
end System.Storage_Pools;
@end example

@item
A storage pool type (or pool type) is a descendant of Root_Storage_Pool.
The elements of a storage pool are the objects allocated in the pool by
allocators.

@item
For every access subtype S, the following attributes are defined:

@item
S'Storage_Pool

@example
Denotes the storage pool of the type of S. The type of this
attribute is Root_Storage_Pool'Class.
@end example

@item
S'Storage_Size

@example
Yields the result of calling Storage_Size(S'Storage_Pool),
which is intended to be a measure of the number of storage
elements reserved for the pool. The type of this attribute
is universal_integer.
@end example

@item
Storage_Size or Storage_Pool may be specified for a non-derived
access-to-object type via an attribute_definition_clause; the name in a
Storage_Pool clause shall denote a variable.

@item
An allocator of type T allocates storage from T's storage pool. If the
storage pool is a user-defined object, then the storage is allocated by
calling Allocate, passing T'Storage_Pool as the Pool parameter. The
Size_In_Storage_Elements parameter indicates the number of storage
elements to be allocated, and is no more than
D'Max_Size_In_Storage_Elements, where D is the designated subtype. The
Alignment parameter is D'Alignment. The result returned in the
Storage_Address parameter is used by the allocator as the address of the
allocated storage, which is a contiguous block of memory of
Size_In_Storage_Elements storage elements. Any exception propagated by
Allocate is propagated by the allocator.

@item
If Storage_Pool is not specified for a type defined by an
access_to_object_definition, then the implementation chooses a standard
storage pool for it in an implementation-defined manner. In this case,
the exception Storage_Error is raised by an allocator if there is not
enough storage. It is implementation defined whether or not the
implementation provides user-accessible names for the standard pool
type(s).

@item
If Storage_Size is specified for an access type, then the Storage_Size
of this pool is at least that requested, and the storage for the pool is
reclaimed when the master containing the declaration of the access type
is left. If the implementation cannot satisfy the request, Storage_Error
is raised at the point of the attribute_definition_clause. If neither
Storage_Pool nor Storage_Size are specified, then the meaning of
Storage_Size is implementation defined.

@item
If Storage_Pool is specified for an access type, then the specified pool
is used.

@item
The effect of calling Allocate and Deallocate for a standard storage
pool directly (rather than implicitly via an allocator or an instance of
Unchecked_Deallocation) is unspecified.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If Storage_Pool is specified for an access type, then if Allocate can
satisfy the request, it should allocate a contiguous block of memory,
and return the address of the first storage element in Storage_Address.
The block should contain Size_In_Storage_Elements storage elements, and
should be aligned according to Alignment. The allocated storage should
not be used for any other purpose while the pool element remains in
existence. If the request cannot be satisfied, then Allocate should
propagate an exception (such as Storage_Error). If Allocate behaves in
any other manner, then the program execution is erroneous.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
An implementation shall document the set of values that a user-defined
Allocate procedure needs to accept for the Alignment parameter. An
implementation shall document how the standard storage pool is chosen,
and how storage is allocated by standard storage pools.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An implementation should document any cases in which it dynamically
allocates heap storage for a purpose other than the evaluation of an
allocator.

@item
A default (implementation-provided) storage pool for an
access-to-constant type should not have overhead to support deallocation
of individual objects.

@item
A storage pool for an anonymous access type should be created at the
point of an allocator for the type, and be reclaimed when the designated
object becomes inaccessible.

NOTES

@item
(23) A user-defined storage pool type can be obtained by extending the
Root_Storage_Pool type, and overriding the primitive subprograms
Allocate, Deallocate, and Storage_Size. A user-defined storage pool can
then be obtained by declaring an object of the type extension. The user
can override Initialize and Finalize if there is any need for
non-trivial initialization and finalization for a user-defined pool
type. For example, Finalize might reclaim blocks of storage that are
allocated separately from the pool object itself.

@item
(24) The writer of the user-defined allocation and deallocation
procedures, and users of allocators for the associated access type, are
responsible for dealing with any interactions with tasking. In
particular:

@enumerate 28
@item
If the allocators are used in different tasks, they require mutual
exclusion.

@item
If they are used inside protected objects, they cannot block.

@item
If they are used by interrupt handlers, see @ref{C.3, ``Interrupt
Support''}, the mutual exclusion mechanism has to work properly in that
context.
@end enumerate
@end enumerate

@enumerate 31
@item
(25) The primitives Allocate, Deallocate, and Storage_Size are declared
as abstract, see @ref{3.9.3}, and therefore they have to be overridden when
a new (non-abstract) storage pool type is declared.

@need 1000
@sp 1
@center @emph{Examples}

@item
To associate an access type with a storage pool object, the user first
declares a pool object of some type derived from Root_Storage_Pool.
Then, the user defines its Storage_Pool attribute, as follows:

@item
@example
Pool_Object : Some_Storage_Pool_Type;
@end example

@item
@example
type T is access Designated;
for T'Storage_Pool use Pool_Object;
@end example

@item
Another access type may be added to an existing storage pool, via:

@item
@example
for T2'Storage_Pool use T'Storage_Pool;
@end example

@item
The semantics of this is implementation defined for a standard storage
pool.

@item
As usual, a derivative of Root_Storage_Pool may define additional
operations. For example, presuming that Mark_Release_Pool_Type has two
additional operations, Mark and Release, the following is a possible
use:

@item
@example
type Mark_Release_Pool_Type
   (Pool_Size : Storage_Elements.Storage_Count;
    Block_Size : Storage_Elements.Storage_Count)
        is new Root_Storage_Pool with limited private;
@end example

@item
@example
...
@end example

@item
@example
MR_Pool : Mark_Release_Pool_Type (Pool_Size => 2000,
                                  Block_Size => 100);
@end example

@item
@example
type Acc is access ...;
for Acc'Storage_Pool use MR_Pool;
...
@end example

@item
@example
Mark(MR_Pool);
... -- Allocate objects using ``new Designated(...)''.
Release(MR_Pool); -- Reclaim the storage.
@end example
@end enumerate

@menu
* 13.11.1:: The Max_Size_In_Storage_Elements Attribute
* 13.11.2:: Unchecked Storage Deallocation
* 13.11.3:: Pragma Controlled
@end menu

@c ---------------------------------------------------------------------------
@node 13.11.1, 13.11.2, 13.11, 13
@subsection The Max_Size_In_Storage_Elements Attribute

@enumerate
@item
The Max_Size_In_Storage_Elements attribute is useful in writing
user-defined pool types.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For every subtype S, the following attribute is defined:

@item
S'Max_Size_In_Storage_Elements

@item
@example
Denotes the maximum value for Size_In_Storage_Elements that
will be requested via Allocate for an access type whose
designated subtype is S. The value of this attribute is of
type universal_integer.
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.11.2, 13.11.3, 13.11.1, 13.11
@subsection Unchecked Storage Deallocation

@enumerate
@item
Unchecked storage deallocation of an object designated by a value of an
access type is achieved by a call to an instance of the generic
procedure Unchecked_Deallocation.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined generic library procedure exists:

@item
@example
generic
   type Object(<>) is limited private;
   type Name   is access  Object;
procedure Ada.Unchecked_Deallocation(X : in out Name);
pragma Convention(Intrinsic, Ada.Unchecked_Deallocation);
pragma Preelaborate(Ada.Unchecked_Deallocation);
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Given an instance of Unchecked_Deallocation declared as follows:

@item
@example
procedure Free is
    new Ada.Unchecked_Deallocation
      (object_subtype_name, access_to_variable_subtype_name);
@end example

@item
Procedure Free has the following effect:

@enumerate 7
@item
After executing Free(X), the value of X is null.

@item
Free(X), when X is already equal to null, has no effect.

@item
Free(X), when X is not equal to null first performs finalization, as
described in @ref{7.6}. It then deallocates the storage occupied by the
object designated by X. If the storage pool is a user-defined object,
then the storage is deallocated by calling Deallocate, passing
access_to_variable_subtype_name'Storage_Pool as the Pool parameter.
Storage_Address is the value returned in the Storage_Address parameter
of the corresponding Allocate call. Size_In_Storage_Elements and
Alignment are the same values passed to the corresponding Allocate call.
There is one exception: if the object being freed contains tasks, the
object might not be deallocated.
@end enumerate
@end enumerate

@enumerate 10
@item
After Free(X), the object designated by X, and any subcomponents
thereof, no longer exist; their storage can be reused for other
purposes.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
It is a bounded error to free a discriminated, unterminated task object.
The possible consequences are:

@enumerate 12
@item
No exception is raised.

@item
Program_Error or Tasking_Error is raised at the point of the
deallocation.

@item
Program_Error or Tasking_Error is raised in the task the next time it
references any of the discriminants.
@end enumerate
@end enumerate

@enumerate 15
@item
In the first two cases, the storage for the discriminants (and for any
enclosing object if it is designated by an access discriminant of the
task) is not reclaimed prior to task termination.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
Evaluating a name that denotes a nonexistent object is erroneous. The
execution of a call to an instance of Unchecked_Deallocation is
erroneous if the object was created other than by an allocator for an
access type whose pool is Name'Storage_Pool.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
For a standard storage pool, Free should actually reclaim the storage.

NOTES

@item
(26) The rules here that refer to Free apply to any instance of
Unchecked_Deallocation.

@item
(27) Unchecked_Deallocation cannot be instantiated for an
access-to-constant type. This is implied by the rules of 12.5.4.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.11.3, 13.12, 13.11.2, 13.11
@subsection Pragma Controlled

@enumerate
@item
Pragma Controlled is used to prevent any automatic reclamation of
storage (garbage collection) for the objects created by allocators of a
given access type.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Controlled is as follows:

@item
@example
pragma Controlled(first_subtype_local_name);
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The first_subtype_local_name of a pragma Controlled shall denote a
non-derived access subtype.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A pragma Controlled is a representation pragma that specifies the
controlled aspect of representation.

@item
Garbage collection is a process that automatically reclaims storage, or
moves objects to a different address, while the objects still exist.

@item
If a pragma Controlled is specified for an access type with a standard
storage pool, then garbage collection is not performed for objects in
that pool.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation need not support garbage collection, in which case, a
pragma Controlled has no effect.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.12, 13.13, 13.11.3, 13
@section Pragma Restrictions

@enumerate
@item
A pragma Restrictions expresses the user's intent to abide by certain
restrictions. This may facilitate the construction of simpler run-time
environments.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Restrictions is as follows:

@item
@example
pragma Restrictions(restriction@{, restriction@});
@end example

@item
@example
restriction ::= restriction_identifier
   | restriction_parameter_identifier => expression
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
Unless otherwise specified for a particular restriction, the expression
is expected to be of any integer type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
Unless otherwise specified for a particular restriction, the expression
shall be static, and its value shall be nonnegative.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The set of restrictions is implementation defined.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A pragma Restrictions is a configuration pragma; unless otherwise
specified for a particular restriction, a partition shall obey the
restriction if a pragma Restrictions applies to any compilation unit
included in the partition.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may place limitations on the values of the expression
that are supported, and limitations on the supported combinations of
restrictions. The consequences of violating such limitations are
implementation defined.

NOTES

@item
(28) Restrictions intended to facilitate the construction of efficient
tasking run-time systems are defined in @ref{D.7}. Safety- and
security-related restrictions are defined in @ref{H.4}.

@item
(29) An implementation has to enforce the restrictions in cases where
enforcement is required, even if it chooses not to take advantage of the
restrictions in terms of efficiency.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.13, 13.13.1, 13.12, 13
@section Streams

@enumerate
@item
A stream is a sequence of elements comprising values from possibly
different types and allowing sequential access to these values. A stream
type is a type in the class whose root type is Streams.Root_Stream_Type.
A stream type may be implemented in various ways, such as an external
sequential file, an internal buffer, or a network channel.
@end enumerate

@menu
* 13.13.1:: The Package Streams
* 13.13.2:: Stream-Oriented Attributes
@end menu

@c ---------------------------------------------------------------------------
@node 13.13.1, 13.13.2, 13.13, 13.13
@subsection The Package Streams

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The abstract type Root_Stream_Type is the root type of the class of
stream types. The types in this class represent different kinds of
streams. A new stream type is defined by extending the root type (or
some other stream type), overriding the Read and Write operations, and
optionally defining additional primitive subprograms, according to the
requirements of the particular kind of stream. The predefined
stream-oriented attributes like T'Read and T'Write make dispatching
calls on the Read and Write procedures of the Root_Stream_Type.
(User-defined T'Read and T'Write attributes can also make such calls, or
can call the Read and Write attributes of other types.)

@item
@example
package Ada.Streams is
    pragma Pure(Streams);
@end example

@item
@example
    type Root_Stream_Type is abstract tagged limited private;
@end example

@item
@example
    type Stream_Element is mod implementation-defined;
    type Stream_Element_Offset is range implementation-defined;
    subtype Stream_Element_Count is
        Stream_Element_Offset range 0..Stream_Element_Offset'Last;
    type Stream_Element_Array is
        array(Stream_Element_Offset range <>) of Stream_Element;
@end example

@item
@example
    procedure Read(
      Stream : in out Root_Stream_Type;
      Item   : out Stream_Element_Array;
      Last   : out Stream_Element_Offset) is abstract;
@end example

@item
@example
    procedure Write(
      Stream : in out Root_Stream_Type;
      Item   : in Stream_Element_Array) is abstract;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Streams;
@end example

@item
The Read operation transfers Item'Length stream elements from the
specified stream to fill the array Item. The index of the last stream
element transferred is returned in Last. Last is less than Item'Last
only if the end of the stream is reached.

@item
The Write operation appends Item to the specified stream.

NOTES

@item
(30) See @ref{A.12.1, ``The Package Streams.Stream_IO''}, for an example of
extending type Root_Stream_Type.
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.13.2, 13.14, 13.13.1, 13.13
@subsection Stream-Oriented Attributes

@enumerate
@item
The Write, Read, Output, and Input attributes convert values to a stream
of elements and reconstruct values from a stream.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For every subtype S of a specific type T, the following attributes are
defined.

@item
S'Write

@example
S'Write denotes a procedure with the following specification:
@end example

@enumerate 4
@item
@example
procedure S'Write(
   Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item : in T)
@end example

@item
S'Write writes the value of Item to Stream.
@end enumerate
@end enumerate

@enumerate 6
@item
S'Read

@example
S'Read denotes a procedure with the following specification:
@end example

@enumerate 7
@item
@example
procedure S'Read(
   Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item : out T)
@end example

@item
S'Read reads the value of Item from Stream.
@end enumerate
@end enumerate

@enumerate 9
@item
For elementary types, the representation in terms of stream elements is
implementation defined. For composite types, the Write or Read attribute
for each component is called in a canonical order. The canonical order
of components is last dimension varying fastest for an array, and
positional aggregate order for a record. Bounds are not included in the
stream if T is an array type. If T is a discriminated type,
discriminants are included only if they have defaults. If T is a tagged
type, the tag is not included.

@item
For every subtype S'Class of a class-wide type T'Class:

@item
S'Class'Write

@example
S'Class'Write denotes a procedure with the following
specification:
@end example

@enumerate 12
@item
@example
procedure S'Class'Write(
   Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : in T'Class)
@end example

@item
Dispatches to the subprogram denoted by the Write attribute of the
specific type identified by the tag of Item.
@end enumerate
@end enumerate

@enumerate 14
@item
S'Class'Read

@example
S'Class'Read denotes a procedure with the following
specification:
@end example

@enumerate 15
@item
@example
procedure S'Class'Read(
   Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item : out T'Class)
@end example

@item
Dispatches to the subprogram denoted by the Read attribute of the
specific type identified by the tag of Item.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 17
@item
If a stream element is the same size as a storage element, then the
normal in-memory representation should be used by Read and Write for
scalar objects. Otherwise, Read and Write should use the smallest number
of stream elements needed to represent all values in the base range of
the scalar type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For every subtype S of a specific type T, the following attributes are
defined.

@item
S'Output

@example
S'Output denotes a procedure with the following specification:
@end example

@enumerate 20
@item
@example
procedure S'Output(
   Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item : in T)
@end example

@item
S'Output writes the value of Item to Stream, including any bounds or
discriminants.
@end enumerate
@end enumerate

@enumerate 22
@item
S'Input

@example
S'Input denotes a function with the following specification:
@end example

@enumerate 23
@item
@example
function S'Input(
   Stream : access Ada.Streams.Root_Stream_Type'Class)
   return T
@end example

@item
S'Input reads and returns one value from Stream, using any bounds or
discriminants written by a corresponding S'Output to determine how much
to read.
@end enumerate
@end enumerate

@enumerate 25
@item
Unless overridden by an attribute_definition_clause, these subprograms
execute as follows:

@enumerate 26
@item
If T is an array type, S'Output first writes the bounds, and S'Input
first reads the bounds. If T has discriminants without defaults,
S'Output first writes the discriminants (using S'Write for each), and
S'Input first reads the discriminants (using S'Read for each).

@item
S'Output then calls S'Write to write the value of Item to the stream.
S'Input then creates an object (with the bounds or discriminants, if
any, taken from the stream), initializes it with S'Read, and returns the
value of the object.
@end enumerate
@end enumerate

@enumerate 28
@item
For every subtype S'Class of a class-wide type T'Class:

@item
S'Class'Output

@example
S'Class'Output denotes a procedure with the following
specification:
@end example

@enumerate 30
@item
@example
procedure S'Class'Output(
   Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : in T'Class)
@end example

@item
First writes the external tag of Item to Stream (by calling
String'Output(Tags.External_Tag(Item'Tag) --  see @ref{3.9}.) and then
dispatches to the subprogram denoted by the Output attribute of the
specific type identified by the tag.
@end enumerate
@end enumerate

@enumerate 32
@item
S'Class'Input

@example
S'Class'Input denotes a function with the following
specification:
@end example

@enumerate 33
@item
@example
function S'Class'Input(
   Stream : access Ada.Streams.Root_Stream_Type'Class)
   return T'Class
@end example

@item
First reads the external tag from Stream and determines the
corresponding internal tag (by calling
Tags.Internal_Tag(String'Input(Stream)) --  see @ref{3.9}.) and then
dispatches to the subprogram denoted by the Input attribute of the
specific type identified by the internal tag; returns that result.
@end enumerate
@end enumerate

@enumerate 35
@item
In the default implementation of Read and Input for a composite type,
for each scalar component that is a discriminant or whose
component_declaration includes a default_expression, a check is made
that the value returned by Read for the component belongs to its
subtype. Constraint_Error is raised if this check fails. For other
scalar components, no check is made. For each component that is of an
access type, if the implementation can detect that the value returned by
Read for the component is not a value of its subtype, Constraint_Error
is raised. If the value is not a value of its subtype and this error is
not detected, the component has an abnormal value, and erroneous
execution can result, see @ref{13.9.1}.

@item
The stream-oriented attributes may be specified for any type via an
attribute_definition_clause. All nonlimited types have default
implementations for these operations. An attribute_reference for one of
these attributes is illegal if the type is limited, unless the attribute
has been specified by an attribute_definition_clause. For an
attribute_definition_clause specifying one of these attributes, the
subtype of the Item parameter shall be the base subtype if scalar, and
the first subtype otherwise. The same rule applies to the result of the
Input function.

NOTES

@item
(31) For a definite subtype S of a type T, only T'Write and T'Read are
needed to pass an arbitrary value of the subtype through a stream. For
an indefinite subtype S of a type T, T'Output and T'Input will normally
be needed, since T'Write and T'Read do not pass bounds, discriminants,
or tags.

@item
(32) User-specified attributes of S'Class are not inherited by other
class-wide types descended from S.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of user-defined Write attribute:

@item
@example
procedure My_Write
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : My_Integer'Base);
for My_Integer'Write use My_Write;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node 13.14, A, 13.13.2, 13
@section Freezing Rules

@enumerate
@item
This clause defines a place in the program text where each declared
entity becomes ``frozen.'' A use of an entity, such as a reference to it
by name, or (for a type) an expression of the type, causes freezing of
the entity in some contexts, as described below. The Legality Rules
forbid certain kinds of uses of an entity in the region of text where it
is frozen.

@item
The freezing of an entity occurs at one or more places (freezing points)
in the program text where the representation for the entity has to be
fully determined. Each entity is frozen from its first freezing point to
the end of the program text (given the ordering of compilation units
defined in @ref{10.1.4}.

@item
The end of a declarative_part, protected_body, or a declaration of a
library package or generic library package, causes freezing of each
entity declared within it, except for incomplete types. A noninstance
body causes freezing of each entity declared before it within the same
declarative_part.

@item
A construct that (explicitly or implicitly) references an entity can
cause the freezing of the entity, as defined by subsequent paragraphs.
At the place where a construct causes freezing, each name, expression,
or range within the construct causes freezing:

@enumerate 5
@item
The occurrence of a generic_instantiation causes freezing; also, if a
parameter of the instantiation is defaulted, the default_expression or
default_name for that parameter causes freezing.

@item
The occurrence of an object_declaration that has no corresponding
completion causes freezing.

@item
The declaration of a record extension causes freezing of the parent
subtype.
@end enumerate
@end enumerate

@enumerate 8
@item
A static expression causes freezing where it occurs. A nonstatic
expression causes freezing where it occurs, unless the expression is
part of a default_expression, a default_name, or a per-object expression
of a component's constraint, in which case, the freezing occurs later as
part of another construct.

@item
The following rules define which entities are frozen at the place where
a construct causes freezing:

@enumerate 10
@item
At the place where an expression causes freezing, the type of the
expression is frozen, unless the expression is an enumeration literal
used as a discrete_choice of the array_aggregate of an
enumeration_representation_clause.

@item
At the place where a name causes freezing, the entity denoted by the
name is frozen, unless the name is a prefix of an expanded name; at the
place where an object name causes freezing, the nominal subtype
associated with the name is frozen.

@item
At the place where a range causes freezing, the type of the range is
frozen.

@item
At the place where an allocator causes freezing, the designated subtype
of its type is frozen. If the type of the allocator is a derived type,
then all ancestor types are also frozen.

@item
At the place where a callable entity is frozen, each subtype of its
profile is frozen. If the callable entity is a member of an entry
family, the index subtype of the family is frozen. At the place where a
function call causes freezing, if a parameter of the call is defaulted,
the default_expression for that parameter causes freezing.

@item
At the place where a subtype is frozen, its type is frozen. At the place
where a type is frozen, any expressions or names within the full type
definition cause freezing; the first subtype, and any component
subtypes, index subtypes, and parent subtype of the type are frozen as
well. For a specific tagged type, the corresponding class-wide type is
frozen as well. For a class-wide type, the corresponding specific type
is frozen as well.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 16
@item
The explicit declaration of a primitive subprogram of a tagged type
shall occur before the type is frozen, see @ref{3.9.2}.

@item
A type shall be completely defined before it is frozen (see @ref{3.11.1},
and @ref{7.3}.).

@item
The completion of a deferred constant declaration shall occur before the
constant is frozen, see @ref{7.4}.

@item
A representation item that directly specifies an aspect of an entity
shall appear before the entity is frozen, see @ref{13.1}.
@end enumerate

@c ===========================================================================
@node A, A.1, 13.14, Top
@appendix  Predefined Language Environment (normative)

@enumerate
@item
This Annex contains the specifications of library units that shall be
provided by every implementation. There are three root library units:
Ada, Interfaces, and System; other library units are children of these:

@item
@example
Standard --  see @ref{A.1}.
  Ada --  see @ref{A.2}.
     Asynchronous_Task_Control --  see @ref{D.11}.
     Calendar --  see @ref{9.6}.
     Characters --  see @ref{A.3.1}.
        Handling --  see @ref{A.3.2}.
        Latin_1 --  see @ref{A.3.3}.
     Command_Line --  see @ref{A.15}.
     Decimal --  see @ref{F.2}.
     Direct_IO --  see @ref{A.8.4}.
     Dynamic_Priorities --  see @ref{D.5}.
     Exceptions --  see @ref{11.4.1}.
     Finalization --  see @ref{7.6}.
     Interrupts --  see @ref{C.3.2}.
        Names --  see @ref{C.3.2}.
     IO_Exceptions --  see @ref{A.13}.
     Numerics --  see @ref{A.5}.
        Complex_Elementary_Functions --  see @ref{G.1.2}.
        Complex_Types --  see @ref{G.1.1}.
        Discrete_Random --  see @ref{A.5.2}.
        Elementary_Functions --  see @ref{A.5.1}.
        Float_Random --  see @ref{A.5.2}.
        Generic_Complex_Elementary_Functions --  see @ref{G.1.2}.
        Generic_Complex_Types --  see @ref{G.1.1}.
        Generic_Elementary_Functions --  see @ref{A.5.1}.
     Real_Time --  see @ref{D.8}.
     Sequential_IO --  see @ref{A.8.1}.
     Storage_IO --  see @ref{A.9}.
     Streams --  see @ref{13.13.1}.
        Stream_IO --  see @ref{A.12.1}.
     Strings --  see @ref{A.4.1}.
        Bounded --  see @ref{A.4.4}.
        Fixed --  see @ref{A.4.3}.
        Maps --  see @ref{A.4.2}.
           Constants --  see @ref{A.4.6}.
        Unbounded --  see @ref{A.4.5}.
        Wide_Bounded --  see @ref{A.4.7}.
        Wide_Fixed --  see @ref{A.4.7}.
        Wide_Maps --  see @ref{A.4.7}.
           Wide_Constants --  see @ref{A.4.7}.
        Wide_Unbounded --  see @ref{A.4.7}.
Standard (...continued)
  Ada (...continued)
     Synchronous_Task_Control --  see @ref{D.10}.
     Tags --  see @ref{3.9}.
     Task_Attributes --  see @ref{C.7.2}.
     Task_Identification --  see @ref{C.7.1}.
     Text_IO --  see @ref{A.10.1}.
        Complex_IO --  see @ref{G.1.3}.
        Editing --  see @ref{F.3.3}.
        Text_Streams --  see @ref{A.12.2}.
     Unchecked_Conversion --  see @ref{13.9}.
     Unchecked_Deallocation --  see @ref{13.11.2}.
     Wide_Text_IO --  see @ref{A.11}.
        Complex_IO --  see @ref{G.1.3}.
        Editing --  see @ref{F.3.4}.
        Text_Streams --  see @ref{A.12.3}.

  Interfaces --  see @ref{B.2}.
     C --  see @ref{B.3}.
        Pointers --  see @ref{B.3.2}.
        Strings --  see @ref{B.3.1}.
     COBOL --  see @ref{B.4}.
     Fortran --  see @ref{B.5}.

  System --  see @ref{13.7}.
     Address_To_Access_Conversions --  see @ref{13.7.2}.
     Machine_Code --  see @ref{13.8}.
     RPC --  see @ref{E.5}.
     Storage_Elements --  see @ref{13.7.1}.
     Storage_Pools --  see @ref{13.11}.
@end example

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall ensure that each language defined subprogram is
reentrant in the sense that concurrent calls on the same subprogram
perform as specified, so long as all parameters that could be passed by
reference denote nonoverlapping objects.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The implementation may restrict the replacement of language-defined
compilation units. The implementation may restrict children of
language-defined library units (other than Standard).
@end enumerate

@menu
* A.1::  The Package Standard
* A.2::  The Package Ada
* A.3::  Character Handling
* A.4::  String Handling
* A.5::  The Numerics Packages
* A.6::  Input-Output
* A.7::  External Files and File Objects
* A.8::  Sequential and Direct Files
* A.9::  The Generic Package Storage_IO
* A.10:: Text Input-Output
* A.11:: Wide Text Input-Output
* A.12:: Stream Input-Output
* A.13:: Exceptions in Input-Output
* A.14:: File Sharing
* A.15:: The Package Command_Line

 --- The Detailed Node Listing ---

* A.1::     The Package Standard
* A.2::     The Package Ada
* A.3::     Character Handling
* A.3.1::   The Package Characters
* A.3.2::   The Package Characters.Handling
* A.3.3::   The Package Characters.Latin_1
* A.4::     String Handling
* A.4.1::   The Package Strings
* A.4.2::   The Package Strings.Maps
* A.4.3::   Fixed-Length String Handling
* A.4.4::   Bounded-Length String Handling
* A.4.5::   Unbounded-Length String Handling
* A.4.6::   String-Handling Sets and Mappings
* A.4.7::   Wide_String Handling
* A.5::     The Numerics Packages
* A.5.1::   Elementary Functions
* A.5.2::   Random Number Generation
* A.5.3::   Attributes of Floating Point Types
* A.5.4::   Attributes of Fixed Point Types
* A.6::     Input-Output
* A.7::     External Files and File Objects
* A.8::     Sequential and Direct Files
* A.8.1::   The Generic Package Sequential_IO
* A.8.2::   File Management
* A.8.3::   Sequential Input-Output Operations
* A.8.4::   The Generic Package Direct_IO
* A.8.5::   Direct Input-Output Operations
* A.9::     The Generic Package Storage_IO
* A.10::    Text Input-Output
* A.10.1::  The Package Text_IO
* A.10.2::  Text File Management
* A.10.3::  Default Input, Output, and Error Files
* A.10.4::  Specification of Line and Page Lengths
* A.10.5::  Operations on Columns, Lines, and Pages
* A.10.6::  Get and Put Procedures
* A.10.7::  Input-Output of Characters and Strings
* A.10.8::  Input-Output for Integer Types
* A.10.9::  Input-Output for Real Types
* A.10.10:: Input-Output for Enumeration Types
* A.11::    Wide Text Input-Output
* A.12::    Stream Input-Output
* A.12.1::  The Package Streams.Stream_IO
* A.12.2::  The Package Text_IO.Text_Streams
* A.12.3::  The Package Wide_Text_IO.Text_Streams
* A.13::    Exceptions in Input-Output
* A.14::    File Sharing
* A.15::    The Package Command_Line
@end menu

@c ---------------------------------------------------------------------------
@node A.1, A.2, A, A
@section The Package Standard

@enumerate
@item
This clause outlines the specification of the package Standard
containing all predefined identifiers in the language. The corresponding
package body is not specified by the language.

@item
The operators that are predefined for the types declared in the package
Standard are given in comments since they are implicitly declared.
Italics are used for pseudo-names of anonymous types (such as root_real)
and for undefined information (such as implementation-defined).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Standard has the following declaration:

@item
@example
package Standard is
   pragma Pure(Standard);
@end example

@item
@example
   type Boolean is (False, True);
@end example

@item
@example
   --  The predefined relational operators
   --  for this type are as follows:
@end example

@item
@example
   -- function "="   (Left, Right : Boolean) return Boolean;
   -- function "/="  (Left, Right : Boolean) return Boolean;
   -- function "<"   (Left, Right : Boolean) return Boolean;
   -- function "<="  (Left, Right : Boolean) return Boolean;
   -- function ">"   (Left, Right : Boolean) return Boolean;
   -- function ">="  (Left, Right : Boolean) return Boolean;
@end example

@item
@example
   --  The predefined logical operators and the predefined
   --  logical negation operator are as follows:
@end example

@item
@example
   --  function "and" (Left, Right : Boolean) return Boolean;
   --  function "or"  (Left, Right : Boolean) return Boolean;
   --  function "xor" (Left, Right : Boolean) return Boolean;
@end example

@item
@example
   --  function "not" (Right : Boolean) return Boolean;
@end example

@item
@example
   --  The integer type root_integer is predefined.
   --  The corresponding universal type is universal_integer.
@end example

@item
@example
   type Integer is range implementation-defined;
@end example

@item
@example
   subtype Natural  is Integer range 0 .. Integer'Last;
   subtype Positive is Integer range 1 .. Integer'Last;
@end example

@item
@example
   --  The predefined operators for type Integer are as follows:
@end example

@item
@example
   --  function "="  (Left, Right : Integer'Base) return Boolean;
   --  function "/=" (Left, Right : Integer'Base) return Boolean;
   --  function "<"  (Left, Right : Integer'Base) return Boolean;
   --  function "<=" (Left, Right : Integer'Base) return Boolean;
   --  function ">"  (Left, Right : Integer'Base) return Boolean;
   --  function ">=" (Left, Right : Integer'Base) return Boolean;
@end example

@item
@example
   --  function "+"   (Right : Integer'Base) return Integer'Base;
   --  function "-"   (Right : Integer'Base) return Integer'Base;
   --  function "abs" (Right : Integer'Base) return Integer'Base;
@end example

@item
@example
   --  function "+"   (Left, Right : Integer'Base)
   --    return Integer'Base;
   --  function "-"   (Left, Right : Integer'Base)
   --    return Integer'Base;
   --  function "*"   (Left, Right : Integer'Base)
   --    return Integer'Base;
   --  function "/"   (Left, Right : Integer'Base)
   --    return Integer'Base;
   --  function "rem" (Left, Right : Integer'Base)
   --    return Integer'Base;
   --  function "mod" (Left, Right : Integer'Base)
   --    return Integer'Base;
@end example

@item
@example
   --  function "**"
     (Left  : Integer'Base;
      Right : Natural) return Integer'Base;
@end example

@item
@example
   --  The specification of each operator for the type
   --  root_integer, or for any additional predefined integer
   --  type, is obtained by replacing Integer by the name of the type
   --  in the specification of the corresponding operator of the type
   --  Integer. The right operand of the exponentiation operator
   --  remains as subtype Natural.
@end example

@item
@example
   --  The floating point type root_real is predefined.
   --  The corresponding universal type is universal_real.
@end example

@item
@example
   type Float is digits implementation-defined;
@end example

@item
@example
   --  The predefined operators for this type are as follows:
@end example

@item
@example
   --  function "="   (Left, Right : Float) return Boolean;
   --  function "/="  (Left, Right : Float) return Boolean;
   --  function "<"   (Left, Right : Float) return Boolean;
   --  function "<="  (Left, Right : Float) return Boolean;
   --  function ">"   (Left, Right : Float) return Boolean;
   --  function ">="  (Left, Right : Float) return Boolean;
@end example

@item
@example
   --  function "+"   (Right : Float) return Float;
   --  function "-"   (Right : Float) return Float;
   --  function "abs" (Right : Float) return Float;
@end example

@item
@example
   --  function "+"   (Left, Right : Float) return Float;
   --  function "-"   (Left, Right : Float) return Float;
   --  function "*"   (Left, Right : Float) return Float;
   --  function "/"   (Left, Right : Float) return Float;
@end example

@item
@example
   --  function "**"
     (Left  : Float;
      Right : Integer'Base) return Float;
@end example

@item
@example
   --  The specification of each operator for the type root_real,
   --  or  for any additional predefined floating point type, is
   --  obtained by replacing Float by the name of the type in the
   --  specification of the corresponding operator of the type Float.
@end example

@item
@example
   --  In addition, the following operators are predefined for
   --  the root numeric types:
@end example

@item
@example
   function "*" (Left : root_integer; Right : root_real)
     return root_real;
@end example

@item
@example
   function "*" (Left : root_real; Right : root_integer)
     return root_real;
@end example

@item
@example
   function "/" (Left : root_real; Right : root_integer)
     return root_real;
@end example

@item
@example
   --  The type universal_fixed is predefined.
   --  The only multiplying operators defined between
   --  fixed point types are
@end example

@item
@example
   function "*" (Left : universal_fixed; Right : universal_fixed)
     return universal_fixed;
@end example

@item
@example
   function "/" (Left : universal_fixed; Right : universal_fixed)
     return universal_fixed;

   --  The declaration of type Character is based on the standard
   --  ISO 8859-1 character set.
@end example

@item
@example
   --  There are no character literals corresponding to the
   --  positions for control characters. They are indicated in
   --  italics in this definition (@pxref{3.5.2}).

   type Character is

     (nul,  soh,  stx,  etx, eot,  enq,  ack,  bel,
      bs,   ht,   lf,   vt,  ff,   cr,   so,   si,

      dle,  dc1,  dc2,  dc3, dc4,  nak,  syn,  etb,
      can,  em,   sub,  esc, fs,   gs,   rs,   us,

      ' ',  '!',  '"',  '#', '$',  '%',  '&',  ''',
      '(',  ')',  '*',  '+', ',',  '-',  '.',  '/',

      '0',  '1',  '2',  '3', '4',  '5',  '6',  '7',
      '8',  '9',  ':',  ';', '<',  '=',  '>',  '?',

      '@',  'A',  'B',  'C', 'D',  'E',  'F',  'G',
      'H',  'I',  'J',  'K', 'L',  'M',  'N',  'O',

      'P',  'Q',  'R',  'S', 'T',  'U',  'V',  'W',
      'X',  'Y',  'Z',  '[', '\',  ']',  '^',  '_',

      '`',  'a',  'b',  'c', 'd',  'e',  'f',  'g',
      'h',  'i',  'j',  'k', 'l',  'm',  'n',  'o',

      'p',  'q',  'r',  's', 't',  'u',  'v',  'w',
      'x',  'y',  'z',  '@{', '|',  '@}',  '~',  del,

      reserved_128, reserved_129,  bph,  nbh,
      reserved_132, nel,     ssa,  esa,

      hts, htj, vts, pld, plu, ri, ss2, ss3,

      dcs, pu1, pu2, sts, cch, mw, spa, epa,

      sos, reserved_153, sci, csi,
      st,  osc,          pm,  apc,

   ... );
@end example

@item
@example
   --  The predefined operators for the type Character are the
   --  same as for any enumeration type.

   --  The declaration of type Wide_Character is based on the
   --  standard ISO 10646 BMP character set. The first 256 positions
   --  have the same contents as type Character (@pxref{3.5.2}).

   type Wide_Character is (nul, soh ... FFFE, FFFF);

   package ASCII is ... end ASCII;  --Obsolescent;  (@pxref{J.5}).

   -- Predefined string types:
@end example

@item
@example
   type String is array(Positive range <>) of Character;
   pragma Pack(String);
@end example

@item
@example
   -- The predefined operators for this type are as follows:
@end example

@item
@example
   --  function "="  (Left, Right: String) return Boolean;
   --  function "/=" (Left, Right: String) return Boolean;
   --  function "<"  (Left, Right: String) return Boolean;
   --  function "<=" (Left, Right: String) return Boolean;
   --  function ">"  (Left, Right: String) return Boolean;
   --  function ">=" (Left, Right: String) return Boolean;
@end example

@item
@example
   --  function "&" (Left: String;    Right: String)
   --    return String;
   --  function "&" (Left: Character; Right: String)
   --    return String;
   --  function "&" (Left: String;    Right: Character)
   --    return String;
   --  function "&" (Left: Character; Right: Character)
   --    return String;
@end example

@item
@example
   type Wide_String is array(Positive range <>) of Wide_Character;
   pragma Pack(Wide_String);
@end example

@item
@example
   --  The predefined operators for this type correspond to those
   --  for String
@end example

@item
@example
   type Duration is delta
     implementation-defined range implementation-defined;
@end example

@item
@example
   --  The predefined operators for the type Duration are the
   --  same as for any fixed point type.
@end example

@item
@example
   -- The predefined exceptions:
@end example

@item
@example
   Constraint_Error: exception;
   Program_Error   : exception;
   Storage_Error   : exception;
   Tasking_Error   : exception;
@end example

@item
@example
end Standard;
@end example

@item
Standard has no private part.

@item
In each of the types Character and Wide_Character, the character
literals for the space character (position 32) and the non-breaking
space character (position 160) correspond to different values. Unless
indicated otherwise, each occurrence of the character literal ' ' in
this International Standard refers to the space character. Similarly,
the character literals for hyphen (position 45) and soft hyphen
(position 173) correspond to different values. Unless indicated
otherwise, each occurrence of the character literal '-' in this
International Standard refers to the hyphen character.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Elaboration of the body of Standard has no effect.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may provide additional predefined integer types and
additional predefined floating point types. Not all of these types need
have names.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If an implementation provides additional named predefined integer types,
then the names should end with ``Integer'' as in ``Long_Integer''. If an
implementation provides additional named predefined floating point
types, then the names should end with ``Float'' as in ``Long_Float''.

NOTES

@item
(1) Certain aspects of the predefined entities cannot be completely
described in the language itself. For example, although the enumeration
type Boolean can be written showing the two enumeration literals False
and True, the short-circuit control forms cannot be expressed in the
language.

@item
(2) As explained in @ref{8.1, ``Declarative Region''}, and
@ref{10.1.4, ``The Compilation Process''}, the declarative region of
the package Standard encloses every library unit and consequently the
main subprogram; the declaration of every library unit is assumed to
occur within this declarative region. Library_items are assumed to be
ordered in such a way that there are no forward semantic dependences.
However, as explained in @ref{8.3, ``Visibility''}, the only library
units that are visible within a given compilation unit are the library
units named by all with_clauses that apply to the given unit, and
moreover, within the declarative region of a given library unit, that
library unit itself.

@item
(3) If all block_statements of a program are named, then the name of
each program unit can always be written as an expanded name starting
with Standard (unless Standard is itself hidden). The name of a library
unit cannot be a homograph of a name (such as Integer) that is already
declared in Standard.

@item
(4) The exception Standard.Numeric_Error is defined in @ref{J.6}.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.2, A.3, A.1, A
@section The Package Ada

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined library package exists:

@item
@example
package Ada is
    pragma Pure(Ada);
end Ada;
@end example

@item
Ada serves as the parent of most of the other language-defined library
units; its declaration is empty (except for the pragma Pure).

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
In the standard mode, it is illegal to compile a child of package Ada.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.3, A.3.1, A.2, A
@section Character Handling

@enumerate
@item
This clause presents the packages related to character processing: an
empty pure package Characters and child packages Characters.Handling and
Characters.Latin_1. The package Characters.Handling provides
classification and conversion functions for Character data, and some
simple functions for dealing with Wide_Character data. The child package
Characters.Latin_1 declares a set of constants initialized to values of
type Character.
@end enumerate

@menu
* A.3.1:: The Package Characters
* A.3.2:: The Package Characters.Handling
* A.3.3:: The Package Characters.Latin_1
@end menu

@c ---------------------------------------------------------------------------
@node A.3.1, A.3.2, A.3, A.3
@subsection The Package Characters

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The library package Characters has the following declaration:

@item
@example
package Ada.Characters is
  pragma Pure(Characters);
end Ada.Characters;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.3.2, A.3.3, A.3.1, A.3
@subsection The Package Characters.Handling

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The library package Characters.Handling has the following declaration:

@item
@example
package Ada.Characters.Handling is
  pragma Preelaborate(Handling);
@end example

@item
@example
  --  Character classification functions
@end example

@item
@example
  function Is_Control           (Item : in Character) return Boolean;
  function Is_Graphic           (Item : in Character) return Boolean;
  function Is_Letter            (Item : in Character) return Boolean;
  function Is_Lower             (Item : in Character) return Boolean;
  function Is_Upper             (Item : in Character) return Boolean;
  function Is_Basic             (Item : in Character) return Boolean;
  function Is_Digit             (Item : in Character) return Boolean;
  function Is_Decimal_Digit     (Item : in Character) return Boolean
    renames Is_Digit;
  function Is_Hexadecimal_Digit (Item : in Character) return Boolean;
  function Is_Alphanumeric      (Item : in Character) return Boolean;
  function Is_Special           (Item : in Character) return Boolean;
@end example

@item
@example
  --  Conversion functions for Character and String
@end example

@item
@example
  function To_Lower (Item : in Character) return Character;
  function To_Upper (Item : in Character) return Character;
  function To_Basic (Item : in Character) return Character;
@end example

@item
@example
  function To_Lower (Item : in String) return String;
  function To_Upper (Item : in String) return String;
  function To_Basic (Item : in String) return String;
@end example

@item
@example
  --  Classifications of and conversions
  --  between Character and ISO 646
@end example

@item
@example
  subtype ISO_646 is
    Character range Character'Val(0) .. Character'Val(127);
@end example

@item
@example
  function Is_ISO_646 (Item : in Character) return Boolean;
  function Is_ISO_646 (Item : in String)    return Boolean;
@end example

@item
@example
  function To_ISO_646 (Item       : in Character;
                       Substitute : in ISO_646 := ' ')
    return ISO_646;
@end example

@item
@example
  function To_ISO_646 (Item       : in String;
                       Substitute : in ISO_646 := ' ')
    return String;
@end example

@item
@example
  --  Classifications of and conversions
  --  between Wide_Character and Character.
@end example

@item
@example
 function Is_Character (Item : in Wide_Character) return Boolean;
 function Is_String    (Item : in Wide_String)    return Boolean;
@end example

@item
@example
  function To_Character (Item       : in Wide_Character;
                         Substitute : in Character := ' ')
    return Character;
@end example

@item
@example
  function To_String (Item       : in Wide_String;
                      Substitute : in Character := ' ')
    return String;
@end example

@item
@example
  function To_Wide_Character (Item : in Character)
    return Wide_Character;
@end example

@item
@example
  function To_Wide_String (Item : in String) return Wide_String;
@end example

@item
@example
end Ada.Characters.Handling;
@end example

@item
In the description below for each function that returns a Boolean
result, the effect is described in terms of the conditions under which
the value True is returned. If these conditions are not met, then the
function returns False.

@item
Each of the following classification functions has a formal Character
parameter, Item, and returns a Boolean result.

@item
Is_Control

@example
True if Item is a control character. A control character is
a character whose position is in one of the ranges 0..31 or
127..159.
@end example

@item
Is_Graphic

@example
True if Item is a graphic character. A graphic character is
a character whose position is in one of the ranges 32..126 or
160..255.
@end example

@item
Is_Letter

@example
True if Item is a letter. A letter is a character that is in
one of the ranges 'A'..'Z' or 'a'..'z', or whose position is
in one of the ranges 192..214, 216..246, or 248..255.
@end example

@item
Is_Lower

@example
True if Item is a lower-case letter. A lower-case letter is
a character that is in the range 'a'..'z', or whose position
is in one of the ranges 223..246 or 248..255.
@end example

@item
Is_Upper

@example
True if Item is an upper-case letter. An upper-case letter
is a character that is in the range 'A'..'Z' or whose
position is in one of the ranges 192..214 or 216.. 222.
@end example

@item
Is_Basic

@example
True if Item is a basic letter. A basic letter is a
character that is in one of the ranges 'A'..'Z' and 'a'..'z',
or that is one of the following: an upper- or lower-case AE
diphthong, an upper- or lower-case Icelandic eth, an upper-
or lower-case Icelandic thorn, or a sharp-s.
@end example

@item
Is_Digit

@example
True if Item is a decimal digit. A decimal digit is a
character in the range '0'..'9'.
@end example

@item
Is_Decimal_Digit

@example
A renaming of Is_Digit.
@end example

@item
Is_Hexadecimal_Digit

@example
True if Item is a hexadecimal digit. A hexadecimal digit is
a character that is either a decimal digit or that is in one
of the ranges 'A' .. 'F' or 'a' .. 'f'.
@end example

@item
Is_Alphanumeric

@example
True if Item is an alphanumeric character. An alphanumeric
character is a character that is either a letter or a decimal
digit.
@end example

@item
Is_Special

@example
True if Item is a special graphic character. A special
graphic character is a graphic character that is not
alphanumeric.
@end example

@item
Each of the names To_Lower, To_Upper, and To_Basic refers to two
functions: one that converts from Character to Character, and the other
that converts from String to String. The result of each
Character-to-Character function is described below, in terms of the
conversion applied to Item, its formal Character parameter. The result
of each String-to-String conversion is obtained by applying to each
element of the function's String parameter the corresponding
Character-to-Character conversion; the result is the null String if the
value of the formal parameter is the null String. The lower bound of the
result String is 1.

@item
To_Lower

@example
Returns the corresponding lower-case value for Item if
Is_Upper(Item), and returns Item otherwise.
@end example

@item
To_Upper

@example
Returns the corresponding upper-case value for Item if
Is_Lower(Item) and Item has an upper-case form, and returns Item
otherwise. The lower case letters sharp-s and y-diaeresis do
not have upper case forms.
@end example

@item
To_Basic

@example
Returns the letter corresponding to Item but with no
diacritical mark, if Item is a letter but not a basic letter;
returns Item otherwise.
@end example

@item
The following set of functions test for membership in the ISO 646
character range, or convert between ISO 646 and Character.

@item
Is_ISO_646

@example
The function whose formal parameter, Item, is of type
Character returns True if Item is in the subtype ISO_646.
@end example

@item
Is_ISO_646

@example
The function whose formal parameter, Item, is of type String
returns True if Is_ISO_646(Item(I)) is True for each I in
Item'Range.
@end example

@item
To_ISO_646

@example
The function whose first formal parameter, Item, is of type
Character returns Item if Is_ISO_646(Item), and returns the
Substitute ISO_646 character otherwise.
@end example

@item
To_ISO_646

@example
The function whose first formal parameter, Item, is of type
String returns the String whose Range is 1..Item'Length and
each of whose elements is given by To_ISO_646 of the
corresponding element in Item.
@end example

@item
The following set of functions test Wide_Character values for membership
in Character, or convert between corresponding characters of
Wide_Character and Character.

@item
Is_Character

@example
Returns True if Wide_Character'Pos(Item) <=
Character'Pos(Character'Last).
@end example

@item
Is_String

@example
Returns True if Is_Character(Item(I)) is True for each I in
Item'Range.
@end example

@item
To_Character

@example
Returns the Character corresponding to Item if
Is_Character(Item), and returns the Substitute Character
otherwise.
@end example

@item
To_String

@example
Returns the String whose range is 1..Item'Length and each of
whose elements is given by To_Character of the corresponding
element in Item.
@end example

@item
To_Wide_Character

@example
Returns the Wide_Character X such that Character'Pos(Item) =
Wide_Character'Pos(X).
@end example

@item
To_Wide_String

@example
Returns the Wide_String whose range is 1..Item'Length and
each of whose elements is given by To_Wide_Character of the
corresponding element in Item.
@end example

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If an implementation provides a localized definition of Character or
Wide_Character, then the effects of the subprograms in
Characters.Handling should reflect the localizations. See also
@ref{3.5.2}.

NOTES

@item
(5) A basic letter is a letter without a diacritical mark.

@item
(6) Except for the hexadecimal digits, basic letters, and ISO_646
characters, the categories identified in the classification functions
form a strict hierarchy:

@enumerate 52
@item
Control characters

@item
Graphic characters

@enumerate 54
@item
Alphanumeric characters

@enumerate 55
@item
Letters

@enumerate 56
@item
Upper-case letters

@item
Lower-case letters
@end enumerate
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate
@enumerate 58
@item
Decimal digits
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 59
@item
Special graphic characters
@end enumerate
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node A.3.3, A.4, A.3.2, A.3
@subsection The Package Characters.Latin_1

@enumerate
@item
The package Characters.Latin_1 declares constants for characters in ISO
8859-1.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Characters.Latin_1 has the following declaration:

@item
@example
package Ada.Characters.Latin_1 is
    pragma Pure(Latin_1);
@end example

@item
@example
  -- Control characters:
@end example

@item
@example
  NUL                  : constant Character := Character'Val(0);
  SOH                  : constant Character := Character'Val(1);
  STX                  : constant Character := Character'Val(2);
  ETX                  : constant Character := Character'Val(3);
  EOT                  : constant Character := Character'Val(4);
  ENQ                  : constant Character := Character'Val(5);
  ACK                  : constant Character := Character'Val(6);
  BEL                  : constant Character := Character'Val(7);
  BS                   : constant Character := Character'Val(8);
  HT                   : constant Character := Character'Val(9);
  LF                   : constant Character := Character'Val(10);
  VT                   : constant Character := Character'Val(11);
  FF                   : constant Character := Character'Val(12);
  CR                   : constant Character := Character'Val(13);
  SO                   : constant Character := Character'Val(14);
  SI                   : constant Character := Character'Val(15);
@end example

@item
@example
  DLE                  : constant Character := Character'Val(16);
  DC1                  : constant Character := Character'Val(17);
  DC2                  : constant Character := Character'Val(18);
  DC3                  : constant Character := Character'Val(19);
  DC4                  : constant Character := Character'Val(20);
  NAK                  : constant Character := Character'Val(21);
  SYN                  : constant Character := Character'Val(22);
  ETB                  : constant Character := Character'Val(23);
  CAN                  : constant Character := Character'Val(24);
  EM                   : constant Character := Character'Val(25);
  SUB                  : constant Character := Character'Val(26);
  ESC                  : constant Character := Character'Val(27);
  FS                   : constant Character := Character'Val(28);
  GS                   : constant Character := Character'Val(29);
  RS                   : constant Character := Character'Val(30);
  US                   : constant Character := Character'Val(31);
@end example

@item
@example
  -- ISO 646 graphic characters:
@end example

@item
@example
  Space                : constant Character := ' ';
                         -- Character'Val(32)
  Exclamation          : constant Character := '!';
                         -- Character'Val(33)
  Quotation            : constant Character := '"';
                         -- Character'Val(34)
  Number_Sign          : constant Character := '#';
                         -- Character'Val(35)
  Dollar_Sign          : constant Character := '$';
                         -- Character'Val(36)
  Percent_Sign         : constant Character := '%';
                         -- Character'Val(37)
  Ampersand            : constant Character := '&';
                         -- Character'Val(38)
  Apostrophe           : constant Character := ''';
                         -- Character'Val(39)
  Left_Parenthesis     : constant Character := '(';
                         -- Character'Val(40)
  Right_Parenthesis    : constant Character := ')';
                         -- Character'Val(41)
  Asterisk             : constant Character := '*';
                         -- Character'Val(42)
  Plus_Sign            : constant Character := '+';
                         -- Character'Val(43)
  Comma                : constant Character := ',';
                         -- Character'Val(44)
  Hyphen               : constant Character := '-';
                         -- Character'Val(45)
  Minus_Sign           : Character renames Hyphen;
  Full_Stop            : constant Character := '.';
                         -- Character'Val(46)
  Solidus              : constant Character := '/';
                         -- Character'Val(47)
@end example

@item
@example
  -- Decimal digits '0' though '9' are at positions 48 through 57
@end example

@item
@example
  Colon                : constant Character := ':';
                         -- Character'Val(58)
  Semicolon            : constant Character := ';';
                         -- Character'Val(59)
  Less_Than_Sign       : constant Character := '<';
                         -- Character'Val(60)
  Equals_Sign          : constant Character := '=';
                         -- Character'Val(61)
  Greater_Than_Sign    : constant Character := '>';
                         -- Character'Val(62)
  Question             : constant Character := '?';
                         -- Character'Val(63)
  Commercial_At        : constant Character := '@';
                         -- Character'Val(64)
@end example

@item
@example
  -- Letters 'A' through 'Z' are at positions 65 through 90
@end example

@item
@example
  Left_Square_Bracket  : constant Character := '[';
                         -- Character'Val(91)
  Reverse_Solidus      : constant Character := '\';
                         -- Character'Val(92)
  Right_Square_Bracket : constant Character := ']';
                         -- Character'Val(93)
  Circumflex           : constant Character := '^';
                         -- Character'Val(94)
  Low_Line             : constant Character := '_';
                         -- Character'Val(95)
@end example

@item
@example
  Grave                : constant Character := '`';
                         -- Character'Val(96)
  LC_A                 : constant Character := 'a';
                         -- Character'Val(97)
  LC_B                 : constant Character := 'b';
                         -- Character'Val(98)
  LC_C                 : constant Character := 'c';
                         -- Character'Val(99)
  LC_D                 : constant Character := 'd';
                         -- Character'Val(100)
  LC_E                 : constant Character := 'e';
                         -- Character'Val(101)
  LC_F                 : constant Character := 'f';
                         -- Character'Val(102)
  LC_G                 : constant Character := 'g';
                         -- Character'Val(103)
  LC_H                 : constant Character := 'h';
                         -- Character'Val(104)
  LC_I                 : constant Character := 'i';
                         -- Character'Val(105)
  LC_J                 : constant Character := 'j';
                         -- Character'Val(106)
  LC_K                 : constant Character := 'k';
                         -- Character'Val(107)
  LC_L                 : constant Character := 'l';
                         -- Character'Val(108)
  LC_M                 : constant Character := 'm';
                         -- Character'Val(109)
  LC_N                 : constant Character := 'n';
                         -- Character'Val(110)
  LC_O                 : constant Character := 'o';
                         -- Character'Val(111)
@end example

@item
@example
  LC_P                 : constant Character := 'p';
                         -- Character'Val(112)
  LC_Q                 : constant Character := 'q';
                         -- Character'Val(113)
  LC_R                 : constant Character := 'r';
                         -- Character'Val(114)
  LC_S                 : constant Character := 's';
                         -- Character'Val(115)
  LC_T                 : constant Character := 't';
                         -- Character'Val(116)
  LC_U                 : constant Character := 'u';
                         -- Character'Val(117)
  LC_V                 : constant Character := 'v';
                         -- Character'Val(118)
  LC_W                 : constant Character := 'w';
                         -- Character'Val(119)
  LC_X                 : constant Character := 'x';
                         -- Character'Val(120)
  LC_Y                 : constant Character := 'y';
                         -- Character'Val(121)
  LC_Z                 : constant Character := 'z';
                         -- Character'Val(122)
  Left_Curly_Bracket   : constant Character := '@{';
                         -- Character'Val(123)
  Vertical_Line        : constant Character := '|';
                         -- Character'Val(124)
  Right_Curly_Bracket  : constant Character := '@}';
                         -- Character'Val(125)
  Tilde                : constant Character := '~';
                         -- Character'Val(126)
  DEL                  : constant Character := Character'Val(127);
@end example

@item
@example
  -- ISO 6429 control characters:
@end example

@item
@example
  IS4                  : Character renames FS;
  IS3                  : Character renames GS;
  IS2                  : Character renames RS;
  IS1                  : Character renames US;
@end example

@item
@example
  Reserved_128         : constant Character := Character'Val(128);
  Reserved_129         : constant Character := Character'Val(129);
  BPH                  : constant Character := Character'Val(130);
  NBH                  : constant Character := Character'Val(131);
  Reserved_132         : constant Character := Character'Val(132);
  NEL                  : constant Character := Character'Val(133);
  SSA                  : constant Character := Character'Val(134);
  ESA                  : constant Character := Character'Val(135);
  HTS                  : constant Character := Character'Val(136);
  HTJ                  : constant Character := Character'Val(137);
  VTS                  : constant Character := Character'Val(138);
  PLD                  : constant Character := Character'Val(139);
  PLU                  : constant Character := Character'Val(140);
  RI                   : constant Character := Character'Val(141);
  SS2                  : constant Character := Character'Val(142);
  SS3                  : constant Character := Character'Val(143);
@end example

@item
@example
  DCS                  : constant Character := Character'Val(144);
  PU1                  : constant Character := Character'Val(145);
  PU2                  : constant Character := Character'Val(146);
  STS                  : constant Character := Character'Val(147);
  CCH                  : constant Character := Character'Val(148);
  MW                   : constant Character := Character'Val(149);
  SPA                  : constant Character := Character'Val(150);
  EPA                  : constant Character := Character'Val(151);
@end example

@item
@example
  SOS                  : constant Character := Character'Val(152);
  Reserved_153         : constant Character := Character'Val(153);
  SCI                  : constant Character := Character'Val(154);
  CSI                  : constant Character := Character'Val(155);
  ST                   : constant Character := Character'Val(156);
  OSC                  : constant Character := Character'Val(157);
  PM                   : constant Character := Character'Val(158);
  APC                  : constant Character := Character'Val(159);
@end example

@item
@example
  -- Other graphic characters:
@end example

@item
@example
  -- Character positions 160 (16#A0#) .. 175 (16#AF#):
  No_Break_Space              : constant Character := ' ';
                                -- Character'Val(160)
  NBSP                        : Character renames No_Break_Space;
  Inverted_Exclamation        : constant Character :=
    Character'Val(161);
  Cent_Sign                   : constant Character :=
    Character'Val(162);
  Pound_Sign                  : constant Character :=
    Character'Val(163);
  Currency_Sign               : constant Character :=
    Character'Val(164);
  Yen_Sign                    : constant Character :=
    Character'Val(165);
  Broken_Bar                  : constant Character :=
    Character'Val(166);
  Section_Sign                : constant Character :=
    Character'Val(167);
  Diaeresis                   : constant Character :=
    Character'Val(168);
  Copyright_Sign              : constant Character :=
    Character'Val(169);
  Feminine_Ordinal_Indicator  : constant Character :=
    Character'Val(170);
  Left_Angle_Quotation        : constant Character :=
    Character'Val(171);
  Not_Sign                    : constant Character :=
    Character'Val(172);
  Soft_Hyphen                 : constant Character :=
    Character'Val(173);
  Registered_Trade_Mark_Sign  : constant Character :=
    Character'Val(174);
  Macron                      : constant Character :=
    Character'Val(175);
@end example

@item
@example
  -- Character positions 176 (16#B0#) .. 191 (16#BF#):
  Degree_Sign                 : constant Character :=
    Character'Val(176);
  Ring_Above                  : Character renames Degree_Sign;
  Plus_Minus_Sign             : constant Character :=
    Character'Val(177);
  Superscript_Two             : constant Character :=
    Character'Val(178);
  Superscript_Three           : constant Character :=
    Character'Val(179);
  Acute                       : constant Character :=
    Character'Val(180);
  Micro_Sign                  : constant Character :=
    Character'Val(181);
  Pilcrow_Sign                : constant Character :=
    Character'Val(182);
  Paragraph_Sign              : Character renames Pilcrow_Sign;
  Middle_Dot                  : constant Character :=
    Character'Val(183);
  Cedilla                     : constant Character :=
    Character'Val(184);
  Superscript_One             : constant Character :=
    Character'Val(185);
  Masculine_Ordinal_Indicator : constant Character :=
    Character'Val(186);
  Right_Angle_Quotation       : constant Character :=
    Character'Val(187);
  Fraction_One_Quarter        : constant Character :=
    Character'Val(188);
  Fraction_One_Half           : constant Character :=
    Character'Val(189);
  Fraction_Three_Quarters     : constant Character :=
    Character'Val(190);
  Inverted_Question           : constant Character :=
    Character'Val(191);
@end example

@item
@example
  -- Character positions 192 (16#C0#) .. 207 (16#CF#):
  UC_A_Grave                  : constant Character :=
    Character'Val(192);
  UC_A_Acute                  : constant Character :=
    Character'Val(193);
  UC_A_Circumflex             : constant Character :=
    Character'Val(194);
  UC_A_Tilde                  : constant Character :=
    Character'Val(195);
  UC_A_Diaeresis              : constant Character :=
    Character'Val(196);
  UC_A_Ring                   : constant Character :=
    Character'Val(197);
  UC_AE_Diphthong             : constant Character :=
    Character'Val(198);
  UC_C_Cedilla                : constant Character :=
    Character'Val(199);
  UC_E_Grave                  : constant Character :=
    Character'Val(200);
  UC_E_Acute                  : constant Character :=
    Character'Val(201);
  UC_E_Circumflex             : constant Character :=
    Character'Val(202);
  UC_E_Diaeresis              : constant Character :=
    Character'Val(203);
  UC_I_Grave                  : constant Character :=
    Character'Val(204);
  UC_I_Acute                  : constant Character :=
    Character'Val(205);
  UC_I_Circumflex             : constant Character :=
    Character'Val(206);
  UC_I_Diaeresis              : constant Character :=
    Character'Val(207);
@end example

@item
@example
  -- Character positions 208 (16#D0#) .. 223 (16#DF#):
  UC_Icelandic_Eth            : constant Character :=
    Character'Val(208);
  UC_N_Tilde                  : constant Character :=
    Character'Val(209);
  UC_O_Grave                  : constant Character :=
    Character'Val(210);
  UC_O_Acute                  : constant Character :=
    Character'Val(211);
  UC_O_Circumflex             : constant Character :=
    Character'Val(212);
  UC_O_Tilde                  : constant Character :=
    Character'Val(213);
  UC_O_Diaeresis              : constant Character :=
    Character'Val(214);
  Multiplication_Sign         : constant Character :=
    Character'Val(215);
  UC_O_Oblique_Stroke         : constant Character :=
    Character'Val(216);
  UC_U_Grave                  : constant Character :=
    Character'Val(217);
  UC_U_Acute                  : constant Character :=
    Character'Val(218);
  UC_U_Circumflex             : constant Character :=
    Character'Val(219);
  UC_U_Diaeresis              : constant Character :=
    Character'Val(220);
  UC_Y_Acute                  : constant Character :=
    Character'Val(221);
  UC_Icelandic_Thorn          : constant Character :=
    Character'Val(222);
  LC_German_Sharp_S           : constant Character :=
    Character'Val(223);
@end example

@item
@example
  -- Character positions 224 (16#E0#) .. 239 (16#EF#):
  LC_A_Grave                  : constant Character :=
    Character'Val(224);
  LC_A_Acute                  : constant Character :=
    Character'Val(225);
  LC_A_Circumflex             : constant Character :=
    Character'Val(226);
  LC_A_Tilde                  : constant Character :=
    Character'Val(227);
  LC_A_Diaeresis              : constant Character :=
    Character'Val(228);
  LC_A_Ring                   : constant Character :=
    Character'Val(229);
  LC_AE_Diphthong             : constant Character :=
    Character'Val(230);
  LC_C_Cedilla                : constant Character :=
    Character'Val(231);
  LC_E_Grave                  : constant Character :=
    Character'Val(232);
  LC_E_Acute                  : constant Character :=
    Character'Val(233);
  LC_E_Circumflex             : constant Character :=
    Character'Val(234);
  LC_E_Diaeresis              : constant Character :=
    Character'Val(235);
  LC_I_Grave                  : constant Character :=
    Character'Val(236);
  LC_I_Acute                  : constant Character :=
    Character'Val(237);
  LC_I_Circumflex             : constant Character :=
    Character'Val(238);
  LC_I_Diaeresis              : constant Character :=
    Character'Val(239);
@end example

@item
@example
  -- Character positions 240 (16#F0#) .. 255 (16#FF#):
  LC_Icelandic_Eth            : constant Character :=
    Character'Val(240);
  LC_N_Tilde                  : constant Character :=
    Character'Val(241);
  LC_O_Grave                  : constant Character :=
    Character'Val(242);
  LC_O_Acute                  : constant Character :=
    Character'Val(243);
  LC_O_Circumflex             : constant Character :=
    Character'Val(244);
  LC_O_Tilde                  : constant Character :=
    Character'Val(245);
  LC_O_Diaeresis              : constant Character :=
    Character'Val(246);
  Division_Sign               : constant Character :=
    Character'Val(247);
  LC_O_Oblique_Stroke         : constant Character :=
    Character'Val(248);
  LC_U_Grave                  : constant Character :=
    Character'Val(249);
  LC_U_Acute                  : constant Character :=
    Character'Val(250);
  LC_U_Circumflex             : constant Character :=
    Character'Val(251);
  LC_U_Diaeresis              : constant Character :=
    Character'Val(252);
  LC_Y_Acute                  : constant Character :=
    Character'Val(253);
  LC_Icelandic_Thorn          : constant Character :=
    Character'Val(254);
  LC_Y_Diaeresis              : constant Character :=
    Character'Val(255);
end Ada.Characters.Latin_1;
@end example

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may provide additional packages as children of
Ada.Characters, to declare names for the symbols of the local character
set or other character sets.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4, A.4.1, A.3.3, A
@section String Handling

@enumerate
@item
This clause presents the specifications of the package Strings and
several child packages, which provide facilities for dealing with string
data. Fixed-length, bounded-length, and unbounded-length strings are
supported, for both String and Wide_String. The string-handling
subprograms include searches for pattern strings and for characters in
program-specified sets, translation (via a character-to-character
mapping), and transformation (replacing, inserting, overwriting, and
deleting of substrings).
@end enumerate

@menu
* A.4.1:: The Package Strings
* A.4.2:: The Package Strings.Maps
* A.4.3:: Fixed-Length String Handling
* A.4.4:: Bounded-Length String Handling
* A.4.5:: Unbounded-Length String Handling
* A.4.6:: String-Handling Sets and Mappings
* A.4.7:: Wide_String Handling
@end menu

@c ---------------------------------------------------------------------------
@node A.4.1, A.4.2, A.4, A.4
@subsection The Package Strings

@enumerate
@item
The package Strings provides declarations common to the string handling
packages.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Strings has the following declaration:

@item
@example
package Ada.Strings is
   pragma Pure(Strings);
@end example

@item
@example
   Space      : constant Character      := ' ';
   Wide_Space : constant Wide_Character := ' ';
@end example

@item
@example
   Length_Error, Pattern_Error, Index_Error, Translation_Error
     : exception;
@end example

@item
@example
   type Alignment  is (Left, Right, Center);
   type Truncation is (Left, Right, Error);
   type Membership is (Inside, Outside);
   type Direction  is (Forward, Backward);
   type Trim_End   is (Left, Right, Both);
end Ada.Strings;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4.2, A.4.3, A.4.1, A.4
@subsection The Package Strings.Maps

@enumerate
@item
The package Strings.Maps defines the types, operations, and other
entities needed for character sets and character-to-character mappings.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Strings.Maps has the following declaration:

@item
@example
package Ada.Strings.Maps is
   pragma Preelaborate(Maps);
@end example

@item
@example
   -- Representation for a set of character values:
   type Character_Set is private;
@end example

@item
@example
   Null_Set : constant Character_Set;
@end example

@item
@example
   type Character_Range is
     record
        Low  : Character;
        High : Character;
     end record;
   -- Represents Character range Low..High
@end example

@item
@example
   type Character_Ranges is
     array (Positive range <>) of Character_Range;
@end example

@item
@example
   function To_Set (Ranges : in Character_Ranges)
     return Character_Set;
@end example

@item
@example
   function To_Set (Span : in Character_Range)
     return Character_Set;
@end example

@item
@example
   function To_Ranges (Set : in Character_Set)
     return Character_Ranges;
@end example

@item
@example
   function "=" (Left, Right : in Character_Set) return Boolean;
@end example

@item
@example
   function "not" (Right : in Character_Set)
     return Character_Set;
   function "and" (Left, Right : in Character_Set)
     return Character_Set;
   function "or"  (Left, Right : in Character_Set)
     return Character_Set;
   function "xor" (Left, Right : in Character_Set)
     return Character_Set;
   function "-"   (Left, Right : in Character_Set)
     return Character_Set;
@end example

@item
@example
   function Is_In (Element : in Character;
                   Set     : in Character_Set)
      return Boolean;
@end example

@item
@example
   function Is_Subset (Elements : in Character_Set;
                       Set      : in Character_Set)
      return Boolean;
@end example

@item
@example
   function "<=" (Left  : in Character_Set;
                  Right : in Character_Set)
      return Boolean renames Is_Subset;
@end example

@item
@example
   -- Alternative representation for a set of character values:
   subtype Character_Sequence is String;
@end example

@item
@example
   function To_Set (Sequence : in Character_Sequence)
     return Character_Set;
@end example

@item
@example
   function To_Set (Singleton : in Character) return Character_Set;
@end example

@item
@example
   function To_Sequence (Set : in Character_Set)
     return Character_Sequence;
@end example

@item
@example
   -- Representation for a character to character mapping:
   type Character_Mapping is private;
@end example

@item
@example
   function Value (Map     : in Character_Mapping;
                   Element : in Character)
      return Character;
@end example

@item
@example
   Identity : constant Character_Mapping;
@end example

@item
@example
   function To_Mapping (From, To : in Character_Sequence)
     return Character_Mapping;
@end example

@item
@example
   function To_Domain (Map : in Character_Mapping)
     return Character_Sequence;
   function To_Range  (Map : in Character_Mapping)
     return Character_Sequence;
@end example

@item
@example
   type Character_Mapping_Function is
      access function (From : in Character) return Character;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Strings.Maps;
@end example

@item
An object of type Character_Set represents a set of characters.

@item
Null_Set represents the set containing no characters.

@item
An object Obj of type Character_Range represents the set of characters
in the range Obj.Low .. Obj.High.

@item
An object Obj of type Character_Ranges represents the union of the sets
corresponding to Obj(I) for I in Obj'Range.

@item
@format
function To_Set (Ranges : in Character_Ranges) return Character_Set;
@end format

@enumerate 32
@item
If Ranges'Length=0 then Null_Set is returned; otherwise the returned
value represents the set corresponding to Ranges.
@end enumerate
@end enumerate

@enumerate 33
@item
@format
function To_Set (Span : in Character_Range) return Character_Set;
@end format

@enumerate 34
@item
The returned value represents the set containing each character in Span.
@end enumerate
@end enumerate

@enumerate 35
@item
@format
function To_Ranges (Set : in Character_Set) return Character_Ranges;
@end format

@enumerate 36
@item
If Set = Null_Set then an empty Character_Ranges array is returned;
otherwise the shortest array of contiguous ranges of Character values in
Set, in increasing order of Low, is returned.
@end enumerate
@end enumerate

@enumerate 37
@item
@format
function "=" (Left, Right : in Character_Set) return Boolean;
@end format

@enumerate 38
@item
The function "=" returns True if Left and Right represent identical
sets, and False otherwise.
@end enumerate
@end enumerate

@enumerate 39
@item
Each of the logical operators "not", "and", "or", and "xor" returns a
Character_Set value that represents the set obtained by applying the
corresponding operation to the set(s) represented by the parameter(s) of
the operator. "-"(Left, Right) is equivalent to "and"(Left,
"not"(Right)).

@item
@format
function Is_In (Element : in Character;
                Set     : in Character_Set);
   return Boolean;
@end format

@enumerate 41
@item
Is_In returns True if Element is in Set, and False otherwise.
@end enumerate
@end enumerate

@enumerate 42
@item
@format
function Is_Subset (Elements : in Character_Set;
                    Set      : in Character_Set)
   return Boolean;
@end format

@enumerate 43
@item
Is_Subset returns True if Elements is a subset of Set, and False
otherwise.
@end enumerate
@end enumerate

@enumerate 44
@item
@format
subtype Character_Sequence is String;
@end format

@enumerate 45
@item
The Character_Sequence subtype is used to portray a set of character
values and also to identify the domain and range of a character mapping.
@end enumerate
@end enumerate

@enumerate 46
@item
@format
function To_Set (Sequence  : in Character_Sequence)
  return Character_Set;

function To_Set (Singleton : in Character)
  return Character_Set;
@end format

@enumerate 47
@item
Sequence portrays the set of character values that it explicitly
contains (ignoring duplicates). Singleton portrays the set comprising a
single Character. Each of the To_Set functions returns a Character_Set
value that represents the set portrayed by Sequence or Singleton.
@end enumerate
@end enumerate

@enumerate 48
@item
@format
function To_Sequence (Set : in Character_Set)
  return Character_Sequence;
@end format

@enumerate 49
@item
The function To_Sequence returns a Character_Sequence value containing
each of the characters in the set represented by Set, in ascending order
with no duplicates.
@end enumerate
@end enumerate

@enumerate 50
@item
@format
type Character_Mapping is private;
@end format

@enumerate 51
@item
An object of type Character_Mapping represents a Character-to-Character
mapping.
@end enumerate
@end enumerate

@enumerate 52
@item
@format
function Value (Map     : in Character_Mapping;
                Element : in Character)
   return Character;
@end format

@enumerate 53
@item
The function Value returns the Character value to which Element maps
with respect to the mapping represented by Map.
@end enumerate
@end enumerate

@enumerate 54
@item
A character C matches a pattern character P with respect to a given
Character_Mapping value Map if Value(Map, C) = P. A string S matches a
pattern string P with respect to a given Character_Mapping if their
lengths are the same and if each character in S matches its
corresponding character in the pattern string P.

@item
String handling subprograms that deal with character mappings have
parameters whose type is Character_Mapping.

@item
@format
Identity : constant Character_Mapping;
@end format

@enumerate 57
@item
Identity maps each Character to itself.
@end enumerate
@end enumerate

@enumerate 58
@item
@format
function To_Mapping (From, To : in Character_Sequence)
  return Character_Mapping;
@end format

@enumerate 59
@item
To_Mapping produces a Character_Mapping such that each element of From
maps to the corresponding element of To, and each other character maps
to itself. If From'Length /= To'Length, or if some character is repeated
in From, then Translation_Error is propagated.
@end enumerate
@end enumerate

@enumerate 60
@item
@format
function To_Domain (Map : in Character_Mapping)
  return Character_Sequence;
@end format

@enumerate 61
@item
To_Domain returns the shortest Character_Sequence value D such that each
character not in D maps to itself, and such that the characters in D are
in ascending order. The lower bound of D is 1.
@end enumerate
@end enumerate

@enumerate 62
@item
@format
function To_Range (Map : in Character_Mapping)
  return Character_Sequence;
@end format

@enumerate 63
@item
To_Range returns the Character_Sequence value R, with lower bound 1 and
upper bound Map'Length, such that if D = To_Domain(Map) then D(I) maps
to R(I) for each I in D'Range.
@end enumerate
@end enumerate

@enumerate 64
@item
An object F of type Character_Mapping_Function maps a Character value C
to the Character value F.all(C), which is said to match C with respect
to mapping function F.

NOTES

@item
(7) Character_Mapping and Character_Mapping_Function are used both for
character equivalence mappings in the search subprograms (such as for
case insensitivity) and as transformational mappings in the Translate
subprograms.

@item
(8) To_Domain(Identity) and To_Range(Identity) each returns the null
string.

@need 1000
@sp 1
@center @emph{Examples}

@item
To_Mapping("ABCD", "ZZAB") returns a Character_Mapping that maps 'A' and
'B' to 'Z', 'C' to 'A', 'D' to 'B', and each other Character to itself.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4.3, A.4.4, A.4.2, A.4
@subsection Fixed-Length String Handling

@enumerate
@item
The language-defined package Strings.Fixed provides string-handling
subprograms for fixed-length strings; that is, for values of type
Standard.String. Several of these subprograms are procedures that modify
the contents of a String that is passed as an out or an in out
parameter; each has additional parameters to control the effect when the
logical length of the result differs from the parameter's length.

@item
For each function that returns a String, the lower bound of the returned
value is 1.

@item
The basic model embodied in the package is that a fixed-length string
comprises significant characters and possibly padding (with space
characters) on either or both ends. When a shorter string is copied to a
longer string, padding is inserted, and when a longer string is copied
to a shorter one, padding is stripped. The Move procedure in
Strings.Fixed, which takes a String as an out parameter, allows the
programmer to control these effects. Similar control is provided by the
string transformation procedures.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Strings.Fixed has the following declaration:

@item
@example
with Ada.Strings.Maps;
package Ada.Strings.Fixed is
   pragma Preelaborate(Fixed);
@end example

@item
@example
   -- "Copy" procedure for strings of possibly different lengths
@end example

@item
@example
   procedure Move (Source  : in  String;
                   Target  : out String;
                   Drop    : in  Truncation := Error;
                   Justify : in  Alignment  := Left;
                   Pad     : in  Character  := Space);
@end example

@item
@example
   -- Search subprograms
@end example

@item
@example
   function Index (Source   : in String;
                   Pattern  : in String;
                   Going    : in Direction := Forward;
                   Mapping  : in Maps.Character_Mapping
                                := Maps.Identity)
      return Natural;
@end example

@item
@example
   function Index (Source   : in String;
                   Pattern  : in String;
                   Going    : in Direction := Forward;
                   Mapping  : in Maps.Character_Mapping_Function)
      return Natural;
@end example

@item
@example
   function Index (Source : in String;
                   Set    : in Maps.Character_Set;
                   Test   : in Membership := Inside;
                   Going  : in Direction  := Forward)
      return Natural;
@end example

@item
@example
   function Index_Non_Blank (Source : in String;
                             Going  : in Direction := Forward)
      return Natural;
@end example

@item
@example
   function Count (Source   : in String;
                   Pattern  : in String;
                   Mapping  : in Maps.Character_Mapping
                                 := Maps.Identity)
      return Natural;
@end example

@item
@example
   function Count (Source   : in String;
                   Pattern  : in String;
                   Mapping  : in Maps.Character_Mapping_Function)
      return Natural;
@end example

@item
@example
   function Count (Source   : in String;
                   Set      : in Maps.Character_Set)
      return Natural;
@end example

@item
@example
   procedure Find_Token (Source : in String;
                         Set    : in Maps.Character_Set;
                         Test   : in Membership;
                         First  : out Positive;
                         Last   : out Natural);
@end example

@item
@example
   -- String translation subprograms
@end example

@item
@example
   function Translate (Source  : in String;
                       Mapping : in Maps.Character_Mapping)
      return String;
@end example

@item
@example
   procedure Translate (Source  : in out String;
                            Mapping : in Maps.Character_Mapping);
@end example

@item
@example
   function Translate (Source  : in String;
                       Mapping : in Maps.Character_Mapping_Function)
      return String;
@end example

@item
@example
   procedure Translate
     (Source  : in out String;
      Mapping : in Maps.Character_Mapping_Function);
@end example

@item
@example
   -- String transformation subprograms
@end example

@item
@example
   function Replace_Slice (Source   : in String;
                           Low      : in Positive;
                           High     : in Natural;
                           By       : in String)
      return String;
@end example

@item
@example
   procedure Replace_Slice (Source   : in out String;
                            Low      : in Positive;
                            High     : in Natural;
                            By       : in String;
                            Drop     : in Truncation := Error;
                            Justify  : in Alignment  := Left;
                            Pad      : in Character  := Space);
@end example

@item
@example
   function Insert (Source   : in String;
                    Before   : in Positive;
                    New_Item : in String)
      return String;
@end example

@item
@example
   procedure Insert (Source   : in out String;
                     Before   : in Positive;
                     New_Item : in String;
                     Drop     : in Truncation := Error);
@end example

@item
@example
   function Overwrite (Source   : in String;
                       Position : in Positive;
                       New_Item : in String)
      return String;
@end example

@item
@example
   procedure Overwrite (Source   : in out String;
                        Position : in Positive;
                        New_Item : in String;
                        Drop     : in Truncation := Right);
@end example

@item
@example
   function Delete (Source  : in String;
                    From    : in Positive;
                    Through : in Natural)
      return String;
@end example

@item
@example
   procedure Delete (Source  : in out String;
                     From    : in Positive;
                     Through : in Natural;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);
@end example

@item
@example
   -- String selector subprograms

   function Trim (Source : in String;
                  Side   : in Trim_End)
      return String;
@end example

@item
@example
   procedure Trim (Source  : in out String;
                   Side    : in Trim_End;
                   Justify : in Alignment := Left;
                   Pad     : in Character := Space);
@end example

@item
@example
   function Trim (Source : in String;
                  Left   : in Maps.Character_Set;
                  Right  : in Maps.Character_Set)
      return String;
@end example

@item
@example
   procedure Trim (Source  : in out String;
                   Left    : in Maps.Character_Set;
                   Right   : in Maps.Character_Set;
                   Justify : in Alignment := Strings.Left;
                   Pad     : in Character := Space);
@end example

@item
@example
   function Head (Source : in String;
                  Count  : in Natural;
                  Pad    : in Character := Space)
      return String;
@end example

@item
@example
   procedure Head (Source  : in out String;
                   Count   : in Natural;
                   Justify : in Alignment := Left;
                   Pad     : in Character := Space);
@end example

@item
@example
   function Tail (Source : in String;
                  Count  : in Natural;
                  Pad    : in Character := Space)
      return String;
@end example

@item
@example
   procedure Tail (Source  : in out String;
                   Count   : in Natural;
                   Justify : in Alignment := Left;
                   Pad     : in Character := Space);
@end example

@item
@example
   --String constructor functions
@end example

@item
@example
   function "*" (Left  : in Natural;
                 Right : in Character) return String;
@end example

@item
@example
   function "*" (Left  : in Natural;
                 Right : in String) return String;
@end example

@item
@example
end Ada.Strings.Fixed;
@end example

@item
The effects of the above subprograms are as follows.

@item
@format
procedure Move (Source  : in  String;
                Target  : out String;
                Drop    : in  Truncation := Error;
                Justify : in  Alignment  := Left;
                Pad     : in  Character  := Space);
@end format

@enumerate 45
@item
The Move procedure copies characters from Source to Target. If Source
has the same length as Target, then the effect is to assign Source to
Target. If Source is shorter than Target then:

@enumerate 46
@item
If Justify=Left, then Source is copied into the first Source'Length
characters of Target.

@item
If Justify=Right, then Source is copied into the last Source'Length
characters of Target.

@item
If Justify=Center, then Source is copied into the middle Source'Length
characters of Target. In this case, if the difference in length between
Target and Source is odd, then the extra Pad character is on the right.

@item
Pad is copied to each Target character not otherwise assigned.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 50
@item
If Source is longer than Target, then the effect is based on Drop.

@enumerate 51
@item
If Drop=Left, then the rightmost Target'Length characters of Source are
copied into Target.

@item
If Drop=Right, then the leftmost Target'Length characters of Source are
copied into Target.

@item
If Drop=Error, then the effect depends on the value of the Justify
parameter and also on whether any characters in Source other than Pad
would fail to be copied:

@enumerate 54
@item
If Justify=Left, and if each of the rightmost
Source'Length-Target'Length characters in Source is Pad, then the
leftmost Target'Length characters of Source are copied to Target.

@item
If Justify=Right, and if each of the leftmost
Source'Length-Target'Length characters in Source is Pad, then the
rightmost Target'Length characters of Source are copied to Target.

@item
Otherwise, Length_Error is propagated.
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate 57
@item
@format
function Index (Source   : in String;
                Pattern  : in String;
                Going    : in Direction := Forward;
                Mapping  : in Maps.Character_Mapping
                              := Maps.Identity)
   return Natural;

function Index (Source   : in String;
                Pattern  : in String;
                Going    : in Direction := Forward;
                Mapping  : in Maps.Character_Mapping_Function)
   return Natural;
@end format

@enumerate 58
@item
Each Index function searches for a slice of Source, with length
Pattern'Length, that matches Pattern with respect to Mapping; the
parameter Going indicates the direction of the lookup. If Going =
Forward, then Index returns the smallest index I such that the slice of
Source starting at I matches Pattern. If Going = Backward, then Index
returns the largest index I such that the slice of Source starting at I
matches Pattern. If there is no such slice, then 0 is returned. If
Pattern is the null string then Pattern_Error is
@end enumerate
@end enumerate

@enumerate 59
@item
@format
function Index (Source : in String;
                Set    : in Maps.Character_Set;
                Test   : in Membership := Inside;
                Going  : in Direction  := Forward)
   return Natural;
@end format

@enumerate 60
@item
Index searches for the first or last occurrence of any of a set of
characters (when Test=Inside), or any of the complement of a set of
characters (when Test=Outside). It returns the smallest index I (if
Going=Forward) or the largest index I (if Going=Backward) such that
Source(I) satisfies the Test condition with respect to Set; it returns 0
if there is no such Character in Source.
@end enumerate
@end enumerate

@enumerate 61
@item
@format
function Index_Non_Blank (Source : in String;
                          Going  : in Direction := Forward)
   return Natural;
@end format

@enumerate 62
@item
Returns Index(Source, Maps.To_Set(Space), Outside, Going)
@end enumerate
@end enumerate

@enumerate 63
@item
@format
function Count (Source   : in String;
                Pattern  : in String;
                Mapping  : in Maps.Character_Mapping
                             := Maps.Identity)
   return Natural;

function Count (Source   : in String;
                Pattern  : in String;
                Mapping  : in Maps.Character_Mapping_Function)
   return Natural;
@end format

@enumerate 64
@item
Returns the maximum number of nonoverlapping slices of Source that match
Pattern with respect to Mapping. If Pattern is the null string then
Pattern_Error is propagated.
@end enumerate
@end enumerate

@enumerate 65
@item
@format
function Count (Source   : in String;
                Set      : in Maps.Character_Set)
   return Natural;
@end format

@enumerate 66
@item
Returns the number of occurrences in Source of characters that are in
Set.
@end enumerate
@end enumerate

@enumerate 67
@item
@format
procedure Find_Token (Source : in String;
                      Set    : in Maps.Character_Set;
                      Test   : in Membership;
                      First  : out Positive;
                      Last   : out Natural);
@end format

@enumerate 68
@item
Find_Token returns in First and Last the indices of the beginning and
end of the first slice of Source all of whose elements satisfy the Test
condition, and such that the elements (if any) immediately before and
after the slice do not satisfy the Test condition. If no such slice
exists, then the value returned for Last is zero, and the value returned
for First is Source'First.
@end enumerate
@end enumerate

@enumerate 69
@item
@format
function Translate (Source  : in String;
                    Mapping : in Maps.Character_Mapping)
   return String;

function Translate (Source  : in String;
                    Mapping : in Maps.Character_Mapping_Function)
   return String;
@end format

@enumerate 70
@item
Returns the string S whose length is Source'Length and such that S(I) is
the character to which Mapping maps the corresponding element of Source,
for I in 1..Source'Length.
@end enumerate
@end enumerate

@enumerate 71
@item
@format
procedure Translate (Source  : in out String;
                     Mapping : in Maps.Character_Mapping);

procedure Translate (Source  : in out String;
                     Mapping : in Maps.Character_Mapping_Function);
@end format

@enumerate 72
@item
Equivalent to Source := Translate(Source, Mapping).
@end enumerate
@end enumerate

@enumerate 73
@item
@format
function Replace_Slice (Source   : in String;
                        Low      : in Positive;
                        High     : in Natural;
                        By       : in String)
   return String;
@end format

@enumerate 74
@item
If Low > Source'Last+1, or High < Source'First-1, then Index_Error is
propagated. Otherwise, if High >= Low then the returned string comprises
Source(Source'First..Low-1) & By & Source(High+1..Source'Last), and if
High < Low then the returned string is Insert(Source, Before=>Low,
New_Item=>By).
@end enumerate
@end enumerate

@enumerate 75
@item
@format
procedure Replace_Slice (Source   : in out String;
                         Low      : in Positive;
                         High     : in Natural;
                         By       : in String;
                         Drop     : in Truncation := Error;
                         Justify  : in Alignment  := Left;
                         Pad      : in Character  := Space);
@end format

@enumerate 76
@item
Equivalent to Move(Replace_Slice(Source, Low, High, By), Source, Drop,
Justify, Pad).
@end enumerate
@end enumerate

@enumerate 77
@item
@format
function Insert (Source   : in String;
                 Before   : in Positive;
                 New_Item : in String)
   return String;
@end format

@enumerate 78
Propagates Index_Error if Before is not in Source'First ..
Source'Last+1; otherwise returns Source(Source'First..Before-1) &
New_Item & Source(Before..Source'Last), but with lower bound 1.
@end enumerate
@end enumerate

@enumerate 79
@item
@format
procedure Insert (Source   : in out String;
                  Before   : in Positive;
                  New_Item : in String;
                  Drop     : in Truncation := Error);
@end format

@enumerate 80
@item
Equivalent to Move(Insert(Source, Before, New_Item), Source, Drop).
@end enumerate
@end enumerate

@enumerate 81
@item
@format
function Overwrite (Source   : in String;
                    Position : in Positive;
                    New_Item : in String)
   return String;
@end format

@enumerate 82
@item
Propagates Index_Error if Position is not in Source'First ..
Source'Last+1; otherwise returns the string obtained from Source by
consecutively replacing characters starting at Position with
corresponding characters from New_Item. If the end of Source is reached
before the characters in New_Item are exhausted, the remaining
characters from New_Item are appended to the string.
@end enumerate
@end enumerate

@enumerate 83
@item
@format
procedure Overwrite (Source   : in out String;
                     Position : in Positive;
                     New_Item : in String;
                     Drop     : in Truncation := Right);
@end format

@enumerate 84
@item
Equivalent to Move(Overwrite(Source, Position, New_Item), Source, Drop).
@end enumerate
@end enumerate

@enumerate 85
@item
@format
function Delete (Source  : in String;
                 From    : in Positive;
                 Through : in Natural)
   return String;
@end format

@enumerate 86
@item
If From <= Through, the returned string is Replace_Slice(Source, From,
Through, ""), otherwise it is Source.
@end enumerate
@end enumerate

@enumerate 87
@item
@format
procedure Delete (Source  : in out String;
                  From    : in Positive;
                  Through : in Natural;
                  Justify : in Alignment := Left;
                  Pad     : in Character := Space);
@end format

@enumerate 88
@item
Equivalent to Move(Delete(Source, From, Through), Source, Justify =>
Justify, Pad => Pad).
@end enumerate
@end enumerate

@enumerate 89
@item
@format
function Trim (Source : in String;
               Side   : in Trim_End)
  return String;
@end format

@enumerate 90
@item
Returns the string obtained by removing from Source all leading Space
characters (if Side = Left), all trailing Space characters (if Side =
Right), or all leading and trailing Space characters (if Side = Both).
@end enumerate
@end enumerate

@enumerate 91
@item
@format
procedure Trim (Source  : in out String;
                Side    : in Trim_End;
                Justify : in Alignment := Left;
                Pad     : in Character := Space);
@end format

@enumerate 92
@item
Equivalent to Move(Trim(Source, Side), Source, Justify=>Justify,
Pad=>Pad).
@end enumerate
@end enumerate

@enumerate 93
@item
@format
function Trim (Source : in String;
               Left   : in Maps.Character_Set;
               Right  : in Maps.Character_Set)
   return String;
@end format

@enumerate 94
@item
Returns the string obtained by removing from Source all leading
characters in Left and all trailing characters in Right.
@end enumerate
@end enumerate

@enumerate 95
@item
@format
procedure Trim (Source  : in out String;
                Left    : in Maps.Character_Set;
                Right   : in Maps.Character_Set;
                Justify : in Alignment := Strings.Left;
                Pad     : in Character := Space);
@end format

@enumerate 96
@item
Equivalent to Move(Trim(Source, Left, Right), Source, Justify =>
Justify, Pad=>Pad).
@end enumerate
@end enumerate

@enumerate 97
@item
@format
function Head (Source : in String;
               Count  : in Natural;
               Pad    : in Character := Space)
   return String;
@end format

@enumerate 98
@item
Returns a string of length Count. If Count <= Source'Length, the string
comprises the first Count characters of Source. Otherwise its contents
are Source concatenated with Count-Source'Length Pad characters.
@end enumerate
@end enumerate

@enumerate 99
@item
@format
procedure Head (Source  : in out String;
                Count   : in Natural;
                Justify : in Alignment := Left;
                Pad     : in Character := Space);
@end format

@enumerate 100
@item
Equivalent to Move(Head(Source, Count, Pad), Source, Drop=>Error,
Justify=>Justify, Pad=>Pad).
@end enumerate
@end enumerate

@enumerate 101
@item
@format
function Tail (Source : in String;
               Count  : in Natural;
               Pad    : in Character := Space)
   return String;
@end format

@enumerate 102
@item
Returns a string of length Count. If Count <= Source'Length, the string
comprises the last Count characters of Source. Otherwise its contents
are Count-Source'Length Pad characters concatenated with Source.
@end enumerate
@end enumerate

@enumerate 103
@item
@format
procedure Tail (Source  : in out String;
                Count   : in Natural;
                Justify : in Alignment := Left;
                Pad     : in Character := Space);
@end format

@enumerate 104
@item
Equivalent to Move(Tail(Source, Count, Pad), Source, Drop=>Error,
Justify=>Justify, Pad=>Pad).
@end enumerate
@end enumerate

@enumerate 105
@item
@format
function "*" (Left  : in Natural;
              Right : in Character) return String;

function "*" (Left  : in Natural;
              Right : in String) return String;
@end format

@enumerate 106
@item
These functions replicate a character or string a specified number of
times. The first function returns a string whose length is Left and each
of whose elements is Right. The second function returns a string whose
length is Left*Right'Length and whose value is the null string if Left =
0 and is (Left-1)*Right & Right otherwise.
@end enumerate
@end enumerate
@enumerate 107

NOTES

@item
(9) In the Index and Count functions taking Pattern and Mapping
parameters, the actual String parameter passed to Pattern should
comprise characters occurring as target characters of the mapping.
Otherwise the pattern will not match.

@item
(10) In the Insert subprograms, inserting at the end of a string is
obtained by passing Source'Last+1 as the Before parameter.

@item
(11) If a null Character_Mapping_Function is passed to any of the string
handling subprograms, Constraint_Error is propagated.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4.4, A.4.5, A.4.3, A.4
@subsection Bounded-Length String Handling

@enumerate
@item
The language-defined package Strings.Bounded provides a generic package
each of whose instances yields a private type Bounded_String and a set
of operations. An object of a particular Bounded_String type represents
a String whose low bound is 1 and whose length can vary conceptually
between 0 and a maximum size established at the generic instantiation.
The subprograms for fixed-length string handling are either overloaded
directly for Bounded_String, or are modified as needed to reflect the
variability in length. Additionally, since the Bounded_String type is
private, appropriate constructor and selector operations are provided.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Strings.Bounded has the following declaration:

@item
@example
with Ada.Strings.Maps;
package Ada.Strings.Bounded is
   pragma Preelaborate(Bounded);
@end example

@item
@example
   generic
      Max   : Positive;    -- Maximum length of a Bounded_String
   package Generic_Bounded_Length is
@end example

@item
@example
      Max_Length : constant Positive := Max;
@end example

@item
@example
      type Bounded_String is private;
@end example

@item
@example
      Null_Bounded_String : constant Bounded_String;
@end example

@item
@example
      subtype Length_Range is Natural range 0 .. Max_Length;
@end example

@item
@example
      function Length (Source : in Bounded_String)
        return Length_Range;
@end example

@item
@example
      -- Conversion, Concatenation, and Selection functions
@end example

@item
@example
      function To_Bounded_String (Source : in String;
                                  Drop   : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      function To_String (Source : in Bounded_String) return String;
@end example

@item
@example
      function Append (Left, Right : in Bounded_String;
                       Drop        : in Truncation  := Error)
         return Bounded_String;
@end example

@item
@example
      function Append (Left  : in Bounded_String;
                       Right : in String;
                       Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      function Append (Left  : in String;
                       Right : in Bounded_String;
                       Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      function Append (Left  : in Bounded_String;
                       Right : in Character;
                       Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      function Append (Left  : in Character;
                       Right : in Bounded_String;
                       Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      procedure Append (Source   : in out Bounded_String;
                        New_Item : in Bounded_String;
                        Drop     : in Truncation  := Error);
@end example

@item
@example
      procedure Append (Source   : in out Bounded_String;
                        New_Item : in String;
                        Drop     : in Truncation  := Error);
@end example

@item
@example
      procedure Append (Source   : in out Bounded_String;
                        New_Item : in Character;
                        Drop     : in Truncation  := Error);
@end example

@item
@example
      function "&" (Left, Right : in Bounded_String)
         return Bounded_String;
@end example

@item
@example
      function "&" (Left : in Bounded_String; Right : in String)
         return Bounded_String;
@end example

@item
@example
      function "&" (Left : in String; Right : in Bounded_String)
         return Bounded_String;
@end example

@item
@example
      function "&" (Left : in Bounded_String; Right : in Character)
         return Bounded_String;
@end example

@item
@example
      function "&" (Left : in Character; Right : in Bounded_String)
         return Bounded_String;
@end example

@item
@example
      function Element (Source : in Bounded_String;
                        Index  : in Positive)
         return Character;
@end example

@item
@example
      procedure Replace_Element (Source : in out Bounded_String;
                                 Index  : in Positive;
                                 By     : in Character);
@end example

@item
@example
      function Slice (Source : in Bounded_String;
                      Low    : in Positive;
                      High   : in Natural)
         return String;
@end example

@item
@example
      function "="  (Left, Right : in Bounded_String) return Boolean;
      function "="  (Left : in Bounded_String; Right : in String)
        return Boolean;
@end example

@item
@example
      function "="  (Left : in String; Right : in Bounded_String)
        return Boolean;
@end example

@item
@example
      function "<"  (Left, Right : in Bounded_String) return Boolean;
@end example

@item
@example
      function "<"  (Left : in Bounded_String; Right : in String)
        return Boolean;
@end example

@item
@example
      function "<"  (Left : in String; Right : in Bounded_String)
        return Boolean;
@end example

@item
@example
      function "<=" (Left, Right : in Bounded_String) return Boolean;
@end example

@item
@example
      function "<="  (Left : in Bounded_String; Right : in String)
        return Boolean;
@end example

@item
@example
      function "<="  (Left : in String; Right : in Bounded_String)
        return Boolean;
@end example

@item
@example
      function ">"  (Left, Right : in Bounded_String) return Boolean;
@end example

@item
@example
      function ">"  (Left : in Bounded_String; Right : in String)
        return Boolean;
@end example

@item
@example
      function ">"  (Left : in String; Right : in Bounded_String)
        return Boolean;
@end example

@item
@example
      function ">=" (Left, Right : in Bounded_String) return Boolean;
@end example

@item
@example
      function ">="  (Left : in Bounded_String; Right : in String)
        return Boolean;
@end example

@item
@example
      function ">="  (Left : in String; Right : in Bounded_String)
        return Boolean;
@end example

@item
@example
      -- Search functions
@end example

@item
@example
      function Index (Source   : in Bounded_String;
                      Pattern  : in String;
                      Going    : in Direction := Forward;
                      Mapping  : in Maps.Character_Mapping
                                 := Maps.Identity)
         return Natural;
@end example

@item
@example
      function Index (Source   : in Bounded_String;
                      Pattern  : in String;
                      Going    : in Direction := Forward;
                      Mapping  : in Maps.Character_Mapping_Function)
         return Natural;
@end example

@item
@example
      function Index (Source : in Bounded_String;
                      Set    : in Maps.Character_Set;
                      Test   : in Membership := Inside;
                      Going  : in Direction  := Forward)
         return Natural;
@end example

@item
@example
      function Index_Non_Blank (Source : in Bounded_String;
                                Going  : in Direction := Forward)
         return Natural;
@end example

@item
@example
      function Count (Source   : in Bounded_String;
                      Pattern  : in String;
                      Mapping  : in Maps.Character_Mapping
                                   := Maps.Identity)
         return Natural;
@end example

@item
@example
      function Count (Source   : in Bounded_String;
                      Pattern  : in String;
                      Mapping  : in Maps.Character_Mapping_Function)
         return Natural;
@end example

@item
@example
      function Count (Source   : in Bounded_String;
                      Set      : in Maps.Character_Set)
         return Natural;
@end example

@item
@example
      procedure Find_Token (Source : in Bounded_String;
                            Set    : in Maps.Character_Set;
                            Test   : in Membership;
                            First  : out Positive;
                            Last   : out Natural);
@end example

@item
@example
      -- String translation subprograms
@end example

@item
@example
      function Translate (Source  : in Bounded_String;
                          Mapping : in Maps.Character_Mapping)
         return Bounded_String;
@end example

@item
@example
      procedure Translate (Source  : in out Bounded_String;
                           Mapping : in Maps.Character_Mapping);
@end example

@item
@example
      function Translate
        (Source  : in Bounded_String;
         Mapping : in Maps.Character_Mapping_Function)
         return Bounded_String;
@end example

@item
@example
      procedure Translate
        (Source  : in out Bounded_String;
         Mapping : in Maps.Character_Mapping_Function);
@end example

@item
@example
      -- String transformation subprograms
@end example

@item
@example
      function Replace_Slice (Source   : in Bounded_String;
                              Low      : in Positive;
                              High     : in Natural;
                              By       : in String;
                              Drop     : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      procedure Replace_Slice (Source   : in out Bounded_String;
                               Low      : in Positive;
                               High     : in Natural;
                               By       : in String;
                               Drop     : in Truncation := Error);
@end example

@item
@example
      function Insert (Source   : in Bounded_String;
                       Before   : in Positive;
                       New_Item : in String;
                       Drop     : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      procedure Insert (Source   : in out Bounded_String;
                        Before   : in Positive;
                        New_Item : in String;
                        Drop     : in Truncation := Error);
@end example

@item
@example
      function Overwrite (Source    : in Bounded_String;
                          Position  : in Positive;
                          New_Item  : in String;
                          Drop      : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      procedure Overwrite (Source    : in out Bounded_String;
                           Position  : in Positive;
                           New_Item  : in String;
                           Drop      : in Truncation := Error);
@end example

@item
@example
      function Delete (Source  : in Bounded_String;
                       From    : in Positive;
                       Through : in Natural)
         return Bounded_String;
@end example

@item
@example
      procedure Delete (Source  : in out Bounded_String;
                        From    : in Positive;
                        Through : in Natural);
@end example

@item
@example
      -- String selector subprograms
@end example

@item
@example
      function Trim (Source : in Bounded_String;
                     Side   : in Trim_End)
         return Bounded_String;

      procedure Trim (Source : in out Bounded_String;
                      Side   : in Trim_End);
@end example

@item
@example
      function Trim (Source : in Bounded_String;
                     Left   : in Maps.Character_Set;
                     Right  : in Maps.Character_Set)
         return Bounded_String;
@end example

@item
@example
      procedure Trim (Source : in out Bounded_String;
                      Left   : in Maps.Character_Set;
                      Right  : in Maps.Character_Set);
@end example

@item
@example
      function Head (Source : in Bounded_String;
                     Count  : in Natural;
                     Pad    : in Character  := Space;
                     Drop   : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      procedure Head (Source : in out Bounded_String;
                      Count  : in Natural;
                      Pad    : in Character  := Space;
                      Drop   : in Truncation := Error);
@end example

@item
@example
      function Tail (Source : in Bounded_String;
                     Count  : in Natural;
                     Pad    : in Character  := Space;
                     Drop   : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      procedure Tail (Source : in out Bounded_String;
                      Count  : in Natural;
                      Pad    : in Character  := Space;
                      Drop   : in Truncation := Error);
@end example

@item
@example
      -- String constructor subprograms
@end example

@item
@example
      function "*" (Left  : in Natural;
                    Right : in Character)
         return Bounded_String;
@end example

@item
@example
      function "*" (Left  : in Natural;
                    Right : in String)
         return Bounded_String;
@end example

@item
@example
      function "*" (Left  : in Natural;
                    Right : in Bounded_String)
         return Bounded_String;
@end example

@item
@example
      function Replicate (Count : in Natural;
                          Item  : in Character;
                          Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      function Replicate (Count : in Natural;
                          Item  : in String;
                          Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
      function Replicate (Count : in Natural;
                          Item  : in Bounded_String;
                          Drop  : in Truncation := Error)
         return Bounded_String;
@end example

@item
@example
   private
       ... -- not specified by the language
   end Generic_Bounded_Length;
@end example

@item
@example
end Ada.Strings.Bounded;
@end example

@item
Null_Bounded_String represents the null string. If an object of type
Bounded_String is not otherwise initialized, it will be initialized to
the same value as Null_Bounded_String.

@item
@format
function Length (Source : in Bounded_String) return Length_Range;
@end format

@enumerate 85
@item
The Length function returns the length of the string represented by
Source.
@end enumerate
@end enumerate

@enumerate 86
@item
@format
function To_Bounded_String (Source : in String;
                            Drop   : in Truncation := Error)
   return Bounded_String;
@end format

@enumerate 87
@item
If Source'Length <= Max_Length then this function returns a
Bounded_String that represents Source. Otherwise the effect depends on
the value of Drop:

@enumerate 88
@item
If Drop=Left, then the result is a Bounded_String that represents the
string comprising the rightmost Max_Length characters of Source.

@item
If Drop=Right, then the result is a Bounded_String that represents the
string comprising the leftmost Max_Length characters of Source.

@item
If Drop=Error, then Strings.Length_Error is propagated.
@end enumerate
@end enumerate
@end enumerate

@enumerate 91
@item
@format
function To_String (Source : in Bounded_String) return String;
@end format

@enumerate 92
@item
To_String returns the String value with lower bound 1 represented by
Source. If B is a Bounded_String, then B =
To_Bounded_String(To_String(B)).
@end enumerate
@end enumerate

@enumerate 93
@item
Each of the Append functions returns a Bounded_String obtained by
concatenating the string or character given or represented by one of the
parameters, with the string or character given or represented by the
other parameter, and applying To_Bounded_String to the concatenation
result string, with Drop as provided to the Append function.

@item
Each of the procedures Append(Source, New_Item, Drop) has the same
effect as the corresponding assignment Source := Append(Source,
New_Item, Drop).

@item
Each of the "&" functions has the same effect as the corresponding
Append function, with Error as the Drop parameter.

@item
@format
function Element (Source : in Bounded_String;
                  Index  : in Positive)
   return Character;
@end format

@enumerate 97
@item
Returns the character at position Index in the string represented by
Source; propagates Index_Error if Index > Length(Source).
@end enumerate
@end enumerate

@enumerate 98
@item
@format
procedure Replace_Element (Source : in out Bounded_String;
                           Index  : in Positive;
                           By     : in Character);
@end format

@enumerate 99
@item
Updates Source such that the character at position Index in the string
represented by Source is By; propagates Index_Error if Index >
Length(Source).
@end enumerate
@end enumerate

@enumerate 100
@item
@format
function Slice (Source : in Bounded_String;
                Low    : in Positive;
                High   : in Natural)
   return String;
@end format

@enumerate 101
@item
Returns the slice at positions Low through High in the string
represented by Source; propagates Index_Error if Low > Length(Source)+1.
@end enumerate
@end enumerate

@enumerate 102
@item
Each of the functions "=", "<", ">","<=", and ">=" returns the same
result as the corresponding String operation applied to the String
values given or represented by the two parameters.

@item
Each of the search subprograms (Index, Index_Non_Blank, Count,
Find_Token) has the same effect as the corresponding subprogram in
Strings.Fixed applied to the string represented by the Bounded_String
parameter.

@item
Each of the Translate subprograms, when applied to a Bounded_String, has
an analogous effect to the corresponding subprogram in Strings.Fixed.
For the Translate function, the translation is applied to the string
represented by the Bounded_String parameter, and the result is converted
(via To_Bounded_String) to a Bounded_String. For the Translate
procedure, the string represented by the Bounded_String parameter after
the translation is given by the Translate function for fixed-length
strings applied to the string represented by the original value of the
parameter.

@item
Each of the transformation subprograms (Replace_Slice, Insert,
Overwrite, Delete), selector subprograms (Trim, Head, Tail), and
constructor functions ("*") has an effect based on its corresponding
subprogram in Strings.Fixed, and Replicate is based on Fixed."*". For
each of these subprograms, the corresponding fixed-length string
subprogram is applied to the string represented by the Bounded_String
parameter. To_Bounded_String is applied the result string, with Drop (or
Error in the case of Generic_Bounded_Length."*") determining the effect
when the string length exceeds Max_Length.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Bounded string objects should not be implemented by implicit pointers
and dynamic allocation.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4.5, A.4.6, A.4.4, A.4
@subsection Unbounded-Length String Handling

@enumerate
@item
The language-defined package Strings.Unbounded provides a private type
Unbounded_String and a set of operations. An object of type
Unbounded_String represents a String whose low bound is 1 and whose
length can vary conceptually between 0 and Natural'Last. The subprograms
for fixed-length string handling are either overloaded directly for
Unbounded_String, or are modified as needed to reflect the flexibility
in length. Since the Unbounded_String type is private, relevant
constructor and selector operations are provided.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Strings.Unbounded has the following declaration:

@item
@example
with Ada.Strings.Maps;
package Ada.Strings.Unbounded is
   pragma Preelaborate(Unbounded);
@end example

@item
@example
   type Unbounded_String is private;
@end example

@item
@example
   Null_Unbounded_String : constant Unbounded_String;
@end example

@item
@example
   function Length (Source : in Unbounded_String) return Natural;
@end example

@item
@example
   type String_Access is access all String;
   procedure Free (X : in out String_Access);
@end example

@item
@example
   -- Conversion, Concatenation, and Selection functions
@end example

@item
@example
   function To_Unbounded_String (Source : in String)
      return Unbounded_String;
@end example

@item
@example
   function To_Unbounded_String (Length : in Natural)
      return Unbounded_String;
@end example

@item
@example
   function To_String (Source : in Unbounded_String) return String;
@end example

@item
@example
   procedure Append (Source   : in out Unbounded_String;
                     New_Item : in Unbounded_String);
@end example

@item
@example
   procedure Append (Source   : in out Unbounded_String;
                     New_Item : in String);
@end example

@item
@example
   procedure Append (Source   : in out Unbounded_String;
                     New_Item : in Character);
@end example

@item
@example
   function "&" (Left, Right : in Unbounded_String)
      return Unbounded_String;
@end example

@item
@example
   function "&" (Left : in Unbounded_String; Right : in String)
      return Unbounded_String;
@end example

@item
@example
   function "&" (Left : in String; Right : in Unbounded_String)
      return Unbounded_String;
@end example

@item
@example
   function "&" (Left : in Unbounded_String; Right : in Character)
      return Unbounded_String;
@end example

@item
@example
   function "&" (Left : in Character; Right : in Unbounded_String)
      return Unbounded_String;
@end example

@item
@example
   function Element (Source : in Unbounded_String;
                     Index  : in Positive)
      return Character;
@end example

@item
@example
   procedure Replace_Element (Source : in out Unbounded_String;
                              Index  : in Positive;
                              By     : in Character);
@end example

@item
@example
   function Slice (Source : in Unbounded_String;
                   Low    : in Positive;
                   High   : in Natural)
      return String;
@end example

@item
@example
   function "="  (Left, Right : in Unbounded_String) return Boolean;
@end example

@item
@example
   function "="  (Left : in Unbounded_String; Right : in String)
     return Boolean;
@end example

@item
@example
   function "="  (Left : in String; Right : in Unbounded_String)
     return Boolean;
@end example

@item
@example
   function "<"  (Left, Right : in Unbounded_String) return Boolean;
@end example

@item
@example
   function "<"  (Left : in Unbounded_String; Right : in String)
     return Boolean;
@end example

@item
@example
   function "<"  (Left : in String; Right : in Unbounded_String)
     return Boolean;
@end example

@item
@example
   function "<=" (Left, Right : in Unbounded_String) return Boolean;
@end example

@item
@example
   function "<="  (Left : in Unbounded_String; Right : in String)
     return Boolean;
@end example

@item
@example
   function "<="  (Left : in String; Right : in Unbounded_String)
     return Boolean;
@end example

@item
@example
   function ">"  (Left, Right : in Unbounded_String) return Boolean;
@end example

@item
@example
   function ">"  (Left : in Unbounded_String; Right : in String)
     return Boolean;
@end example

@item
@example
   function ">"  (Left : in String; Right : in Unbounded_String)
     return Boolean;
@end example

@item
@example
   function ">=" (Left, Right : in Unbounded_String) return Boolean;
@end example

@item
@example
   function ">="  (Left : in Unbounded_String; Right : in String)
     return Boolean;
@end example

@item
@example
   function ">="  (Left : in String; Right : in Unbounded_String)
     return Boolean;
@end example

@item
@example
   -- Search subprograms
@end example

@item
@example
   function Index (Source   : in Unbounded_String;
                   Pattern  : in String;
                   Going    : in Direction := Forward;
                   Mapping  : in Maps.Character_Mapping
                                := Maps.Identity)
      return Natural;
@end example

@item
@example
   function Index (Source   : in Unbounded_String;
                   Pattern  : in String;
                   Going    : in Direction := Forward;
                   Mapping  : in Maps.Character_Mapping_Function)
      return Natural;
@end example

@item
@example
   function Index (Source : in Unbounded_String;
                   Set    : in Maps.Character_Set;
                   Test   : in Membership := Inside;
                   Going  : in Direction  := Forward) return Natural;
@end example

@item
@example
   function Index_Non_Blank (Source : in Unbounded_String;
                             Going  : in Direction := Forward)
      return Natural;
@end example

@item
@example
   function Count (Source   : in Unbounded_String;
                   Pattern  : in String;
                   Mapping  : in Maps.Character_Mapping
                                := Maps.Identity)
      return Natural;
@end example

@item
@example
   function Count (Source   : in Unbounded_String;
                   Pattern  : in String;
                   Mapping  : in Maps.Character_Mapping_Function)
      return Natural;
@end example

@item
@example
   function Count (Source   : in Unbounded_String;
                   Set      : in Maps.Character_Set)
      return Natural;
@end example

@item
@example
   procedure Find_Token (Source : in Unbounded_String;
                         Set    : in Maps.Character_Set;
                         Test   : in Membership;
                         First  : out Positive;
                         Last   : out Natural);
@end example

@item
@example
   -- String translation subprograms
@end example

@item
@example
   function Translate (Source  : in Unbounded_String;
                       Mapping : in Maps.Character_Mapping)
      return Unbounded_String;
@end example

@item
@example
   procedure Translate (Source  : in out Unbounded_String;
                        Mapping : in Maps.Character_Mapping);
@end example

@item
@example
   function Translate
     (Source  : in Unbounded_String;
      Mapping : in Maps.Character_Mapping_Function)
      return Unbounded_String;
@end example

@item
@example
   procedure Translate
     (Source  : in out Unbounded_String;
      Mapping : in Maps.Character_Mapping_Function);
@end example

@item
@example
   -- String transformation subprograms
@end example

@item
@example
   function Replace_Slice (Source   : in Unbounded_String;
                           Low      : in Positive;
                           High     : in Natural;
                           By       : in String)
      return Unbounded_String;
@end example

@item
@example
   procedure Replace_Slice (Source   : in out Unbounded_String;
                            Low      : in Positive;
                            High     : in Natural;
                            By       : in String);
@end example

@item
@example
   function Insert (Source   : in Unbounded_String;
                    Before   : in Positive;
                    New_Item : in String)
      return Unbounded_String;
@end example

@item
@example
   procedure Insert (Source   : in out Unbounded_String;
                     Before   : in Positive;
                     New_Item : in String);
@end example

@item
@example
   function Overwrite (Source    : in Unbounded_String;
                       Position  : in Positive;
                       New_Item  : in String)
      return Unbounded_String;
@end example

@item
@example
   procedure Overwrite (Source    : in out Unbounded_String;
                        Position  : in Positive;
                        New_Item  : in String);
@end example

@item
@example
   function Delete (Source  : in Unbounded_String;
                    From    : in Positive;
                    Through : in Natural)
      return Unbounded_String;
@end example

@item
@example
   procedure Delete (Source  : in out Unbounded_String;
                     From    : in Positive;
                     Through : in Natural);
@end example

@item
@example
   function Trim (Source : in Unbounded_String;
                  Side   : in Trim_End)
      return Unbounded_String;
@end example

@item
@example
   procedure Trim (Source : in out Unbounded_String;
                   Side   : in Trim_End);
@end example

@item
@example
   function Trim (Source : in Unbounded_String;
                  Left   : in Maps.Character_Set;
                  Right  : in Maps.Character_Set)
      return Unbounded_String;
@end example

@item
@example
   procedure Trim (Source : in out Unbounded_String;
                   Left   : in Maps.Character_Set;
                   Right  : in Maps.Character_Set);
@end example

@item
@example
   function Head (Source : in Unbounded_String;
                  Count  : in Natural;
                  Pad    : in Character := Space)
      return Unbounded_String;
@end example

@item
@example
   procedure Head (Source : in out Unbounded_String;
                   Count  : in Natural;
                   Pad    : in Character := Space);
@end example

@item
@example
   function Tail (Source : in Unbounded_String;
                  Count  : in Natural;
                  Pad    : in Character := Space)
      return Unbounded_String;
@end example

@item
@example
   procedure Tail (Source : in out Unbounded_String;
                   Count  : in Natural;
                   Pad    : in Character := Space);
@end example

@item
@example
   function "*" (Left  : in Natural;
                 Right : in Character)
      return Unbounded_String;
@end example

@item
@example
   function "*" (Left  : in Natural;
                 Right : in String)
      return Unbounded_String;
@end example

@item
@example
   function "*" (Left  : in Natural;
                 Right : in Unbounded_String)
      return Unbounded_String;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Strings.Unbounded;
@end example

@item
Null_Unbounded_String represents the null String. If an object of type
Unbounded_String is not otherwise initialized, it will be initialized to
the same value as Null_Unbounded_String.

@item
The function Length returns the length of the String represented by
Source.

@item
The type String_Access provides a (non-private) access type for explicit
processing of unbounded-length strings. The procedure Free performs an
unchecked deallocation of an object of type String_Access.

@item
The function To_Unbounded_String(Source : in String) returns an
Unbounded_String that represents Source. The function
To_Unbounded_String(Length : in Natural) returns an Unbounded_String
that represents an uninitialized String whose length is Length.

@item
The function To_String returns the String with lower bound 1 represented
by Source. To_String and To_Unbounded_String are related as follows:

@enumerate 78
@item
If S is a String, then To_String(To_Unbounded_String(S)) = S.

@item
If U is an Unbounded_String, then To_Unbounded_String(To_String(U)) = U.
@end enumerate
@end enumerate

@enumerate 80
@item
For each of the Append procedures, the resulting string represented by
the Source parameter is given by the concatenation of the original value
of Source and the value of New_Item.

@item
Each of the "&" functions returns an Unbounded_String obtained by
concatenating the string or character given or represented by one of the
parameters, with the string or character given or represented by the
other parameter, and applying To_Unbounded_String to the concatenation
result string.

@item
The Element, Replace_Element, and Slice subprograms have the same effect
as the corresponding bounded-length string subprograms.

@item
Each of the functions "=", "<", ">","<=", and ">=" returns the same
result as the corresponding String operation applied to the String
values given or represented by Left and Right.

@item
Each of the search subprograms (Index, Index_Non_Blank, Count,
Find_Token) has the same effect as the corresponding subprogram in
Strings.Fixed applied to the string represented by the Unbounded_String
parameter.

@item
The Translate function has an analogous effect to the corresponding
subprogram in Strings.Fixed. The translation is applied to the string
represented by the Unbounded_String parameter, and the result is
converted (via To_Unbounded_String) to an Unbounded_String.

@item
Each of the transformation functions (Replace_Slice, Insert, Overwrite,
Delete), selector functions (Trim, Head, Tail), and constructor
functions ("*") is likewise analogous to its corresponding subprogram in
Strings.Fixed. For each of the subprograms, the corresponding
fixed-length string subprogram is applied to the string represented by
the Unbounded_String parameter, and To_Unbounded_String is applied the
result string.

@item
For each of the procedures Translate, Replace_Slice, Insert, Overwrite,
Delete, Trim, Head, and Tail, the resulting string represented by the
Source parameter is given by the corresponding function for fixed-length
strings applied to the string represented by Source's original value.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
No storage associated with an Unbounded_String object shall be lost upon
assignment or scope exit.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4.6, A.4.7, A.4.5, A.4
@subsection String-Handling Sets and Mappings

@enumerate
@item
The language-defined package Strings.Maps.Constants declares
Character_Set and Character_Mapping constants corresponding to
classification and conversion functions in package Characters.Handling.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Strings.Maps.Constants has the following declaration:

@item
@example
package Ada.Strings.Maps.Constants is
   pragma Preelaborate(Constants);
@end example

@item
@example
   Control_Set           : constant Character_Set;
   Graphic_Set           : constant Character_Set;
   Letter_Set            : constant Character_Set;
   Lower_Set             : constant Character_Set;
   Upper_Set             : constant Character_Set;
   Basic_Set             : constant Character_Set;
   Decimal_Digit_Set     : constant Character_Set;
   Hexadecimal_Digit_Set : constant Character_Set;
   Alphanumeric_Set      : constant Character_Set;
   Special_Set           : constant Character_Set;
   ISO_646_Set           : constant Character_Set;
@end example

@item
@example
   Lower_Case_Map        : constant Character_Mapping;
     --Maps to lower case for letters, else identity
   Upper_Case_Map        : constant Character_Mapping;
     --Maps to upper case for letters, else identity
   Basic_Map             : constant Character_Mapping;
     --Maps to basic letter for letters, else identity
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Strings.Maps.Constants;
@end example

@item
Each of these constants represents a correspondingly named set of
characters or character mapping in Characters.Handling, see @ref{A.3.2}.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.4.7, A.5, A.4.6, A.4
@subsection Wide_String Handling

@enumerate
@item
Facilities for handling strings of Wide_Character elements are found in
the packages Strings.Wide_Maps, Strings.Wide_Fixed,
Strings.Wide_Bounded, Strings.Wide_Unbounded, and
Strings.Wide_Maps.Wide_Constants. They provide the same string-handling
operations as the corresponding packages for strings of Character
elements.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The package Strings.Wide_Maps has the following declaration.

@item
@example
package Ada.Strings.Wide_Maps is
   pragma Preelaborate(Wide_Maps);
@end example

@item
@example
   -- Representation for a set of Wide_Character values:
   type Wide_Character_Set is private;
@end example

@item
@example
   Null_Set : constant Wide_Character_Set;
@end example

@item
@example
   type Wide_Character_Range is
     record
         Low  : Wide_Character;
         High : Wide_Character;
     end record;
   -- Represents Wide_Character range Low..High
@end example

@item
@example
   type Wide_Character_Ranges is array (Positive range <>)
     of Wide_Character_Range;
@end example

@item
@example
   function To_Set (Ranges : in Wide_Character_Ranges)
     return Wide_Character_Set;
@end example

@item
@example
   function To_Set (Span : in Wide_Character_Range)
     return Wide_Character_Set;
@end example

@item
@example
   function To_Ranges (Set : in Wide_Character_Set)
     return Wide_Character_Ranges;
@end example

@item
@example
   function "=" (Left, Right : in Wide_Character_Set) return Boolean;
@end example

@item
@example
   function "not" (Right : in Wide_Character_Set)
     return Wide_Character_Set;
   function "and" (Left, Right : in Wide_Character_Set)
     return Wide_Character_Set;
   function "or"  (Left, Right : in Wide_Character_Set)
     return Wide_Character_Set;
   function "xor" (Left, Right : in Wide_Character_Set)
     return Wide_Character_Set;
   function "-"   (Left, Right : in Wide_Character_Set)
     return Wide_Character_Set;
@end example

@item
@example
   function Is_In (Element : in Wide_Character;
                   Set     : in Wide_Character_Set)
      return Boolean;
@end example

@item
@example
   function Is_Subset (Elements : in Wide_Character_Set;
                       Set      : in Wide_Character_Set)
      return Boolean;
@end example

@item
@example
   function "<=" (Left  : in Wide_Character_Set;
                  Right : in Wide_Character_Set)
      return Boolean renames Is_Subset;
@end example

@item
@example
   -- Alternative representation for a set of Wide_Character values:
   subtype Wide_Character_Sequence is Wide_String;
@end example

@item
@example
   function To_Set (Sequence : in Wide_Character_Sequence)
     return Wide_Character_Set;
@end example

@item
@example
   function To_Set (Singleton : in Wide_Character)
     return Wide_Character_Set;
@end example

@item
@example
   function To_Sequence (Set : in Wide_Character_Set)
     return Wide_Character_Sequence;
@end example

@item
@example
   -- Representation for a Wide_Character to Wide_Character mapping:
   type Wide_Character_Mapping is private;
@end example

@item
@example
   function Value (Map     : in Wide_Character_Mapping;
                   Element : in Wide_Character)
      return Wide_Character;
@end example

@item
@example
   Identity : constant Wide_Character_Mapping;
@end example

@item
@example
   function To_Mapping (From, To : in Wide_Character_Sequence)
      return Wide_Character_Mapping;
@end example

@item
@example
   function To_Domain (Map : in Wide_Character_Mapping)
      return Wide_Character_Sequence;
@end example

@item
@example
   function To_Range  (Map : in Wide_Character_Mapping)
      return Wide_Character_Sequence;
@end example

@item
@example
   type Wide_Character_Mapping_Function is access
      function (From : in Wide_Character) return Wide_Character;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Strings.Wide_Maps;
@end example

@item
The context clause for each of the packages Strings.Wide_Fixed,
Strings.Wide_Bounded, and Strings.Wide_Unbounded identifies
Strings.Wide_Maps instead of Strings.Maps.

@item
For each of the packages Strings.Fixed, Strings.Bounded,
Strings.Unbounded, and Strings.Maps.Constants the corresponding wide
string package has the same contents except that

@enumerate 30
@item
Wide_Space replaces Space

@item
Wide_Character replaces Character

@item
Wide_String replaces String

@item
Wide_Character_Set replaces Character_Set

@item
Wide_Character_Mapping replaces Character_Mapping

@item
Wide_Character_Mapping_Function replaces Character_Mapping_Function

@item
Wide_Maps replaces Maps

@item
Bounded_Wide_String replaces Bounded_String

@item
Null_Bounded_Wide_String replaces Null_Bounded_String

@item
To_Bounded_Wide_String replaces To_Bounded_String

@item
To_Wide_String replaces To_String

@item
Unbounded_Wide_String replaces Unbounded_String

@item
Null_Unbounded_Wide_String replaces Null_Unbounded_String

@item
Wide_String_Access replaces String_Access

@item
To_Unbounded_Wide_String replaces To_Unbounded_String
@end enumerate
@end enumerate

@enumerate 45
@item
The following additional declaration is present in
Strings.Wide_Maps.Wide_Constants:

@item
@example
Character_Set : constant Wide_Maps.Wide_Character_Set;
--  Contains each Wide_Character value WC such that
--  Characters.Is_Character(WC) is True
@end example

NOTES

@item
(12) If a null Wide_Character_Mapping_Function is passed to any of the
Wide_String handling subprograms, Constraint_Error is propagated.

@item
(13) Each Wide_Character_Set constant in the package
Strings.Wide_Maps.Wide_Constants contains no values outside the
Character portion of Wide_Character. Similarly, each
Wide_Character_Mapping constant in this package is the identity mapping
when applied to any element outside the Character portion of
Wide_Character.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.5, A.5.1, A.4.7, A
@section The Numerics Packages

@enumerate
@item
The library package Numerics is the parent of several child units that
provide facilities for mathematical computation. One child, the generic
package Generic_Elementary_Functions, is defined in @ref{A.5.1},
together with nongeneric equivalents; two others, the package
Float_Random and the generic package Discrete_Random, are defined in
@ref{A.5.2}. Additional (optional) children are defined in
@ref{G, ``Numerics''}.

@need 1000
@sp 1
@center @emph{Static Semantics}
@end enumerate
@enumerate 3
@item
@example
package Ada.Numerics is
   pragma Pure(Numerics);
   Argument_Error : exception;
   Pi : constant :=
     3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;
   e  : constant :=
     2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996;
end Ada.Numerics;
@end example

@item
The Argument_Error exception is raised by a subprogram in a child unit
of Numerics to signal that one or more of the actual subprogram
parameters are outside the domain of the corresponding mathematical
function.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The implementation may specify the values of Pi and e to a larger number
of significant digits.
@end enumerate

@menu
* A.5.1:: Elementary Functions
* A.5.2:: Random Number Generation
* A.5.3:: Attributes of Floating Point Types
* A.5.4:: Attributes of Fixed Point Types
@end menu

@c ---------------------------------------------------------------------------
@node A.5.1, A.5.2, A.5, A.5
@subsection Elementary Functions

@enumerate
@item
Implementation-defined approximations to the mathematical functions
known as the ``elementary functions'' are provided by the subprograms in
Numerics.Generic_Elementary_Functions. Nongeneric equivalents of this
generic package for each of the predefined floating point types are also
provided as children of Numerics.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The generic library package Numerics.Generic_Elementary_Functions has
the following declaration:

@item
@example
generic
   type Float_Type is digits <>;
package Ada.Numerics.Generic_Elementary_Functions is
   pragma Pure(Generic_Elementary_Functions);
@end example

@item
@example
   function Sqrt (X       : Float_Type'Base) return Float_Type'Base;
   function Log  (X       : Float_Type'Base) return Float_Type'Base;
   function Log  (X, Base : Float_Type'Base) return Float_Type'Base;
   function Exp  (X       : Float_Type'Base) return Float_Type'Base;
   function "**" (Left, Right : Float_Type'Base)
     return Float_Type'Base;
@end example

@item
@example
   function Sin (X        : Float_Type'Base) return Float_Type'Base;
   function Sin (X, Cycle : Float_Type'Base) return Float_Type'Base;
   function Cos (X        : Float_Type'Base) return Float_Type'Base;
   function Cos (X, Cycle : Float_Type'Base) return Float_Type'Base;
   function Tan (X        : Float_Type'Base) return Float_Type'Base;
   function Tan (X, Cycle : Float_Type'Base) return Float_Type'Base;
   function Cot (X        : Float_Type'Base) return Float_Type'Base;
   function Cot (X, Cycle : Float_Type'Base) return Float_Type'Base;
@end example

@item
@example
   function Arcsin (X        : Float_Type'Base)
     return Float_Type'Base;
   function Arcsin (X, Cycle : Float_Type'Base)
     return Float_Type'Base;
   function Arccos (X        : Float_Type'Base)
     return Float_Type'Base;
   function Arccos (X, Cycle : Float_Type'Base)
     return Float_Type'Base;
   function Arctan (Y        : Float_Type'Base;
                    X        : Float_Type'Base := 1.0)
     return Float_Type'Base;
   function Arctan (Y        : Float_Type'Base;
                    X        : Float_Type'Base := 1.0;
                    Cycle    : Float_Type'Base)
     return Float_Type'Base;
   function Arccot (X        : Float_Type'Base;
                    Y        : Float_Type'Base := 1.0)
     return Float_Type'Base;
   function Arccot (X        : Float_Type'Base;
                    Y        : Float_Type'Base := 1.0;
                    Cycle    : Float_Type'Base)
     return Float_Type'Base;
@end example

@item
@example
   function Sinh    (X : Float_Type'Base) return Float_Type'Base;
   function Cosh    (X : Float_Type'Base) return Float_Type'Base;
   function Tanh    (X : Float_Type'Base) return Float_Type'Base;
   function Coth    (X : Float_Type'Base) return Float_Type'Base;
   function Arcsinh (X : Float_Type'Base) return Float_Type'Base;
   function Arccosh (X : Float_Type'Base) return Float_Type'Base;
   function Arctanh (X : Float_Type'Base) return Float_Type'Base;
   function Arccoth (X : Float_Type'Base) return Float_Type'Base;
@end example

@item
@example
end Ada.Numerics.Generic_Elementary_Functions;
@end example

@item
The library package Numerics.Elementary_Functions defines the same
subprograms as Numerics.Generic_Elementary_Functions, except that the
predefined type Float is systematically substituted for Float_Type'Base
throughout. Nongeneric equivalents of
Numerics.Generic_Elementary_Functions for each of the other predefined
floating point types are defined similarly, with the names
Numerics.Short_Elementary_Functions, Numerics.Long_Elementary_Functions,
etc.

@item
The functions have their usual mathematical meanings. When the Base
parameter is specified, the Log function computes the logarithm to the
given base; otherwise, it computes the natural logarithm. When the Cycle
parameter is specified, the parameter X of the forward trigonometric
functions (Sin, Cos, Tan, and Cot) and the results of the inverse
trigonometric functions (Arcsin, Arccos, Arctan, and Arccot) are
measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

@item
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

@enumerate 12
@item
The results of the Sqrt and Arccosh functions and that of the
exponentiation operator are nonnegative.

@item
The result of the Arcsin function is in the quadrant containing the
point (1.0, x), where x is the value of the parameter X. This quadrant
is I or IV; thus, the range of the Arcsin function is approximately
-Pi/2.0 to Pi/2.0 (-Cycle/4.0 to Cycle/4.0, if the parameter Cycle is
specified).

@item
The result of the Arccos function is in the quadrant containing the
point (x, 1.0), where x is the value of the parameter X. This quadrant
is I or II; thus, the Arccos function ranges from 0.0 to approximately
Pi (Cycle/2.0, if the parameter Cycle is specified).

@item
The results of the Arctan and Arccot functions are in the quadrant
containing the point (x, y), where x and y are the values of the
parameters X and Y, respectively. This may be any quadrant (I through
IV) when the parameter X (resp., Y) of Arctan (resp., Arccot) is
specified, but it is restricted to quadrants I and IV (resp., I and II)
when that parameter is omitted. Thus, the range when that parameter is
specified is approximately -Pi to Pi (-Cycle/2.0 to Cycle/2.0, if the
parameter Cycle is specified); when omitted, the range of Arctan (resp.,
Arccot) is that of Arcsin (resp., Arccos), as given above. When the
point (x, y) lies on the negative x-axis, the result approximates

@enumerate 16
@item
Pi (resp., -Pi) when the sign of the parameter Y is positive (resp.,
negative), if Float_Type'Signed_Zeros is True;

@item
Pi, if Float_Type'Signed_Zeros is False.
@end enumerate
@end enumerate
@end enumerate

@enumerate 18
@item
(In the case of the inverse trigonometric functions, in which a result
lying on or near one of the axes may not be exactly representable, the
approximation inherent in computing the result may place it in an
adjacent quadrant, close to but on the wrong side of the axis.)

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The exception Numerics.Argument_Error is raised, signaling a parameter
value outside the domain of the corresponding mathematical function, in
the following cases:

@enumerate 20
@item
by any forward or inverse trigonometric function with specified cycle,
when the value of the parameter Cycle is zero or negative;

@item
by the Log function with specified base, when the value of the parameter
Base is zero, one, or negative;

@item
by the Sqrt and Log functions, when the value of the parameter X is
negative;

@item
by the exponentiation operator, when the value of the left operand is
negative or when both operands have the value zero;

@item
by the Arcsin, Arccos, and Arctanh functions, when the absolute value of
the parameter X exceeds one;

@item
by the Arctan and Arccot functions, when the parameters X and Y both
have the value zero;

@item
by the Arccosh function, when the value of the parameter X is less than
one; and

@item
by the Arccoth function, when the absolute value of the parameter X is
less than one.
@end enumerate
@end enumerate

@enumerate 28
@item
The exception Constraint_Error is raised, signaling a pole of the
mathematical function (analogous to dividing by zero), in the following
cases, provided that Float_Type'Machine_Overflows is True:

@enumerate 29
@item
by the Log, Cot, and Coth functions, when the value of the parameter X
is zero;

@item
by the exponentiation operator, when the value of the left operand is
zero and the value of the exponent is negative;

@item
by the Tan function with specified cycle, when the value of the
parameter X is an odd multiple of the quarter cycle;

@item
by the Cot function with specified cycle, when the value of the
parameter X is zero or a multiple of the half cycle; and

@item
by the Arctanh and Arccoth functions, when the absolute value of the
parameter X is one.
@end enumerate
@end enumerate

@enumerate 34
@item
Constraint_Error can also be raised when a finite result overflows
(@pxref{G.2.4}) this may occur for parameter values sufficiently near
poles, and, in the case of some of the functions, for parameter values
with sufficiently large magnitudes. When Float_Type'Machine_Overflows is
False, the result at poles is unspecified.

@item
When one parameter of a function with multiple parameters represents a
pole and another is outside the function's domain, the latter takes
precedence (i.e., Numerics.Argument_Error is raised).

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
In the implementation of Numerics.Generic_Elementary_Functions, the
range of intermediate values allowed during the calculation of a final
result shall not be affected by any range constraint of the subtype
Float_Type.

@item
In the following cases, evaluation of an elementary function shall yield
the prescribed result, provided that the preceding rules do not call for
an exception to be raised:

@enumerate 38
@item
When the parameter X has the value zero, the Sqrt, Sin, Arcsin, Tan,
Sinh, Arcsinh, Tanh, and Arctanh functions yield a result of zero, and
the Exp, Cos, and Cosh functions yield a result of one.

@item
When the parameter X has the value one, the Sqrt function yields a
result of one, and the Log, Arccos, and Arccosh functions yield a result
of zero.

@item
When the parameter Y has the value zero and the parameter X has a
positive value, the Arctan and Arccot functions yield a result of zero.

@item
The results of the Sin, Cos, Tan, and Cot functions with specified cycle
are exact when the mathematical result is zero; those of the first two
are also exact when the mathematical result is +/-1.0.

@item
Exponentiation by a zero exponent yields the value one. Exponentiation
by a unit exponent yields the value of the left operand. Exponentiation
of the value one yields the value one. Exponentiation of the value zero
yields the value zero.
@end enumerate
@end enumerate

@enumerate 43
@item
Other accuracy requirements for the elementary functions, which apply
only in implementations conforming to the Numerics Annex, and then only
in the ``strict'' mode defined there, see @ref{G.2}, are given in
@ref{G.2.4}.

@item
When Float_Type'Signed_Zeros is True, the sign of a zero result shall be
as follows:

@enumerate 45
@item
A prescribed zero result delivered at the origin by one of the odd
functions (Sin, Arcsin, Sinh, Arcsinh, Tan, Arctan or Arccot as a
function of Y when X is fixed and positive, Tanh, and Arctanh) has the
sign of the parameter X (Y, in the case of Arctan or Arccot).

@item
A prescribed zero result delivered by one of the odd functions away from
the origin, or by some other elementary function, has an
implementation-defined sign.

@item
A zero result that is not a prescribed result (i.e., one that results
from rounding or underflow) has the correct mathematical sign.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 48
@item
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.5.2, A.5.3, A.5.1, A.5
@subsection Random Number Generation

@enumerate
@item
Facilities for the generation of pseudo-random floating point numbers
are provided in the package Numerics.Float_Random; the generic package
Numerics.Discrete_Random provides similar facilities for the generation
of pseudo-random integers and pseudo-random values of enumeration types.
For brevity, pseudo-random values of any of these types are called
random numbers.

@item
Some of the facilities provided are basic to all applications of random
numbers. These include a limited private type each of whose objects
serves as the generator of a (possibly distinct) sequence of random
numbers; a function to obtain the ``next'' random number from a given
sequence of random numbers (that is, from its generator); and
subprograms to initialize or reinitialize a given generator to a
time-dependent state or a state denoted by a single integer.

@item
Other facilities are provided specifically for advanced applications.
These include subprograms to save and restore the state of a given
generator; a private type whose objects can be used to hold the saved
state of a generator; and subprograms to obtain a string representation
of a given generator state, or, given such a string representation, the
corresponding state.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Numerics.Float_Random has the following declaration:

@item
@example
package Ada.Numerics.Float_Random is
@end example

@item
@example
   -- Basic facilities
@end example

@item
@example
   type Generator is limited private;
@end example

@item
@example
   subtype Uniformly_Distributed is Float range 0.0 .. 1.0;
   function Random (Gen : Generator) return Uniformly_Distributed;
@end example

@item
@example
   procedure Reset (Gen       : in Generator;
                    Initiator : in Integer);
   procedure Reset (Gen       : in Generator);
@end example

@item
@example
   -- Advanced facilities
@end example

@item
@example
   type State is private;
@end example

@item
@example
   procedure Save  (Gen        : in  Generator;
                    To_State   : out State);
   procedure Reset (Gen        : in  Generator;
                    From_State : in  State);
@end example

@item
@example
   Max_Image_Width : constant
     := implementation-defined integer value;
@end example

@item
@example
   function Image (Of_State    : State)  return String;
   function Value (Coded_State : String) return State;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Numerics.Float_Random;
@end example

@item
The generic library package Numerics.Discrete_Random has the following
declaration:

@item
@example
generic
   type Result_Subtype is (<>);
package Ada.Numerics.Discrete_Random is
@end example

@item
@example
   -- Basic facilities
@end example

@item
@example
   type Generator is limited private;
@end example

@item
@example
   function Random (Gen : Generator) return Result_Subtype;
@end example

@item
@example
   procedure Reset (Gen       : in Generator;
                    Initiator : in Integer);
   procedure Reset (Gen       : in Generator);
@end example

@item
@example
   -- Advanced facilities
@end example

@item
@example
   type State is private;
@end example

@item
@example
   procedure Save  (Gen        : in  Generator;
                    To_State   : out State);
   procedure Reset (Gen        : in  Generator;
                    From_State : in  State);
@end example

@item
@example
   Max_Image_Width : constant
     := implementation-defined integer value;
@end example

@item
@example
   function Image (Of_State    : State)  return String;
   function Value (Coded_State : String) return State;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Numerics.Discrete_Random;
@end example

@item
An object of the limited private type Generator is associated with a
sequence of random numbers. Each generator has a hidden (internal)
state, which the operations on generators use to determine the position
in the associated sequence. All generators are implicitly initialized to
an unspecified state that does not vary from one program execution to
another; they may also be explicitly initialized, or reinitialized, to a
time-dependent state, to a previously saved state, or to a state
uniquely denoted by an integer value.

@item
An object of the private type State can be used to hold the internal
state of a generator. Such objects are only needed if the application is
designed to save and restore generator states or to examine or
manufacture them.

@item
The operations on generators affect the state and therefore the future
values of the associated sequence. The semantics of the operations on
generators and states are defined below.

@item
@format
function Random (Gen : Generator) return Uniformly_Distributed;

function Random (Gen : Generator) return Result_Subtype;
@end format

@enumerate 32
@item
Obtains the ``next'' random number from the given generator, relative to
its current state, according to an implementation-defined algorithm. The
result of the function in Numerics.Float_Random is delivered as a value
of the subtype Uniformly_Distributed, which is a subtype of the
predefined type Float having a range of 0.0 .. 1.0. The result of the
function in an instantiation of Numerics.Discrete_Random is delivered as
a value of the generic formal subtype Result_Subtype.
@end enumerate
@end enumerate

@enumerate 33
@item
@format
procedure Reset (Gen       : in Generator;
                 Initiator : in Integer);

procedure Reset (Gen       : in Generator);
@end format

@enumerate 34
@item
Sets the state of the specified generator to one that is an unspecified
function of the value of the parameter Initiator (or to a time-dependent
state, if only a generator parameter is specified). The latter form of
the procedure is known as the time-dependent Reset procedure.
@end enumerate
@end enumerate

@enumerate 35
@item
@format
procedure Save  (Gen        : in  Generator;
                 To_State   : out State);

procedure Reset (Gen        : in  Generator;
                 From_State : in  State);
@end format

@enumerate 36
@item
Save obtains the current state of a generator. Reset gives a generator
the specified state. A generator that is reset to a state previously
obtained by invoking Save is restored to the state it had when Save was
invoked.
@end enumerate
@end enumerate

@enumerate 37
@item
@format
function Image (Of_State    : State)  return String;

function Value (Coded_State : String) return State;
@end format

@enumerate 38
@item
Image provides a representation of a state coded (in an
implementation-defined way) as a string whose length is bounded by the
value of Max_Image_Width. Value is the inverse of Image: Value(Image(S))
= S for each state S that can be obtained from a generator by invoking
Save.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 39
@item
Instantiation of Numerics.Discrete_Random with a subtype having a null
range raises Constraint_Error.

@item
Invoking Value with a string that is not the image of any generator
state raises Constraint_Error.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
A sufficiently long sequence of random numbers obtained by successive
calls to Random is approximately uniformly distributed over the range of
the result subtype.

@item
The Random function in an instantiation of Numerics.Discrete_Random is
guaranteed to yield each value in its result subtype in a finite number
of calls, provided that the number of such values does not exceed 2 **
15.

@item
Other performance requirements for the random number generator, which
apply only in implementations conforming to the Numerics Annex, and then
only in the ``strict'' mode defined there, see @ref{G.2}, are given in
@ref{G.2.5}.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
No one algorithm for random number generation is best for all
applications. To enable the user to determine the suitability of the
random number generators for the intended application, the
implementation shall describe the algorithm used and shall give its
period, if known exactly, or a lower bound on the period, if the exact
period is unknown. Periods that are so long that the periodicity is
unobservable in practice can be described in such terms, without giving
a numerical bound.

@item
The implementation also shall document the minimum time interval between
calls to the time-dependent Reset procedure that are guaranteed to
initiate different sequences, and it shall document the nature of the
strings that Value will accept without raising Constraint_Error.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Any storage associated with an object of type Generator should be
reclaimed on exit from the scope of the object.

@item
If the generator period is sufficiently long in relation to the number
of distinct initiator values, then each possible value of Initiator
passed to Reset should initiate a sequence of random numbers that does
not, in a practical sense, overlap the sequence initiated by any other
value. If this is not possible, then the mapping between initiator
values and generator states should be a rapidly varying function of the
initiator value.

NOTES

@item
(14) If two or more tasks are to share the same generator, then the
tasks have to synchronize their access to the generator as for any
shared variable, see @ref{9.10}.

@item
(15) Within a given implementation, a repeatable random number sequence
can be obtained by relying on the implicit initialization of generators
or by explicitly initializing a generator with a repeatable initiator
value. Different sequences of random numbers can be obtained from a
given generator in different program executions by explicitly
initializing the generator to a time-dependent state.

@item
(16) A given implementation of the Random function in
Numerics.Float_Random may or may not be capable of delivering the values
0.0 or 1.0. Portable applications should assume that these values, or
values sufficiently close to them to behave indistinguishably from them,
can occur. If a sequence of random integers from some fixed range is
needed, the application should use the Random function in an appropriate
instantiation of Numerics.Discrete_Random, rather than transforming the
result of the Random function in Numerics.Float_Random. However, some
applications with unusual requirements, such as for a sequence of random
integers each drawn from a different range, will find it more convenient
to transform the result of the floating point Random function. For M>=1,
the expression

@item
@example
Integer(Float(M) * Random(G)) mod M
@end example

@item
transforms the result of Random(G) to an integer uniformly distributed
over the range 0 .. M-1; it is valid even if Random delivers 0.0 or 1.0.
Each value of the result range is possible, provided that M is not too
large. Exponentially distributed (floating point) random numbers with
mean and standard deviation 1.0 can be obtained by the transformation

@item
@example
-Log(Random(G) + Float'Model_Small))
@end example

@item
where Log comes from Numerics.Elementary_Functions, see @ref{A.5.1}, in
this expression, the addition of Float'Model_Small avoids the exception
that would be raised were Log to be given the value zero, without
affecting the result (in most implementations) when Random returns a
nonzero value.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of a program that plays a simulated dice game:

@item
@example
with Ada.Numerics.Discrete_Random;
procedure Dice_Game is
   subtype Die is Integer range 1 .. 6;
   subtype Dice is Integer range 2*Die'First .. 2*Die'Last;
   package Random_Die is new Ada.Numerics.Discrete_Random (Die);
   use Random_Die;
   G : Generator;
   D : Dice;
begin
   Reset (G);  -- Start the generator in a unique state in each run
   loop
      -- Roll a pair of dice; sum and process the results
      D := Random(G) + Random(G);
      ...
   end loop;
end Dice_Game;
@end example

@item
Example of a program that simulates coin tosses:

@item
@example
with Ada.Numerics.Discrete_Random;
procedure Flip_A_Coin is
   type Coin is (Heads, Tails);
   package Random_Coin is new Ada.Numerics.Discrete_Random (Coin);
   use Random_Coin;
   G : Generator;
begin
   Reset (G);  -- Start the generator in a unique state in each run
   loop
      -- Toss a coin and process the result
      case Random(G) is
          when Heads =>
             ...
          when Tails =>
             ...
      end case;
   ...
   end loop;
end Flip_A_Coin;
@end example

@item
Example of a parallel simulation of a physical system, with a separate
generator of event probabilities in each task:

@item
@example
with Ada.Numerics.Float_Random;
procedure Parallel_Simulation is
   use Ada.Numerics.Float_Random;
   task type Worker is
      entry Initialize_Generator (Initiator : in Integer);
      ...
   end Worker;
   W : array (1 .. 10) of Worker;
   task body Worker is
      G : Generator;
      Probability_Of_Event : Uniformly_Distributed;
   begin
      accept Initialize_Generator (Initiator : in Integer) do
         Reset (G, Initiator);
      end Initialize_Generator;
      loop
         ...
         Probability_Of_Event := Random(G);
         ...
      end loop;
   end Worker;
begin
   -- Initialize the generators in the Worker tasks
   -- to different states
   for I in W'Range loop
      W(I).Initialize_Generator (I);
   end loop;
   ... -- Wait for the Worker tasks to terminate
end Parallel_Simulation;
@end example

NOTES

@item
(17) Notes on the last example:  Although each Worker task initializes
its generator to a different state, those states will be the same in
every execution of the program. The generator states can be initialized
uniquely in each program execution by instantiating
Ada.Numerics.Discrete_Random for the type Integer in the main procedure,
resetting the generator obtained from that instance to a time-dependent
state, and then using random integers obtained from that generator to
initialize the generators in each Worker task.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.5.3, A.5.4, A.5.2, A.5
@subsection Attributes of Floating Point Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following representation-oriented attributes are defined for every
subtype S of a floating point type T.

@item
S'Machine_Radix

@example
Yields the radix of the hardware representation of the type
T. The value of this attribute is of the type universal_integer.
@end example

@item
The values of other representation-oriented attributes of a floating
point subtype, and of the ``primitive function'' attributes of a
floating point subtype described later, are defined in terms of a
particular representation of nonzero values called the canonical form.
The canonical form (for the type T) is the form

@example
+/-mantissa*T'Machine_Radix ** exponent
@end example

where

@enumerate 4
@item
mantissa is a fraction in the number base T'Machine_Radix, the first
digit of which is nonzero, and

@item
exponent is an integer.
@end enumerate
@end enumerate

@enumerate 6
@item
S'Machine_Mantissa

@example
Yields the largest value of p such that every value
expressible in the canonical form (for the type T), having a
p-digit mantissa and an exponent between T'Machine_Emin and
T'Machine_Emax, is a machine number, see @ref{3.5.7}, of the type
T. This attribute yields a value of the type
universal_integer.
@end example

@item
S'Machine_Emin

@example
Yields the smallest (most negative) value of exponent such
that every value expressible in the canonical form (for the
type T), having a mantissa of T'Machine_Mantissa digits, is a
machine number, see @ref{3.5.7}, of the type T. This attribute
yields a value of the type universal_integer.
@end example

@item
S'Machine_Emax

@example
Yields the largest (most positive) value of exponent such
that every value expressible in the canonical form (for the
type T), having a mantissa of T'Machine_Mantissa digits, is a
machine number (@pxref{3.5.7}) of the type T. This attribute
yields a value of the type universal_integer.
@end example

@item
S'Denorm

@example
Yields the value True if every value expressible in the form

    +/-mantissa*T'Machine_Radix ** T'Machine_Emin

where mantissa is a nonzero T'Machine_Mantissa-digit fraction
in the number base T'Machine_Radix, the first digit of which
is zero, is a machine number, see @ref{3.5.7}, of the type T;
yields the value False otherwise. The value of this
attribute is of the predefined type Boolean.
@end example

@item
The values described by the formula in the definition of S'Denorm are
called denormalized numbers. A nonzero machine number that is not a
denormalized number is a normalized number. A normalized number x of a
given type T is said to be represented in canonical form when it is
expressed in the canonical form (for the type T) with a mantissa having
T'Machine_Mantissa digits; the resulting form is the canonical-form
representation of x.

@item
S'Machine_Rounds

@example
Yields the value True if rounding is performed on inexact
results of every predefined operation that yields a result of
the type T; yields the value False otherwise. The value of
this attribute is of the predefined type Boolean.
@end example

@item
S'Machine_Overflows

@example
Yields the value True if overflow and divide-by-zero are
detected and reported by raising Constraint_Error for every
predefined operation that yields a result of the type T;
yields the value False otherwise. The value of this
attribute is of the predefined type Boolean.
@end example

@item
S'Signed_Zeros

@example
Yields the value True if the hardware representation for the
type T has the capability of representing both positively and
negatively signed zeros, these being generated and used by
the predefined operations of the type T as specified in IEC
559:1989; yields the value False otherwise. The value of
this attribute is of the predefined type Boolean.
@end example

@item
For every value x of a floating point type T, the normalized exponent of
x is defined as follows:

@enumerate 15
@item
the normalized exponent of zero is (by convention) zero;

@item
for nonzero x, the normalized exponent of x is the unique integer k such
that T'Machine_Radix ** (k - 1) <=|x|<T'Machine_Radix ** k.
@end enumerate
@end enumerate

@enumerate 17
@item
The following primitive function attributes are defined for any subtype
S of a floating point type T.

@item
S'Exponent

@example
S'Exponent denotes a function with the following specification:
@end example

@enumerate 19
@item
@format
function S'Exponent (X : T)
  return universal_integer
@end format

@item
The function yields the normalized exponent of X.
@end enumerate
@end enumerate

@enumerate 21
@item
S'Fraction

@example
S'Fraction denotes a function with the following specification:
@end example

@enumerate 22
@item
@format
function S'Fraction (X : T)
  return T
@end format

@item
The function yields the value X*T'Machine_Radix ** -k, where k is the
normalized exponent of X. A zero result, which can only occur when X is
zero, has the sign of X.
@end enumerate
@end enumerate

@enumerate 24
@item
S'Compose

@example
S'Compose denotes a function with the following specification:
@end example

@enumerate 25
@item
@format
function S'Compose (Fraction : T;
                    Exponent : universal_integer)
  return T
@end format

@item
Let v be the value Fraction*T'Machine_Radix ** (Exponent-k), where k is
the normalized exponent of Fraction. If v is a machine number of the
type T, or if |v|>=T'Model_Small, the function yields v; otherwise, it
yields either one of the machine numbers of the type T adjacent to v.
Constraint_Error is optionally raised if v is outside the base range of
S. A zero result has the sign of Fraction when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 27
@item
S'Scaling

@enumerate 28
@item
@format
S'Scaling denotes a function with the following specification:
@end format

@item
@format
function S'Scaling (X          : T;
                    Adjustment : universal_integer)
  return T
@end format

@item
Let v be the value X*T'Machine_Radix ** (Adjustment). If v is a machine
number of the type T, or if |v|>=T'Model_Small, the function yields v;
otherwise, it yields either one of the machine numbers of the type T
adjacent to v. Constraint_Error is optionally raised if v is outside the
base range of S. A zero result has the sign of X when S'Signed_Zeros is
True.
@end enumerate
@end enumerate

@enumerate 30
@item
S'Floor

@example
S'Floor denotes a function with the following specification:
@end example

@enumerate 31
@item
@format
function S'Floor (X : T)
  return T
@end format

@item
The function yields the value Floor(X), i.e., the largest (most
positive) integral value less than or equal to X. When X is zero, the
result has the sign of X; a zero result otherwise has a positive sign.
@end enumerate
@end enumerate

@enumerate 33
@item
S'Ceiling

@example
S'Ceiling denotes a function with the following specification:
@end example

@enumerate 34
@item
@format
function S'Ceiling (X : T)
  return T
@end format

@item
The function yields the value Ceiling(X), i.e., the smallest (most
negative) integral value greater than or equal to X. When X is zero, the
result has the sign of X; a zero result otherwise has a negative sign
when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 36
@item
S'Rounding

@example
S'Rounding denotes a function with the following specification:
@end example

@enumerate 37
@item
@format
function S'Rounding (X : T)
  return T
@end format

@item
The function yields the integral value nearest to X, rounding away from
zero if X lies exactly halfway between two integers. A zero result has
the sign of X when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 39
@item
S'Unbiased_Rounding

@example
S'Unbiased_Rounding denotes a function with the following
specification:
@end example

@enumerate 40
@item
@format
function S'Unbiased_Rounding (X : T)
  return T
@end format

@item
The function yields the integral value nearest to X, rounding toward the
even integer if X lies exactly halfway between two integers. A zero
result has the sign of X when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 42
@item
S'Truncation

@example
S'Truncation denotes a function with the following
specification:
@end example

@enumerate 43
@item
@format
function S'Truncation (X : T)
  return T
@end format

@item
The function yields the value Ceiling(X) when X is negative, and
Floor(X) otherwise. A zero result has the sign of X when S'Signed_Zeros
is True.
@end enumerate
@end enumerate

@enumerate 45
@item
S'Remainder

@example
S'Remainder denotes a function with the following
specification:
@end example

@enumerate 46
@item
@format
function S'Remainder (X, Y : T)
  return T
@end format

@item
For nonzero Y, let v be the value X-n*Y, where n is the integer nearest
to the exact value of X/Y; if |n-X/Y|=1/2, then n is chosen to be even.
If v is a machine number of the type T, the function yields v;
otherwise, it yields zero. Constraint_Error is raised if Y is zero. A
zero result has the sign of X when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 48
@item
S'Adjacent

@example
S'Adjacent denotes a function with the following specification:
@end example

@enumerate 49
@item
@format
function S'Adjacent (X, Towards : T)
  return T
@end format

@item
If Towards=X, the function yields X; otherwise, it yields the machine
number of the type T adjacent to X in the direction of Towards, if that
machine number exists. If the result would be outside the base range of
S, Constraint_Error is raised. When T'Signed_Zeros is True, a zero
result has the sign of X. When Towards is zero, its sign has no bearing
on the result.
@end enumerate
@end enumerate

@enumerate 51
@item
S'Copy_Sign

@example
S'Copy_Sign denotes a function with the following
specification:
@end example

@enumerate 52
@item
@format
function S'Copy_Sign (Value, Sign : T)
  return T
@end format

@item
If the value of Value is nonzero, the function yields a result whose
magnitude is that of Value and whose sign is that of Sign; otherwise, it
yields the value zero. Constraint_Error is optionally raised if the
result is outside the base range of S. A zero result has the sign of
Sign when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 54
@item
S'Leading_Part

@example
S'Leading_Part denotes a function with the following
specification:
@end example

@enumerate 55
@item
@format
function S'Leading_Part (X : T;
                         Radix_Digits : universal_integer)
  return T
@end format

@item
Let v be the value T'Machine_Radix ** (k-Radix_Digits), where k is the
normalized exponent of X. The function yields the value

@enumerate 57
@item
Floor(X/v)*v, when X is nonnegative and Radix_Digits is positive;

@item
Ceiling(X/v)*v, when X is negative and Radix_Digits is positive.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 59
@item
Constraint_Error is raised when Radix_Digits is zero or negative. A zero
result, which can only occur when X is zero, has the sign of X.
@end enumerate
@end enumerate

@enumerate 60
@item
S'Machine

@example
S'Machine denotes a function with the following specification:
@end example

@enumerate 61
@item
@format
function S'Machine (X : T)
  return T
@end format

@item
If X is a machine number of the type T, the function yields X;
otherwise, it yields the value obtained by rounding or truncating X to
either one of the adjacent machine numbers of the type T.
Constraint_Error is raised if rounding or truncating X to the precision
of the machine numbers results in a value outside the base range of S. A
zero result has the sign of X when S'Signed_Zeros is True.
@end enumerate
@end enumerate

@enumerate 63
@item
The following model-oriented attributes are defined for any subtype S of
a floating point type T.

@item
S'Model_Mantissa

@example
If the Numerics Annex is not supported, this attribute yields
an implementation defined value that is greater than or equal
to Ceiling(d*log (10)/log (T'Machine_Radix))+1, where d is
the requested decimal precision of T, and less than or equal
to the value of T'Machine_Mantissa. @xref{G.2.2}, for further
requirements that apply to implementations supporting the
Numerics Annex. The value of this attribute is of the type
universal_integer.
@end example

@item
S'Model_Emin

@example
If the Numerics Annex is not supported, this attribute yields
an implementation defined value that is greater than or equal
to the value of T'Machine_Emin. @xref{G.2.2}, for further
requirements that apply to implementations supporting the
Numerics Annex. The value of this attribute is of the type
universal_integer.
@end example

@item
S'Model_Epsilon

@example
Yields the value T'Machine_Radix ** 1-T'Model_Mantissa. The value
of this attribute is of the type universal_real.
@end example

@item
S'Model_Small

@example
Yields the value T'Machine_Radix ** T'Model_Emin-1. The value of
this attribute is of the type universal_real.
@end example

@item
S'Model

@example
S'Model denotes a function with the following specification:
@end example

@enumerate 69
@item
@format
function S'Model (X : T)
  return T
@end format

@item
If the Numerics Annex is not supported, the meaning of this attribute is
implementation defined;  @xref{G.2.2}, for the definition that applies to
implementations supporting the Numerics Annex.
@end enumerate
@end enumerate

@enumerate 71
@item
S'Safe_First

@example
Yields the lower bound of the safe range, see @ref{3.5.7}, of the
type T. If the Numerics Annex is not supported, the value of
this attribute is implementation defined;  @xref{G.2.2}, for the
definition that applies to implementations supporting the
Numerics Annex. The value of this attribute is of the type
universal_real.
@end example

@item
S'Safe_Last

@example
Yields the upper bound of the safe range, see @ref{3.5.7}, of the
type T. If the Numerics Annex is not supported, the value of
this attribute is implementation defined;  @xref{G.2.2}, for the
definition that applies to implementations supporting the
Numerics Annex. The value of this attribute is of the type
universal_real.
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.5.4, A.6, A.5.3, A.5
@subsection Attributes of Fixed Point Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following representation-oriented attributes are defined for every
subtype S of a fixed point type T.

@item
S'Machine_Radix

@example
Yields the radix of the hardware representation of the type
T. The value of this attribute is of the type
universal_integer.
@end example

@item
S'Machine_Rounds

@example
Yields the value True if rounding is performed on inexact
results of every predefined operation that yields a result of
the type T; yields the value False otherwise. The value of
this attribute is of the predefined type Boolean.
@end example

@item
S'Machine_Overflows

@example
Yields the value True if overflow and divide-by-zero are
detected and reported by raising Constraint_Error for every
predefined operation that yields a result of the type T;
yields the value False otherwise. The value of this
attribute is of the predefined type Boolean.
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.6, A.7, A.5.4, A
@section Input-Output

@enumerate
@item
Input-output is provided through language-defined packages, each of
which is a child of the root package Ada. The generic packages
Sequential_IO and Direct_IO define input-output operations applicable to
files containing elements of a given type. The generic package
Storage_IO supports reading from and writing to an in-memory buffer.
Additional operations for text input-output are supplied in the packages
Text_IO and Wide_Text_IO. Heterogeneous input-output is provided through
the child packages Streams.Stream_IO and Text_IO.Text_Streams, see also
@ref{13.13}. The package IO_Exceptions defines the exceptions needed by
the predefined input-output packages.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.7, A.8, A.6, A
@section External Files and File Objects

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
Values input from the external environment of the program, or output to
the external environment, are considered to occupy external files. An
external file can be anything external to the program that can produce a
value to be read or receive a value to be written. An external file is
identified by a string (the name). A second string (the form) gives
further system-dependent characteristics that may be associated with the
file, such as the physical organization or access rights. The
conventions governing the interpretation of such strings shall be
documented.

@item
Input and output operations are expressed as operations on objects of
some file type, rather than directly in terms of the external files. In
the remainder of this section, the term file is always used to refer to
a file object; the term external file is used otherwise.

@item
Input-output for sequential files of values of a single element type is
defined by means of the generic package Sequential_IO. In order to
define sequential input-output for a given element type, an
instantiation of this generic unit, with the given type as actual
parameter, has to be declared. The resulting package contains the
declaration of a file type (called File_Type) for files of such
elements, as well as the operations applicable to these files, such as
the Open, Read, and Write procedures.

@item
Input-output for direct access files is likewise defined by a generic
package called Direct_IO. Input-output in human-readable form is defined
by the (nongeneric) packages Text_IO for Character and String data, and
Wide_Text_IO for Wide_Character and Wide_String data. Input-output for
files containing streams of elements representing values of possibly
different types is defined by means of the (nongeneric) package
Streams.Stream_IO.

@item
Before input or output operations can be performed on a file, the file
first has to be associated with an external file. While such an
association is in effect, the file is said to be open, and otherwise the
file is said to be closed.

@item
The language does not define what happens to external files after the
completion of the main program and all the library tasks (in particular,
if corresponding files have not been closed). The effect of input-output
for access types is unspecified.

@item
An open file has a current mode, which is a value of one of the
following enumeration types:

@item
@format
type File_Mode is (In_File, Inout_File, Out_File);  --  for Direct_IO
@end format

@enumerate 9
@item
These values correspond respectively to the cases where only reading,
both reading and writing, or only writing are to be performed.
@end enumerate
@end enumerate

@enumerate 10
@item
@format
type File_Mode is (In_File, Out_File, Append_File);
--  for Sequential_IO, Text_IO, Wide_Text_IO, and Stream_IO
@end format

@enumerate 11
@item
These values correspond respectively to the cases where only reading,
only writing, or only appending are to be performed.

@item
The mode of a file can be changed.
@end enumerate
@end enumerate

@enumerate 13
@item
Several file management operations are common to Sequential_IO,
Direct_IO, Text_IO, and Wide_Text_IO. These operations are described in
subclause @ref{A.8.2}, for sequential and direct files. Any additional
effects concerning text input-output are described in
@ref{A.10.2}.

@item
The exceptions that can be propagated by the execution of an
input-output subprogram are defined in the package IO_Exceptions; the
situations in which they can be propagated are described following the
description of the subprogram (and in @ref{A.13}). The
exceptions Storage_Error and Program_Error may be propagated.
(Program_Error can only be propagated due to errors made by the caller
of the subprogram.) Finally, exceptions can be propagated in certain
implementation-defined situations.

NOTES

@item
(18) Each instantiation of the generic packages Sequential_IO and
Direct_IO declares a different type File_Type. In the case of Text_IO,
Wide_Text_IO, and Streams.Stream_IO, the corresponding type File_Type is
unique.

@item
(19) A bidirectional device can often be modeled as two sequential files
associated with the device, one of mode In_File, and one of mode
Out_File. An implementation may restrict the number of files that may
be associated with a given external file.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.8, A.8.1, A.7, A
@section Sequential and Direct Files

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
Two kinds of access to external files are defined in this subclause:
sequential access and direct access. The corresponding file types and
the associated operations are provided by the generic packages
Sequential_IO and Direct_IO. A file object to be used for sequential
access is called a sequential file, and one to be used for direct access
is called a direct file. Access to stream files is described in
@ref{A.12.1}.

@item
For sequential access, the file is viewed as a sequence of values that
are transferred in the order of their appearance (as produced by the
program or by the external environment). When the file is opened with
mode In_File or Out_File, transfer starts respectively from or to the
beginning of the file. When the file is opened with mode Append_File,
transfer to the file starts after the last element of the file.

@item
For direct access, the file is viewed as a set of elements occupying
consecutive positions in linear order; a value can be transferred to or
from an element of the file at any selected position. The position of an
element is specified by its index, which is a number, greater than zero,
of the implementation-defined integer type Count. The first element, if
any, has index one; the index of the last element, if any, is called the
current size; the current size is zero if there are no elements. The
current size is a property of the external file.

@item
An open direct file has a current index, which is the index that will be
used by the next read or write operation. When a direct file is opened,
the current index is set to one. The current index of a direct file is a
property of a file object, not of an external file.
@end enumerate

@menu
* A.8.1:: The Generic Package Sequential_IO
* A.8.2:: File Management
* A.8.3:: Sequential Input-Output Operations
* A.8.4:: The Generic Package Direct_IO
* A.8.5:: Direct Input-Output Operations
@end menu

@c ---------------------------------------------------------------------------
@node A.8.1, A.8.2, A.8, A.8
@subsection The Generic Package Sequential_IO

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The generic library package Sequential_IO has the following declaration:

@item
@example
with Ada.IO_Exceptions;
generic
   type Element_Type(<>) is private;
package Ada.Sequential_IO is
@end example

@item
@example
   type File_Type is limited private;
@end example

@item
@example
   type File_Mode is (In_File, Out_File, Append_File);
@end example

@item
@example
   -- File management
@end example

@item
@example
   procedure Create(File : in out File_Type;
                    Mode : in File_Mode := Out_File;
                    Name : in String := "";
                    Form : in String := "");
@end example

@item
@example
   procedure Open  (File : in out File_Type;
                    Mode : in File_Mode;
                    Name : in String;
                    Form : in String := "");
@end example

@item
@example
   procedure Close (File : in out File_Type);
   procedure Delete(File : in out File_Type);
   procedure Reset (File : in out File_Type; Mode : in File_Mode);
   procedure Reset (File : in out File_Type);
@end example

@item
@example
   function Mode   (File : in File_Type) return File_Mode;
   function Name   (File : in File_Type) return String;
   function Form   (File : in File_Type) return String;
@end example

@item
@example
   function Is_Open(File : in File_Type) return Boolean;
@end example

@item
@example
   -- Input and output operations
@end example

@item
@example
   procedure Read  (File : in File_Type; Item : out Element_Type);
   procedure Write (File : in File_Type; Item : in Element_Type);
@end example

@item
@example
   function End_Of_File(File : in File_Type) return Boolean;
@end example

@item
@example
   -- Exceptions
@end example

@item
@example
   Status_Error : exception renames IO_Exceptions.Status_Error;
   Mode_Error   : exception renames IO_Exceptions.Mode_Error;
   Name_Error   : exception renames IO_Exceptions.Name_Error;
   Use_Error    : exception renames IO_Exceptions.Use_Error;
   Device_Error : exception renames IO_Exceptions.Device_Error;
   End_Error    : exception renames IO_Exceptions.End_Error;
   Data_Error   : exception renames IO_Exceptions.Data_Error;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Sequential_IO;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.8.2, A.8.3, A.8.1, A.8
@subsection File Management

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The procedures and functions described in this subclause provide for the
control of external files; their declarations are repeated in each of
the packages for sequential, direct, text, and stream input-output. For
text input-output, the procedures Create, Open, and Reset have
additional effects described in subclause (@pxref{A.10.2}).

@item
@format
procedure Create(File : in out File_Type;
                 Mode : in File_Mode := default_mode;
                 Name : in String := "";
                 Form : in String := "");
@end format

@enumerate 3
@item
Establishes a new external file, with the given name and form, and
associates this external file with the given file. The given file is
left open. The current mode of the given file is set to the given access
mode. The default access mode is the mode Out_File for sequential and
text input-output; it is the mode Inout_File for direct input-output. or
direct access, the size of the created file is implementation defined.

@item
A null string for Name specifies an external file that is not accessible
after the completion of the main program (a temporary file). A null
string for Form specifies the use of the default options of the
implementation for the external file.

@item
The exception Status_Error is propagated if the given file is already
open. The exception Name_Error is propagated if the string given as Name
does not allow the identification of an external file. The exception
Use_Error is propagated if, for the specified mode, the external
environment does not support creation of an external file with the given
name (in the absence of Name_Error) and form.
@end enumerate
@end enumerate

@enumerate 6
@item
@format
procedure Open(File : in out File_Type;
               Mode : in File_Mode;
               Name : in String;
               Form : in String := "");
@end format

@enumerate 7
@item
Associates the given file with an existing external file having the
given name and form, and sets the current mode of the given file to the
given mode. The given file is left open.

@item
The exception Status_Error is propagated if the given file is already
open. The exception Name_Error is propagated if the string given as Name
does not allow the identification of an external file; in particular,
this exception is propagated if no external file with the given name
exists. The exception Use_Error is propagated if, for the specified
mode, the external environment does not support opening for an external
file with the given name (in the absence of Name_Error) and form.
@end enumerate
@end enumerate

@enumerate 9
@item
@format
procedure Close(File : in out File_Type);
@end format

@enumerate 10
@item
Severs the association between the given file and its associated
external file. The given file is left closed. In addition, for
sequential files, if the file being closed has mode Out_File or
Append_File, then the last element written since the most recent open or
reset is the last element that can be read from the file. If no elements
have been written and the file mode is Out_File, then the closed file is
empty. If no elements have been written and the file mode is
Append_File, then the closed file is unchanged.

@item
The exception Status_Error is propagated if the given file is not open.
@end enumerate
@end enumerate

@enumerate 12
@item
@format
procedure Delete(File : in out File_Type);
@end format

@enumerate 13
@item
Deletes the external file associated with the given file. The given file
is closed, and the external file ceases to exist.

@item
The exception Status_Error is propagated if the given file is not open.
The exception Use_Error is propagated if deletion of the external file
is not supported by the external environment.
@end enumerate
@end enumerate

@enumerate 15
@item
@format
procedure Reset(File : in out File_Type; Mode : in File_Mode);
procedure Reset(File : in out File_Type);
@end format

@enumerate 16
@item
Resets the given file so that reading from its elements can be restarted
from the beginning of the file (for modes In_File and Inout_File), and
so that writing to its elements can be restarted at the beginning of the
file (for modes Out_File and Inout_File) or after the last element of
the file (for mode Append_File). In particular, for direct access this
means that the current index is set to one. If a Mode parameter is
supplied, the current mode of the given file is set to the given mode.
In addition, for sequential files, if the given file has mode Out_File
or Append_File when Reset is called, the last element written since the
most recent open or reset is the last element that can be read from the
file. If no elements have been written and the file mode is Out_File,
the reset file is empty. If no elements have been written and the file
mode is Append_File, then the reset file is unchanged.

@item
The exception Status_Error is propagated if the file is not open. The
exception Use_Error is propagated if the external environment does not
support resetting for the external file and, also, if the external
environment does not support resetting to the specified mode for the
external file.
@end enumerate
@end enumerate

@enumerate 18
@item
@format
function Mode(File : in File_Type) return File_Mode;
@end format

@enumerate 19
@item
Returns the current mode of the given file.

@item
The exception Status_Error is propagated if the file is not open.
@end enumerate
@end enumerate

@enumerate 21
@item
@format
function Name(File : in File_Type) return String;
@end format

@enumerate 22
@item
Returns a string which uniquely identifies the external file currently
associated with the given file (and may thus be used in an Open
operation). If an external environment allows alternative specifications
of the name (for example, abbreviations), the string returned by the
function should correspond to a full specification of the name.

@item
The exception Status_Error is propagated if the given file is not open.
The exception Use_Error is propagated if the associated external file is
a temporary file that cannot be opened by any name.
@end enumerate
@end enumerate

@enumerate 24
@item
@format
function Form(File : in File_Type) return String;
@end format

@enumerate 25
@item
Returns the form string for the external file currently associated with
the given file. If an external environment allows alternative
specifications of the form (for example, abbreviations using default
options), the string returned by the function should correspond to a
full specification (that is, it should indicate explicitly all options
selected, including default options).

@item
The exception Status_Error is propagated if the given file is not open.
@end enumerate
@end enumerate

@enumerate 27
@item
@format
function Is_Open(File : in File_Type) return Boolean;
@end format

@enumerate 28
@item
Returns True if the file is open (that is, if it is associated with an
external file), otherwise returns False.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 29
@item
An implementation may propagate Name_Error or Use_Error if an attempt is
made to use an I/O feature that cannot be supported by the
implementation due to limitations in the external environment. Any such
restriction should be documented.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.8.3, A.8.4, A.8.2, A.8
@subsection Sequential Input-Output Operations

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The operations available for sequential input and output are described
in this subclause. The exception Status_Error is propagated if any of
these operations is attempted for a file that is not open.

@item
@format
procedure Read(File : in File_Type; Item : out Element_Type);
@end format

@enumerate 3
@item
Operates on a file of mode In_File. Reads an element from the given
file, and returns the value of this element in the Item parameter.

@item
The exception Mode_Error is propagated if the mode is not In_File. The
exception End_Error is propagated if no more elements can be read from
the given file. The exception Data_Error can be propagated if the
element read cannot be interpreted as a value of the subtype
Element_Type, see @ref{A.13, ``Exceptions in Input-Output''}.
@end enumerate
@end enumerate

@enumerate 5
@item
@format
procedure Write(File : in File_Type; Item : in Element_Type);
@end format

@enumerate 6
@item
Operates on a file of mode Out_File or Append_File. Writes the value of
Item to the given file.

@item
The exception Mode_Error is propagated if the mode is not Out_File or
Append_File. The exception Use_Error is propagated if the capacity of
the external file is exceeded.
@end enumerate
@end enumerate

@enumerate 8
@item
@format
function End_Of_File(File : in File_Type) return Boolean;
@end format

@enumerate 9
@item
Operates on a file of mode In_File. Returns True if no more elements can
be read from the given file; otherwise returns False.

@item
The exception Mode_Error is propagated if the mode is not In_File.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node A.8.4, A.8.5, A.8.3, A.8
@subsection The Generic Package Direct_IO

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The generic library package Direct_IO has the following declaration:

@item
@example
with Ada.IO_Exceptions;
generic
   type Element_Type is private;
package Ada.Direct_IO is
@end example

@item
@example
   type File_Type is limited private;
@end example

@item
@example
   type File_Mode is (In_File, Inout_File, Out_File);
   type Count     is range 0 .. implementation-defined;
   subtype Positive_Count is Count range 1 .. Count'Last;
@end example

@item
@example
   -- File management
@end example

@item
@example
   procedure Create(File : in out File_Type;
                    Mode : in File_Mode := Inout_File;
                    Name : in String := "";
                    Form : in String := "");
@end example

@item
@example
   procedure Open  (File : in out File_Type;
                    Mode : in File_Mode;
                    Name : in String;
                    Form : in String := "");
@end example

@item
@example
   procedure Close (File : in out File_Type);
   procedure Delete(File : in out File_Type);
   procedure Reset (File : in out File_Type; Mode : in File_Mode);
   procedure Reset (File : in out File_Type);
@end example

@item
@example
   function Mode   (File : in File_Type) return File_Mode;
   function Name   (File : in File_Type) return String;
   function Form   (File : in File_Type) return String;
@end example

@item
@example
   function Is_Open(File : in File_Type) return Boolean;
@end example

@item
@example
   -- Input and output operations
@end example

@item
@example
   procedure Read (File : in File_Type; Item : out Element_Type;
                                        From : in Positive_Count);
   procedure Read (File : in File_Type; Item : out Element_Type);
@end example

@item
@example
   procedure Write(File : in File_Type; Item : in  Element_Type;
                                        To   : in Positive_Count);
   procedure Write(File : in File_Type; Item : in Element_Type);
@end example

@item
@example
   procedure Set_Index(File : in File_Type; To : in Positive_Count);
@end example

@item
@example
   function Index(File : in File_Type) return Positive_Count;
   function Size (File : in File_Type) return Count;
@end example

@item
@example
   function End_Of_File(File : in File_Type) return Boolean;
@end example

@item
@example
   -- Exceptions
@end example

@item
@example
   Status_Error : exception renames IO_Exceptions.Status_Error;
   Mode_Error   : exception renames IO_Exceptions.Mode_Error;
   Name_Error   : exception renames IO_Exceptions.Name_Error;
   Use_Error    : exception renames IO_Exceptions.Use_Error;
   Device_Error : exception renames IO_Exceptions.Device_Error;
   End_Error    : exception renames IO_Exceptions.End_Error;
   Data_Error   : exception renames IO_Exceptions.Data_Error;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Direct_IO;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.8.5, A.9, A.8.4, A.8
@subsection Direct Input-Output Operations

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The operations available for direct input and output are described in
this subclause. The exception Status_Error is propagated if any of these
operations is attempted for a file that is not open.

@item
@format
procedure Read(File : in File_Type; Item : out Element_Type;
                                    From : in  Positive_Count);

procedure Read(File : in File_Type; Item : out Element_Type);
@end format

@enumerate 3
@item
Operates on a file of mode In_File or Inout_File. In the case of the
first form, sets the current index of the given file to the index value
given by the parameter From. Then (for both forms) returns, in the
parameter Item, the value of the element whose position in the given
file is specified by the current index of the file; finally, increases
the current index by one.

@item
The exception Mode_Error is propagated if the mode of the given file is
Out_File. The exception End_Error is propagated if the index to be used
exceeds the size of the external file. The exception Data_Error can be
propagated if the element read cannot be interpreted as a value of the
subtype Element_Type, see @ref{A.13}.
@end enumerate
@end enumerate

@enumerate 5
@item
@format
procedure Write(File : in File_Type; Item : in Element_Type;
                                     To   : in Positive_Count);

procedure Write(File : in File_Type; Item : in Element_Type);
@end format

@enumerate 6
@item
Operates on a file of mode Inout_File or Out_File. In the case of the
first form, sets the index of the given file to the index value given by
the parameter To. Then (for both forms) gives the value of the parameter
Item to the element whose position in the given file is specified by the
current index of the file; finally, increases the current index by one.

@item
The exception Mode_Error is propagated if the mode of the given file is
In_File. The exception Use_Error is propagated if the capacity of the
external file is exceeded.
@end enumerate
@end enumerate

@enumerate 8
@item
@format
procedure Set_Index(File : in File_Type; To : in Positive_Count);
@end format

@enumerate 9
@item
Operates on a file of any mode. Sets the current index of the given file
to the given index value (which may exceed the current size of the
file).
@end enumerate
@end enumerate

@enumerate 10
@item
@format
function Index(File : in File_Type) return Positive_Count;
@end format

@enumerate 11
@item
Operates on a file of any mode. Returns the current index of the given
file.
@end enumerate
@end enumerate

@enumerate 12
@item
@format
function Size(File : in File_Type) return Count;
@end format

@enumerate 13
@item
Operates on a file of any mode. Returns the current size of the external
file that is associated with the given file.
@end enumerate
@end enumerate

@enumerate 14
@item
@format
function End_Of_File(File : in File_Type) return Boolean;
@end format

@enumerate 15
@item
Operates on a file of mode In_File or Inout_File. Returns True if the
current index exceeds the size of the external file; otherwise returns
False.

@item
The exception Mode_Error is propagated if the mode of the given file is
Out_File.
@end enumerate
@end enumerate
@enumerate 17

NOTES

@item
(20) Append_File mode is not supported for the generic package
Direct_IO.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.9, A.10, A.8.5, A
@section The Generic Package Storage_IO

@enumerate
@item
The generic package Storage_IO provides for reading from and writing to
an in-memory buffer. This generic package supports the construction of
user-defined input-output packages.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The generic library package Storage_IO has the following declaration:

@item
@example
with Ada.IO_Exceptions;
with System.Storage_Elements;
generic
   type Element_Type is private;
package Ada.Storage_IO is
   pragma Preelaborate(Storage_IO);
@end example

@item
@example
   Buffer_Size : constant System.Storage_Elements.Storage_Count
     := implementation-defined;
   subtype Buffer_Type is
     System.Storage_Elements.Storage_Array (1..Buffer_Size);
@end example

@item
@example
   -- Input and output operations
@end example

@item
@example
   procedure Read (Buffer : in      Buffer_Type;
                   Item   :     out Element_Type);
@end example

@item
@example
   procedure Write(Buffer :    out Buffer_Type;
                   Item   : in     Element_Type);
@end example

@item
@example
   -- Exceptions
@end example

@item
@example
   Data_Error : exception renames IO_Exceptions.Data_Error;
end Ada.Storage_IO;
@end example

@item
In each instance, the constant Buffer_Size has a value that is the size
(in storage elements) of the buffer required to represent the content of
an object of subtype Element_Type, including any implicit levels of
indirection used by the implementation. The Read and Write procedures of
Storage_IO correspond to the Read and Write procedures of Direct_IO
(@pxref{A.8.4}) but with the content of the Item parameter being read from
or written into the specified Buffer, rather than an external file.

NOTES

@item
(21) A buffer used for Storage_IO holds only one element at a time; an
external file used for Direct_IO holds a sequence of elements.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10, A.10.1, A.9, A
@section Text Input-Output

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
This clause describes the package Text_IO, which provides facilities for
input and output in human-readable form. Each file is read or written
sequentially, as a sequence of characters grouped into lines, and as a
sequence of lines grouped into pages. The specification of the package
is given below in subclause (@pxref{A.10.1}).

@item
The facilities for file management given above, in 
@ref{A.8.2} and @ref{A.8.3}, are available for text input-output. In
place of Read and Write, however, there are procedures Get and Put that
input values of suitable types from text files, and output values to
them. These values are provided to the Put procedures, and returned by
the Get procedures, in a parameter Item. Several overloaded procedures
of these names exist, for different types of Item. These Get procedures
analyze the input sequences of characters based on lexical elements (see
@ref{2}.) and return the corresponding values; the Put
procedures output the given values as appropriate lexical elements.
Procedures Get and Put are also available that input and output
individual characters treated as character values rather than as lexical
elements. Related to character input are procedures to look ahead at the
next character without reading it, and to read a character
``immediately'' without waiting for an end-of-line to signal
availability.

@item
In addition to the procedures Get and Put for numeric and enumeration
types of Item that operate on text files, analogous procedures are
provided that read from and write to a parameter of type String. These
procedures perform the same analysis and composition of character
sequences as their counterparts which have a file parameter.

@item
For all Get and Put procedures that operate on text files, and for many
other subprograms, there are forms with and without a file parameter.
Each such Get procedure operates on an input file, and each such Put
procedure operates on an output file. If no file is specified, a default
input file or a default output file is used.

@item
At the beginning of program execution the default input and output files
are the so-called standard input file and standard output file. These
files are open, have respectively the current modes In_File and
Out_File, and are associated with two implementation-defined external
files. Procedures are provided to change the current default input file
and the current default output file.

@item
At the beginning of program execution a default file for
program-dependent error-related text output is the so-called standard
error file. This file is open, has the current mode Out_File, and is
associated with an implementation-defined external file. A procedure is
provided to change the current default error file.

@item
From a logical point of view, a text file is a sequence of pages, a page
is a sequence of lines, and a line is a sequence of characters; the end
of a line is marked by a line terminator; the end of a page is marked by
the combination of a line terminator immediately followed by a page
terminator; and the end of a file is marked by the combination of a line
terminator immediately followed by a page terminator and then a file
terminator. Terminators are generated during output; either by calls of
procedures provided expressly for that purpose; or implicitly as part of
other operations, for example, when a bounded line length, a bounded
page length, or both, have been specified for a file.

@item
The actual nature of terminators is not defined by the language and
hence depends on the implementation. Although terminators are recognized
or generated by certain of the procedures that follow, they are not
necessarily implemented as characters or as sequences of characters.
Whether they are characters (and if so which ones) in any particular
implementation need not concern a user who neither explicitly outputs
nor explicitly inputs control characters. The effect of input (Get) or
output (Put) of control characters (other than horizontal tabulation) is
not specified by the language.

@item
The characters of a line are numbered, starting from one; the number of
a character is called its column number. For a line terminator, a column
number is also defined: it is one more than the number of characters in
the line. The lines of a page, and the pages of a file, are similarly
numbered. The current column number is the column number of the next
character or line terminator to be transferred. The current line number
is the number of the current line. The current page number is the number
of the current page. These numbers are values of the subtype
Positive_Count of the type Count (by convention, the value zero of the
type Count is used to indicate special conditions).

@item
@example
type Count is range 0 .. implementation-defined;
subtype Positive_Count is Count range 1 .. Count'Last;
@end example

@item
For an output file or an append file, a maximum line length can be
specified and a maximum page length can be specified. If a value to be
output cannot fit on the current line, for a specified maximum line
length, then a new line is automatically started before the value is
output; if, further, this new line cannot fit on the current page, for a
specified maximum page length, then a new page is automatically started
before the value is output. Functions are provided to determine the
maximum line length and the maximum page length. When a file is opened
with mode Out_File or Append_File, both values are zero: by convention,
this means that the line lengths and page lengths are unbounded.
(Consequently, output consists of a single line if the subprograms for
explicit control of line and page structure are not used.)  The constant
Unbounded is provided for this purpose.
@end enumerate

@menu
* A.10.1::  The Package Text_IO
* A.10.2::  Text File Management
* A.10.3::  Default Input, Output, and Error Files
* A.10.4::  Specification of Line and Page Lengths
* A.10.5::  Operations on Columns, Lines, and Pages
* A.10.6::  Get and Put Procedures
* A.10.7::  Input-Output of Characters and Strings
* A.10.8::  Input-Output for Integer Types
* A.10.9::  Input-Output for Real Types
* A.10.10:: Input-Output for Enumeration Types
@end menu

@c ---------------------------------------------------------------------------
@node A.10.1, A.10.2, A.10, A.10
@subsection The Package Text_IO

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The library package Text_IO has the following declaration:

@item
@example
with Ada.IO_Exceptions;
package Ada.Text_IO is
@end example

@item
@example
   type File_Type is limited private;
@end example

@item
@example
   type File_Mode is (In_File, Out_File, Append_File);
@end example

@item
@example
   type Count is range 0 .. implementation-defined;
   subtype Positive_Count is Count range 1 .. Count'Last;
   Unbounded : constant Count := 0; -- line and page length
@end example

@item
@example
   subtype Field       is Integer range 0 .. implementation-defined;
   subtype Number_Base is Integer range 2 .. 16;
@end example

@item
@example
   type Type_Set is (Lower_Case, Upper_Case);
@end example

@item
@example
   -- File Management
@end example

@item
@example
   procedure Create (File : in out File_Type;
                     Mode : in File_Mode := Out_File;
                     Name : in String    := "";
                     Form : in String    := "");
@end example

@item
@example
   procedure Open   (File : in out File_Type;
                     Mode : in File_Mode;
                     Name : in String;
                     Form : in String := "");
@end example

@item
@example
   procedure Close  (File : in out File_Type);
   procedure Delete (File : in out File_Type);
   procedure Reset  (File : in out File_Type; Mode : in File_Mode);
   procedure Reset  (File : in out File_Type);
@end example

@item
@example
   function  Mode   (File : in File_Type) return File_Mode;
   function  Name   (File : in File_Type) return String;
   function  Form   (File : in File_Type) return String;
@end example

@item
@example
   function  Is_Open(File : in File_Type) return Boolean;
@end example

@item
@example
   -- Control of default input and output files
@end example

@item
@example
   procedure Set_Input (File : in File_Type);
   procedure Set_Output(File : in File_Type);
   procedure Set_Error (File : in File_Type);
@end example

@item
@example
   function Standard_Input  return File_Type;
   function Standard_Output return File_Type;
   function Standard_Error  return File_Type;
@end example

@item
@example
   function Current_Input   return File_Type;
   function Current_Output  return File_Type;
   function Current_Error   return File_Type;
@end example

@item
@example
   type File_Access is access constant File_Type;
@end example

@item
@example
   function Standard_Input  return File_Access;
   function Standard_Output return File_Access;
   function Standard_Error  return File_Access;
@end example

@item
@example
   function Current_Input   return File_Access;
   function Current_Output  return File_Access;
   function Current_Error   return File_Access;
@end example

@item
@example
   --Buffer control

   procedure Flush (File : in out File_Type);
   procedure Flush;
@end example

@item
@example
   -- Specification of line and page lengths
@end example

@item
@example
   procedure Set_Line_Length(File : in File_Type; To : in Count);
   procedure Set_Line_Length(To   : in Count);
@end example

@item
@example
   procedure Set_Page_Length(File : in File_Type; To : in Count);
   procedure Set_Page_Length(To   : in Count);
@end example

@item
@example
   function  Line_Length(File : in File_Type) return Count;
   function  Line_Length return Count;
@end example

@item
@example
   function  Page_Length(File : in File_Type) return Count;
   function  Page_Length return Count;
@end example

@item
@example
   -- Column, Line, and Page Control
@end example

@item
@example
   procedure New_Line   (File    : in File_Type;
                         Spacing : in Positive_Count := 1);
   procedure New_Line   (Spacing : in Positive_Count := 1);
@end example

@item
@example
   procedure Skip_Line  (File    : in File_Type;
                         Spacing : in Positive_Count := 1);
   procedure Skip_Line  (Spacing : in Positive_Count := 1);
@end example

@item
@example
   function  End_Of_Line(File : in File_Type) return Boolean;
   function  End_Of_Line return Boolean;
@end example

@item
@example
   procedure New_Page   (File : in File_Type);
   procedure New_Page;
@end example

@item
@example
   procedure Skip_Page  (File : in File_Type);
   procedure Skip_Page;
@end example

@item
@example
   function  End_Of_Page(File : in File_Type) return Boolean;
   function  End_Of_Page return Boolean;
@end example

@item
@example
   function  End_Of_File(File : in File_Type) return Boolean;
   function  End_Of_File return Boolean;
@end example

@item
@example
   procedure Set_Col (File : in File_Type; To : in Positive_Count);
   procedure Set_Col (To   : in Positive_Count);
@end example

@item
@example
   procedure Set_Line(File : in File_Type; To : in Positive_Count);
   procedure Set_Line(To   : in Positive_Count);
@end example

@item
@example
   function Col (File : in File_Type) return Positive_Count;
   function Col  return Positive_Count;
@end example

@item
@example
   function Line(File : in File_Type) return Positive_Count;
   function Line return Positive_Count;
@end example

@item
@example
   function Page(File : in File_Type) return Positive_Count;
   function Page return Positive_Count;
@end example

@item
@example
   -- Character Input-Output
@end example

@item
@example
   procedure Get(File : in  File_Type; Item : out Character);
   procedure Get(Item : out Character);
@end example

@item
@example
   procedure Put(File : in  File_Type; Item : in Character);
   procedure Put(Item : in  Character);
@end example

@item
@example
   procedure Look_Ahead (File        : in  File_Type;
                         Item        : out Character;
                         End_Of_Line : out Boolean);
   procedure Look_Ahead (Item        : out Character;
                         End_Of_Line : out Boolean);
@end example

@item
@example
   procedure Get_Immediate(File      : in  File_Type;
                           Item      : out Character);
   procedure Get_Immediate(Item      : out Character);
@end example

@item
@example
   procedure Get_Immediate(File      : in  File_Type;
                           Item      : out Character;
                           Available : out Boolean);
   procedure Get_Immediate(Item      : out Character;
                           Available : out Boolean);
@end example

@item
@example
   -- String Input-Output
@end example

@item
@example
   procedure Get(File : in  File_Type; Item : out String);
   procedure Get(Item : out String);
@end example

@item
@example
   procedure Put(File : in  File_Type; Item : in String);
   procedure Put(Item : in  String);
@end example

@item
@example
   procedure Get_Line(File : in  File_Type;
                      Item : out String;
                      Last : out Natural);
   procedure Get_Line(Item : out String; Last : out Natural);
@end example

@item
@example
   procedure Put_Line(File : in  File_Type; Item : in String);
   procedure Put_Line(Item : in  String);
@end example

@item
@example
   -- Generic packages for Input-Output of Integer Types
@end example

@item
@example
   generic
      type Num is range <>;
   package Integer_IO is
@end example

@item
@example
      Default_Width : Field := Num'Width;
      Default_Base  : Number_Base := 10;
@end example

@item
@example
      procedure Get(File  : in  File_Type;
                    Item  : out Num;
                    Width : in Field := 0);
      procedure Get(Item  : out Num;
                    Width : in  Field := 0);
@end example

@item
@example
      procedure Put(File  : in File_Type;
                    Item  : in Num;
                    Width : in Field := Default_Width;
                    Base  : in Number_Base := Default_Base);
      procedure Put(Item  : in Num;
                    Width : in Field := Default_Width;
                    Base  : in Number_Base := Default_Base);
      procedure Get(From : in  String;
                    Item : out Num;
                    Last : out Positive);
      procedure Put(To   : out String;
                    Item : in Num;
                    Base : in Number_Base := Default_Base);
@end example

@item
@example
   end Integer_IO;
@end example

@item
@example
   generic
      type Num is mod <>;
   package Modular_IO is
@end example

@item
@example
      Default_Width : Field := Num'Width;
      Default_Base  : Number_Base := 10;
@end example

@item
@example
      procedure Get(File  : in  File_Type;
                    Item  : out Num;
                    Width : in Field := 0);
      procedure Get(Item  : out Num;
                    Width : in  Field := 0);
@end example

@item
@example
      procedure Put(File  : in File_Type;
                    Item  : in Num;
                    Width : in Field := Default_Width;
                    Base  : in Number_Base := Default_Base);
      procedure Put(Item  : in Num;
                    Width : in Field := Default_Width;
                    Base  : in Number_Base := Default_Base);
      procedure Get(From : in  String;
                    Item : out Num;
                    Last : out Positive);
      procedure Put(To   : out String;
                    Item : in Num;
                    Base : in Number_Base := Default_Base);
@end example

@item
@example
   end Modular_IO;
@end example

@item
@example
   -- Generic packages for Input-Output of Real Types
@end example

@item
@example
   generic
      type Num is digits <>;
   package Float_IO is
@end example

@item
@example
      Default_Fore : Field := 2;
      Default_Aft  : Field := Num'Digits-1;
      Default_Exp  : Field := 3;
@end example

@item
@example
      procedure Get(File  : in  File_Type;
                    Item  : out Num;
                    Width : in  Field := 0);
      procedure Get(Item  : out Num;
                    Width : in  Field := 0);
@end example

@item
@example
      procedure Put(File : in File_Type;
                    Item : in Num;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
      procedure Put(Item : in Num;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
@end example

@item
@example
      procedure Get(From : in String;
                    Item : out Num;
                    Last : out Positive);
      procedure Put(To   : out String;
                    Item : in Num;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
   end Float_IO;
@end example

@item
@example
   generic
      type Num is delta <>;
   package Fixed_IO is
@end example

@item
@example
      Default_Fore : Field := Num'Fore;
      Default_Aft  : Field := Num'Aft;
      Default_Exp  : Field := 0;
@end example

@item
@example
      procedure Get(File  : in  File_Type;
                    Item  : out Num;
                    Width : in  Field := 0);
      procedure Get(Item  : out Num;
                    Width : in  Field := 0);
@end example

@item
@example
      procedure Put(File : in File_Type;
                    Item : in Num;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
      procedure Put(Item : in Num;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
@end example

@item
@example
      procedure Get(From : in  String;
                    Item : out Num;
                    Last : out Positive);
      procedure Put(To   : out String;
                    Item : in Num;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
   end Fixed_IO;
@end example

@item
@example
   generic
      type Num is delta <> digits <>;
   package Decimal_IO is
@end example

@item
@example
      Default_Fore : Field := Num'Fore;
      Default_Aft  : Field := Num'Aft;
      Default_Exp  : Field := 0;
@end example

@item
@example
      procedure Get(File  : in  File_Type;
                    Item  : out Num;
                    Width : in  Field := 0);
      procedure Get(Item  : out Num;
                    Width : in  Field := 0);
@end example

@item
@example
      procedure Put(File : in File_Type;
                    Item : in Num;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
      procedure Put(Item : in Num;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
@end example

@item
@example
      procedure Get(From : in  String;
                    Item : out Num;
                    Last : out Positive);
      procedure Put(To   : out String;
                    Item : in Num;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
   end Decimal_IO;
@end example

@item
@example
   -- Generic package for Input-Output of Enumeration Types
@end example

@item
@example
   generic
      type Enum is (<>);
   package Enumeration_IO is
@end example

@item
@example
      Default_Width   : Field := 0;
      Default_Setting : Type_Set := Upper_Case;
@end example

@item
@example
      procedure Get(File : in  File_Type;
                    Item : out Enum);
      procedure Get(Item : out Enum);
@end example

@item
@example
      procedure Put(File  : in File_Type;
                    Item  : in Enum;
                    Width : in Field    := Default_Width;
                    Set   : in Type_Set := Default_Setting);
      procedure Put(Item  : in Enum;
                    Width : in Field    := Default_Width;
                    Set   : in Type_Set := Default_Setting);
@end example

@item
@example
      procedure Get(From : in  String;
                    Item : out Enum;
                    Last : out Positive);
      procedure Put(To   : out String;
                    Item : in  Enum;
                    Set  : in  Type_Set := Default_Setting);
   end Enumeration_IO;
@end example

@item
@example
   -- Exceptions
@end example

@item
@example
   Status_Error : exception renames IO_Exceptions.Status_Error;
   Mode_Error   : exception renames IO_Exceptions.Mode_Error;
   Name_Error   : exception renames IO_Exceptions.Name_Error;
   Use_Error    : exception renames IO_Exceptions.Use_Error;
   Device_Error : exception renames IO_Exceptions.Device_Error;
   End_Error    : exception renames IO_Exceptions.End_Error;
   Data_Error   : exception renames IO_Exceptions.Data_Error;
   Layout_Error : exception renames IO_Exceptions.Layout_Error;
private
   ... -- not specified by the language
end Ada.Text_IO;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.2, A.10.3, A.10.1, A.10
@subsection Text File Management

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The only allowed file modes for text files are the modes In_File,
Out_File, and Append_File. The subprograms given in 
@ref{A.8.2}, for the control of external files, and the function
End_Of_File given in  @ref{A.8.3}, for sequential
input-output, are also available for text files. There is also a version
of End_Of_File that refers to the current default input file. For text
files, the procedures have the following additional effects:

@enumerate 2
@item
For the procedures Create and Open: After a file with mode Out_File or
Append_File is opened, the page length and line length are unbounded
(both have the conventional value zero). After a file (of any mode) is
opened, the current column, current line, and current page numbers are
set to one. If the mode is Append_File, it is implementation defined
whether a page terminator will separate preexisting text in the file
from the new text to be written.

@item
For the procedure Close: If the file has the current mode Out_File or
Append_File, has the effect of calling New_Page, unless the current page
is already terminated; then outputs a file terminator.

@item
For the procedure Reset: If the file has the current mode Out_File or
Append_File, has the effect of calling New_Page, unless the current page
is already terminated; then outputs a file terminator. The current
column, line, and page numbers are set to one, and the line and page
lengths to Unbounded. If the new mode is Append_File, it is
implementation defined whether a page terminator will separate
preexisting text in the file from the new text to be written.
@end enumerate
@end enumerate

@enumerate 5
@item
The exception Mode_Error is propagated by the procedure Reset upon an
attempt to change the mode of a file that is the current default input
file, the current default output file, or the current default error
file.

NOTES

@item
(22) An implementation can define the Form parameter of Create and Open
to control effects including the following:

@enumerate 7
@item
the interpretation of line and column numbers for an interactive file,
and

@item
the interpretation of text formats in a file created by a foreign
program.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.3, A.10.4, A.10.2, A.10
@subsection Default Input, Output, and Error Files

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following subprograms provide for the control of the particular
default files that are used when a file parameter is omitted from a Get,
Put, or other operation of text input-output described below, or when
application-dependent error-related text is to be output.

@item
@format
procedure Set_Input(File : in File_Type);
@end format

@enumerate 3
@item
Operates on a file of mode In_File. Sets the current default input file
to File.

@item
The exception Status_Error is propagated if the given file is not open.
The exception Mode_Error is propagated if the mode of the given file is
not In_File.
@end enumerate
@end enumerate

@enumerate 5
@item
@format
procedure Set_Output(File : in File_Type);
procedure Set_Error (File : in File_Type);
@end format

@enumerate 6
@item
Each operates on a file of mode Out_File or Append_File. Set_Output sets
the current default output file to File. Set_Error sets the current
default error file to File. The exception Status_Error is propagated if
the given file is not open. The exception Mode_Error is propagated if
the mode of the given file is not Out_File or Append_File.
@end enumerate
@end enumerate

@enumerate 7
@item
@format
function Standard_Input return File_Type;
function Standard_Input return File_Access;
@end format

@enumerate 8
@item
Returns the standard input file, see @ref{A.10}, or an access value
designating the standard input file, respectively.
@end enumerate
@end enumerate

@enumerate 9
@item
@format
function Standard_Output return File_Type;
function Standard_Output return File_Access;
@end format

@enumerate 10
@item
Returns the standard output file, see @ref{A.10}, or an access value
designating the standard output file, respectively.
@end enumerate
@end enumerate

@enumerate 11
@item
@format
function Standard_Error return File_Type;
function Standard_Error return File_Access;
@end format

@enumerate 12
@item
Returns the standard error file, see @ref{A.10}, or an access value
designating the standard output file, respectively.

@item
The Form strings implicitly associated with the opening of
Standard_Input, Standard_Output, and Standard_Error at the start of
program execution are implementation defined.
@end enumerate
@end enumerate

@enumerate 14
@item
@format
function Current_Input return File_Type;
function Current_Input return File_Access;
@end format

@enumerate 15
@item
Returns the current default input file, or an access value designating
the current default input file, respectively.
@end enumerate
@end enumerate

@enumerate 16
@item
@format
function Current_Output return File_Type;
function Current_Output return File_Access;
@end format

@enumerate 17
@item
Returns the current default output file, or an access value designating
the current default output file, respectively.
@end enumerate
@end enumerate

@enumerate 18
@item
@format
function Current_Error return File_Type;
function Current_Error return File_Access;
@end format

@enumerate 19
@item
Returns the current default error file, or an access value designating
the current default error file, respectively.
@end enumerate
@end enumerate

@enumerate 20
@item
@format
procedure Flush (File : in out File_Type);
procedure Flush;
@end format

@enumerate 21
@item
The effect of Flush is the same as the corresponding subprogram in
Streams.Stream_IO, see @ref{A.12.1}. If File is not explicitly specified,
Current_Output is used.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@enumerate 22
@item
The execution of a program is erroneous if it attempts to use a current
default input, default output, or default error file that no longer
exists.

@item
If the Close operation is applied to a file object that is also serving
as the default input, default output, or default error file, then
subsequent operations on such a default file are erroneous.

NOTES

@item
(23) The standard input, standard output, and standard error files
cannot be opened, closed, reset, or deleted, because the parameter File
of the corresponding procedures has the mode in out.

@item
(24) The standard input, standard output, and standard error files are
different file objects, but not necessarily different external files.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.4, A.10.5, A.10.3, A.10
@subsection Specification of Line and Page Lengths

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The subprograms described in this subclause are concerned with the line
and page structure of a file of mode Out_File or Append_File. They
operate either on the file given as the first parameter, or, in the
absence of such a file parameter, on the current default output file.
They provide for output of text with a specified maximum line length or
page length. In these cases, line and page terminators are output
implicitly and automatically when needed. When line and page lengths are
unbounded (that is, when they have the conventional value zero), as in
the case of a newly opened file, new lines and new pages are only
started when explicitly called for.

@item
In all cases, the exception Status_Error is propagated if the file to be
used is not open; the exception Mode_Error is propagated if the mode of
the file is not Out_File or Append_File.

@item
@format
procedure Set_Line_Length(File : in File_Type; To : in Count);
procedure Set_Line_Length(To   : in Count);
@end format

@enumerate 4
@item
Sets the maximum line length of the specified output or append file to
the number of characters specified by To. The value zero for To
specifies an unbounded line length.

@item
The exception Use_Error is propagated if the specified line length is
inappropriate for the associated external file.
@end enumerate
@end enumerate

@enumerate 6
@item
@format
procedure Set_Page_Length(File : in File_Type; To : in Count);
procedure Set_Page_Length(To   : in Count);
@end format

@enumerate 7
@item
Sets the maximum page length of the specified output or append file to
the number of lines specified by To. The value zero for To specifies an
unbounded page length.

@item
The exception Use_Error is propagated if the specified page length is
inappropriate for the associated external file.
@end enumerate
@end enumerate

@enumerate 9
@item
@format
function Line_Length(File : in File_Type) return Count;
function Line_Length return Count;
@end format

@enumerate 10
@item
Returns the maximum line length currently set for the specified output
or append file, or zero if the line length is unbounded.
@end enumerate
@end enumerate

@enumerate 11
@item
@format
function Page_Length(File : in File_Type) return Count;
function Page_Length return Count;
@end format

@enumerate 12
@item
Returns the maximum page length currently set for the specified output
or append file, or zero if the page length is unbounded.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.5, A.10.6, A.10.4, A.10
@subsection Operations on Columns, Lines, and Pages

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The subprograms described in this subclause provide for explicit control
of line and page structure; they operate either on the file given as the
first parameter, or, in the absence of such a file parameter, on the
appropriate (input or output) current default file. The exception
Status_Error is propagated by any of these subprograms if the file to be
used is not open.

@item
@format
procedure New_Line(File    : in File_Type;
                   Spacing : in Positive_Count := 1);
procedure New_Line(Spacing : in Positive_Count := 1);
@end format

@enumerate 3
@item
Operates on a file of mode Out_File or Append_File.

@item
For a Spacing of one: Outputs a line terminator and sets the current
column number to one. Then increments the current line number by one,
except in the case that the current line number is already greater than
or equal to the maximum page length, for a bounded page length; in that
case a page terminator is output, the current page number is incremented
by one, and the current line number is set to one.

@item
For a Spacing greater than one, the above actions are performed Spacing
times.

@item
The exception Mode_Error is propagated if the mode is not Out_File or
Append_File.
@end enumerate
@end enumerate

@enumerate 7
@item
@format
procedure Skip_Line(File    : in File_Type;
                    Spacing : in Positive_Count := 1);
procedure Skip_Line(Spacing : in Positive_Count := 1);
@end format

@enumerate 8
@item
Operates on a file of mode In_File.

@item
For a Spacing of one: Reads and discards all characters until a line
terminator has been read, and then sets the current column number to
one. If the line terminator is not immediately followed by a page
terminator, the current line number is incremented by one. Otherwise, if
the line terminator is immediately followed by a page terminator, then
the page terminator is skipped, the current page number is incremented
by one, and the current line number is set to one.

@item
For a Spacing greater than one, the above actions are performed Spacing
times.

@item
The exception Mode_Error is propagated if the mode is not In_File. The
exception End_Error is propagated if an attempt is made to read a file
terminator.
@end enumerate
@end enumerate

@enumerate 12
@item
@format
function End_Of_Line(File : in File_Type) return Boolean;
function End_Of_Line return Boolean;
@end format

@enumerate 13
@item
Operates on a file of mode In_File. Returns True if a line terminator or
a file terminator is next; otherwise returns False.

@item
The exception Mode_Error is propagated if the mode is not In_File.
@end enumerate
@end enumerate

@enumerate 15
@item
@format
procedure New_Page(File : in File_Type);
procedure New_Page;
@end format

@enumerate 16
@item
Operates on a file of mode Out_File or Append_File. Outputs a line
terminator if the current line is not terminated, or if the current page
is empty (that is, if the current column and line numbers are both equal
to one). Then outputs a page terminator, which terminates the current
page. Adds one to the current page number and sets the current column
and line numbers to one.

@item
The exception Mode_Error is propagated if the mode is not Out_File or
Append_File.
@end enumerate
@end enumerate

@enumerate 18
@item
@format
procedure Skip_Page(File : in File_Type);
procedure Skip_Page;
@end format

@enumerate 19
@item
Operates on a file of mode In_File. Reads and discards all characters
and line terminators until a page terminator has been read. Then adds
one to the current page number, and sets the current column and line
numbers to one.

@item
The exception Mode_Error is propagated if the mode is not In_File. The
exception End_Error is propagated if an attempt is made to read a file
terminator.
@end enumerate
@end enumerate

@enumerate 21
@item
@format
function End_Of_Page(File : in File_Type) return Boolean;
function End_Of_Page return Boolean;
@end format

@enumerate 22
@item
Operates on a file of mode In_File. Returns True if the combination of a
line terminator and a page terminator is next, or if a file terminator
is next; otherwise returns False.

@item
The exception Mode_Error is propagated if the mode is not In_File.
@end enumerate
@end enumerate

@enumerate 24
@item
@format
function End_Of_File(File : in File_Type) return Boolean;
function End_Of_File return Boolean;
@end format

@enumerate 25
@item
Operates on a file of mode In_File. Returns True if a file terminator is
next, or if the combination of a line, a page, and a file terminator is
next; otherwise returns False.

@item
The exception Mode_Error is propagated if the mode is not In_File.

@item
The following subprograms provide for the control of the current
position of reading or writing in a file. In all cases, the default file
is the current output file.
@end enumerate
@end enumerate

@enumerate 28
@item
@format
procedure Set_Col(File : in File_Type; To : in Positive_Count);
procedure Set_Col(To   : in Positive_Count);
@end format

@enumerate 29
@item
If the file mode is Out_File or Append_File:

@enumerate 30
@item
If the value specified by To is greater than the current column number,
outputs spaces, adding one to the current column number after each
space, until the current column number equals the specified value. If
the value specified by To is equal to the current column number, there
is no effect. If the value specified by To is less than the current
column number, has the effect of calling New_Line (with a spacing of
one), then outputs (To - 1) spaces, and sets the current column number
to the specified value.

@item
The exception Layout_Error is propagated if the value specified by To
exceeds Line_Length when the line length is bounded (that is, when it
does not have the conventional value zero).
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 32
@item
If the file mode is In_File:

@enumerate 33
@item
Reads (and discards) individual characters, line terminators, and page
terminators, until the next character to be read has a column number
that equals the value specified by To; there is no effect if the current
column number already equals this value. Each transfer of a character or
terminator maintains the current column, line, and page numbers in the
same way as a Get procedure, see @ref{A.10.6}. (Short lines will be skipped
until a line is reached that has a character at the specified column
position.)

@item
The exception End_Error is propagated if an attempt is made to read a
file terminator.
@end enumerate
@end enumerate
@end enumerate

@enumerate 35
@item
@format
procedure Set_Line(File : in File_Type; To : in Positive_Count);
procedure Set_Line(To   : in Positive_Count);
@end format

@enumerate 36
@item
If the file mode is Out_File or Append_File:

@enumerate 37
@item
If the value specified by To is greater than the current line number,
has the effect of repeatedly calling New_Line (with a spacing of one),
until the current line number equals the specified value. If the value
specified by To is equal to the current line number, there is no effect.
If the value specified by To is less than the current line number, has
the effect of calling New_Page followed by a call of New_Line with a
spacing equal to (To - 1).

@item
The exception Layout_Error is propagated if the value specified by To
exceeds Page_Length when the page length is bounded (that is, when it
does not have the conventional value zero).
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 39
@item
If the mode is In_File:

@enumerate 40
@item
Has the effect of repeatedly calling Skip_Line (with a spacing of one),
until the current line number equals the value specified by To; there is
no effect if the current line number already equals this value. (Short
pages will be skipped until a page is reached that has a line at the
specified line position.)

@item
The exception End_Error is propagated if an attempt is made to read a
file terminator.
@end enumerate
@end enumerate
@end enumerate

@enumerate 42
@item
@format
function Col(File : in File_Type) return Positive_Count;
function Col return Positive_Count;
@end format

@enumerate 43
@item
Returns the current column number.

@item
The exception Layout_Error is propagated if this number exceeds
Count'Last.
@end enumerate
@end enumerate

@enumerate 45
@item
@format
function Line(File : in File_Type) return Positive_Count;
function Line return Positive_Count;
@end format

@enumerate 46
@item
Returns the current line number.

@item
The exception Layout_Error is propagated if this number exceeds
Count'Last.
@end enumerate
@end enumerate

@enumerate 48
@item
@format
function Page(File : in File_Type) return Positive_Count;
function Page return Positive_Count;
@end format

@enumerate 49
@item
Returns the current page number.

@item
The exception Layout_Error is propagated if this number exceeds
Count'Last.
@end enumerate
@end enumerate

@enumerate 51
@item
The column number, line number, or page number are allowed to exceed
Count'Last (as a consequence of the input or output of sufficiently many
characters, lines, or pages). These events do not cause any exception to
be propagated. However, a call of Col, Line, or Page propagates the
exception Layout_Error if the corresponding number exceeds Count'Last.

NOTES

@item
(25) A page terminator is always skipped whenever the preceding line
terminator is skipped. An implementation may represent the combination
of these terminators by a single character, provided that it is properly
recognized on input.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.6, A.10.7, A.10.5, A.10
@subsection Get and Put Procedures

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The procedures Get and Put for items of the type Character, String,
numeric types, and enumeration types are described in subsequent
subclauses. Features of these procedures that are common to most of
these types are described in this subclause. The Get and Put procedures
for items of type Character and String deal with individual character
values; the Get and Put procedures for numeric and enumeration types
treat the items as lexical elements.

@item
All procedures Get and Put have forms with a file parameter, written
first. Where this parameter is omitted, the appropriate (input or
output) current default file is understood to be specified. Each
procedure Get operates on a file of mode In_File. Each procedure Put
operates on a file of mode Out_File or Append_File.

@item
All procedures Get and Put maintain the current column, line, and page
numbers of the specified file: the effect of each of these procedures
upon these numbers is the result of the effects of individual transfers
of characters and of individual output or skipping of terminators. Each
transfer of a character adds one to the current column number. Each
output of a line terminator sets the current column number to one and
adds one to the current line number. Each output of a page terminator
sets the current column and line numbers to one and adds one to the
current page number. For input, each skipping of a line terminator sets
the current column number to one and adds one to the current line
number; each skipping of a page terminator sets the current column and
line numbers to one and adds one to the current page number. Similar
considerations apply to the procedures Get_Line, Put_Line, and Set_Col.

@item
Several Get and Put procedures, for numeric and enumeration types, have
format parameters which specify field lengths; these parameters are of
the nonnegative subtype Field of the type Integer.

@item
Input-output of enumeration values uses the syntax of the corresponding
lexical elements. Any Get procedure for an enumeration type begins by
skipping any leading blanks, or line or page terminators. Get procedures
for numeric or enumeration types start by skipping leading blanks, where
a blank is defined as a space or a horizontal tabulation character.
Next, characters are input only so long as the sequence input is an
initial sequence of an identifier or of a character literal (in
particular, input ceases when a line terminator is encountered). The
character or line terminator that causes input to cease remains
available for subsequent input.

@item
For a numeric type, the Get procedures have a format parameter called
Width. If the value given for this parameter is zero, the Get procedure
proceeds in the same manner as for enumeration types, but using the
syntax of numeric literals instead of that of enumeration literals. If a
nonzero value is given, then exactly Width characters are input, or the
characters up to a line terminator, whichever comes first; any skipped
leading blanks are included in the count. The syntax used for numeric
literals is an extended syntax that allows a leading sign (but no
intervening blanks, or line or page terminators) and that also allows
(for real types) an integer literal as well as forms that have digits
only before the point or only after the point.

@item
Any Put procedure, for an item of a numeric or an enumeration type,
outputs the value of the item as a numeric literal, identifier, or
character literal, as appropriate. This is preceded by leading spaces if
required by the format parameters Width or Fore (as described in later
subclauses), and then a minus sign for a negative value; for an
enumeration type, the spaces follow instead of leading. The format given
for a Put procedure is overridden if it is insufficiently wide, by using
the minimum needed width.

@item
Two further cases arise for Put procedures for numeric and enumeration
types, if the line length of the specified output file is bounded (that
is, if it does not have the conventional value zero). If the number of
characters to be output does not exceed the maximum line length, but is
such that they cannot fit on the current line, starting from the current
column, then (in effect) New_Line is called (with a spacing of one)
before output of the item. Otherwise, if the number of characters
exceeds the maximum line length, then the exception Layout_Error is
propagated and nothing is output.

@item
The exception Status_Error is propagated by any of the procedures Get,
Get_Line, Put, and Put_Line if the file to be used is not open. The
exception Mode_Error is propagated by the procedures Get and Get_Line if
the mode of the file to be used is not In_File; and by the procedures
Put and Put_Line, if the mode is not Out_File or Append_File.

@item
The exception End_Error is propagated by a Get procedure if an attempt
is made to skip a file terminator. The exception Data_Error is
propagated by a Get procedure if the sequence finally input is not a
lexical element corresponding to the type, in particular if no
characters were input; for this test, leading blanks are ignored; for an
item of a numeric type, when a sign is input, this rule applies to the
succeeding numeric literal. The exception Layout_Error is propagated by
a Put procedure that outputs to a parameter of type String, if the
length of the actual string is insufficient for the output of the item.

@need 1000
@sp 1
@center @emph{Examples}

@item
In the examples, here and in @ref{A.10.8}, and
@ref{A.10.9}, the string quotes and the lower case letter b are not
transferred: they are shown only to reveal the layout and spaces.

@item
@example
N : Integer;
   ...
Get(N);
@end example

@item
@example
-- Characters at input  Sequence input  Value of N

-- bb-12535b            -12535          -12535
-- bb12_535e1b           12_535e1        125350
-- bb12_535e;            12_535e         (none) Data_Error raised
@end example

@item
Example of overridden width parameter:

@item
@example
Put(Item => -23, Width => 2);  --  "-23"
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.7, A.10.8, A.10.6, A.10
@subsection Input-Output of Characters and Strings

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
For an item of type Character the following procedures are provided:

@item
@format
procedure Get(File : in File_Type; Item : out Character);
procedure Get(Item : out Character);
@end format

@enumerate 3
@item
After skipping any line terminators and any page terminators, reads the
next character from the specified input file and returns the value of
this character in the out parameter Item.

@item
The exception End_Error is propagated if an attempt is made to skip a
file terminator.
@end enumerate
@end enumerate

@enumerate 5
@item
@format
procedure Put(File : in File_Type; Item : in Character);
procedure Put(Item : in Character);
@end format

@enumerate 6
@item
If the line length of the specified output file is bounded (that is,
does not have the conventional value zero), and the current column
number exceeds it, has the effect of calling New_Line with a spacing of
one. Then, or otherwise, outputs the given character to the file.
@end enumerate
@end enumerate

@enumerate 7
@item
@format
procedure Look_Ahead (File        : in  File_Type;
                      Item        : out Character;
                      End_Of_Line : out Boolean);

procedure Look_Ahead (Item        : out Character;
                      End_Of_Line : out Boolean);
@end format

@enumerate 8
@item
Mode_Error is propagated if the mode of the file is not In_File. Sets
End_Of_Line to True if at end of line, including if at end of page or at
end of file; in each of these cases the value of Item is not specified.
Otherwise End_Of_Line is set to False and Item is set to the the next
character (without consuming it) from the file.
@end enumerate
@end enumerate

@enumerate 9
@item
@format
procedure Get_Immediate(File : in  File_Type;
                        Item : out Character);

procedure Get_Immediate(Item : out Character);
@end format

@enumerate 10
@item
Reads the next character, either control or graphic, from the specified
File or the default input file. Mode_Error is propagated if the mode of
the file is not In_File. End_Error is propagated if at the end of the
file. The current column, line and page numbers for the file are not
affected.
@end enumerate
@end enumerate

@enumerate 11
@item
@format
procedure Get_Immediate(File      : in  File_Type;
                        Item      : out Character;
                        Available : out Boolean);

procedure Get_Immediate(Item      : out Character;
                        Available : out Boolean);
@end format

@enumerate 12
@item
If a character, either control or graphic, is available from the
specified File or the default input file, then the character is read;
Available is True and Item contains the value of this character. If a
character is not available, then Available is False and the value of
Item is not specified. Mode_Error is propagated if the mode of the file
is not In_File. End_Error is propagated if at the end of the file. The
current column, line and page numbers for the file are not affected.
@end enumerate
@end enumerate

@enumerate 13
@item
For an item of type String the following procedures are provided:

@item
@format
procedure Get(File : in File_Type; Item : out String);
procedure Get(Item : out String);
@end format

@enumerate 15
@item
Determines the length of the given string and attempts that number of
Get operations for successive characters of the string (in particular,
no operation is performed if the string is null).
@end enumerate
@end enumerate

@enumerate 16
@item
@format
procedure Put(File : in File_Type; Item : in String);
procedure Put(Item : in String);
@end format

@enumerate 17
@item
Determines the length of the given string and attempts that number of
Put operations for successive characters of the string (in particular,
no operation is performed if the string is null).
@end enumerate
@end enumerate

@enumerate 18
@item
@format
procedure Get_Line(File : in     File_Type;
                   Item :    out String;
                   Last :    out Natural);

procedure Get_Line(Item : out String; Last : out Natural);
@end format

@enumerate 19
@item
Reads successive characters from the specified input file and assigns
them to successive characters of the specified string. Reading stops if
the end of the string is met. Reading also stops if the end of the line
is met before meeting the end of the string; in this case Skip_Line is
(in effect) called with a spacing of 1. The values of characters not
assigned are not specified.

@item
If characters are read, returns in Last the index value such that
Item(Last) is the last character assigned (the index of the first
character assigned is Item'First). If no characters are read, returns in
Last an index value that is one less than Item'First. The exception
End_Error is propagated if an attempt is made to skip a file terminator.
@end enumerate
@end enumerate

@enumerate 21
@item
@format
procedure Put_Line(File : in File_Type; Item : in String);
procedure Put_Line(Item : in String);
@end format

@enumerate 22
@item
Calls the procedure Put for the given string, and then the procedure
New_Line with a spacing of one.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 23
@item
The Get_Immediate procedures should be implemented with unbuffered
input. For a device such as a keyboard, input should be ``available'' if
a key has already been typed, whereas for a disk file, input should
always be available except at end of file. For a file associated with a
keyboard-like device, any line-editing features of the underlying
operating system should be disabled during the execution of
Get_Immediate.

NOTES

@item
(26) Get_Immediate can be used to read a single key from the keyboard
``immediately''; that is, without waiting for an end of line. In a call
of Get_Immediate without the parameter Available, the caller will wait
until a character is available.

@item
(27) In a literal string parameter of Put, the enclosing string bracket
characters are not output. Each doubled string bracket character in the
enclosed string is output as a single string bracket character, as a
consequence of the rule for string literals, see @ref{2.6}.

@item
(28) A string read by Get or written by Put can extend over several
lines. An implementation is allowed to assume that certain external
files do not contain page terminators, in which case Get_Line and
Skip_Line can return as soon as a line terminator is read.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.8, A.10.9, A.10.7, A.10
@subsection Input-Output for Integer Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following procedures are defined in the generic packages Integer_IO
and Modular_IO, which have to be instantiated for the appropriate signed
integer or modular type respectively (indicated by Num in the
specifications).

@item
Values are output as decimal or based literals, without low line
characters or exponent, and, for Integer_IO, preceded by a minus sign if
negative. The format (which includes any leading spaces and minus sign)
can be specified by an optional field width parameter. Values of widths
of fields in output formats are of the nonnegative integer subtype
Field. Values of bases are of the integer subtype Number_Base.

@item
@example
subtype Number_Base is Integer range 2 .. 16;
@end example

@item
The default field width and base to be used by output procedures are
defined by the following variables that are declared in the generic
packages Integer_IO and Modular_IO:

@item
@example
Default_Width : Field := Num'Width;
Default_Base  : Number_Base := 10;
@end example

@item
The following procedures are provided:

@item
@format
procedure Get(File  : in     File_Type;
              Item  :    out Num;
              Width : in     Field := 0);

procedure Get(Item : out Num; Width : in Field := 0);
@end format

@enumerate 8
@item
If the value of the parameter Width is zero, skips any leading blanks,
line terminators, or page terminators, then reads a plus sign if present
or (for a signed type only) a minus sign if present, then reads the
longest possible sequence of characters matching the syntax of a numeric
literal without a point. If a nonzero value of Width is supplied, then
exactly Width characters are input, or the characters (possibly none) up
to a line terminator, whichever comes first; any skipped leading blanks
are included in the count.

@item
Returns, in the parameter Item, the value of type Num that corresponds
to the sequence input.

@item
10  The exception Data_Error is propagated if the sequence of characters
read does not form a legal integer literal or if the value obtained is
not of the subtype Num (for Integer_IO) or is not in the base range of
Num (for Modular_IO).
@end enumerate
@end enumerate

@enumerate 11
@item
@format
procedure Put(File  : in File_Type;
              Item  : in Num;
              Width : in Field := Default_Width;
              Base  : in Number_Base := Default_Base);

procedure Put(Item  : in Num;
              Width : in Field := Default_Width;
              Base  : in Number_Base := Default_Base);
@end format

@enumerate 12
@item
Outputs the value of the parameter Item as an integer literal, with no
low lines, no exponent, and no leading zeros (but a single zero for the
value zero), and a preceding minus sign for a negative value.

@item
If the resulting sequence of characters to be output has fewer than
Width characters, then leading spaces are first output to make up the
difference.

@item
Uses the syntax for decimal literal if the parameter Base has the value
ten (either explicitly or through Default_Base); otherwise, uses the
syntax for based literal, with any letters in upper case.
@end enumerate
@end enumerate

@enumerate 15
@item
@format
procedure Get(From : in     String;
              Item :    out Num;
              Last :    out Positive);
@end format

@enumerate 16
@item
Reads an integer value from the beginning of the given string, following
the same rules as the Get procedure that reads an integer value from a
file, but treating the end of the string as a file terminator. Returns,
in the parameter Item, the value of type Num that corresponds to the
sequence input. Returns in Last the index value such that From(Last) is
the last character read.

@item
The exception Data_Error is propagated if the sequence input does not
have the required syntax or if the value obtained is not of the subtype
Num.
@end enumerate
@end enumerate

@enumerate 18
@item
@format
procedure Put(To   :    out String;
              Item : in     Num;
              Base : in     Number_Base := Default_Base);
@end format

@enumerate 19
@item
Outputs the value of the parameter Item to the given string, following
the same rule as for output to a file, using the length of the given
string as the value for Width.
@end enumerate
@end enumerate

@enumerate 20
@item
Integer_Text_IO is a library package that is a nongeneric equivalent to
Text_IO.Integer_IO for the predefined type Integer:

@item
@example
with Ada.Text_IO;
package Ada.Integer_Text_IO is new Ada.Text_IO.Integer_IO(Integer);
@end example

@item
For each predefined signed integer type, a nongeneric equivalent to
Text_IO.Integer_IO is provided, with names such as
Ada.Long_Integer_Text_IO.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

NOTES

@item
(29) For Modular_IO, execution of Get propagates Data_Error if the
sequence of characters read forms an integer literal outside the range
0..Num'Last.

@need 1000
@sp 1
@center @emph{Examples}

@end enumerate
@enumerate 26
@item
@example
package Int_IO is new Integer_IO(Small_Int); use Int_IO;
-- default format used at instantiation,
-- Default_Width = 4, Default_Base = 10
@end example

@item
@example
Put(126);                            -- "b126"
Put(-126, 7);                        -- "bbb-126"
Put(126, Width => 13, Base => 2);    -- "bbb2#1111110#"
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.9, A.10.10, A.10.8, A.10
@subsection Input-Output for Real Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following procedures are defined in the generic packages Float_IO,
Fixed_IO, and Decimal_IO, which have to be instantiated for the
appropriate floating point, ordinary fixed point, or decimal fixed point
type respectively (indicated by Num in the specifications).

@item
Values are output as decimal literals without low line characters. The
format of each value output consists of a Fore field, a decimal point,
an Aft field, and (if a nonzero Exp parameter is supplied) the letter E
and an Exp field. The two possible formats thus correspond to:

@item
@example
Fore  .  Aft
@end example

@item
and to:

@item
@example
Fore  .  Aft  E  Exp
@end example

@item
without any spaces between these fields. The Fore field may include
leading spaces, and a minus sign for negative values. The Aft field
includes only decimal digits (possibly with trailing zeros). The Exp
field includes the sign (plus or minus) and the exponent (possibly with
leading zeros).

@item
For floating point types, the default lengths of these fields are
defined by the following variables that are declared in the generic
package Float_IO:

@item
@example
Default_Fore : Field := 2;
Default_Aft  : Field := Num'Digits-1;
Default_Exp  : Field := 3;
@end example

@item
For ordinary or decimal fixed point types, the default lengths of these
fields are defined by the following variables that are declared in the
generic packages Fixed_IO and Decimal_IO, respectively:

@item
@example
Default_Fore : Field := Num'Fore;
Default_Aft  : Field := Num'Aft;
Default_Exp  : Field := 0;
@end example

@item
The following procedures are provided:

@item
@format
procedure Get(File  : in     File_Type;
              Item  :    out Num;
              Width : in     Field := 0);

procedure Get(Item : out Num; Width : in Field := 0);
@end format

@enumerate 13
@item
If the value of the parameter Width is zero, skips any leading blanks,
line terminators, or page terminators, then reads the longest possible
sequence of characters matching the syntax of any of the following
(@pxref{2.4}):

@enumerate 14
@item
[+|-]numeric_literal

@item
[+|-]numeral.[exponent]

@item
[+|-].numeral[exponent]

@item
[+|-]base#based_numeral.#[exponent]

@item
[+|-]base#.based_numeral#[exponent]
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 19
@item
If a nonzero value of Width is supplied, then exactly Width characters
are input, or the characters (possibly none) up to a line terminator,
whichever comes first; any skipped leading blanks are included in the
count.

@item
Returns in the parameter Item the value of type Num that corresponds to
the sequence input, preserving the sign (positive if none has been
specified) of a zero value if Num is a floating point type and
Num'Signed_Zeros is True.

@item
The exception Data_Error is propagated if the sequence input does not
have the required syntax or if the value obtained is not of the subtype
Num.
@end enumerate
@end enumerate

@enumerate 22
@item
@format
procedure Put(File : in File_Type;
              Item : in Num;
              Fore : in Field := Default_Fore;
              Aft  : in Field := Default_Aft;
              Exp  : in Field := Default_Exp);

procedure Put(Item : in Num;
              Fore : in Field := Default_Fore;
              Aft  : in Field := Default_Aft;
              Exp  : in Field := Default_Exp);
@end format

@enumerate 23
@item
Outputs the value of the parameter Item as a decimal literal with the
format defined by Fore, Aft and Exp. If the value is negative, or if Num
is a floating point type where Num'Signed_Zeros is True and the value is
a negatively signed zero, then a minus sign is included in the integer
part. If Exp has the value zero, then the integer part to be output has
as many digits as are needed to represent the integer part of the value
of Item, overriding Fore if necessary, or consists of the digit zero if
the value of Item has no integer part.

@item
If Exp has a value greater than zero, then the integer part to be output
has a single digit, which is nonzero except for the value 0.0 of Item.

@item
In both cases, however, if the integer part to be output has fewer than
Fore characters, including any minus sign, then leading spaces are first
output to make up the difference. The number of digits of the fractional
part is given by Aft, or is one if Aft equals zero. The value is
rounded; a value of exactly one half in the last place is rounded away
from zero.

@item
If Exp has the value zero, there is no exponent part. If Exp has a value
greater than zero, then the exponent part to be output has as many
digits as are needed to represent the exponent part of the value of Item
(for which a single digit integer part is used), and includes an initial
sign (plus or minus). If the exponent part to be output has fewer than
Exp characters, including the sign, then leading zeros precede the
digits, to make up the difference. For the value 0.0 of Item, the
exponent has the value zero.
@end enumerate
@end enumerate

@enumerate 27
@item
@format
procedure Get(From : in String; Item : out Num; Last : out Positive);
@end format

@enumerate 28
@item
Reads a real value from the beginning of the given string, following the
same rule as the Get procedure that reads a real value from a file, but
treating the end of the string as a file terminator. Returns, in the
parameter Item, the value of type Num that corresponds to the sequence
input. Returns in Last the index value such that From(Last) is the last
character read.

@item
The exception Data_Error is propagated if the sequence input does not
have the required syntax, or if the value obtained is not of the subtype
Num.
@end enumerate
@end enumerate

@enumerate 30
@item
@format
procedure Put(To   : out String;
              Item : in Num;
              Aft  : in Field := Default_Aft;
              Exp  : in Field := Default_Exp);
@end format

@enumerate 31
@item
Outputs the value of the parameter Item to the given string, following
the same rule as for output to a file, using a value for Fore such that
the sequence of characters output exactly fills the string, including
any leading spaces.
@end enumerate
@end enumerate

@enumerate 32
@item
Float_Text_IO is a library package that is a nongeneric equivalent to
Text_IO.Float_IO for the predefined type Float:

@item
@example
with Ada.Text_IO;
package Ada.Float_Text_IO is new Ada.Text_IO.Float_IO(Float);
@end example

@item
For each predefined floating point type, a nongeneric equivalent to
Text_IO.Float_IO is provided, with names such as Ada.Long_Float_Text_IO.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may extend Get and Put for floating point types to
support special values such as infinities and NaNs.

@item
The implementation of Put need not produce an output value with greater
accuracy than is supported for the base subtype. The additional
accuracy, if any, of the value produced by Put when the number of
requested digits in the integer and fractional parts exceeds the
required accuracy is implementation defined.

@item
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

NOTES

@item
(30) For an item with a positive value, if output to a string exactly
fills the string without leading spaces, then output of the
corresponding negative value will propagate Layout_Error.

@item
(31) The rules for the Value attribute, see @ref{3.5}, and the rules for
Get are based on the same set of formats.

@need 1000
@sp 1
@center @emph{Examples}

@end enumerate
@enumerate 41
@item
@example
package Real_IO is new Float_IO(Real); use Real_IO;
-- default format used at instantiation, Default_Exp = 3
@end example

@item
@example
X : Real := -123.4567;  --  digits 8   (see @ref{3.5.7})
@end example

@item
@example
Put(X);  -- default format "-1.2345670E+02"
Put(X, Fore => 5, Aft => 3, Exp => 2);  -- "bbb-1.235E+2"
Put(X, 5, 3, 0);  -- "b-123.457"
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node A.10.10, A.11, A.10.9, A.10
@subsection Input-Output for Enumeration Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following procedures are defined in the generic package
Enumeration_IO, which has to be instantiated for the appropriate
enumeration type (indicated by Enum in the specification).

@item
Values are output using either upper or lower case letters for
identifiers. This is specified by the parameter Set, which is of the
enumeration type Type_Set.

@item
@example
type Type_Set is (Lower_Case, Upper_Case);
@end example

@item
The format (which includes any trailing spaces) can be specified by an
optional field width parameter. The default field width and letter case
are defined by the following variables that are declared in the generic
package Enumeration_IO:

@item
@example
Default_Width   : Field := 0;
Default_Setting : Type_Set := Upper_Case;
@end example

@item
The following procedures are provided:

@item
@format
procedure Get(File : in File_Type; Item : out Enum);
procedure Get(Item : out Enum);
@end format

@enumerate 8
@item
After skipping any leading blanks, line terminators, or page
terminators, reads an identifier according to the syntax of this lexical
element (lower and upper case being considered equivalent), or a
character literal according to the syntax of this lexical element
(including the apostrophes). Returns, in the parameter Item, the value
of type Enum that corresponds to the sequence input.

@item
The exception Data_Error is propagated if the sequence input does not
have the required syntax, or if the identifier or character literal does
not correspond to a value of the subtype Enum.
@end enumerate
@end enumerate

@enumerate 10
@item
@format
procedure Put(File  : in File_Type;
              Item  : in Enum;
              Width : in Field := Default_Width;
              Set   : in Type_Set := Default_Setting);

procedure Put(Item  : in Enum;
              Width : in Field := Default_Width;
              Set   : in Type_Set := Default_Setting);
@end format

@enumerate 11
@item
Outputs the value of the parameter Item as an enumeration literal
(either an identifier or a character literal). The optional parameter
Set indicates whether lower case or upper case is used for identifiers;
it has no effect for character literals. If the sequence of characters
produced has fewer than Width characters, then trailing spaces are
finally output to make up the difference. If Enum is a character type,
the sequence of characters produced is as for Enum'Image(Item), as
modified by the Width and Set parameters.
@end enumerate
@end enumerate

@enumerate 12
@item
@format
procedure Get(From : in     String;
              Item :    out Enum;
              Last :    out Positive);
@end format

@enumerate 13
@item
Reads an enumeration value from the beginning of the given string,
following the same rule as the Get procedure that reads an enumeration
value from a file, but treating the end of the string as a file
terminator. Returns, in the parameter Item, the value of type Enum that
corresponds to the sequence input. Returns in Last the index value such
that From(Last) is the last character read.

@item
The exception Data_Error is propagated if the sequence input does not
have the required syntax, or if the identifier or character literal does
not correspond to a value of the subtype Enum.
@end enumerate
@end enumerate

@enumerate 15
@item
@format
procedure Put(To   : out String;
              Item : in Enum;
              Set  : in Type_Set := Default_Setting);
@end format

@enumerate 16
@item
Outputs the value of the parameter Item to the given string, following
the same rule as for output to a file, using the length of the given
string as the value for Width.
@end enumerate
@end enumerate

@enumerate 17
@item
Although the specification of the generic package Enumeration_IO would
allow instantiation for an float type, this is not the intended purpose
of this generic package, and the effect of such instantiations is not
defined by the language.

NOTES

@item
(32) There is a difference between Put defined for characters, and for
enumeration values. Thus

@item
@example
Ada.Text_IO.Put('A');  --  outputs the character A
@end example

@item
@example
package Char_IO is new Ada.Text_IO.Enumeration_IO(Character);
Char_IO.Put('A');  -- outputs the character 'A', between apostrophes
@end example

@item
(33) The type Boolean is an enumeration type, hence Enumeration_IO can
be instantiated for this type.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.11, A.12, A.10.10, A
@section Wide Text Input-Output

@enumerate
@item
The package Wide_Text_IO provides facilities for input and output in
human-readable form. Each file is read or written sequentially, as a
sequence of wide characters grouped into lines, and as a sequence of
lines grouped into pages.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The specification of package Wide_Text_IO is the same as that for
Text_IO, except that in each Get, Look_Ahead, Get_Immediate, Get_Line,
Put, and Put_Line procedure, any occurrence of Character is replaced by
Wide_Character, and any occurrence of String is replaced by Wide_String.

@item
Nongeneric equivalents of Wide_Text_IO.Integer_IO and
Wide_Text_IO.Float_IO are provided (as for Text_IO) for each predefined
numeric type, with names such as Ada.Integer_Wide_Text_IO,
Ada.Long_Integer_Wide_Text_IO, Ada.Float_Wide_Text_IO,
Ada.Long_Float_Wide_Text_IO.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.12, A.12.1, A.11, A
@section Stream Input-Output

@enumerate
@item
The packages Streams.Stream_IO, Text_IO.Text_Streams, and
Wide_Text_IO.Text_Streams provide stream-oriented operations on files.
@end enumerate

@menu
* A.12.1:: The Package Streams.Stream_IO
* A.12.2:: The Package Text_IO.Text_Streams
* A.12.3:: The Package Wide_Text_IO.Text_Streams
@end menu

@c ---------------------------------------------------------------------------
@node A.12.1, A.12.2, A.12, A.12
@subsection The Package Streams.Stream_IO

@enumerate
@item
The subprograms in the child package Streams.Stream_IO provide control
over stream files. Access to a stream file is either sequential, via a
call on Read or Write to transfer an array of stream elements, or
positional (if supported by the implementation for the given file), by
specifying a relative index for an element. Since a stream file can be
converted to a Stream_Access value, calling stream-oriented attribute
subprograms of different element types with the same Stream_Access value
provides heterogeneous input-output. @xref{13.13}, for a general
discussion of streams.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Streams.Stream_IO has the following declaration:

@item
@example
with Ada.IO_Exceptions;
package Ada.Streams.Stream_IO is
@end example

@item
@example
    type Stream_Access is access all Root_Stream_Type'Class;
@end example

@item
@example
    type File_Type is limited private;
@end example

@item
@example
    type File_Mode is (In_File, Out_File, Append_File);
@end example

@item
@example
    type    Count          is range 0 .. implementation-defined;
    subtype Positive_Count is Count range 1 .. Count'Last;
      -- Index into file, in stream elements.
@end example

@item
@example
    procedure Create (File : in out File_Type;
                      Mode : in File_Mode := Out_File;
                      Name : in String    := "";
                      Form : in String    := "");
@end example

@item
@example
    procedure Open (File : in out File_Type;
                    Mode : in File_Mode;
                    Name : in String;
                    Form : in String := "");
@end example

@item
@example
    procedure Close  (File : in out File_Type);
    procedure Delete (File : in out File_Type);
    procedure Reset  (File : in out File_Type; Mode : in File_Mode);
    procedure Reset  (File : in out File_Type);
@end example

@item
@example
    function Mode (File : in File_Type) return File_Mode;
    function Name (File : in File_Type) return String;
    function Form (File : in File_Type) return String;
@end example

@item
@example
    function Is_Open     (File : in File_Type) return Boolean;
    function End_Of_File (File : in File_Type) return Boolean;
@end example

@item
@example
    function Stream (File : in File_Type) return Stream_Access;
    -- Return stream access for use with T'Input and T'Output
@end example

@end enumerate
@enumerate 15
@item
@example
    -- Read array of stream elements from file
    procedure Read (File : in  File_Type;
                    Item : out Stream_Element_Array;
                    Last : out Stream_Element_Offset;
                    From : in  Positive_Count);
@end example

@item
@example
    procedure Read (File : in  File_Type;
                    Item : out Stream_Element_Array;
                    Last : out Stream_Element_Offset);
@end example

@end enumerate
@enumerate 18
@item
@example
    -- Write array of stream elements into file
    procedure Write (File : in File_Type;
                     Item : in Stream_Element_Array;
                     To   : in Positive_Count);
@end example

@item
@example
    procedure Write (File : in File_Type;
                     Item : in Stream_Element_Array);
@end example

@end enumerate
@enumerate 21
@item
@example
    -- Operations on position within file
@end example

@item
@example
    procedure Set_Index(File : in File_Type;
                        To   : in Positive_Count);
@end example

@item
@example
    function Index(File : in File_Type) return Positive_Count;
    function Size (File : in File_Type) return Count;
@end example

@item
@example
    procedure Set_Mode(File : in out File_Type;
                       Mode : in     File_Mode);
@end example

@item
@example
    procedure Flush(File : in out File_Type);
@end example

@item
@example
    -- exceptions
    Status_Error : exception renames IO_Exceptions.Status_Error;
    Mode_Error   : exception renames IO_Exceptions.Mode_Error;
    Name_Error   : exception renames IO_Exceptions.Name_Error;
    Use_Error    : exception renames IO_Exceptions.Use_Error;
    Device_Error : exception renames IO_Exceptions.Device_Error;
    End_Error    : exception renames IO_Exceptions.End_Error;
    Data_Error   : exception renames IO_Exceptions.Data_Error;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Streams.Stream_IO;
@end example

@item
The subprograms Create, Open, Close, Delete, Reset, Mode, Name, Form,
Is_Open, and End_of_File have the same effect as the corresponding
subprograms in Sequential_IO, see @ref{A.8.2}.

@item
The Stream function returns a Stream_Access result from a File_Type
object, thus allowing the stream-oriented attributes Read, Write, Input,
and Output to be used on the same file for multiple types.

@item
The procedures Read and Write are equivalent to the corresponding
operations in the package Streams. Read propagates Mode_Error if the
mode of File is not In_File. Write propagates Mode_Error if the mode of
File is not Out_File or Append_File. The Read procedure with a
Positive_Count parameter starts reading at the specified index. The
Write procedure with a Positive_Count parameter starts writing at the
specified index.

@item
The Index function returns the current file index, as a count (in stream
elements) from the beginning of the file. The position of the first
element in the file is 1.

@item
The Set_Index procedure sets the current index to the specified value.

@item
If positioning is not supported for the given file, then a call of Index
or Set_Index propagates Use_Error. Similarly, a call of Read or Write
with a Positive_Count parameter propagates Use_Error.

@item
The Size function returns the current size of the file, in stream
elements.

@item
The Set_Mode procedure changes the mode of the file. If the new mode is
Append_File, the file is positioned to its end; otherwise, the position
in the file is unchanged.

@item
The Flush procedure synchronizes the external file with the internal
file (by flushing any internal buffers) without closing the file or
changing the position. Mode_Error is propagated if the mode of the file
is In_File.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.12.2, A.12.3, A.12.1, A.12
@subsection The Package Text_IO.Text_Streams

@enumerate
@item
The package Text_IO.Text_Streams provides a function for treating a text
file as a stream.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Text_IO.Text_Streams has the following declaration:

@item
@example
with Ada.Streams;
package Ada.Text_IO.Text_Streams is
   type Stream_Access is access all Streams.Root_Stream_Type'Class;
@end example

@item
@example
   function Stream (File : in File_Type) return Stream_Access;
end Ada.Text_IO.Text_Streams;
@end example

@item
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.

NOTES

@item
(34) The ability to obtain a stream for a text file allows
Current_Input, Current_Output, and Current_Error to be processed with
the functionality of streams, including the mixing of text and binary
input-output, and the mixing of binary input-output for different types.

@item
(35) Performing operations on the stream associated with a text file
does not affect the column, line, or page counts.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.12.3, A.13, A.12.2, A.12
@subsection The Package Wide_Text_IO.Text_Streams

@enumerate
@item
The package Wide_Text_IO.Text_Streams provides a function for treating a
wide text file as a stream.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Wide_Text_IO.Text_Streams has the following
declaration:

@item
@example
with Ada.Streams;
package Ada.Wide_Text_IO.Text_Streams is
   type Stream_Access is access all Streams.Root_Stream_Type'Class;
@end example

@item
@example
   function Stream (File : in File_Type) return Stream_Access;
end Ada.Wide_Text_IO.Text_Streams;
@end example

@item
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.13, A.14, A.12.3, A
@section Exceptions in Input-Output

@enumerate
@item
The package IO_Exceptions defines the exceptions needed by the
predefined input-output packages.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package IO_Exceptions has the following declaration:

@item
@example
package Ada.IO_Exceptions is
   pragma Pure(IO_Exceptions);
@end example

@item
@example
   Status_Error : exception;
   Mode_Error   : exception;
   Name_Error   : exception;
   Use_Error    : exception;
   Device_Error : exception;
   End_Error    : exception;
   Data_Error   : exception;
   Layout_Error : exception;
@end example

@item
@example
end Ada.IO_Exceptions;
@end example

@item
If more than one error condition exists, the corresponding exception
that appears earliest in the following list is the one that is
propagated.

@item
The exception Status_Error is propagated by an attempt to operate upon a
file that is not open, and by an attempt to open a file that is already
open.

@item
The exception Mode_Error is propagated by an attempt to read from, or
test for the end of, a file whose current mode is Out_File or
Append_File, and also by an attempt to write to a file whose current
mode is In_File. In the case of Text_IO, the exception Mode_Error is
also propagated by specifying a file whose current mode is Out_File or
Append_File in a call of Set_Input, Skip_Line, End_Of_Line, Skip_Page,
or End_Of_Page; and by specifying a file whose current mode is In_File
in a call of Set_Output, Set_Line_Length, Set_Page_Length, Line_Length,
Page_Length, New_Line, or New_Page.

@item
The exception Name_Error is propagated by a call of Create or Open if
the string given for the parameter Name does not allow the
identification of an external file. For example, this exception is
propagated if the string is improper, or, alternatively, if either none
or more than one external file corresponds to the string.

@item
The exception Use_Error is propagated if an operation is attempted that
is not possible for reasons that depend on characteristics of the
external file. For example, this exception is propagated by the
procedure Create, among other circumstances, if the given mode is
Out_File but the form specifies an input only device, if the parameter
Form specifies invalid access rights, or if an external file with the
given name already exists and overwriting is not allowed.

@item
The exception Device_Error is propagated if an input-output operation
cannot be completed because of a malfunction of the underlying system.

@item
The exception End_Error is propagated by an attempt to skip (read past)
the end of a file.

@item
The exception Data_Error can be propagated by the procedure Read (or by
the Read attribute) if the element read cannot be interpreted as a value
of the required subtype. This exception is also propagated by a
procedure Get (defined in the package Text_IO) if the input character
sequence fails to satisfy the required syntax, or if the value input
does not belong to the range of the required subtype.

@item
The exception Layout_Error is propagated (in text input-output) by Col,
Line, or Page if the value returned exceeds Count'Last. The exception
Layout_Error is also propagated on output by an attempt to set column or
line numbers in excess of specified maximum line or page lengths,
respectively (excluding the unbounded cases). It is also propagated by
an attempt to Put too many characters to a string.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the conditions under which Name_Error,
Use_Error and Device_Error are propagated.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
If the associated check is too complex, an implementation need not
propagate Data_Error as part of a procedure Read (or the Read attribute)
if the value read cannot be interpreted as a value of the required
subtype.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If the element read by the procedure Read (or by the Read attribute)
cannot be interpreted as a value of the required subtype, but this is
not detected and Data_Error is not propagated, then the resulting value
can be abnormal, and subsequent references to the value can lead to
erroneous execution, as explained in @ref{13.9.1}.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.14, A.15, A.13, A
@section File Sharing

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate
@item
It is not specified by the language whether the same external file can
be associated with more than one file object. If such sharing is
supported by the implementation, the following effects are defined:

@enumerate 2
@item
Operations on one text file object do not affect the column, line, and
page numbers of any other file object.

@item
Standard_Input and Standard_Output are associated with distinct external
files, so operations on one of these files cannot affect operations on
the other file. In particular, reading from Standard_Input does not
affect the current page, line, and column numbers for Standard_Output,
nor does writing to Standard_Output affect the current page, line, and
column numbers for Standard_Input.

@item
For direct and stream files, the current index is a property of each
file object; an operation on one file object does not affect the current
index of any other file object.

@item
For direct and stream files, the current size of the file is a property
of the external file.
@end enumerate
@end enumerate

@enumerate 6
All other effects are identical.
@end enumerate

@c ---------------------------------------------------------------------------
@node A.15, B, A.14, A
@section The Package Command_Line

@enumerate
@item
The package Command_Line allows a program to obtain the values of its
arguments and to set the exit status code to be returned on normal
termination.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Ada.Command_Line has the following declaration:

@item
@example
package Ada.Command_Line is
  pragma Preelaborate(Command_Line);
@end example

@item
@example
  function Argument_Count return Natural;
@end example

@item
@example
  function Argument (Number : in Positive) return String;
@end example

@item
@example
  function Command_Name return String;
@end example

@item
@example
  type Exit_Status is implementation-defined integer type;
@end example

@item
@example
  Success : constant Exit_Status;
  Failure : constant Exit_Status;
@end example

@item
@example
  procedure Set_Exit_Status (Code : in Exit_Status);
@end example

@item
@example
private
  ... -- not specified by the language
end Ada.Command_Line;
@end example

@item
@format
function Argument_Count return Natural;
@end format

@enumerate 12
@item
If the external execution environment supports passing arguments to a
program, then Argument_Count returns the number of arguments passed to
the program invoking the function. Otherwise it returns 0. The meaning
of ``number of arguments'' is implementation defined.
@end enumerate
@end enumerate

@enumerate 13
@item
@format
function Argument (Number : in Positive) return String;
@end format

@enumerate 14
@item
If the external execution environment supports passing arguments to a
program, then Argument returns an implementation-defined value
corresponding to the argument at relative position Number. If Number is
outside the range 1..Argument_Count, then Constraint_Error is
propagated.
@end enumerate
@end enumerate

@enumerate 15
@item
@format
function Command_Name return String;
@end format

@enumerate 16
@item
If the external execution environment supports passing arguments to a
program, then Command_Name returns an implementation-defined value
corresponding to the name of the command invoking the program; otherwise
Command_Name returns the null string.

@item
The type Exit_Status represents the range of exit status values
supported by the external execution environment. The constants Success
and Failure correspond to success and failure, respectively.
@end enumerate
@end enumerate

@enumerate 18
@item
@format
procedure Set_Exit_Status (Code : in Exit_Status);
@end format

@enumerate 19
@item
If the external execution environment supports returning an exit status
from a program, then Set_Exit_Status sets Code as the status. Normal
termination of a program returns as the exit status the value most
recently set by Set_Exit_Status, or, if no such value has been set, then
the value Success. If a program terminates abnormally, the status set by
Set_Exit_Status is ignored, and an implementation-defined exit status
value is set.

@item
If the external execution environment does not support returning an exit
value from a program, then Set_Exit_Status does nothing.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 21
@item
An alternative declaration is allowed for package Command_Line if
different functionality is appropriate for the external execution
environment.

NOTES

@item
(36) Argument_Count, Argument, and Command_Name correspond to the C
language's argc, argv[n] (for n>0) and argv[0], respectively.
@end enumerate

@c ===========================================================================
@node B, B.1, A.15, Top
@appendix  Interface to Other Languages (normative)

@enumerate
@item
This Annex describes features for writing mixed-language programs.
General interface support is presented first; then specific support for
C, COBOL, and Fortran is defined, in terms of language interface
packages for each of these languages.
@end enumerate

@menu
* B.1:: Interfacing Pragmas
* B.2:: The Package Interfaces
* B.3:: Interfacing with C
* B.4:: Interfacing with COBOL
* B.5:: Interfacing with Fortran

 --- The Detailed Node Listing ---

* B.1::   Interfacing Pragmas
* B.2::   The Package Interfaces
* B.3::   Interfacing with C
* B.3.1:: The Package Interfaces.C.Strings
* B.3.2:: The Generic Package Interfaces.C.Pointers
* B.4::   Interfacing with COBOL
* B.5::   Interfacing with Fortran
@end menu

@c ---------------------------------------------------------------------------
@node B.1, B.2, B, B
@section Interfacing Pragmas

@enumerate
@item
A pragma Import is used to import an entity defined in a foreign
language into an Ada program, thus allowing a foreign-language
subprogram to be called from Ada, or a foreign-language variable to be
accessed from Ada. In contrast, a pragma Export is used to export an Ada
entity to a foreign language, thus allowing an Ada subprogram to be
called from a foreign language, or an Ada object to be accessed from a
foreign language. The pragmas Import and Export are intended primarily
for objects and subprograms, although implementations are allowed to
support other entities.

@item
A pragma Convention is used to specify that an Ada entity should use the
conventions of another language. It is intended primarily for types and
``callback'' subprograms. For example, ``pragma Convention(Fortran,
Matrix);'' implies that Matrix should be represented according to the
conventions of the supported Fortran implementation, namely column-major
order.

@item
A pragma Linker_Options is used to specify the system linker parameters
needed when a given compilation unit is included in a partition.

@need 1000
@sp 1
@center @emph{Syntax}

@item
An interfacing pragma is a representation pragma that is one of the
pragmas Import, Export, or Convention. Their forms, together with that
of the related pragma Linker_Options, are as follows:

@item
@example
pragma Import
  ([Convention =>] convention_identifier,
   [Entity =>] local_name [,
   [External_Name =>] string_expression] [,
   [Link_Name =>] string_expression]);
@end example

@item
@example
pragma Export
  ([Convention =>] convention_identifier,
   [Entity =>] local_name [,
   [External_Name =>] string_expression] [,
   [Link_Name =>] string_expression]);
@end example

@item
@example
pragma Convention
  ([Convention =>] convention_identifier,
  [Entity =>] local_name);
@end example

@item
@example
pragma Linker_Options(string_expression);
@end example

@enumerate 9
@item
A pragma Linker_Options is allowed only at the place of a
declarative_item.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@enumerate 10
@item
The expected type for a string_expression in an interfacing pragma or in
pragma Linker_Options is String.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The convention_identifier of an interfacing pragma shall be the name of
a convention. The convention names are implementation defined, except
for certain language-defined ones, such as Ada and Intrinsic, as
explained in @ref{6.3.1, ``Conformance Rules''}. Additional convention
names generally represent the calling conventions of foreign languages,
language implementations, or specific run-time models. The convention of
a callable entity is its calling convention.

@item
If L is a convention_identifier for a language, then a type T is said to
be compatible with convention L, (alternatively, is said to be an
L-compatible type) if any of the following conditions are met:

@enumerate 13
@item
T is declared in a language interface package corresponding to L and is
defined to be L-compatible, see @ref{B.3}, @ref{B.3.1}, @ref{B.3.2},
@ref{B.4} and @ref{B.5}

@item
Convention L has been specified for T in a pragma Convention, and T is
eligible for convention L; that is:

@enumerate 15
@item
T is an array type with either an unconstrained or
statically-constrained first subtype, and its component type is
L-compatible,

@item
T is a record type that has no discriminants and that only has
components with statically-constrained subtypes, and each component type
is L-compatible,

@item
T is an access-to-object type, and its designated type is L-compatible,

@item
T is an access-to-subprogram type, and its designated profile's
parameter and result types are all L-compatible.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 19
@item
T is derived from an L-compatible type,

@item
The implementation permits T as an L-compatible type.
@end enumerate
@end enumerate

@enumerate 21
@item
If pragma Convention applies to a type, then the type shall either be
compatible with or eligible for the convention specified in the pragma.

@item
A pragma Import shall be the completion of a declaration.
Notwithstanding any rule to the contrary, a pragma Import may serve as
the completion of any kind of (explicit) declaration if supported by an
implementation for that kind of declaration. If a completion is a pragma
Import, then it shall appear in the same declarative_part,
package_specification, task_definition or protected_definition as the
declaration. For a library unit, it shall appear in the same
compilation, before any subsequent compilation_units other than pragmas.
If the local_name denotes more than one entity, then the pragma Import
is the completion of all of them.

@item
An entity specified as the Entity argument to a pragma Import (or pragma
Export) is said to be imported (respectively, exported).

@item
The declaration of an imported object shall not include an explicit
initialization expression. Default initializations are not performed.

@item
The type of an imported or exported object shall be compatible with the
convention specified in the corresponding pragma.

@item
For an imported or exported subprogram, the result and parameter types
shall each be compatible with the convention specified in the
corresponding pragma.

@item
The external name and link name string_expressions of a pragma Import or
Export, and the string_expression of a pragma Linker_Options, shall be
static.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Import, Export, and Convention pragmas are representation pragmas that
specify the convention aspect of representation. In addition, Import and
Export pragmas specify the imported and exported aspects of
representation, respectively.

@item
An interfacing pragma is a program unit pragma when applied to a program
unit, see @ref{10.1.5}.

@item
An interfacing pragma defines the convention of the entity denoted by
the local_name. The convention represents the calling convention or
representation convention of the entity. For an access-to-subprogram
type, it represents the calling convention of designated subprograms. In
addition:

@enumerate 31
@item
A pragma Import specifies that the entity is defined externally (that
is, outside the Ada program).

@item
A pragma Export specifies that the entity is used externally.

@item
A pragma Import or Export optionally specifies an entity's external
name, link name, or both.
@end enumerate
@end enumerate

@enumerate 34
@item
An external name is a string value for the name used by a foreign
language program either for an entity that an Ada program imports, or
for referring to an entity that an Ada program exports.

@item
A link name is a string value for the name of an exported or imported
entity, based on the conventions of the foreign language's compiler in
interfacing with the system's linker tool.

@item
The meaning of link names is implementation defined. If neither a link
name nor the Address attribute of an imported or exported entity is
specified, then a link name is chosen in an implementation-defined
manner, based on the external name if one is specified.

@item
Pragma Linker_Options has the effect of passing its string argument as a
parameter to the system linker (if one exists), if the immediately
enclosing compilation unit is included in the partition being linked.
The interpretation of the string argument, and the way in which the
string arguments from multiple Linker_Options pragmas are combined, is
implementation defined.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Notwithstanding what this International Standard says elsewhere, the
elaboration of a declaration denoted by the local_name of a pragma
Import does not create the entity. Such an elaboration has no other
effect than to allow the defining name to denote the external entity.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If an implementation supports pragma Export to a given language, then it
should also allow the main subprogram to be written in that language. It
should support some mechanism for invoking the elaboration of the Ada
library units included in the system, and for invoking the finalization
of the environment task. On typical systems, the recommended mechanism
is to provide two subprograms whose link names are "adainit" and
"adafinal". Adainit should contain the elaboration code for library
units. Adafinal should contain the finalization code. These subprograms
should have no effect the second and subsequent time they are called.

@item
Automatic elaboration of preelaborated packages should be provided when
pragma Export is supported.

@item
For each supported convention L other than Intrinsic, an implementation
should support Import and Export pragmas for objects of L-compatible
types and for subprograms, and pragma Convention for L-eligible types
and for subprograms, presuming the other language has corresponding
features. Pragma Convention need not be supported for scalar types.

NOTES

@item
(1) Implementations may place restrictions on interfacing pragmas; for
example, requiring each exported entity to be declared at the library
level.

@item
(2) A pragma Import specifies the conventions for accessing external
entities. It is possible that the actual entity is written in assembly
language, but reflects the conventions of a particular language. For
example, pragma Import(Ada, ...) can be used to interface to an assembly
language routine that obeys the Ada compiler's calling conventions.

@item
(3) To obtain ``call-back'' to an Ada subprogram from a foreign language
environment, pragma Convention should be specified both for the
access-to-subprogram type and the specific subprogram(s) to which
'Access is applied.

@item
(4) It is illegal to specify more than one of Import, Export, or
Convention for a given entity.

@item
(5) The local_name in an interfacing pragma can denote more than one
entity in the case of overloading. Such a pragma applies to all of the
denoted entities.

@item
(6) Also  @ref{13.8, ``Machine Code Insertions''}.

@item
(7) If both External_Name and Link_Name are specified for an Import or
Export pragma, then the External_Name is ignored.

@item
(8) An interfacing pragma might result in an effect that violates Ada
semantics.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of interfacing pragmas:

@item
@example
package Fortran_Library is
  function Sqrt (X : Float) return Float;
  function Exp  (X : Float) return Float;
private
  pragma Import(Fortran, Sqrt);
  pragma Import(Fortran, Exp);
end Fortran_Library;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node B.2, B.3, B.1, B
@section The Package Interfaces

@enumerate
@item
Package Interfaces is the parent of several library packages that
declare types and other entities useful for interfacing to foreign
languages. It also contains some implementation-defined types that are
useful across more than one language (in particular for interfacing to
assembly language).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Interfaces has the following skeletal declaration:

@item
@example
package Interfaces is
   pragma Pure(Interfaces);
@end example

@item
@example
   type Integer_n is range -2**(n-1) .. 2**(n-1) - 1;
   -- 2's complement
@end example

@item
@example
   type Unsigned_n is mod 2**n;
@end example

@item
@example
   function Shift_Left  (Value  : Unsigned_n;
                         Amount : Natural) return Unsigned_n;
   function Shift_Right (Value  : Unsigned_n;
                         Amount : Natural) return Unsigned_n;
   function Shift_Right_Arithmetic (Value  : Unsigned_n;
                                    Amount : Natural)
     return Unsigned_n;
   function Rotate_Left  (Value  : Unsigned_n;
                          Amount : Natural) return Unsigned_n;
   function Rotate_Right (Value  : Unsigned_n;
                          Amount : Natural) return Unsigned_n;
   ...
end Interfaces;
@end example

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
An implementation shall provide the following declarations in the
visible part of package Interfaces:

@enumerate 8
@item
Signed and modular integer types of n bits, if supported by the target
architecture, for each n that is at least the size of a storage element
and that is a factor of the word size. The names of these types are of
the form Integer_n for the signed types, and Unsigned_n for the modular
types;

@item
For each such modular type in Interfaces, shifting and rotating
subprograms as specified in the declaration of Interfaces above. These
subprograms are Intrinsic. They operate on a bit-by-bit basis, using the
binary representation of the value of the operands to yield a binary
representation for the result. The Amount parameter gives the number of
bits by which to shift or rotate. For shifting, zero bits are shifted
in, except in the case of Shift_Right_Arithmetic, where one bits are
shifted in if Value is at least half the modulus.

@item
Floating point types corresponding to each floating point format fully
supported by the hardware.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 11
@item
An implementation may provide implementation-defined library units that
are children of Interfaces, and may add declarations to the visible part
of Interfaces in addition to the ones defined above.

@item Implementation Advice

@item
For each implementation-defined convention identifier, there should be a
child package of package Interfaces with the corresponding name. This
package should contain any declarations that would be useful for
interfacing to the language (implementation) represented by the
convention. Any declarations useful for interfacing to any language on
the given hardware architecture should be provided directly in
Interfaces.

@item
An implementation supporting an interface to C, COBOL, or Fortran should
provide the corresponding package or packages described in the following
clauses.
@end enumerate

@c ---------------------------------------------------------------------------
@node B.3, B.3.1, B.2, B
@section Interfacing with C

@enumerate
@item
The facilities relevant to interfacing with the C language are the
package Interfaces.C and its children; and support for the Import,
Export, and Convention pragmas with convention_identifier C.

@item
The package Interfaces.C contains the basic types, constants and
subprograms that allow an Ada program to pass scalars and strings to C
functions.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Interfaces.C has the following declaration:

@item
@example
package Interfaces.C is
   pragma Pure(C);
@end example

@item
@example
   -- Declarations based on C's <limits.h>
@end example

@item
@example
   CHAR_BIT  : constant := implementation-defined; -- typically 8
   SCHAR_MIN : constant := implementation-defined; -- typically -128
   SCHAR_MAX : constant := implementation-defined; -- typically 127
   UCHAR_MAX : constant := implementation-defined; -- typically 255
@end example

@item
@example
   -- Signed and Unsigned Integers
   type int   is range implementation-defined;
   type short is range implementation-defined;
   type long  is range implementation-defined;
@end example

@item
@example
   type signed_char is range SCHAR_MIN .. SCHAR_MAX;
   for signed_char'Size use CHAR_BIT;
@end example

@item
@example
   type unsigned       is mod implementation-defined;
   type unsigned_short is mod implementation-defined;
   type unsigned_long  is mod implementation-defined;
@end example

@item
@example
   type unsigned_char is mod (UCHAR_MAX+1);
   for unsigned_char'Size use CHAR_BIT;
@end example

@item
@example
   subtype plain_char is implementation-defined;
@end example

@item
@example
   type ptrdiff_t is range implementation-defined;
@end example

@item
@example
   type size_t is mod implementation-defined;
@end example

@item
@example
   -- Floating Point
@end example

@item
@example
   type C_float     is digits implementation-defined;
@end example

@item
@example
   type double      is digits implementation-defined;
@end example

@item
@example
   type long_double is digits implementation-defined;
@end example

@item
@example
   -- Characters and Strings
@end example

@item
@example
   type char is <implementation-defined character type>;
@end example

@item
@example
   nul : constant char := char'First;
@end example

@item
@example
   function To_C   (Item : in Character) return char;
@end example

@item
@example
   function To_Ada (Item : in char) return Character;
@end example

@item
@example
   type char_array is array (size_t range <>) of aliased char;
   pragma Pack(char_array);
   for char_array'Component_Size use CHAR_BIT;
@end example

@item
@example
   function Is_Nul_Terminated (Item : in char_array) return Boolean;
@end example

@item
@example
   function To_C   (Item       : in String;
                    Append_Nul : in Boolean := True)
      return char_array;
@end example

@item
@example
   function To_Ada (Item     : in char_array;
                    Trim_Nul : in Boolean := True)
      return String;
@end example

@item
@example
   procedure To_C (Item       : in String;
                   Target     : out char_array;
                   Count      : out size_t;
                   Append_Nul : in Boolean := True);
@end example

@item
@example
   procedure To_Ada (Item     : in char_array;
                     Target   : out String;
                     Count    : out Natural;
                     Trim_Nul : in Boolean := True);
@end example

@item
@example
   -- Wide Character and Wide String
@end example

@item
@example
   type wchar_t is implementation-defined;
@end example

@item
@example
   wide_nul : constant wchar_t := wchar_t'First;
@end example

@item
@example
   function To_C   (Item : in Wide_Character) return wchar_t;
   function To_Ada (Item : in wchar_t       ) return Wide_Character;
@end example

@item
@example
   type wchar_array is array (size_t range <>) of aliased wchar_t;
@end example

@item
@example
   pragma Pack(wchar_array);
@end example

@item
@example
   function Is_Nul_Terminated (Item : in wchar_array)
     return Boolean;
@end example

@item
@example
   function To_C   (Item       : in Wide_String;
                    Append_Nul : in Boolean := True)
      return wchar_array;
@end example

@item
@example
   function To_Ada (Item     : in wchar_array;
                    Trim_Nul : in Boolean := True)
      return Wide_String;
@end example

@item
@example
   procedure To_C (Item       : in  Wide_String;
                   Target     : out wchar_array;
                   Count      : out size_t;
                   Append_Nul : in  Boolean := True);
@end example

@item
@example
   procedure To_Ada (Item     : in  wchar_array;
                     Target   : out Wide_String;
                     Count    : out Natural;
                     Trim_Nul : in  Boolean := True);
@end example

@item
@example
   Terminator_Error : exception;
@end example

@item
@example
end Interfaces.C;
@end example

@item
Each of the types declared in Interfaces.C is C-compatible.

@item
The types int, short, long, unsigned, ptrdiff_t, size_t, double, char,
and wchar_t correspond respectively to the C types having the same
names. The types signed_char, unsigned_short, unsigned_long,
unsigned_char, C_float, and long_double correspond respectively to the C
types signed char, unsigned short, unsigned long, unsigned char, float,
and long double.

@item
The type of the subtype plain_char is either signed_char or
unsigned_char, depending on the C implementation.

@item
@format
function To_C   (Item : in Character) return char;
function To_Ada (Item : in char     ) return Character;
@end format

@enumerate 46
@item
The functions To_C and To_Ada map between the Ada type Character and the
C type char.
@end enumerate
@end enumerate

@enumerate 47
@item
@format
function Is_Nul_Terminated (Item : in char_array) return Boolean;
@end format

@enumerate 48
@item
The result of Is_Nul_Terminated is True if Item contains nul, and is
False otherwise.
@end enumerate
@end enumerate

@enumerate 49
@item
@format
function To_C (Item       : in String;
               Append_Nul : in Boolean := True)
  return char_array;

function To_Ada (Item     : in char_array;
                 Trim_Nul : in Boolean := True)
  return String;
@end format

@enumerate 50
@item
The result of To_C is a char_array value of length Item'Length (if
Append_Nul is False) or Item'Length+1 (if Append_Nul is True). The lower
bound is 0. For each component Item(I), the corresponding component in
the result is To_C applied to Item(I). The value nul is appended if
Append_Nul is True.

@item
The result of To_Ada is a String whose length is Item'Length (if
Trim_Nul is False) or the length of the slice of Item preceding the
first nul (if Trim_Nul is True). The lower bound of the result is 1. If
Trim_Nul is False, then for each component Item(I) the corresponding
component in the result is To_Ada applied to Item(I). If Trim_Nul is
True, then for each component Item(I) before the first nul the
corresponding component in the result is To_Ada applied to Item(I). The
function propagates Terminator_Error if Trim_Nul is True and Item does
not contain nul.
@end enumerate
@end enumerate

@enumerate 52
@item
@format
procedure To_C (Item       : in String;
                Target     : out char_array;
                Count      : out size_t;
                Append_Nul : in Boolean := True);

procedure To_Ada (Item     : in char_array;
                  Target   : out String;
                  Count    : out Natural;
                  Trim_Nul : in Boolean := True);
@end format

@enumerate 53
@item
For procedure To_C, each element of Item is converted (via the To_C
function) to a char, which is assigned to the corresponding element of
Target. If Append_Nul is True, nul is then assigned to the next element
of Target. In either case, Count is set to the number of Target elements
assigned. If Target is not long enough, Constraint_Error is propagated.

@item
For procedure To_Ada, each element of Item (if Trim_Nul is False) or
each element of Item preceding the first nul (if Trim_Nul is True) is
converted (via the To_Ada function) to a Character, which is assigned to
the corresponding element of Target. Count is set to the number of
Target elements assigned. If Target is not long enough, Constraint_Error
is propagated. If Trim_Nul is True and Item does not contain nul, then
Terminator_Error is propagated.
@end enumerate
@end enumerate

@enumerate 55
@item
@format
function Is_Nul_Terminated (Item : in wchar_array) return Boolean;
@end format

@enumerate 56
@item
The result of Is_Nul_Terminated is True if Item contains wide_nul, and
is False otherwise.
@end enumerate
@end enumerate

@enumerate 57
@item
@format
function To_C   (Item : in Wide_Character) return wchar_t;
function To_Ada (Item : in wchar_t       ) return Wide_Character;
@end format

@enumerate 58
@item
To_C and To_Ada provide the mappings between the Ada and C wide
character types.
@end enumerate
@end enumerate

@enumerate 59
@item
@format
function To_C   (Item       : in Wide_String;
                 Append_Nul : in Boolean := True)
   return wchar_array;

function To_Ada (Item     : in wchar_array;
                 Trim_Nul : in Boolean := True)
   return Wide_String;

procedure To_C (Item       : in Wide_String;
                Target     : out wchar_array;
                Count      : out size_t;
                Append_Nul : in Boolean := True);

procedure To_Ada (Item     : in wchar_array;
                  Target   : out Wide_String;
                  Count    : out Natural;
                  Trim_Nul : in Boolean := True);
@end format

@enumerate 60
@item
The To_C and To_Ada subprograms that convert between Wide_String and
wchar_array have analogous effects to the To_C and To_Ada subprograms
that convert between String and char_array, except that wide_nul is used
instead of nul.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@enumerate 61
@item
An implementation shall support pragma Convention with a C
convention_identifier for a C-eligible type, see @ref{B.1}.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may provide additional declarations in the C interface
packages.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An implementation should support the following interface correspondences
between Ada and C.

@enumerate 64
@item
An Ada procedure corresponds to a void-returning C function.

@item
An Ada function corresponds to a non-void C function.

@item
An Ada in scalar parameter is passed as a scalar argument to a C
function.

@item
An Ada in parameter of an access-to-object type with designated type T
is passed as a t* argument to a C function, where t is the C type
corresponding to the Ada type T.

@item
An Ada access T parameter, or an Ada out or in out parameter of an
elementary type T, is passed as a t* argument to a C function, where t
is the C type corresponding to the Ada type T. In the case of an
elementary out or in out parameter, a pointer to a temporary copy is
used to preserve by-copy semantics.

@item
An Ada parameter of a record type T, of any mode, is passed as a t*
argument to a C function, where t is the C struct corresponding to the
Ada type T.

@item
An Ada parameter of an array type with component type T, of any mode, is
passed as a t* argument to a C function, where t is the C type
corresponding to the Ada type T.

@item
An Ada parameter of an access-to-subprogram type is passed as a pointer
to a C function whose prototype corresponds to the designated
subprogram's specification.
@end enumerate
@end enumerate
@enumerate 72

NOTES

@item
(9) Values of type char_array are not implicitly terminated with nul. If
a char_array is to be passed as a parameter to an imported C function
requiring nul termination, it is the programmer's responsibility to
obtain this effect.

@item
(10) To obtain the effect of C's sizeof(item_type), where Item_Type is
the corresponding Ada type, evaluate the expression:
size_t(Item_Type'Size/CHAR_BIT).

@item
(11) There is no explicit support for C's union types. Unchecked
conversions can be used to obtain the effect of C unions.

@item
(12) A C function that takes a variable number of arguments can
correspond to several Ada subprograms, taking various specific numbers
and types of parameters.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of using the Interfaces.C package:

@item
@example
--Calling the C Library Function strcpy
with Interfaces.C;
procedure Test is
   package C renames Interfaces.C;
   use type C.char_array;
   -- Call <string.h> strcpy:
   -- C definition of strcpy:
   --    char *strcpy(char *s1, const char *s2);
   -- This function copies the string pointed to by s2
   -- (including the terminating null character) into the array
   -- pointed to by s1. If copying takes place between objects that
   -- overlap, the behavior is undefined. The strcpy function
   --  returns the value of s1.
@end example

@item
@example
   -- Note: since the C function's return value is of no interest,
   --  the Ada interface is a procedure
   procedure Strcpy (Target : out C.char_array;
                     Source : in  C.char_array);
@end example

@item
@example
pragma Import(C, Strcpy, "strcpy");
@end example

@item
@example
   Chars1 :  C.char_array(1..20);
   Chars2 :  C.char_array(1..20);
@end example

@item
@example
begin
   Chars2(1..6) := "qwert" & C.nul;
@end example

@item
@example
   Strcpy(Chars1, Chars2);
@end example

@item
@example
-- Now Chars1(1..6) = "qwert" & C.Nul
@end example

@item
@example
end Test;
@end example
@end enumerate

@menu
* B.3.1:: The Package Interfaces.C.Strings
* B.3.2:: The Generic Package Interfaces.C.Pointers
@end menu

@c ---------------------------------------------------------------------------
@node B.3.1, B.3.2, B.3, B.3
@subsection The Package Interfaces.C.Strings

@enumerate
@item
The package Interfaces.C.Strings declares types and subprograms allowing
an Ada program to allocate, reference, update, and free C-style strings.
In particular, the private type chars_ptr corresponds to a common use of
``char *'' in C programs, and an object of this type can be passed to a
subprogram to which pragma Import(C,...) has been applied, and for which
``char *'' is the type of the argument of the C function.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Interfaces.C.Strings has the following declaration:

@item
@example
package Interfaces.C.Strings is
   pragma Preelaborate(Strings);
@end example

@item
@example
   type char_array_access is access all char_array;
@end example

@item
@example
   type chars_ptr is private;
@end example

@item
@example
   type chars_ptr_array is array (size_t range <>) of chars_ptr;
@end example

@item
@example
   Null_Ptr : constant chars_ptr;
@end example

@item
@example
   function To_Chars_Ptr (Item      : in char_array_access;
                          Nul_Check : in Boolean := False)
      return chars_ptr;
@end example

@item
@example
   function New_Char_Array (Chars : in char_array) return chars_ptr;
@end example

@item
@example
   function New_String (Str : in String) return chars_ptr;
@end example

@item
@example
   procedure Free (Item : in out chars_ptr);
@end example

@item
@example
   Dereference_Error : exception;
@end example

@item
@example
   function Value (Item : in chars_ptr) return char_array;
@end example

@item
@example
   function Value (Item : in chars_ptr; Length : in size_t)
      return char_array;
@end example

@item
@example
   function Value (Item : in chars_ptr) return String;
@end example

@item
@example
   function Value (Item : in chars_ptr; Length : in size_t)
      return String;
@end example

@item
@example
   function Strlen (Item : in chars_ptr) return size_t;
@end example

@item
@example
   procedure Update (Item   : in chars_ptr;
                     Offset : in size_t;
                     Chars  : in char_array;
                     Check  : in Boolean := True);
@end example

@item
@example
   procedure Update (Item   : in chars_ptr;
                     Offset : in size_t;
                     Str    : in String;
                     Check  : in Boolean := True);
@end example

@item
@example
   Update_Error : exception;
@end example

@item
@example
private
   ... -- not specified by the language
end Interfaces.C.Strings;
@end example

@item
The type chars_ptr is C-compatible and corresponds to the use of C's
``char *'' for a pointer to the first char in a char array terminated by
nul. When an object of type chars_ptr is declared, its value is by
default set to Null_Ptr, unless the object is imported, see @ref{B.1}.

@item
@format
function To_Chars_Ptr (Item      : in char_array_access;
                       Nul_Check : in Boolean := False)
   return chars_ptr;
@end format

@enumerate 24
@item
If Item is null, then To_Chars_Ptr returns Null_Ptr. Otherwise, if
Nul_Check is True and Item.all does not contain nul, then the function
propagates Terminator_Error; if Nul_Check is True and Item.all does
contain nul, To_Chars_Ptr performs a pointer conversion with no
allocation of memory.
@end enumerate
@end enumerate

@enumerate 25
@item
@format
function New_Char_Array (Chars   : in char_array) return chars_ptr;
@end format

@enumerate 26
@item
This function returns a pointer to an allocated object initialized to
Chars(Chars'First .. Index) & nul, where

@item
Index = Chars'Last if Chars does not contain nul, or

@item
Index is the smallest size_t value I such that Chars(I+1) = nul.
@end enumerate
@end enumerate
@enumerate 29
Storage_Error is propagated if the allocation fails.

@item
@format
function New_String (Str : in String) return chars_ptr;
@end format

@enumerate 30
@item
This function is equivalent to New_Char_Array(To_C(Str)).
@end enumerate
@end enumerate

@enumerate 31
@item
@format
procedure Free (Item : in out chars_ptr);
@end format

@enumerate 32
@item
If Item is Null_Ptr, then Free has no effect. Otherwise, Free releases
the storage occupied by Value(Item), and resets Item to Null_Ptr.
@end enumerate
@end enumerate

@enumerate 33
@item
@format
function Value (Item : in chars_ptr) return char_array;
@end format

@enumerate 34
@item
If Item = Null_Ptr then Value propagates Dereference_Error. Otherwise
Value returns the prefix of the array of chars pointed to by Item, up to
and including the first nul. The lower bound of the result is 0. If Item
does not point to a nul-terminated string, then execution of Value is
erroneous.
@end enumerate
@end enumerate

@enumerate 35
@item
@format
function Value (Item : in chars_ptr; Length : in size_t)
   return char_array;
@end format

@enumerate 36
@item
If Item = Null_Ptr then Value(Item) propagates Dereference_Error.
Otherwise Value returns the shorter of two arrays: the first Length
chars pointed to by Item, and Value(Item). The lower bound of the result
is 0.
@end enumerate
@end enumerate

@enumerate 37
@item
@format
function Value (Item : in chars_ptr) return String;
@end format

@enumerate 38
@item
Equivalent to To_Ada(Value(Item), Trim_Nul=>True).
@end enumerate
@end enumerate

@enumerate 39
@item
@format
function Value (Item : in chars_ptr; Length : in size_t)
   return String;
@end format

@enumerate 40
@item
Equivalent to To_Ada(Value(Item, Length), Trim_Nul=>True).
@end enumerate
@end enumerate

@enumerate 41
@item
@format
function Strlen (Item : in chars_ptr) return size_t;
@end format

@enumerate 42
@item
Returns Val'Length-1 where Val = Value(Item); propagates
Dereference_Error if Item = Null_Ptr.
@end enumerate
@end enumerate

@enumerate 43
@item
@format
procedure Update (Item   : in chars_ptr;
                  Offset : in size_t;
                  Chars  : in char_array;
                  Check  : Boolean := True);
@end format

@enumerate 44
@item
This procedure updates the value pointed to by Item, starting at
position Offset, using Chars as the data to be copied into the array.
Overwriting the nul terminator, and skipping with the Offset past the
nul terminator, are both prevented if Check is True, as follows:

@enumerate 45
@item
Let N = Strlen(Item). If Check is True, then:

@enumerate 46
@item
If Offset+Chars'Length>N, propagate Update_Error.

@item
Otherwise, overwrite the data in the array pointed to by Item, starting
at the char at position Offset, with the data in Chars.
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 48
@item
If Check is False, then processing is as above, but with no check that
Offset+Chars'Length>N.
@end enumerate
@end enumerate
@end enumerate

@enumerate 49
@item
@format
procedure Update (Item   : in chars_ptr;
                  Offset : in size_t;
                  Str    : in String;
                  Check  : in Boolean := True);
@end format

@enumerate 50
@item
Equivalent to Update(Item, Offset, To_C(Str), Check).
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@enumerate 51
@item
Execution of any of the following is erroneous if the Item parameter is
not null_ptr and Item does not point to a nul-terminated array of chars.

@enumerate 52
@item
a Value function not taking a Length parameter,

@item
the Free procedure,

@item
the Strlen function.
@end enumerate
@end enumerate

@enumerate 55
@item
Execution of Free(X) is also erroneous if the chars_ptr X was not
returned by New_Char_Array or New_String.

@item
Reading or updating a freed char_array is erroneous.

@item
Execution of Update is erroneous if Check is False and a call with Check
equal to True would have propagated Update_Error.

NOTES

@item
(13) New_Char_Array and New_String might be implemented either through
the allocation function from the C environment (``malloc'') or through
Ada dynamic memory allocation (``new''). The key points are

@enumerate 59
@item
the returned value (a chars_ptr) is represented as a C ``char *'' so
that it may be passed to C functions;

@item
the allocated object should be freed by the programmer via a call of
Free, not by a called C function.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node B.3.2, B.4, B.3.1, B.3
@subsection The Generic Package Interfaces.C.Pointers

@enumerate
@item
The generic package Interfaces.C.Pointers allows the Ada programmer to
perform C-style operations on pointers. It includes an access type
Pointer, Value functions that dereference a Pointer and deliver the
designated array, several pointer arithmetic operations, and ``copy''
procedures that copy the contents of a source pointer into the array
designated by a destination pointer. As in C, it treats an object Ptr of
type Pointer as a pointer to the first element of an array, so that for
example, adding 1 to Ptr yields a pointer to the second element of the
array.

@item
The generic allows two styles of usage: one in which the array is
terminated by a special terminator element; and another in which the
programmer needs to keep track of the length.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The generic library package Interfaces.C.Pointers has the following
declaration:

@item
@example
generic
   type Index is (<>);
   type Element is private;
   type Element_Array is array (Index range <>) of aliased Element;
   Default_Terminator : Element;
package Interfaces.C.Pointers is
   pragma Preelaborate(Pointers);
@end example

@item
@example
   type Pointer is access all Element;
@end example

@item
@example
   function Value(Ref        : in Pointer;
                  Terminator : in Element := Default_Terminator)
      return Element_Array;
@end example

@item
@example
   function Value(Ref    : in Pointer;
                  Length : in ptrdiff_t)
      return Element_Array;
@end example

@item
@example
   Pointer_Error : exception;
@end example

@item
@example
   -- C-style Pointer arithmetic
@end example

@item
@example
   function "+" (Left  : in Pointer;
                 Right : in ptrdiff_t) return Pointer;
   function "+" (Left  : in ptrdiff_t;
                 Right : in Pointer)   return Pointer;
   function "-" (Left  : in Pointer;
                 Right : in ptrdiff_t) return Pointer;
   function "-" (Left  : in Pointer;
                 Right : in Pointer)   return ptrdiff_t;
@end example

@item
@example
   procedure Increment (Ref : in out Pointer);
   procedure Decrement (Ref : in out Pointer);
@end example

@item
@example
   pragma Convention (Intrinsic, "+");
   pragma Convention (Intrinsic, "-");
   pragma Convention (Intrinsic, Increment);
   pragma Convention (Intrinsic, Decrement);
@end example

@item
@example
   function Virtual_Length
     (Ref        : in Pointer;
      Terminator : in Element := Default_Terminator)
     return ptrdiff_t;
@end example

@item
@example
   procedure Copy_Terminated_Array
     (Source     : in Pointer;
      Target     : in Pointer;
      Limit      : in ptrdiff_t := ptrdiff_t'Last;
      Terminator : in Element :=  Default_Terminator);
@end example

@item
@example
   procedure Copy_Array (Source  : in Pointer;
                         Target  : in Pointer;
                         Length  : in ptrdiff_t);
@end example

@item
@example
end Interfaces.C.Pointers;
@end example

@item
The type Pointer is C-compatible and corresponds to one use of C's
``Element *''. An object of type Pointer is interpreted as a pointer to
the initial Element in an Element_Array. Two styles are supported:

@enumerate 18
@item
Explicit termination of an array value with Default_Terminator (a
special terminator value);

@item
Programmer-managed length, with Default_Terminator treated simply as a
data element.
@end enumerate
@end enumerate

@enumerate 20
@item
@format
function Value(Ref        : in Pointer;
               Terminator : in Element := Default_Terminator)
  return Element_Array;
@end format

@enumerate 21
@item
This function returns an Element_Array whose value is the array pointed
to by Ref, up to and including the first Terminator; the lower bound of
the array is Index'First. Interfaces.C.Strings.Dereference_Error is
propagated if Ref is null.
@end enumerate
@end enumerate

@enumerate 22
@item
@format
function Value(Ref    : in Pointer;
               Length : in ptrdiff_t)
   return Element_Array;
@end format

@enumerate 23
@item
This function returns an Element_Array comprising the first Length
elements pointed to by Ref. The exception
Interfaces.C.Strings.Dereference_Error is propagated if Ref is null.
@end enumerate
@end enumerate

@enumerate 24
@item
The "+" and "-" functions perform arithmetic on Pointer values, based on
the Size of the array elements. In each of these functions,
Pointer_Error is propagated if a Pointer parameter is null.

@item
@format
procedure Increment (Ref : in out Pointer);
@end format

@enumerate 26
@item
Equivalent to Ref := Ref+1.
@end enumerate
@end enumerate

@enumerate 27
@item
@format
procedure Decrement (Ref : in out Pointer);
@end format

@enumerate 28
@item
Equivalent to Ref := Ref-1.
@end enumerate
@end enumerate

@enumerate 29
@item
@format
function Virtual_Length
  (Ref        : in Pointer;
   Terminator : in Element := Default_Terminator)
   return ptrdiff_t;
@end format

@enumerate 30
@item
Returns the number of Elements, up to the one just before the first
Terminator, in Value(Ref, Terminator).
@end enumerate
@end enumerate

@enumerate 31
@item
@format
procedure Copy_Terminated_Array
  (Source     : in Pointer;
   Target     : in Pointer;
   Limit      : in ptrdiff_t := ptrdiff_t'Last;
   Terminator : in Element := Default_Terminator);
@end format

@enumerate 32
@item
This procedure copies Value(Source, Terminator) into the array pointed
to by Target; it stops either after Terminator has been copied, or the
number of elements copied is Limit, whichever occurs first.
Dereference_Error is propagated if either Source or Target is null.
@end enumerate
@end enumerate

@enumerate 33
@item
@format
procedure Copy_Array (Source  : in Pointer;
                      Target  : in Pointer;
                      Length  : in ptrdiff_t);
@end format

@enumerate 34
@item
This procedure copies the first Length elements from the array pointed
to by Source, into the array pointed to by Target. Dereference_Error is
propagated if either Source or Target is null.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@enumerate 35
@item
It is erroneous to dereference a Pointer that does not designate an
aliased Element.

@item
Execution of Value(Ref, Terminator) is erroneous if Ref does not
designate an aliased Element in an Element_Array terminated by
Terminator.

@item
Execution of Value(Ref, Length) is erroneous if Ref does not designate
an aliased Element in an Element_Array containing at least Length
Elements between the designated Element and the end of the array,
inclusive.

@item
Execution of Virtual_Length(Ref, Terminator) is erroneous if Ref does
not designate an aliased Element in an Element_Array terminated by
Terminator.

@item
Execution of Copy_Terminated_Array(Source, Target, Limit, Terminator) is
erroneous in either of the following situations:

@enumerate 40
@item
Execution of both Value(Source,Terminator) and Value(Source,Limit) are
erroneous, or

@item
Copying writes past the end of the array containing the Element
designated by Target.
@end enumerate
@end enumerate

@enumerate 42
@item
Execution of Copy_Array(Source, Target, Length) is erroneous if either
Value(Source, Length) is erroneous, or copying writes past the end of
the array containing the Element designated by Target.

NOTES

@item
(14) To compose a Pointer from an Element_Array, use 'Access on the
first element. For example (assuming appropriate instantiations):

@item
@example
Some_Array   : Element_Array(0..5) ;
Some_Pointer : Pointer := Some_Array(0)'Access;
@end example

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of Interfaces.C.Pointers:

@item
@example
with Interfaces.C.Pointers;
with Interfaces.C.Strings;
procedure Test_Pointers is
   package C renames Interfaces.C;
   package Char_Ptrs is
      new C.Pointers (Index              => C.size_t,
                      Element            => C.char,
                      Element_Array      => C.char_array,
                      Default_Terminator => C.nul);
@end example

@item
@example
   use type Char_Ptrs.Pointer;
   subtype Char_Star is Char_Ptrs.Pointer;
@end example

@item
@example
   procedure Strcpy (Target_Ptr, Source_Ptr : Char_Star) is
      Target_Temp_Ptr : Char_Star := Target_Ptr;
      Source_Temp_Ptr : Char_Star := Source_Ptr;
      Element : C.char;
   begin
      if Target_Temp_Ptr = null or Source_Temp_Ptr = null then
         raise C.Strings.Dereference_Error;
      end if;
@end example

@item
@example
      loop
         Element             := Source_Temp_Ptr.all;
         Target_Temp_Ptr.all := Element;
         exit when Element = C.nul;
         Char_Ptrs.Increment(Target_Temp_Ptr);
         Char_Ptrs.Increment(Source_Temp_Ptr);
      end loop;
   end Strcpy;
begin
   ...
end Test_Pointers;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node B.4, B.5, B.3.2, B
@section Interfacing with COBOL

@enumerate
@item
The facilities relevant to interfacing with the COBOL language are the
package Interfaces.COBOL and support for the Import, Export and
Convention pragmas with convention_identifier COBOL.

@item
The COBOL interface package supplies several sets of facilities:

@enumerate 3
@item
A set of types corresponding to the native COBOL types of the supported
COBOL implementation (so-called ``internal COBOL representations''),
allowing Ada data to be passed as parameters to COBOL programs

@item
A set of types and constants reflecting external data representations
such as might be found in files or databases, allowing COBOL-generated
data to be read by an Ada program, and Ada-generated data to be read by
COBOL programs

@item
A generic package for converting between an Ada decimal type value and
either an internal or external COBOL representation
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 6
@item
The library package Interfaces.COBOL has the following declaration:

@item
@example
package Interfaces.COBOL is
   pragma Preelaborate(COBOL);
@end example

@item
@example
   -- Types and operations for internal data representations
@end example

@item
@example
   type Floating      is digits implementation-defined;
   type Long_Floating is digits implementation-defined;
@end example

@item
@example
   type Binary      is range implementation-defined;
   type Long_Binary is range implementation-defined;
@end example

@item
@example
   Max_Digits_Binary      : constant := implementation-defined;
   Max_Digits_Long_Binary : constant := implementation-defined;
@end example

@item
@example
   type Decimal_Element  is mod implementation-defined;
   type Packed_Decimal is
     array (Positive range <>) of Decimal_Element;
   pragma Pack(Packed_Decimal);
@end example

@item
@example
   type COBOL_Character is implementation-defined character type;
@end example

@item
@example
   Ada_To_COBOL : array (Character) of COBOL_Character
     := implementation-defined;
@end example

@item
@example
   COBOL_To_Ada : array (COBOL_Character) of Character
     := implementation-defined;
@end example

@item
@example
   type Alphanumeric is
     array (Positive range <>) of COBOL_Character;
   pragma Pack(Alphanumeric);
@end example

@item
@example
   function To_COBOL (Item : in String) return Alphanumeric;
   function To_Ada   (Item : in Alphanumeric) return String;
@end example

@item
@example
   procedure To_COBOL (Item       : in String;
                       Target     : out Alphanumeric;
                       Last       : out Natural);
@end example

@item
@example
   procedure To_Ada (Item     : in Alphanumeric;
                     Target   : out String;
                     Last     : out Natural);
@end example

@item
@example
   type Numeric is array (Positive range <>) of COBOL_Character;
   pragma Pack(Numeric);
@end example

@item
@example
   -- Formats for COBOL data representations
@end example

@item
@example
   type Display_Format is private;
@end example

@item
@example
   Unsigned             : constant Display_Format;
   Leading_Separate     : constant Display_Format;
   Trailing_Separate    : constant Display_Format;
   Leading_Nonseparate  : constant Display_Format;
   Trailing_Nonseparate : constant Display_Format;
@end example

@item
@example
   type Binary_Format is private;
@end example

@item
@example
   High_Order_First  : constant Binary_Format;
   Low_Order_First   : constant Binary_Format;
   Native_Binary     : constant Binary_Format;
@end example

@item
@example
   type Packed_Format is private;
@end example

@item
@example
   Packed_Unsigned   : constant Packed_Format;
   Packed_Signed     : constant Packed_Format;
@end example

@item
@example
   -- Types for external representation of COBOL binary data
@end example

@item
@example
   type Byte is mod 2**COBOL_Character'Size;
   type Byte_Array is array (Positive range <>) of Byte;
   pragma Pack (Byte_Array);
@end example

@item
@example
   Conversion_Error : exception;
@end example

@item
@example
   generic
      type Num is delta <> digits <>;
   package Decimal_Conversions is
@end example

@item
@example
      -- Display Formats: data values are represented as Numeric
@end example

@item
@example
      function Valid (Item   : in Numeric;
                      Format : in Display_Format) return Boolean;
@end example

@item
@example
      function Length (Format : in Display_Format) return Natural;
@end example

@item
@example
      function To_Decimal (Item   : in Numeric;
                           Format : in Display_Format) return Num;
@end example

@item
@example
      function To_Display (Item   : in Num;
                           Format : in Display_Format)
        return Numeric;
@end example

@item
@example
      -- Packed Formats:
      -- data values are represented as Packed_Decimal
@end example

@item
@example
      function Valid (Item   : in Packed_Decimal;
                      Format : in Packed_Format) return Boolean;
@end example

@item
@example
      function Length (Format : in Packed_Format) return Natural;
@end example

@item
@example
      function To_Decimal (Item   : in Packed_Decimal;
                           Format : in Packed_Format) return Num;
@end example

@item
@example
      function To_Packed (Item   : in Num;
                          Format : in Packed_Format)
        return Packed_Decimal;
@end example

@item
@example
      -- Binary Formats:
      -- external data values are represented as Byte_Array
@end example

@item
@example
      function Valid (Item   : in Byte_Array;
                      Format : in Binary_Format) return Boolean;
@end example

@item
@example
      function Length (Format : in Binary_Format) return Natural;
      function To_Decimal (Item   : in Byte_Array;
                           Format : in Binary_Format) return Num;
@end example

@item
@example
      function To_Binary (Item   : in Num;
                        Format : in Binary_Format)
        return Byte_Array;
@end example

@item
@example
      -- Internal Binary formats:
      -- data values are of type Binary or Long_Binary
@end example

@item
@example
      function To_Decimal (Item : in Binary)      return Num;
      function To_Decimal (Item : in Long_Binary) return Num;
@end example

@item
@example
      function To_Binary      (Item : in Num)  return Binary;
      function To_Long_Binary (Item : in Num)  return Long_Binary;
@end example

@item
@example
   end Decimal_Conversions;
@end example

@item
@example
private
   ... -- not specified by the language
end Interfaces.COBOL;
@end example

@item
Each of the types in Interfaces.COBOL is COBOL-compatible.

@item
The types Floating and Long_Floating correspond to the native types in
COBOL for data items with computational usage implemented by floating
point. The types Binary and Long_Binary correspond to the native types
in COBOL for data items with binary usage, or with computational usage
implemented by binary.

@item
Max_Digits_Binary is the largest number of decimal digits in a numeric
value that is represented as Binary. Max_Digits_Long_Binary is the
largest number of decimal digits in a numeric value that is represented
as Long_Binary.

@item
The type Packed_Decimal corresponds to COBOL's packed-decimal usage.

@item
The type COBOL_Character defines the run-time character set used in the
COBOL implementation. Ada_To_COBOL and COBOL_To_Ada are the mappings
between the Ada and COBOL run-time character sets.

@item
Type Alphanumeric corresponds to COBOL's alphanumeric data category.

@item
Each of the functions To_COBOL and To_Ada converts its parameter based
on the mappings Ada_To_COBOL and COBOL_To_Ada, respectively. The length
of the result for each is the length of the parameter, and the lower
bound of the result is 1. Each component of the result is obtained by
applying the relevant mapping to the corresponding component of the
parameter.

@item
Each of the procedures To_COBOL and To_Ada copies converted elements
from Item to Target, using the appropriate mapping (Ada_To_COBOL or
COBOL_To_Ada, respectively). The index in Target of the last element
assigned is returned in Last (0 if Item is a null array). If Item'Length
exceeds Target'Length, Constraint_Error is propagated.

@item
Type Numeric corresponds to COBOL's numeric data category with display
usage.

@item
The types Display_Format, Binary_Format, and Packed_Format are used in
conversions between Ada decimal type values and COBOL internal or
external data representations. The value of the constant Native_Binary
is either High_Order_First or Low_Order_First, depending on the
implementation.

@item
@format
function Valid (Item   : in Numeric;
                Format : in Display_Format) return Boolean;
@end format

@enumerate 62
@item
The function Valid checks that the Item parameter has a value consistent
with the value of Format. If the value of Format is other than Unsigned,
Leading_Separate, and Trailing_Separate, the effect is implementation
defined. If Format does have one of these values, the following rules
apply:

@enumerate 63
@item
Format=Unsigned: if Item comprises zero or more leading space characters
followed by one or more decimal digit characters then Valid returns
True, else it returns False.

@item
Format=Leading_Separate: if Item comprises zero or more leading space
characters, followed by a single occurrence of the plus or minus sign
character, and then one or more decimal digit characters, then Valid
returns True, else it returns False.

@item
Format=Trailing_Separate: if Item comprises zero or more leading space
characters, followed by one or more decimal digit characters and finally
a plus or minus sign character, then Valid returns True, else it returns
False.
@end enumerate
@end enumerate
@end enumerate

@enumerate 66
@item
@format
function Length (Format : in Display_Format) return Natural;
@end format

@enumerate 67
@item
The Length function returns the minimal length of a Numeric value
sufficient to hold any value of type Num when represented as Format.
@end enumerate
@end enumerate

@enumerate 68
@item
@format
function To_Decimal (Item   : in Numeric;
                     Format : in Display_Format) return Num;
@end format

@enumerate 69
@item
Produces a value of type Num corresponding to Item as represented by
Format. The number of digits after the assumed radix point in Item is
Num'Scale. Conversion_Error is propagated if the value represented by
Item is outside the range of Num.
@end enumerate
@end enumerate

@enumerate 70
@item
@format
function To_Display (Item   : in Num;
                     Format : in Display_Format) return Numeric;
@end format

@enumerate 71
@item
This function returns the Numeric value for Item, represented in
accordance with Format. Conversion_Error is propagated if Num is
negative and Format is Unsigned.
@end enumerate
@end enumerate

@enumerate 72
@item
@format
function Valid (Item   : in Packed_Decimal;
                Format : in Packed_Format) return Boolean;
@end format

@enumerate 73
@item
This function returns True if Item has a value consistent with Format,
and False otherwise. The rules for the formation of Packed_Decimal
values are implementation defined.
@end enumerate
@end enumerate

@enumerate 74
@item
@format
function Length (Format : in Packed_Format) return Natural;
@end format

@enumerate 75
@item
This function returns the minimal length of a Packed_Decimal value
sufficient to hold any value of type Num when represented as Format.
@end enumerate
@end enumerate

@enumerate 76
@item
@format
function To_Decimal (Item   : in Packed_Decimal;
                     Format : in Packed_Format) return Num;
@end format

@enumerate 77
@item
Produces a value of type Num corresponding to Item as represented by
Format. Num'Scale is the number of digits after the assumed radix point
in Item. Conversion_Error is propagated if the value represented by Item
is outside the range of Num.
@end enumerate
@end enumerate

@enumerate 78
@item
@format
function To_Packed (Item   : in Num;
                    Format : in Packed_Format)
  return Packed_Decimal;
@end format

@enumerate 79
@item
This function returns the Packed_Decimal value for Item, represented in
accordance with Format. Conversion_Error is propagated if Num is
negative and Format is Packed_Unsigned.
@end enumerate
@end enumerate

@enumerate 80
@item
@format
function Valid (Item   : in Byte_Array;
                Format : in Binary_Format) return Boolean;
@end format

@enumerate 81
@item
This function returns True if Item has a value consistent with Format,
and False otherwise.
@end enumerate
@end enumerate

@enumerate 82
@item
@format
function Length (Format : in Binary_Format) return Natural;
@end format

@enumerate 83
@item
This function returns the minimal length of a Byte_Array value
sufficient to hold any value of type Num when represented as Format.
@end enumerate
@end enumerate

@enumerate 84
@item
@format
function To_Decimal (Item   : in Byte_Array;
                     Format : in Binary_Format) return Num;
@end format

@enumerate 85
@item
Produces a value of type Num corresponding to Item as represented by
Format. Num'Scale is the number of digits after the assumed radix point
in Item. Conversion_Error is propagated if the value represented by Item
is outside the range of Num.
@end enumerate
@end enumerate

@enumerate 86
@item
@format
function To_Binary (Item   : in Num;
                    Format : in Binary_Format) return Byte_Array;
@end format

@enumerate 87
@item
This function returns the Byte_Array value for Item, represented in
accordance with Format.
@end enumerate
@end enumerate

@enumerate 88
@item
@format
function To_Decimal (Item : in Binary)      return Num;

function To_Decimal (Item : in Long_Binary) return Num;
@end format

@enumerate 89
@item
These functions convert from COBOL binary format to a corresponding
value of the decimal type Num. Conversion_Error is propagated if Item is
too large for Num.
@end enumerate
@end enumerate

@enumerate 90
@item
@format
function To_Binary      (Item : in Num)  return Binary;

function To_Long_Binary (Item : in Num)  return Long_Binary;
@end format

@enumerate 91
@item
These functions convert from Ada decimal to COBOL binary format.
Conversion_Error is propagated if the value of Item is too large to be
represented in the result type.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@enumerate 92
@item
An implementation shall support pragma Convention with a COBOL
convention_identifier for a COBOL-eligible type, see @ref{B.1}.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may provide additional constants of the private types
Display_Format, Binary_Format, or Packed_Format.

@item
An implementation may provide further floating point and integer types
in Interfaces.COBOL to match additional native COBOL types, and may also
supply corresponding conversion functions in the generic package
Decimal_Conversions.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An Ada implementation should support the following interface
correspondences between Ada and COBOL.

@enumerate 96
@item
An Ada access T parameter is passed as a ``BY REFERENCE'' data item of
the COBOL type corresponding to T.

@item
An Ada in scalar parameter is passed as a ``BY CONTENT'' data item of
the corresponding COBOL type.

@item
Any other Ada parameter is passed as a ``BY REFERENCE'' data item of the
COBOL type corresponding to the Ada parameter type; for scalars, a local
copy is used if necessary to ensure by-copy semantics.
@end enumerate
@end enumerate
@enumerate 99

NOTES

@item
(15) An implementation is not required to support pragma Convention for
access types, nor is it required to support pragma Import, Export or
Convention for functions.

@item
(16) If an Ada subprogram is exported to COBOL, then a call from COBOL
call may specify either ``BY CONTENT'' or ``BY REFERENCE''.

@need 1000
@sp 1
@center @emph{Examples}

@item
Examples of Interfaces.COBOL:

@item
@example
with Interfaces.COBOL;
procedure Test_Call is
@end example

@item
@example
   -- Calling a foreign COBOL program
   -- Assume that a COBOL program PROG has the following declaration
   --  in its LINKAGE section:
   --  01 Parameter-Area
   --     05 NAME   PIC X(20).
   --     05 SSN    PIC X(9).
   --     05 SALARY PIC 99999V99 USAGE COMP.
   -- The effect of PROG is to update SALARY based on some algorithm
@end example

@item
@example
   package COBOL renames Interfaces.COBOL;
@end example

@item
@example
   type Salary_Type is delta 0.01 digits 7;
@end example

@item
@example
   type COBOL_Record is
      record
         Name   : COBOL.Numeric(1..20);
         SSN    : COBOL.Numeric(1..9);
         Salary : COBOL.Binary;  -- Assume Binary = 32 bits
      end record;
   pragma Convention (COBOL, COBOL_Record);
@end example

@item
@example
   procedure Prog (Item : in out COBOL_Record);
   pragma Import (COBOL, Prog, "PROG");
@end example

@item
@example
   package Salary_Conversions is
      new COBOL.Decimal_Conversions(Salary_Type);
@end example

@item
@example
   Some_Salary : Salary_Type := 12_345.67;
   Some_Record : COBOL_Record :=
      (Name   => "Johnson, John       ",
       SSN    => "111223333",
       Salary => Salary_Conversions.To_Binary(Some_Salary));
@end example

@item
@example
begin
   Prog (Some_Record);
   ...
end Test_Call;
@end example

@item
@example
with Interfaces.COBOL;
with COBOL_Sequential_IO;
-- Assumed to be supplied by implementation
procedure Test_External_Formats is
@end example

@item
@example
   -- Using data created by a COBOL program
   -- Assume that a COBOL program has created a sequential file with
   --  the following record structure, and that we need to
   --  process the records in an Ada program
   --  01 EMPLOYEE-RECORD
   --     05 NAME    PIC X(20).
   --     05 SSN     PIC X(9).
   --     05 SALARY  PIC 99999V99 USAGE COMP.
   --     05 ADJUST  PIC S999V999 SIGN LEADING SEPARATE.
   -- The COMP data is binary (32 bits), high-order byte first
@end example

@item
@example
   package COBOL renames Interfaces.COBOL;
@end example

@item
@example
   type Salary_Type      is delta 0.01  digits 7;
   type Adjustments_Type is delta 0.001 digits 6;
@end example

@item
@example
   type COBOL_Employee_Record_Type is  -- External representation
      record
         Name    : COBOL.Alphanumeric(1..20);
         SSN     : COBOL.Alphanumeric(1..9);
         Salary  : COBOL.Byte_Array(1..4);
         Adjust  : COBOL.Numeric(1..7);  -- Sign and 6 digits
      end record;
   pragma Convention (COBOL, COBOL_Employee_Record_Type);
@end example

@item
@example
   package COBOL_Employee_IO is
      new COBOL_Sequential_IO(COBOL_Employee_Record_Type);
   use COBOL_Employee_IO;
@end example

@item
@example
   COBOL_File : File_Type;
@end example

@item
@example
   type Ada_Employee_Record_Type is  -- Internal representation
      record
         Name    : String(1..20);
         SSN     : String(1..9);
         Salary  : Salary_Type;
         Adjust  : Adjustments_Type;
      end record;
@end example

@item
@example
   COBOL_Record : COBOL_Employee_Record_Type;
   Ada_Record   : Ada_Employee_Record_Type;
@end example

@item
@example
   package Salary_Conversions is
      new COBOL.Decimal_Conversions(Salary_Type);
   use Salary_Conversions;
@end example

@item
@example
   package Adjustments_Conversions is
      new COBOL.Decimal_Conversions(Adjustments_Type);
   use Adjustments_Conversions;
@end example

@item
@example
begin
   Open (COBOL_File, Name => "Some_File");
@end example

@item
@example
   loop
     Read (COBOL_File, COBOL_Record);
@end example

@item
@example
     Ada_Record.Name := To_Ada(COBOL_Record.Name);
     Ada_Record.SSN  := To_Ada(COBOL_Record.SSN);
     Ada_Record.Salary :=
        To_Decimal(COBOL_Record.Salary, COBOL.High_Order_First);
     Ada_Record.Adjust :=
        To_Decimal(COBOL_Record.Adjust, COBOL.Leading_Separate);
     ... -- Process Ada_Record
   end loop;
exception
   when End_Error => ...
end Test_External_Formats;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node B.5, C, B.4, B
@section Interfacing with Fortran

@enumerate
@item
The facilities relevant to interfacing with the Fortran language are the
package Interfaces.Fortran and support for the Import, Export and
Convention pragmas with convention_identifier Fortran.

@item
The package Interfaces.Fortran defines Ada types whose representations
are identical to the default representations of the Fortran intrinsic
types Integer, Real, Double Precision, Complex, Logical, and Character
in a supported Fortran implementation. These Ada types can therefore be
used to pass objects between Ada and Fortran programs.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Interfaces.Fortran has the following declaration:

@item
@example
with Ada.Numerics.Generic_Complex_Types;  --  see @ref{G.1.1}.
pragma Elaborate_All(Ada.Numerics.Generic_Complex_Types);
package Interfaces.Fortran is
   pragma Pure(Fortran);
@end example

@item
@example
   type Fortran_Integer is range implementation-defined;
@end example

@item
@example
   type Real             is digits implementation-defined;
   type Double_Precision is digits implementation-defined;
@end example

@item
@example
   type Logical is new Boolean;
@end example

@item
@example
   package Single_Precision_Complex_Types is
      new Ada.Numerics.Generic_Complex_Types (Real);
@end example

@item
@example
   type Complex is new Single_Precision_Complex_Types.Complex;
@end example

@item
@example
   subtype Imaginary is Single_Precision_Complex_Types.Imaginary;
   i : Imaginary renames Single_Precision_Complex_Types.i;
   j : Imaginary renames Single_Precision_Complex_Types.j;
@end example

@item
@example
   type Character_Set is implementation-defined character type;
@end example

@item
@example
   type Fortran_Character is
     array (Positive range <>) of Character_Set;
   pragma Pack (Fortran_Character);
@end example

@item
@example
   function To_Fortran (Item : in Character) return Character_Set;
   function To_Ada (Item : in Character_Set) return Character;
@end example

@item
@example
   function To_Fortran (Item : in String) return Fortran_Character;
   function To_Ada     (Item : in Fortran_Character) return String;
@end example

@item
@example
   procedure To_Fortran (Item       : in String;
                         Target     : out Fortran_Character;
                         Last       : out Natural);
@end example

@item
@example
   procedure To_Ada (Item     : in Fortran_Character;
                     Target   : out String;
                     Last     : out Natural);
@end example

@item
@example
end Interfaces.Fortran;
@end example

@item
The types Fortran_Integer, Real, Double_Precision, Logical, Complex, and
Fortran_Character are Fortran-compatible.

@item
The To_Fortran and To_Ada functions map between the Ada type Character
and the Fortran type Character_Set, and also between the Ada type String
and the Fortran type Fortran_Character. The To_Fortran and To_Ada
procedures have analogous effects to the string conversion subprograms
found in Interfaces.COBOL.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
An implementation shall support pragma Convention with a Fortran
convention_identifier for a Fortran-eligible type, see @ref{B.1}.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may add additional declarations to the Fortran
interface packages. For example, the Fortran interface package for an
implementation of Fortran 77 (ANSI X3.9-1978) that defines types like
Integer*n, Real*n, Logical*n, and Complex*n may contain the declarations
of types named Integer_Star_n, Real_Star_n, Logical_Star_n, and
Complex_Star_n. (This convention should not apply to Character*n, for
which the Ada analog is the constrained array subtype Fortran_Character
(1..n).) Similarly, the Fortran interface package for an implementation
of Fortran 90 that provides multiple kinds of intrinsic types, e.g.
Integer (Kind=n), Real (Kind=n), Logical (Kind=n), Complex (Kind=n), and
Character (Kind=n), may contain the declarations of types with the
recommended names Integer_Kind_n, Real_Kind_n, Logical_Kind_n,
Complex_Kind_n, and Character_Kind_n.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
An Ada implementation should support the following interface
correspondences between Ada and Fortran:

@enumerate 23
@item
An Ada procedure corresponds to a Fortran subroutine.

@item
An Ada function corresponds to a Fortran function.

@item
An Ada parameter of an elementary, array, or record type T is passed as
a T(F) argument to a Fortran procedure, where T(F) is the Fortran type
corresponding to the Ada type T, and where the INTENT attribute of the
corresponding dummy argument matches the Ada formal parameter mode; the
Fortran implementation's parameter passing conventions are used. For
elementary types, a local copy is used if necessary to ensure by-copy
semantics.

@item
An Ada parameter of an access-to-subprogram type is passed as a
reference to a Fortran procedure whose interface corresponds to the
designated subprogram's specification.
@end enumerate
@end enumerate
@enumerate 27

NOTES

@item
(17) An object of a Fortran-compatible record type, declared in a
library package or subprogram, can correspond to a Fortran common block;
the type also corresponds to a Fortran ``derived type''.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of Interfaces.Fortran:

@item
@example
with Interfaces.Fortran;
use Interfaces.Fortran;
procedure Ada_Application is
@end example

@item
@example
   type Fortran_Matrix is array
     (Integer range <>,
      Integer range <>) of Double_Precision;
   pragma Convention (Fortran, Fortran_Matrix);
   -- stored in Fortran's column-major order
   procedure Invert
     (Rank : in Fortran_Integer;
      X    : in out Fortran_Matrix);
   pragma Import (Fortran, Invert);
   -- a Fortran subroutine
@end example

@item
@example
   Rank      : constant Fortran_Integer := 100;
   My_Matrix : Fortran_Matrix (1 .. Rank, 1 .. Rank);
@end example

@item
@example
begin
@end example

@item
@example
   ...
   My_Matrix := ...;
   ...
   Invert (Rank, My_Matrix);
   ...
@end example

@item
@example
end Ada_Application;
@end example
@end enumerate

@c ===========================================================================
@node C, C.1, B.5, Top
@appendix  Systems Programming (normative)

@enumerate
@item
The Systems Programming Annex specifies additional capabilities provided
for low-level programming. These capabilities are also required in many
real-time, embedded, distributed, and information systems.
@end enumerate

@menu
* C.1:: Access to Machine Operations
* C.2:: Required Representation Support
* C.3:: Interrupt Support
* C.4:: Preelaboration Requirements
* C.5:: Pragma Discard_Names
* C.6:: Shared Variable Control
* C.7:: Task Identification and Attributes

--- The Detailed Node Listing ---

* C.1::   Access to Machine Operations
* C.2::   Required Representation Support
* C.3::   Interrupt Support
* C.3.1:: Protected Procedure Handlers
* C.3.2:: The Package Interrupts
* C.4::   Preelaboration Requirements
* C.5::   Pragma Discard_Names
* C.6::   Shared Variable Control
* C.7::   Task Identification and Attributes
* C.7.1:: The Package Task_Identification
* C.7.2:: The Package Task_Attributes
@end menu

@c ---------------------------------------------------------------------------
@node C.1, C.2, C, C
@section Access to Machine Operations

@enumerate
@item
This clause specifies rules regarding access to machine instructions
from within an Ada program.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall support machine code insertions, see @ref{13.8},
or intrinsic subprograms, see @ref{6.3.1}, (or both).
Implementation-defined attributes shall be provided to allow the use of
Ada entities as operands.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The machine code or intrinsics support should allow access to all
operations normally available to assembly language programmers for the
target environment, including privileged instructions, if any.

@item
The interfacing pragmas (@pxref{B}) should support interface to
assembler; the default assembler should be associated with the
convention identifier Assembler.

@item
If an entity is exported to assembly language, then the implementation
should allocate it at an addressable location, and should ensure that it
is retained by the linking process, even if not otherwise referenced
from the Ada code. The implementation should assume that any call to a
machine code or assembler subprogram is allowed to read or update every
object that is specified as exported.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the overhead associated with calling
machine-code or intrinsic subprograms, as compared to a fully-inlined
call, and to a regular out-of-line call.

@item
The implementation shall document the types of the package
System.Machine_Code usable for machine code insertions, and the
attributes to be used in machine code insertions for references to Ada
entities.

@item
The implementation shall document the subprogram calling conventions
associated with the convention identifiers available for use with the
interfacing pragmas (Ada and Assembler, at a minimum), including
register saving, exception propagation, parameter passing, and function
value returning.

@item
For exported and imported subprograms, the implementation shall document
the mapping between the Link_Name string, if specified, or the Ada
designator, if not, and the external link name used for such a
subprogram.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The implementation should ensure that little or no overhead is
associated with calling intrinsic and machine-code subprograms.

@item
It is recommended that intrinsic subprograms be provided for convenient
access to any machine operations that provide special capabilities or
efficiency and that are not otherwise available through the language
constructs. Examples of such instructions include:

@enumerate 12
@item
Atomic read-modify-write operations -- e.g., test and set, compare and
swap, decrement and test, enqueue/dequeue.

@item
Standard numeric functions -- e.g., sin, log.

@item
String manipulation operations -- e.g., translate and test.

@item
Vector operations -- e.g., compare vector against thresholds.

@item
Direct operations on I/O ports.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node C.2, C.3, C.1, C
@section Required Representation Support

@enumerate
@item
This clause specifies minimal requirements on the implementation's
support for representation items and related features.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall support at least the functionality defined by
the recommended levels of support in @ref{13}.
@end enumerate

@c ---------------------------------------------------------------------------
@node C.3, C.3.1, C.2, C
@section Interrupt Support

@enumerate
@item
This clause specifies the language-defined model for hardware interrupts
in addition to mechanisms for handling interrupts.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
An interrupt represents a class of events that are detected by the
hardware or the system software. Interrupts are said to occur. An
occurrence of an interrupt is separable into generation and delivery.
Generation of an interrupt is the event in the underlying hardware or
system that makes the interrupt available to the program. Delivery is
the action that invokes part of the program as response to the interrupt
occurrence. Between generation and delivery, the interrupt occurrence
(or interrupt) is pending. Some or all interrupts may be blocked. When
an interrupt is blocked, all occurrences of that interrupt are prevented
from being delivered. Certain interrupts are reserved. The set of
reserved interrupts is implementation defined. A reserved interrupt is
either an interrupt for which user-defined handlers are not supported,
or one which already has an attached handler by some other
implementation-defined means. Program units can be connected to
non-reserved interrupts. While connected, the program unit is said to be
attached to that interrupt. The execution of that program unit, the
interrupt handler, is invoked upon delivery of the interrupt occurrence.

@item
While a handler is attached to an interrupt, it is called once for each
delivered occurrence of that interrupt. While the handler executes, the
corresponding interrupt is blocked.

@item
While an interrupt is blocked, all occurrences of that interrupt are
prevented from being delivered. Whether such occurrences remain pending
or are lost is implementation defined.

@item
Each interrupt has a default treatment which determines the system's
response to an occurrence of that interrupt when no user-defined handler
is attached. The set of possible default treatments is implementation
defined, as is the method (if one exists) for configuring the default
treatments for interrupts.

@item
An interrupt is delivered to the handler (or default treatment) that is
in effect for that interrupt at the time of delivery.

@item
An exception propagated from a handler that is invoked by an interrupt
has no effect.

@item
If the Ceiling_Locking policy, see @ref{D.3}, is in effect, the interrupt
handler executes with the active priority that is the ceiling priority
of the corresponding protected object.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall provide a mechanism to determine the minimum
stack space that is needed for each interrupt handler and to reserve
that space for the execution of the handler. This space should
accommodate nested invocations of the handler where the system permits
this.

@item
If the hardware or the underlying system holds pending interrupt
occurrences, the implementation shall provide for later delivery of
these occurrences to the program.

@item
If the Ceiling_Locking policy is not in effect, the implementation shall
provide means for the application to specify whether interrupts are to
be blocked during protected actions.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the following items:

@enumerate 13
@item
For each interrupt, which interrupts are blocked from delivery when a
handler attached to that interrupt executes (either as a result of an
interrupt delivery or of an ordinary call on a procedure of the
corresponding protected object).

@item
Any interrupts that cannot be blocked, and the effect of attaching
handlers to such interrupts, if this is permitted.

@item
Which run-time stack an interrupt handler uses when it executes as a
result of an interrupt delivery; if this is configurable, what is the
mechanism to do so; how to specify how much space to reserve on that
stack.

@item
Any implementation- or hardware-specific activity that happens before a
user-defined interrupt handler gets control (e.g., reading device
registers, acknowledging devices).

@item
Any timing or other limitations imposed on the execution of interrupt
handlers.

@item
The state (blocked/unblocked) of the non-reserved interrupts when the
program starts; if some interrupts are unblocked, what is the mechanism
a program can use to protect itself before it can attach the
corresponding handlers.

@item
Whether the interrupted task is allowed to resume execution before the
interrupt handler returns.

@item
The treatment of interrupt occurrences that are generated while the
interrupt is blocked; i.e., whether one or more occurrences are held for
later delivery, or all are lost.

@item
Whether predefined or implementation-defined exceptions are raised as a
result of the occurrence of any interrupt, and the mapping between the
machine interrupts (or traps) and the predefined exceptions.

@item
On a multi-processor, the rules governing the delivery of an interrupt
to a particular processor.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 23
@item
If the underlying system or hardware does not allow interrupts to be
blocked, then no blocking is required as part of the execution of
subprograms of a protected object whose one of its subprograms is an
interrupt handler.

@item
In a multi-processor with more than one interrupt subsystem, it is
implementation defined whether (and how) interrupt sources from separate
subsystems share the same Interrupt_ID type, see @ref{C.3.2}. In
particular, the meaning of a blocked or pending interrupt may then be
applicable to one processor only.

@item
Implementations are allowed to impose timing or other limitations on the
execution of interrupt handlers.

@item
Other forms of handlers are allowed to be supported, in which case, the
rules of this subclause should be adhered to.

@item
The active priority of the execution of an interrupt handler is allowed
to vary from one occurrence of the same interrupt to another.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If the Ceiling_Locking policy is not in effect, the implementation
should provide means for the application to specify which interrupts are
to be blocked during protected actions, if the underlying system allows
for a finer-grain control of interrupt blocking.

NOTES

@item
(1) The default treatment for an interrupt can be to keep the interrupt
pending or to deliver it to an implementation-defined handler. Examples
of actions that an implementation-defined handler is allowed to perform
include aborting the partition, ignoring (i.e., discarding occurrences
of) the interrupt, or queuing one or more occurrences of the interrupt
for possible later delivery when a user-defined handler is attached to
that interrupt.

@item
(2) It is a bounded error to call Task_Identification.Current_Task
(@pxref{C.7.1}) from an interrupt handler.

@item
(3) The rule that an exception propagated from an interrupt handler has
no effect is modeled after the rule about exceptions propagated out of
task bodies.
@end enumerate

@menu
* C.3.1:: Protected Procedure Handlers
* C.3.2:: The Package Interrupts
@end menu

@c ---------------------------------------------------------------------------
@node C.3.1, C.3.2, C.3, C.3
@subsection Protected Procedure Handlers

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate
@item
The form of a pragma Interrupt_Handler is as follows:

@item
@example
pragma Interrupt_Handler(handler_name);
@end example

@item
The form of a pragma Attach_Handler is as follows:

@item
@example
pragma Attach_Handler(handler_name, expression);
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
For the Interrupt_Handler and Attach_Handler pragmas, the handler_name
shall resolve to denote a protected procedure with a parameterless
profile.

@item
For the Attach_Handler pragma, the expected type for the expression is
Interrupts.Interrupt_ID, see @ref{C.3.2}.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The Attach_Handler pragma is only allowed immediately within the
protected_definition where the corresponding subprogram is declared. The
corresponding protected_type_declaration or single_protected_declaration
shall be a library level declaration.

@item
The Interrupt_Handler pragma is only allowed immediately within a
protected_definition. The corresponding protected_type_declaration shall
be a library level declaration. In addition, any object_declaration of
such a type shall be a library level declaration.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
If the pragma Interrupt_Handler appears in a protected_definition, then
the corresponding procedure can be attached dynamically, as a handler,
to interrupts, see @ref{C.3.2}. Such procedures are allowed to be attached
to multiple interrupts.

@item
The expression in the Attach_Handler pragma as evaluated at object
creation time specifies an interrupt. As part of the initialization of
that object, if the Attach_Handler pragma is specified, the handler
procedure is attached to the specified interrupt. A check is made that
the corresponding interrupt is not reserved. Program_Error is raised if
the check fails, and the existing treatment for the interrupt is not
affected.

@item
If the Ceiling_Locking policy, see @ref{D.3} is in effect then upon the
initialization of a protected object that either an Attach_Handler or
Interrupt_Handler pragma applies to one of its procedures, a check is
made that the ceiling priority defined in the protected_definition is in
the range of System.Interrupt_Priority. If the check fails,
Program_Error is raised.

@item
When a protected object is finalized, for any of its procedures that are
attached to interrupts, the handler is detached. If the handler was
attached by a procedure in the Interrupts package or if no user handler
was previously attached to the interrupt, the default treatment is
restored. Otherwise, that is, if an Attach_Handler pragma was used, the
previous handler is restored.

@item
When a handler is attached to an interrupt, the interrupt is blocked
(subject to the Implementation Permission in @ref{C.3}, during the
execution of every protected action on the protected object containing
the handler.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If the Ceiling_Locking policy, see @ref{D.3}, is in effect and an interrupt
is delivered to a handler, and the interrupt hardware priority is higher
than the ceiling priority of the corresponding protected object, the
execution of the program is erroneous.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The following metric shall be documented by the implementation:

@enumerate 16
@item
The worst case overhead for an interrupt handler that is a parameterless
protected procedure, in clock cycles. This is the execution time not
directly attributable to the handler procedure or the interrupted
execution. It is estimated as C - (A+B), where A is how long it takes to
complete a given sequence of instructions without any interrupt, B is
how long it takes to complete a normal call to a given protected
procedure, and C is how long it takes to complete the same sequence of
instructions when it is interrupted by one execution of the same
procedure called via an interrupt.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 17
@item
When the pragmas Attach_Handler or Interrupt_Handler apply to a
protected procedure, the implementation is allowed to impose
implementation-defined restrictions on the corresponding
protected_type_declaration and protected_body.

@item
An implementation may use a different mechanism for invoking a protected
procedure in response to a hardware interrupt than is used for a call to
that protected procedure from a task.

@item
Notwithstanding what this subclause says elsewhere, the Attach_Handler
and Interrupt_Handler pragmas are allowed to be used for other,
implementation defined, forms of interrupt handlers.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Whenever possible, the implementation should allow interrupt handlers to
be called directly by the hardware.

@item
Whenever practical, the implementation should detect violations of any
implementation-defined restrictions before run time.

NOTES

@item
(4) The Attach_Handler pragma can provide static attachment of handlers
to interrupts if the implementation supports preelaboration of protected
objects (@pxref{C.4}).

@item
(5) The ceiling priority of a protected object that one of its
procedures is attached to an interrupt should be at least as high as the
highest processor priority at which that interrupt will ever be
delivered.

@item
(6) Protected procedures can also be attached dynamically to interrupts
via operations declared in the predefined package Interrupts.

@item
(7) An example of a possible implementation-defined restriction is
disallowing the use of the standard storage pools within the body of a
protected procedure that is an interrupt handler.
@end enumerate

@c ---------------------------------------------------------------------------
@node C.3.2, C.4, C.3.1, C.3
@subsection The Package Interrupts

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined packages exist:

@item
@example
with System;
package Ada.Interrupts is
   type Interrupt_ID is implementation-defined;
   type Parameterless_Handler is
      access protected procedure;
@end example
@end enumerate

@enumerate 4
@item
@example
   function Is_Reserved (Interrupt : Interrupt_ID)
      return Boolean;
@end example

@item
@example
   function Is_Attached (Interrupt : Interrupt_ID)
      return Boolean;
@end example

@item
@example
   function Current_Handler (Interrupt : Interrupt_ID)
      return Parameterless_Handler;
@end example

@item
@example
   procedure Attach_Handler
      (New_Handler : in Parameterless_Handler;
       Interrupt   : in Interrupt_ID);
@end example

@item
@example
   procedure Exchange_Handler
      (Old_Handler : out Parameterless_Handler;
       New_Handler : in Parameterless_Handler;
       Interrupt   : in Interrupt_ID);
@end example

@item
@example
   procedure Detach_Handler
      (Interrupt : in Interrupt_ID);
@end example

@item
@example
   function Reference(Interrupt : Interrupt_ID)
      return System.Address;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Interrupts;
@end example

@item
@example
package Ada.Interrupts.Names is
   implementation-defined : constant Interrupt_ID :=
     implementation-defined;
      . . .
   implementation-defined : constant Interrupt_ID :=
     implementation-defined;
end Ada.Interrupts.Names;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The Interrupt_ID type is an implementation-defined discrete type used to
identify interrupts.

@item
The Is_Reserved function returns True if and only if the specified
interrupt is reserved.

@item
The Is_Attached function returns True if and only if a user-specified
interrupt handler is attached to the interrupt.

@item
The Current_Handler function returns a value that represents the
attached handler of the interrupt. If no user-defined handler is
attached to the interrupt, Current_Handler returns a value that
designates the default treatment; calling Attach_Handler or
Exchange_Handler with this value restores the default treatment.

@item
The Attach_Handler procedure attaches the specified handler to the
interrupt, overriding any existing treatment (including a user handler)
in effect for that interrupt. If New_Handler is null, the default
treatment is restored. If New_Handler designates a protected procedure
to which the pragma Interrupt_Handler does not apply, Program_Error is
raised. In this case, the operation does not modify the existing
interrupt treatment.

@item
The Exchange_Handler procedure operates in the same manner as
Attach_Handler with the addition that the value returned in Old_Handler
designates the previous treatment for the specified interrupt.

@item
The Detach_Handler procedure restores the default treatment for the
specified interrupt.

@item
For all operations defined in this package that take a parameter of type
Interrupt_ID, with the exception of Is_Reserved and Reference, a check
is made that the specified interrupt is not reserved. Program_Error is
raised if this check fails.

@item
If, by using the Attach_Handler, Detach_Handler, or Exchange_Handler
procedures, an attempt is made to detach a handler that was attached
statically (using the pragma Attach_Handler), the handler is not
detached and Program_Error is raised.

@item
The Reference function returns a value of type System.Address that can
be used to attach a task entry, via an address clause, see @ref{J.7.1}, to
theinterrupt specified by Interrupt. This function raises Program_Error
if attaching task entries to interrupts (or to this particular
interrupt) is not supported.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
At no time during attachment or exchange of handlers shall the current
handler of the corresponding interrupt be undefined.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
If the Ceiling_Locking policy, see @ref{D.3}, is in effect the
implementation shall document the default ceiling priority assigned to a
protected object that contains either the Attach_Handler or
Interrupt_Handler pragmas, but not the Interrupt_Priority pragma. This
default need not be the same for all interrupts.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If implementation-defined forms of interrupt handler procedures are
supported, such as protected procedures with parameters, then for each
such form of a handler, a type analogous to Parameterless_Handler should
be specified in a child package of Interrupts, with the same operations
as in the predefined package Interrupts.

NOTES

@item
(8) The package Interrupts.Names contains implementation-defined names
(and constant values) for the interrupts that are supported by the
implementation.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of interrupt handlers:

@item
@example
Device_Priority : constant
  array (1..5) of System.Interrupt_Priority := ( ... );
protected type Device_Interface
  (Int_ID : Ada.Interrupts.Interrupt_ID) is
  procedure Handler;
  pragma Attach_Handler(Handler, Int_ID);
  ...
  pragma Interrupt_Priority(Device_Priority(Int_ID));
end Device_Interface;
  ...
Device_1_Driver : Device_Interface(1);
  ...
Device_5_Driver : Device_Interface(5);
  ...
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node C.4, C.5, C.3.2, C
@section Preelaboration Requirements

@enumerate
@item
This clause specifies additional implementation and documentation
requirements for the Preelaborate pragma, see @ref{10.2.1}.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall not incur any run-time overhead for the
elaboration checks of subprograms and protected_bodies declared in
preelaborated library units.

@item
The implementation shall not execute any memory write operations after
load time for the elaboration of constant objects declared immediately
within the declarative region of a preelaborated library package, so
long as the subtype and initial expression (or default initial
expressions if initialized by default) of the object_declaration satisfy
the following restrictions. The meaning of load time is implementation
defined.

@enumerate 4
@item
Any subtype_mark denotes a statically constrained subtype, with
statically constrained subcomponents, if any;

@item
any constraint is a static constraint;

@item
any allocator is for an access-to-constant type;

@item
any uses of predefined operators appear only within static expressions;

@item
any primaries that are names, other than attribute_references for the
Access or Address attributes, appear only within static expressions;

@item
any name that is not part of a static expression is an expanded name or
direct_name that statically denotes some entity;

@item
any discrete_choice of an array_aggregate is static;

@item
no language-defined check associated with the elaboration of the
object_declaration can fail.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@enumerate 12
@item
The implementation shall document any circumstances under which the
elaboration of a preelaborated package causes code to be executed at run
time.

@item
The implementation shall document whether the method used for
initialization of preelaborated variables allows a partition to be
restarted without reloading.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
It is recommended that preelaborated packages be implemented in such a
way that there should be little or no code executed at run time for the
elaboration of entities not already covered by the Implementation
Requirements.
@end enumerate

@c ---------------------------------------------------------------------------
@node C.5, C.6, C.4, C
@section Pragma Discard_Names

@enumerate
@item
A pragma Discard_Names may be used to request a reduction in storage
used for the names of certain entities.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Discard_Names is as follows:

@item
@example
pragma Discard_Names[([On => ] local_name)];
@end example

@enumerate 4
@item
A pragma Discard_Names is allowed only immediately within a
declarative_part, immediately within a package_specification, or as a
configuration pragma.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 5
@item
The local_name (if present) shall denote a non-derived enumeration first
subtype, a tagged first subtype, or an exception. The pragma applies to
the type or exception. Without a local_name, the pragma applies to all
such entities declared after the pragma, within the same declarative
region. Alternatively, the pragma can be used as a configuration pragma.
If the pragma applies to a type, then it applies also to all descendants
of the type.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
If a local_name is given, then a pragma Discard_Names is a
representation pragma.

@item
If the pragma applies to an enumeration type, then the semantics of the
Wide_Image and Wide_Value attributes are implementation defined for that
type; the semantics of Image and Value are still defined in terms of
Wide_Image and Wide_Value. In addition, the semantics of
Text_IO.Enumeration_IO are implementation defined. If the pragma applies
to a tagged type, then the semantics of the Tags.Expanded_Name function
are implementation defined for that type. If the pragma applies to an
exception, then the semantics of the Exceptions.Exception_Name function
are implementation defined for that exception.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If the pragma applies to an entity, then the implementation should
reduce the amount of storage used for storing names associated with that
entity.
@end enumerate

@c ---------------------------------------------------------------------------
@node C.6, C.7, C.5, C
@section Shared Variable Control

@enumerate
@item
This clause specifies representation pragmas that control the use of
shared variables.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form for pragmas Atomic, Volatile, Atomic_Components, and
Volatile_Components is as follows:

@item
@example
pragma Atomic(local_name);
@end example

@item
@example
pragma Volatile(local_name);
@end example

@item
@example
pragma Atomic_Components(array_local_name);
@end example

@item
@example
pragma Volatile_Components(array_local_name);
@end example

@item
An atomic type is one to which a pragma Atomic applies. An atomic object
(including a component) is one to which a pragma Atomic applies, or a
component of an array to which a pragma Atomic_Components applies, or
any object of an atomic type.

@item
A volatile type is one to which a pragma Volatile applies. A volatile
object (including a component) is one to which a pragma Volatile
applies, or a component of an array to which a pragma
Volatile_Components applies, or any object of a volatile type. In
addition, every atomic type or object is also defined to be volatile.
Finally, if an object is volatile, then so are all of its subcomponents
(the same does not apply to atomic).

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The local_name in an Atomic or Volatile pragma shall resolve to denote
either an object_declaration, a non-inherited component_declaration, or
a full_type_declaration. The array_local_name in an Atomic_Components or
Volatile_Components pragma shall resolve to denote the declaration of an
array type or an array object of an anonymous type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
It is illegal to apply either an Atomic or Atomic_Components pragma to
an object or type if the implementation cannot support the indivisible
reads and updates required by the pragma (see below).

@item
It is illegal to specify the Size attribute of an atomic object, the
Component_Size attribute for an array type with atomic components, or
the layout attributes of an atomic component, in a way that prevents the
implementation from performing the required indivisible reads and
updates.

@item
If an atomic object is passed as a parameter, then the type of the
formal parameter shall either be atomic or allow pass by copy (that is,
not be a nonatomic by-reference type). If an atomic object is used as an
actual for a generic formal object of mode in out, then the type of the
generic formal object shall be atomic. If the prefix of an
attribute_reference for an Access attribute denotes an atomic object
(including a component), then the designated type of the resulting
access type shall be atomic. If an atomic type is used as an actual for
a generic formal derived type, then the ancestor of the formal type
shall be atomic or allow pass by copy. Corresponding rules apply to
volatile objects and types.

@item
If a pragma Volatile, Volatile_Components, Atomic, or Atomic_Components
applies to a stand-alone constant object, then a pragma Import shall
also apply to it.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
These pragmas are representation pragmas, see @ref{13.1}.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For an atomic object (including an atomic component) all reads and
updates of the object as a whole are indivisible.

@item
For a volatile object all reads and updates of the object as a whole are
performed directly to memory.

@item
Two actions are sequential, see @ref{9.10}, if each is the read or update
of the same atomic object.

@item
If a type is atomic or volatile and it is not a by-copy type, then the
type is defined to be a by-reference type. If any subcomponent of a type
is atomic or volatile, then the type is defined to be a by-reference
type.

@item
If an actual parameter is atomic or volatile, and the corresponding
formal parameter is not, then the parameter is passed by copy.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The external effect of a program, see @ref{1.1.3}, is defined to include
each read and update of a volatile or atomic object. The implementation
shall not generate any memory reads or updates of atomic or volatile
objects other than those specified by the program.

@item
If a pragma Pack applies to a type any of whose subcomponents are
atomic, the implementation shall not pack the atomic subcomponents more
tightly than that for which it can support indivisible reads and
updates.

NOTES

@item
(9) An imported volatile or atomic constant behaves as a constant (i.e.
read-only) with respect to other parts of the Ada program, but can still
be modified by an ``external source.''
@end enumerate

@c ---------------------------------------------------------------------------
@node C.7, C.7.1, C.6, C
@section Task Identification and Attributes

@enumerate
@item
This clause describes operations and attributes that can be used to
obtain the identity of a task. In addition, a package that associates
user-defined information with a task is defined.
@end enumerate

@menu
* C.7.1:: The Package Task_Identification
* C.7.2:: The Package Task_Attributes
@end menu

@c ---------------------------------------------------------------------------
@node C.7.1, C.7.2, C.7, C.7
@subsection The Package Task_Identification

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined library package exists:

@item
@example
package Ada.Task_Identification is
   type Task_ID is private;
   Null_Task_ID : constant Task_ID;
   function  "=" (Left, Right : Task_ID) return Boolean;
@end example

@item
@example
   function  Image        (T : Task_ID) return String;
   function  Current_Task return Task_ID;
   procedure Abort_Task   (T : in out Task_ID);
@end example

@item
@example
   function  Is_Terminated(T : Task_ID) return Boolean;
   function  Is_Callable  (T : Task_ID) return Boolean;
private
   ... -- not specified by the language
end Ada.Task_Identification;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A value of the type Task_ID identifies an existent task. The constant
Null_Task_ID does not identify any task. Each object of the type Task_ID
is default initialized to the value of Null_Task_ID.

@item
The function "=" returns True if and only if Left and Right identify the
same task or both have the value Null_Task_ID.

@item
The function Image returns an implementation-defined string that
identifies T. If T equals Null_Task_ID, Image returns an empty string.

@item
The function Current_Task returns a value that identifies the calling
task.

@item
The effect of Abort_Task is the same as the abort_statement for the task
identified by T. In addition, if T identifies the environment task, the
entire partition is aborted, see @ref{E.1}.

@item
The functions Is_Terminated and Is_Callable return the value of the
corresponding attribute of the task identified by T.

@item
For a prefix T that is of a task type (after any implicit dereference),
the following attribute is defined:

@item
T'Identity

@item
@example
Yields a value of the type Task_ID that identifies the task
denoted by T.
@end example

@item
For a prefix E that denotes an entry_declaration, the following
attribute is defined:

@item
E'Caller

@example
Yields a value of the type Task_ID that identifies the task
whose call is now being serviced. Use of this attribute is
allowed only inside an entry_body or accept_statement
corresponding to the entry_declaration denoted by E.
@end example

@item
Program_Error is raised if a value of Null_Task_ID is passed as a
parameter to Abort_Task, Is_Terminated, and Is_Callable.

@item
Abort_Task is a potentially blocking operation, see @ref{9.5.1}.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
It is a bounded error to call the Current_Task function from an entry
body or an interrupt handler. Program_Error is raised, or an
implementation-defined value of the type Task_ID is returned.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If a value of Task_ID is passed as a parameter to any of the operations
declared in this package (or any language-defined child of this
package), and the corresponding task object no longer exists, the
execution of the program is erroneous.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the effect of calling Current_Task
from an entry body or interrupt handler.

NOTES

@item
(10) This package is intended for use in writing user-defined task
scheduling packages and constructing server tasks. Current_Task can be
used in conjunction with other operations requiring a task as an
argument such as Set_Priority, see @ref{D.5}.

@item
(11) The function Current_Task and the attribute Caller can return a
Task_ID value that identifies the environment task.
@end enumerate

@c ---------------------------------------------------------------------------
@node C.7.2, D, C.7.1, C.7
@subsection The Package Task_Attributes

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following language-defined generic library package exists:

@item
@example
with Ada.Task_Identification; use Ada.Task_Identification;
generic
   type Attribute is private;
   Initial_Value : in Attribute;
package Ada.Task_Attributes is
@end example

@item
@example
   type Attribute_Handle is access all Attribute;
@end example

@item
@example
   function Value(T : Task_ID := Current_Task)
     return Attribute;
@end example

@item
@example
   function Reference(T : Task_ID := Current_Task)
     return Attribute_Handle;
@end example

@item
@example
   procedure Set_Value(Val : in Attribute;
                       T   : in Task_ID := Current_Task);
   procedure Reinitialize(T : in Task_ID := Current_Task);
@end example

@item
@example
end Ada.Task_Attributes;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
When an instance of Task_Attributes is elaborated in a given active
partition, an object of the actual type corresponding to the formal type
Attribute is implicitly created for each task (of that partition) that
exists and is not yet terminated. This object acts as a user-defined
attribute of the task. A task created previously in the partition and
not yet terminated has this attribute from that point on. Each task
subsequently created in the partition will have this attribute when
created. In all these cases, the initial value of the given attribute is
Initial_Value.

@item
The Value operation returns the value of the corresponding attribute of
T.

@item
The Reference operation returns an access value that designates the
corresponding attribute of T.

@item
The Set_Value operation performs any finalization on the old value of
the attribute of T and assigns Val to that attribute, see @ref{5.2}, and
@ref{7.6}.

@item
The effect of the Reinitialize operation is the same as Set_Value where
the Val parameter is replaced with Initial_Value.

@item
For all the operations declared in this package, Tasking_Error is raised
if the task identified by T is terminated. Program_Error is raised if
the value of T is Null_Task_ID.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
It is erroneous to dereference the access value returned by a given call
on Reference after a subsequent call on Reinitialize for the same task
attribute, or after the associated task terminates.

@item
If a value of Task_ID is passed as a parameter to any of the operations
declared in this package and the corresponding task object no longer
exists, the execution of the program is erroneous.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall perform each of the above operations for a
given attribute of a given task atomically with respect to any other of
the above operations for the same attribute of the same task.

@item
When a task terminates, the implementation shall finalize all attributes
of the task, and reclaim any other storage associated with the
attributes.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the limit on the number of attributes
per task, if any, and the limit on the total storage for attribute
values per task, if such a limit exists.

@item
In addition, if these limits can be configured, the implementation shall
document how to configure them.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The implementation shall document the following metrics: A task calling
the following subprograms shall execute in a sufficiently high priority
as to not be preempted during the measurement period. This period shall
start just before issuing the call and end just after the call
completes. If the attributes of task T are accessed by the measurement
tests, no other task shall access attributes of that task during the
measurement period. For all measurements described here, the Attribute
type shall be a scalar whose size is equal to the size of the predefined
integer size. For each measurement, two cases shall be documented: one
where the accessed attributes are of the calling task (that is, the
default value for the T parameter is used), and the other, where T
identifies another, non-terminated, task.

@item
The following calls (to subprograms in the Task_Attributes package)
shall be measured:

@enumerate 22
@item
a call to Value, where the return value is Initial_Value;

@item
a call to Value, where the return value is not equal to Initial_Value;

@item
a call to Reference, where the return value designates a value equal to
Initial_Value;

@item
a call to Reference, where the return value designates a value not equal
to Initial_Value;

@item
a call to Set_Value where the Val parameter is not equal to
Initial_Value and the old attribute value is equal to Initial_Value.

@item
a call to Set_Value where the Val parameter is not equal to
Initial_Value and the old attribute value is not equal to Initial_Value.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 28
@item
An implementation need not actually create the object corresponding to a
task attribute until its value is set to something other than that of
Initial_Value, or until Reference is called for the task attribute.
Similarly, when the value of the attribute is to be reinitialized to
that of Initial_Value, the object may instead be finalized and its
storage reclaimed, to be recreated when needed later. While the object
does not exist, the function Value may simply return Initial_Value,
rather than implicitly creating the object.

@item
An implementation is allowed to place restrictions on the maximum number
of attributes a task may have, the maximum size of each attribute, and
the total storage size allocated for all the attributes of a task.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Some implementations are targeted to domains in which memory use at run
time must be completely deterministic. For such implementations, it is
recommended that the storage for task attributes will be pre-allocated
statically and not from the heap. This can be accomplished by either
placing restrictions on the number and the size of the task's
attributes, or by using the pre-allocated storage for the first N
attribute objects, and the heap for the others. In the latter case, N
should be documented.

NOTES

@item
(12) An attribute always exists (after instantiation), and has the
initial value. It need not occupy memory until the first operation that
potentially changes the attribute value. The same holds true after
Reinitialize.

@item
(13) The result of the Reference function should be used with care; it
is always safe to use that result in the task body whose attribute is
being accessed. However, when the result is being used by another task,
the programmer must make sure that the task whose attribute is being
accessed is not yet terminated. Failing to do so could make the program
execution erroneous.

@item
(14) As specified in @ref{C.7.1}, if the parameter T (in a call on a
subprogram of an instance of this package) identifies a nonexistent
task, the execution of the program is erroneous.
@end enumerate

@c ===========================================================================
@node D, D.1, C.7.2, Top
@appendix  Real-Time Systems (normative)

@enumerate
@item
This Annex specifies additional characteristics of Ada implementations
intended for real-time systems software. To conform to this Annex, an
implementation shall also conform to the Systems Programming Annex.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The metrics are documentation requirements; an implementation shall
document the values of the language-defined metrics for at least one
configuration of hardware or an underlying system supported by the
implementation, and shall document the details of that configuration.

@item
The metrics do not necessarily yield a simple number. For some, a range
is more suitable, for others a formula dependent on some parameter is
appropriate, and for others, it may be more suitable to break the metric
into several cases. Unless specified otherwise, the metrics in this
annex are expressed in processor clock cycles. For metrics that require
documentation of an upper bound, if there is no upper bound, the
implementation shall report that the metric is unbounded.

NOTES

@item
(1) The specification of the metrics makes a distinction between upper
bounds and simple execution times. Where something is just specified as
``the execution time of'' a piece of code, this leaves one the freedom
to choose a nonpathological case. This kind of metric is of the form
``there exists a program such that the value of the metric is V''.
Conversely, the meaning of upper bounds is ``there is no program such
that the value of the metric is greater than V''. This kind of metric
can only be partially tested, by finding the value of V for one or more
test programs.

@item
(2) The metrics do not cover the whole language; they are limited to
features that are specified in @ref{C, ``Systems Programming''},
and in this Annex. The metrics are intended to provide guidance to
potential users as to whether a particular implementation of such a
feature is going to be adequate for a particular real-time application.
As such, the metrics are aimed at known implementation choices that can
result in significant performance differences.

@item
(3) The purpose of the metrics is not necessarily to provide
fine-grained quantitative results or to serve as a comparison between
different implementations on the same or different platforms. Instead,
their goal is rather qualitative; to define a standard set of
approximate values that can be measured and used to estimate the general
suitability of an implementation, or to evaluate the comparative utility
of certain features of an implementation for a particular real-time
application.
@end enumerate

@menu
* D.1::  Task Priorities
* D.2::  Priority Scheduling
* D.3::  Priority Ceiling Locking
* D.4::  Entry Queuing Policies
* D.5::  Dynamic Priorities
* D.6::  Preemptive Abort
* D.7::  Tasking Restrictions
* D.8::  Monotonic Time
* D.9::  Delay Accuracy
* D.10:: Synchronous Task Control
* D.11:: Asynchronous Task Control
* D.12:: Other Optimizations and Determinism Rules

--- The Detailed Node Listing ---

* D.1::   Task Priorities
* D.2::   Priority Scheduling
* D.2.1:: The Task Dispatching Model
* D.2.2:: The Standard Task Dispatching Policy
* D.3::   Priority Ceiling Locking
* D.4::   Entry Queuing Policies
* D.5::   Dynamic Priorities
* D.6::   Preemptive Abort
* D.7::   Tasking Restrictions
* D.8::   Monotonic Time
* D.9::   Delay Accuracy
* D.10::  Synchronous Task Control
* D.11::  Asynchronous Task Control
* D.12::  Other Optimizations and Determinism Rules
@end menu

@c ---------------------------------------------------------------------------
@node D.1, D.2, D, D
@section Task Priorities

@enumerate
@item
This clause specifies the priority model for real-time systems. In
addition, the methods for specifying priorities are defined.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Priority is as follows:

@item
@example
pragma Priority(expression);
@end example

@item
The form of a pragma Interrupt_Priority is as follows:

@item
@example
pragma Interrupt_Priority[(expression)];
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expected type for the expression in a Priority or Interrupt_Priority
pragma is Integer.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A Priority pragma is allowed only immediately within a task_definition,
a protected_definition, or the declarative_part of a subprogram_body. An
Interrupt_Priority pragma is allowed only immediately within a task_
definition or a protected_definition. At most one such pragma shall
appear within a given construct.

@item
For a Priority pragma that appears in the declarative_part of a
subprogram_body, the expression shall be static, and its value shall be
in the range of System.Priority.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following declarations exist in package System:

@item
@example
subtype Any_Priority is Integer range implementation-defined;
subtype Priority is Any_Priority range
  Any_Priority'First .. implementation-defined;
subtype Interrupt_Priority is Any_Priority range
  Priority'Last+1 .. Any_Priority'Last;
@end example

@item
@example
Default_Priority : constant Priority
  := (Priority'First + Priority'Last)/2;
@end example

@item
The full range of priority values supported by an implementation is
specified by the subtype Any_Priority. The subrange of priority values
that are high enough to require the blocking of one or more interrupts
is specified by the subtype Interrupt_Priority. The subrange of priority
values below System.Interrupt_Priority'First is specified by the subtype
System.Priority.

@item
The priority specified by a Priority or Interrupt_Priority pragma is the
value of the expression in the pragma, if any. If there is no expression
in an Interrupt_Priority pragma, the priority value is
Interrupt_Priority'Last.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A Priority pragma has no effect if it occurs in the declarative_part of
the subprogram_body of a subprogram other than the main subprogram.

@item
A task priority is an integer value that indicates a degree of urgency
and is the basis for resolving competing demands of tasks for resources.
Unless otherwise specified, whenever tasks compete for processors or
other implementation-defined resources, the resources are allocated to
the task with the highest priority value. The base priority of a task is
the priority with which it was created, or to which it was later set by
Dynamic_Priorities.Set_Priority, see @ref{D.5}. At all times, a task also
has an active priority, which generally reflects its base priority as
well as any priority it inherits from other sources. Priority
inheritance is the process by which the priority of a task or other
entity (e.g. a protected object, see @ref{D.3}) is used in the evaluation
of another task's active priority.

@item
The effect of specifying such a pragma in a protected_definition is
discussed in @ref{D.3}.

@item
The expression in a Priority or Interrupt_Priority pragma that appears
in a task_definition is evaluated for each task object, see @ref{9.1}. For
a Priority pragma, the value of the expression is converted to the
subtype Priority; for an Interrupt_Priority pragma, this value is
converted to the subtype Any_Priority. The priority value is then
associated with the task object whose task_definition contains the
pragma.

@item
Likewise, the priority value is associated with the environment task if
the pragma appears in the declarative_part of the main subprogram.

@item
The initial value of a task's base priority is specified by default or
by means of a Priority or Interrupt_Priority pragma. After a task is
created, its base priority can be changed only by a call to
Dynamic_Priorities.Set_Priority, see @ref{D.5}. The initial base priority
of a task in the absence of a pragma is the base priority of the task
that creates it at the time of creation, see @ref{9.1}. If a pragma
Priority does not apply to the main subprogram, the initial base
priority of the environment task is System.Default_Priority. The task's
active priority is used when the task competes for processors.
Similarly, the task's active priority is used to determine the task's
position in any queue when Priority_Queuing is specified, see @ref{D.4}.

@item
At any time, the active priority of a task is the maximum of all the
priorities the task is inheriting at that instant. For a task that is
not held, see @ref{D.11}, its base priority is always a source of priority
inheritance. Other sources of priority inheritance are specified under
the following conditions:

@enumerate 21
@item
During activation, a task being activated inherits the active priority
of the its activator, see @ref{9.2}.

@item
During rendezvous, the task accepting the entry call inherits the active
priority of the caller, see @ref{9.5.3}.

@item
During a protected action on a protected object, a task inherits the
ceiling priority of the protected object, see @ref{9.5}, and @ref{D.3}.
@end enumerate
@end enumerate

@enumerate 24
@item
In all of these cases, the priority ceases to be inherited as soon as
the condition calling for the inheritance no longer exists.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The range of System.Interrupt_Priority shall include at least one value.

@item
The range of System.Priority shall include at least 30 values.

NOTES

@item
(4) The priority expression can include references to discriminants of
the enclosing type.

@item
(5) It is a consequence of the active priority rules that at the point
when a task stops inheriting a priority from another source, its active
priority is re-evaluated. This is in addition to other instances
described in this Annex for such re-evaluation.

@item
(6) An implementation may provide a non-standard mode in which tasks
inherit priorities under conditions other than those specified above.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.2, D.2.1, D.1, D
@section Priority Scheduling

@enumerate
@item
This clause describes the rules that determine which task is selected
for execution when more than one task is ready, see @ref{9.2}. The rules
have two parts: the task dispatching model, see @ref{D.2.1}, and a specific
task dispatching policy, see @ref{D.2.2}.
@end enumerate

@menu
* D.2.1:: The Task Dispatching Model
* D.2.2:: The Standard Task Dispatching Policy
@end menu

@c ---------------------------------------------------------------------------
@node D.2.1, D.2.2, D.2, D.2
@subsection The Task Dispatching Model

@enumerate
@item
The task dispatching model specifies preemptive scheduling, based on
conceptual priority-ordered ready queues.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A task runs (that is, it becomes a running task) only when it is ready
(@pxref{9.2}) and the execution resources required by that task are
available. Processors are allocated to tasks based on each task's active
priority.

@item
It is implementation defined whether, on a multiprocessor, a task that
is waiting for access to a protected object keeps its processor busy.

@item
Task dispatching is the process by which one ready task is selected for
execution on a processor. This selection is done at certain points
during the execution of a task called task dispatching points. A task
reaches a task dispatching point whenever it becomes blocked, and
whenever it becomes ready. In addition, the completion of an
accept_statement, see @ref{9.5.2}, and task termination are task
dispatching points for the executing task. Other task dispatching points
are defined throughout this Annex.

@item
Task dispatching policies are specified in terms of conceptual ready
queues, task states, and task preemption. A ready queue is an ordered
list of ready tasks. The first position in a queue is called the head of
the queue, and the last position is called the tail of the queue. A task
is ready if it is in a ready queue, or if it is running. Each processor
has one ready queue for each priority value. At any instant, each ready
queue of a processor contains exactly the set of tasks of that priority
that are ready for execution on that processor, but are not running on
any processor; that is, those tasks that are ready, are not running on
any processor, and can be executed using that processor and other
available resources. A task can be on the ready queues of more than one
processor.

@item
Each processor also has one running task, which is the task currently
being executed by that processor. Whenever a task running on a processor
reaches a task dispatching point, one task is selected to run on that
processor. The task selected is the one at the head of the highest
priority nonempty ready queue; this task is then removed from all ready
queues to which it belongs.

@item
A preemptible resource is a resource that while allocated to one task
can be allocated (temporarily) to another instead. Processors are
preemptible resources. Access to a protected object, see @ref{9.5.1}, is a
nonpreemptible resource. When a higher-priority task is dispatched to
the processor, and the previously running task is placed on the
appropriate ready queue, the latter task is said to be preempted.

@item
A new running task is also selected whenever there is a nonempty ready
queue with a higher priority than the priority of the running task, or
when the task dispatching policy requires a running task to go back to a
ready queue. These are also task dispatching points.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation is allowed to define additional resources as execution
resources, and to define the corresponding allocation policies for them.
Such resources may have an implementation defined effect on task
dispatching, see @ref{D.2.2}.

@item
An implementation may place implementation-defined restrictions on tasks
whose active priority is in the Interrupt_Priority range.

NOTES

@item
(7) Section @ref{9} specifies under which circumstances a task becomes
ready. The ready state is affected by the rules for task activation and
termination, delay statements, and entry calls. When a task is not
ready, it is said to be blocked.

@item
(8) An example of a possible implementation-defined execution resource
is a page of physical memory, which needs to be loaded with a particular
page of virtual memory before a task can continue execution.

@item
(9) The ready queues are purely conceptual; there is no requirement that
such lists physically exist in an implementation.

@item
(10) While a task is running, it is not on any ready queue. Any time the
task that is running on a processor is added to a ready queue, a new
running task is selected for that processor.

@item
(11) In a multiprocessor system, a task can be on the ready queues of
more than one processor. At the extreme, if several processors share the
same set of ready tasks, the contents of their ready queues is
identical, and so they can be viewed as sharing one ready queue, and can
be implemented that way. Thus, the dispatching model covers
multiprocessors where dispatching is implemented using a single ready
queue, as well as those with separate dispatching domains.

@item
(12) The priority of a task is determined by rules specified in this
subclause, and under @ref{D.1, ``Task Priorities''}, @ref{D.3,
``Priority Ceiling Locking''}, and @ref{D.5, ``Dynamic Priorities''}.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.2.2, D.3, D.2.1, D.2
@subsection The Standard Task Dispatching Policy

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate
@item
The form of a pragma Task_Dispatching_Policy is as follows:

@item
@example
pragma Task_Dispatching_Policy(policy_identifier );
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The policy_identifier shall either be FIFO_Within_Priorities or an
implementation-defined identifier.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A Task_Dispatching_Policy pragma is a configuration pragma.

@item
If the FIFO_Within_Priorities policy is specified for a partition, then
the Ceiling_Locking policy, see @ref{D.3} shall also be specified for the
partition.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A task dispatching policy specifies the details of task dispatching that
are not covered by the basic task dispatching model. These rules govern
when tasks are inserted into and deleted from the ready queues, and
whether a task is inserted at the head or the tail of the queue for its
active priority. The task dispatching policy is specified by a
Task_Dispatching_Policy configuration pragma. If no such pragma appears
in any of the program units comprising a partition, the task dispatching
policy for that partition is unspecified.

@item
The language defines only one task dispatching policy,
FIFO_Within_Priorities; when this policy is in effect, modifications to
the ready queues occur only as follows:

@enumerate 8
@item
When a blocked task becomes ready, it is added at the tail of the ready
queue for its active priority.

@item
When the active priority of a ready task that is not running changes, or
the setting of its base priority takes effect, the task is removed from
the ready queue for its old active priority and is added at the tail of
the ready queue for its new active priority, except in the case where
the active priority is lowered due to the loss of inherited priority, in
which case the task is added at the head of the ready queue for its new
active priority.

@item
When the setting of the base priority of a running task takes effect,
the task is added to the tail of the ready queue for its active
priority.

@item
When a task executes a delay_statement that does not result in blocking,
it is added to the tail of the ready queue for its active priority.
@end enumerate
@end enumerate

@enumerate 12
@item
Each of the events specified above is a task dispatching point
(@pxref{D.2.1}).

@item
In addition, when a task is preempted, it is added at the head of the
ready queue for its active priority.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
Priority inversion is the duration for which a task remains at the head
of the highest priority ready queue while the processor executes a lower
priority task. The implementation shall document:

@enumerate 15
@item
The maximum priority inversion a user task can experience due to
activity of the implementation (on behalf of lower priority tasks), and

@item
whether execution of a task can be preempted by the implementation
processing of delay expirations for lower priority tasks, and if so, for
how long.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 17
@item
Implementations are allowed to define other task dispatching policies,
but need not support more than one such policy per partition.

@item
For optimization purposes, an implementation may alter the points at
which task dispatching occurs, in an implementation defined manner.
However, a delay_statement always corresponds to at least one task
dispatching point.

NOTES

@item
(13) If the active priority of a running task is lowered due to loss of
inherited priority (as it is on completion of a protected operation) and
there is a ready task of the same active priority that is not running,
the running task continues to run (provided that there is no higher
priority task).

@item
(14) The setting of a task's base priority as a result of a call to
Set_Priority does not always take effect immediately when Set_Priority
is called. The effect of setting the task's base priority is deferred
while the affected task performs a protected action.

@item
(15) Setting the base priority of a ready task causes the task to move
to the end of the queue for its active priority, regardless of whether
the active priority of the task actually changes.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.3, D.4, D.2.2, D
@section Priority Ceiling Locking

@enumerate
@item
This clause specifies the interactions between priority task scheduling
and protected object ceilings. This interaction is based on the concept
of the ceiling priority of a protected object.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Locking_Policy is as follows:

@item
@example
pragma Locking_Policy(policy_identifier);
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The policy_identifier shall either be Ceiling_Locking or an
implementation-defined identifier.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A Locking_Policy pragma is a configuration pragma.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A locking policy specifies the details of protected object locking.
These rules specify whether or not protected objects have priorities,
and the relationships between these priorities and task priorities. In
addition, the policy specifies the state of a task when it executes a
protected action, and how its active priority is affected by the
locking. The locking policy is specified by a Locking_Policy pragma. For
implementation-defined locking policies, the effect of a Priority or
Interrupt_Priority pragma on a protected object is implementation
defined. If no Locking_Policy pragma appears in any of the program units
comprising a partition, the locking policy for that partition, as well
as the effect of specifying either a Priority or Interrupt_Priority
pragma for a protected object, are implementation defined.

@item
There is one predefined locking policy, Ceiling_Locking; this policy is
defined as follows:

@enumerate 8
@item
Every protected object has a ceiling priority, which is determined by
either a Priority or Interrupt_Priority pragma as defined in D.1. The
ceiling priority of a protected object (or ceiling, for short) is an
upper bound on the active priority a task can have when it calls
protected operations of that protected object.

@item
The expression of a Priority or Interrupt_Priority pragma is evaluated
as part of the creation of the corresponding protected object and
converted to the subtype System.Any_Priority or
System.Interrupt_Priority, respectively. The value of the expression is
the ceiling priority of the corresponding protected object.

@item
If an Interrupt_Handler or Attach_Handler pragma, see @ref{C.3.1}, appears
in a protected_definition without an Interrupt_Priority pragma, the
ceiling priority of protected objects of that type is implementation
defined, but in the range of the subtype System.Interrupt_Priority.

@item
If no pragma Priority, Interrupt_Priority, Interrupt_Handler, or
Attach_Handler is specified in the protected_definition, then the
ceiling priority of the corresponding protected object is
System.Priority'Last.

@item
While a task executes a protected action, it inherits the ceiling
priority of the corresponding protected object.

@item
When a task calls a protected operation, a check is made that its active
priority is not higher than the ceiling of the corresponding protected
object; Program_Error is raised if this check fails.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 14
@item
The implementation is allowed to round all ceilings in a certain
subrange of System.Priority or System.Interrupt_Priority up to the top
of that subrange, uniformly.

@item
Implementations are allowed to define other locking policies, but need
not support more than one such policy per partition.

@item
Since implementations are allowed to place restrictions on code that
runs at an interrupt-level active priority, see @ref{C.3.1}, and
@ref{D.2.1}, the implementation may implement a language feature in
terms of a protected object with an implementation-defined ceiling, but
the ceiling shall be no less than Priority'Last.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The implementation should use names that end with ``_Locking'' for
implementation-defined locking policies.

NOTES

@item
(16) While a task executes in a protected action, it can be preempted
only by tasks whose active priorities are higher than the ceiling
priority of the protected object.

@item
(17) If a protected object has a ceiling priority in the range of
Interrupt_Priority, certain interrupts are blocked while protected
actions of that object execute. In the extreme, if the ceiling is
Interrupt_Priority'Last, all blockable interrupts are blocked during
that time.

@item
(18) The ceiling priority of a protected object has to be in the
Interrupt_Priority range if one of its procedures is to be used as an
interrupt handler, see @ref{C.3}.

@item
(19) When specifying the ceiling of a protected object, one should
choose a value that is at least as high as the highest active priority
at which tasks can be executing when they call protected operations of
that object. In determining this value the following factors, which can
affect active priority, should be considered: the effect of
Set_Priority, nested protected operations, entry calls, task activation,
and other implementation-defined factors.

@item
(20) Attaching a protected procedure whose ceiling is below the
interrupt hardware priority to an interrupt causes the execution of the
program to be erroneous, see @ref{C.3.1}.

@item
(21) On a single processor implementation, the ceiling priority rules
guarantee that there is no possibility of deadlock involving only
protected subprograms (excluding the case where a protected operation
calls another protected operation on the same protected object).
@end enumerate

@c ---------------------------------------------------------------------------
@node D.4, D.5, D.3, D
@section Entry Queuing Policies

@enumerate
@item
This clause specifies a mechanism for a user to choose an entry queuing
policy. It also defines one such policy. Other policies are
implementation defined.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Queuing_Policy is as follows:

@item
@example
pragma Queuing_Policy(policy_identifier);
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The policy_identifier shall be either FIFO_Queuing, Priority_Queuing or
an implementation-defined identifier.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A Queuing_Policy pragma is a configuration pragma.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A queuing policy governs the order in which tasks are queued for entry
service, and the order in which different entry queues are considered
for service. The queuing policy is specified by a Queuing_Policy pragma.

@item
Two queuing policies, FIFO_Queuing and Priority_Queuing, are language
defined. If no Queuing_Policy pragma appears in any of the program units
comprising the partition, the queuing policy for that partition is
FIFO_Queuing. The rules for this policy are specified in @ref{9.5.3},
and @ref{9.7.1}.

@item
The Priority_Queuing policy is defined as follows:

@enumerate 9
@item
The calls to an entry (including a member of an entry family) are queued
in an order consistent with the priorities of the calls. The priority of
an entry call is initialized from the active priority of the calling
task at the time the call is made, but can change later. Within the same
priority, the order is consistent with the calling (or requeuing, or
priority setting) time (that is, a FIFO order).

@item
After a call is first queued, changes to the active priority of a task
do not affect the priority of the call, unless the base priority of the
task is set.

@item
When the base priority of a task is set, see @ref{D.5}, if the task is
blocked on an entry call, and the call is queued, the priority of the
call is updated to the new active priority of the calling task. This
causes the call to be removed from and then reinserted in the queue at
the new active priority.

@item
When more than one condition of an entry_barrier of a protected object
becomes True, and more than one of the respective queues is nonempty,
the call with the highest priority is selected. If more than one such
call has the same priority, the call that is queued on the entry whose
declaration is first in textual order in the protected_definition is
selected. For members of the same entry family, the one with the lower
family index is selected.

@item
If the expiration time of two or more open delay_alternatives is the
same and no other accept_alternatives are open, the
sequence_of_statements of the delay_alternative that is first in textual
order in the selective_accept is executed.

@item
When more than one alternative of a selective_accept is open and has
queued calls, an alternative whose queue has the highest-priority call
at its head is selected. If two or more open alternatives have
equal-priority queued calls, then a call on the entry in the
accept_alternative that is first in textual order in the
selective_accept is selected.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 15
@item
Implementations are allowed to define other queuing policies, but need
not support more than one such policy per partition.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The implementation should use names that end with ``_Queuing'' for
implementation-defined queuing policies.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.5, D.6, D.4, D
@section Dynamic Priorities

@enumerate
@item
This clause specifies how the base priority of a task can be modified or
queried at run time.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
with System;
with Ada.Task_Identification; --  see @ref{C.7.1}.
package Ada.Dynamic_Priorities is
@end example

@item
@example
   procedure Set_Priority
     (Priority : in System.Any_Priority;
      T        : in Ada.Task_Identification.Task_ID :=
        Ada.Task_Identification.Current_Task);
@end example

@item
@example
   function Get_Priority
     (T : Ada.Task_Identification.Task_ID :=
       Ada.Task_Identification.Current_Task)
     return System.Any_Priority;
@end example

@item
@example
end Ada.Dynamic_Priorities;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The procedure Set_Priority sets the base priority of the specified task
to the specified Priority value. Set_Priority has no effect if the task
is terminated.

@item
The function Get_Priority returns T's current base priority.
Tasking_Error is raised if the task is terminated.

@item
Program_Error is raised by Set_Priority and Get_Priority if T is equal
to Null_Task_ID.

@item
Setting the task's base priority to the new value takes place as soon as
is practical but not while the task is performing a protected action.
This setting occurs no later then the next abort completion point of the
task T, see @ref{9.8}.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
If a task is blocked on a protected entry call, and the call is queued,
it is a bounded error to raise its base priority above the ceiling
priority of the corresponding protected object. When an entry call is
cancelled, it is a bounded error if the priority of the calling task is
higher than the ceiling priority of the corresponding protected object.
In either of these cases, either Program_Error is raised in the task
that called the entry, or its priority is temporarily lowered, or both,
or neither.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If any subprogram in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the
program is erroneous.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The implementation shall document the following metric:

@enumerate 14
@item
The execution time of a call to Set_Priority, for the nonpreempting
case, in processor clock cycles. This is measured for a call that
modifies the priority of a ready task that is not running (which cannot
be the calling one), where the new base priority of the affected task is
lower than the active priority of the calling task, and the affected
task is not on any entry queue and is not executing a protected
operation.
@end enumerate
@end enumerate
@enumerate 15

NOTES

@item
(22) Setting a task's base priority affects task dispatching. First, it
can change the task's active priority. Second, under the standard task
dispatching policy it always causes the task to move to the tail of the
ready queue corresponding to its active priority, even if the new base
priority is unchanged.

@item
(23) Under the priority queuing policy, setting a task's base priority
has an effect on a queued entry call if the task is blocked waiting for
the call. That is, setting the base priority of a task causes the
priority of a queued entry call from that task to be updated and the
call to be removed and then reinserted in the entry queue at the new
priority, see @ref{D.4}, unless the call originated from the
triggering_statement of an asynchronous_select.

@item
(24) The effect of two or more Set_Priority calls executed in parallel
on the same task is defined as executing these calls in some serial
order.

@item
(25) The rule for when Tasking_Error is raised for Set_Priority or
Get_Priority is different from the rule for when Tasking_Error is raised
on an entry call, see @ref{9.5.3}. In particular, setting or querying the
priority of a completed or an abnormal task is allowed, so long as the
task is not yet terminated.

@item
(26) Changing the priorities of a set of tasks can be performed by a
series of calls to Set_Priority for each task separately. For this to
work reliably, it should be done within a protected operation that has
high enough ceiling priority to guarantee that the operation completes
without being preempted by any of the affected tasks.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.6, D.7, D.5, D
@section Preemptive Abort

@enumerate
@item
This clause specifies requirements on the immediacy with which an
aborted construct is completed.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
On a system with a single processor, an aborted construct is completed
immediately at the first point that is outside the execution of an
abort-deferred operation.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
On a multiprocessor, the implementation shall document any conditions
that cause the completion of an aborted construct to be delayed later
than what is specified for a single processor.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The implementation shall document the following metrics:

@enumerate 5
@item
The execution time, in processor clock cycles, that it takes for an
abort_statement to cause the completion of the aborted task. This is
measured in a situation where a task T2 preempts task T1 and aborts T1.
T1 does not have any finalization code. T2 shall verify that T1 has
terminated, by means of the Terminated attribute.

@item
On a multiprocessor, an upper bound in seconds, on the time that the
completion of an aborted task can be delayed beyond the point that it is
required for a single processor.

@item
An upper bound on the execution time of an asynchronous_select, in
processor clock cycles. This is measured between a point immediately
before a task T1 executes a protected operation Pr.Set that makes the
condition of an entry_barrier Pr.Wait true, and the point where task T2
resumes execution immediately after an entry call to Pr.Wait in an
asynchronous_select. T1 preempts T2 while T2 is executing the abortable
part, and then blocks itself so that T2 can execute. The execution time
of T1 is measured separately, and subtracted.

@item
An upper bound on the execution time of an asynchronous_select, in the
case that no asynchronous transfer of control takes place. This is
measured between a point immediately before a task executes the
asynchronous_select with a nonnull abortable part, and the point where
the task continues execution immediately after it. The execution time of
the abortable part is subtracted.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 9
@item
Even though the abort_statement is included in the list of potentially
blocking operations, see @ref{9.5.1}, it is recommended that this statement
be implemented in a way that never requires the task executing the
abort_statement to block.

@item
On a multi-processor, the delay associated with aborting a task on
another processor should be bounded; the implementation should use
periodic polling, if necessary, to achieve this.

NOTES

@item
(27) Abortion does not change the active or base priority of the aborted
task.

@item
(28) Abortion cannot be more immediate than is allowed by the rules for
deferral of abortion during finalization and in protected actions.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.7, D.8, D.6, D
@section Tasking Restrictions

@enumerate
@item
This clause defines restrictions that can be used with a pragma
Restrictions, see @ref{13.12}, to facilitate the construction of highly
efficient tasking run-time systems.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following restriction_identifiers are language defined:

@item
No_Task_Hierarchy

@example
All (nonenvironment) tasks depend directly on the environment
task of the partition.
@end example

@item
No_Nested_Finalization

@example
Objects with controlled parts and access types that designate
such objects shall be declared only at library level.
@end example

@item
No_Abort_Statements

@example
There are no abort_statements, and there are no calls on
Task_Identification.Abort_Task.
@end example

@item
No_Terminate_Alternatives

@example
There are no selective_accepts with terminate_alternatives.
@end example

@item
No_Task_Allocators

@example
There are no allocators for task types or types containing
task subcomponents.
@end example

@item
No_Implicit_Heap_Allocations

@example
There are no operations that implicitly require heap storage
allocation to be performed by the implementation. The
operations that implicitly require heap storage allocation
are implementation defined.
@end example

@item
No_Dynamic_Priorities

@example
There are no semantic dependences on the package
Dynamic_Priorities.
@end example

@item
No_Asynchronous_Control

@example
There are no semantic dependences on the package
Asynchronous_Task_Control.
@end example

@item
The following restriction_parameter_identifiers are language defined:

@item
Max_Select_Alternatives

@example
Specifies the maximum number of alternatives in a
selective_accept.
@end example

@item
Max_Task_Entries

@example
Specifies the maximum number of entries per task. The bounds
of every entry family of a task unit shall be static, or
shall be defined by a discriminant of a subtype whose
corresponding bound is static. A value of zero indicates
that no rendezvous are possible.
@end example

@item
Max_Protected_Entries

@example
Specifies the maximum number of entries per protected type.
The bounds of every entry family of a protected unit shall be
static, or shall be defined by a discriminant of a subtype
whose corresponding bound is static.
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
If the following restrictions are violated, the behavior is
implementation defined. If an implementation chooses to detect such a
violation, Storage_Error should be raised.

@item
The following restriction_parameter_identifiers are language defined:

@item
Max_Storage_At_Blocking

@example
Specifies the maximum portion (in storage elements) of a
task's Storage_Size that can be retained by a blocked task.
@end example

@item
Max_Asynchronous_Select_Nesting

@example
Specifies the maximum dynamic nesting level of
asynchronous_selects. A value of zero prevents the use of any
asynchronous_select.
@end example

@item
Max_Tasks

@example
Specifies the maximum number of task creations that may be
executed over the lifetime of a partition, not counting the
creation of the environment task.
@end example

@item
It is implementation defined whether the use of pragma Restrictions
results in a reduction in executable program size, storage requirements,
or execution time. If possible, the implementation should provide
quantitative descriptions of such effects for each restriction.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
When feasible, the implementation should take advantage of the specified
restrictions to produce a more efficient implementation.

NOTES

@item
(29) The above Storage_Checks can be suppressed with pragma Suppress.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.8, D.9, D.7, D
@section Monotonic Time

@enumerate
@item
This clause specifies a high-resolution, monotonic clock package.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
package Ada.Real_Time is
@end example

@item
@example
  type Time is private;
  Time_First : constant Time;
  Time_Last : constant Time;
  Time_Unit : constant := implementation-defined-real-number;
@end example
@end enumerate

@enumerate 6
@item
@example
  type Time_Span is private;
  Time_Span_First : constant Time_Span;
  Time_Span_Last : constant Time_Span;
  Time_Span_Zero : constant Time_Span;
  Time_Span_Unit : constant Time_Span;
@end example

@item
@example
  Tick : constant Time_Span;
  function Clock return Time;
@end example

@item
@example
  function "+" (Left : Time; Right : Time_Span) return Time;
  function "+" (Left : Time_Span; Right : Time) return Time;
  function "-" (Left : Time; Right : Time_Span) return Time;
  function "-" (Left : Time; Right : Time) return Time_Span;
@end example

@item
@example
  function "<" (Left, Right : Time) return Boolean;
  function "<="(Left, Right : Time) return Boolean;
  function ">" (Left, Right : Time) return Boolean;
  function ">="(Left, Right : Time) return Boolean;
@end example

@item
@example
  function "+" (Left, Right : Time_Span) return Time_Span;
  function "-" (Left, Right : Time_Span) return Time_Span;
  function "-" (Right : Time_Span) return Time_Span;
  function "*" (Left : Time_Span; Right : Integer) return Time_Span;
  function "*" (Left : Integer; Right : Time_Span) return Time_Span;
  function "/" (Left, Right : Time_Span) return Integer;
  function "/" (Left : Time_Span; Right : Integer) return Time_Span;
@end example

@item
@example
  function "abs"(Right : Time_Span) return Time_Span;
@end example

@item
@example
  function "<" (Left, Right : Time_Span) return Boolean;
  function "<="(Left, Right : Time_Span) return Boolean;
  function ">" (Left, Right : Time_Span) return Boolean;
  function ">="(Left, Right : Time_Span) return Boolean;
@end example

@item
@example
  function To_Duration (TS : Time_Span) return Duration;
  function To_Time_Span (D : Duration) return Time_Span;
@end example

@item
@example
  function Nanoseconds  (NS : Integer) return Time_Span;
  function Microseconds (US : Integer) return Time_Span;
  function Milliseconds (MS : Integer) return Time_Span;
@end example

@item
@example
  type Seconds_Count is range implementation-defined;
@end example

@item
@example
  procedure Split(T  : in     Time;
                  SC :    out Seconds_Count;
                  TS :    out Time_Span);
  function Time_Of(SC : Seconds_Count; TS : Time_Span) return Time;
@end example

@item
@example
private
   ... -- not specified by the language
end Ada.Real_Time;
@end example

@item
In this Annex, real time is defined to be the physical time as observed
in the external environment. The type Time is a time type as defined by
@ref{9.6}, values of this type may be used in a delay_until_statement.
Values of this type represent segments of an ideal time line. The set of
values of the type Time corresponds one-to-one with an
implementation-defined range of mathematical integers.

@item
The Time value I represents the half-open real time interval that starts
with E+I*Time_Unit and is limited by E+(I+1)*Time_Unit, where Time_Unit
is an implementation-defined real number and E is an unspecified origin
point, the epoch, that is the same for all values of the type Time. It
is not specified by the language whether the time values are
synchronized with any standard time reference. For example, E can
correspond to the time of system initialization or it can correspond to
the epoch of some time standard.

@item
Values of the type Time_Span represent length of real time duration. The
set of values of this type corresponds one-to-one with an
implementation-defined range of mathematical integers. The Time_Span
value corresponding to the integer I represents the real-time duration
I*Time_Unit.

@item
Time_First and Time_Last are the smallest and largest values of the Time
type, respectively. Similarly, Time_Span_First and Time_Span_Last are
the smallest and largest values of the Time_Span type, respectively.

@item
A value of type Seconds_Count represents an elapsed time, measured in
seconds, since the epoch.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Time_Unit is the smallest amount of real time representable by the Time
type; it is expressed in seconds. Time_Span_Unit is the difference
between two successive values of the Time type. It is also the smallest
positive value of type Time_Span. Time_Unit and Time_Span_Unit represent
the same real time duration. A clock tick is a real time interval during
which the clock value (as observed by calling the Clock function)
remains constant. Tick is the average length of such intervals.

@item
The function To_Duration converts the value TS to a value of type
Duration. Similarly, the function To_Time_Span converts the value D to a
value of type Time_Span. For both operations, the result is rounded to
the nearest exactly representable value (away from zero if exactly
halfway between two exactly representable values).

@item
To_Duration(Time_Span_Zero) returns 0.0, and To_Time_Span(0.0) returns
Time_Span_Zero.

@item
The functions Nanoseconds, Microseconds, and Milliseconds convert the
input parameter to a value of the type Time_Span. NS, US, and MS are
interpreted as a number of nanoseconds, microseconds, and milliseconds
respectively. The result is rounded to the nearest exactly representable
value (away from zero if exactly halfway between two exactly
representable values).

@item
The effects of the operators on Time and Time_Span are as for the
operators defined for integer types.

@item
The function Clock returns the amount of time since the epoch.

@item
The effects of the Split and Time_Of operations are defined as follows,
treating values of type Time, Time_Span, and Seconds_Count as
mathematical integers. The effect of Split(T,SC,TS) is to set SC and TS
to values such that T*Time_Unit = SC*1.0 + TS*Time_Unit, and 0.0 <=
TS*Time_Unit < 1.0. The value returned by Time_Of(SC,TS) is the value T
such that T*Time_Unit = SC*1.0 + TS*Time_Unit.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The range of Time values shall be sufficient to uniquely represent the
range of real times from program start-up to 50 years later. Tick shall
be no greater than 1 millisecond. Time_Unit shall be less than or equal
to 20 microseconds.

@item
Time_Span_First shall be no greater than -3600 seconds, and
Time_Span_Last shall be no less than 3600 seconds.

@item
A clock jump is the difference between two successive distinct values of
the clock (as observed by calling the Clock function). There shall be no
backward clock jumps.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the values of Time_First, Time_Last,
Time_Span_First, Time_Span_Last, Time_Span_Unit, and Tick.

@item
The implementation shall document the properties of the underlying time
base used for the clock and for type Time, such as the range of values
supported and any relevant aspects of the underlying hardware or
operating system facilities used.

@item
The implementation shall document whether or not there is any
synchronization with external time references, and if such
synchronization exists, the sources of synchronization information, the
frequency of synchronization, and the synchronization method applied.

@item
The implementation shall document any aspects of the the external
environment that could interfere with the clock behavior as defined in
this clause.

@need 1000
@sp 1
@center @emph{Metrics}

@item
For the purpose of the metrics defined in this clause, real time is
defined to be the International Atomic Time (TAI).

@item
The implementation shall document the following metrics:

@enumerate 39
@item
@format
An upper bound on the real-time duration of a clock tick. This is
a value D such that if t1 and t2 are any real times such that t1 <
t2 and Clock   = Clock   then t2 - t1 <= D.
            t1        t2
@end format

@item
An upper bound on the size of a clock jump.

@item
An upper bound on the drift rate of Clock with respect to real time.
This is a real number D such that

@item
@example
E*(1-D) <= (Clock    - Clock ) <= E*(1+D)
                 t+E        t

provided that: Clock  + E*(1+D) <= Time_Last.
                    t
@end example

@item
@format
where Clock  is the value of Clock at time t, and E is a real time
           t
time duration not less than 24 hours. The value of E used for this
metric shall be reported. @end format

@item
An upper bound on the execution time of a call to the Clock function, in
processor clock cycles.

@item
Upper bounds on the execution times of the operators of the types Time
and Time_Span, in processor clock cycles.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 46
@item
Implementations targeted to machines with word size smaller than 32 bits
need not support the full range and granularity of the Time and
Time_Span types.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
When appropriate, implementations should provide configuration
mechanisms to change the value of Tick.

@item
It is recommended that Calendar.Clock and Real_Time.Clock be implemented
as transformations of the same time base.

@item
It is recommended that the ``best'' time base which exists in the
underlying system be available to the application through Clock.
``Best'' may mean highest accuracy or largest range.

NOTES

@item
(30) The rules in this clause do not imply that the implementation can
protect the user from operator or installation errors which could result
in the clock being set incorrectly.

@item
(31) Time_Unit is the granularity of the Time type. In contrast, Tick
represents the granularity of Real_Time.Clock. There is no requirement
that these be the same.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.9, D.10, D.8, D
@section Delay Accuracy

@enumerate
@item
This clause specifies performance requirements for the delay_statement.
The rules apply both to delay_relative_statement and to
delay_until_statement. Similarly, they apply equally to a simple
delay_statement and to one which appears in a delay_alternative.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The effect of the delay_statement for Real_Time.Time is defined in terms
of Real_Time.Clock:

@enumerate 3
@item
@format
If C  is a value of Clock read before a task executes a
    1
delay_relative_statement with duration D, and C  is a value of Clock
                                               2
read after the task resumes execution following that delay_statement,
then C  - C  >= D.
      2    1
@end format

@item
If C is a value of Clock read after a task resumes execution following a
delay_until_statement with Real_Time.Time value T, then C >= T.
@end enumerate
@end enumerate

@enumerate 5
@item
A simple delay_statement with a negative or zero value for the
expiration time does not cause the calling task to be blocked; it is
nevertheless a potentially blocking operation, see @ref{9.5.1}.

@item
When a delay_statement appears in a delay_alternative of a
timed_entry_call the selection of the entry call is attempted,
regardless of the specified expiration time. When a delay_statement
appears in a selective_accept_alternative, and a call is queued on one
of the open entries, the selection of that entry call proceeds,
regardless of the value of the delay expression.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the minimum value of the delay
expression of a delay_relative_statement that causes the task to
actually be blocked.

@item
The implementation shall document the minimum difference between the
value of the delay expression of a delay_until_statement and the value
of Real_Time.Clock, that causes the task to actually be blocked.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The implementation shall document the following metrics:

@enumerate 10
@item
An upper bound on the execution time, in processor clock cycles, of a
delay_relative_statement whose requested value of the delay expression
is less than or equal to zero.

@item
An upper bound on the execution time, in processor clock cycles, of a
delay_until_statement whose requested value of the delay expression is
less than or equal to the value of Real_Time.Clock at the time of
executing the statement. Similarly, for Calendar.Clock.

@item
An upper bound on the lateness of a delay_relative_statement, for a
positive value of the delay expression, in a situation where the task
has sufficient priority to preempt the processor as soon as it becomes
ready, and does not need to wait for any other execution resources. The
upper bound is expressed as a function of the value of the delay
expression. The lateness is obtained by subtracting the value of the
delay expression from the actual duration. The actual duration is
measured from a point immediately before a task executes the
delay_statement to a point immediately after the task resumes execution
following this statement.

@item
An upper bound on the lateness of a delay_until_statement, in a
situation where the value of the requested expiration time is after the
time the task begins executing the statement, the task has sufficient
priority to preempt the processor as soon as it becomes ready, and it
does not need to wait for any other execution resources. The upper bound
is expressed as a function of the difference between the requested
expiration time and the clock value at the time the statement begins
execution. The lateness of a delay_until_statement is obtained by
subtracting the requested expiration time from the real time that the
task resumes execution following this statement.
@end enumerate
@end enumerate
@enumerate 14

NOTES

@item
(32) The execution time of a delay_statement that does not cause the
task to be blocked (e.g. ``delay 0.0;'' ) is of interest in situations
where delays are used to achieve voluntary round-robin task dispatching
among equal-priority tasks.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.10, D.11, D.9, D
@section Synchronous Task Control

@enumerate
@item
This clause describes a language-defined private semaphore (suspension
object), which can be used for two-stage suspend operations and as a
simple building block for implementing higher-level queues.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined package exists:

@item
@example
package Ada.Synchronous_Task_Control is
@end example

@item
@example
  type Suspension_Object is limited private;
  procedure Set_True(S : in out Suspension_Object);
  procedure Set_False(S : in out Suspension_Object);
  function Current_State(S : Suspension_Object) return Boolean;
  procedure Suspend_Until_True(S : in out Suspension_Object);
private
     ... -- not specified by the language
end Ada.Synchronous_Task_Control;
@end example

@item
The type Suspension_Object is a by-reference type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
An object of the type Suspension_Object has two visible states: true and
false. Upon initialization, its value is set to false.

@item
The operations Set_True and Set_False are atomic with respect to each
other and with respect to Suspend_Until_True; they set the state to true
and false respectively.

@item
Current_State returns the current state of the object.

@item
The procedure Suspend_Until_True blocks the calling task until the state
of the object S is true; at that point the task becomes ready and the
state of the object becomes false.

@item
Program_Error is raised upon calling Suspend_Until_True if another task
is already waiting on that suspension object. Suspend_Until_True is a
potentially blocking operation, see @ref{9.5.1}.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation is required to allow the calling of Set_False and
Set_True during any protected action, even one that has its ceiling
priority in the Interrupt_Priority range.
@end enumerate

@c ---------------------------------------------------------------------------
@node D.11, D.12, D.10, D
@section Asynchronous Task Control

@enumerate
@item
This clause introduces a language-defined package to do asynchronous
suspend/resume on tasks. It uses a conceptual held priority value to
represent the task's held state.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
with Ada.Task_Identification;
package Ada.Asynchronous_Task_Control is
  procedure Hold(T : in Ada.Task_Identification.Task_ID);
  procedure Continue(T : in Ada.Task_Identification.Task_ID);
  function Is_Held(T : Ada.Task_Identification.Task_ID)
   return Boolean;
end Ada.Asynchronous_Task_Control;
@end example

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
After the Hold operation has been applied to a task, the task becomes
held. For each processor there is a conceptual idle task, which is
always ready. The base priority of the idle task is below
System.Any_Priority'First. The held priority is a constant of the type
integer whose value is below the base priority of the idle task.

@item
The Hold operation sets the state of T to held. For a held task:  the
task's own base priority does not constitute an inheritance source
(@pxref{D.1}) and the value of the held priority is defined to be such a
source instead.

@item
The Continue operation resets the state of T to not-held; T's active
priority is then reevaluated as described in D.1. This time, T's base
priority is taken into account.

@item
The Is_Held function returns True if and only if T is in the held state.

@item
As part of these operations, a check is made that the task identified by
T is not terminated. Tasking_Error is raised if the check fails.
Program_Error is raised if the value of T is Null_Task_ID.

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
If any operation in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the
program is erroneous.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation need not support Asynchronous_Task_Control if it is
infeasible to support it in the target environment.

NOTES

@item
(33) It is a consequence of the priority rules that held tasks cannot be
dispatched on any processor in a partition (unless they are inheriting
priorities) since their priorities are defined to be below the priority
of any idle task.

@item
(34) The effect of calling Get_Priority and Set_Priority on a Held task
is the same as on any other task.

@item
(35) Calling Hold on a held task or Continue on a non-held task has no
effect.

@item
(36) The rules affecting queuing are derived from the above rules, in
addition to the normal priority rules:

@enumerate 15
@item
When a held task is on the ready queue, its priority is so low as to
never reach the top of the queue as long as there are other tasks on
that queue.

@item
If a task is executing in a protected action, inside a rendezvous, or is
inheriting priorities from other sources (e.g. when activated), it
continues to execute until it is no longer executing the corresponding
construct.

@item
If a task becomes held while waiting (as a caller) for a rendezvous to
complete, the active priority of the accepting task is not affected.

@item
If a task becomes held while waiting in a selective_accept, and a entry
call is issued to one of the open entries, the corresponding accept body
executes. When the rendezvous completes, the active priority of the
accepting task is lowered to the held priority (unless it is still
inheriting from other sources), and the task does not execute until
another Continue.

@item
The same holds if the held task is the only task on a protected entry
queue whose barrier becomes open. The corresponding entry body executes.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node D.12, E, D.11, D
@section Other Optimizations and Determinism Rules

@enumerate
@item
This clause describes various requirements for improving the response
and determinism in a real-time system.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
If the implementation blocks interrupts, see @ref{C.3}, not as a result of
direct user action (e.g. an execution of a protected action) there shall
be an upper bound on the duration of this blocking.

@item
The implementation shall recognize entry-less protected types. The
overhead of acquiring the execution resource of an object of such a
type, see @ref{9.5.1}, shall be minimized. In particular, there should not
be any overhead due to evaluating entry_barrier conditions.

@item
Unchecked_Deallocation shall be supported for terminated tasks that are
designated by access types, and shall have the effect of releasing all
the storage associated with the task. This includes any run-time system
or heap storage that has been implicitly allocated for the task by the
implementation.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document the upper bound on the duration of
interrupt blocking caused by the implementation. If this is different
for different interrupts or interrupt priority levels, it should be
documented for each case.

@need 1000
@sp 1
@center @emph{Metrics}

@item
The implementation shall document the following metric:

@enumerate 7
@item
The overhead associated with obtaining a mutual-exclusive access to an
entry-less protected object. This shall be measured in the following
way:

@enumerate 8
@item
For a protected object of the form:

@item
@example
protected Lock is
   procedure Set;
   function Read return Boolean;
private
   Flag : Boolean := False;
end Lock;
@end example

@item
@example
protected body Lock is
   procedure Set is
   begin
      Flag := True;
   end Set;
   function Read return Boolean
   Begin
      return Flag;
   end Read;
end Lock;
@end example

@item
The execution time, in processor clock cycles, of a call to Set. This
shall be measured between the point just before issuing the call, and
the point just after the call completes. The function Read shall be
called later to verify that Set was indeed called (and not optimized
away). The calling task shall have sufficiently high priority as to not
be preempted during the measurement period. The protected object shall
have sufficiently high ceiling priority to allow the task to call Set.

@item
For a multiprocessor, if supported, the metric shall be reported for the
case where no contention (on the execution resource) exists from tasks
executing on other processors.
@end enumerate
@end enumerate
@end enumerate

@c ===========================================================================
@node E, E.1, D.12, Top
@appendix  Distributed Systems (normative)

@enumerate
@item
This Annex defines facilities for supporting the implementation of
distributed systems using multiple partitions working cooperatively as
part of a single Ada program.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A distributed system is an interconnection of one or more processing
nodes (a system resource that has both computational and storage
capabilities), and zero or more storage nodes (a system resource that
has only storage capabilities, with the storage addressable by one or
more processing nodes).

@item
A distributed program comprises one or more partitions that execute
independently (except when they communicate) in a distributed system.

@item
The process of mapping the partitions of a program to the nodes in a
distributed system is called configuring the partitions of the program.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall provide means for explicitly assigning library
units to a partition and for the configuring and execution of a program
consisting of multiple partitions on a distributed system; the means are
implementation defined.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may require that the set of processing nodes of a
distributed system be homogeneous.

NOTES

@item
(1) The partitions comprising a program may be executed on differently
configured distributed systems or on a non-distributed system without
requiring recompilation. A distributed program may be partitioned
differently from the same set of library units without recompilation.
The resulting execution is semantically equivalent.

@item
(2) A distributed program retains the same type safety as the equivalent
single partition program.
@end enumerate

@menu
* E.1:: Partitions
* E.2:: Categorization of Library Units
* E.3:: Consistency of a Distributed System
* E.4:: Remote Subprogram Calls
* E.5:: Partition Communication Subsystem

--- The Detailed Node Listing ---

* E.1::   Partitions
* E.2::   Categorization of Library Units
* E.2.1:: Shared Passive Library Units
* E.2.2:: Remote Types Library Units
* E.2.3:: Remote Call Interface Library Units
* E.3::   Consistency of a Distributed System
* E.4::   Remote Subprogram Calls
* E.4.1:: Pragma Asynchronous
* E.4.2:: Example of Use of a Remote Access-to-Class-Wide Type
* E.5::   Partition Communication Subsystem
@end menu

@c ---------------------------------------------------------------------------
@node E.1, E.2, E, E
@section Partitions

@enumerate
@item
The partitions of a distributed program are classified as either active
or passive.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
An active partition is a partition as defined in @ref{10.2}. A passive
partition is a partition that has no thread of control of its own, whose
library units are all preelaborated, and whose data and subprograms are
accessible to one or more active partitions.

@item
A passive partition shall include only library_items that either are
declared pure or are shared passive, see @ref{10.2.1}, and @ref{E.2.1}.

@item
An active partition shall be configured on a processing node. A passive
partition shall be configured either on a storage node or on a
processing node.

@item
The configuration of the partitions of a program onto a distributed
system shall be consistent with the possibility for data references or
calls between the partitions implied by their semantic dependences. Any
reference to data or call of a subprogram across partitions is called a
remote access.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A library_item is elaborated as part of the elaboration of each
partition that includes it. If a normal library unit, see @ref{E.2}, has
state, then a separate copy of the state exists in each active partition
that elaborates it. The state evolves independently in each such
partition.

@item
An active partition terminates when its environment task terminates. A
partition becomes inaccessible if it terminates or if it is aborted. An
active partition is aborted when its environment task is aborted. In
addition, if a partition fails during its elaboration, it becomes
inaccessible to other partitions. Other implementation-defined events
can also result in a partition becoming inaccessible.

@item
For a prefix D that denotes a library-level declaration, excepting a
declaration of or within a declared-pure library unit, the following
attribute is defined:

@item
D'Partition_ID

@example
Denotes a value of the type universal_integer that
identifies the partition in which D was elaborated. If D
denotes the declaration of a remote call interface
library unit, see @ref{E.2.3}, the given partition is the
one where the body of D was elaborated.
@end example

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
It is a bounded error for there to be cyclic elaboration dependences
between the active partitions of a single distributed program. The
possible effects are deadlock during elaboration, or the raising of
Program_Error in one or all of the active partitions involved.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation may allow multiple active or passive partitions to be
configured on a single processing node, and multiple passive partitions
to be configured on a single storage node. In these cases, the
scheduling policies, treatment of priorities, and management of shared
resources between these partitions are implementation defined.

@item
An implementation may allow separate copies of an active partition to be
configured on different processing nodes, and to provide appropriate
interactions between the copies to present a consistent state of the
partition to other active partitions.

@item
In an implementation, the partitions of a distributed program need not
be loaded and elaborated all at the same time; they may be loaded and
elaborated one at a time over an extended period of time. An
implementation may provide facilities to abort and reload a partition
during the execution of a distributed program.

@item
An implementation may allow the state of some of the partitions of a
distributed program to persist while other partitions of the program
terminate and are later reinvoked.

NOTES

@item
(3) Library units are grouped into partitions after compile time, but
before run time. At compile time, only the relevant library unit
properties are identified using categorization pragmas.

@item
(4) The value returned by the Partition_ID attribute can be used as a
parameter to implementation-provided subprograms in order to query
information about the partition.
@end enumerate

@c ---------------------------------------------------------------------------
@node E.2, E.2.1, E.1, E
@section Categorization of Library Units

@enumerate
@item
Library units can be categorized according to the role they play in a
distributed program. Certain restrictions are associated with each
category to ensure that the semantics of a distributed program remain
close to the semantics for a nondistributed program.

@item
A categorization pragma is a library unit pragma, see @ref{10.1.5}, that
restricts the declarations, child units, or semantic dependences of the
library unit to which it applies. A categorized library unit is a
library unit to which a categorization pragma applies.

@item
The pragmas Shared_Passive, Remote_Types, and Remote_Call_Interface are
categorization pragmas. In addition, for the purposes of this Annex, the
pragma Pure, see @ref{10.2.1} is considered a categorization pragma.

@item
A library package or generic library package is called a shared passive
library unit if a Shared_Passive pragma applies to it. A library package
or generic library package is called a remote types library unit if a
Remote_Types pragma applies to it. A library package or generic library
package is called a remote call interface if a Remote_Call_Interface
pragma applies to it. A normal library unit is one to which no
categorization pragma applies.

@item
The various categories of library units and the associated restrictions
are described in this clause and its subclauses. The categories are
related hierarchically in that the library units of one category can
depend semantically only on library units of that category or an earlier
one, except that the body of a remote types or remote call interface
library unit is unrestricted.

@item
The overall hierarchy (including declared pure) is as follows:

@item
Declared Pure

@example
Can depend only on other declared pure library units;
@end example

@item
Shared Passive

@example
Can depend only on other shared passive or declared pure
library units;
@end example

@item
Remote Types

@example
The declaration of the library unit can depend only on other
remote types library units, or one of the above; the body of
the library unit is unrestricted;
@end example

@item
Remote Call Interface

@example
The declaration of the library unit can depend only on other
remote call interfaces, or one of the above; the body of the
library unit is unrestricted;
@end example

@item
Normal

@example
Unrestricted.
@end example

@item
Declared pure and shared passive library units are preelaborated. The
declaration of a remote types or remote call interface library unit is
required to be preelaborable.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
For a given library-level type declared in a preelaborated library unit
or in the declaration of a remote types or remote call interface library
unit, the implementation shall choose the same representation for the
type upon each elaboration of the type's declaration for different
partitions of the same program.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
Implementations are allowed to define other categorization pragmas.
@end enumerate

@menu
* E.2.1:: Shared Passive Library Units
* E.2.2:: Remote Types Library Units
* E.2.3:: Remote Call Interface Library Units
@end menu

@c ---------------------------------------------------------------------------
@node E.2.1, E.2.2, E.2, E.2
@subsection Shared Passive Library Units

@enumerate
@item
A shared passive library unit is used for managing global data shared
between active partitions. The restrictions on shared passive library
units prevent the data or tasks of one active partition from being
accessible to another active partition through references implicit in
objects declared in the shared passive library unit.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Shared_Passive is as follows:

@item
@example
pragma Shared_Passive[(library_unit_name)];
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A shared passive library unit is a library unit to which a
Shared_Passive pragma applies. The following restrictions apply to such
a library unit:

@enumerate 5
@item
it shall be preelaborable, see @ref{10.2.1},

@item
it shall depend semantically only upon declared pure or shared passive
library units;

@item
it shall not contain a library-level declaration of an access type that
designates a class-wide type, task type, or protected type with
entry_declarations; if the shared passive library unit is generic, it
shall not contain a declaration for such an access type unless the
declaration is nested within a body other than a package_body.
@end enumerate
@end enumerate

@enumerate 8
@item
Notwithstanding the definition of accessibility given in @ref{3.10.2},
the declaration of a library unit P1 is not accessible from within the
declarative region of a shared passive library unit P2, unless the
shared passive library unit P2 depends semantically on P1.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A shared passive library unit is preelaborated.

@need 1000
@sp 1
@center @emph{Compilation Rules}

@item
A shared passive library unit shall be assigned to at most one partition
within a given program.

@item
Notwithstanding the rule given in @ref{10.2}, a compilation unit in a
given partition does not need (in the sense of  @ref{10.2}.) the shared
passive library units on which it depends semantically to be included in
that same partition; they will typically reside in separate passive
partitions.
@end enumerate

@c ---------------------------------------------------------------------------
@node E.2.2, E.2.3, E.2.1, E.2
@subsection Remote Types Library Units

@enumerate
@item
A remote types library unit supports the definition of types intended
for use in communication between active partitions.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Remote_Types is as follows:

@item
@example
pragma Remote_Types[(library_unit_name)];
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A remote types library unit is a library unit to which the pragma
Remote_Types applies. The following restrictions apply to the
declaration of such a library unit:

@enumerate 5
@item
it shall be preelaborable;

@item
it shall depend semantically only on declared pure, shared passive, or
other remote types library units;

@item
it shall not contain the declaration of any variable within the visible
part of the library unit;

@item
if the full view of a type declared in the visible part of the library
unit has a part that is of a non-remote access type, then that access
type, or the type of some part that includes the access type
subcomponent, shall have user-specified Read and Write attributes.
@end enumerate
@end enumerate

@enumerate 9
@item
An access type declared in the visible part of a remote types or remote
call interface library unit is called a remote access type. Such a type
shall be either an access-to-subprogram type or a general access type
that designates a class-wide limited private type.

@item
The following restrictions apply to the use of a remote
access-to-subprogram type:

@enumerate 11
@item
A value of a remote access-to-subprogram type shall be converted only to
another (subtype-conformant) remote access-to-subprogram type;

@item
The prefix of an Access attribute_reference that yields a value of a
remote access-to-subprogram type shall statically denote a
(subtype-conformant) remote subprogram.
@end enumerate
@end enumerate

@enumerate 13
@item
The following restrictions apply to the use of a remote
access-to-class-wide type:

@enumerate 14
@item
The primitive subprograms of the corresponding specific limited private
type shall only have access parameters if they are controlling formal
parameters; the types of all the non-controlling formal parameters shall
have Read and Write attributes.

@item
A value of a remote access-to-class-wide type shall be explicitly
converted only to another remote access-to-class-wide type;

@item
A value of a remote access-to-class-wide type shall be dereferenced (or
implicitly converted to an anonymous access type) only as part of a
dispatching call where the value designates a controlling operand of the
call, see @ref{E.4, ``Remote Subprogram Calls''},

@item
The Storage_Pool and Storage_Size attributes are not defined for remote
access-to-class-wide types; the expected type for an allocator shall not
be a remote access-to-class-wide type; a remote access-to-class-wide
type shall not be an actual parameter for a generic formal access type;
@end enumerate
@end enumerate
@enumerate 18

NOTES

@item
(5) A remote types library unit need not be pure, and the types it
defines may include levels of indirection implemented by using access
types. User-specified Read and Write attributes, see @ref{13.13.2} provide
for sending values of such a type between active partitions, with Write
marshalling the representation, and Read unmarshalling any levels of
indirection.
@end enumerate

@c ---------------------------------------------------------------------------
@node E.2.3, E.3, E.2.2, E.2
@subsection Remote Call Interface Library Units

@enumerate
@item
A remote call interface library unit can be used as an interface for
remote procedure calls (RPCs) (or remote function calls) between active
partitions.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Remote_Call_Interface is as follows:

@item
@example
pragma Remote_Call_Interface[(library_unit_name)];
@end example

@item
The form of a pragma All_Calls_Remote is as follows:

@item
@example
pragma All_Calls_Remote[(library_unit_name)];
@end example

@enumerate 6
@item
A pragma All_Calls_Remote is a library unit pragma.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Legality Rules}

@enumerate 7
@item
A remote call interface (RCI) is a library unit to which the pragma
Remote_Call_Interface applies. A subprogram declared in the visible part
of such a library unit is called a remote subprogram.

@item
The declaration of an RCI library unit shall be preelaborable
(@pxref{10.2.1}) and shall depend semantically only upon declared pure,
shared passive, remote types, or other remote call interface library
units.

@item
In addition, the following restrictions apply to the visible part of an
RCI library unit:

@enumerate 10
@item
it shall not contain the declaration of a variable;

@item
it shall not contain the declaration of a limited type;

@item
it shall not contain a nested generic_declaration;

@item
it shall not contain the declaration of a subprogram to which a pragma
Inline applies;

@item
it shall not contain a subprogram (or access-to-subprogram) declaration
whose profile has an access parameter, or a formal parameter of a
limited type unless that limited type has user-specified Read and Write
attributes;

@item
any public child of the library unit shall be a remote call interface
library unit.
@end enumerate
@end enumerate

@enumerate 16
@item
If a pragma All_Calls_Remote applies to a library unit, the library unit
shall be a remote call interface.

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
A remote call interface library unit shall be assigned to at most one
partition of a given program. A remote call interface library unit whose
parent is also an RCI library unit shall be assigned only to the same
partition as its parent.

@item
Notwithstanding the rule given in @ref{10.2}, a compilation unit in a
given partition that semantically depends on the declaration of an RCI
library unit, needs (in the sense of @ref{10.2}.) only the declaration
of the RCI library unit, not the body, to be included in that same
partition. Therefore, the body of an RCI library unit is included only
in the partition to which the RCI library unit is explicitly assigned.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
If a pragma All_Calls_Remote applies to a given RCI library package,
then the implementation shall route any call to a subprogram of the RCI
package from outside the declarative region of the package through the
Partition Communication Subsystem (PCS); see @ref{E.5}. Calls to such
subprograms from within the declarative region of the package are
defined to be local and shall not go through the PCS.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
An implementation need not support the Remote_Call_Interface pragma nor
the All_Calls_Remote pragma. Explicit message-based communication
between active partitions can be supported as an alternative to RPC.
@end enumerate

@c ---------------------------------------------------------------------------
@node E.3, E.4, E.2.3, E
@section Consistency of a Distributed System

@enumerate
@item
This clause defines attributes and rules associated with verifying the
consistency of a distributed program.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For a prefix P that statically denotes a program unit, the following
attributes are defined:

@item
P'Version

@example
Yields a value of the predefined type String that identifies
the version of the compilation unit that contains the
declaration of the program unit.
@end example

@item
P'Body_Version

@example
Yields a value of the predefined type String that identifies
the version of the compilation unit that contains the body
(but not any subunits) of the program unit.
@end example

@item
The version of a compilation unit changes whenever the version changes
for any compilation unit on which it depends semantically. The version
also changes whenever the compilation unit itself changes in a
semantically significant way. It is implementation defined whether there
are other events (such as recompilation) that result in the version of a
compilation unit changing.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
In a distributed program, a library unit is consistent if the same
version of its declaration is used throughout. It is a bounded error to
elaborate a partition of a distributed program that contains a
compilation unit that depends on a different version of the declaration
of a shared passive or RCI library unit than that included in the
partition to which the shared passive or RCI library unit was assigned.
As a result of this error, Program_Error can be raised in one or both
partitions during elaboration; in any case, the partitions become
inaccessible to one another.
@end enumerate

@c ---------------------------------------------------------------------------
@node E.4, E.4.1, E.3, E
@section Remote Subprogram Calls

@enumerate
@item
A remote subprogram call is a subprogram call that invokes the execution
of a subprogram in another partition. The partition that originates the
remote subprogram call is the calling partition, and the partition that
executes the corresponding subprogram body is the called partition. Some
remote procedure calls are allowed to return prior to the completion of
subprogram execution. These are called asynchronous remote procedure
calls.

@item
There are three different ways of performing a remote subprogram call:

@enumerate 3
@item
As a direct call on a (remote) subprogram explicitly declared in a
remote call interface;

@item
As an indirect call through a value of a remote access-to-subprogram
type;

@item
As a dispatching call with a controlling operand designated by a value
of a remote access-to-class-wide type.
@end enumerate
@end enumerate

@enumerate 6
@item
The first way of calling corresponds to a static binding between the
calling and the called partition. The latter two ways correspond to a
dynamic binding between the calling and the called partition.

@item
A remote call interface library unit, see @ref{E.2.3}, defines the remote
subprograms or remote access types used for remote subprogram calls.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
In a dispatching call with two or more controlling operands, if one
controlling operand is designated by a value of a remote
access-to-class-wide type, then all shall be.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
For the execution of a remote subprogram call, subprogram parameters
(and later the results, if any) are passed using a stream-oriented
representation, see @ref{13.13.1}, which is suitable for transmission
between partitions. This action is called marshalling. Unmarshalling is
the reverse action of reconstructing the parameters or results from the
stream-oriented representation. Marshalling is performed initially as
part of the remote subprogram call in the calling partition;
unmarshalling is done in the called partition. After the remote
subprogram completes, marshalling is performed in the called partition,
and finally unmarshalling is done in the calling partition.

@item
A calling stub is the sequence of code that replaces the subprogram body
of a remotely called subprogram in the calling partition. A receiving
stub is the sequence of code (the ``wrapper'') that receives a remote
subprogram call on the called partition and invokes the appropriate
subprogram body.

@item
Remote subprogram calls are executed at most once, that is, if the
subprogram call returns normally, then the called subprogram's body was
executed exactly once.

@item
The task executing a remote subprogram call blocks until the subprogram
in the called partition returns, unless the call is asynchronous. For an
asynchronous remote procedure call, the calling task can become ready
before the procedure in the called partition returns.

@item
If a construct containing a remote call is aborted, the remote
subprogram call is cancelled. Whether the execution of the remote
subprogram is immediately aborted as a result of the cancellation is
implementation defined.

@item
If a remote subprogram call is received by a called partition before the
partition has completed its elaboration, the call is kept pending until
the called partition completes its elaboration (unless the call is
cancelled by the calling partition prior to that).

@item
If an exception is propagated by a remotely called subprogram, and the
call is not an asynchronous call, the corresponding exception is
reraised at the point of the remote subprogram call. For an asynchronous
call, if the remote procedure call returns prior to the completion of
the remotely called subprogram, any exception is lost.

@item
The exception Communication_Error, see @ref{E.5} is raised if a remote call
cannot be completed due to difficulties in communicating with the called
partition.

@item
All forms of remote subprogram calls are potentially blocking
operations, see @ref{9.5.1}.

@item
In a remote subprogram call with a formal parameter of a class-wide
type, a check is made that the tag of the actual parameter identifies a
tagged type declared in a declared-pure or shared passive library unit,
or in the visible part of a remote types or remote call interface
library unit. Program_Error is raised if this check fails.

@item
In a dispatching call with two or more controlling operands that are
designated by values of a remote access-to-class-wide type, a check is
made (in addition to the normal Tag_Check --  see @ref{11.5}.) that all the
remote access-to-class-wide values originated from Access
attribute_references that were evaluated by tasks of the same active
partition. Constraint_Error is raised if this check fails.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation of remote subprogram calls shall conform to the PCS
interface as defined by the specification of the language-defined
package System.RPC, see @ref{E.5}. The calling stub shall use the Do_RPC
procedure unless the remote procedure call is asynchronous in which case
Do_APC shall be used. On the receiving side, the corresponding receiving
stub shall be invoked by the RPC-receiver.

NOTES

@item
(6) A given active partition can both make and receive remote subprogram
calls. Thus, an active partition can act as both a client and a server.

@item
(7) If a given exception is propagated by a remote subprogram call, but
the exception does not exist in the calling partition, the exception can
be handled by an others choice or be propagated to and handled by a
third partition.
@end enumerate

@menu
* E.4.1:: Pragma Asynchronous
* E.4.2:: Example of Use of a Remote Access-to-Class-Wide Type
@end menu

@c ---------------------------------------------------------------------------
@node E.4.1, E.4.2, E.4, E.4
@subsection Pragma Asynchronous

@enumerate
@item
This subclause introduces the pragma Asynchronous which allows a remote
subprogram call to return prior to completion of the execution of the
corresponding remote subprogram body.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Asynchronous is as follows:

@item
@example
pragma Asynchronous(local_name);
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The local_name of a pragma Asynchronous shall denote either:

@enumerate 5
@item
One or more remote procedures; the formal parameters of the procedure(s)
shall all be of mode in;

@item
The first subtype of a remote access-to-procedure type; the formal
parameters of the designated profile of the type shall all be of mode
in;

@item
The first subtype of a remote access-to-class-wide type.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate 8
@item
A pragma Asynchronous is a representation pragma. When applied to a
type, it specifies the type-related asynchronous aspect of the type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A remote call is asynchronous if it is a call to a procedure, or a call
through a value of an access-to-procedure type, to which a pragma
Asynchronous applies. In addition, if a pragma Asynchronous applies to a
remote access-to-class-wide type, then a dispatching call on a procedure
with a controlling operand designated by a value of the type is
asynchronous if the formal parameters of the procedure are all of mode
in.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
Asynchronous remote procedure calls shall be implemented such that the
corresponding body executes at most once as a result of the call.
@end enumerate

@c ---------------------------------------------------------------------------
@node E.4.2, E.5, E.4.1, E.4
@subsection Example of Use of a Remote Access-to-Class-Wide Type

@need 1000
@sp 1
@center @emph{Examples}

@enumerate
@item
Example of using a remote access-to-class-wide type to achieve dynamic
binding across active partitions:

@item
@example
package Tapes is
   pragma Pure(Tapes);
   type Tape is abstract tagged limited private;
   -- Primitive dispatching operations where
   -- Tape is controlling operand
   procedure Copy (From, To : access Tape;
                   Num_Recs : in Natural) is abstract;
   procedure Rewind (T : access Tape) is abstract;
   -- More operations
private
   type Tape is ...
end Tapes;
@end example

@item
@example
with Tapes;
package Name_Server is
   pragma Remote_Call_Interface;
   -- Dynamic binding to remote operations is achieved
   -- using the access-to-limited-class-wide type Tape_Ptr
   type Tape_Ptr is access all Tapes.Tape'Class;
   -- The following statically bound remote operations
   -- allow for a name-server capability in this example
   function  Find     (Name : String) return Tape_Ptr;
   procedure Register (Name : in String; T : in Tape_Ptr);
   procedure Remove   (T : in Tape_Ptr);
   -- More operations
end Name_Server;
@end example

@item
@example
package Tape_Driver is
  -- Declarations are not shown, they are irrelevant here
end Tape_Driver;
@end example

@item
@example
with Tapes, Name_Server;
package body Tape_Driver is
   type New_Tape is new Tapes.Tape with ...
   procedure Copy
    (From, To : access New_Tape; Num_Recs: in Natural) is
   begin
     . . .
   end Copy;
   procedure Rewind (T : access New_Tape) is
   begin
      . . .
   end Rewind;
   -- Objects remotely accessible through use
   -- of Name_Server operations
   Tape1, Tape2 : aliased New_Tape;
begin
   Name_Server.Register ("NINE-TRACK",  Tape1'Access);
   Name_Server.Register ("SEVEN-TRACK", Tape2'Access);
end Tape_Driver;
@end example

@item
@example
with Tapes, Name_Server;
-- Tape_Driver is not needed
-- and thus not mentioned in the with_clause
procedure Tape_Client is
   T1, T2 : Name_Server.Tape_Ptr;
begin
   T1 := Name_Server.Find ("NINE-TRACK");
   T2 := Name_Server.Find ("SEVEN-TRACK");
   Tapes.Rewind (T1);
   Tapes.Rewind (T2);
   Tapes.Copy (T1, T2, 3);
end Tape_Client;
@end example

@item
Notes on the example:

@enumerate 9
@item
The package Tapes provides the necessary declarations of the type and
its primitive operations.

@item
Name_Server is a remote call interface package and is elaborated in a
separate active partition to provide the necessary naming services (such
as Register and Find) to the entire distributed program through remote
subprogram calls.

@item
Tape_Driver is a normal package that is elaborated in a partition
configured on the processing node that is connected to the tape
device(s). The abstract operations are overridden to support the locally
declared tape devices (Tape1, Tape2). The package is not visible to its
clients, but it exports the tape devices (as remote objects) through the
services of the Name_Server. This allows for tape devices to be
dynamically added, removed or replaced without requiring the
modification of the clients' code.

@item
The Tape_Client procedure references only declarations in the Tapes and
Name_Server packages. Before using a tape for the first time, it needs
to query the Name_Server for a system-wide identity for that tape. From
then on, it can use that identity to access the tape device.

@item
Values of remote access type Tape_Ptr include the necessary information
to complete the remote dispatching operations that result from
dereferencing the controlling operands T1 and T2.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node E.5, F, E.4.2, E
@section Partition Communication Subsystem

@enumerate
@item
The Partition Communication Subsystem (PCS) provides facilities for
supporting communication between the active partitions of a distributed
program. The package System.RPC is a language-defined interface to the
PCS. An implementation conforming to this Annex shall use the RPC
interface to implement remote subprogram calls.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following language-defined library package exists:

@item
@example
with Ada.Streams; --  see @ref{13.13.1}.
package System.RPC is
@end example

@item
@example
   type Partition_ID is range 0 .. implementation-defined;
@end example

@item
@example
   Communication_Error : exception;
@end example

@item
@example
   type Params_Stream_Type(
      Initial_Size : Ada.Streams.Stream_Element_Count) is new
      Ada.Streams.Root_Stream_Type with private;
@end example

@item
@example
   procedure Read(
      Stream : in out Params_Stream_Type;
      Item : out Ada.Streams.Stream_Element_Array;
      Last : out Ada.Streams.Stream_Element_Offset);
@end example

@item
@example
   procedure Write(
      Stream : in out Params_Stream_Type;
      Item : in Ada.Streams.Stream_Element_Array);
@end example

@item
@example
   -- Synchronous call
   procedure Do_RPC(
      Partition  : in Partition_ID;
      Params     : access Params_Stream_Type;
      Result     : access Params_Stream_Type);
@end example

@item
@example
   -- Asynchronous call
   procedure Do_APC(
      Partition  : in Partition_ID;
      Params     : access Params_Stream_Type);
@end example

@item
@example
   -- The handler for incoming RPCs
   type RPC_Receiver is access procedure(
      Params     : access Params_Stream_Type;
      Result     : access Params_Stream_Type);
@end example

@item
@example
   procedure Establish_RPC_Receiver(
      Partition : in Partition_ID;
      Receiver  : in RPC_Receiver);
@end example

@item
@example
private
   ... -- not specified by the language
end System.RPC;
@end example

@item
A value of the type Partition_ID is used to identify a partition.

@item
An object of the type Params_Stream_Type is used for identifying the
particular remote subprogram that is being called, as well as
marshalling and unmarshalling the parameters or result of a remote
subprogram call, as part of sending them between partitions.

@item
The Read and Write procedures override the corresponding abstract
operations for the type Params_Stream_Type.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The Do_RPC and Do_APC procedures send a message to the active partition
identified by the Partition parameter.

@item
After sending the message, Do_RPC blocks the calling task until a reply
message comes back from the called partition or some error is detected
by the underlying communication system in which case Communication_Error
is raised at the point of the call to Do_RPC.

@item
Do_APC operates in the same way as Do_RPC except that it is allowed to
return immediately after sending the message.

@item
Upon normal return, the stream designated by the Result parameter of
Do_RPC contains the reply message.

@item
The procedure System.RPC.Establish_RPC_Receiver is called once,
immediately after elaborating the library units of an active partition
(that is, right after the elaboration of the partition) if the partition
includes an RCI library unit, but prior to invoking the main subprogram,
if any. The Partition parameter is the Partition_ID of the active
partition being elaborated. The Receiver parameter designates an
implementation-provided procedure called the RPC-receiver which will
handle all RPCs received by the partition from the PCS.
Establish_RPC_Receiver saves a reference to the RPC-receiver; when a
message is received at the called partition, the RPC-receiver is called
with the Params stream containing the message. When the RPC-receiver
returns, the contents of the stream designated by Result is placed in a
message and sent back to the calling partition.

@item
If a call on Do_RPC is aborted, a cancellation message is sent to the
called partition, to request that the execution of the remotely called
subprogram be aborted.

@item
The subprograms declared in System.RPC are potentially blocking
operations.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation of the RPC-receiver shall be reentrant, thereby
allowing concurrent calls on it from the PCS to service concurrent
remote subprogram calls into the partition.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation of the PCS shall document whether the RPC-receiver is
invoked from concurrent tasks. If there is an upper limit on the number
of such tasks, this limit shall be documented as well, together with the
mechanisms to configure it (if this is supported).

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The PCS is allowed to contain implementation-defined interfaces for
explicit message passing, broadcasting, etc. Similarly, it is allowed to
provide additional interfaces to query the state of some remote
partition (given its partition ID) or of the PCS itself, to set timeouts
and retry parameters, to get more detailed error status, etc. These
additional interfaces should be provided in child packages of
System.RPC.

@item
A body for the package System.RPC need not be supplied by the
implementation.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Whenever possible, the PCS on the called partition should allow for
multiple tasks to call the RPC-receiver with different messages and
should allow them to block until the corresponding subprogram body
returns.

@item
The Write operation on a stream of type Params_Stream_Type should raise
Storage_Error if it runs out of space trying to write the Item into the
stream.

NOTES

@item
(8) The package System.RPC is not designed for direct calls by user
programs. It is instead designed for use in the implementation of remote
subprograms calls, being called by the calling stubs generated for a
remote call interface library unit to initiate a remote call, and in
turn calling back to an RPC-receiver that dispatches to the receiving
stubs generated for the body of a remote call interface, to handle a
remote call received from elsewhere.
@end enumerate

@c ===========================================================================
@node F, F.1, E.5, Top
@appendix  Information Systems (normative)

@enumerate
@item
This Annex provides a set of facilities relevant to Information Systems
programming. These fall into several categories:

@enumerate 2
@item
an attribute definition clause specifying Machine_Radix for a decimal
subtype;

@item
the package Decimal, which declares a set of constants defining the
implementation's capacity for decimal types, and a generic procedure for
decimal division; and

@item
the child packages Text_IO.Editing and Wide_Text_IO.Editing, which
support formatted and localized output of decimal data, based on
``picture String'' values.
@end enumerate
@end enumerate

@enumerate 5
@item
See also:  @ref{3.5.9, ``Fixed Point Types''}, @ref{3.5.10,
``Operations of Fixed Point Types''}, @ref{4.6, ``Type Conversions''},
@xref{13.3, ``Representation Attributes''}, @ref{A.10.9, ``Input-Output
for Real Types''}, @ref{B.4, ``Interfacing with COBOL''}, @ref{B.3,
``Interfacing with C''}, and @ref{G, ``Numerics''}.

@item
The character and string handling packages in @ref{A, ``Predefined
Language Environment''}, are also relevant for Information Systems.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
If COBOL (respectively, C) is widely supported in the target
environment, implementations supporting the Information Systems Annex
should provide the child package Interfaces.COBOL (respectively,
Interfaces.C) specified in Annex B and should support a
convention_identifier of COBOL (respectively, C) in the interfacing
pragmas, see @ref{B}, thus allowing Ada programs to interface with programs
written in that language.
@end enumerate

@menu
* F.1:: Machine_Radix Attribute Definition Clause
* F.2:: The Package Decimal
* F.3:: Edited Output for Decimal Types

--- The Detailed Node Listing ---

* F.1::   Machine_Radix Attribute Definition Clause
* F.2::   The Package Decimal
* F.3::   Edited Output for Decimal Types
* F.3.1:: Picture String Formation
* F.3.2:: Edited Output Generation
* F.3.3:: The Package Text_IO.Editing
* F.3.4:: The Package Wide_Text_IO.Editing
@end menu

@c ---------------------------------------------------------------------------
@node F.1, F.2, F, F
@section Machine_Radix Attribute Definition Clause

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
Machine_Radix may be specified for a decimal first subtype
(@pxref{3.5.9}) via an attribute_definition_clause; the expression of such
a clause shall be static, and its value shall be 2 or 10. A value of 2
implies a binary base range; a value of 10 implies a decimal base range.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Packed decimal should be used as the internal representation for objects
of subtype S when S'Machine_Radix = 10.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of Machine_Radix attribute definition clause:

@item
@example
type Money is delta 0.01 digits 15;
for Money'Machine_Radix use 10;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node F.2, F.3, F.1, F
@section The Package Decimal

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The library package Decimal has the following declaration:

@item
@example
package Ada.Decimal is
   pragma Pure(Decimal);
@end example

@item
@example
   Max_Scale : constant := implementation-defined;
   Min_Scale : constant := implementation-defined;
@end example

@item
@example
   Min_Delta : constant := 10.0**(-Max_Scale);
   Max_Delta : constant := 10.0**(-Min_Scale);
@end example

@item
@example
   Max_Decimal_Digits : constant := implementation-defined;
@end example

@item
@example
   generic
      type Dividend_Type  is delta <> digits <>;
      type Divisor_Type   is delta <> digits <>;
      type Quotient_Type  is delta <> digits <>;
      type Remainder_Type is delta <> digits <>;
   procedure Divide (Dividend  : in Dividend_Type;
                     Divisor   : in Divisor_Type;
                     Quotient  : out Quotient_Type;
                     Remainder : out Remainder_Type);
   pragma Convention(Intrinsic, Divide);
@end example

@item
@example
end Ada.Decimal;
@end example

@item
Max_Scale is the largest N such that 10.0**(-N) is allowed as a decimal
type's delta. Its type is universal_integer.

@item
Min_Scale is the smallest N such that 10.0**(-N) is allowed as a decimal
type's delta. Its type is universal_integer.

@item
Min_Delta is the smallest value allowed for delta in a
decimal_fixed_point_definition. Its type is universal_real.

@item
Max_Delta is the largest value allowed for delta in a
decimal_fixed_point_definition. Its type is universal_real.

@item
Max_Decimal_Digits is the largest value allowed for digits in a
decimal_fixed_point_definition. Its type is universal_integer.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The effect of Divide is as follows. The value of Quotient is
Quotient_Type(Dividend/Divisor). The value of Remainder is
Remainder_Type(Intermediate), where Intermediate is the difference
between Dividend and the product of Divisor and Quotient; this result is
computed exactly.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
Decimal.Max_Decimal_Digits shall be at least 18.

@item
Decimal.Max_Scale shall be at least 18.

@item
Decimal.Min_Scale shall be at most 0.

NOTES

@item
(1) The effect of division yielding a quotient with control over
rounding versus truncation is obtained by applying either the function
attribute Quotient_Type'Round or the conversion Quotient_Type to the
expression Dividend/Divisor.
@end enumerate

@c ---------------------------------------------------------------------------
@node F.3, F.3.1, F.2, F
@section Edited Output for Decimal Types

@enumerate
@item
The child packages Text_IO.Editing and Wide_Text_IO.Editing provide
localizable formatted text output, known as edited output , for decimal
types. An edited output string is a function of a numeric value,
program-specifiable locale elements, and a format control value. The
numeric value is of some decimal type. The locale elements are:

@enumerate 2
@item
the currency string;

@item
the digits group separator character;

@item
the radix mark character; and

@item
the fill character that replaces leading zeros of the numeric value.
@end enumerate
@end enumerate

@enumerate 6
@item
For Text_IO.Editing the edited output and currency strings are of type
String, and the locale characters are of type Character. For
Wide_Text_IO.Editing their types are Wide_String and Wide_Character,
respectively.

@item
Each of the locale elements has a default value that can be replaced or
explicitly overridden.

@item
A format-control value is of the private type Picture; it determines the
composition of the edited output string and controls the form and
placement of the sign, the position of the locale elements and the
decimal digits, the presence or absence of a radix mark, suppression of
leading zeros, and insertion of particular character values.

@item
A Picture object is composed from a String value, known as a picture
String, that serves as a template for the edited output string, and a
Boolean value that controls whether a string of all space characters is
produced when the number's value is zero. A picture String comprises a
sequence of one- or two-Character symbols, each serving as a placeholder
for a character or string at a corresponding position in the edited
output string. The picture String symbols fall into several categories
based on their effect on the edited output string:

@item
@example
Decimal Digit:      '9'
Radix Control:      '.'  'V'
Sign Control:       '+'  '-'  '<'  '>'  "CR"  "DB"
Currency Control:   '$'  '#'
Zero Suppression:   'Z'  '*'
Simple Insertion:   '_'  'B'  '0'  '/'
@end example

@item
The entries are not case-sensitive. Mixed- or lower-case forms for "CR"
and "DB", and lower-case forms for 'V', 'Z', and 'B', have the same
effect as the upper-case symbols shown.

@item
An occurrence of a '9' Character in the picture String represents a
decimal digit position in the edited output string.

@item
A radix control Character in the picture String indicates the position
of the radix mark in the edited output string: an actual character
position for '.', or an assumed position for 'V'.

@item
A sign control Character in the picture String affects the form of the
sign in the edited output string. The '<' and '>' Character values
indicate parentheses for negative values. A Character '+', '-', or '<'
appears either singly, signifying a fixed-position sign in the edited
output, or repeated, signifying a floating-position sign that is
preceded by zero or more space characters and that replaces a leading 0.

@item
A currency control Character in the picture String indicates an
occurrence of the currency string in the edited output string. The '$'
Character represents the complete currency string; the '#' Character
represents one character of the currency string. A '$' Character appears
either singly, indicating a fixed-position currency string in the edited
output, or repeated, indicating a floating-position currency string that
occurs in place of a leading 0. A sequence of '#' Character values
indicates either a fixed- or floating-position currency string,
depending on context.

@item
A zero suppression Character in the picture String allows a leading zero
to be replaced by either the space character (for 'Z') or the fill
character (for '*').

@item
A simple insertion Character in the picture String represents, in
general, either itself (if '/' or '0'), the space character (if 'B'), or
the digits group separator character (if '_'). In some contexts it is
treated as part of a floating sign, floating currency, or zero
suppression string.

@item
An example of a picture String is "<###Z_ZZ9.99>". If the currency
string is "FF", the separator character is ',', and the radix mark is
'.' then the edited output string values for the decimal values 32.10
and -5432.10 are "bbFFbbb32.10b" and "(bFF5,432.10)", respectively,
where 'b' indicates the space character.

@item
The generic packages Text_IO.Decimal_IO and Wide_Text_IO.Decimal_IO
(@pxref{A.10.9, ``Input-Output for Real Types''}) provide text input and
non-edited text output for decimal types.

NOTES

@item
(2) A picture String is of type Standard.String, both for
Text_IO.Editing and Wide_Text_IO.Editing.
@end enumerate

@menu
* F.3.1:: Picture String Formation
* F.3.2:: Edited Output Generation
* F.3.3:: The Package Text_IO.Editing
* F.3.4:: The Package Wide_Text_IO.Editing
@end menu

@c ---------------------------------------------------------------------------
@node F.3.1, F.3.2, F.3, F.3
@subsection Picture String Formation

@enumerate
@item
A well-formed picture String, or simply picture String, is a String
value that conforms to the syntactic rules, composition constraints, and
character replication conventions specified in this clause.
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 3
@item
@example
picture_string ::=
   fixed_$_picture_string
 | fixed_#_picture_string
 | floating_currency_picture_string
 | non_currency_picture_string
@end example

@item
@example
fixed_$_picture_string ::=
   [fixed_LHS_sign] fixed_$_char @{direct_insertion@}
     [zero_suppression] number [RHS_sign]

 | [fixed_LHS_sign @{direct_insertion@}] [zero_suppression]
     number fixed_$_char @{direct_insertion@} [RHS_sign]

 | floating_LHS_sign number fixed_$_char @{direct_insertion@}
     [RHS_sign]

 | [fixed_LHS_sign] fixed_$_char @{direct_insertion@}
     all_zero_suppression_number @{direct_insertion@}  [RHS_sign]

 | [fixed_LHS_sign @{direct_insertion@}] all_zero_suppression_number
     @{direct_insertion@} fixed_$_char @{direct_insertion@}
     [RHS_sign]

 | all_sign_number @{direct_insertion@} fixed_$_char
     @{direct_insertion@} [RHS_sign]
@end example

@item
@example
fixed_#_picture_string ::=
   [fixed_LHS_sign] single_#_currency @{direct_insertion@}
     [zero_suppression] number [RHS_sign]

 | [fixed_LHS_sign] multiple_#_currency @{direct_insertion@}
     zero_suppression number [RHS_sign]

 | [fixed_LHS_sign @{direct_insertion@}] [zero_suppression]
     number fixed_#_currency @{direct_insertion@} [RHS_sign]

 | floating_LHS_sign number fixed_#_currency @{direct_insertion@}
     [RHS_sign]

 | [fixed_LHS_sign] single_#_currency @{direct_insertion@}
     all_zero_suppression_number @{direct_insertion@} [RHS_sign]

 | [fixed_LHS_sign] multiple_#_currency @{direct_insertion@}
     all_zero_suppression_number @{direct_insertion@} [RHS_sign]

 | [fixed_LHS_sign @{direct_insertion@}] all_zero_suppression_number
     @{direct_insertion@} fixed_#_currency @{direct_insertion@}
     [RHS_sign]

 | all_sign_number @{direct_insertion@} fixed_#_currency
     @{direct_insertion@} [RHS_sign]
@end example

@item
@example
floating_currency_picture_string ::=
   [fixed_LHS_sign] @{direct_insertion@} floating_$_currency
     number [RHS_sign]
 | [fixed_LHS_sign] @{direct_insertion@} floating_#_currency
     number [RHS_sign]
 | [fixed_LHS_sign] @{direct_insertion@} all_currency_number
     @{direct_insertion@} [RHS_sign]
@end example

@item
@example
non_currency_picture_string ::=
   [fixed_LHS_sign @{direct_insertion@}] zero_suppression
     number [RHS_sign]
 | [floating_LHS_sign]
     number [RHS_sign]
 | [fixed_LHS_sign @{direct_insertion@}]
   all_zero_suppression_number @{direct_insertion@} [RHS_sign]
 | all_sign_number @{direct_insertion@}
 | fixed_LHS_sign direct_insertion @{direct_insertion@}
     number [RHS_sign]
@end example

@item
@example
fixed_LHS_sign ::=  LHS_Sign
@end example

@item
@example
LHS_Sign ::=  + | - | <
@end example

@item
@example
fixed_$_char ::= $
@end example

@item
@example
direct_insertion ::=  simple_insertion
@end example

@item
@example
simple_insertion ::=  _ | B | 0 | /
@end example

@item
@example
zero_suppression ::=  Z @{Z
                      | context_sensitive_insertion@}
                      | fill_string
@end example

@item
@example
context_sensitive_insertion ::=  simple_insertion
@end example

@item
@example
fill_string ::=  * @{* | context_sensitive_insertion@}
@end example

@item
@example
number ::=
   fore_digits [radix [aft_digits] @{direct_insertion@}]
 | radix aft_digits @{direct_insertion@}
@end example

@item
@example
fore_digits ::= 9 @{9 | direct_insertion@}
@end example

@item
@example
aft_digits ::=  @{9 | direct_insertion@} 9
@end example

@item
@example
radix ::= . | V
@end example

@item
@example
RHS_sign ::= + | - | > | CR | DB
@end example

@item
@example
floating_LHS_sign ::=
   LHS_Sign @{context_sensitive_insertion@} LHS_Sign
     @{LHS_Sign | context_sensitive_insertion@}
@end example

@item
@example
single_#_currency ::= #
@end example

@item
@example
multiple_#_currency ::= ## @{#@}
@end example

@item
@example
fixed_#_currency ::= single_#_currency | multiple_#_currency
@end example

@item
@example
floating_$_currency ::=
   $ @{context_sensitive_insertion@} $ @{$
   | context_sensitive_insertion@}
@end example

@item
@example
floating_#_currency ::=
   # @{context_sensitive_insertion@} # @{#
   | context_sensitive_insertion@}
@end example

@item
@example
all_sign_number ::=  all_sign_fore [radix [all_sign_aft]] [>]
@end example

@item
@example
all_sign_fore ::=
   sign_char @{context_sensitive_insertion@} sign_char @{sign_char
   | context_sensitive_insertion@}
@end example

@item
@example
all_sign_aft ::= @{all_sign_aft_char@} sign_char

all_sign_aft_char ::=  sign_char | context_sensitive_insertion
@end example

@item
@example
sign_char ::= + | - | <
@end example

@item
@example
all_currency_number ::=  all_currency_fore
  [radix [all_currency_aft]]
@end example

@item
@example
all_currency_fore ::=
   currency_char @{context_sensitive_insertion@}
     currency_char @{currency_char | context_sensitive_insertion@}
@end example

@item
@example
all_currency_aft ::= @{all_currency_aft_char@} currency_char

all_currency_aft_char ::= currency_char
                          | context_sensitive_insertion
@end example

@item
@example
currency_char ::= $ | #
@end example

@item
@example
all_zero_suppression_number ::=  all_zero_suppression_fore
  [ radix [all_zero_suppression_aft]]
@end example

@item
@example
all_zero_suppression_fore ::=
   zero_suppression_char @{zero_suppression_char
   | context_sensitive_insertion@}
@end example

@item
@example
all_zero_suppression_aft ::= @{all_zero_suppression_aft_char@}
  zero_suppression_char

all_zero_suppression_aft_char ::=  zero_suppression_char
                                   | context_sensitive_insertion
@end example

@item
@example
zero_suppression_char ::= Z | *
@end example

@item
The following composition constraints apply to a picture String:

@enumerate 40
@item
A floating_LHS_sign does not have occurrences of different LHS_Sign
Character values.

@item
If a picture String has '<' as fixed_LHS_sign, then it has '>' as
RHS_sign.

@item
If a picture String has '<' in a floating_LHS_sign or in an
all_sign_number, then it has an occurrence of '>'.

@item
If a picture String has '+' or '-' as fixed_LHS_sign, in a
floating_LHS_sign, or in an all_sign_number, then it has no RHS_sign.

@item
An instance of all_sign_number does not have occurrences of different
sign_char Character values.

@item
An instance of all_currency_number does not have occurrences of
different currency_char Character values.

@item
An instance of all_zero_suppression_number does not have occurrences of
different zero_suppression_char Character values, except for possible
case differences between 'Z' and 'z'.
@end enumerate
@end enumerate

@enumerate 47
@item
A replicable Character is a Character that, by the above rules, can
occur in two consecutive positions in a picture String.

@item
A Character replication is a String

@item
@example
char & '(' & spaces & count_string & ')'
@end example

@item
where char is a replicable Character, spaces is a String (possibly
empty) comprising only space Character values, and count_string is a
String of one or more decimal digit Character values. A Character
replication in a picture String has the same effect as (and is said to
be equivalent to) a String comprising n consecutive occurrences of char,
where n=Integer'Value(count_string).

@item
An expanded picture String is a picture String containing no Character
replications.

NOTES

@item
(3) Although a sign to the left of the number can float, a sign to the
right of the number is in a fixed position.
@end enumerate

@c ---------------------------------------------------------------------------
@node F.3.2, F.3.3, F.3.1, F.3
@subsection Edited Output Generation

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate
@item
The contents of an edited output string are based on:

@enumerate 2
@item
A value, Item, of some decimal type Num,

@item
An expanded picture String Pic_String,

@item
A Boolean value, Blank_When_Zero,

@item
A Currency string,

@item
A Fill character,

@item
A Separator character, and

@item
A Radix_Mark character.
@end enumerate
@end enumerate

@enumerate 9
@item
The combination of a True value for Blank_When_Zero and a '*' character
in Pic_String is inconsistent; no edited output string is defined.

@item
A layout error is identified in the rules below if leading non-zero
digits of Item, character values of the Currency string, or a negative
sign would be truncated; in such cases no edited output string is
defined.

@item
The edited output string has lower bound 1 and upper bound N where N =
Pic_String'Length + Currency_Length_Adjustment - Radix_Adjustment, and

@enumerate 12
@item
Currency_Length_Adjustment = Currency'Length - 1 if there is some
occurrence of '$' in Pic_String, and 0 otherwise.

@item
Radix_Adjustment = 1 if there is an occurrence of 'V' or 'v' in Pic_Str,
and 0 otherwise.

@item
@format
Let the magnitude of Item be expressed as a base-10 number
I ***I .F ***F , called the displayed magnitude of Item, where:
 p    1  1    q
@end format

@item
q = Min(Max(Num'Scale, 0), n) where n is 0 if Pic_String has no radix
and is otherwise the number of digit positions following radix in
Pic_String, where a digit position corresponds to an occurrence of '9',
a zero_suppression_char (for an all_zero_suppression_number), a
currency_char (for an all_currency_number), or a sign_char (for an
all_sign_number).

@item
@format
I  /= 0 if p>0.
 p
@end format
@end enumerate
@end enumerate

@enumerate 17
@item
If n < Num'Scale, then the above number is the result of rounding (away
from 0 if exactly midway between values).

@item
If Blank_When_Zero = True and the displayed magnitude of Item is zero,
then the edited output string comprises all space character values.
Otherwise, the picture String is treated as a sequence of instances of
syntactic categories based on the rules in @ref{F.3.1}, and the edited
output string is the concatenation of string values derived from these
categories according to the following mapping rules.

@item
Table F-1 shows the mapping from a sign control symbol to a
corresponding character or string in the edited output. In the columns
showing the edited output, a lower-case 'b' represents the space
character. If there is no sign control symbol but the value of Item is
negative, a layout error occurs and no edited output string is produced.

@format
    +---------------------------------------------------+
    |                                                   |
    | Table F-1: Edited Output for Sign Control Symbols |
    |                                                   |
    +----------------+------------------+---------------+
    |                |                  |               |
    | Sign Control   | Edited Output    | Edited Output |
    | Symbol         | for Non-Negative | for Negative  |
    |                | Number           | Number        |
    |                |                  |               |
    +----------------+------------------+---------------+
    |                |                  |               |
    |      '+'       |        '+'       |      '-'      |
    |                |                  |               |
    |      '-'       |        'b'       |      '-'      |
    |                |                  |               |
    |      '<'       |        'b'       |      '('      |
    |                |                  |               |
    |      '>'       |        'b'       |      ')'      |
    |                |                  |               |
    |     "CR"       |       "bb"       |     "CR"      |
    |                |                  |               |
    |     "DB"       |       "bb"       |     "DB"      |
    |                |                  |               |
    +----------------+------------------+---------------+
@end format

@item
An instance of fixed_LHS_sign maps to a character as shown in Table F-1.

@item
An instance of fixed_$_char maps to Currency.

@item
An instance of direct_insertion maps to Separator if direct_insertion =
'_', and to the direct_insertion Character otherwise.

@item
An instance of number maps to a string integer_part & radix_part &
fraction_part where:

@enumerate 24
@item
The string for integer_part is obtained as follows:

@enumerate 25
@item
@format
Occurrences of '9' in fore_digits of number are replaced
from right to left with the decimal digit character values
for I , ..., I , respectively.
     1        p
@end format

@item
Each occurrence of '9' in fore_digits to the left of the leftmost '9'
replaced according to rule 1 is replaced with '0'.

@item
If p exceeds the number of occurrences of '9' in fore_digits of number,
then the excess leftmost digits are eligible for use in the mapping of
an instance of zero_suppression, floating_LHS_sign, floating_$_currency,
or floating_#_currency to the left of number; if there is no such
instance, then a layout error occurs and no edited output string is
produced.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 28
@item
The radix_part is:

@enumerate 29
@item
"" if number does not include a radix, if radix = 'V', or if radix = 'v'

@item
Radix_Mark if number includes '.' as radix
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 30
@item
The string for fraction_part is obtained as follows:

@enumerate 34
@item
@format
Occurrences of '9' in aft_digits of number are replaced
from left to right with the decimal digit character values
for F , ... F .
     1       q
@end format

@item
Each occurrence of '9' in aft_digits to the right of the rightmost '9'
replaced according to rule 1 is replaced by '0'.
@end enumerate
@end enumerate
@end enumerate

@enumerate 34
@item
An instance of zero_suppression maps to the string obtained as follows:

@enumerate 35
@item
The rightmost 'Z', 'z', or '*' Character values are replaced with the
excess digits (if any) from the integer_part of the mapping of the
number to the right of the zero_suppression instance,

@item
A context_sensitive_insertion Character is replaced as though it were a
direct_insertion Character, if it occurs to the right of some 'Z', 'z',
or '*' in zero_suppression that has been mapped to an excess digit,

@item
Each Character to the left of the leftmost Character replaced according
to rule 1 above is replaced by:

@enumerate 38
@item
the space character if the zero suppression Character is 'Z' or 'z', or

@item
the Fill character if the zero suppression Character is '*'.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 40
@item
A layout error occurs if some excess digits remain after all 'Z', 'z',
and '*' Character values in zero_suppression have been replaced via rule
1; no edited output string is produced.
@end enumerate
@end enumerate

@enumerate 41
@item
An instance of RHS_sign maps to a character or string as shown in Table
F-1.

@item
An instance of floating_LHS_sign maps to the string obtained as follows.

@enumerate 43
@item
Up to all but one of the rightmost LHS_Sign Character values are
replaced by the excess digits (if any) from the integer_part of the
mapping of the number to the right of the floating_LHS_sign instance.

@item
The next Character to the left is replaced with the character given by
the entry in Table F-1 corresponding to the LHS_Sign Character.

@item
A context_sensitive_insertion Character is replaced as though it were a
direct_insertion Character, if it occurs to the right of the leftmost
LHS_Sign character replaced according to rule 1.

@item
Any other Character is replaced by the space character..

@item
A layout error occurs if some excess digits remain after replacement via
rule 1; no edited output string is produced.
@end enumerate
@end enumerate

@enumerate 48
@item
An instance of fixed_#_currency maps to the Currency string with n space
character values concatenated on the left (if the instance does not
follow a radix) or on the right (if the instance does follow a radix),
where n is the difference between the length of the fixed_#_currency
instance and Currency'Length. A layout error occurs if Currency'Length
exceeds the length of the fixed_#_currency instance; no edited output
string is produced.

@item
An instance of floating_$_currency maps to the string obtained as
follows:

@enumerate 50
@item
Up to all but one of the rightmost '$' Character values are replaced
with the excess digits (if any) from the integer_part of the mapping of
the number to the right of the floating_$_currency instance.

@item
The next Character to the left is replaced by the Currency string.

@item
A context_sensitive_insertion Character is replaced as though it were a
direct_insertion Character, if it occurs to the right of the leftmost
'$' Character replaced via rule 1.

@item
Each other Character is replaced by the space character.

@item
A layout error occurs if some excess digits remain after replacement by
rule 1; no edited output string is produced.
@end enumerate
@end enumerate

@enumerate 55
@item
An instance of floating_#_currency maps to the string obtained as
follows:

@enumerate 56
@item
Up to all but one of the rightmost '#' Character values are replaced
with the excess digits (if any) from the integer_part of the mapping of
the number to the right of the floating_#_currency instance.

@item
The substring whose last Character occurs at the position immediately
preceding the leftmost Character replaced via rule 1, and whose length
is Currency'Length, is replaced by the Currency string.

@item
A context_sensitive_insertion Character is replaced as though it were a
direct_insertion Character, if it occurs to the right of the leftmost
'#' replaced via rule 1.

@item
Any other Character is replaced by the space character.

@item
A layout error occurs if some excess digits remain after replacement
rule 1, or if there is no substring with the required length for
replacement rule 2; no edited output string is produced.
@end enumerate
@end enumerate

@enumerate 61
@item
An instance of all_zero_suppression_number maps to:

@enumerate 62
@item
a string of all spaces if the displayed magnitude of Item is zero, the
zero_suppression_char is 'Z' or 'z', and the instance of
all_zero_suppression_number does not have a radix at its last character
position;

@item
a string containing the Fill character in each position except for the
character (if any) corresponding to radix, if zero_suppression_char =
'*' and the displayed magnitude of Item is zero;

@item
otherwise, the same result as if each zero_suppression_char in
all_zero_suppression_aft were '9', interpreting the instance of
all_zero_suppression_number as either zero_suppression number (if a
radix and all_zero_suppression_aft are present), or as zero_suppression
otherwise.
@end enumerate
@end enumerate

@enumerate 65
@item
An instance of all_sign_number maps to:

@enumerate 66
@item
a string of all spaces if the displayed magnitude of Item is zero and
the instance of all_sign_number does not have a radix at its last
character position;

@item
otherwise, the same result as if each sign_char in all_sign_number_aft
were '9', interpreting the instance of all_sign_number as either
floating_LHS_sign number (if a radix and all_sign_number_aft are
present), or as floating_LHS_sign otherwise.
@end enumerate
@end enumerate

@enumerate 68
@item
An instance of all_currency_number maps to:

@enumerate 69
@item
a string of all spaces if the displayed magnitude of Item is zero and
the instance of all_currency_number does not have a radix at its last
character position;

@item
otherwise, the same result as if each currency_char in
all_currency_number_aft were '9', interpreting the instance of
all_currency_number as floating_$_currency number or floating_#_currency
number (if a radix and all_currency_number_aft are present), or as
floating_$_currency or floating_#_currency otherwise.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Examples}

@enumerate 71
@item
In the result string values shown below, 'b' represents the space
character.

@item
@example
Item:         Picture and Result Strings:
@end example

@item
@example
123456.78     Picture:  "-###**_***_**9.99"
                        "bbb$***123,456.78"
                        "bbFF***123.456,78" (currency = "FF",
                                             separator = '.',
                                             radix mark = ',')
@end example

@item
@example
123456.78     Picture:  "-$$$**_***_**9.99"
              Result:   "bbb$***123,456.78"
                        "bbbFF***123.456,78" (currency = "FF",
                                              separator = '.',
                                              radix mark = ',')
@end example

@item
@example
0.0          Picture: "-$$$$$$.$$"
             Result:  "bbbbbbbbbb"
@end example

@item
@example
0.20         Picture: "-$$$$$$.$$"
             Result:  "bbbbbb$.20"
@end example

@item
@example
-1234.565    Picture: "<<<<_<<<.<<###>"
             Result:  "bb(1,234.57DMb)"  (currency = "DM")
@end example

@item
@example
12345.67     Picture: "###_###_##9.99"
             Result:  "bbCHF12,345.67"   (currency = "CHF")
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node F.3.3, F.3.4, F.3.2, F.3
@subsection The Package Text_IO.Editing

@enumerate
@item
The package Text_IO.Editing provides a private type Picture with
associated operations, and a generic package Decimal_Output. An object
of type Picture is composed from a well-formed picture String
(@pxref{F.3.1}) and a Boolean item indicating whether a zero numeric value
will result in an edited output string of all space characters. The
package Decimal_Output contains edited output subprograms implementing
the effects defined in @ref{F.3.2}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The library package Text_IO.Editing has the following declaration:

@item
@example
package Ada.Text_IO.Editing is
@end example

@item
@example
   type Picture is private;
@end example

@item
@example
   function Valid (Pic_String      : in String;
                   Blank_When_Zero : in Boolean := False)
     return Boolean;
@end example

@item
@example
   function To_Picture (Pic_String      : in String;
                        Blank_When_Zero : in Boolean := False)
      return Picture;
@end example

@item
@example
   function Pic_String      (Pic : in Picture) return String;
   function Blank_When_Zero (Pic : in Picture) return Boolean;
@end example

@item
@example
   Max_Picture_Length  : constant := implementation_defined;
@end example

@item
@example
   Picture_Error       : exception;
@end example

@item
@example
   Default_Currency    : constant String    := "$";
   Default_Fill        : constant Character := '*';
   Default_Separator   : constant Character := ',';
   Default_Radix_Mark  : constant Character := '.';
@end example

@item
@example
   generic
      type Num is delta <> digits <>;
      Default_Currency   : in String
        :=  Text_IO.Editing.Default_Currency;
      Default_Fill       : in Character
        :=  Text_IO.Editing.Default_Fill;
      Default_Separator  : in Character
        :=  Text_IO.Editing.Default_Separator;
      Default_Radix_Mark : in Character
        :=  Text_IO.Editing.Default_Radix_Mark;
   package Decimal_Output is
      function Length (Pic      : in Picture;
                       Currency : in String := Default_Currency)
         return Natural;
@end example

@item
@example
      function Valid (Item     : in Num;
                      Pic      : in Picture;
                      Currency : in String := Default_Currency)
         return Boolean;
@end example

@item
@example
      function Image
        (Item       : in Num;
         Pic        : in Picture;
         Currency   : in String    := Default_Currency;
         Fill       : in Character := Default_Fill;
         Separator  : in Character := Default_Separator;
         Radix_Mark : in Character := Default_Radix_Mark)
         return String;
@end example

@item
@example
      procedure Put
        (File       : in File_Type;
         Item       : in Num;
         Pic        : in Picture;
         Currency   : in String    := Default_Currency;
         Fill       : in Character := Default_Fill;
         Separator  : in Character := Default_Separator;
         Radix_Mark : in Character := Default_Radix_Mark);
@end example

@item
@example
      procedure Put
        (Item       : in Num;
         Pic        : in Picture;
         Currency   : in String    := Default_Currency;
         Fill       : in Character := Default_Fill;
         Separator  : in Character := Default_Separator;
         Radix_Mark : in Character := Default_Radix_Mark);
@end example

@item
@example
      procedure Put
        (To         : out String;
         Item       : in Num;
         Pic        : in Picture;
         Currency   : in String    := Default_Currency;
         Fill       : in Character := Default_Fill;
         Separator  : in Character := Default_Separator;
         Radix_Mark : in Character := Default_Radix_Mark);
   end Decimal_Output;
private
   ... -- not specified by the language
end Ada.Text_IO.Editing;
@end example

@item
The exception Constraint_Error is raised if the Image function or any of
the Put procedures is invoked with a null string for Currency.

@item
@format
function Valid (Pic_String      : in String;
                Blank_When_Zero : in Boolean := False)
  return Boolean;
@end format

@enumerate 19
@item
Valid returns True if Pic_String is a well-formed picture String
(@pxref{F.3.1}) the length of whose expansion does not exceed
Max_Picture_Length, and if either Blank_When_Zero is False or Pic_String
contains no '*'.
@end enumerate
@end enumerate

@enumerate 20
@item
@format
function To_Picture (Pic_String      : in String;
                     Blank_When_Zero : in Boolean := False)
   return Picture;
@end format

@enumerate 21
@item
To_Picture returns a result Picture such that the application of the
function Pic_String to this result yields an expanded picture String
equivalent to Pic_String, and such that Blank_When_Zero applied to the
result Picture is the same value as the parameter Blank_When_Zero.
Picture_Error is raised if not Valid(Pic_String, Blank_When_Zero).
@end enumerate
@end enumerate

@enumerate 22
@item
@format
function Pic_String      (Pic : in Picture) return String;

function Blank_When_Zero (Pic : in Picture) return Boolean;
@end format

@enumerate 23
@item
If Pic is To_Picture(String_Item, Boolean_Item) for some String_Item and
Boolean_Item, then:

@enumerate 24
@item
Pic_String(Pic) returns an expanded picture String equivalent to
String_Item and with any lower-case letter replaced with its
corresponding upper-case form, and

@item
Blank_When_Zero(Pic) returns Boolean_Item.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 26
@item
If Pic_1 and Pic_2 are objects of type Picture, then "="(Pic_1, Pic_2)
is True when

@enumerate 27
@item
Pic_String(Pic_1) = Pic_String(Pic_2), and

@item
Blank_When_Zero(Pic_1) = Blank_When_Zero(Pic_2).
@end enumerate
@end enumerate
@end enumerate

@enumerate 29
@item
@format
function Length (Pic      : in Picture;
                 Currency : in String := Default_Currency)
   return Natural;
@end format

@enumerate 30
@item
Length returns Pic_String(Pic)'Length + Currency_Length_Adjustment -
Radix_Adjustment where

@enumerate 31
@item
Currency_Length_Adjustment =

@enumerate 32
@item
Currency'Length - 1 if there is some occurrence of '$' in
Pic_String(Pic), and

@item
0 otherwise.
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 34
@item
Radix_Adjustment =

@enumerate 35
@item
1 if there is an occurrence of 'V' or 'v' in Pic_Str(Pic), and

@item
0 otherwise.
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate 37
@item
@format
function Valid (Item     : in Num;
                Pic      : in Picture;
                Currency : in String := Default_Currency)
   return Boolean;
@end format

@enumerate 38
@item
Valid returns True if Image(Item, Pic, Currency) does not raise
Layout_Error, and returns False otherwise.
@end enumerate
@end enumerate

@enumerate 39
@item
@format
function Image (Item       : in Num;
                Pic        : in Picture;
                Currency   : in String    := Default_Currency;
                Fill       : in Character := Default_Fill;
                Separator  : in Character := Default_Separator;
                Radix_Mark : in Character := Default_Radix_Mark)
   return String;
@end format

@enumerate 40
@item
Image returns the edited output String as defined in @ref{F.3.2}, for
Item, Pic_String(Pic), Blank_When_Zero(Pic), Currency, Fill, Separator,
and Radix_Mark. If these rules identify a layout error, then Image
raises the exception Layout_Error.
@end enumerate
@end enumerate

@enumerate 41
@item
@format
procedure Put (File       : in File_Type;
               Item       : in Num;
               Pic        : in Picture;
               Currency   : in String    := Default_Currency;
               Fill       : in Character := Default_Fill;
               Separator  : in Character := Default_Separator;
               Radix_Mark : in Character := Default_Radix_Mark);

procedure Put (Item       : in Num;
               Pic        : in Picture;
               Currency   : in String    := Default_Currency;
               Fill       : in Character := Default_Fill;
               Separator  : in Character := Default_Separator;
               Radix_Mark : in Character := Default_Radix_Mark);
@end format

@enumerate 42
@item
Each of these Put procedures outputs Image(Item, Pic, Currency, Fill,
Separator, Radix_Mark) consistent with the conventions for Put for other
real types in case of bounded line length, see @ref{A.10.6, ``Get and Put
Procedures''}.
@end enumerate
@end enumerate

@enumerate 43
@item
@format
procedure Put (To         : out String;
               Item       : in Num;
               Pic        : in Picture;
               Currency   : in String    := Default_Currency;
               Fill       : in Character := Default_Fill;
               Separator  : in Character := Default_Separator;
               Radix_Mark : in Character := Default_Radix_Mark);
@end format

@enumerate 44
@item
Put copies Image(Item, Pic, Currency, Fill, Separator, Radix_Mark) to
the given string, right justified. Otherwise unassigned Character values
in To are assigned the space character. If To'Length is less than the
length of the string resulting from Image, then Layout_Error is raised.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@enumerate 45
@item
Max_Picture_Length shall be at least 30. The implementation shall
support currency strings of length up to at least 10, both for
Default_Currency in an instantiation of Decimal_Output, and for Currency
in an invocation of Image or any of the Put procedures.

NOTES

@item
(4) The rules for edited output are based on COBOL (ANSI X3.23:1985,
endorsed by ISO as ISO 1989-1985), with the following differences:

@enumerate 37
@item
The COBOL provisions for picture string localization and for 'P' format
are absent from Ada.

@item
The following Ada facilities are not in COBOL:

@enumerate 49
@item
currency symbol placement after the number,

@item
localization of edited output string for multi-character currency string
values, including support for both length-preserving and
length-expanding currency symbols in picture strings

@item
localization of the radix mark, digits separator, and
fill character, and

@item
parenthesization of negative values.
@end enumerate
@end enumerate
@end enumerate

@enumerate 37
The value of 30 for Max_Picture_Length is the same limit as in COBOL.
@end enumerate

@c ---------------------------------------------------------------------------
@node F.3.4, G, F.3.3, F.3
@subsection The Package Wide_Text_IO.Editing

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The child package Wide_Text_IO.Editing has the same contents as
Text_IO.Editing, except that:

@enumerate 2
@item
each occurrence of Character is replaced by Wide_Character,

@item
each occurrence of Text_IO is replaced by Wide_Text_IO,

@item
the subtype of Default_Currency is Wide_String rather than String, and

@item
each occurrence of String in the generic package Decimal_Output is
replaced by Wide_String.
@end enumerate
@end enumerate
@enumerate 6

NOTES

@item
(5) Each of the functions Wide_Text_IO.Editing.Valid, To_Picture, and
Pic_String has String (versus Wide_String) as its parameter or result
subtype, since a picture String is not localizable.
@end enumerate

@c ===========================================================================
@node G, G.1, F.3.4, Top
@appendix  Numerics (normative)

@enumerate
@item
The Numerics Annex specifies

@enumerate 2
@item
features for complex arithmetic, including complex I/O;

@item
a mode (``strict mode''), in which the predefined arithmetic operations
of floating point and fixed point types and the functions and operations
of various predefined packages have to provide guaranteed accuracy or
conform to other numeric performance requirements, which the Numerics
Annex also specifies;

@item
a mode (``relaxed mode''), in which no accuracy or other numeric
performance requirements need be satisfied, as for implementations not
conforming to the Numerics Annex;

@item
models of floating point and fixed point arithmetic on which the
accuracy requirements of strict mode are based; and

@item
the definitions of the model-oriented attributes of floating point types
that apply in the strict mode.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 7
@item
If Fortran (respectively, C) is widely supported in the target
environment, implementations supporting the Numerics Annex should
provide the child package Interfaces.Fortran (respectively,
Interfaces.C) specified in Annex B and should support a
convention_identifier of Fortran (respectively, C) in the interfacing
pragmas, see @ref{B, ``Annex B''}, thus allowing Ada programs to interface
with programs written in that language.
@end enumerate

@menu
* G.1:: Complex Arithmetic
* G.2:: Numeric Performance Requirements

--- The Detailed Node Listing ---

* G.1::   Complex Arithmetic
* G.1.1:: Complex Types
* G.1.2:: Complex Elementary Functions
* G.1.3:: Complex Input-Output
* G.1.4:: The Package Wide_Text_IO.Complex_IO
* G.2::   Numeric Performance Requirements
* G.2.1:: Model of Floating Point Arithmetic
* G.2.2:: Model-Oriented Attributes of Floating Point Types
* G.2.3:: Model of Fixed Point Arithmetic
* G.2.4:: Accuracy Requirements for the Elementary Functions
* G.2.5:: Performance Requirements for Random Number Generation
* G.2.6:: Accuracy Requirements for Complex Arithmetic
@end menu

@c ---------------------------------------------------------------------------
@node G.1, G.1.1, G, G
@section Complex Arithmetic

@enumerate
@item
Types and arithmetic operations for complex arithmetic are provided in
Generic_Complex_Types, which is defined in @ref{G.1.1}.
Implementation-defined approximations to the complex analogs of the
mathematical functions known as the ``elementary functions'' are
provided by the subprograms in Generic_Complex_Elementary_Functions,
which is defined in @ref{G.1.2}. Both of these library units are
generic children of the predefined package Numerics, see @ref{A.5}.
Nongeneric equivalents of these generic packages for each of the
predefined floating point types are also provided as children of
Numerics.
@end enumerate

@menu
* G.1.1:: Complex Types
* G.1.2:: Complex Elementary Functions
* G.1.3:: Complex Input-Output
* G.1.4:: The Package Wide_Text_IO.Complex_IO
@end menu

@c ---------------------------------------------------------------------------
@node G.1.1, G.1.2, G.1, G.1
@subsection Complex Types

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The generic library package Numerics.Generic_Complex_Types has the
following declaration:

@item
@example
generic
   type Real is digits <>;
package Ada.Numerics.Generic_Complex_Types is
   pragma Pure(Generic_Complex_Types);
@end example

@item
@example
   type Complex is
      record
         Re, Im : Real'Base;
      end record;
@end example

@item
@example
   type Imaginary is private;
@end example

@item
@example
   i : constant Imaginary;
   j : constant Imaginary;
@end example

@item
@example
   function Re (X : Complex)   return Real'Base;
   function Im (X : Complex)   return Real'Base;
   function Im (X : Imaginary) return Real'Base;
@end example

@item
@example
   procedure Set_Re (X  : in out Complex;
                     Re : in     Real'Base);
   procedure Set_Im (X  : in out Complex;
                     Im : in     Real'Base);
   procedure Set_Im (X  :    out Imaginary;
                     Im : in     Real'Base);
@end example

@item
@example
   function Compose_From_Cartesian (Re, Im : Real'Base)
     return Complex;
   function Compose_From_Cartesian (Re     : Real'Base)
     return Complex;
   function Compose_From_Cartesian (Im     : Imaginary)
     return Complex;
@end example

@item
@example
   function Modulus (X     : Complex) return Real'Base;
   function "abs"   (Right : Complex) return Real'Base
     renames Modulus;
@end example

@item
@example
   function Argument (X     : Complex)   return Real'Base;
   function Argument (X     : Complex;
                      Cycle : Real'Base) return Real'Base;
@end example

@item
@example
   function Compose_From_Polar
     (Modulus, Argument        : Real'Base)
      return Complex;
   function Compose_From_Polar
     (Modulus, Argument, Cycle : Real'Base)
      return Complex;
@end example

@item
@example
   function "+"       (Right : Complex) return Complex;
   function "-"       (Right : Complex) return Complex;
   function Conjugate (X     : Complex) return Complex;
@end example

@item
@example
   function "+" (Left, Right : Complex) return Complex;
   function "-" (Left, Right : Complex) return Complex;
   function "*" (Left, Right : Complex) return Complex;
   function "/" (Left, Right : Complex) return Complex;
@end example

@item
@example
   function "**" (Left : Complex; Right : Integer) return Complex;
@end example

@item
@example
   function "+"       (Right : Imaginary) return Imaginary;
   function "-"       (Right : Imaginary) return Imaginary;
   function Conjugate (X     : Imaginary) return Imaginary
     renames "-";
   function "abs"     (Right : Imaginary) return Real'Base;
@end example

@item
@example
   function "+" (Left, Right : Imaginary) return Imaginary;
   function "-" (Left, Right : Imaginary) return Imaginary;
   function "*" (Left, Right : Imaginary) return Real'Base;
   function "/" (Left, Right : Imaginary) return Real'Base;
@end example

@item
@example
   function "**" (Left : Imaginary; Right : Integer) return Complex;
@end example

@item
@example
   function "<"  (Left, Right : Imaginary) return Boolean;
   function "<=" (Left, Right : Imaginary) return Boolean;
   function ">"  (Left, Right : Imaginary) return Boolean;
   function ">=" (Left, Right : Imaginary) return Boolean;
@end example

@item
@example
   function "+" (Left  : Complex;
                 Right : Real'Base) return Complex;
   function "+" (Left  : Real'Base;
                 Right : Complex)   return Complex;
   function "-" (Left  : Complex;
                 Right : Real'Base) return Complex;
   function "-" (Left  : Real'Base;
                 Right : Complex)   return Complex;
   function "*" (Left  : Complex;
                 Right : Real'Base) return Complex;
   function "*" (Left  : Real'Base;
                 Right : Complex)   return Complex;
   function "/" (Left  : Complex;
                 Right : Real'Base) return Complex;
   function "/" (Left  : Real'Base;
                 Right : Complex)   return Complex;
@end example

@item
@example
   function "+" (Left  : Complex;
                 Right : Imaginary) return Complex;
   function "+" (Left  : Imaginary;
                 Right : Complex)   return Complex;
   function "-" (Left  : Complex;
                 Right : Imaginary) return Complex;
   function "-" (Left  : Imaginary;
                 Right : Complex)   return Complex;
   function "*" (Left  : Complex;
                 Right : Imaginary) return Complex;
   function "*" (Left  : Imaginary;
                 Right : Complex)   return Complex;
   function "/" (Left  : Complex;
                 Right : Imaginary) return Complex;
   function "/" (Left  : Imaginary;
                 Right : Complex)   return Complex;
@end example

@item
@example
   function "+" (Left  : Imaginary;
                 Right : Real'Base) return Complex;
   function "+" (Left  : Real'Base;
                 Right : Imaginary) return Complex;
   function "-" (Left  : Imaginary;
                 Right : Real'Base) return Complex;
   function "-" (Left  : Real'Base;
                 Right : Imaginary) return Complex;
   function "*" (Left  : Imaginary;
                 Right : Real'Base) return Imaginary;
   function "*" (Left  : Real'Base;
                 Right : Imaginary) return Imaginary;
   function "/" (Left  : Imaginary;
                 Right : Real'Base) return Imaginary;
   function "/" (Left  : Real'Base;
                 Right : Imaginary) return Imaginary;
@end example

@item
@example
private
@end example

@item
@example
   type Imaginary is new Real'Base;
   i : constant Imaginary := 1.0;
   j : constant Imaginary := 1.0;
@end example

@item
@example
end Ada.Numerics.Generic_Complex_Types;
@end example

@item
The library package Numerics.Complex_Types defines the same types,
constants, and subprograms as Numerics.Generic_Complex_Types, except
that the predefined type Float is systematically substituted for
Real'Base throughout. Nongeneric equivalents of
Numerics.Generic_Complex_Types for each of the other predefined floating
point types are defined similarly, with the names
Numerics.Short_Complex_Types, Numerics.Long_Complex_Types, etc.

@item
Complex is a visible type with cartesian components.

@item
Imaginary is a private type; its full type is derived from Real'Base.

@item
The arithmetic operations and the Re, Im, Modulus, Argument, and
Conjugate functions have their usual mathematical meanings. When applied
to a parameter of pure-imaginary type, the ``imaginary-part'' function
Im yields the value of its parameter, as the corresponding real value.
The remaining subprograms have the following meanings:

@enumerate 29
@item
The Set_Re and Set_Im procedures replace the designated component of a
complex parameter with the given real value; applied to a parameter of
pure-imaginary type, the Set_Im procedure replaces the value of that
parameter with the imaginary value corresponding to the given real
value.

@item
The Compose_From_Cartesian function constructs a complex value from the
given real and imaginary components. If only one component is given, the
other component is implicitly zero.

@item
The Compose_From_Polar function constructs a complex value from the
given modulus (radius) and argument (angle). When the value of the
parameter Modulus is positive (resp., negative), the result is the
complex value represented by the point in the complex plane lying at a
distance from the origin given by the absolute value of Modulus and
forming an angle measured counterclockwise from the positive (resp.,
negative) real axis given by the value of the parameter Argument.
@end enumerate
@end enumerate

@enumerate 32
@item
When the Cycle parameter is specified, the result of the Argument
function and the parameter Argument of the Compose_From_Polar function
are measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

@item
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

@enumerate 34
@item
The result of the Modulus function is nonnegative.

@item
The result of the Argument function is in the quadrant containing the
point in the complex plane represented by the parameter X. This may be
any quadrant (I through IV); thus, the range of the Argument function is
approximately -Pi to Pi (-Cycle/2.0 to Cycle/2.0, if the parameter Cycle
is specified). When the point represented by the parameter X lies on the
negative real axis, the result approximates

@enumerate 36
@item
Pi (resp., -Pi) when the sign of the imaginary component of X is
positive (resp., negative), if Real'Signed_Zeros is True;

@item
Pi, if Real'Signed_Zeros is False.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 38
@item
Because a result lying on or near one of the axes may not be exactly
representable, the approximation inherent in computing the result may
place it in an adjacent quadrant, close to but on the wrong side of the
axis.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 39
@item
The exception Numerics.Argument_Error is raised by the Argument and
Compose_From_Polar functions with specified cycle, signaling a parameter
value outside the domain of the corresponding mathematical function,
when the value of the parameter Cycle is zero or negative.

@item
The exception Constraint_Error is raised by the division operator when
the value of the right operand is zero, and by the exponentiation
operator when the value of the left operand is zero and the value of the
exponent is negative, provided that Real'Machine_Overflows is True; when
Real'Machine_Overflows is False, the result is unspecified.
Constraint_Error can also be raised when a finite result overflows
(@pxref{G.2.6}).

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
In the implementation of Numerics.Generic_Complex_Types, the range of
intermediate values allowed during the calculation of a final result
shall not be affected by any range constraint of the subtype Real.

@item
In the following cases, evaluation of a complex arithmetic operation
shall yield the prescribed result, provided that the preceding rules do
not call for an exception to be raised:

@enumerate 43
@item
The results of the Re, Im, and Compose_From_Cartesian functions are
exact.

@item
The real (resp., imaginary) component of the result of a binary addition
operator that yields a result of complex type is exact when either of
its operands is of pure-imaginary (resp., real) type.

@item
The real (resp., imaginary) component of the result of a binary
subtraction operator that yields a result of complex type is exact when
its right operand is of pure-imaginary (resp., real) type.

@item
The real component of the result of the Conjugate function for the
complex type is exact.

@item
When the point in the complex plane represented by the parameter X lies
on the nonnegative real axis, the Argument function yields a result of
zero.

@item
When the value of the parameter Modulus is zero, the Compose_From_Polar
function yields a result of zero.

@item
When the value of the parameter Argument is equal to a multiple of the
quarter cycle, the result of the Compose_From_Polar function with
specified cycle lies on one of the axes. In this case, one of its
components is zero, and the other has the magnitude of the parameter
Modulus.

@item
Exponentiation by a zero exponent yields the value one. Exponentiation
by a unit exponent yields the value of the left operand. Exponentiation
of the value one yields the value one. Exponentiation of the value zero
yields the value zero, provided that the exponent is nonzero. When the
left operand is of pure-imaginary type, one component of the result of
the exponentiation operator is zero.
@end enumerate
@end enumerate

@enumerate 51
@item
When the result, or a result component, of any operator of
Numerics.Generic_Complex_Types has a mathematical definition in terms of
a single arithmetic or relational operation, that result or result
component exhibits the accuracy of the corresponding operation of the
type Real.

@item
Other accuracy requirements for the Modulus, Argument, and
Compose_From_Polar functions, and accuracy requirements for the
multiplication of a pair of complex operands or for division by a
complex operand, all of which apply only in the strict mode, are given
in @ref{G.2.6}.

@item
The sign of a zero result or zero result component yielded by a complex
arithmetic operation or function is implementation defined when
Real'Signed_Zeros is True.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

@item
Implementations may obtain the result of exponentiation of a complex or
pure-imaginary operand by repeated complex multiplication, with
arbitrary association of the factors and with a possible final complex
reciprocation (when the exponent is negative). Implementations are also
permitted to obtain the result of exponentiation of a complex operand,
but not of a pure-imaginary operand, by converting the left operand to a
polar representation; exponentiating the modulus by the given exponent;
multiplying the argument by the given exponent, when the exponent is
positive, or dividing the argument by the absolute value of the given
exponent, when the exponent is negative; and reconverting to a cartesian
representation. Because of this implementation freedom, no accuracy
requirement is imposed on complex exponentiation (except for the
prescribed results given above, which apply regardless of the
implementation method chosen).

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Because the usual mathematical meaning of multiplication of a complex
operand and a real operand is that of the scaling of both components of
the former by the latter, an implementation should not perform this
operation by first promoting the real operand to complex type and then
performing a full complex multiplication. In systems that, in the
future, support an Ada binding to IEC 559:1989, the latter technique
will not generate the required result when one of the components of the
complex operand is infinite. (Explicit multiplication of the infinite
component by the zero component obtained during promotion yields a NaN
that propagates into the final result.)  Analogous advice applies in the
case of multiplication of a complex operand and a pure-imaginary
operand, and in the case of division of a complex operand by a real or
pure-imaginary operand.

@item
Likewise, because the usual mathematical meaning of addition of a
complex operand and a real operand is that the imaginary operand remains
unchanged, an implementation should not perform this operation by first
promoting the real operand to complex type and then performing a full
complex addition. In implementations in which the Signed_Zeros attribute
of the component type is True (and which therefore conform to IEC
559:1989 in regard to the handling of the sign of zero in predefined
arithmetic operations), the latter technique will not generate the
required result when the imaginary component of the complex operand is a
negatively signed zero. (Explicit addition of the negative zero to the
zero obtained during promotion yields a positive zero.)  Analogous
advice applies in the case of addition of a complex operand and a
pure-imaginary operand, and in the case of subtraction of a complex
operand and a real or pure-imaginary operand.

@item
Implementations in which Real'Signed_Zeros is True should attempt to
provide a rational treatment of the signs of zero results and result
components. As one example, the result of the Argument function should
have the sign of the imaginary component of the parameter X when the
point represented by that parameter lies on the positive real axis; as
another, the sign of the imaginary component of the Compose_From_Polar
function should be the same as (resp., the opposite of) that of the
Argument parameter when that parameter has a value of zero and the
Modulus parameter has a nonnegative (resp., negative) value.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.1.2, G.1.3, G.1.1, G.1
@subsection Complex Elementary Functions

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The generic library package
Numerics.Generic_Complex_Elementary_Functions has the following
declaration:

@item
@example
with Ada.Numerics.Generic_Complex_Types;
generic
   with package Complex_Types is new
     Ada.Numerics.Generic_Complex_Types (<>);
   use Complex_Types;
package Ada.Numerics.Generic_Complex_Elementary_Functions is
   pragma Pure(Generic_Complex_Elementary_Functions);
@end example

@item
@example
   function Sqrt (X : Complex)   return Complex;
   function Log  (X : Complex)   return Complex;
   function Exp  (X : Complex)   return Complex;
   function Exp  (X : Imaginary) return Complex;
   function "**" (Left  : Complex;
                  Right : Complex)   return Complex;
   function "**" (Left  : Complex;
                  Right : Real'Base) return Complex;
   function "**" (Left  : Real'Base;
                  Right : Complex)   return Complex;
@end example

@item
@example
   function Sin (X : Complex) return Complex;
   function Cos (X : Complex) return Complex;
   function Tan (X : Complex) return Complex;
   function Cot (X : Complex) return Complex;
@end example

@item
@example
   function Arcsin (X : Complex) return Complex;
   function Arccos (X : Complex) return Complex;
   function Arctan (X : Complex) return Complex;
   function Arccot (X : Complex) return Complex;
@end example

@item
@example
   function Sinh (X : Complex) return Complex;
   function Cosh (X : Complex) return Complex;
   function Tanh (X : Complex) return Complex;
   function Coth (X : Complex) return Complex;
@end example

@item
@example
   function Arcsinh (X : Complex) return Complex;
   function Arccosh (X : Complex) return Complex;
   function Arctanh (X : Complex) return Complex;
   function Arccoth (X : Complex) return Complex;
@end example

@item
@example
end Ada.Numerics.Generic_Complex_Elementary_Functions;
@end example

@item
The library package Numerics.Complex_Elementary_Functions defines the
same subprograms as Numerics.Generic_Complex_Elementary_Functions,
except that the predefined type Float is systematically substituted for
Real'Base, and the Complex and Imaginary types exported by
Numerics.Complex_Types are systematically substituted for Complex and
Imaginary, throughout. Nongeneric equivalents of
Numerics.Generic_Complex_Elementary_Functions corresponding to each of
the other predefined floating point types are defined similarly, with
the names Numerics.Short_Complex_Elementary_Functions,
Numerics.Long_Complex_Elementary_Functions, etc.

@item
The overloading of the Exp function for the pure-imaginary type is
provided to give the user an alternate way to compose a complex value
from a given modulus and argument. In addition to
Compose_From_Polar(Rho, Theta), see @ref{G.1.1}, the programmer may write
Rho * Exp(i * Theta).

@item
The imaginary (resp., real) component of the parameter X of the forward
hyperbolic (resp., trigonometric) functions and of the Exp function (and
the parameter X, itself, in the case of the overloading of the Exp
function for the pure-imaginary type) represents an angle measured in
radians, as does the imaginary (resp., real) component of the result of
the Log and inverse hyperbolic (resp., trigonometric) functions.

@item
The functions have their usual mathematical meanings. However, the
arbitrariness inherent in the placement of branch cuts, across which
some of the complex elementary functions exhibit discontinuities, is
eliminated by the following conventions:

@enumerate 13
@item
The imaginary component of the result of the Sqrt and Log functions is
discontinuous as the parameter X crosses the negative real axis.

@item
The result of the exponentiation operator when the left operand is of
complex type is discontinuous as that operand crosses the negative real
axis.

@item
The real (resp., imaginary) component of the result of the Arcsin and
Arccos (resp., Arctanh) functions is discontinuous as the parameter X
crosses the real axis to the left of -1.0 or the right of 1.0.

@item
The real (resp., imaginary) component of the result of the Arctan
(resp., Arcsinh) function is discontinuous as the parameter X crosses
the imaginary axis below -i or above i.

@item
The real component of the result of the Arccot function is discontinuous
as the parameter X crosses the imaginary axis between -i and i.

@item
The imaginary component of the Arccosh function is discontinuous as the
parameter X crosses the real axis to the left of 1.0.

@item
The imaginary component of the result of the Arccoth function is
discontinuous as the parameter X crosses the real axis between -1.0 and
1.0.
@end enumerate
@end enumerate

@enumerate 20
@item
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

@enumerate 21
@item
The real component of the result of the Sqrt and Arccosh functions is
nonnegative.

@item
The same convention applies to the imaginary component of the result of
the Log function as applies to the result of the natural-cycle version
of the Argument function of Numerics.Generic_Complex_Types
(@pxref{G.1.1}).

@item
The range of the real (resp., imaginary) component of the result of the
Arcsin and Arctan (resp., Arcsinh and Arctanh) functions is
approximately -Pi/2.0 to Pi/2.0.

@item
The real (resp., imaginary) component of the result of the Arccos and
Arccot (resp., Arccoth) functions ranges from 0.0 to approximately Pi.

@item
The range of the imaginary component of the result of the Arccosh
function is approximately -Pi to Pi.
@end enumerate
@end enumerate

@enumerate 26
@item
In addition, the exponentiation operator inherits the single-valuedness
of the Log function.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
The exception Numerics.Argument_Error is raised by the exponentiation
operator, signaling a parameter value outside the domain of the
corresponding mathematical function, when the value of the left operand
is zero and the real component of the exponent (or the exponent itself,
when it is of real type) is zero.

@item
The exception Constraint_Error is raised, signaling a pole of the
mathematical function (analogous to dividing by zero), in the following
cases, provided that Complex_Types.Real'Machine_Overflows is True:

@enumerate 29
@item
by the Log, Cot, and Coth functions, when the value of the parameter X
is zero;

@item
by the exponentiation operator, when the value of the left operand is
zero and the real component of the exponent (or the exponent itself,
when it is of real type) is negative;

@item
by the Arctan and Arccot functions, when the value of the parameter X is
+/-i;

@item
by the Arctanh and Arccoth functions, when the value of the parameter X
is +/-1.0.

@end enumerate
@end enumerate

@enumerate 33
@item
Constraint_Error can also be raised when a finite result overflows
(@pxref{G.2.6}) this may occur for parameter values sufficiently near
poles, and, in the case of some of the functions, for parameter values
having components of sufficiently large magnitude. When
Complex_Types.Real'Machine_Overflows is False, the result at poles is
unspecified.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
In the implementation of Numerics.Generic_Complex_Elementary_Functions,
the range of intermediate values allowed during the calculation of a
final result shall not be affected by any range constraint of the
subtype Complex_Types.Real.

@item
In the following cases, evaluation of a complex elementary function
shall yield the prescribed result (or a result having the prescribed
component), provided that the preceding rules do not call for an
exception to be raised:

@enumerate 36
@item
When the parameter X has the value zero, the Sqrt, Sin, Arcsin, Tan,
Arctan, Sinh, Arcsinh, Tanh, and Arctanh functions yield a result of
zero; the Exp, Cos, and Cosh functions yield a result of one; the Arccos
and Arccot functions yield a real result; and the Arccoth function
yields an imaginary result.

@item
When the parameter X has the value one, the Sqrt function yields a
result of one; the Log, Arccos, and Arccosh functions yield a result of
zero; and the Arcsin function yields a real result.

@item
When the parameter X has the value -1.0, the Sqrt function yields the
result

@enumerate 39
@item
i (resp., -i), when the sign of the imaginary component of X is positive
(resp., negative), if Complex_Types.Real'Signed_Zeros is True;

@item
i, if Complex_Types.Real'Signed_Zeros is False;
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 41
@item
the Log function yields an imaginary result; and the Arcsin and Arccos
functions yield a real result.

@item
When the parameter X has the value +/-i, the Log function yields an
imaginary result.

@item
Exponentiation by a zero exponent yields the value one. Exponentiation
by a unit exponent yields the value of the left operand (as a complex
value). Exponentiation of the value one yields the value one.
Exponentiation of the value zero yields the value zero.
@end enumerate
@end enumerate

@enumerate 44
@item
Other accuracy requirements for the complex elementary functions, which
apply only in the strict mode, are given in @ref{G.2.6}.

@item
The sign of a zero result or zero result component yielded by a complex
elementary function is implementation defined when
Complex_Types.Real'Signed_Zeros is True.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package with the appropriate predefined
nongeneric equivalent of Numerics.Generic_Complex_Types; if they are,
then the latter shall have been obtained by actual instantiation of
Numerics.Generic_Complex_Types.

@item
The exponentiation operator may be implemented in terms of the Exp and
Log functions. Because this implementation yields poor accuracy in some
parts of the domain, no accuracy requirement is imposed on complex
exponentiation.

@item
The implementation of the Exp function of a complex parameter X is
allowed to raise the exception Constraint_Error, signaling overflow,
when the real component of X exceeds an unspecified threshold that is
approximately log (Complex_Types.Real'Safe_Last). This permission
recognizes the impracticality of avoiding overflow in the marginal case
that the exponential of the real component of X exceeds the safe range
of Complex_Types.Real but both components of the final result do not.
Similarly, the Sin and Cos (resp., Sinh and Cosh) functions are allowed
to raise the exception Constraint_Error, signaling overflow, when the
absolute value of the imaginary (resp., real) component of the parameter
X exceeds an unspecified threshold that is approximately log
(Complex_Types.Real'Safe_Last)+log (2.0). This permission recognizes the
impracticality of avoiding overflow in the marginal case that the
hyperbolic sine or cosine of the imaginary (resp., real) component of X
exceeds the safe range of Complex_Types.Real but both components of the
final result do not.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Implementations in which Complex_Types.Real'Signed_Zeros is True should
attempt to provide a rational treatment of the signs of zero results and
result components. For example, many of the complex elementary functions
have components that are odd functions of one of the parameter
components; in these cases, the result component should have the sign of
the parameter component at the origin. Other complex elementary
functions have zero components whose sign is opposite that of a
parameter component at the origin, or is always positive or always
negative.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.1.3, G.1.4, G.1.2, G.1
@subsection Complex Input-Output

@enumerate
@item
The generic package Text_IO.Complex_IO defines procedures for the
formatted input and output of complex values. The generic actual
parameter in an instantiation of Text_IO.Complex_IO is an instance of
Numerics.Generic_Complex_Types for some floating point subtype.
Exceptional conditions are reported by raising the appropriate exception
defined in Text_IO.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The generic library package Text_IO.Complex_IO has the following
declaration:

@item
@example
with Ada.Numerics.Generic_Complex_Types;
generic
   with package Complex_Types is new
     Ada.Numerics.Generic_Complex_Types (<>);
package Ada.Text_IO.Complex_IO is
@end example

@item
@example
   use Complex_Types;
@end example

@item
@example
   Default_Fore : Field := 2;
   Default_Aft  : Field := Real'Digits - 1;
   Default_Exp  : Field := 3;
@end example

@item
@example
   procedure Get (File  : in  File_Type;
                  Item  : out Complex;
                  Width : in  Field := 0);
   procedure Get (Item  : out Complex;
                  Width : in  Field := 0);
@end example

@item
@example
   procedure Put (File : in File_Type;
                  Item : in Complex;
                  Fore : in Field := Default_Fore;
                  Aft  : in Field := Default_Aft;
                  Exp  : in Field := Default_Exp);
   procedure Put (Item : in Complex;
                  Fore : in Field := Default_Fore;
                  Aft  : in Field := Default_Aft;
                  Exp  : in Field := Default_Exp);
@end example

@item
@example
   procedure Get (From : in  String;
                  Item : out Complex;
                  Last : out Positive);
   procedure Put (To   : out String;
                  Item : in  Complex;
                  Aft  : in  Field := Default_Aft;
                  Exp  : in  Field := Default_Exp);
@end example

@item
@example
end Ada.Text_IO.Complex_IO;
@end example

@item
The semantics of the Get and Put procedures are as follows:

@item
@format
procedure Get (File  : in  File_Type;
               Item  : out Complex;
               Width : in  Field := 0);

procedure Get (Item  : out Complex;
               Width : in  Field := 0);
@end format

@enumerate 12
@item
The input sequence is a pair of optionally signed real literals
representing the real and imaginary components of a complex value;
optionally, the pair of components may be separated by a comma and/or
surrounded by a pair of parentheses. Blanks are freely allowed before
each of the components and before the parentheses and comma, if either
is used. If the value of the parameter Width is zero, then

@enumerate 13
@item
line and page terminators are also allowed in these places;

@item
the components shall be separated by at least one blank or line
terminator if the comma is omitted; and

@item
reading stops when the right parenthesis has been read, if the input
sequence includes a left parenthesis, or when the imaginary component
has been read, otherwise.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 12
        If a nonzero value of Width is supplied, then

@enumerate 16
@item
the components shall be separated by at least one blank if the comma is
omitted; and

@item
exactly Width characters are read, or the characters (possibly none) up
to a line terminator, whichever comes first (blanks are included in the
count).
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 18
@item
Returns, in the parameter Item, the value of type Complex that
corresponds to the input sequence.

@item
The exception Text_IO.Data_Error is raised if the input sequence does
not have the required syntax or if the components of the complex value
obtained are not of the base subtype of Complex_Types.Real.
@end enumerate
@end enumerate

@enumerate 20
@item
@format
procedure Put (File : in File_Type;
               Item : in Complex;
               Fore : in Field := Default_Fore;
               Aft  : in Field := Default_Aft;
               Exp  : in Field := Default_Exp);

procedure Put (Item : in Complex;
               Fore : in Field := Default_Fore;
               Aft  : in Field := Default_Aft;
               Exp  : in Field := Default_Exp);
@end format

@enumerate 21
@item
Outputs the value of the parameter Item as a pair of decimal literals
representing the real and imaginary components of the complex value,
using the syntax of an aggregate. More specifically,

@enumerate 22
@item
outputs a left parenthesis;

@item
outputs the value of the real component of the parameter Item with the
format defined by the corresponding Put procedure of an instance of
Text_IO.Float_IO for the base subtype of Complex_Types.Real, using the
given values of Fore, Aft, and Exp;

@item
outputs a comma;

@item
outputs the value of the imaginary component of the parameter Item with
the format defined by the corresponding Put procedure of an instance of
Text_IO.Float_IO for the base subtype of Complex_Types.Real, using the
given values of Fore, Aft, and Exp;

@item
outputs a right parenthesis.
@end enumerate
@end enumerate
@end enumerate

@enumerate 27
@item
@format
procedure Get (From : in  String;
               Item : out Complex;
               Last : out Positive);
@end format

@enumerate 28
@item
Reads a complex value from the beginning of the given string, following
the same rule as the Get procedure that reads a complex value from a
file, but treating the end of the string as a line terminator. Returns,
in the parameter Item, the value of type Complex that corresponds to the
input sequence. Returns in Last the index value such that From(Last) is
the last character read.

@item
The exception Text_IO.Data_Error is raised if the input sequence does
not have the required syntax or if the components of the complex value
obtained are not of the base subtype of Complex_Types.Real.
@end enumerate
@end enumerate

@enumerate 30
@item
@format
procedure Put (To   : out String;
               Item : in  Complex;
               Aft  : in  Field := Default_Aft;
               Exp  : in  Field := Default_Exp);
@end format

@enumerate 31
@item
Outputs the value of the parameter Item to the given string as a pair of
decimal literals representing the real and imaginary components of the
complex value, using the syntax of an aggregate. More specifically,

@enumerate 32
@item
a left parenthesis, the real component, and a comma are left justified
in the given string, with the real component having the format defined
by the Put procedure (for output to a file) of an instance of
Text_IO.Float_IO for the base subtype of Complex_Types.Real, using a
value of zero for Fore and the given values of Aft and Exp;

@item
the imaginary component and a right parenthesis are right justified in
the given string, with the imaginary component having the format defined
by the Put procedure (for output to a file) of an instance of
Text_IO.Float_IO for the base subtype of Complex_Types.Real, using a
value for Fore that completely fills the remainder of the string,
together with the given values of Aft and Exp.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 34
@item
The exception Text_IO.Layout_Error is raised if the given string is too
short to hold the formatted output.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@enumerate 35
@item
Other exceptions declared (by renaming) in Text_IO may be raised by the
preceding procedures in the appropriate circumstances, as for the
corresponding procedures of Text_IO.Float_IO.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.1.4, G.2, G.1.3, G.1
@subsection The Package Wide_Text_IO.Complex_IO

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
Implementations shall also provide the generic library package
Wide_Text_IO.Complex_IO. Its declaration is obtained from that of
Text_IO.Complex_IO by systematically replacing Text_IO by Wide_Text_IO
and String by Wide_String; the description of its behavior is obtained
by additionally replacing references to particular characters (commas,
parentheses, etc.) by those for the corresponding wide characters.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.2, G.2.1, G.1.4, G
@section Numeric Performance Requirements

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@enumerate
@item
Implementations shall provide a user-selectable mode in which the
accuracy and other numeric performance requirements detailed in the
following subclauses are observed. This mode, referred to as the strict
mode, may or may not be the default mode; it directly affects the
results of the predefined arithmetic operations of real types and the
results of the subprograms in children of the Numerics package, and
indirectly affects the operations in other language defined packages.
Implementations shall also provide the opposing mode, which is known as
the relaxed mode.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
Either mode may be the default mode.

@item
The two modes need not actually be different.
@end enumerate

@menu
* G.2.1:: Model of Floating Point Arithmetic
* G.2.2:: Model-Oriented Attributes of Floating Point Types
* G.2.3:: Model of Fixed Point Arithmetic
* G.2.4:: Accuracy Requirements for the Elementary Functions
* G.2.5:: Performance Requirements for Random Number Generation
* G.2.6:: Accuracy Requirements for Complex Arithmetic
@end menu

@c ---------------------------------------------------------------------------
@node G.2.1, G.2.2, G.2, G.2
@subsection Model of Floating Point Arithmetic

@enumerate
@item
In the strict mode, the predefined operations of a floating point type
shall satisfy the accuracy requirements specified here and shall avoid
or signal overflow in the situations described. This behavior is
presented in terms of a model of floating point arithmetic that builds
on the concept of the canonical form, see @ref{A.5.3}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
Associated with each floating point type is an infinite set of model
numbers. The model numbers of a type are used to define the accuracy
requirements that have to be satisfied by certain predefined operations
of the type; through certain attributes of the model numbers, they are
also used to explain the meaning of a user-declared floating point type
declaration. The model numbers of a derived type are those of the parent
type; the model numbers of a subtype are those of its type.

@item
The model numbers of a floating point type T are zero and all the values
expressible in the canonical form (for the type T), in which mantissa
has T'Model_Mantissa digits and exponent has a value greater than or
equal to T'Model_Emin. (These attributes are defined in @ref{G.2.2}.)

@item
A model interval of a floating point type is any interval whose bounds
are model numbers of the type. The model interval of a type T associated
with a value v is the smallest model interval of T that includes v. (The
model interval associated with a model number of a type consists of that
number only.)

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The accuracy requirements for the evaluation of certain predefined
operations of floating point types are as follows.

@item
An operand interval is the model interval, of the type specified for the
operand of an operation, associated with the value of the operand.

@item
For any predefined arithmetic operation that yields a result of a
floating point type T, the required bounds on the result are given by a
model interval of T (called the result interval) defined in terms of the
operand values as follows:

@enumerate 8
@item
The result interval is the smallest model interval of T that includes
the minimum and the maximum of all the values obtained by applying the
(exact) mathematical operation to values arbitrarily selected from the
respective operand intervals.
@end enumerate
@end enumerate

@enumerate 9
@item
The result interval of an exponentiation is obtained by applying the
above rule to the sequence of multiplications defined by the exponent,
assuming arbitrary association of the factors, and to the final division
in the case of a negative exponent.

@item
The result interval of a conversion of a numeric value to a floating
point type T is the model interval of T associated with the operand
value, except when the source expression is of a fixed point type with a
small that is not a power of T'Machine_Radix or is a fixed point
multiplication or division either of whose operands has a small that is
not a power of T'Machine_Radix; in these cases, the result interval is
implementation defined.

@item
For any of the foregoing operations, the implementation shall deliver a
value that belongs to the result interval when both bounds of the result
interval are in the safe range of the result type T, as determined by
the values of T'Safe_First and T'Safe_Last; otherwise,

@enumerate 12
@item
if T'Machine_Overflows is True, the implementation shall either deliver
a value that belongs to the result interval or raise Constraint_Error;

@item
if T'Machine_Overflows is False, the result is implementation defined.
@end enumerate
@end enumerate

@enumerate 14
@item
For any predefined relation on operands of a floating point type T, the
implementation may deliver any value (i.e., either True or False)
obtained by applying the (exact) mathematical comparison to values
arbitrarily chosen from the respective operand intervals.

@item
The result of a membership test is defined in terms of comparisons of
the operand value with the lower and upper bounds of the given range or
type mark (the usual rules apply to these comparisons).

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
If the underlying floating point hardware implements division as
multiplication by a reciprocal, the result interval for division (and
exponentiation by a negative exponent) is implementation defined.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.2.2, G.2.3, G.2.1, G.2
@subsection Model-Oriented Attributes of Floating Point Types

@enumerate
@item
In implementations that support the Numerics Annex, the model-oriented
attributes of floating point types shall yield the values defined here,
in both the strict and the relaxed modes. These definitions add
conditions to those in @ref{A.5.3}.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
For every subtype S of a floating point type T:

@item
S'Model_Mantissa

@example
Yields the number of digits in the mantissa of the
canonical form of the model numbers of T, see @ref{A.5.3}.
The value of this attribute shall be greater than or
equal to Ceiling(d*log (10)/log (T'Machine_Radix))+1,
where d is the requested decimal precision of T. In
addition, it shall be less than or equal to the value of
T'Machine_Mantissa. This attribute yields a value of the
type universal_integer.
@end example

@item
S'Model_Emin

@example
Yields the minimum exponent of the canonical form of the model
numbers of T, see @ref{A.5.3}. The value of this attribute shall
be greater than or equal to the value of T'Machine_Emin. This
attribute yields a value of the type universal_integer.
@end example

@item
S'Safe_First

@example
Yields the lower bound of the safe range of T. The value of
this attribute shall be a model number of T and greater than
or equal to the lower bound of the base range of T. In
addition, if T is declared by a floating_point_definition or
is derived from such a type, and the
floating_point_definition includes a real_range_specification
specifying a lower bound of lb, then the value of this
attribute shall be less than or equal to lb; otherwise, it
shall be less than or equal to -10.0 ** (4*d), where d is the
requested decimal precision of T. This attribute yields a
value of the type universal_real.
@end example

@item
S'Safe_Last

@example
Yields the upper bound of the safe range of T. The value of
this attribute shall be a model number of T and less than or
equal to the upper bound of the base range of T. In
addition, if T is declared by a floating_point_definition or
is derived from such a type, and the floating_point_definition
includes a real_range_specification specifying an
upper bound of ub, then the value of this attribute shall be
greater than or equal to ub; otherwise, it shall be greater
than or equal to 10.0 ** (4*d), where d is the requested
decimal precision of T. This attribute yields a value of the
type universal_real.
@end example

@item
S'Model

@example
Denotes a function (of a parameter X) whose specification is
given in @ref{A.5.3}. If X is a model number of T, the
function yields X; otherwise, it yields the value obtained by
rounding or truncating X to either one of the adjacent model
numbers of T. Constraint_Error is raised if the resulting model
number is outside the safe range of S. A zero result has the
sign of X when S'Signed_Zeros is True.
@end example

@item
Subject to the constraints given above, the values of S'Model_Mantissa
and S'Safe_Last are to be maximized, and the values of S'Model_Emin and
S'Safe_First minimized, by the implementation as follows:

@enumerate 9
@item
First, S'Model_Mantissa is set to the largest value for which values of
S'Model_Emin, S'Safe_First, and S'Safe_Last can be chosen so that the
implementation satisfies the strict-mode requirements of @ref{G.2.1},
in terms of the model numbers and safe range induced by these
attributes.

@item
Next, S'Model_Emin is set to the smallest value for which values of
S'Safe_First and S'Safe_Last can be chosen so that the implementation
satisfies the strict-mode requirements of @ref{G.2.1}, in terms of the
model numbers and safe range induced by these attributes and the
previously determined value of S'Model_Mantissa.

@item
Finally, S'Safe_First and S'Safe_last are set (in either order) to the
smallest and largest values, respectively, for which the implementation
satisfies the strict-mode requirements of @ref{G.2.1}, in terms of the
model numbers and safe range induced by these attributes and the
previously determined values of S'Model_Mantissa and S'Model_Emin.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node G.2.3, G.2.4, G.2.2, G.2
@subsection Model of Fixed Point Arithmetic

@enumerate
@item
In the strict mode, the predefined arithmetic operations of a fixed
point type shall satisfy the accuracy requirements specified here and
shall avoid or signal overflow in the situations described.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The accuracy requirements for the predefined fixed point arithmetic
operations and conversions, and the results of relations on fixed point
operands, are given below.

@item
The operands of the fixed point adding operators, absolute value, and
comparisons have the same type. These operations are required to yield
exact results, unless they overflow.

@item
Multiplications and divisions are allowed between operands of any two
fixed point types; the result has to be (implicitly or explicitly)
converted to some other numeric type. For purposes of defining the
accuracy rules, the multiplication or division and the conversion are
treated as a single operation whose accuracy depends on three types
(those of the operands and the result). For decimal fixed point types,
the attribute T'Round may be used to imply explicit conversion with
rounding, see @ref{3.5.10}.

@item
When the result type is a floating point type, the accuracy is as given
in @ref{G.2.1}. For some combinations of the operand and result types
in the remaining cases, the result is required to belong to a small set
of values called the perfect result set; for other combinations, it is
required merely to belong to a generally larger and
implementation-defined set of values called the close result set. When
the result type is a decimal fixed point type, the perfect result set
contains a single value; thus, operations on decimal types are always
fully specified.

@item
When one operand of a fixed-fixed multiplication or division is of type
universal_real, that operand is not implicitly converted in the usual
sense, since the context does not determine a unique target type, but
the accuracy of the result of the multiplication or division (i.e.,
whether the result has to belong to the perfect result set or merely the
close result set) depends on the value of the operand of type
universal_real and on the types of the other operand and of the result.

@item
For a fixed point multiplication or division whose (exact) mathematical
result is v, and for the conversion of a value v to a fixed point type,
the perfect result set and close result set are defined as follows:

@enumerate 8
@item
If the result type is an ordinary fixed point type with a small of s,

@enumerate
@enumerate 9
@item
if v is an integer multiple of s, then the perfect result set contains
only the value v;

@item
otherwise, it contains the integer multiple of s just below v and the
integer multiple of s just above v.
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 11
@item
The close result set is an implementation-defined set of consecutive
integer multiples of s containing the perfect result set as a subset.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 12
@item
If the result type is a decimal type with a small of s,

@enumerate
@enumerate 13
@item
if v is an integer multiple of s, then the perfect result set contains
only the value v;

@item
otherwise, if truncation applies then it contains only the integer
multiple of s in the direction toward zero, whereas if rounding applies
then it contains only the nearest integer multiple of s (with ties
broken by rounding away from zero).
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 15
@item
The close result set is an implementation-defined set of consecutive
integer multiples of s containing the perfect result set as a subset.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 16
@item
If the result type is an integer type,

@enumerate
@enumerate 17
@item
if v is an integer, then the perfect result set contains only the value
v;

@item
otherwise, it contains the integer nearest to the value v (if v lies
equally distant from two consecutive integers, the perfect result set
contains the one that is further from zero).
@end enumerate
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate
@enumerate 19
@item
The close result set is an implementation-defined set of consecutive
integers containing the perfect result set as a subset.
@end enumerate
@end enumerate
@end enumerate

@enumerate 20
@item
The result of a fixed point multiplication or division shall belong
either to the perfect result set or to the close result set, as
described below, if overflow does not occur. In the following cases, if
the result type is a fixed point type, let s be its small; otherwise,
i.e. when the result type is an integer type, let s be 1.0.

@enumerate 21
@item
For a multiplication or division neither of whose operands is of type
universal_real, let l and r be the smalls of the left and right
operands. For a multiplication, if (l*r)/s is an integer or the
reciprocal of an integer (the smalls are said to be ``compatible'' in
this case), the result shall belong to the perfect result set;
otherwise, it belongs to the close result set. For a division, if
l/(r*s) is an integer or the reciprocal of an integer (i.e., the smalls
are compatible), the result shall belong to the perfect result set;
otherwise, it belongs to the close result set.

@item
For a multiplication or division having one universal_real operand with
a value of v, note that it is always possible to factor v as an integer
multiple of a ``compatible'' small, but the integer multiple may be
``too big.''  If there exists a factorization in which that multiple is
less than some implementation-defined limit, the result shall belong to
the perfect result set; otherwise, it belongs to the close result set.
@end enumerate
@end enumerate

@enumerate 23
@item
A multiplication P * Q of an operand of a fixed point type F by an
operand of an integer type I, or vice-versa, and a division P / Q of an
operand of a fixed point type F by an operand of an integer type I, are
also allowed. In these cases, the result has a type of F; explicit
conversion of the result is never required. The accuracy required in
these cases is the same as that required for a multiplication F(P * Q)
or a division F(P / Q) obtained by interpreting the operand of the
integer type to have a fixed point type with a small of 1.0.

@item
The accuracy of the result of a conversion from an integer or fixed
point type to a fixed point type, or from a fixed point type to an
integer type, is the same as that of a fixed point multiplication of the
source value by a fixed point operand having a small of 1.0 and a value
of 1.0, as given by the foregoing rules. The result of a conversion from
a floating point type to a fixed point type shall belong to the close
result set. The result of a conversion of a universal_real operand to a
fixed point type shall belong to the perfect result set.

@item
The possibility of overflow in the result of a predefined arithmetic
operation or conversion yielding a result of a fixed point type T is
analogous to that for floating point types, except for being related to
the base range instead of the safe range. If all of the permitted
results belong to the base range of T, then the implementation shall
deliver one of the permitted results; otherwise,

@enumerate 26
@item
if T'Machine_Overflows is True, the implementation shall either deliver
one of the permitted results or raise Constraint_Error;

@item
if T'Machine_Overflows is False, the result is implementation defined.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node G.2.4, G.2.5, G.2.3, G.2
@subsection Accuracy Requirements for the Elementary Functions

@enumerate
@item
In the strict mode, the performance of
Numerics.Generic_Elementary_Functions shall be as specified here.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
When an exception is not raised, the result of evaluating a function in
an instance EF of Numerics.Generic_Elementary_Functions belongs to a
result interval, defined as the smallest model interval of EF.Float_Type
that contains all the values of the form f*(1.0+d), where f is the exact
value of the corresponding mathematical function at the given parameter
values, d is a real number, and |d| is less than or equal to the
function's maximum relative error. The function delivers a value that
belongs to the result interval when both of its bounds belong to the
safe range of EF.Float_Type; otherwise,

@enumerate 3
@item
if EF.Float_Type'Machine_Overflows is True, the function either delivers
a value that belongs to the result interval or raises Constraint_Error,
signaling overflow;

@item
if EF.Float_Type'Machine_Overflows is False, the result is
implementation defined.
@end enumerate
@end enumerate

@enumerate 5
@item
The maximum relative error exhibited by each function is as follows:

@enumerate 6
@item
2.0*EF.Float_Type'Model_Epsilon, in the case of the Sqrt, Sin, and Cos
functions;

@item
4.0*EF.Float_Type'Model_Epsilon, in the case of the Log, Exp, Tan, Cot,
and inverse trigonometric functions; and

@item
8.0*EF.Float_Type'Model_Epsilon, in the case of the forward and inverse
hyperbolic functions.
@end enumerate
@end enumerate

@enumerate 9
@item
The maximum relative error exhibited by the exponentiation operator,
which depends on the values of the operands, is (4.0+|Right*log
(Left)|/32.0)*EF.Float_Type'Model_Epsilon.

@item
The maximum relative error given above applies throughout the domain of
the forward trigonometric functions when the Cycle parameter is
specified. When the Cycle parameter is omitted, the maximum relative
error given above applies only when the absolute value of the angle
parameter X is less than or equal to some implementation-defined angle
threshold, which shall be at least EF.Float_Type'Machine_Radix **
Floor(EF.Float_Type'Machine_Mantissa/2). Beyond the angle threshold, the
accuracy of the forward trigonometric functions is implementation
defined.

@item
The prescribed results specified in @ref{A.5.1}, for certain functions
at particular parameter values take precedence over the maximum relative
error bounds; effectively, they narrow to a single value the result
interval allowed by the maximum relative error bounds. Additional rules
with a similar effect are given by the table below for the inverse
trigonometric functions, at particular parameter values for which the
mathematical result is possibly not a model number of EF.Float_Type (or
is, indeed, even transcendental). In each table entry, the values of the
parameters are such that the result lies on the axis between two
quadrants; the corresponding accuracy rule, which takes precedence over
the maximum relative error bounds, is that the result interval is the
model interval of EF.Float_Type associated with the exact mathematical
result given in the table.

@item
@format
  +--------------------------------------------------------------+
  |                                                              |
  |       Tightly Approximated Elementary Function Results       |
  |                                                              |
  +-----------------+----------+----------+------------+-------- +
  |                 |          |          |            |         |
  |                 |          |          |   Exact    | Exact   |
  |                 |          |          |   Result   | Result  |
  |                 | Value of | Value of | when Cycle | when    |
  |    Function     |     X    |     Y    | Specified  | Cycle   |
  |                 |          |          |            | Omitted |
  |                 |          |          |            |         |
  +-----------------+----------+----------+------------+---------+
  |                 |          |          |            |         |
  |     Arcsin      |   1.0    |   n.a.   | Cycle/4.0  |  Pi/2.0 |
  |                 |          |          |            |         |
  |     Arcsin      |   -1.0   |   n.a.   | -Cycle/4.0 | -Pi/2.0 |
  |                 |          |          |            |         |
  |     Arccos      |   0.0    |   n.a.   | Cycle/4.0  |  Pi/2.0 |
  |                 |          |          |            |         |
  |     Arccos      |   -1.0   |   n.a.   | Cycle/2.0  |    Pi   |
  |                 |          |          |            |         |
  | Arctan & Arccot |   0.0    | positive | Cycle/4.0  |  Pi/2.0 |
  |                 |          |          |            |         |
  | Arctan & Arccot |   0.0    | negative | -Cycle/4.0 | -Pi/2.0 |
  |                 |          |          |            |         |
  | Arctan & Arccot | negative |   +0.0   | Cycle/2.0  |    Pi   |
  |                 |          |          |            |         |
  | Arctan & Arccot | negative |   -0.0   | -Cycle/2.0 |   -Pi   |
  |                 |          |          |            |         |
  | Arctan & Arccot | negative |   0.0    | Cycle/2.0  |    Pi   |
  |                 |          |          |            |         |
  +-----------------+----------+----------+------------+---------+
@end format

@item
The last line of the table is meant to apply when EF.Float_Type'Signed_
Zeros is False; the two lines just above it, when
EF.Float_Type'Signed_Zeros is True and the parameter Y has a zero value
with the indicated sign.

@item
The amount by which the result of an inverse trigonometric function is
allowed to spill over into a quadrant adjacent to the one corresponding
to the principal branch, as given in @ref{A.5.1}, is limited. The rule
is that the result belongs to the smallest model interval of
EF.Float_Type that contains both boundaries of the quadrant
corresponding to the principal branch. This rule also takes precedence
over the maximum relative error bounds, effectively narrowing the result
interval allowed by them.

@item
Finally, the following specifications also take precedence over the
maximum relative error bounds:

@enumerate 16
@item
The absolute value of the result of the Sin, Cos, and Tanh functions
never exceeds one.

@item
The absolute value of the result of the Coth function is never less than
one.

@item
The result of the Cosh function is never less than one.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Implementation Advice}

@enumerate 19
@item
The versions of the forward trigonometric functions without a Cycle
parameter should not be implemented by calling the corresponding version
with a Cycle parameter of 2.0*Numerics.Pi, since this will not provide
the required accuracy in some portions of the domain. For the same
reason, the version of Log without a Base parameter should not be
implemented by calling the corresponding version with a Base parameter
of Numerics.e.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.2.5, G.2.6, G.2.4, G.2
@subsection Performance Requirements for Random Number Generation

@enumerate
@item
In the strict mode, the performance of Numerics.Float_Random and
Numerics.Discrete_Random shall be as specified here.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
Two different calls to the time-dependent Reset procedure shall reset
the generator to different states, provided that the calls are separated
in time by at least one second and not more than fifty years.

@item
The implementation's representations of generator states and its
algorithms for generating random numbers shall yield a period of at
least 2**31-2; much longer periods are desirable but not required.

@item
The implementations of Numerics.Float_Random.Random and
Numerics.Discrete_Random.Random shall pass at least 85% of the
individual trials in a suite of statistical tests. For
Numerics.Float_Random, the tests are applied directly to the floating
point values generated (i.e., they are not converted to integers first),
while for Numerics.Discrete_Random they are applied to the generated
values of various discrete types. Each test suite performs 6 different
tests, with each test repeated 10 times, yielding a total of 60
individual trials. An individual trial is deemed to pass if the
chi-square value (or other statistic) calculated for the observed counts
or distribution falls within the range of values corresponding to the
2.5 and 97.5 percentage points for the relevant degrees of freedom
(i.e., it shall be neither too high nor too low). For the purpose of
determining the degrees of freedom, measurement categories are combined
whenever the expected counts are fewer than 5.
@end enumerate

@c ---------------------------------------------------------------------------
@node G.2.6, H, G.2.5, G.2
@subsection Accuracy Requirements for Complex Arithmetic

@enumerate
@item
In the strict mode, the performance of Numerics.Generic_Complex_Types
and Numerics.Generic_Complex_Elementary_Functions shall be as specified
here.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
When an exception is not raised, the result of evaluating a real
function of an instance CT of Numerics.Generic_Complex_Types (i.e., a
function that yields a value of subtype CT.Real'Base or CT.Imaginary)
belongs to a result interval defined as for a real elementary function
(@pxref{G.2.4}).

@item When an exception is not raised, each component of the result of
evaluating a complex function of such an instance, or of an instance of
Numerics.Generic_Complex_Elementary_Functions obtained by instantiating
the latter with CT (i.e., a function that yields a value of subtype
CT.Complex), also belongs to a result interval. The result intervals for
the components of the result are either defined by a maximum relative
error bound or by a maximum box error bound. When the result interval
for the real (resp., imaginary) component is defined by maximum relative
error, it is defined as for that of a real function, relative to the
exact value of the real (resp., imaginary) part of the result of the
corresponding mathematical function. When defined by maximum box error,
the result interval for a component of the result is the smallest model
interval of CT.Real that contains all the values of the corresponding
part of f*(1.0+d), where f is the exact complex value of the
corresponding mathematical function at the given parameter values, d is
complex, and |d| is less than or equal to the given maximum box error.
The function delivers a value that belongs to the result interval (or a
value both of whose components belong to their respective result
intervals) when both bounds of the result interval(s) belong to the safe
range of CT.Real; otherwise,

@enumerate 4
@item
if CT.Real'Machine_Overflows is True, the function either delivers a
value that belongs to the result interval (or a value both of whose
components belong to their respective result intervals) or raises
Constraint_Error, signaling overflow;

@item
if CT.Real'Machine_Overflows is False, the result is implementation
defined.
@end enumerate
@end enumerate

@enumerate 6
@item
The error bounds for particular complex functions are tabulated below.
In the table, the error bound is given as the coefficient of
CT.Real'Model_Epsilon.

@item
@format
  +-----------------------------------------------------------------+
  |                                                                 |
  |          Error Bounds for Particular Complex Functions          |
  |                                                                 |
  +-----------------------------+---------+-----------------+-------+
  |                             |         |                 |       |
  |                             | Nature  |    Nature of    | Error |
  |    Function or Operator     |   of    |      Bound      | Bound |
  |                             | Result  |                 |       |
  |                             |         |                 |       |
  +-----------------------------+---------+-----------------+-------+
  |                             |         |                 |       |
  |           Modulus           |  real   | max. rel. error |   3.0 |
  |                             |         |                 |       |
  |          Argument           |  real   | max. rel. error |   4.0 |
  |                             |         |                 |       |
  |     Compose_From_Polar      | complex | max. rel. error |   3.0 |
  |                             |         |                 |       |
  | "*" (both operands complex) | complex | max. box error  |   5.0 |
  |                             |         |                 |       |
  | "/" (right operand complex) | complex | max. box error  |  13.0 |
  |                             |         |                 |       |
  |            Sqrt             | complex | max. rel. error |   6.0 |
  |                             |         |                 |       |
  |             Log             | complex | max. box error  |  13.0 |
  |                             |         |                 |       |
  |   Exp (complex parameter)   | complex | max. rel. error |   7.0 |
  |                             |         |                 |       |
  |  Exp (imaginary parameter)  | complex | max. rel. error |   2.0 |
  |                             |         |                 |       |
  |  Sin, Cos, Sinh, and Cosh   | complex | max. rel. error |  11.0 |
  |                             |         |                 |       |
  |  Tan, Cot, Tanh, and Coth   | complex | max. rel. error |  35.0 |
  |                             |         |                 |       |
  |    inverse trigonometric    | complex | max. rel. error |  14.0 |
  |                             |         |                 |       |
  |     inverse hyperbolic      | complex | max. rel. error |  14.0 |
  |                             |         |                 |       |
  +-----------------------------+---------+-----------------+-------+
@end format

@item
The maximum relative error given above applies throughout the domain of
the Compose_From_Polar function when the Cycle parameter is specified.
When the Cycle parameter is omitted, the maximum relative error applies
only when the absolute value of the parameter Argument is less than or
equal to the angle threshold, see @ref{G.2.4}. For the Exp function, and
for the forward hyperbolic (resp., trigonometric) functions, the maximum
relative error given above likewise applies only when the absolute value
of the imaginary (resp., real) component of the parameter X (or the
absolute value of the parameter itself, in the case of the Exp function
with a parameter of pure-imaginary type) is less than or equal to the
angle threshold. For larger angles, the accuracy is implementation
defined.

@item
The prescribed results specified in @ref{G.1.2}, for certain functions
at particular parameter values take precedence over the error bounds;
effectively, they narrow to a single value the result interval allowed
by the error bounds for a component of the result. Additional rules with
a similar effect are given below for certain inverse trigonometric and
inverse hyperbolic functions, at particular parameter values for which a
component of the mathematical result is transcendental. In each case,
the accuracy rule, which takes precedence over the error bounds, is that
the result interval for the stated result component is the model
interval of CT.Real associated with the component's exact mathematical
value. The cases in question are as follows:

@enumerate 10
@item
When the parameter X has the value zero, the real (resp., imaginary)
component of the result of the Arccot (resp., Arccoth) function is in
the model interval of CT.Real associated with the value Pi/2.0.

@item
When the parameter X has the value one, the real component of the result
of the Arcsin function is in the model interval of CT.Real associated
with the value Pi/2.0.

@item
When the parameter X has the value -1.0, the real component of the
result of the Arcsin (resp., Arccos) function is in the model interval
of CT.Real associated with the value -Pi/2.0 (resp., Pi).
@end enumerate
@end enumerate

@enumerate 13
@item
The amount by which a component of the result of an inverse
trigonometric or inverse hyperbolic function is allowed to spill over
into a quadrant adjacent to the one corresponding to the principal
branch, as given in @ref{G.1.2}, is limited. The rule is that the
result belongs to the smallest model interval of CT.Real that contains
both boundaries of the quadrant corresponding to the principal branch.
This rule also takes precedence to the maximum error bounds, effectively
narrowing the result interval allowed by them.

@item
Finally, the results allowed by the error bounds are narrowed by one
further rule: The absolute value of each component of the result of the
Exp function, for a pure-imaginary parameter, never exceeds one.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The version of the Compose_From_Polar function without a Cycle parameter
should not be implemented by calling the corresponding version with a
Cycle parameter of 2.0*Numerics.Pi, since this will not provide the
required accuracy in some portions of the domain.
@end enumerate

@c ===========================================================================
@node H, H.1, G.2.6, Top
@appendix  Safety and Security (normative)

@enumerate
@item
This Annex addresses requirements for systems that are safety critical
or have security constraints. It provides facilities and specifies
documentation requirements that relate to several needs:

@enumerate 2
@item
Understanding program execution;

@item
Reviewing object code;

@item
Restricting language constructs whose usage might complicate the
demonstration of program correctness
@end enumerate
@end enumerate

@enumerate 1
Execution understandability is supported by pragma Normalize_Scalars,
and also by requirements for the implementation to document the effect
of a program in the presence of a bounded error or where the language
rules leave the effect unspecified.
@end enumerate

@enumerate 5
@item
The pragmas Reviewable and Restrictions relate to the other requirements
addressed by this Annex.

NOTES

@item
(1) The Valid attribute, see @ref{13.9.2}, is also useful in addressing
these needs, to avoid problems that could otherwise arise from scalars
that have values outside their declared range constraints.
@end enumerate

@menu
* H.1:: Pragma Normalize_Scalars
* H.2:: Documentation of Implementation Decisions
* H.3:: Reviewable Object Code
* H.4:: Safety and Security Restrictions

--- The Detailed Node Listing ---

* H.1::   Pragma Normalize_Scalars
* H.2::   Documentation of Implementation Decisions
* H.3::   Reviewable Object Code
* H.3.1:: Pragma Reviewable
* H.3.2:: Pragma Inspection_Point
* H.4::   Safety and Security Restrictions
@end menu

@c ---------------------------------------------------------------------------
@node H.1, H.2, H, H
@section Pragma Normalize_Scalars

@enumerate
@item
This pragma ensures that an otherwise uninitialized scalar object is set
to a predictable value, but out of range if possible.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Normalize_Scalars is as follows:

@item
@example
pragma Normalize_Scalars;
@end example

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
Pragma Normalize_Scalars is a configuration pragma. It applies to all
compilation_units included in a partition.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
If a pragma Normalize_Scalars applies, the implementation shall document
the implicit initial value for scalar subtypes, and shall identify each
case in which such a value is used and is not an invalid representation.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
Whenever possible, the implicit initial value for a scalar subtype
should be an invalid representation, see @ref{13.9.1}.

NOTES

@item
(2) The initialization requirement applies to uninitialized scalar
objects that are subcomponents of composite objects, to allocated
objects, and to stand-alone objects. It also applies to scalar out
parameters. Scalar subcomponents of composite out parameters are
initialized to the corresponding part of the actual, by virtue of
@ref{6.4.1}.

@item
(3) The initialization requirement does not apply to a scalar for which
pragma Import has been specified, since initialization of an imported
object is performed solely by the foreign language environment
(@pxref{B.1}).

@item
(4) The use of pragma Normalize_Scalars in conjunction with Pragma
Restrictions(No_Exceptions) may result in erroneous execution
(@pxref{H.4}).
@end enumerate

@c ---------------------------------------------------------------------------
@node H.2, H.3, H.1, H
@section Documentation of Implementation Decisions

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@enumerate
@item
The implementation shall document the range of effects for each
situation that the language rules identify as either a bounded error or
as having an unspecified effect. If the implementation can constrain the
effects of erroneous execution for a given construct, then it shall
document such constraints. The documentation might be provided either
independently of any compilation unit or partition, or as part of an
annotated listing for a given unit or partition. See also  @ref{1.1.3},
and @ref{1.1.2}.

NOTES

@item
(5) Among the situations to be documented are the conventions chosen for
parameter passing, the methods used for the management of run-time
storage, and the method used to evaluate numeric expressions if this
involves extended range or extra precision.
@end enumerate

@c ---------------------------------------------------------------------------
@node H.3, H.3.1, H.2, H
@section Reviewable Object Code

@enumerate
@item
Object code review and validation are supported by pragmas Reviewable
and Inspection_Point.
@end enumerate

@menu
* H.3.1:: Pragma Reviewable
* H.3.2:: Pragma Inspection_Point
@end menu

@c ---------------------------------------------------------------------------
@node H.3.1, H.3.2, H.3, H.3
@subsection Pragma Reviewable

@enumerate
@item
This pragma directs the implementation to provide information to
facilitate analysis and review of a program's object code, in particular
to allow determination of execution time and storage usage and to
identify the correspondence between the source and object programs.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Reviewable is as follows:

@item
@example
pragma Reviewable;
@end example

@need 1000
@sp 1
@center @emph{Post-Compilation Rules}

@item
Pragma Reviewable is a configuration pragma. It applies to all
compilation_units included in a partition.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall provide the following information for any
compilation unit to which such a pragma applies:

@enumerate 6
@item
Where compiler-generated run-time checks remain;

@item
An identification of any construct with a language-defined check that is
recognized prior to run time as certain to fail if executed (even if the
generation of run-time checks has been suppressed);

@item
For each reference to a scalar object, an identification of the
reference as either ``known to be initialized,'' or ``possibly
uninitialized,'' independent of whether pragma Normalize_Scalars
applies;

@item
Where run-time support routines are implicitly invoked;

@item
An object code listing, including:

@enumerate 11
@item
Machine instructions, with relative offsets;

@item
Where each data object is stored during its lifetime;

@item
Correspondence with the source program, including an identification of
the code produced per declaration and per statement.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 14
@item
An identification of each construct for which the implementation detects
the possibility of erroneous execution;

@item
For each subprogram, block, task, or other construct implemented by
reserving and subsequently freeing an area on a run-time stack, an
identification of the length of the fixed-size portion of the area and
an indication of whether the non-fixed size portion is reserved on the
stack or in a dynamically-managed storage region.
@end enumerate
@end enumerate

@enumerate 16
@item
The implementation shall provide the following information for any
partition to which the pragma applies:

@enumerate 17
@item
An object code listing of the entire partition, including initialization
and finalization code as well as run-time system components, and with an
identification of those instructions and data that will be relocated at
load time;

@item
A description of the run-time model relevant to the partition.
@end enumerate
@end enumerate

@enumerate 19
The implementation shall provide control- and data-flow information, both
within each compilation unit and across the compilation units of the
partition.

@need 1000
@sp 1
@center @emph{Implementation Advice}

@item
The implementation should provide the above information in both a
human-readable and machine-readable form, and should document the latter
so as to ease further processing by automated tools.

@item
Object code listings should be provided both in a symbolic format and
also in an appropriate numeric format (such as hexadecimal or octal).

NOTES

@item
(6) The order of elaboration of library units will be documented even in
the absence of pragma Reviewable, see @ref{10.2}.
@end enumerate

@c ---------------------------------------------------------------------------
@node H.3.2, H.4, H.3.1, H.3
@subsection Pragma Inspection_Point

@enumerate
@item
An occurrence of a pragma Inspection_Point identifies a set of objects
each of whose values is to be available at the point(s) during program
execution corresponding to the position of the pragma in the compilation
unit. The purpose of such a pragma is to facilitate code validation.

@need 1000
@sp 1
@center @emph{Syntax}

@item
The form of a pragma Inspection_Point is as follows:

@item
@example
pragma Inspection_Point[(object_name @{, object_name@})];
@end example

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
A pragma Inspection_Point is allowed wherever a declarative_item or
statement is allowed. Each object_name shall statically denote the
declaration of an object.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An inspection point is a point in the object code corresponding to the
occurrence of a pragma Inspection_Point in the compilation unit. An
object is inspectable at an inspection point if the corresponding pragma
Inspection_Point either has an argument denoting that object, or has no
arguments.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
Execution of a pragma Inspection_Point has no effect.

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
Reaching an inspection point is an external interaction with respect to
the values of the inspectable objects at that point, see @ref{1.1.3}.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
For each inspection point, the implementation shall identify a mapping
between each inspectable object and the machine resources (such as
memory locations or registers) from which the object's value can be
obtained.

NOTES

@item
(7) The implementation is not allowed to perform ``dead store
elimination'' on the last assignment to a variable prior to a point
where the variable is inspectable. Thus an inspection point has the
effect of an implicit reference to each of its inspectable objects.

@item
(8) Inspection points are useful in maintaining a correspondence between
the state of the program in source code terms, and the machine state
during the program's execution. Assertions about the values of program
objects can be tested in machine terms at inspection points. Object code
between inspection points can be processed by automated tools to verify
programs mechanically.

@item
(9) The identification of the mapping from source program objects to
machine resources is allowed to be in the form of an annotated object
listing, in human-readable or tool-processable form.
@end enumerate

@c ---------------------------------------------------------------------------
@node H.4, J, H.3.2, H
@section Safety and Security Restrictions

@enumerate
@item
This clause defines restrictions that can be used with pragma
Restrictions, see @ref{13.12}, these facilitate the demonstration of
program correctness by allowing tailored versions of the run-time
system.

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following restrictions, the same as in @ref{D.7}, apply in this
Annex: No_Task_Hierarchy, No_Abort_Statement,
No_Implicit_Heap_Allocation, Max_Task_Entries is 0,
Max_Asynchronous_Select_Nesting is 0, and Max_Tasks is 0. The last three
restrictions are checked prior to program execution.

@item
The following additional restrictions apply in this Annex.

@item
Tasking-related restriction:

@item
No_Protected_Types

@example
There are no declarations of protected types or protected
objects.
@end example

@item
Memory-management related restrictions:

@item
No_Allocators

@example
There are no occurrences of an allocator.
@end example

@item
No_Local_Allocators

@example
Allocators are prohibited in subprograms, generic sub-programs,
tasks, and entry bodies; instantiations of generic
packages are also prohibited in these contexts.
@end example

@item
No_Unchecked_Deallocation

@example
Semantic dependence on Unchecked_Deallocation is not allowed.
@end example

@item
Immediate_Reclamation

@example
Except for storage occupied by objects created by allocators
and not deallocated via unchecked deallocation, any storage
reserved at run time for an object is immediately reclaimed
when the object no longer exists.
@end example

@item
Exception-related restriction:

@item
No_Exceptions

@example
Raise_statements and exception_handlers are not allowed. No
language-defined run-time checks are generated; however, a
run-time check performed automatically by the hardware is
permitted.
@end example

@item
Other restrictions:

@item
No_Floating_Point

@example
Uses of predefined floating point types and operations, and
declarations of new floating point types, are not allowed.
@end example

@item
No_Fixed_Point

@example
Uses of predefined fixed point types and operations, and
declarations of new fixed point types, are not allowed.
@end example

@item
No_Unchecked_Conversion

@example
Semantic dependence on the predefined generic
Unchecked_Conversion is not allowed.
@end example

@item
No_Access_Subprograms

@example
The declaration of access-to-subprogram types is not allowed.
@end example

@item
No_Unchecked_Access

@example
The Unchecked_Access attribute is not allowed.
@end example

@item
No_Dispatch

@example
Occurrences of T'Class are not allowed, for any (tagged)
subtype T.
@end example

@item
No_IO

@example
Semantic dependence on any of the library units
Sequential_IO, Direct_IO, Text_IO, Wide_Text_IO, or Stream_IO
is not allowed.
@end example

@item
No_Delay

@example
Delay_Statements and semantic dependence on package Calendar
are not allowed.
@end example

@item
No_Recursion

@example
As part of the execution of a subprogram, the same subprogram
is not invoked.
@end example

@item
No_Reentrancy

@example
During the execution of a subprogram by a task, no other task
invokes the same subprogram.
@end example

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
If an implementation supports pragma Restrictions for a particular
argument, then except for the restrictions No_Unchecked_Deallocation,
No_Unchecked_Conversion, No_Access_Subprograms, and No_Unchecked_Access,
the associated restriction applies to the run-time system.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
If a pragma Restrictions(No_Exceptions) is specified, the implementation
shall document the effects of all constructs where language-defined
checks are still performed automatically (for example, an overflow check
performed by the processor).

@need 1000
@sp 1
@center @emph{Erroneous Execution}

@item
Program execution is erroneous if pragma Restrictions(No_Exceptions) has
been specified and the conditions arise under which a generated
language-defined run-time check would fail.

@item
Program execution is erroneous if pragma Restrictions(No_Recursion) has
been specified and a subprogram is invoked as part of its own execution,
or if pragma Restrictions(No_Reentrancy) has been specified and during
the execution of a subprogram by a task, another task invokes the same
subprogram.
@end enumerate

@c ===========================================================================
@node J, J.1, H.4, Top
@appendix  Obsolescent Features (normative)

@enumerate
@item
This Annex contains descriptions of features of the language whose
functionality is largely redundant with other features defined by this
International Standard. Use of these features is not recommended in
newly written programs.
@end enumerate

@menu
* J.1:: Renamings of Ada 83 Library Units
* J.2:: Allowed Replacements of Characters
* J.3:: Reduced Accuracy Subtypes
* J.4:: The Constrained Attribute
* J.5:: ASCII
* J.6:: Numeric_Error
* J.7:: At Clauses
* J.8:: Mod Clauses
* J.9:: The Storage_Size Attribute

--- The Detailed Node Listing ---

* J.1::   Renamings of Ada 83 Library Units
* J.2::   Allowed Replacements of Characters
* J.3::   Reduced Accuracy Subtypes
* J.4::   The Constrained Attribute
* J.5::   ASCII
* J.6::   Numeric_Error
* J.7::   At Clauses
* J.7.1:: Interrupt Entries
* J.8::   Mod Clauses
* J.9::   The Storage_Size Attribute
@end menu

@c ---------------------------------------------------------------------------
@node J.1, J.2, J, J
@section Renamings of Ada 83 Library Units

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following library_unit_renaming_declarations exist:

@item
@example
with Ada.Unchecked_Conversion;
generic function Unchecked_Conversion
  renames Ada.Unchecked_Conversion;
@end example

@item
@example
with Ada.Unchecked_Deallocation;
generic procedure Unchecked_Deallocation
  renames Ada.Unchecked_Deallocation;
@end example

@item
@example
with Ada.Sequential_IO;
generic package Sequential_IO renames Ada.Sequential_IO;
@end example

@item
@example
with Ada.Direct_IO;
generic package Direct_IO renames Ada.Direct_IO;
@end example

@item
@example
with Ada.Text_IO;
package Text_IO renames Ada.Text_IO;
@end example

@item
@example
with Ada.IO_Exceptions;
package IO_Exceptions renames Ada.IO_Exceptions;
@end example

@item
@example
with Ada.Calendar;
package Calendar renames Ada.Calendar;
@end example

@item
@example
with System.Machine_Code;
package Machine_Code renames System.Machine_Code; -- If supported.
@end example

@need 1000
@sp 1
@center @emph{Implementation Requirements}

@item
The implementation shall allow the user to replace these renamings.
@end enumerate

@c ---------------------------------------------------------------------------
@node J.2, J.3, J.1, J
@section Allowed Replacements of Characters

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate
@item
The following replacements are allowed for the vertical line, number
sign, and quotation mark characters:

@enumerate 2
@item
A vertical line character (|) can be replaced by an exclamation mark (!)
where used as a delimiter.

@item
The number sign characters (#) of a based_literal can be replaced by
colons (:) provided that the replacement is done for both occurrences.

@item
The quotation marks (") used as string brackets at both ends of a string
literal can be replaced by percent signs (%) provided that the enclosed
sequence of characters contains no quotation mark, and provided that
both string brackets are replaced. Any percent sign within the sequence
of characters shall then be doubled and each such doubled percent sign
is interpreted as a single percent sign character value.

@item
These replacements do not change the meaning of the program.
@end enumerate
@end enumerate

@c ---------------------------------------------------------------------------
@node J.3, J.4, J.2, J
@section Reduced Accuracy Subtypes

@enumerate
@item
A digits_constraint may be used to define a floating point subtype with
a new value for its requested decimal precision, as reflected by its
Digits attribute. Similarly, a delta_constraint may be used to define an
ordinary fixed point subtype with a new value for its delta, as
reflected by its Delta attribute.

@need 1000
@sp 1
@center @emph{Syntax}

@item
@example
delta_constraint ::= delta static_expression [range_constraint]
@end example

@need 1000
@sp 1
@center @emph{Name Resolution Rules}

@item
The expression of a delta_constraint is expected to be of any real type.

@need 1000
@sp 1
@center @emph{Legality Rules}

@item
The expression of a delta_constraint shall be static.

@item
For a subtype_indication with a delta_constraint, the subtype_mark shall
denote an ordinary fixed point subtype.

@item
For a subtype_indication with a digits_constraint, the subtype_mark
shall denote either a decimal fixed point subtype or a floating point
subtype (notwithstanding the rule given in @ref{3.5.9}, that only
allows a decimal fixed point subtype).

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A subtype_indication with a subtype_mark that denotes an ordinary fixed
point subtype and a delta_constraint defines an ordinary fixed point
subtype with a delta given by the value of the expression of the
delta_constraint. If the delta_constraint includes a range_constraint,
then the ordinary fixed point subtype is constrained by the
range_constraint.

@item
A subtype_indication with a subtype_mark that denotes a floating point
subtype and a digits_constraint defines a floating point subtype with a
requested decimal precision (as reflected by its Digits attribute) given
by the value of the expression of the digits_constraint. If the
digits_constraint includes a range_constraint, then the floating point
subtype is constrained by the range_constraint.

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@item
A delta_constraint is compatible with an ordinary fixed point subtype if
the value of the expression is no less than the delta of the subtype,
and the range_constraint, if any, is compatible with the subtype.

@item
A digits_constraint is compatible with a floating point subtype if the
value of the expression is no greater than the requested decimal
precision of the subtype, and the range_constraint, if any, is
compatible with the subtype.

@item
The elaboration of a delta_constraint consists of the elaboration of the
range_constraint, if any.
@end enumerate

@c ---------------------------------------------------------------------------
@node J.4, J.5, J.3, J
@section The Constrained Attribute

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
For every private subtype S, the following attribute is defined:

@item
S'Constrained

@example
Yields the value False if S denotes an unconstrained
nonformal private subtype with discriminants; also yields the
value False if S denotes a generic formal private subtype,
and the associated actual subtype is either an unconstrained
subtype with discriminants or an unconstrained array subtype;
yields the value True otherwise. The value of this attribute
is of the predefined subtype Boolean.
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node J.5, J.6, J.4, J
@section ASCII

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following declaration exists in the declaration of package Standard:

@item
@example
package ASCII is
@end example

@item
@example
   --  Control characters:
@end example

@item
@example
   NUL   : constant Character := nul;
   SOH   : constant Character := soh;
   STX   : constant Character := stx;
   ETX   : constant Character := etx;
   EOT   : constant Character := eot;
   ENQ   : constant Character := enq;
   ACK   : constant Character := ack;
   BEL   : constant Character := bel;
   BS    : constant Character := bs;
   HT    : constant Character := ht;
   LF    : constant Character := lf;
   VT    : constant Character := vt;
   FF    : constant Character := ff;
   CR    : constant Character := cr;
   SO    : constant Character := so;
   SI    : constant Character := si;
   DLE   : constant Character := dle;
   DC1   : constant Character := dc1;
   DC2   : constant Character := dc2;
   DC3   : constant Character := dc3;
   DC4   : constant Character := dc4;
   NAK   : constant Character := nak;
   SYN   : constant Character := syn;
   ETB   : constant Character := etb;
   CAN   : constant Character := can;
   EM    : constant Character := em;
   SUB   : constant Character := sub;
   ESC   : constant Character := esc;
   FS    : constant Character := fs;
   GS    : constant Character := gs;
   RS    : constant Character := rs;
   US    : constant Character := us;
   DEL   : constant Character := del;
@end example

@item
@example
   -- Other characters:
@end example

@item
@example
   Exclam    : constant Character:= '!';
   Quotation : constant Character:= '"';
   Sharp     : constant Character:= '#';
   Dollar    : constant Character:= '$';
   Percent   : constant Character:= '%';
   Ampersand : constant Character:= '&';
   Colon     : constant Character:= ':';
   Semicolon : constant Character:= ';';
   Query     : constant Character:= '?';
   At_Sign   : constant Character:= '@';
   L_Bracket : constant Character:= '[';
   Back_Slash: constant Character:= '\';
   R_Bracket : constant Character:= ']';
   Circumflex: constant Character:= '^';
   Underline : constant Character:= '_';
   Grave     : constant Character:= '`';
   L_Brace   : constant Character:= '@{';
   Bar       : constant Character:= '|';
   R_Brace   : constant Character:= '@}';
   Tilde     : constant Character:= '~';
@end example

@item
@example
   -- Lower case letters:
@end example

@item
@example
   LC_A: constant Character:= 'a';
   ...
   LC_Z: constant Character:= 'z';
@end example

@item
@example
end ASCII;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node J.6, J.7, J.5, J
@section Numeric_Error

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
The following declaration exists in the declaration of package Standard:

@item
@example
Numeric_Error : exception renames Constraint_Error;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node J.7, J.7.1, J.6, J
@section At Clauses

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate
@item
@example
at_clause ::= for direct_name use at expression;
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
An at_clause of the form ``for x use at y;'' is equivalent to an
attribute_definition_clause of the form ``for x'Address use y;''.
@end enumerate

@menu
* J.7.1:: Interrupt Entries
@end menu

@c ---------------------------------------------------------------------------
@node J.7.1, J.8, J.7, J.7
@subsection Interrupt Entries

@enumerate
@item
Implementations are permitted to allow the attachment of task entries to
interrupts via the address clause. Such an entry is referred to as an
interrupt entry.

@item
The address of the task entry corresponds to a hardware interrupt in an
implementation-defined manner. (See Ada.Interrupts.Reference in
@ref{C.3.2}.)

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
The following attribute is defined:

@item
For any task entry X:

@item
X'Address

@example
For a task entry whose address is specified (an interrupt
entry), the value refers to the corresponding hardware
interrupt. For such an entry, as for any other task entry,
the meaning of this value is implementation defined. The
value of this attribute is of the type of the subtype
System.Address.
@end example

@enumerate 6
@item
Address may be specified for single entries via an
attribute_definition_clause.
@end enumerate
@end enumerate

@need 1000
@sp 1
@center @emph{Dynamic Semantics}

@enumerate 7
@item
As part of the initialization of a task object, the address clause for
an interrupt entry is elaborated, which evaluates the expression of the
address clause. A check is made that the address specified is associated
with some interrupt to which a task entry may be attached. If this check
fails, Program_Error is raised. Otherwise, the interrupt entry is
attached to the interrupt associated with the specified address.

@item
Upon finalization of the task object, the interrupt entry, if any, is
detached from the corresponding interrupt and the default treatment is
restored.

@item
While an interrupt entry is attached to an interrupt, the interrupt is
reserved, see @ref{C.3}.

@item
An interrupt delivered to a task entry acts as a call to the entry
issued by a hardware task whose priority is in the
System.Interrupt_Priority range. It is implementation defined whether
the call is performed as an ordinary entry call, a timed entry call, or
a conditional entry call; which kind of call is performed can depend on
the specific interrupt.

@need 1000
@sp 1
@center @emph{Bounded (Run-Time) Errors}

@item
It is a bounded error to evaluate E'Caller, see @ref{C.7.1}, in an
accept_statement for an interrupt entry. The possible effects are the
same as for calling Current_Task from an entry body.

@need 1000
@sp 1
@center @emph{Documentation Requirements}

@item
The implementation shall document to which interrupts a task entry may
be attached.

@item
The implementation shall document whether the invocation of an interrupt
entry has the effect of an ordinary entry call, conditional call, or a
timed call, and whether the effect varies in the presence of pending
interrupts.

@need 1000
@sp 1
@center @emph{Implementation Permissions}

@item
The support for this subclause is optional.

@item
Interrupts to which the implementation allows a task entry to be
attached may be designated as reserved for the entire duration of
program execution; that is, not just when they have an interrupt entry
attached to them.

@item
Interrupt entry calls may be implemented by having the hardware execute
directly the appropriate accept body. Alternatively, the implementation
is allowed to provide an internal interrupt handler to simulate the
effect of a normal task calling the entry.

@item
The implementation is allowed to impose restrictions on the
specifications and bodies of tasks that have interrupt entries.

@item
It is implementation defined whether direct calls (from the program) to
interrupt entries are allowed.

@item
If a select_statement contains both a terminate_alternative and an
accept_alternative for an interrupt entry, then an implementation is
allowed to impose further requirements for the selection of the
terminate_alternative in addition to those given in, see @ref{9.3}.

NOTES

@item
(1) Queued interrupts correspond to ordinary entry calls. Interrupts
that are lost if not immediately processed correspond to conditional
entry calls. It is a consequence of the priority rules that an accept
body executed in response to an interrupt can be executed with the
active priority at which the hardware generates the interrupt, taking
precedence over lower priority tasks, without a scheduling action.

@item
(2) Control information that is supplied upon an interrupt can be passed
to an associated interrupt entry as one or more parameters of mode in.

@need 1000
@sp 1
@center @emph{Examples}

@item
Example of an interrupt entry:

@item
@example
task Interrupt_Handler is
  entry Done;
  for Done'Address use
    Ada.Interrupts.Reference (Ada.Interrupts.Names.Device_Done);
end Interrupt_Handler;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node J.8, J.9, J.7.1, J
@section Mod Clauses

@need 1000
@sp 1
@center @emph{Syntax}

@enumerate
@item
@example
mod_clause ::= at mod static_expression;
@end example

@need 1000
@sp 1
@center @emph{Static Semantics}

@item
A record_representation_clause of the form:

@item
@example
for r use
    record at mod a
        ...
    end record;
@end example

@item
is equivalent to:

@item
@example
for r'Alignment use a;
for r use
    record
        ...
    end record;
@end example
@end enumerate

@c ---------------------------------------------------------------------------
@node J.9, K, J.8, J
@section The Storage_Size Attribute

@need 1000
@sp 1
@center @emph{Static Semantics}

@enumerate
@item
For any task subtype T, the following attribute is defined:

@item
T'Storage_Size

@example
Denotes an implementation-defined value of type
universal_integer representing the number of storage
elements reserved for a task of the subtype T.
@end example

@enumerate 3
@item
Storage_Size may be specified for a task first subtype via an
attribute_definition_clause.
@end enumerate
@end enumerate

@c ===========================================================================
@node K, L, J.9, Top
@appendix  Language-Defined Attributes (informative)

@enumerate
@item
This annex summarizes the definitions given elsewhere of the
language-defined attributes.

@item
P'Access

@enumerate 3
For a prefix P that denotes a subprogram:

@item
P'Access yields an access value that designates the subprogram denoted
by P. The type of P'Access is an access-to-subprogram type (S), as
determined by the expected type (@pxref{3.10.2}).
@end enumerate
@end enumerate

@enumerate 4
@item
X'Access

@enumerate 5
For a prefix X that denotes an aliased view of an object:

@item
X'Access yields an access value that designates the object denoted by X.
The type of X'Access is an access-to-object type, as determined by the
expected type. The expected type shall be a general access type
(@pxref{3.10.2}).
@end enumerate
@end enumerate

@enumerate 6
@item
X'Address

@enumerate 7
For a prefix X that denotes an object, program unit, or
label:

@item
Denotes the address of the first of the storage elements allocated to X.
For a program unit or label, this value refers to the machine code
associated with the corresponding body or statement. The value of this
attribute is of type System.Address (@pxref{13.3}).
@end enumerate
@end enumerate

@enumerate 8
@item
S'Adjacent

@enumerate 9
For every subtype S of a floating point type T:

@item
S'Adjacent denotes a function with the following specification:

@item
@example
function S'Adjacent (X, Towards : T) return T
@end example

@item
If Towards=X, the function yields X; otherwise, it yields the machine
number of the type T adjacent to X in the direction of Towards, if that
machine number exists. If the result would be outside the base range of
S, Constraint_Error is raised. When T'Signed_Zeros is True, a zero
result has the sign of X. When Towards is zero, its sign has no bearing
on the result (@pxref{A.5.3}).
@end enumerate
@end enumerate

@enumerate 12
@item
S'Aft

@enumerate 13
For every fixed point subtype S:

@item
S'Aft yields the number of decimal digits needed after the decimal point
to accommodate the delta of the subtype S, unless the delta of the
subtype S is greater than 0.1, in which case the attribute yields the
value one. (S'Aft is the smallest positive integer N for which
(10**N)*S'Delta is greater than or equal to one.)  The value of this
attribute is of the type universal_integer (@pxref{3.5.10}).
@end enumerate
@end enumerate

@enumerate 14
@item
X'Alignment

@enumerate 15
For a prefix X that denotes a subtype or object:

@item
The Address of an object that is allocated under control of the
implementation is an integral multiple of the Alignment of the object
(that is, the Address modulo the Alignment is zero). The offset of a
record component is a multiple of the Alignment of the component. For an
object that is not allocated under control of the implementation (that
is, one that is imported, that is allocated by a user-defined allocator,
whose Address has been specified, or is designated by an access value
returned by an instance of Unchecked_Conversion), the implementation may
assume that the Address is an integral multiple of its Alignment. The
implementation shall not assume a stricter alignment.

@item
The value of this attribute is of type universal_integer, and
nonnegative; zero means that the object is not necessarily aligned on a
storage element boundary (@pxref{13.3}).
@end enumerate
@end enumerate

@enumerate 17
@item
S'Base

@enumerate 18
For every scalar subtype S:

@item
S'Base denotes an unconstrained subtype of the type of S. This
unconstrained subtype is called the base subtype of the type
(@pxref{3.5}).
@end enumerate
@end enumerate

@enumerate 19
@item
S'Bit_Order

@enumerate 20
For every specific record subtype S:

@item
Denotes the bit ordering for the type of S. The value of this attribute
is of type System.Bit_Order (@pxref{13.5.3}).
@end enumerate
@end enumerate

@enumerate 21
@item
P'Body_Version

@enumerate 22
For a prefix P that statically denotes a program unit:

@item
Yields a value of the predefined type String that identifies the version
of the compilation unit that contains the body (but not any subunits) of
the program unit (@pxref{E.3}).
@end enumerate
@end enumerate

@enumerate 23
@item
T'Callable

@enumerate 24
For a prefix T that is of a task type (after any implicit dereference):

@item
Yields the value True when the task denoted by T is callable, and False
otherwise (@pxref{9.9}).
@end enumerate
@end enumerate

@enumerate 25
@item
E'Caller

@enumerate 26
For a prefix E that denotes an entry_declaration:

@item
Yields a value of the type Task_ID that identifies the task whose call
is now being serviced. Use of this attribute is allowed only inside an
entry_body or accept_statement corresponding to the entry_declaration
denoted by E (@pxref{C.7.1}).
@end enumerate
@end enumerate

@enumerate 27
@item
S'Ceiling

@enumerate 28
For every subtype S of a floating point type T:

@item
S'Ceiling denotes a function with the following specification:

@item
@example
function S'Ceiling (X : T) return T
@end example

@item
The function yields the value Ceiling(X), i.e., the smallest (most
negative) integral value greater than or equal to X. When X is zero, the
result has the sign of X; a zero result otherwise has a negative sign
when S'Signed_Zeros is True (@pxref{A.5.3}).
@end enumerate
@end enumerate

@enumerate 31
@item
S'Class

@enumerate 32
For every subtype S of a tagged type T (specific or class-wide):

@item
S'Class denotes a subtype of the class-wide type (called T'Class in this
International Standard) for the class rooted at T (or if S already
denotes a class-wide subtype, then S'Class is the same as S).

@item
S'Class is unconstrained. However, if S is constrained, then the values
of S'Class are only those that when converted to the type T belong to S
(@pxref{3.9}).
@end enumerate
@end enumerate

@enumerate 34
@item
S'Class

@enumerate 35
For every subtype S of an untagged private type whose full view is
tagged:

@item
Denotes the class-wide subtype corresponding to the full view of S. This
attribute is allowed only from the beginning of the private part in
which the full view is declared, until the declaration of the full view.
After the full view, the Class attribute of the full view can be used
(@pxref{7.3.1}).
@end enumerate
@end enumerate

@enumerate 36
@item
X'Component_Size

@enumerate 37
For a prefix X that denotes an array subtype or array object (after any
implicit dereference):

@item
Denotes the size in bits of components of the type of X. The value of
this attribute is of type universal_integer (@pxref{13.3}).
@end enumerate
@end enumerate

@enumerate 38
@item
S'Compose

@enumerate 39
For every subtype S of a floating point type T:

@item
S'Compose denotes a function with the following specification:

@item
@example
function S'Compose
 (Fraction : T;
  Exponent : universal_integer) return T
@end example

@item
Let v be the value (Fraction*T'Machine_Radix) ** (Exponent-k), where k
is the normalized exponent of Fraction. If v is a machine number of the
type T, or if |v|>=T'Model_Small, the function yields v; otherwise, it
yields either one of the machine numbers of the type T adjacent to v.
Constraint_Error is optionally raised if v is outside the base range of
S. A zero result has the sign of Fraction when S'Signed_Zeros is True
(@pxref{A.5.3}).
@end enumerate
@end enumerate

@enumerate 42
@item
A'Constrained

@enumerate 43
For a prefix A that is of a discriminated type (after any implicit
dereference):

@item
Yields the value True if A denotes a constant, a value, or a constrained
variable, and False otherwise (@pxref{3.7.2}).
@end enumerate
@end enumerate

@enumerate 44
@item
S'Copy_Sign

@enumerate 45
For every subtype S of a floating point type T:

@item
S'Copy_Sign denotes a function with the following specification:

@item
@example
function S'Copy_Sign (Value, Sign : T) return T
@end example

@item
If the value of Value is nonzero, the function yields a result whose
magnitude is that of Value and whose sign is that of Sign; otherwise, it
yields the value zero. Constraint_Error is optionally raised if the
result is outside the base range of S. A zero result has the sign of
Sign when S'Signed_Zeros is True (@pxref{A.5.3}).
@end enumerate
@end enumerate

@enumerate 48
@item
E'Count

@enumerate 49
For a prefix E that denotes an entry of a task or protected unit:

@item
Yields the number of calls presently queued on the entry E of the
current instance of the unit. The value of this attribute is of the type
universal_integer (@pxref{9.9}).
@end enumerate
@end enumerate

@enumerate 50
@item
S'Definite

@enumerate 51
For a prefix S that denotes a formal indefinite subtype:

@item
S'Definite yields True if the actual subtype corresponding to S is
definite; otherwise it yields False. The value of this attribute is of
the predefined type Boolean (@pxref{12.5.1}).
@end enumerate
@end enumerate

@enumerate 52
@item
S'Delta

@enumerate 53
For every fixed point subtype S:

@item
S'Delta denotes the delta of the fixed point subtype S. The value of
this attribute is of the type universal_real (@pxref{3.5.10}).
@end enumerate
@end enumerate

@enumerate 54
@item
S'Denorm

@enumerate 55
For every subtype S of a floating point type T:

@item
Yields the value True if every value expressible in the form

@example
                           T'Machine_Emin
+/-mantissa*T'Machine_Radix
@end example

where mantissa is a nonzero T'Machine_Mantissa-digit fraction in the
number base T'Machine_Radix, the first digit of which is zero, is a
machine number, see @ref{3.5.7}, of the type T; yields the value False
otherwise. The value of this attribute is of the predefined type
Boolean (@pxref{A.5.3}).
@end enumerate
@end enumerate

@enumerate 56
@item
S'Digits

@enumerate 57
For every decimal fixed point subtype S:

@item
S'Digits denotes the digits of the decimal fixed point subtype S, which
corresponds to the number of decimal digits that are representable in
objects of the subtype. The value of this attribute is of the type
universal_integer (@pxref{3.5.10}).
@end enumerate
@end enumerate

@enumerate 58
@item
S'Digits

@enumerate 59
For every floating point subtype S:

@item
S'Digits denotes the requested decimal precision for the subtype S. The
value of this attribute is of the type universal_integer (@pxref{3.5.8}).
@end enumerate
@end enumerate

@enumerate 60
@item
S'Exponent

@enumerate 61
For every subtype S of a floating point type T:

@item
S'Exponent denotes a function with the following specification:

@item
@example
function S'Exponent (X : T) return universal_integer
@end example

@item
The function yields the normalized exponent of X (@pxref{A.5.3}).
@end enumerate
@end enumerate

@enumerate 64
@item
S'External_Tag

@enumerate 65
For every subtype S of a tagged type T (specific or class-wide):

@item
S'External_Tag denotes an external string representation for S'Tag; it
is of the predefined type String. External_Tag may be specified for a
specific tagged type via an attribute_definition_clause; the expression
of such a clause shall be static. The default external tag
representation is implementation defined (see @ref{3.9.2} and
@ref{13.13.2}). @xref{13.3}.
@end enumerate
@end enumerate

@enumerate 66
@item
A'First(N)

@enumerate 67
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'First(N) denotes the lower bound of the N-th index range; its type is
the corresponding index type (@pxref{3.6.2}).
@end enumerate
@end enumerate

@enumerate 68
@item
A'First

@enumerate 69
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'First denotes the lower bound of the first index range; its type is
the corresponding index type (@pxref{3.6.2}).
@end enumerate
@end enumerate

@enumerate 70
@item
S'First

@enumerate 71
For every scalar subtype S:

@item
S'First denotes the lower bound of the range of S. The value of this
attribute is of the type of S. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 72
@item
R.C'First_Bit

@enumerate 73
For a component C of a composite, non-array object R:

@item
Denotes the offset, from the start of the first of the storage elements
occupied by C, of the first bit occupied by C. This offset is measured
in bits. The first bit of a storage element is numbered zero. The value
of this attribute is of the type universal_integer. @xref{13.5.2}.
@end enumerate
@end enumerate

@enumerate 74
@item
S'Floor

@enumerate 75
For every subtype S of a floating point type T:

@item
S'Floor denotes a function with the following specification:

@item
@example
function S'Floor (X : T) return T
@end example

@item
The function yields the value Floor(X), i.e., the largest (most
positive) integral value less than or equal to X. When X is zero, the
result has the sign of X; a zero result otherwise has a positive sign.
@xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 78
@item
S'Fore

@enumerate 79
For every fixed point subtype S:

@item
S'Fore yields the minimum number of characters needed before the decimal
point for the decimal representation of any value of the subtype S,
assuming that the representation does not include an exponent, but
includes a one-character prefix that is either a minus sign or a space.
(This minimum number does not include superfluous zeros or underlines,
and is at least 2.)  The value of this attribute is of the type
universal_integer. @xref{3.5.10}.
@end enumerate
@end enumerate

@enumerate 80
@item
S'Fraction

@enumerate 81
For every subtype S of a floating point type T:

@item
S'Fraction denotes a function with the following specification:

@item
@example
function S'Fraction (X : T) return T
@end example

@item
The function yields the value (X*T'Machine_Radix) ** -k, where k is the
normalized exponent of X. A zero result, which can only occur when X is
zero, has the sign of X. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 84
@item
E'Identity

@enumerate 85
For a prefix E that denotes an exception:

@item
E'Identity returns the unique identity of the exception. The type of
this attribute is Exception_Id. @xref{11.4.1}.
@end enumerate
@end enumerate

@enumerate 86
@item
T'Identity

@enumerate 87
For a prefix T that is of a task type (after any implicit dereference):

@item
Yields a value of the type Task_ID that identifies the task denoted by
T. @xref{C.7.1}.
@end enumerate
@end enumerate

@enumerate 88
@item
S'Image

@enumerate 89
For every scalar subtype S:

@item
S'Image denotes a function with the following specification:

@item
@example
function S'Image(Arg : S'Base) return String
@end example

@item
The function returns an image of the value of Arg as a String.
@xref{3.5}.
@end enumerate
@end enumerate

@enumerate 92
@item
S'Class'Input

@enumerate 93
For every subtype S'Class of a class-wide type T'Class:

@item
S'Class'Input denotes a function with the following specification:

@item
@example
function S'Class'Input
  (Stream : access Ada.Streams.Root_Stream_Type'Class)
  return T'Class
@end example

@item
First reads the external tag from Stream and determines the
corresponding internal tag (by calling
Tags.Internal_Tag(String'Input(Stream)) --  see @ref{3.9}.) and then
dispatches to the subprogram denoted by the Input attribute of the
specific type identified by the internal tag; returns that result.
@xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 96
@item
S'Input

@enumerate 97
For every subtype S of a specific type T:

@item
S'Input denotes a function with the following specification:

@item
@example
function S'Input
  (Stream : access Ada.Streams.Root_Stream_Type'Class)
  return T
@end example

@item
S'Input reads and returns one value from Stream, using any bounds or
discriminants written by a corresponding S'Output to determine how much
to read. @xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 100
@item
A'Last(N)

@enumerate 101
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'Last(N) denotes the upper bound of the N-th index range; its type is
the corresponding index type. @xref{3.6.2}.
@end enumerate
@end enumerate

@enumerate 102
@item
A'Last

@enumerate 103
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'Last denotes the upper bound of the first index range; its type is the
corresponding index type. @xref{3.6.2}.
@end enumerate
@end enumerate

@enumerate 104
@item
S'Last

@enumerate 105
For every scalar subtype S:

@item
S'Last denotes the upper bound of the range of S. The value of this
attribute is of the type of S. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 106
@item
R.C'Last_Bit

@enumerate 107
For a component C of a composite, non-array object R:

@item
Denotes the offset, from the start of the first of the storage elements
occupied by C, of the last bit occupied by C. This offset is measured in
bits. The value of this attribute is of the type universal_integer.
@xref{13.5.2}.
@end enumerate
@end enumerate

@enumerate 108
@item
S'Leading_Part

@enumerate 109
For every subtype S of a floating point type T:

@item
S'Leading_Part denotes a function with the following specification:

@item
@example
function S'Leading_Part
  (X            : T;
   Radix_Digits : universal_integer) return T
@end example

@item
Let v be the value T'Machine_Radix ** (k-Radix_Digits), where k is the
normalized exponent of X. The function yields the value

@enumerate 112
@item
Floor(X/v)*v, when X is nonnegative and Radix_Digits is positive;

@item
Ceiling(X/v)*v, when X is negative and Radix_Digits is positive.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 114
@item
Constraint_Error is raised when Radix_Digits is zero or negative. A zero
result, which can only occur when X is zero, has the sign of X.
@xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 115
@item
A'Length(N)

@enumerate 116
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'Length(N) denotes the number of values of the N-th index range (zero
for a null range); its type is universal_integer. @xref{3.6.2}.
@end enumerate
@end enumerate

@enumerate 117
@item
A'Length

@enumerate 118
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'Length denotes the number of values of the first index range (zero for
a null range); its type is universal_integer. @xref{3.6.2}.
@end enumerate
@end enumerate

@enumerate 119
@item
S'Machine

@enumerate 120
For every subtype S of a floating point type T:

@item
S'Machine denotes a function with the following specification:

@item
@example
function S'Machine (X : T) return T
@end example

@item
If X is a machine number of the type T, the function yields X;
otherwise, it yields the value obtained by rounding or truncating X to
either one of the adjacent machine numbers of the type T.
Constraint_Error is raised if rounding or truncating X to the precision
of the machine numbers results in a value outside the base range of S. A
zero result has the sign of X when S'Signed_Zeros is True. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 123
@item
S'Machine_Emax

@enumerate 124
For every subtype S of a floating point type T:

@item
Yields the largest (most positive) value of exponent such that every
value expressible in the canonical form (for the type T), having a
mantissa of T'Machine_Mantissa digits, is a machine number
(@pxref{3.5.7}) of the type T. This attribute yields a value of the type
universal_integer. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 125
@item
S'Machine_Emin

@enumerate 126
For every subtype S of a floating point type T:

@item
Yields the smallest (most negative) value of exponent such that every
value expressible in the canonical form (for the type T), having a
mantissa of T'Machine_Mantissa digits, is a machine number
(@pxref{3.5.7}) of the type T. This attribute yields a value of the type
universal_integer. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 127
@item
S'Machine_Mantissa

@enumerate 128
For every subtype S of a floating point type T:

@item
Yields the largest value of p such that every value expressible in the
canonical form (for the type T), having a p-digit mantissa and an
exponent between T'Machine_Emin and T'Machine_Emax, is a machine number
(see @ref{3.5.7}) of the type T. This attribute yields a value of the type
universal_integer. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 129
@item
S'Machine_Overflows

@enumerate 130
For every subtype S of a fixed point type T:

@item
Yields the value True if overflow and divide-by-zero are detected and
reported by raising Constraint_Error for every predefined operation that
yields a result of the type T; yields the value False otherwise. The
value of this attribute is of the predefined type Boolean. @xref{A.5.4}.
@end enumerate
@end enumerate

@enumerate 131
@item
S'Machine_Overflows

@enumerate 132
For every subtype S of a floating point type T:

@item
Yields the value True if overflow and divide-by-zero are detected and
reported by raising Constraint_Error for every predefined operation that
yields a result of the type T; yields the value False otherwise. The
value of this attribute is of the predefined type Boolean. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 133
@item
S'Machine_Radix

@enumerate 134
For every subtype S of a fixed point type T:

@item
Yields the radix of the hardware representation of the type T. The value
of this attribute is of the type universal_integer. @xref{A.5.4}.
@end enumerate
@end enumerate

@enumerate 135
@item
S'Machine_Radix

@enumerate 136
For every subtype S of a floating point type T:

@item
Yields the radix of the hardware representation of the type T. The value
of this attribute is of the type universal_integer. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 137
@item
S'Machine_Rounds

@enumerate 138
For every subtype S of a fixed point type T:

@item
Yields the value True if rounding is performed on inexact results of
every predefined operation that yields a result of the type T; yields
the value False otherwise. The value of this attribute is of the
predefined type Boolean. @xref{A.5.4}.
@end enumerate
@end enumerate

@enumerate 139
@item
S'Machine_Rounds

@enumerate 140
For every subtype S of a floating point type T:

@item
Yields the value True if rounding is performed on inexact results of
every predefined operation that yields a result of the type T; yields
the value False otherwise. The value of this attribute is of the
predefined type Boolean. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 141
@item
S'Max

@enumerate 142
For every scalar subtype S:

@item
S'Max denotes a function with the following specification:

@item
@example
function S'Max(Left, Right : S'Base) return S'Base
@end example

@item
The function returns the greater of the values of the two parameters.
@xref{3.5}.
@end enumerate
@end enumerate

@enumerate 145
@item
S'Max_Size_In_Storage_Elements

@enumerate 146
For every subtype S:

@item
Denotes the maximum value for Size_In_Storage_Elements that will be
requested via Allocate for an access type whose designated subtype is S.
The value of this attribute is of type universal_integer.
@xref{13.11.1}.
@end enumerate
@end enumerate

@enumerate 147
@item
S'Min

@enumerate 148
For every scalar subtype S:

@item
S'Min denotes a function with the following specification:

@item
@example
function S'Min(Left, Right : S'Base) return S'Base
@end example

@item
The function returns the lesser of the values of the two parameters.
@xref{3.5}.
@end enumerate
@end enumerate

@enumerate 151
@item
S'Model

@enumerate 152
For every subtype S of a floating point type T:

@item
S'Model denotes a function with the following specification:

@item
@example
function S'Model (X : T) return T
@end example

@item
If the Numerics Annex is not supported, the meaning of this attribute is
implementation defined;  see @ref{G.2.2} for the definition that applies to
implementations supporting the Numerics Annex. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 155
@item
S'Model_Emin

@enumerate 156
For every subtype S of a floating point type T:

@item
If the Numerics Annex is not supported, this attribute yields an
implementation defined value that is greater than or equal to the value
of T'Machine_Emin. @xref{G.2.2}, for further requirements that apply to
implementations supporting the Numerics Annex. The value of this
attribute is of the type universal_integer. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 157
@item
S'Model_Epsilon

@enumerate 158
For every subtype S of a floating point type T:

@item
Yields the value T'Machine_Radix ** (1-T'Model_Mantissa). The value of
this attribute is of the type universal_real. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 159
@item
S'Model_Mantissa

@enumerate 160
For every subtype S of a floating point type T:

@item
If the Numerics Annex is not supported, this attribute yields an
implementation defined value that is greater than or equal to
Ceiling(d*log (10)/log (T'Machine_Radix))+1, where d is the requested
decimal precision of T, and less than or equal to the value of
T'Machine_Mantissa. @xref{G.2.2}, for further requirements that apply to
implementations supporting the Numerics Annex. The value of this
attribute is of the type universal_integer. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 161
@item
S'Model_Small

@enumerate 162
For every subtype S of a floating point type T:

@item
Yields the value T'Machine_Radix ** (T'Model_Emin-1). The value of this
attribute is of the type universal_real. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 163
@item
S'Modulus

@enumerate 164
For every modular subtype S:

@item
S'Modulus yields the modulus of the type of S, as a value of the type
universal_integer. @xref{3.5.4}.
@end enumerate
@end enumerate

@enumerate 165
@item
S'Class'Output

@enumerate 166
For every subtype S'Class of a class-wide type T'Class:

@item
S'Class'Output denotes a procedure with the following specification:

@item
@example
procedure S'Class'Output
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : in T'Class)
@end example

@item
First writes the external tag of Item to Stream (by calling
String'Output(Tags.External_Tag(Item'Tag) --  see @ref{3.9}.) and then
dispatches to the subprogram denoted by the Output attribute of the
specific type identified by the tag. @xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 169
@item
S'Output

@enumerate 170
For every subtype S of a specific type T:

@item
S'Output denotes a procedure with the following specification:

@item
@example
procedure S'Output
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : in T)
@end example

@item
S'Output writes the value of Item to Stream, including any bounds or
discriminants. @xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 173
@item
D'Partition_ID

@enumerate 174
For a prefix D that denotes a library-level declaration, excepting a
declaration of or within a declared-pure library unit:

@item
Denotes a value of the type universal_integer that identifies the
partition in which D was elaborated. If D denotes the declaration of a
remote call interface library unit, see @ref{E.2.3}, the given partition is
the one where the body of D was elaborated. @xref{E.1}.
@end enumerate
@end enumerate

@enumerate 175
@item
S'Pos

@enumerate 176
For every discrete subtype S:

@item
S'Pos denotes a function with the following specification:

@item
@example
function S'Pos(Arg : S'Base) return universal_integer
@end example

@item
This function returns the position number of the value of Arg, as a
value of type universal_integer. @xref{3.5.5}.
@end enumerate
@end enumerate

@enumerate 179
@item
R.C'Position

@enumerate 180
For a component C of a composite, non-array object R:

@item
Denotes the same value as R.C'Address - R'Address. The value of this
attribute is of the type universal_integer. @xref{13.5.2}.
@end enumerate
@end enumerate

@enumerate 181
@item
S'Pred

@enumerate 182
For every scalar subtype S:

@item
S'Pred denotes a function with the following specification:

@item
@example
function S'Pred(Arg : S'Base) return S'Base
@end example

@item
For an enumeration type, the function returns the value whose position
number is one less than that of the value of Arg;  Constraint_Error is
raised if there is no such value of the type. For an integer type, the
function returns the result of subtracting one from the value of Arg.
For a fixed point type, the function returns the result of subtracting
small from the value of Arg. For a floating point type, the function
returns the machine number (as defined in @ref{3.5.7}.) immediately
below the value of Arg;  Constraint_Error is raised if there is no such
machine number. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 185
@item
A'Range(N)

@enumerate 186
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'Range(N) is equivalent to the range A'First(N) .. A'Last(N), except
that the prefix A is only evaluated once. @xref{3.6.2}.
@end enumerate
@end enumerate

@enumerate 187
@item
A'Range

@enumerate 188
For a prefix A that is of an array type (after any implicit
dereference), or denotes a constrained array subtype:

@item
A'Range is equivalent to the range A'First .. A'Last, except that the
prefix A is only evaluated once. @xref{3.6.2}.
@end enumerate
@end enumerate

@enumerate 189
@item
S'Range

@enumerate 190
For every scalar subtype S:

@item
S'Range is equivalent to the range S'First .. S'Last. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 191
@item
S'Class'Read

@enumerate 192
For every subtype S'Class of a class-wide type T'Class:

@item
S'Class'Read denotes a procedure with the following specification:

@item
@example
procedure S'Class'Read
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : out T'Class)
@end example

@item
Dispatches to the subprogram denoted by the Read attribute of the
specific type identified by the tag of Item. @xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 195
@item
S'Read

@enumerate 196
For every subtype S of a specific type T:

@item
S'Read denotes a procedure with the following specification:

@item
@example
procedure S'Read
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : out T)
@end example

@item
S'Read reads the value of Item from Stream. @xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 199
@item
S'Remainder

@enumerate 200
For every subtype S of a floating point type T:

@item
S'Remainder denotes a function with the following specification:

@item
@example
function S'Remainder (X, Y : T) return T
@end example

@item
For nonzero Y, let v be the value X-n*Y, where n is the integer nearest
to the exact value of X/Y; if |n-X/Y|=1/2, then n is chosen to be even.
If v is a machine number of the type T, the function yields v;
otherwise, it yields zero. Constraint_Error is raised if Y is zero. A
zero result has the sign of X when S'Signed_Zeros is True. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 203
@item
S'Round

@enumerate 204
For every decimal fixed point subtype S:

@item
S'Round denotes a function with the following specification:

@item
@example
function S'Round(X : universal_real) return S'Base
@end example

@item
The function returns the value obtained by rounding X (away from 0, if X
is midway between two values of the type of S). @xref{3.5.10}.
@end enumerate
@end enumerate

@enumerate 207
@item
S'Rounding

@enumerate 208
For every subtype S of a floating point type T:

@item
S'Rounding denotes a function with the following specification:

@item
@example
function S'Rounding (X : T) return T
@end example

@item
The function yields the integral value nearest to X, rounding away from
zero if X lies exactly halfway between two integers. A zero result has
the sign of X when S'Signed_Zeros is True. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 211
@item
S'Safe_First

@enumerate 212
For every subtype S of a floating point type T:

@item
Yields the lower bound of the safe range, see @ref{3.5.7}, of the type T.
If the Numerics Annex is not supported, the value of this attribute is
implementation defined;  @xref{G.2.2}, for the definition that applies to
implementations supporting the Numerics Annex. The value of this
attribute is of the type universal_real. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 213
@item
S'Safe_Last

@enumerate 214
For every subtype S of a floating point type T:

@item
Yields the upper bound of the safe range, see @ref{3.5.7} of the type T. If
the Numerics Annex is not supported, the value of this attribute is
implementation defined;  @xref{G.2.2}, for the definition that applies to
implementations supporting the Numerics Annex. The value of this
attribute is of the type universal_real. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 215
@item
S'Scale

@enumerate 216
For every decimal fixed point subtype S:

@item
S'Scale denotes the scale of the subtype S, defined as the value N such
that S'Delta = 10.0**(-N). The scale indicates the position of the point
relative to the rightmost significant digits of values of subtype S. The
value of this attribute is of the type universal_integer. @xref{3.5.10}.
@end enumerate
@end enumerate

@enumerate 217
@item
S'Scaling

@enumerate 218
For every subtype S of a floating point type T:

@item
S'Scaling denotes a function with the following specification:

@item
@example
function S'Scaling
  (X          : T;
   Adjustment : universal_integer) return T
@end example

@item
Let v be the value X*T'Machine_Radix ** Adjustment. If v is a machine
number of the type T, or if |v|>=T'Model_Small, the function yields v;
otherwise, it yields either one of the machine numbers of the type T
adjacent to v. Constraint_Error is optionally raised if v is outside the
base range of S. A zero result has the sign of X when S'Signed_Zeros is
True. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 221
@item
S'Signed_Zeros

@enumerate 222
For every subtype S of a floating point type T:

@item
Yields the value True if the hardware representation for the type T has
the capability of representing both positively and negatively signed
zeros, these being generated and used by the predefined operations of
the type T as specified in IEC 559:1989; yields the value False
otherwise. The value of this attribute is of the predefined type
Boolean. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 223
@item
S'Size

@enumerate 224
For every subtype S:

@item
If S is definite, denotes the size (in bits) that the implementation
would choose for the following objects of subtype S:

@enumerate 225
@item
A record component of subtype S when the record type is packed.

@item
The formal parameter of an instance of Unchecked_Conversion that
converts from subtype S to some other subtype.
@end enumerate
@end enumerate
@end enumerate

@enumerate
@enumerate 227
@item
If S is indefinite, the meaning is implementation defined. The value of
this attribute is of the type universal_integer. @xref{13.3}.
@end enumerate
@end enumerate

@enumerate 228
@item
X'Size

@enumerate 229
For a prefix X that denotes an object:

@item
Denotes the size in bits of the representation of the object. The value
of this attribute is of the type universal_integer. @xref{13.3}.
@end enumerate
@end enumerate

@enumerate 230
@item
S'Small

@enumerate 231
For every fixed point subtype S:

@item
S'Small denotes the small of the type of S. The value of this attribute
is of the type universal_real. @xref{3.5.10}.
@end enumerate
@end enumerate

@enumerate 232
@item
S'Storage_Pool

@enumerate 233
For every access subtype S:

@item
Denotes the storage pool of the type of S. The type of this attribute is
Root_Storage_Pool'Class. @xref{13.11}.
@end enumerate
@end enumerate

@enumerate 234
@item
S'Storage_Size

@enumerate 235
For every access subtype S:

@item
Yields the result of calling Storage_Size(S'Storage_Pool), which is
intended to be a measure of the number of storage elements reserved for
the pool. The type of this attribute is universal_integer. @xref{13.11}.
@end enumerate
@end enumerate

@enumerate 236
@item
T'Storage_Size

@enumerate 237
For a prefix T that denotes a task object (after any implicit
dereference):

@item
Denotes the number of storage elements reserved for the task. The value
of this attribute is of the type universal_integer. The Storage_Size
includes the size of the task's stack, if any. The language does not
specify whether or not it includes other storage associated with the
task (such as the ``task control block'' used by some implementations.)
@xref{13.3}.
@end enumerate
@end enumerate

@enumerate 238
@item
S'Succ

@enumerate 239
For every scalar subtype S:

@item
S'Succ denotes a function with the following specification:

@item
@example
function S'Succ(Arg : S'Base) return S'Base
@end example

@item
For an enumeration type, the function returns the value whose position
number is one more than that of the value of Arg;  Constraint_Error is
raised if there is no such value of the type. For an integer type, the
function returns the result of adding one to the value of Arg. For a
fixed point type, the function returns the result of adding small to the
value of Arg. For a floating point type, the function returns the
machine number (as defined in @ref{3.5.7}.) immediately above the value
of Arg;  Constraint_Error is raised if there is no such machine number.
@xref{3.5}.
@end enumerate
@end enumerate

@enumerate 242
@item
S'Tag

@enumerate 243
For every subtype S of a tagged type T (specific or class-wide):

@item
S'Tag denotes the tag of the type T (or if T is class-wide, the tag of
the root type of the corresponding class). The value of this attribute
is of type Tag. @xref{3.9}.
@end enumerate
@end enumerate

@enumerate 244
@item
X'Tag

@enumerate 245
For a prefix X that is of a class-wide tagged type (after any implicit
dereference):

@item
X'Tag denotes the tag of X. The value of this attribute is of type Tag.
@xref{3.9}.
@end enumerate
@end enumerate

@enumerate 246
@item
T'Terminated

@enumerate 247
For a prefix T that is of a task type (after any implicit dereference):

@item
Yields the value True if the task denoted by T is terminated, and False
otherwise. The value of this attribute is of the predefined type
Boolean. @xref{9.9}.
@end enumerate
@end enumerate

@enumerate 248
@item
S'Truncation

@enumerate 249
For every subtype S of a floating point type T:

@item
S'Truncation denotes a function with the following specification:

@item
@example
function S'Truncation (X : T) return T
@end example

@item
The function yields the value Ceiling(X) when X is negative, and
Floor(X) otherwise. A zero result has the sign of X when S'Signed_Zeros
is True. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 252
@item
S'Unbiased_Rounding

@enumerate 253
For every subtype S of a floating point type T:

@item
S'Unbiased_Rounding denotes a function with the following specification:

@item
@example
function S'Unbiased_Rounding (X : T) return T
@end example

@item
The function yields the integral value nearest to X, rounding toward the
even integer if X lies exactly halfway between two integers. A zero
result has the sign of X when S'Signed_Zeros is True. @xref{A.5.3}.
@end enumerate
@end enumerate

@enumerate 256
@item
X'Unchecked_Access

@enumerate 257
For a prefix X that denotes an aliased view of an object:

@item
All rules and semantics that apply to X'Access, see @ref{3.10.2}, apply
also to X'Unchecked_Access, except that, for the purposes of
accessibility rules and checks, it is as if X were declared immediately
within a library package. @xref{13.10}.
@end enumerate
@end enumerate

@enumerate 258
@item
S'Val

@enumerate 259
For every discrete subtype S:

@item
S'Val denotes a function with the following specification:

@item
@example
function S'Val(Arg : universal_integer) return S'Base
@end example

@item
This function returns a value of the type of S whose position number
equals the value of Arg. @xref{3.5.5}.
@end enumerate
@end enumerate

@enumerate 262
@item
262 X'Valid

@enumerate 263
For a prefix X that denotes a scalar object (after any implicit
dereference):

@item
Yields True if and only if the object denoted by X is normal and has a
valid representation. The value of this attribute is of the predefined
type Boolean. @xref{13.9.2}.
@end enumerate
@end enumerate

@enumerate 264
@item
S'Value

@enumerate 265
For every scalar subtype S:

@item
S'Value denotes a function with the following specification:

@item
@example
function S'Value(Arg : String) return S'Base
@end example

@item
This function returns a value given an image of the value as a String,
ignoring any leading or trailing spaces. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 268
@item
P'Version

@enumerate 269
For a prefix P that statically denotes a program unit:

@item
Yields a value of the predefined type String that identifies the version
of the compilation unit that contains the declaration of the program
unit. @xref{E.3}.
@end enumerate
@end enumerate

@enumerate 270
@item
S'Wide_Image

@enumerate 271
For every scalar subtype S:

@item
S'Wide_Image denotes a function with the following specification:

@item
@example
function S'Wide_Image(Arg : S'Base) return Wide_String
@end example

@item
The function returns an image of the value of Arg, that is, a sequence
of characters representing the value in display form. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 274
@item
S'Wide_Value

@enumerate 275
For every scalar subtype S:

@item
S'Wide_Value denotes a function with the following specification:

@item
@example
function S'Wide_Value(Arg : Wide_String) return S'Base
@end example

@item
This function returns a value given an image of the value as a
Wide_String, ignoring any leading or trailing spaces. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 278
@item
S'Wide_Width

@enumerate 279
For every scalar subtype S:

@item
S'Wide_Width denotes the maximum length of a Wide_String returned by
S'Wide_Image over all values of the subtype S. It denotes zero for a
subtype that has a null range. Its type is universal_integer.
@xref{3.5}.
@end enumerate
@end enumerate

@enumerate 280
@item
S'Width

@enumerate 281
For every scalar subtype S:

@item
S'Width denotes the maximum length of a String returned by S'Image over
all values of the subtype S. It denotes zero for a subtype that has a
null range. Its type is universal_integer. @xref{3.5}.
@end enumerate
@end enumerate

@enumerate 282
@item
S'Class'Write

@enumerate 283
For every subtype S'Class of a class-wide type T'Class:

@item
S'Class'Write denotes a procedure with the following specification:

@item
@example
procedure S'Class'Write
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item   : in T'Class)
@end example

@item
Dispatches to the subprogram denoted by the Write attribute of the
specific type identified by the tag of Item. @xref{13.13.2}.
@end enumerate
@end enumerate

@enumerate 286
@item
S'Write

@enumerate 287
For every subtype S of a specific type T:

@item
S'Write denotes a procedure with the following specification:

@item
@example
procedure S'Write
  (Stream : access Ada.Streams.Root_Stream_Type'Class;
   Item : in T)
@end example

@item
S'Write writes the value of Item to Stream. @xref{13.13.2}.
@end enumerate
@end enumerate

@c ===========================================================================
@node L, M, K, Top
@appendix  Language-Defined Pragmas (informative)

@enumerate
@item
This Annex summarizes the definitions given elsewhere of the
language-defined pragmas.

@item
@format
pragma All_Calls_Remote[(library_unit_name)];
--  see @ref{E.2.3}.
@end format

@item
@format
pragma Asynchronous(local_name);
--  see @ref{E.4.1}.
@end format

@item
@format
pragma Atomic(local_name);
--  see @ref{C.6}.
@end format

@item
@format
pragma Atomic_Components(array_local_name);
--  see @ref{C.6}.
@end format

@item
@format
pragma Attach_Handler(handler_name, expression);
--  see @ref{C.3.1}.
@end format

@item
@format
pragma Controlled(first_subtype_local_name);
--  see @ref{13.11.3}.
@end format

@item
@format
pragma Convention([Convention =>] convention_identifier,
  [Entity =>] local_name);
--  see @ref{B.1}.
@end format

@item
@format
pragma Discard_Names[([On => ] local_name)];
--  see @ref{C.5}.
@end format

@item
@format
pragma Elaborate(library_unit_name@{, library_unit_name@});
--  see @ref{10.2.1}.
@end format

@item
@format
pragma Elaborate_All(library_unit_name@{, library_unit_name@});
--  see @ref{10.2.1}.
@end format

@item
@format
pragma Elaborate_Body[(library_unit_name)];
--  see @ref{10.2.1}.
@end format

@item
@format
pragma Export( [Convention =>] convention_identifier,
  [Entity =>] local_name [, [External_Name =>] string_expression]
  [, [Link_Name =>] string_expression]);
--  see @ref{B.1}.
@end format

@item
@format
pragma Import( [Convention =>] convention_identifier,
  [Entity =>] local_name [, [External_Name =>] string_expression]
  [, [Link_Name =>] string_expression]);
--  see @ref{B.1}.
@end format

@item
@format
pragma Inline(name @{, name@});
--  see @ref{6.3.2}.
@end format

@item
@format
pragma Inspection_Point[(object_name @{, object_name@})];
--  see @ref{H.3.2}.
@end format

@item
@format
pragma Interrupt_Handler(handler_name);
--  see @ref{C.3.1}.
@end format

@item
@format
pragma Interrupt_Priority[(expression)];
--  see @ref{D.1}.
@end format

@item
@format
pragma Linker_Options(string_expression);
--  see @ref{B.1}.
@end format

@item
@format
pragma List(identifier);
--  see @ref{2.8}.
@end format

@item
@format
pragma Locking_Policy(policy_identifier);
--  see @ref{D.3}.
@end format

@item
@format
pragma Normalize_Scalars;
--  see @ref{H.1}.
@end format

@item
@format
pragma Optimize(identifier);
--  see @ref{2.8}.
@end format

@item
@format
pragma Pack(first_subtype_local_name);
--  see @ref{13.2}.
@end format

@item
@format
pragma Page;
--  see @ref{2.8}.
@end format

@item
@format
pragma Preelaborate[(library_unit_name)];
--  see @ref{10.2.1}.
@end format

@item
@format
pragma Priority(expression);
--  see @ref{D.1}.
@end format

@item
@format
pragma Pure[(library_unit_name)];
--  see @ref{10.2.1}.
@end format

@item
@format
pragma Queuing_Policy(policy_identifier);
--  see @ref{D.4}.
@end format

@item
@format
pragma Remote_Call_Interface[(library_unit_name)];
--  see @ref{E.2.3}.
@end format

@item
@format
pragma Remote_Types[(library_unit_name)];
--  see @ref{E.2.2}.
@end format

@item
@format
pragma Restrictions(restriction@{, restriction@});
--  see @ref{13.12}.
@end format

@item
@format
pragma Reviewable;
--  see @ref{H.3.1}.
@end format

@item
@format
pragma Shared_Passive[(library_unit_name)];
--  see @ref{E.2.1}.
@end format

@item
@format
pragma Storage_Size(expression);
--  see @ref{13.3}.
@end format

@item
@format
pragma Suppress(identifier [, [On =>] name]);
--  see @ref{11.5}.
@end format

@item
@format
pragma Task_Dispatching_Policy(policy_identifier );
--  see @ref{D.2.2}.
@end format

@item
@format
pragma Volatile(local_name);
--  see @ref{C.6}.
@end format

@item
@format
pragma Volatile_Components(array_local_name);
--  see @ref{C.6}.
@end format
@end enumerate

@c ===========================================================================
@node M, N, L, Top
@appendix  Implementation-Defined Characteristics (informative)

@enumerate
@item
The Ada language allows for certain machine dependences in a controlled
manner. Each Ada implementation must document all implementation-defined
characteristics:

@enumerate 2
@item
Whether or not each recommendation given in Implementation Advice is
followed. @xref{1.1.2,,1.1.2(37)}.

@item
Capacity limitations of the implementation. @xref{1.1.3,,1.1.3(3)}.

@item
Variations from the standard that are impractical to avoid given the
implementation's execution environment. @xref{1.1.3,,1.1.3(6)}.

@item
Which code_statements cause external interactions. @xref{1.1.3,,1.1.3(10)}.

@item
The coded representation for the text of an Ada program. @xref{2.1},
(4).

@item
The control functions allowed in comments. @xref{2.1,,2.1(14)}.

@item
The representation for an end of line. @xref{2.2,,2.2(2)}.

@item
Maximum supported line length and lexical element length. @xref{2.2},
(15).

@item
Implementation-defined pragmas. @xref{2.8,,2.8(14)}.

@item
Effect of pragma Optimize. @xref{2.8,,2.8(27)}.

@item
The sequence of characters of the value returned by S'Image when some of
the graphic characters of S'Wide_Image are not defined in Character.
@xref{3.5,,3.5(37)}.

@item
The predefined integer types declared in Standard. @xref{3.5.4,,3.5.4(25)}.

@item
Any nonstandard integer types and the operators defined for them.
@xref{3.5.4,,3.5.4(26)}.

@item
Any nonstandard real types and the operators defined for them.
@xref{3.5.6,,3.5.6(8)}.

@item
What combinations of requested decimal precision and range are supported
for floating point types. @xref{3.5.7,,3.5.7(7)}.

@item
The predefined floating point types declared in Standard. @xref{3.5.7},
(16).

@item
The small of an ordinary fixed point type. @xref{3.5.9,,3.5.9(8)}.

@item
What combinations of small, range, and digits are supported for fixed
point types. @xref{3.5.9,,3.5.9(10)}.

@item
The result of Tags.Expanded_Name for types declared within an unnamed
block_statement. @xref{3.9,,3.9(10)}.

@item
Implementation-defined attributes. @xref{4.1.4,,4.1.4(12)}.

@item
Any implementation-defined time types. @xref{9.6,,9.6(6)}.

@item
The time base associated with relative delays. @xref{9.6,,9.6(20)}.

@item
The time base of the type Calendar.Time. @xref{9.6,,9.6(23)}.

@item
The timezone used for package Calendar operations. @xref{9.6,,9.6(24)}.

@item
Any limit on delay_until_statements of select_statements. @xref{9.6},
(29).

@item
Whether or not two nonoverlapping parts of a composite object are
independently addressable, in the case where packing, record layout, or
Component_Size is specified for the object. @xref{9.10,,9.10(1)}.

@item
The representation for a compilation. @xref{10.1,,10.1(2)}.

@item
Any restrictions on compilations that contain multiple
compilation_units. @xref{10.1,,10.1(4)}.

@item
The mechanisms for creating an environment and for adding and replacing
compilation units. @xref{10.1.4,,10.1.4(3)}.

@item
The manner of explicitly assigning library units to a partition.
@xref{10.2,,10.2(2)}.

@item
The implementation-defined means, if any, of specifying which
compilation units are needed by a given compilation unit. @xref{10.2},
(2).

@item
The manner of designating the main subprogram of a partition.
@xref{10.2,,10.2(7)}.

@item
The order of elaboration of library_items. @xref{10.2,,10.2(18)}.

@item
Parameter passing and function return for the main subprogram.
@xref{10.2,,10.2(21)}.

@item
The mechanisms for building and running partitions. @xref{10.2,,10.2(24)}.

@item
The details of program execution, including program termination.
@xref{10.2,,10.2(25)}.

@item
The semantics of any nonactive partitions supported by the
implementation. @xref{10.2,,10.2(28)}.

@item
The information returned by Exception_Message. @xref{11.4.1,,11.4.1(10)}.

@item
The result of Exceptions.Exception_Name for types declared within an
unnamed block_statement. @xref{11.4.1,,11.4.1(12)}.

@item
The information returned by Exception_Information. @xref{11.4.1,,11.4.1(13)}.

@item
Implementation-defined check names. @xref{11.5,,11.5(27)}.

@item
The interpretation of each aspect of representation. @xref{13.1,,13.1(20)}.

@item
Any restrictions placed upon representation items. @xref{13.1,,13.1(20)}.

@item
The meaning of Size for indefinite subtypes. @xref{13.3,,13.3(48)}.

@item
The default external representation for a type tag. @xref{13.3,,13.3(75)}.

@item
What determines whether a compilation unit is the same in two different
partitions. @xref{13.3,,13.3(76)}.

@item
Implementation-defined components. @xref{13.5.1,,13.5.1(15)}.

@item
If Word_Size = Storage_Unit, the default bit ordering. @xref{13.5.3},
(5).

@item
The contents of the visible part of package System and its
language-defined children. @xref{13.7,,13.7(2)}.

@item
The contents of the visible part of package System.Machine_Code, and the
meaning of code_statements. @xref{13.8,,13.8(7)}.

@item
The effect of unchecked conversion. @xref{13.9,,13.9(11)}.

@item
The manner of choosing a storage pool for an access type when
Storage_Pool is not specified for the type. @xref{13.11,,13.11(17)}.

@item
Whether or not the implementation provides user-accessible names for the
standard pool type(s). @xref{13.11,,13.11(17)}.

@item
The meaning of Storage_Size. @xref{13.11,,13.11(18)}.

@item
Implementation-defined aspects of storage pools. @xref{13.11,,13.11(22)}.

@item
The set of restrictions allowed in a pragma Restrictions. @xref{13.12},
(7).

@item
The consequences of violating limitations on Restrictions pragmas.
@xref{13.12,,13.12(9)}.

@item
The representation used by the Read and Write attributes of elementary
types in terms of stream elements. @xref{13.13.2,,13.13.2(9)}.

@item
The names and characteristics of the numeric subtypes declared in the
visible part of package Standard. @xref{A.1,,A.1(3)}.

@item
The accuracy actually achieved by the elementary functions.
@xref{A.5.1,,A.5.1(1)}.

@item
The sign of a zero result from some of the operators or functions in
Numerics.Generic_Elementary_Functions, when Float_Type'Signed_Zeros is
True. @xref{A.5.1,,A.5.1(46)}.

@item
The value of Numerics.Float_Random.Max_Image_Width. @xref{A.5.2,,A.5.2(27)}.

@item
The value of Numerics.Discrete_Random.Max_Image_Width. @xref{A.5.2},
(27).

@item
The algorithms for random number generation. See  @xref{2,,2(32)}.

@item
The string representation of a random number generator's state.
@xref{A.5.2,,A.5.2(38)}.

@item
The minimum time interval between calls to the time-dependent Reset
procedure that are guaranteed to initiate different random number
sequences. @xref{A.5.2,,A.5.2(45)}.

@item
The values of the Model_Mantissa, Model_Emin, Model_Epsilon, Model,
Safe_First, and Safe_Last attributes, if the Numerics Annex is not
supported. @xref{A.5.3,,A.5.3(72)}.

@item
Any implementation-defined characteristics of the input-output packages.
@xref{A.7,,A.7(14)}.

@item
The value of Buffer_Size in Storage_IO. @xref{A.9,,A.9(10)}.

@item
external files for standard input, standard output, and standard error.
@xref{A.10,,A.10(5)}.

@item
The accuracy of the value produced by Put. @xref{A.10.9,,A.10.9(36)}.

@item
The meaning of Argument_Count, Argument, and Command_Name. @xref{A.15},
(1).

@item
Implementation-defined convention names. @xref{B.1,,B.1(11)}.

@item
The meaning of link names. @xref{B.1,,B.1(36)}.

@item
The manner of choosing link names when neither the link name nor the
address of an imported or exported entity is specified. @xref{ B.1},
(36).

@item
The effect of pragma Linker_Options. @xref{B.1,,B.1(37)}.

@item
The contents of the visible part of package Interfaces and its
language-defined descendants. @xref{B.2,,B.2(1)}.

@item
Implementation-defined children of package Interfaces. The contents of
the visible part of package Interfaces. @xref{11}.

@item
The types Floating, Long_Floating, Binary, Long_Binary, Decimal_Element,
and COBOL_Character; and the initializations of the variables
Ada_To_COBOL and COBOL_To_Ada, in Interfaces.COBOL  @xref{B.4,,B.4(50)}.

@item
Support for access to machine instructions. @xref{C.1,,C.1(1)}.

@item
Implementation-defined aspects of access to machine operations.
@xref{C.1,,C.1(9)}.

@item
Implementation-defined aspects of interrupts. @xref{C.3,,C.3(2)}.

@item
Implementation-defined aspects of preelaboration. @xref{C.4,,C.4(13)}.

@item
The semantics of pragma Discard_Names. @xref{C.5,,C.5(7)}.

@item
The result of the Task_Identification.Image attribute. @xref{C.7.1},
(7).

@item
The value of Current_Task when in a protected entry or interrupt
handler. @xref{C.7.1,,C.7.1(17)}.

@item
The effect of calling Current_Task from an entry body or interrupt
handler. @xref{C.7.1,,C.7.1(19)}.

@item
Implementation-defined aspects of Task_Attributes. @xref{C.7.2,,C.7.2(19)}.

@item
Values of all Metrics. @xref{D,,D(2)}.

@item
The declarations of Any_Priority and Priority. @xref{D.1,,D.1(11)}.

@item
Implementation-defined execution resources. @xref{D.1,,D.1(15)}.

@item
Whether, on a multiprocessor, a task that is waiting for access to a
protected object keeps its processor busy. @xref{D.2.1,,D.2.1(3)}.

@item
The affect of implementation defined execution resources on task
dispatching. @xref{D.2.1,,D.2.1(9)}.

@item
Implementation-defined policy_identifiers allowed in a pragma
Task_Dispatching_Policy. @xref{D.2.2,,D.2.2(3)}.

@item
Implementation-defined aspects of priority inversion. @xref{D.2.2},
(16).

@item
Implementation defined task dispatching. @xref{D.2.2,,D.2.2(18)}.

@item
Implementation-defined policy_identifiers allowed in a pragma
Locking_Policy. @xref{D.3,,D.3(4)}.

@item
Default ceiling priorities. @xref{D.3,,D.3(10)}.

@item
The ceiling of any protected object used internally by the
implementation. @xref{D.3,,D.3(16)}.

@item
Implementation-defined queuing policies. @xref{D.4,,D.4(1)}.

@item
On a multiprocessor, any conditions that cause the completion of an
aborted construct to be delayed later than what is specified for a
single processor. @xref{D.6,,D.6(3)}.

@item
Any operations that implicitly require heap storage allocation.
@xref{D.7,,D.7(8)}.

@item
Implementation-defined aspects of pragma Restrictions. @xref{D.7,,D.7(20)}.

@item
Implementation-defined aspects of package Real_Time. @xref{D.8,,D.8(17)}.

@item
Implementation-defined aspects of delay_statements. @xref{D.9,,D.9(8)}.

@item
The upper bound on the duration of interrupt blocking caused by the
implementation. @xref{D.12,,D.12(5)}.

@item
The means for creating and executing distributed programs. @xref{E},
(5).

@item
Any events that can result in a partition becoming inaccessible.
@xref{E.1,,E.1(7)}.

@item
The scheduling policies, treatment of priorities, and management of
shared resources between partitions in certain cases. @xref{E.1,,E.1(11)}.

@item
Events that cause the version of a compilation unit to change.
@xref{E.3,,E.3(5)}.

@item
Whether the execution of the remote subprogram is immediately aborted as
a result of cancellation. @xref{E.4,,E.4(13)}.

@item
Implementation-defined aspects of the PCS. @xref{E.5,,E.5(25)}.

@item
Implementation-defined interfaces in the PCS. @xref{E.5,,E.5(26)}.

@item
The values of named numbers in the package Decimal. @xref{F.2,,F.2(7)}.

@item
The value of Max_Picture_Length in the package Text_IO.Editing
@xref{F.3.3,,F.3.3(16)}.

@item
The value of Max_Picture_Length in the package Wide_Text_IO.Editing
@xref{F.3.4,,F.3.4(5)}.

@item
The accuracy actually achieved by the complex elementary functions and
by other complex arithmetic operations. @xref{G.1,,G.1(1)}.

@item
The sign of a zero result (or a component thereof) from any operator or
function in Numerics.Generic_Complex_Types, when Real'Signed_Zeros is
True. @xref{G.1.1,,G.1.1(53)}.

@item
The sign of a zero result (or a component thereof) from any operator or
function in Numerics.Generic_Complex_Elementary_Functions, when
Complex_Types.Real'Signed_Zeros is True. @xref{G.1.2,,G.1.2(45)}.

@item
Whether the strict mode or the relaxed mode is the default. @xref{G.2},
(2).

@item
The result interval in certain cases of fixed-to-float conversion.
@xref{G.2.1,,G.2.1(10)}.

@item
The result of a floating point arithmetic operation in overflow
situations, when the Machine_Overflows attribute of the result type is
False. @xref{G.2.1,,G.2.1(13)}.

@item
The result interval for division (or exponentiation by a negative
exponent), when the floating point hardware implements division as
multiplication by a reciprocal. @xref{G.2.1,,G.2.1(16)}.

@item
The definition of close result set, which determines the accuracy of
certain fixed point multiplications and divisions. @xref{G.2.3,,G.2.3(5)}.

@item
Conditions on a universal_real operand of a fixed point multiplication
or division for which the result shall be in the perfect result set.
@xref{G.2.3,,G.2.3(22)}.

@item
The result of a fixed point arithmetic operation in overflow situations,
when the Machine_Overflows attribute of the result type is False.
@xref{G.2.3,,G.2.3(27)}.

@item
The result of an elementary function reference in overflow situations,
when the Machine_Overflows attribute of the result type is False.
@xref{G.2.4,,G.2.4(4)}.

@item
The value of the angle threshold, within which certain elementary
functions, complex arithmetic operations, and complex elementary
functions yield results conforming to a maximum relative error bound.
@xref{G.2.4,,G.2.4(10)}.

@item
The accuracy of certain elementary functions for parameters beyond the
angle threshold. @xref{G.2.4,,G.2.4(10)}.

@item
The result of a complex arithmetic operation or complex elementary
function reference in overflow situations, when the Machine_Overflows
attribute of the corresponding real type is False. @xref{G.2.6,,G.2.6(5)}.

@item
The accuracy of certain complex arithmetic operations and certain
complex elementary functions for parameters (or components thereof)
beyond the angle threshold. @xref{G.2.6,,G.2.6(8)}.

@item
Information regarding bounded errors and erroneous execution.
@xref{H.2,,H.2(1)}.

@item
Implementation-defined aspects of pragma Inspection_Point. @xref{H.3.2},
(8).

@item
Implementation-defined aspects of pragma Restrictions. @xref{H.4,,H.4(25)}.

@item
Any restrictions on pragma Restrictions. @xref{H.4,,H.4(27)}.
@end enumerate
@end enumerate

@c ===========================================================================
@node N, P, M, Top
@appendix  Glossary (informative)

@enumerate
@item
This Annex contains informal descriptions of some terms used in this
International Standard. To find more formal definitions, look the term
up in the index.

@item
@strong{Access type}. An access type has values that designate aliased
objects. Access types correspond to ``pointer types'' or ``reference
types'' in some other languages.

@item
@strong{Aliased}. An aliased view of an object is one that can be
designated by an access value. Objects allocated by allocators are
aliased. Objects can also be explicitly declared as aliased with the
reserved word aliased. The Access attribute can be used to create an
access value designating an aliased object.

@item
@strong{Array type}. An array type is a composite type whose components
are all of the same type. Components are selected by indexing.

@item
@strong{Character type}. A character type is an enumeration type whose
values include characters.

@item
@strong{Class}. A class is a set of types that is closed under
derivation, which means that if a given type is in the class, then all
types derived from that type are also in the class. The set of types of
a class share common properties, such as their primitive operations.

@item
@strong{Compilation unit}. The text of a program can be submitted to the
compiler in one or more compilations. Each compilation is a succession
of compilation_units. A compilation_unit contains either the
declaration, the body, or a renaming of a program unit.

@item
@strong{Composite type}. A composite type has components.

@item
@strong{Construct}. A construct is a piece of text (explicit or
implicit) that is an instance of a syntactic category defined under
``Syntax.''

@item
@strong{Controlled type}. A controlled type supports user-defined
assignment and finalization. Objects are always finalized before being
destroyed.

@strong{Declaration}. A declaration is a language construct that
associates a name with (a view of) an entity. A declaration may appear
explicitly in the program text (an explicit declaration), or may be
supposed to occur at a given place in the text as a consequence of the
semantics of another construct (an implicit declaration).

@item
@strong{Definition}. All declarations contain a definition for a view of
an entity. A view consists of an identification of the entity (the
entity of the view), plus view-specific characteristics that affect the
use of the entity through that view (such as mode of access to an
object, formal parameter names and defaults for a subprogram, or
visibility to components of a type). In most cases, a declaration also
contains the definition for the entity itself (a renaming_declaration is
an example of a declaration that does not define a new entity, but
instead defines a view of an existing entity, see @ref{8.5}.

@item
@strong{Derived type}. A derived type is a type defined in terms of
another type, which is the parent type of the derived type. Each class
containing the parent type also contains the derived type. The derived
type inherits properties such as components and primitive operations
from the parent. A type together with the types derived from it
(directly or indirectly) form a derivation class.

@item
@strong{Discrete type}. A discrete type is either an integer type or an
enumeration type. Discrete types may be used, for example, in
case_statements and as array indices.

@item
@strong{Discriminant}. A discriminant is a parameter of a composite
type. It can control, for example, the bounds of a component of the type
if that type is an array type. A discriminant of a task type can be used
to pass data to a task of the type upon creation.

@item
@strong{Elementary type}. An elementary type does not have components.

@item
@strong{Enumeration type}. An enumeration type is defined by an
enumeration of its values, which may be named by identifiers or
character literals.

@item
@strong{Exception}. An exception represents a kind of exceptional
situation; an occurrence of such a situation (at run time) is called an
exception occurrence. To raise an exception is to abandon normal program
execution so as to draw attention to the fact that the corresponding
situation has arisen. Performing some actions in response to the arising
of an exception is called handling the exception.

@item
@strong{Execution}. The process by which a construct achieves its
run-time effect is called execution. Execution of a declaration is also
called elaboration. Execution of an expression is also called
evaluation.

@item
@strong{Generic unit}. A generic unit is a template for a (nongeneric)
program unit; the template can be parameterized by objects, types,
subprograms, and packages. An instance of a generic unit is created by a
generic_instantiation. The rules of the language are enforced when a
generic unit is compiled, using a generic contract model; additional
checks are performed upon instantiation to verify the contract is met.
That is, the declaration of a generic unit represents a contract between
the body of the generic and instances of the generic. Generic units can
be used to perform the role that macros sometimed play in other
languages.

@item
@strong{Integer type}. Integer types comprise the signed integer types
and the modular types. A signed integer type has a base range that
includes both positive and negative numbers, and has operations that may
raise an exception when the result is outside the base range. A modular
type has a base range whose lower bound is zero, and has operations with
``wraparound'' semantics. Modular types subsume what are called
``unsigned types'' in some other languages.

@item
@strong{Library unit}. A library unit is a separately compiled program
unit, and is always a package, subprogram, or generic unit. Library
units may have other (logically nested) library units as children, and
may have other program units physically nested within them. A root
library unit, together with its children and grandchildren and so on,
form a subsystem.

@item
@strong{Limited type}. A limited type is (a view of) a type for which
the assignment operation is not allowed. A nonlimited type is a (view of
a) type for which the assignment operation is allowed.

@item
@strong{Object}. An object is either a constant or a variable. An object
contains a value. An object is created by an object_declaration or by an
allocator. A formal parameter is (a view of) an object. A subcomponent
of an object is an object.

@item
@strong{Package}. Packages are program units that allow the
specification of groups of logically related entities. Typically, a
package contains the declaration of a type (often a private type or
private extension) along with the declarations of primitive subprograms
of the type, which can be called from outside the package, while their
inner workings remain hidden from outside users.

@item
@strong{Partition}. A partition is a part of a program. Each partition
consists of a set of library units. Each partition may run in a separate
address space, possibly on a separate computer. A program may contain
just one partition. A distributed program typically contains multiple
partitions, which can execute concurrently.

@item
@strong{Pragma}. A pragma is a compiler directive. There are
language-defined pragmas that give instructions for optimization,
listing control, etc. An implementation may support additional
(implementation-defined) pragmas.

@item
@strong{Primitive operations}. The primitive operations of a type are
the operations (such as subprograms) declared together with the type
declaration. They are inherited by other types in the same class of
types. For a tagged type, the primitive subprograms are dispatching
subprograms, providing run-time polymorphism. A dispatching subprogram
may be called with statically tagged operands, in which case the
subprogram body invoked is determined at compile time. Alternatively, a
dispatching subprogram may be called using a dispatching call, in which
case the subprogram body invoked is determined at run time.

@item
@strong{Private extension}. A private extension is like a record
extension, except that the components of the extension part are hidden
from its clients.

@item
@strong{Private type}. A private type is a partial view of a type whose
full view is hidden from its clients.

@item
@strong{Program unit}. A program unit is either a package, a task unit,
a protected unit, a protected entry, a generic unit, or an explicitly
declared subprogram other than an enumeration literal. Certain kinds of
program units can be separately compiled. Alternatively, they can appear
physically nested within other program units.

@item
@strong{Program}. A program is a set of partitions, each of which may
execute in a separate address space, possibly on a separate computer. A
partition consists of a set of library units.

@item
@strong{Protected type}. A protected type is a composite type whose
components are protected from concurrent access by multiple tasks.

@item
@strong{Real type}. A real type has values that are approximations of
the real numbers. Floating point and fixed point types are real types.

@item
@strong{Record extension}. A record extension is a type that extends
another type by adding additional components.

@item
@strong{Record type}. A record type is a composite type consisting of
zero or more named components, possibly of different types.

@item
@strong{Scalar type}. A scalar type is either a discrete type or a real
type.

@item
@strong{Subtype}. A subtype is a type together with a constraint, which
constrains the values of the subtype to satisfy a certain condition. The
values of a subtype are a subset of the values of its type.

@item
@strong{Tagged type}. The objects of a tagged type have a run-time type
tag, which indicates the specific type with which the object was
originally created. An operand of a class-wide tagged type can be used
in a dispatching call; the tag indicates which subprogram body to
invoke. Nondispatching calls, in which the subprogram body to invoke is
determined at compile time, are also allowed. Tagged types may be
extended with additional components.

@item
@strong{Task type}. A task type is a composite type whose values are
tasks, which are active entities that may execute concurrently with
other tasks. The top-level task of a partition is called the environment
task.

@item
@strong{Type}. Each object has a type. A type has an associated set of
values, and a set of primitive operations which implement the
fundamental aspects of its semantics. Types are grouped into classes.
The types of a given class share a set of primitive operations. Classes
are closed under derivation; that is, if a type is in a class, then all
of its derivatives are in that class.

@item
@strong{View}. (See Definition.)
@end enumerate

@c ===========================================================================
@node P, Index, N, Top
@appendix  Syntax Summary (informative)

@enumerate
@item
This Annex summarizes the complete syntax of the language. @ref{1.1.4},
for a description of the notation used.

@format
@ref{2.1}
character ::=
     graphic_character
   | format_effector
   | other_control_function

@ref{2.1}
graphic_character ::=
     identifier_letter
   | digit
   | space_character
   | special_character

@ref{2.3}
identifier ::= identifier_letter @{[underline] letter_or_digit@}

@ref{2.3}
letter_or_digit ::= identifier_letter | digit

@ref{2.4}
numeric_literal ::= decimal_literal | based_literal

@ref{2.4.1}
decimal_literal ::= numeral [.numeral] [exponent]

@ref{2.4.1}
numeral ::= digit @{[underline] digit@}

@ref{2.4.1}
exponent ::= E [+] numeral | E - numeral

@ref{2.4.2}
based_literal ::= base # based_numeral [.based_numeral] # [exponent]

@ref{2.4.2}
base ::= numeral

@ref{2.4.2}
based_numeral ::= extended_digit @{[underline] extended_digit@}

@ref{2.4.2}
extended_digit ::= digit | A | B | C | D | E | F

@ref{2.5}
character_literal ::= 'graphic_character'

@ref{2.6}
string_literal ::= "@{string_element@}"

@ref{2.6}
string_element ::= "" | non_quotation_mark_graphic_character

A string_element is either a pair of quotation marks (""), or a
single graphic_character other than a quotation mark.

@ref{2.7}
comment ::= --@{non_end_of_line_character@}

@ref{2.8}
pragma ::=
   pragma identifier [(pragma_argument_association
      @{, pragma_argument_association@})];

@ref{2.8}
pragma_argument_association ::=
     [pragma_argument_identifier =>] name
   | [pragma_argument_identifier =>] expression

@ref{3.1}
basic_declaration ::=
     type_declaration         | subtype_declaration
   | object_declaration       | number_declaration
   | subprogram_declaration   | abstract_subprogram_declaration
   | package_declaration      | renaming_declaration
   | exception_declaration    | generic_declaration
   | generic_instantiation

@ref{3.1}
defining_identifier ::= identifier

@ref{3.2.1}
type_declaration ::=
     full_type_declaration
   | incomplete_type_declaration
   | private_type_declaration
   | private_extension_declaration

@ref{3.2.1}
full_type_declaration ::=
     type defining_identifier [known_discriminant_part]
       is type_definition;
   | task_type_declaration
   | protected_type_declaration

@ref{3.2.1}
type_definition ::=
     enumeration_type_definition | integer_type_definition
   | real_type_definition        | array_type_definition
   | record_type_definition      | access_type_definition
   | derived_type_definition

@ref{3.2.2}
subtype_declaration ::=
   subtype defining_identifier is subtype_indication;

@ref{3.2.2}
subtype_indication ::=  subtype_mark [constraint]

@ref{3.2.2}
subtype_mark ::= subtype_name

@ref{3.2.2}
constraint ::= scalar_constraint | composite_constraint

@ref{3.2.2}
scalar_constraint ::=
   range_constraint | digits_constraint | delta_constraint

@ref{3.2.2}
composite_constraint ::=
   index_constraint | discriminant_constraint

@ref{3.3.1}
object_declaration ::=
    defining_identifier_list : [aliased] [constant]
      subtype_indication [:= expression];
  | defining_identifier_list : [aliased] [constant]
      array_type_definition [:= expression];
  | single_task_declaration
  | single_protected_declaration

@ref{3.3.1}
defining_identifier_list ::=
   defining_identifier @{, defining_identifier@}

@ref{3.3.2}
number_declaration ::=
   defining_identifier_list : constant := static_expression;

@ref{3.4}
derived_type_definition ::= [abstract] new
  parent_subtype_indication [record_extension_part]

@ref{3.5}
range_constraint ::= range range

@ref{3.5}
range ::=
     range_attribute_reference
   | simple_expression .. simple_expression

@ref{3.5.1}
enumeration_type_definition ::=
   (enumeration_literal_specification
     @{, enumeration_literal_specification@})

@ref{3.5.1}
enumeration_literal_specification ::=
   defining_identifier | defining_character_literal

@ref{3.5.1}
defining_character_literal ::= character_literal

@ref{3.5.4}
integer_type_definition ::=
   signed_integer_type_definition | modular_type_definition

@ref{3.5.4}
signed_integer_type_definition ::=
   range static_simple_expression .. static_simple_expression

@ref{3.5.4}
modular_type_definition ::= mod static_expression

@ref{3.5.6}
real_type_definition ::=
   floating_point_definition | fixed_point_definition

@ref{3.5.7}
floating_point_definition ::=
   digits static_expression [real_range_specification]

@ref{3.5.7}
real_range_specification ::=
   range static_simple_expression .. static_simple_expression

@ref{3.5.9}
fixed_point_definition ::=
   ordinary_fixed_point_definition | decimal_fixed_point_definition

@ref{3.5.9}
ordinary_fixed_point_definition ::=
   delta static_expression real_range_specification

@ref{3.5.9}
decimal_fixed_point_definition ::=
   delta static_expression digits static_expression
     [real_range_specification]

@ref{3.5.9}
digits_constraint ::=
   digits static_expression [range_constraint]

@ref{3.6}
array_type_definition ::=
   unconstrained_array_definition | constrained_array_definition

@ref{3.6}
unconstrained_array_definition ::=
   array(index_subtype_definition @{, index_subtype_definition@})
     of component_definition

@ref{3.6}
index_subtype_definition ::= subtype_mark range <>

@ref{3.6}
constrained_array_definition ::=
   array (discrete_subtype_definition
     @{, discrete_subtype_definition@}) of component_definition

@ref{3.6}
discrete_subtype_definition ::= discrete_subtype_indication | range

@ref{3.6}
component_definition ::= [aliased] subtype_indication

@ref{3.6.1}
index_constraint ::= (discrete_range @{, discrete_range@})

@ref{3.6.1}
discrete_range ::= discrete_subtype_indication | range

@ref{3.7}
discriminant_part ::=
   unknown_discriminant_part | known_discriminant_part

@ref{3.7}
unknown_discriminant_part ::= (<>)

@ref{3.7}
known_discriminant_part ::=
   (discriminant_specification @{; discriminant_specification@})

@ref{3.7}
discriminant_specification ::=
     defining_identifier_list : subtype_mark
       [:= default_expression]
   | defining_identifier_list : access_definition
       [:= default_expression]

@ref{3.7}
default_expression ::= expression

@ref{3.7.1}
discriminant_constraint ::=
   (discriminant_association @{, discriminant_association@})

@ref{3.7.1}
discriminant_association ::=
   [discriminant_selector_name
     @{| discriminant_selector_name@} =>] expression

@ref{3.8}
record_type_definition ::=
   [[abstract] tagged] [limited] record_definition

@ref{3.8}
record_definition ::=
     record
        component_list
     end record
   | null record

@ref{3.8}
component_list ::=
     component_item @{component_item@}
   | @{component_item@} variant_part
   |  null;

@ref{3.8}
component_item ::= component_declaration | representation_clause

@ref{3.8}
component_declaration ::=
   defining_identifier_list : component_definition
     [:= default_expression];

@ref{3.8.1}
variant_part ::=
   case discriminant_direct_name is
      variant
      @{variant@}
   end case;

@ref{3.8.1}
variant ::=
   when discrete_choice_list =>
      component_list

@ref{3.8.1}
discrete_choice_list ::= discrete_choice @{| discrete_choice@}

@ref{3.8.1}
discrete_choice ::= expression | discrete_range | others

@ref{3.9.1}
record_extension_part ::= with record_definition

@ref{3.10}
access_type_definition ::=
     access_to_object_definition
   | access_to_subprogram_definition

@ref{3.10}
access_to_object_definition ::=
    access [general_access_modifier] subtype_indication

@ref{3.10}
general_access_modifier ::= all | constant

@ref{3.10}
access_to_subprogram_definition ::=
     access [protected] procedure parameter_profile
   | access [protected] function  parameter_and_result_profile

@ref{3.10}
access_definition ::= access subtype_mark

@ref{3.10.1}
incomplete_type_declaration ::=
   type defining_identifier [discriminant_part];

@ref{3.11}
declarative_part ::= @{declarative_item@}

@ref{3.11}
declarative_item ::= basic_declarative_item | body

@ref{3.11}
basic_declarative_item ::=
   basic_declaration | representation_clause | use_clause

@ref{3.11}
body ::= proper_body | body_stub

@ref{3.11}
proper_body ::=
   subprogram_body | package_body | task_body | protected_body

@ref{4.1}
name ::=
     direct_name                | explicit_dereference
   | indexed_component          | slice
   | selected_component         | attribute_reference
   | type_conversion            | function_call
   | character_literal

@ref{4.1}
direct_name ::= identifier | operator_symbol

@ref{4.1}
prefix ::= name | implicit_dereference

@ref{4.1}
explicit_dereference ::= name.all

@ref{4.1}
implicit_dereference ::= name

@ref{4.1.1}
indexed_component ::= prefix(expression @{, expression@})

@ref{4.1.2}
slice ::= prefix(discrete_range)

@ref{4.1.3}
selected_component ::= prefix . selector_name

@ref{4.1.3}
selector_name ::= identifier | character_literal | operator_symbol

@ref{4.1.4}
attribute_reference ::= prefix'attribute_designator

@ref{4.1.4}
attribute_designator ::=
     identifier[(static_expression)]
   | Access | Delta | Digits

@ref{4.1.4}
range_attribute_reference ::= prefix'range_attribute_designator

@ref{4.1.4}
range_attribute_designator ::= Range[(static_expression)]

@ref{4.3}
aggregate ::=
   record_aggregate | extension_aggregate | array_aggregate

@ref{4.3.1}
record_aggregate ::= (record_component_association_list)

@ref{4.3.1}
record_component_association_list ::=
     record_component_association @{, record_component_association@}
   | null record

@ref{4.3.1}
record_component_association ::=
   [ component_choice_list => ] expression

@ref{4.3.1}
component_choice_list ::=
     component_selector_name @{| component_selector_name@}
   | others

@ref{4.3.2}
extension_aggregate ::=
(ancestor_part with record_component_association_list)

@ref{4.3.2}
ancestor_part ::= expression | subtype_mark

@ref{4.3.3}
array_aggregate ::=
   positional_array_aggregate | named_array_aggregate

@ref{4.3.3}
positional_array_aggregate ::=
     (expression, expression @{, expression@})
   | (expression @{, expression@}, others => expression)

@ref{4.3.3}
named_array_aggregate ::=
   (array_component_association @{, array_component_association@})

@ref{4.3.3}
array_component_association ::=
   discrete_choice_list => expression

@ref{4.4}
expression ::=
     relation @{and relation@} | relation @{and then relation@}
   | relation @{or relation@}  | relation @{or else relation@}
   | relation @{xor relation@}

@ref{4.4}
relation ::=
     simple_expression [relational_operator simple_expression]
   | simple_expression [not] in range
   | simple_expression [not] in subtype_mark

@ref{4.4}
simple_expression ::=
   [unary_adding_operator] term @{binary_adding_operator term@}

@ref{4.4}
term ::= factor @{multiplying_operator factor@}

@ref{4.4}
factor ::= primary [** primary] | abs primary | not primary

@ref{4.4}
primary ::=
     numeric_literal   | null
   | string_literal    | aggregate
   | name              | qualified_expression
   | allocator         | (expression)

@ref{4.5}
logical_operator             ::=  and | or  | xor

@ref{4.5}
relational_operator          ::=  =   | /=  | <   | <= | > | >=

@ref{4.5}
binary_adding_operator       ::=  +   | -   | &

@ref{4.5}
unary_adding_operator        ::=  +   | -

@ref{4.5}
multiplying_operator         ::=  *   | /   | mod | rem

@ref{4.5}
highest_precedence_operator  ::=  **  | abs | not

@ref{4.6}
type_conversion ::=
     subtype_mark(expression)
   | subtype_mark(name)

@ref{4.7}
qualified_expression ::=
   subtype_mark'(expression) | subtype_mark'aggregate

@ref{4.8}
allocator ::=
   new subtype_indication | new qualified_expression

@ref{5.1}
sequence_of_statements ::= statement @{statement@}

@ref{5.1}
statement ::=
   @{label@} simple_statement | @{label@} compound_statement

@ref{5.1}
simple_statement ::= null_statement
   | assignment_statement   | exit_statement
   | goto_statement         | procedure_call_statement
   | return_statement       | entry_call_statement
   | requeue_statement      | delay_statement
   | abort_statement        | raise_statement
   | code_statement

@ref{5.1}
compound_statement ::=
     if_statement           | case_statement
   | loop_statement         | block_statement
   | accept_statement       | select_statement

@ref{5.1}
null_statement ::= null;

@ref{5.1}
label ::= <<label_statement_identifier>>

@ref{5.1}
statement_identifier ::= direct_name

@ref{5.2}
assignment_statement ::= variable_name := expression;

@ref{5.3}
if_statement ::=
   if condition then
      sequence_of_statements
   @{elsif condition then
      sequence_of_statements@}
   [else
      sequence_of_statements]
   end if;

@ref{5.3}
condition ::= boolean_expression

@ref{5.4}
case_statement ::=
   case expression is
      case_statement_alternative
      @{case_statement_alternative@}
   end case;

@ref{5.4}
case_statement_alternative ::=
   when discrete_choice_list =>
      sequence_of_statements

@ref{5.5}
loop_statement ::=
   [loop_statement_identifier:]
      [iteration_scheme] loop
         sequence_of_statements
      end loop [loop_identifier];

@ref{5.5}
iteration_scheme ::= while condition
   | for loop_parameter_specification

@ref{5.5}
loop_parameter_specification ::=
   defining_identifier in [reverse] discrete_subtype_definition

@ref{5.6}
block_statement ::=
   [block_statement_identifier:]
      [declare
         declarative_part]
      begin
         handled_sequence_of_statements
      end [block_identifier];

@ref{5.7}
exit_statement ::= exit [loop_name] [when condition];

@ref{5.8}
goto_statement ::= goto label_name;

@ref{6.1}
subprogram_declaration ::= subprogram_specification;

@ref{6.1}
abstract_subprogram_declaration ::= subprogram_specification is abstract;

@ref{6.1}
subprogram_specification ::=
     procedure defining_program_unit_name parameter_profile
   | function defining_designator parameter_and_result_profile

@ref{6.1}
designator ::= [parent_unit_name . ]identifier | operator_symbol

@ref{6.1}
defining_designator ::=
   defining_program_unit_name | defining_operator_symbol

@ref{6.1}
defining_program_unit_name ::=
   [parent_unit_name . ]defining_identifier

@ref{6.1}
operator_symbol ::= string_literal

@ref{6.1}
defining_operator_symbol ::= operator_symbol

@ref{6.1}
parameter_profile ::= [formal_part]

@ref{6.1}
parameter_and_result_profile ::= [formal_part] return subtype_mark

@ref{6.1}
formal_part ::=
   (parameter_specification @{; parameter_specification@})

@ref{6.1}
parameter_specification ::=
     defining_identifier_list : mode subtype_mark
       [:= default_expression]
   | defining_identifier_list : access_definition
       [:= default_expression]

@ref{6.1}
mode ::= [in] | in out | out

@ref{6.3}
subprogram_body ::=
   subprogram_specification is
      declarative_part
   begin
      handled_sequence_of_statements
   end [designator];

@ref{6.4}
procedure_call_statement ::=
     procedure_name;
   | procedure_prefix actual_parameter_part;

@ref{6.4}
function_call ::=
     function_name
   | function_prefix actual_parameter_part

@ref{6.4}
actual_parameter_part ::=
   (parameter_association @{, parameter_association@})

@ref{6.4}
parameter_association ::=
   [formal_parameter_selector_name =>] explicit_actual_parameter

@ref{6.4}
explicit_actual_parameter ::= expression | variable_name

@ref{6.5}
return_statement ::= return [expression];

@ref{7.1}
package_declaration ::= package_specification;

@ref{7.1}
package_specification ::=
   package defining_program_unit_name is
      @{basic_declarative_item@}
   [private
      @{basic_declarative_item@}]
   end [[parent_unit_name.]identifier]

@ref{7.2}
package_body ::=
   package body defining_program_unit_name is
      declarative_part
   [begin
      handled_sequence_of_statements]
   end [[parent_unit_name.]identifier];

@ref{7.3}
private_type_declaration ::=
   type defining_identifier [discriminant_part] is
     [[abstract] tagged] [limited] private;

@ref{7.3}
private_extension_declaration ::=
   type defining_identifier [discriminant_part] is
     [abstract] new ancestor_subtype_indication with private;

@ref{8.4}
use_clause ::= use_package_clause | use_type_clause

@ref{8.4}
use_package_clause ::= use package_name @{, package_name@};

@ref{8.4}
use_type_clause ::= use type subtype_mark @{, subtype_mark@};

@ref{8.5}
renaming_declaration ::=
      object_renaming_declaration
    | exception_renaming_declaration
    | package_renaming_declaration
    | subprogram_renaming_declaration
    | generic_renaming_declaration

@ref{8.5.1}
object_renaming_declaration ::=
   defining_identifier : subtype_mark renames object_name;

@ref{8.5.2}
exception_renaming_declaration ::=
   defining_identifier : exception renames exception_name;

@ref{8.5.3}
package_renaming_declaration ::=
   package defining_program_unit_name renames package_name;

@ref{8.5.4}
subprogram_renaming_declaration ::=
   subprogram_specification renames callable_entity_name;

@ref{8.5.5}
generic_renaming_declaration ::=
     generic package defining_program_unit_name renames
       generic_package_name;
   | generic procedure defining_program_unit_name renames
       generic_procedure_name;
   | generic function defining_program_unit_name renames
       generic_function_name;

@ref{9.1}
task_type_declaration ::=
   task type defining_identifier [known_discriminant_part]
     [is task_definition];

@ref{9.1}
single_task_declaration ::=
   task defining_identifier [is task_definition];

@ref{9.1}
task_definition ::=
      @{task_item@}
   [ private
      @{task_item@}]
   end [task_identifier]

@ref{9.1}
task_item ::= entry_declaration | representation_clause

@ref{9.1}
task_body ::=
   task body defining_identifier is
      declarative_part
   begin
      handled_sequence_of_statements
   end [task_identifier];

@ref{9.4}
protected_type_declaration ::=
   protected type defining_identifier [known_discriminant_part] is
     protected_definition;

@ref{9.4}
single_protected_declaration ::=
   protected defining_identifier is protected_definition;

@ref{9.4}
protected_definition ::=
      @{ protected_operation_declaration @}
   [ private
      @{ protected_element_declaration @} ]
   end [protected_identifier]

@ref{9.4}
protected_operation_declaration ::=
     subprogram_declaration
   | entry_declaration
   | representation_clause

@ref{9.4}
protected_element_declaration ::=
   protected_operation_declaration | component_declaration

@ref{9.4}
protected_body ::=
   protected body defining_identifier is
      @{ protected_operation_item @}
   end [protected_identifier];

@ref{9.4}
protected_operation_item ::=
     subprogram_declaration
   | subprogram_body
   | entry_body
   | representation_clause

@ref{9.5.2}
entry_declaration ::=
   entry defining_identifier [(discrete_subtype_definition)]
     parameter_profile;

@ref{9.5.2}
accept_statement ::=
   accept entry_direct_name [(entry_index)] parameter_profile [do
      handled_sequence_of_statements
   end [entry_identifier]];

@ref{9.5.2}
entry_index ::= expression

@ref{9.5.2}
entry_body ::=
   entry defining_identifier entry_body_formal_part entry_barrier is
      declarative_part
   begin
      handled_sequence_of_statements
   end [entry_identifier];

@ref{9.5.2}
entry_body_formal_part ::=
   [(entry_index_specification)] parameter_profile

@ref{9.5.2}
entry_barrier ::= when condition

@ref{9.5.2}
entry_index_specification ::=
   for defining_identifier in discrete_subtype_definition

@ref{9.5.3}
entry_call_statement ::= entry_name [actual_parameter_part];

@ref{9.5.4}
requeue_statement ::= requeue entry_name [with abort];

@ref{9.6}
delay_statement ::= delay_until_statement | delay_relative_statement

@ref{9.6}
delay_until_statement ::= delay until delay_expression;

@ref{9.6}
delay_relative_statement ::= delay delay_expression;

@ref{9.7}
select_statement ::=
     selective_accept
   | timed_entry_call
   | conditional_entry_call
   | asynchronous_select

@ref{9.7.1}
selective_accept ::=
   select
      [guard]
      select_alternative
   @{ or
      [guard]
      select_alternative @}
   [ else
      sequence_of_statements ]
  end select;

@ref{9.7.1}
guard ::= when condition =>

@ref{9.7.1}
select_alternative ::=
     accept_alternative
   | delay_alternative
   | terminate_alternative

@ref{9.7.1}
accept_alternative ::=
accept_statement [sequence_of_statements]

@ref{9.7.1}
delay_alternative ::=
delay_statement [sequence_of_statements]

@ref{9.7.1}
terminate_alternative ::= terminate;

@ref{9.7.2}
timed_entry_call ::=
   select
      entry_call_alternative
   or
      delay_alternative
   end select;

@ref{9.7.2}
entry_call_alternative ::=
   entry_call_statement [sequence_of_statements]

@ref{9.7.3}
conditional_entry_call ::=
   select
      entry_call_alternative
   else
      sequence_of_statements
   end select;

@ref{9.7.4}
asynchronous_select ::=
   select
      triggering_alternative
   then abort
      abortable_part
   end select;

@ref{9.7.4}
triggering_alternative ::=
   triggering_statement [sequence_of_statements]

@ref{9.7.4}
triggering_statement ::= entry_call_statement | delay_statement

@ref{9.7.4}
abortable_part ::= sequence_of_statements

@ref{9.8}
abort_statement ::= abort task_name @{, task_name@};

@ref{10.1.1}
compilation ::= @{compilation_unit@}

@ref{10.1.1}
compilation_unit ::=
     context_clause library_item
   | context_clause subunit

@ref{10.1.1}
library_item ::= [private] library_unit_declaration
   | library_unit_body
   | [private] library_unit_renaming_declaration

@ref{10.1.1}
library_unit_declaration ::=
     subprogram_declaration | package_declaration
   | generic_declaration    | generic_instantiation

@ref{10.1.1}
library_unit_renaming_declaration ::=
     package_renaming_declaration
   | generic_renaming_declaration
   | subprogram_renaming_declaration

@ref{10.1.1}
library_unit_body ::= subprogram_body | package_body

@ref{10.1.1}
parent_unit_name ::= name

@ref{10.1.2}
context_clause ::= @{context_item@}

@ref{10.1.2}
context_item ::= with_clause | use_clause

@ref{10.1.2}
with_clause ::= with library_unit_name @{, library_unit_name@};

@ref{10.1.3}
body_stub ::=
     subprogram_body_stub
   | package_body_stub
   | task_body_stub
   | protected_body_stub

@ref{10.1.3}
subprogram_body_stub ::= subprogram_specification is separate;

@ref{10.1.3}
package_body_stub ::= package body defining_identifier is separate;

@ref{10.1.3}
task_body_stub ::= task body defining_identifier is separate;

@ref{10.1.3}
protected_body_stub ::=
   protected body defining_identifier is separate;

@ref{10.1.3}
subunit ::= separate (parent_unit_name) proper_body

@ref{11.1}
exception_declaration ::= defining_identifier_list : exception;

@ref{11.2}
handled_sequence_of_statements ::=
      sequence_of_statements
   [exception
      exception_handler
      @{exception_handler@}]

@ref{11.2}
exception_handler ::=
  when [choice_parameter_specification:] exception_choice
    @{| exception_choice@} =>
     sequence_of_statements

@ref{11.2}
choice_parameter_specification ::= defining_identifier

@ref{11.2}
exception_choice ::= exception_name | others

@ref{11.3}
raise_statement ::= raise [exception_name];

@ref{12.1}
generic_declaration ::=
   generic_subprogram_declaration | generic_package_declaration

@ref{12.1}
generic_subprogram_declaration ::=
   generic_formal_part subprogram_specification;

@ref{12.1}
generic_package_declaration ::=
   generic_formal_part package_specification;

@ref{12.1}
generic_formal_part ::=
   generic @{generic_formal_parameter_declaration | use_clause@}

@ref{12.1}
generic_formal_parameter_declaration ::=
      formal_object_declaration
    | formal_type_declaration
    | formal_subprogram_declaration
    | formal_package_declaration

@ref{12.3}
generic_instantiation ::=
     package defining_program_unit_name is
       new generic_package_name [generic_actual_part];
   | procedure defining_program_unit_name is
       new generic_procedure_name [generic_actual_part];
   | function defining_designator is
       new generic_function_name [generic_actual_part];

@ref{12.3}
generic_actual_part ::=
   (generic_association @{, generic_association@})

@ref{12.3}
generic_association ::=
   [generic_formal_parameter_selector_name =>]
     explicit_generic_actual_parameter

@ref{12.3}
explicit_generic_actual_parameter ::= expression | variable_name
   | subprogram_name | entry_name | subtype_mark
   | package_instance_name

@ref{12.4}
formal_object_declaration ::=
   defining_identifier_list : mode subtype_mark
     [:= default_expression];

@ref{12.5}
formal_type_declaration ::=
   type defining_identifier[discriminant_part] is
     formal_type_definition;

@ref{12.5}
formal_type_definition ::=
     formal_private_type_definition
   | formal_derived_type_definition
   | formal_discrete_type_definition
   | formal_signed_integer_type_definition
   | formal_modular_type_definition
   | formal_floating_point_definition
   | formal_ordinary_fixed_point_definition
   | formal_decimal_fixed_point_definition
   | formal_array_type_definition
   | formal_access_type_definition

@ref{12.5.1}
formal_private_type_definition ::=
   [[abstract] tagged] [limited] private

@ref{12.5.1}
formal_derived_type_definition ::=
   [abstract] new subtype_mark [with private]

@ref{12.5.2}
formal_discrete_type_definition ::= (<>)

@ref{12.5.2}
formal_signed_integer_type_definition ::= range <>

@ref{12.5.2}
formal_modular_type_definition ::= mod <>

@ref{12.5.2}
formal_floating_point_definition ::= digits <>

@ref{12.5.2}
formal_ordinary_fixed_point_definition ::= delta <>

@ref{12.5.2}
formal_decimal_fixed_point_definition ::= delta <> digits <>

@ref{12.5.3}
formal_array_type_definition ::= array_type_definition

@ref{12.5.4}
formal_access_type_definition ::= access_type_definition

@ref{12.6}
formal_subprogram_declaration ::=
   with subprogram_specification [is subprogram_default];

@ref{12.6}
subprogram_default ::= default_name | <>

@ref{12.6}
default_name ::= name

@ref{12.7}
formal_package_declaration ::=
   with package defining_identifier is new
     generic_package_name formal_package_actual_part;

@ref{12.7}
formal_package_actual_part ::= (<>) | [generic_actual_part]

@ref{13.1}
representation_clause ::=
     attribute_definition_clause
   | enumeration_representation_clause
   | record_representation_clause
   | at_clause

@ref{13.1}
local_name ::=
     direct_name
   | direct_name'attribute_designator
   | library_unit_name

@ref{13.3}
attribute_definition_clause ::=
     for local_name'attribute_designator use expression;
   | for local_name'attribute_designator use name;

@ref{13.4}
enumeration_representation_clause ::=
   for first_subtype_local_name use enumeration_aggregate;

@ref{13.4}
enumeration_aggregate ::= array_aggregate

@ref{13.5.1}
record_representation_clause ::=
   for first_subtype_local_name use
      record [mod_clause]
         @{component_clause@}
      end record;

@ref{13.5.1}
component_clause ::=
   component_local_name at position range first_bit .. last_bit;

@ref{13.5.1}
position ::= static_expression

@ref{13.5.1}
first_bit ::= static_simple_expression

@ref{13.5.1}
last_bit ::= static_simple_expression

@ref{13.8}
code_statement ::= qualified_expression;

@ref{13.12}
restriction ::= restriction_identifier
   | restriction_parameter_identifier => expression

@ref{J.3}
delta_constraint ::= delta static_expression [range_constraint]

@ref{J.7}
at_clause ::= for direct_name use at expression;

@ref{J.8}
mod_clause ::= at mod static_expression;

@end format

@need 1000
@sp 1
@center @emph{SYNTAX CROSS REFERENCE}

@item
@format
abort_statement
   simple_statement                      @ref{5.1}

abortable_part
   asynchronous_select                   @ref{9.7.4}

abstract_subprogram_declaration
   basic_declaration                     @ref{3.1}

accept_alternative
   select_alternative                    @ref{9.7.1}

accept_statement
   accept_alternative                    @ref{9.7.1}
   compound_statement                    @ref{5.1}

access_definition
   discriminant_specification            @ref{3.7}
   parameter_specification               @ref{6.1}

access_type_definition
   formal_access_type_definition         @ref{12.5.4}
   type_definition                       @ref{3.2.1}

access_to_object_definition
   access_type_definition                @ref{3.10}

access_to_subprogram_definition
   access_type_definition                @ref{3.10}

actual_parameter_part
   entry_call_statement                  @ref{9.5.3}
   function_call                         @ref{6.4}
   procedure_call_statement              @ref{6.4}

aggregate
   primary                               @ref{4.4}
   qualified_expression                  @ref{4.7}

allocator
   primary                               @ref{4.4}

ancestor_part
   extension_aggregate                   @ref{4.3.2}

array_aggregate
   aggregate                             @ref{4.3}
   enumeration_aggregate                 @ref{13.4}

array_component_association
   named_array_aggregate                 @ref{4.3.3}

array_type_definition
   formal_array_type_definition          @ref{12.5.3}
   object_declaration                    @ref{3.3.1}
   type_definition                       @ref{3.2.1}

assignment_statement
   simple_statement                      @ref{5.1}

asynchronous_select
   select_statement                      @ref{9.7}

at_clause
   representation_clause                 @ref{13.1}

attribute_definition_clause
   representation_clause                 @ref{13.1}

attribute_designator
   attribute_definition_clause           @ref{13.3}
   attribute_reference                   @ref{4.1.4}
   local_name                            @ref{13.1}

attribute_reference
   name                                  @ref{4.1}

base
   based_literal                         @ref{2.4.2}

based_literal
   numeric_literal                       @ref{2.4}

based_numeral
   based_literal                         @ref{2.4.2}

basic_declaration
   basic_declarative_item                @ref{3.11}

basic_declarative_item
   declarative_item                      @ref{3.11}
   package_specification                 @ref{7.1}

binary_adding_operator
   simple_expression                     @ref{4.4}

block_statement
   compound_statement                    @ref{5.1}

body
   declarative_item                      @ref{3.11}

body_stub
   body                                  @ref{3.11}

case_statement
   compound_statement                    @ref{5.1}

case_statement_alternative
   case_statement                        @ref{5.4}

character
   comment                               @ref{2.7}

character_literal
   defining_character_literal            @ref{3.5.1}
   name                                  @ref{4.1}
   selector_name                         @ref{4.1.3}

choice_parameter_specification
   exception_handler                     @ref{11.2}

code_statement
   simple_statement                      @ref{5.1}

compilation_unit
   compilation                           @ref{10.1.1}

component_choice_list
   record_component_association          @ref{4.3.1}

component_clause
   record_representation_clause          @ref{13.5.1}

component_declaration
   component_item                        @ref{3.8}
   protected_element_declaration         @ref{9.4}

component_definition
   component_declaration                 @ref{3.8}
   constrained_array_definition          @ref{3.6}
   unconstrained_array_definition        @ref{3.6}

component_item
   component_list                        @ref{3.8}

component_list
   record_definition                     @ref{3.8}
   variant                               @ref{3.8.1}

composite_constraint
   constraint                            @ref{3.2.2}

compound_statement
   statement                             @ref{5.1}

condition
   entry_barrier                         @ref{9.5.2}
   exit_statement                        @ref{5.7}
   guard                                 @ref{9.7.1}
   if_statement                          @ref{5.3}
   iteration_scheme                      @ref{5.5}

conditional_entry_call
   select_statement                      @ref{9.7}

constrained_array_definition
   array_type_definition                 @ref{3.6}

constraint
   subtype_indication                    @ref{3.2.2}

context_clause
   compilation_unit                      @ref{10.1.1}

context_item
   context_clause                        @ref{10.1.2}

decimal_fixed_point_definition
   fixed_point_definition                @ref{3.5.9}

decimal_literal
   numeric_literal                       @ref{2.4}

declarative_item
   declarative_part                      @ref{3.11}

declarative_part
   block_statement                       @ref{5.6}
   entry_body                            @ref{9.5.2}
   package_body                          @ref{7.2}
   subprogram_body                       @ref{6.3}
   task_body                             @ref{9.1}
default_expression
   component_declaration                 @ref{3.8}
   discriminant_specification            @ref{3.7}
   formal_object_declaration             @ref{12.4}
   parameter_specification               @ref{6.1}

default_name
   subprogram_default                    @ref{12.6}

defining_character_literal
   enumeration_literal_specification     @ref{3.5.1}

defining_designator
   generic_instantiation                 @ref{12.3}
   subprogram_specification              @ref{6.1}

defining_identifier
   choice_parameter_specification        @ref{11.2}
   defining_identifier_list              @ref{3.3.1}
   defining_program_unit_name            @ref{6.1}
   entry_body                            @ref{9.5.2}
   entry_declaration                     @ref{9.5.2}
   entry_index_specification             @ref{9.5.2}
   enumeration_literal_specification     @ref{3.5.1}
   exception_renaming_declaration        @ref{8.5.2}
   formal_package_declaration            @ref{12.7}
   formal_type_declaration               @ref{12.5}
   full_type_declaration                 @ref{3.2.1}
   incomplete_type_declaration           @ref{3.10.1}
   loop_parameter_specification          @ref{5.5}
   object_renaming_declaration           @ref{8.5.1}
   package_body_stub                     @ref{10.1.3}
   private_extension_declaration         @ref{7.3}
   private_type_declaration              @ref{7.3}
   protected_body                        @ref{9.4}
   protected_body_stub                   @ref{10.1.3}
   protected_type_declaration            @ref{9.4}
   single_protected_declaration          @ref{9.4}
   single_task_declaration               @ref{9.1}
   subtype_declaration                   @ref{3.2.2}
   task_body                             @ref{9.1}
   task_body_stub                        @ref{10.1.3}
   task_type_declaration                 @ref{9.1}

defining_identifier_list
   component_declaration                 @ref{3.8}
   discriminant_specification            @ref{3.7}
   exception_declaration                 @ref{11.1}
   formal_object_declaration             @ref{12.4}
   number_declaration                    @ref{3.3.2}
   object_declaration                    @ref{3.3.1}
   parameter_specification               @ref{6.1}

defining_operator_symbol
   defining_designator                   @ref{6.1}

defining_program_unit_name
   defining_designator                   @ref{6.1}
   generic_instantiation                 @ref{12.3}
   generic_renaming_declaration          @ref{8.5.5}
   package_body                          @ref{7.2}
   package_renaming_declaration          @ref{8.5.3}
   package_specification                 @ref{7.1}
   subprogram_specification              @ref{6.1}

delay_alternative
   select_alternative                    @ref{9.7.1}
   timed_entry_call                      @ref{9.7.2}

delay_relative_statement
   delay_statement                       @ref{9.6}

delay_statement
   delay_alternative                     @ref{9.7.1}
   simple_statement                      @ref{5.1}
   triggering_statement                  @ref{9.7.4}

delay_until_statement
   delay_statement                       @ref{9.6}

delta_constraint
   scalar_constraint                     @ref{3.2.2}

derived_type_definition
   type_definition                       @ref{3.2.1}

designator
   subprogram_body                       @ref{6.3}

digit
   extended_digit                        @ref{2.4.2}
   graphic_character                     @ref{2.1}
   letter_or_digit                       @ref{2.3}
   numeral                               @ref{2.4.1}

digits_constraint
   scalar_constraint                     @ref{3.2.2}

direct_name
   accept_statement                      @ref{9.5.2}
   at_clause                             @ref{J.7}
   local_name                            @ref{13.1}
   name                                  @ref{4.1}
   statement_identifier                  @ref{5.1}
   variant_part                          @ref{3.8.1}

discrete_choice
   discrete_choice_list                  @ref{3.8.1}

discrete_choice_list
   array_component_association           @ref{4.3.3}
   case_statement_alternative            @ref{5.4}
   variant                               @ref{3.8.1}

discrete_range
   discrete_choice                       @ref{3.8.1}
   index_constraint                      @ref{3.6.1}
   slice                                 @ref{4.1.2}

discrete_subtype_definition
   constrained_array_definition          @ref{3.6}
   entry_declaration                     @ref{9.5.2}
   entry_index_specification             @ref{9.5.2}
   loop_parameter_specification          @ref{5.5}

discriminant_association
   discriminant_constraint               @ref{3.7.1}

discriminant_constraint
   composite_constraint                  @ref{3.2.2}

discriminant_part
   formal_type_declaration               @ref{12.5}
   incomplete_type_declaration           @ref{3.10.1}
   private_extension_declaration         @ref{7.3}
   private_type_declaration              @ref{7.3}

discriminant_specification
   known_discriminant_part               @ref{3.7}

entry_barrier
   entry_body                            @ref{9.5.2}

entry_body
   protected_operation_item              @ref{9.4}

entry_body_formal_part
   entry_body                            @ref{9.5.2}

entry_call_alternative
   conditional_entry_call                @ref{9.7.3}
   timed_entry_call                      @ref{9.7.2}

entry_call_statement
   entry_call_alternative                @ref{9.7.2}
   simple_statement                      @ref{5.1}
   triggering_statement                  @ref{9.7.4}

entry_declaration
   protected_operation_declaration       @ref{9.4}
   task_item                             @ref{9.1}

entry_index
   accept_statement                      @ref{9.5.2}

entry_index_specification
   entry_body_formal_part                @ref{9.5.2}

enumeration_aggregate
   enumeration_representation_clause     @ref{13.4}

enumeration_literal_specification
   enumeration_type_definition           @ref{3.5.1}

enumeration_representation_clause
   representation_clause                 @ref{13.1}

enumeration_type_definition
   type_definition                       @ref{3.2.1}

exception_choice
   exception_handler                     @ref{11.2}

exception_declaration
   basic_declaration                     @ref{3.1}

exception_handler
   handled_sequence_of_statements        @ref{11.2}

exception_renaming_declaration
   renaming_declaration                  @ref{8.5}

exit_statement
   simple_statement                      @ref{5.1}

explicit_actual_parameter
   parameter_association                 @ref{6.4}

explicit_dereference
   name                                  @ref{4.1}

explicit_generic_actual_parameter
   generic_association                   @ref{12.3}

exponent
   based_literal                         @ref{2.4.2}
   decimal_literal                       @ref{2.4.1}

expression
   ancestor_part                         @ref{4.3.2}
   array_component_association           @ref{4.3.3}
   assignment_statement                  @ref{5.2}
   at_clause                             @ref{J.7}
   attribute_definition_clause           @ref{13.3}
   attribute_designator                  @ref{4.1.4}
   case_statement                        @ref{5.4}
   condition                             @ref{5.3}
   decimal_fixed_point_definition        @ref{3.5.9}
   default_expression                    @ref{3.7}
   delay_relative_statement              @ref{9.6}
   delay_until_statement                 @ref{9.6}
   delta_constraint                      @ref{J.3}
   digits_constraint                     @ref{3.5.9}
   discrete_choice                       @ref{3.8.1}
   discriminant_association              @ref{3.7.1}
   entry_index                           @ref{9.5.2}
   explicit_actual_parameter             @ref{6.4}
   explicit_generic_actual_parameter     @ref{12.3}
   floating_point_definition             @ref{3.5.7}
   indexed_component                     @ref{4.1.1}
   mod_clause                            @ref{J.8}
   modular_type_definition               @ref{3.5.4}
   number_declaration                    @ref{3.3.2}
   object_declaration                    @ref{3.3.1}
   ordinary_fixed_point_definition       @ref{3.5.9}
   position                              @ref{13.5.1}
   positional_array_aggregate            @ref{4.3.3}
   pragma_argument_association           @ref{2.8}
   primary                               @ref{4.4}
   qualified_expression                  @ref{4.7}
   range_attribute_designator            @ref{4.1.4}
   record_component_association          @ref{4.3.1}
   restriction                           @ref{13.12}
   return_statement                      @ref{6.5}
   type_conversion                       @ref{4.6}

extended_digit
   based_numeral                         @ref{2.4.2}

extension_aggregate
   aggregate                             @ref{4.3}

factor
   term                                  @ref{4.4}

first_bit
   component_clause                      @ref{13.5.1}

fixed_point_definition
   real_type_definition                  @ref{3.5.6}

floating_point_definition
   real_type_definition                  @ref{3.5.6}

formal_access_type_definition
   formal_type_definition                @ref{12.5}

formal_array_type_definition
   formal_type_definition                @ref{12.5}

formal_decimal_fixed_point_definition
   formal_type_definition                @ref{12.5}

formal_derived_type_definition
   formal_type_definition                @ref{12.5}

formal_discrete_type_definition
   formal_type_definition                @ref{12.5}

formal_floating_point_definition
   formal_type_definition                @ref{12.5}

formal_modular_type_definition
   formal_type_definition                @ref{12.5}

formal_object_declaration
   generic_formal_parameter_declaration  @ref{12.1}

formal_ordinary_fixed_point_definition
   formal_type_definition                @ref{12.5}

formal_package_actual_part
   formal_package_declaration            @ref{12.7}

formal_package_declaration
   generic_formal_parameter_declaration  @ref{12.1}

formal_part
   parameter_and_result_profile          @ref{6.1}
   parameter_profile                     @ref{6.1}

formal_private_type_definition
   formal_type_definition                @ref{12.5}

formal_signed_integer_type_definition
   formal_type_definition                @ref{12.5}

formal_subprogram_declaration
   generic_formal_parameter_declaration  @ref{12.1}

formal_type_declaration
   generic_formal_parameter_declaration  @ref{12.1}

formal_type_definition
   formal_type_declaration               @ref{12.5}

format_effector
   character                             @ref{2.1}

full_type_declaration
   type_declaration                      @ref{3.2.1}

function_call
   name                                  @ref{4.1}

general_access_modifier
   access_to_object_definition           @ref{3.10}

generic_actual_part
   formal_package_actual_part            @ref{12.7}
   generic_instantiation                 @ref{12.3}

generic_association
   generic_actual_part                   @ref{12.3}

generic_declaration
   basic_declaration                     @ref{3.1}
   library_unit_declaration              @ref{10.1.1}

generic_formal_parameter_declaration
   generic_formal_part                   @ref{12.1}

generic_formal_part
   generic_package_declaration           @ref{12.1}
   generic_subprogram_declaration        @ref{12.1}

generic_instantiation
   basic_declaration                     @ref{3.1}
   library_unit_declaration              @ref{10.1.1}

generic_package_declaration
   generic_declaration                   @ref{12.1}

generic_renaming_declaration
   library_unit_renaming_declaration     @ref{10.1.1}
   renaming_declaration                  @ref{8.5}

generic_subprogram_declaration
   generic_declaration                   @ref{12.1}

goto_statement
   simple_statement                      @ref{5.1}

graphic_character
   character                             @ref{2.1}
   character_literal                     @ref{2.5}
   string_element                        @ref{2.6}

guard
   selective_accept                      @ref{9.7.1}

handled_sequence_of_statements
   accept_statement                      @ref{9.5.2}
   block_statement                       @ref{5.6}
   entry_body                            @ref{9.5.2}
   package_body                          @ref{7.2}
   subprogram_body                       @ref{6.3}
   task_body                             @ref{9.1}

identifier
   accept_statement                      @ref{9.5.2}
   attribute_designator                  @ref{4.1.4}
   block_statement                       @ref{5.6}
   defining_identifier                   @ref{3.1}
   designator                            @ref{6.1}
   direct_name                           @ref{4.1}
   entry_body                            @ref{9.5.2}
   loop_statement                        @ref{5.5}
   package_body                          @ref{7.2}
   package_specification                 @ref{7.1}
   pragma                                @ref{2.8}
   pragma_argument_association           @ref{2.8}
   protected_body                        @ref{9.4}
   protected_definition                  @ref{9.4}
   restriction                           @ref{13.12}
   selector_name                         @ref{4.1.3}
   task_body                             @ref{9.1}
   task_definition                       @ref{9.1}

identifier_letter
   graphic_character                     @ref{2.1}
   identifier                            @ref{2.3}
   letter_or_digit                       @ref{2.3}

if_statement
   compound_statement                    @ref{5.1}

implicit_dereference
   prefix                                @ref{4.1}

incomplete_type_declaration
   type_declaration                      @ref{3.2.1}

index_constraint
   composite_constraint                  @ref{3.2.2}

index_subtype_definition
   unconstrained_array_definition        @ref{3.6}

indexed_component
   name                                  @ref{4.1}

integer_type_definition
   type_definition                       @ref{3.2.1}

iteration_scheme
   loop_statement                        @ref{5.5}

known_discriminant_part
   discriminant_part                     @ref{3.7}
   full_type_declaration                 @ref{3.2.1}
   protected_type_declaration            @ref{9.4}
   task_type_declaration                 @ref{9.1}

label
   statement                             @ref{5.1}

last_bit
   component_clause                      @ref{13.5.1}

letter_or_digit
   identifier                            @ref{2.3}

library_item
   compilation_unit                      @ref{10.1.1}

library_unit_body
   library_item                          @ref{10.1.1}

library_unit_declaration
   library_item                          @ref{10.1.1}

library_unit_renaming_declaration
   library_item                          @ref{10.1.1}

local_name
   attribute_definition_clause           @ref{13.3}
   component_clause                      @ref{13.5.1}
   enumeration_representation_clause     @ref{13.4}
   record_representation_clause          @ref{13.5.1}

loop_parameter_specification
   iteration_scheme                      @ref{5.5}

loop_statement
   compound_statement                    @ref{5.1}

mod_clause
   record_representation_clause          @ref{13.5.1}

mode
   formal_object_declaration             @ref{12.4}
   parameter_specification               @ref{6.1}

modular_type_definition
   integer_type_definition               @ref{3.5.4}

multiplying_operator
   term                                  @ref{4.4}

name
   abort_statement                       @ref{9.8}
   assignment_statement                  @ref{5.2}
   attribute_definition_clause           @ref{13.3}
   default_name                          @ref{12.6}
   entry_call_statement                  @ref{9.5.3}
   exception_choice                      @ref{11.2}
   exception_renaming_declaration        @ref{8.5.2}
   exit_statement                        @ref{5.7}
   explicit_actual_parameter             @ref{6.4}
   explicit_dereference                  @ref{4.1}
   explicit_generic_actual_parameter     @ref{12.3}
   formal_package_declaration            @ref{12.7}
   function_call                         @ref{6.4}
   generic_instantiation                 @ref{12.3}
   generic_renaming_declaration          @ref{8.5.5}
   goto_statement                        @ref{5.8}
   implicit_dereference                  @ref{4.1}
   local_name                            @ref{13.1}
   object_renaming_declaration           @ref{8.5.1}
   package_renaming_declaration          @ref{8.5.3}
   parent_unit_name                      @ref{10.1.1}
   pragma_argument_association           @ref{2.8}
   prefix                                @ref{4.1}
   primary                               @ref{4.4}
   procedure_call_statement              @ref{6.4}
   raise_statement                       @ref{11.3}
   requeue_statement                     @ref{9.5.4}
   subprogram_renaming_declaration       @ref{8.5.4}
   subtype_mark                          @ref{3.2.2}
   type_conversion                       @ref{4.6}
   use_package_clause                    @ref{8.4}
   with_clause                           @ref{10.1.2}

named_array_aggregate
   array_aggregate                       @ref{4.3.3}

null_statement
   simple_statement                      @ref{5.1}

number_declaration
   basic_declaration                     @ref{3.1}

numeral
   base                                  @ref{2.4.2}
   decimal_literal                       @ref{2.4.1}
   exponent                              @ref{2.4.1}

numeric_literal
   primary                               @ref{4.4}

object_declaration
   basic_declaration                     @ref{3.1}

object_renaming_declaration
   renaming_declaration                  @ref{8.5}

operator_symbol
   defining_operator_symbol              @ref{6.1}
   designator                            @ref{6.1}
   direct_name                           @ref{4.1}
   selector_name                         @ref{4.1.3}

ordinary_fixed_point_definition
   fixed_point_definition                @ref{3.5.9}

other_control_function
   character                             @ref{2.1}

package_body
   library_unit_body                     @ref{10.1.1}
   proper_body                           @ref{3.11}

package_body_stub
   body_stub                             @ref{10.1.3}

package_declaration
   basic_declaration                     @ref{3.1}
   library_unit_declaration              @ref{10.1.1}

package_renaming_declaration
   library_unit_renaming_declaration     @ref{10.1.1}
   renaming_declaration                  @ref{8.5}

package_specification
   generic_package_declaration           @ref{12.1}
   package_declaration                   @ref{7.1}

parameter_and_result_profile
   access_to_subprogram_definition       @ref{3.10}
   subprogram_specification              @ref{6.1}

parameter_association
   actual_parameter_part                 @ref{6.4}

parameter_profile
   accept_statement                      @ref{9.5.2}
   access_to_subprogram_definition       @ref{3.10}
   entry_body_formal_part                @ref{9.5.2}
   entry_declaration                     @ref{9.5.2}
   subprogram_specification              @ref{6.1}

parameter_specification
   formal_part                           @ref{6.1}

parent_unit_name
   defining_program_unit_name            @ref{6.1}
   designator                            @ref{6.1}
   package_body                          @ref{7.2}
   package_specification                 @ref{7.1}
   subunit                               @ref{10.1.3}

position
   component_clause                      @ref{13.5.1}

positional_array_aggregate
   array_aggregate                       @ref{4.3.3}

pragma_argument_association
   pragma                                @ref{2.8}

prefix
   attribute_reference                   @ref{4.1.4}
   function_call                         @ref{6.4}
   indexed_component                     @ref{4.1.1}
   procedure_call_statement              @ref{6.4}
   range_attribute_reference             @ref{4.1.4}
   selected_component                    @ref{4.1.3}
   slice                                 @ref{4.1.2}

primary
   factor                                @ref{4.4}

private_extension_declaration
   type_declaration                      @ref{3.2.1}

private_type_declaration
   type_declaration                      @ref{3.2.1}

procedure_call_statement
   simple_statement                      @ref{5.1}

proper_body
   body                                  @ref{3.11}
   subunit                               @ref{10.1.3}

protected_body
   proper_body                           @ref{3.11}

protected_body_stub
   body_stub                             @ref{10.1.3}

protected_definition
   protected_type_declaration            @ref{9.4}
   single_protected_declaration          @ref{9.4}

protected_element_declaration
   protected_definition                  @ref{9.4}

protected_operation_declaration
   protected_definition                  @ref{9.4}
   protected_element_declaration         @ref{9.4}

protected_operation_item
   protected_body                        @ref{9.4}

protected_type_declaration
   full_type_declaration                 @ref{3.2.1}

qualified_expression
   allocator                             @ref{4.8}
   code_statement                        @ref{13.8}
   primary                               @ref{4.4}

raise_statement
   simple_statement                      @ref{5.1}

range
   discrete_range                        @ref{3.6.1}
   discrete_subtype_definition           @ref{3.6}
   range_constraint                      @ref{3.5}
   relation                              @ref{4.4}

range_attribute_designator
   range_attribute_reference             @ref{4.1.4}

range_attribute_reference
   range                                 @ref{3.5}

range_constraint
   delta_constraint                      @ref{J.3}
   digits_constraint                     @ref{3.5.9}
   scalar_constraint                     @ref{3.2.2}

real_range_specification
   decimal_fixed_point_definition        @ref{3.5.9}
   floating_point_definition             @ref{3.5.7}
   ordinary_fixed_point_definition       @ref{3.5.9}

real_type_definition
   type_definition                       @ref{3.2.1}

record_aggregate
   aggregate                             @ref{4.3}

record_component_association
   record_component_association_list     @ref{4.3.1}

record_component_association_list
   extension_aggregate                   @ref{4.3.2}
   record_aggregate                      @ref{4.3.1}

record_definition
   record_extension_part                 @ref{3.9.1}
   record_type_definition                @ref{3.8}

record_extension_part
   derived_type_definition               @ref{3.4}

record_representation_clause
   representation_clause                 @ref{13.1}

record_type_definition
   type_definition                       @ref{3.2.1}

relation
   expression                            @ref{4.4}

relational_operator
   relation                              @ref{4.4}

renaming_declaration
   basic_declaration                     @ref{3.1}

representation_clause
   basic_declarative_item                @ref{3.11}
   component_item                        @ref{3.8}
   protected_operation_declaration       @ref{9.4}
   protected_operation_item              @ref{9.4}
   task_item                             @ref{9.1}

requeue_statement
   simple_statement                      @ref{5.1}

return_statement
   simple_statement                      @ref{5.1}

scalar_constraint
   constraint                            @ref{3.2.2}

select_alternative
   selective_accept                      @ref{9.7.1}

select_statement
   compound_statement                    @ref{5.1}

selected_component
   name                                  @ref{4.1}

selective_accept
   select_statement                      @ref{9.7}

selector_name
   component_choice_list                 @ref{4.3.1}
   discriminant_association              @ref{3.7.1}
   generic_association                   @ref{12.3}
   parameter_association                 @ref{6.4}
   selected_component                    @ref{4.1.3}

sequence_of_statements
   abortable_part                        @ref{9.7.4}
   accept_alternative                    @ref{9.7.1}
   case_statement_alternative            @ref{5.4}
   conditional_entry_call                @ref{9.7.3}
   delay_alternative                     @ref{9.7.1}
   entry_call_alternative                @ref{9.7.2}
   exception_handler                     @ref{11.2}
   handled_sequence_of_statements        @ref{11.2}
   if_statement                          @ref{5.3}
   loop_statement                        @ref{5.5}
   selective_accept                      @ref{9.7.1}
   triggering_alternative                @ref{9.7.4}

signed_integer_type_definition
   integer_type_definition               @ref{3.5.4}

simple_expression
   first_bit                             @ref{13.5.1}
   last_bit                              @ref{13.5.1}
   range                                 @ref{3.5}
   real_range_specification              @ref{3.5.7}
   relation                              @ref{4.4}
   signed_integer_type_definition        @ref{3.5.4}

simple_statement
   statement                             @ref{5.1}

single_protected_declaration
   object_declaration                    @ref{3.3.1}

single_task_declaration
   object_declaration                    @ref{3.3.1}

slice
   name                                  @ref{4.1}

space_character
   graphic_character                     @ref{2.1}

special_character
   graphic_character                     @ref{2.1}

statement
   sequence_of_statements                @ref{5.1}

statement_identifier
   block_statement                       @ref{5.6}
   label                                 @ref{5.1}
   loop_statement                        @ref{5.5}
string_element
   string_literal                        @ref{2.6}

string_literal
   operator_symbol                       @ref{6.1}
   primary                               @ref{4.4}

subprogram_body
   library_unit_body                     @ref{10.1.1}
   proper_body                           @ref{3.11}
   protected_operation_item              @ref{9.4}

subprogram_body_stub
   body_stub                             @ref{10.1.3}

subprogram_declaration
   basic_declaration                     @ref{3.1}
   library_unit_declaration              @ref{10.1.1}
   protected_operation_declaration       @ref{9.4}
   protected_operation_item              @ref{9.4}

subprogram_default
   formal_subprogram_declaration         @ref{12.6}

subprogram_renaming_declaration
   library_unit_renaming_declaration     @ref{10.1.1}
   renaming_declaration                  @ref{8.5}

subprogram_specification
   abstract_subprogram_declaration       @ref{6.1}
   formal_subprogram_declaration         @ref{12.6}
   generic_subprogram_declaration        @ref{12.1}
   subprogram_body                       @ref{6.3}
   subprogram_body_stub                  @ref{10.1.3}
   subprogram_declaration                @ref{6.1}
   subprogram_renaming_declaration       @ref{8.5.4}

subtype_declaration
   basic_declaration                     @ref{3.1}

subtype_indication
   access_to_object_definition           @ref{3.10}
   allocator                             @ref{4.8}
   component_definition                  @ref{3.6}
   derived_type_definition               @ref{3.4}
   discrete_range                        @ref{3.6.1}
   discrete_subtype_definition           @ref{3.6}
   object_declaration                    @ref{3.3.1}
   private_extension_declaration         @ref{7.3}
   subtype_declaration                   @ref{3.2.2}

subtype_mark
   access_definition                     @ref{3.10}
   ancestor_part                         @ref{4.3.2}
   discriminant_specification            @ref{3.7}
   explicit_generic_actual_parameter     @ref{12.3}
   formal_derived_type_definition        @ref{12.5.1}
   formal_object_declaration             @ref{12.4}
   index_subtype_definition              @ref{3.6}
   object_renaming_declaration           @ref{8.5.1}
   parameter_and_result_profile          @ref{6.1}
   parameter_specification               @ref{6.1}
   qualified_expression                  @ref{4.7}
   relation                              @ref{4.4}
   subtype_indication                    @ref{3.2.2}
   type_conversion                       @ref{4.6}
   use_type_clause                       @ref{8.4}

subunit
   compilation_unit                      @ref{10.1.1}

task_body
   proper_body                           @ref{3.11}

task_body_stub
   body_stub                             @ref{10.1.3}

task_definition
   single_task_declaration               @ref{9.1}
   task_type_declaration                 @ref{9.1}

task_item
   task_definition                       @ref{9.1}

task_type_declaration
   full_type_declaration                 @ref{3.2.1}

term
   simple_expression                     @ref{4.4}

terminate_alternative
   select_alternative                    @ref{9.7.1}

timed_entry_call
   select_statement                      @ref{9.7}

triggering_alternative
   asynchronous_select                   @ref{9.7.4}

triggering_statement
   triggering_alternative                @ref{9.7.4}

type_conversion
   name                                  @ref{4.1}

type_declaration
   basic_declaration                     @ref{3.1}

type_definition
   full_type_declaration                 @ref{3.2.1}

unary_adding_operator
   simple_expression                     @ref{4.4}

unconstrained_array_definition
   array_type_definition                 @ref{3.6}

underline
   based_numeral                         @ref{2.4.2}
   identifier                            @ref{2.3}
   numeral                               @ref{2.4.1}

unknown_discriminant_part
   discriminant_part                     @ref{3.7}

use_clause
   basic_declarative_item                @ref{3.11}
   context_item                          @ref{10.1.2}
   generic_formal_part                   @ref{12.1}

use_package_clause
   use_clause                            @ref{8.4}

use_type_clause
   use_clause                            @ref{8.4}

variant
   variant_part                          @ref{3.8.1}

variant_part
   component_list                        @ref{3.8}

with_clause
   context_item                          @ref{10.1.2}
@end format
@end enumerate

@c ===========================================================================
@node Index, Index.Operators, P, Top
@section Index

@example
Index entries are given by paragraph number. A list of all
language-defined library units may be found under Language-Defined
Library Units. A list of all language-defined types may be found under
Language-Defined Types.
@end example

@menu
* Index.Operators::
* Index.Digits::
* Index.A::
* Index.B::
* Index.C::
* Index.D::
* Index.E::
* Index.F::
* Index.G::
* Index.H::
* Index.I::
* Index.J::
* Index.K::
* Index.L::
* Index.M::
* Index.N::
* Index.O::
* Index.P::
* Index.Q::
* Index.R::
* Index.S::
* Index.T::
* Index.U::
* Index.V::
* Index.W::
* Index.X::
* Index.Y::
@end menu

@c ---------------------------------------------------------------------------
@node Index.Operators, Index.Digits, Index, Index
@section Operator index

@format
&  operator    @ref{4.4}(1), @ref{4.5.3}(1), @ref{4.5.3}(3)

*  operator    @ref{4.4}(1), @ref{4.5.5}(1), @ref{4.5.5}(1)
** operator    @ref{4.4}(1), @ref{4.5.6}(1), @ref{4.5.6}(7)

+  operator    @ref{4.4}(1), @ref{4.5.3}(1), @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1)

=  operator    @ref{4.4}(1), @ref{4.5.2}(1), @ref{4.5.2}(1)

-  operator    @ref{4.4}(1), @ref{4.5.3}(1), @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1)

/  operator    @ref{4.4}(1), @ref{4.5.5}(1), @ref{4.5.5}(1)
/= operator    @ref{4.4}(1), @ref{4.5.2}(1), @ref{4.5.2}(1)

<  operator    @ref{4.4}(1), @ref{4.5.2}(1), @ref{4.5.2}(1)
<= operator    @ref{4.4}(1), @ref{4.5.2}(1), @ref{4.5.2}(1)

>  operator    @ref{4.4}(1), @ref{4.5.2}(1), @ref{4.5.2}(1)
>= operator    @ref{4.4}(1), @ref{4.5.2}(1), @ref{4.5.2}(1)
@end format

@c ---------------------------------------------------------------------------
@node Index.Digits, Index.A, Index.Operators, Index
@section Digits index

@format
10646-1:1993, ISO/IEC standard    @ref{1.2,,1.2(8)}.
1539:1991,    ISO/IEC standard    @ref{1.2,,1.2(3)}.
1989:1985,    ISO standard        @ref{1.2,,1.2(4)}.

6429:1992,    ISO/IEC standard    @ref{1.2,,1.2(5)}.
646:1991,     ISO/IEC standard    @ref{1.2,,1.2(2)}.

8859-1:1987,  ISO/IEC standard    @ref{1.2,,1.2(6)}.

9899:1990,    ISO/IEC standard    @ref{1.2,,1.2(7)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.A, Index.B, Index.Digits, Index
@chapter index

@format
A_Form    @ref{4.6}.
abnormal completion    @ref{7.6.1}.
abnormal state of an object    @ref{13.9.1}.
   [partial]    @ref{9.8}(21), see @ref{11.6}(6), see @ref{A.13}(21), see @ref{11.6}(6), see @ref{A.13,,A.13(17)}.
abnormal task    @ref{9.8}.
abort
   of a partition    @ref{E.1}.
   of a task    @ref{9.8}.
   of the execution of a construct    @ref{9.8}.
abort completion point    @ref{9.8}.
abort-deferred operation    @ref{9.8}.
abort_statement    @ref{9.8}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Abort_Task    @ref{C.7.1}.
abortable_part    @ref{9.7.4}.
   used    @ref{9.7.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
abs operator    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(1)}.
absolute value    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(1)}.
abstract data type (ADT)
   See also abstract type    @ref{3.9.3}.
   See private types and private extensions    @ref{7.3}.
abstract subprogram    @ref{3.9.3}(1), see @ref{3.9.3}(1), see @ref{3.9.3,,3.9.3(3)}.
abstract type    @ref{3.9.3}(1), see @ref{3.9.3}(1), see @ref{3.9.3,,3.9.3(2)}.
abstract_subprogram_declaration    @ref{6.1}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Acc    @ref{13.11}.
accept_alternative    @ref{9.7.1}.
   used    @ref{9.7.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
accept_statement    @ref{9.5.2}.
   used    @ref{5.1}(5), see @ref{9.7.1}(5), see @ref{P}(5), see @ref{9.7.1}(5), see @ref{P,,P(1)}.
acceptable interpretation    @ref{8.6}.
Access attribute    @ref{3.10.2}(24), see @ref{3.10.2}(24), see @ref{3.10.2,,3.10.2(32)},
                    @ref{K}(2),        @ref{K}(2),        @ref{K,,K(4)}.
   See also Unchecked_Access attribute    @ref{13.10}.
access discriminant    @ref{3.7}.
access parameter    @ref{6.1}.
access paths
   distinct    @ref{6.2}.
access type    @ref{3.10}(1), see @ref{N}(1), see @ref{N,,N(2)}.
access types
   input-output unspecified    @ref{A.7}.
access value    @ref{3.10}.
access-to-constant type    @ref{3.10}.
access-to-object type    @ref{3.10}.
access-to-subprogram type    @ref{3.10}(7), see @ref{3.10}(7), see @ref{3.10,,3.10(11)}.
access-to-variable type    @ref{3.10}.
Access_Check    @ref{11.5}.
   [partial]    @ref{4.1}(13), see @ref{4.6}(13), see @ref{4.6,,4.6(49)}.
access_definition    @ref{3.10}.
   used    @ref{3.7}(5), see @ref{6.1}(15), see @ref{P}(5), see @ref{6.1}(15), see @ref{P,,P(1)}.
access_type_definition    @ref{3.10}.
   used    @ref{3.2.1}(4), see @ref{12.5.4}(2), see @ref{P}(4), see @ref{12.5.4}(2), see @ref{P,,P(1)}.
access_to_object_definition    @ref{3.10}.
   used    @ref{3.10}(2), see @ref{P}(2), see @ref{P,,P(1)}.
access_to_subprogram_definition    @ref{3.10}.
   used    @ref{3.10}(2), see @ref{P}(2), see @ref{P,,P(1)}.
accessibility
   from shared passive library units    @ref{E.2.1}.
accessibility level    @ref{3.10.2}.
accessibility rule
   Access attribute    @ref{3.10.2}(28), see @ref{3.10.2}(28), see @ref{3.10.2,,3.10.2(32)}.
   record extension    @ref{3.9.1}.
   requeue statement    @ref{9.5.4}.
   type conversion    @ref{4.6}(17), see @ref{4.6}(17), see @ref{4.6,,4.6(20)}.
Accessibility_Check    @ref{11.5}.
   [partial]    @ref{3.10.2}(29), see @ref{4.6}(48), see @ref{6.5}(29), see @ref{4.6}(48), see @ref{6.5,,6.5(17)},
                @ref{E.4}.
accessible partition    @ref{E.1}.
accuracy    @ref{4.6}(32), see @ref{G.2}(32), see @ref{G.2,,G.2(1)}.
ACK    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
acquire
   execution resource associated with protected object
         @ref{9.5.1}.
Activate    @ref{6.4}.
activation
   of a task    @ref{9.2}.
activation failure    @ref{9.2}.
activator
   of a task    @ref{9.2}.
active partition    @ref{10.2}(28), see @ref{E.1}(28), see @ref{E.1,,E.1(2)}.
active priority    @ref{D.1}.
actual    @ref{12.3}.
actual duration    @ref{D.9}.
actual parameter
   for a formal parameter    @ref{6.4.1}.
actual subtype    @ref{3.3}(23), see @ref{12.5}(23), see @ref{12.5,,12.5(4)}.
   of an object    @ref{3.3.1}.
actual type    @ref{12.5}.
actual_parameter_part    @ref{6.4}.
   used    @ref{6.4}(2), see @ref{6.4}(3), see @ref{9.5.3}(2), see @ref{P}(2), see @ref{6.4}(3), see @ref{9.5.3}(2), see @ref{P,,P(1)}.
Acute    @ref{A.3.3}.
Ada    @ref{A.2}.
Ada calling convention    @ref{6.3.1}.
Ada.Asynchronous_Task_Control    @ref{D.11}.
Ada.Calendar    @ref{9.6}.
Ada.Characters    @ref{A.3.1}.
Ada.Characters.Handling    @ref{A.3.2}.
Ada.Characters.Latin_1    @ref{A.3.3}.
Ada.Command_Line    @ref{A.15}.
Ada.Decimal    @ref{F.2}.
Ada.Direct_IO    @ref{A.8.4}.
Ada.Dynamic_Priorities    @ref{D.5}.
Ada.Exceptions    @ref{11.4.1}.
Ada.Finalization    @ref{7.6}.
Ada.Float_Text_IO    @ref{A.10.9}.
Ada.Float_Wide_Text_IO    @ref{A.11}.
Ada.Integer_Text_IO    @ref{A.10.8}.
Ada.Integer_Wide_Text_IO    @ref{A.11}.
Ada.Interrupts    @ref{C.3.2}.
Ada.Interrupts.Names    @ref{C.3.2}.
Ada.Numerics    @ref{A.5}.
Ada.Numerics.Complex_Elementary_Functions    @ref{G.1.2}.
Ada.Numerics.Complex_Types    @ref{G.1.1}.
Ada.Numerics.Discrete_Random    @ref{A.5.2}.
Ada.Numerics.Elementary_Functions    @ref{A.5.1}.
Ada.Numerics.Float_Random    @ref{A.5.2}.
Ada.Numerics.Generic_Complex_Elementary_Functions    @ref{G.1.2}.
Ada.Numerics.Generic_Complex_Types    @ref{G.1.1}.
Ada.Numerics.Generic_Elementary_Functions    @ref{A.5.1}.
Ada.Real_Time    @ref{D.8}.
Ada.Sequential_IO    @ref{A.8.1}.
Ada.Storage_IO    @ref{A.9}.
Ada.Streams    @ref{13.13.1}.
Ada.Streams.Stream_IO    @ref{A.12.1}.
Ada.Strings    @ref{A.4.1}.
Ada.Strings.Bounded    @ref{A.4.4}.
Ada.Strings.Fixed    @ref{A.4.3}.
Ada.Strings.Maps    @ref{A.4.2}.
Ada.Strings.Maps.Constants    @ref{A.4.6}.
Ada.Strings.Unbounded    @ref{A.4.5}.
Ada.Strings.Wide_Bounded    @ref{A.4.7}.
Ada.Strings.Wide_Fixed    @ref{A.4.7}.
Ada.Strings.Wide_Maps    @ref{A.4.7}.
Ada.Strings.Wide_Maps.Wide_Constants    @ref{A.4.7}.
Ada.Strings.Wide_Unbounded    @ref{A.4.7}.
Ada.Synchronous_Task_Control    @ref{D.10}.
Ada.Tags    @ref{3.9}.
Ada.Task_Attributes    @ref{C.7.2}.
Ada.Task_Identification    @ref{C.7.1}.
Ada.Text_IO    @ref{A.10.1}.
Ada.Text_IO.Complex_IO    @ref{G.1.3}.
Ada.Text_IO.Editing    @ref{F.3.3}.
Ada.Text_IO.Text_Streams    @ref{A.12.2}.
Ada.Unchecked_Conversion    @ref{13.9}.
Ada.Unchecked_Deallocation    @ref{13.11.2}.
Ada.Wide_Text_IO    @ref{A.11}.
Ada.Wide_Text_IO.Complex_IO    @ref{G.1.4}.
Ada.Wide_Text_IO.Editing    @ref{F.3.4}.
Ada.Wide_Text_IO.Text_Streams    @ref{A.12.3}.
Ada.IO_Exceptions    @ref{A.13}.
Ada_Application    @ref{B.5}.
Ada_Employee_Record_Type    @ref{B.4}.
Addition    @ref{3.9.1}.
Address    @ref{13.7}.
   arithmetic    @ref{13.7.1}.
   comparison    @ref{13.7}.
   null    @ref{13.7}.
Address attribute    @ref{13.3}(11), see @ref{J.7.1}(5), see @ref{K}(11), see @ref{J.7.1}(5), see @ref{K,,K(6)}.
Address clause    @ref{13.3}(7), see @ref{13.3}(7), see @ref{13.3,,13.3(12)}.
Address_To_Access_Conversions
   child of System    @ref{13.7.2}.
Adjacent attribute    @ref{A.5.3}(48), see @ref{K}(48), see @ref{K,,K(8)}.
Adjust    @ref{7.6}(2), see @ref{7.6}(2), see @ref{7.6,,7.6(6)}.
adjusting the value of an object    @ref{7.6}(15), see @ref{7.6}(15), see @ref{7.6,,7.6(16)}.
adjustment    @ref{7.6}(15), see @ref{7.6}(15), see @ref{7.6,,7.6(16)}.
   as part of assignment    @ref{5.2}.
Adjustments_Conversions    @ref{B.4}.
Adjustments_Type    @ref{B.4}.
ADT (abstract data type)
   See also abstract type    @ref{3.9.3}.
   See private types and private extensions    @ref{7.3}.
advice    @ref{1.1.2}.
Aft attribute    @ref{3.5.10}(5), see @ref{K}(5), see @ref{K,,K(12)}.
aggregate    @ref{4.3}(1), see @ref{4.3}(1), see @ref{4.3,,4.3(2)}.
   used    @ref{4.4}(7), see @ref{4.7}(2), see @ref{P}(7), see @ref{4.7}(2), see @ref{P,,P(1)}.
   See also composite type    @ref{3.2}.
aliased    @ref{3.10}(9), see @ref{N}(9), see @ref{N,,N(3)}.
aliasing
   See distinct access paths    @ref{6.2}.
Alignment    @ref{A.4.1}.
Alignment attribute    @ref{13.3}(23), see @ref{K}(23), see @ref{K,,K(14)}.
Alignment clause    @ref{13.3}(7), see @ref{13.3}(7), see @ref{13.3,,13.3(25)}.
All_Calls_Remote pragma    @ref{E.2.3}(5), see @ref{L}(5), see @ref{L,,L(2)}.
All_Checks    @ref{11.5}.
Allocate    @ref{13.11}.
allocator    @ref{4.8}.
   used    @ref{4.4}(7), see @ref{P}(7), see @ref{P,,P(1)}.
Alphanumeric    @ref{B.4}.
alphanumeric character
   a category of Character    @ref{A.3.2}.
Alphanumeric_Set    @ref{A.4.6}.
ambiguous    @ref{8.6}.
ampersand @ref{2.1}(15), see @ref{A.3.3}(8)
ampersand operator    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.3,,4.5.3(3)}.
ancestor
   of a library unit    @ref{10.1.1}.
   of a type    @ref{3.4.1}.
   ultimate    @ref{3.4.1}.
ancestor subtype
   of a private_extension_declaration    @ref{7.3}.
   of a formal derived type    @ref{12.5.1}.
ancestor_part    @ref{4.3.2}.
   used    @ref{4.3.2}(2), see @ref{P}(2), see @ref{P,,P(1)}.
and operator    @ref{4.4}(1), see @ref{4.5.1}(1), see @ref{4.5.1,,4.5.1(2)}.
and then (short-circuit control form)    @ref{4.4},
                                         @ref{4.5.1}.
Angle    @ref{12.5}.
angle threshold    @ref{G.2.4}.
Annex
   informative    @ref{1.1.2}.
   normative    @ref{1.1.2}.
   Specialized Needs    @ref{1.1.2}.
anonymous access type    @ref{3.10}.
anonymous array type    @ref{3.3.1}.
anonymous protected type    @ref{3.3.1}.
anonymous task type    @ref{3.3.1}.
anonymous type    @ref{3.2.1}.
Any_Priority    @ref{13.7}(16), see @ref{D.1}(16), see @ref{D.1,,D.1(10)}.
APC    @ref{A.3.3}.
apostrophe    @ref{2.1}(15), see @ref{A.3.3}(15), see @ref{A.3.3,,A.3.3(8)}.
Append    @ref{A.4.4}(13), see @ref{A.4.4}(14), see @ref{A.4.4}(13), see @ref{A.4.4}(14), see @ref{A.4.4,,A.4.4(15)},
          @ref{A.4.4}(16), see @ref{A.4.4}(17), see @ref{A.4.4}(16), see @ref{A.4.4}(17), see @ref{A.4.4,,A.4.4(18)},
          @ref{A.4.4}(19), see @ref{A.4.4}(20), see @ref{A.4.5}(19), see @ref{A.4.4}(20), see @ref{A.4.5,,A.4.5(12)},
          @ref{A.4.5}(13), see @ref{A.4.5}(13), see @ref{A.4.5,,A.4.5(14)}.
applicable index constraint    @ref{4.3.3}.
application areas    @ref{1.1.2}.
apply
   to a loop_statement by an exit_statement    @ref{5.7}.
   to a callable construct by a return_statement    @ref{6.5}.
   to a program unit by a program unit pragma    @ref{10.1.5}.
arbitrary order    @ref{1.1.4}.
Arccos    @ref{A.5.1}(6), see @ref{G.1.2}(6), see @ref{G.1.2,,G.1.2(5)}.
Arccosh    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(7)}.
Arccot    @ref{A.5.1}(6), see @ref{G.1.2}(6), see @ref{G.1.2,,G.1.2(5)}.
Arccoth    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(7)}.
Arcsin @ref{A.5.1}(6), see @ref{G.1.2}(5)
Arcsinh    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(7)}.
Arctan    @ref{A.5.1}(6), see @ref{G.1.2}(6), see @ref{G.1.2,,G.1.2(5)}.
Arctanh    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(7)}.
Argument    @ref{A.15}(5), see @ref{G.1.1}(5), see @ref{G.1.1,,G.1.1(10)}.
argument of a pragma    @ref{2.8}.
Argument_Count    @ref{A.15}.
Argument_Error    @ref{A.5}.
array    @ref{3.6}.
array component expression    @ref{4.3.3}.
array indexing
   See indexed_component    @ref{4.1.1}.
array slice    @ref{4.1.2}.
array type    @ref{3.6}(1), see @ref{N}(1), see @ref{N,,N(4)}.
array_aggregate    @ref{4.3.3}.
   used    @ref{4.3}(2), see @ref{13.4}(3), see @ref{P}(2), see @ref{13.4}(3), see @ref{P,,P(1)}.
array_component_association    @ref{4.3.3}.
   used    @ref{4.3.3}(4), see @ref{P}(4), see @ref{P,,P(1)}.
array_type_definition    @ref{3.6}.
   used    @ref{3.2.1}(4), see @ref{3.3.1}(2), see @ref{12.5.3}(4), see @ref{3.3.1}(2), see @ref{12.5.3,,12.5.3(2)},
           @ref{P}.
ASCII    @ref{A.1}(36), see @ref{J.5}(36), see @ref{J.5,,J.5(2)}.
   package physically nested within the declaration of Standard
         @ref{A.1}.
aspect of representation    @ref{13.1}.
   coding    @ref{13.4}.
   controlled    @ref{13.11.3}.
   convention, calling convention    @ref{B.1}.
   exported    @ref{B.1}.
   imported    @ref{B.1}.
   layout    @ref{13.5}.
   packing    @ref{13.2}.
   record layout    @ref{13.5}.
   specifiable attributes    @ref{13.3}.
   storage place    @ref{13.5}.
assembly language    @ref{C.1}.
assign
   See assignment operation    @ref{5.2}.
assigning back of parameters    @ref{6.4.1}.
assignment
   user-defined    @ref{7.6}.
assignment operation    @ref{5.2}(3), see @ref{5.2}(12), see @ref{7.6}(3), see @ref{5.2}(12), see @ref{7.6,,7.6(13)}.
   during elaboration of an object_declaration    @ref{3.3.1}.
   during evaluation of a generic_association for a formal object
     of mode in @ref{12.4}(11)
   during evaluation of a parameter_association    @ref{6.4.1}.
   during evaluation of an aggregate    @ref{4.3}.
   during evaluation of an initialized allocator    @ref{4.8}.
   during evaluation of an uninitialized allocator    @ref{4.8},
         @ref{4.8}.
   during evaluation of concatenation    @ref{4.5.3}.
   during execution of a for loop    @ref{5.5}.
   during execution of a return_statement    @ref{6.5}.
   during execution of an assignment_statement    @ref{5.2}.
   during parameter copy back    @ref{6.4.1}.
assignment_statement    @ref{5.2}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
associated components
   of a record_component_association    @ref{4.3.1}.
associated discriminants
   of a named discriminant_association    @ref{3.7.1}.
   of a positional discriminant_association    @ref{3.7.1}.
associated object
   of a value of a by-reference type    @ref{6.2}.
asterisk    @ref{2.1}(15), see @ref{A.3.3}(15), see @ref{A.3.3,,A.3.3(8)}.
asynchronous
   remote procedure call    @ref{E.4.1}.
Asynchronous pragma    @ref{E.4.1}(3), see @ref{L}(3), see @ref{L,,L(3)}.
asynchronous remote procedure call    @ref{E.4}.
asynchronous_select    @ref{9.7.4}.
   used    @ref{9.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Asynchronous_Task_Control
   child of Ada    @ref{D.11}.
at-most-once execution    @ref{E.4}.
at_clause    @ref{J.7}.
   used    @ref{13.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
atomic    @ref{C.6}.
Atomic pragma    @ref{C.6}(3), see @ref{L}(3), see @ref{L,,L(4)}.
Atomic_Components pragma    @ref{C.6}(5), see @ref{L}(5), see @ref{L,,L(5)}.
Attach_Handler    @ref{C.3.2}.
Attach_Handler pragma    @ref{C.3.1}, L(6)
attaching
   to an interrupt    @ref{C.3}.
attribute    @ref{4.1.4}(1), see @ref{C.7.2}(2), see @ref{K}(1), see @ref{C.7.2}(2), see @ref{K,,K(1)}.
   representation    @ref{13.3}.
   specifiable    @ref{13.3}.
   specifying    @ref{13.3}.
attribute_definition_clause    @ref{13.3}.
   used    @ref{13.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
attribute_designator    @ref{4.1.4}.
   used    @ref{4.1.4}(2), see @ref{13.1}(3), see @ref{13.3}(2), see @ref{13.1}(3), see @ref{13.3,,13.3(2)},
           @ref{P}.
Attribute_Handle    @ref{C.7.2}.
attribute_reference    @ref{4.1.4}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
attributes
   Access    @ref{3.10.2}(24), see @ref{3.10.2}(32), see @ref{K}(24), see @ref{3.10.2}(32), see @ref{K,,K(2)},
             @ref{K}.
   Address    @ref{13.3}(11), see @ref{J.7.1}(5), see @ref{K}(11), see @ref{J.7.1}(5), see @ref{K,,K(6)}.
   Adjacent    @ref{A.5.3}(48), see @ref{K}(48), see @ref{K,,K(8)}.
   Aft    @ref{3.5.10}(5), see @ref{K}(5), see @ref{K,,K(12)}.
   Alignment    @ref{13.3}(23), see @ref{K}(23), see @ref{K,,K(14)}.
   Base    @ref{3.5}(15), see @ref{K}(15), see @ref{K,,K(17)}.
   Bit_Order    @ref{13.5.3}(4), see @ref{K}(4), see @ref{K,,K(19)}.
   Body_Version    @ref{E.3}(4), see @ref{K}(4), see @ref{K,,K(21)}.
   Callable    @ref{9.9}(2), see @ref{K}(2), see @ref{K,,K(23)}.
   Caller    @ref{C.7.1}(14), see @ref{K}(14), see @ref{K,,K(25)}.
   Ceiling    @ref{A.5.3}(33), see @ref{K}(33), see @ref{K,,K(27)}.
   Class    @ref{3.9}(14), see @ref{7.3.1}(9), see @ref{K}(14), see @ref{7.3.1}(9), see @ref{K,,K(31)},
            @ref{K}.
   Component_Size    @ref{13.3}(69), see @ref{K}(69), see @ref{K,,K(36)}.
   Compose    @ref{A.5.3}(24), see @ref{K}(24), see @ref{K,,K(38)}.
   Constrained    @ref{3.7.2}(3), see @ref{J.4}(2), see @ref{K}(3), see @ref{J.4}(2), see @ref{K,,K(42)}.
   Copy_Sign    @ref{A.5.3}(51), see @ref{K}(51), see @ref{K,,K(44)}.
   Count    @ref{9.9}(5), see @ref{K}(5), see @ref{K,,K(48)}.
   Definite    @ref{12.5.1}(23), see @ref{K}(23), see @ref{K,,K(50)}.
   Delta    @ref{3.5.10}(3), see @ref{K}(3), see @ref{K,,K(52)}.
   Denorm    @ref{A.5.3}(9), see @ref{K}(9), see @ref{K,,K(54)}.
   Digits    @ref{3.5.8}(2), see @ref{3.5.10}(7), see @ref{K}(2), see @ref{3.5.10}(7), see @ref{K,,K(56)},
             @ref{K}.
   Exponent    @ref{A.5.3}(18), see @ref{K}(18), see @ref{K,,K(60)}.
   External_Tag    @ref{13.3}(75), see @ref{K}(75), see @ref{K,,K(64)}.
   First    @ref{3.5}(12), see @ref{3.6.2}(3), see @ref{K}(12), see @ref{3.6.2}(3), see @ref{K,,K(68)},
            @ref{K}.
   First(N)    @ref{3.6.2}(4), see @ref{K}(4), see @ref{K,,K(66)}.
   First_Bit    @ref{13.5.2}(3), see @ref{K}(3), see @ref{K,,K(72)}.
   Floor    @ref{A.5.3}(30), see @ref{K}(30), see @ref{K,,K(74)}.
   Fore    @ref{3.5.10}(4), see @ref{K}(4), see @ref{K,,K(78)}.
   Fraction    @ref{A.5.3}(21), see @ref{K}(21), see @ref{K,,K(80)}.
   Identity    @ref{11.4.1}(9), see @ref{C.7.1}(12), see @ref{K}(9), see @ref{C.7.1}(12), see @ref{K,,K(84)},
               @ref{K}.
   Image    @ref{3.5}(35), see @ref{K}(35), see @ref{K,,K(88)}.
   Input    @ref{13.13.2}(22), see @ref{13.13.2}(32), see @ref{K}(22), see @ref{13.13.2}(32), see @ref{K,,K(92)},
            @ref{K}.
   Last    @ref{3.5}(13), see @ref{3.6.2}(5), see @ref{K}(13), see @ref{3.6.2}(5), see @ref{K,,K(102)},
           @ref{K}.
   Last(N)    @ref{3.6.2}(6), see @ref{K}(6), see @ref{K,,K(100)}.
   Last_Bit    @ref{13.5.2}(4), see @ref{K}(4), see @ref{K,,K(106)}.
   Leading_Part    @ref{A.5.3}(54), see @ref{K}(54), see @ref{K,,K(108)}.
   Length    @ref{3.6.2}(9), see @ref{K}(9), see @ref{K,,K(117)}.
   Length(N)    @ref{3.6.2}(10), see @ref{K}(10), see @ref{K,,K(115)}.
   Machine    @ref{A.5.3}(60), see @ref{K}(60), see @ref{K,,K(119)}.
   Machine_Emax    @ref{A.5.3}(8), see @ref{K}(8), see @ref{K,,K(123)}.
   Machine_Emin @ref{A.5.3}(7), see @ref{K}(125)
   Machine_Mantissa    @ref{A.5.3}(6), see @ref{K}(6), see @ref{K,,K(127)}.
   Machine_Overflows    @ref{A.5.3}(12), see @ref{A.5.4}(12), see @ref{A.5.4,,A.5.4(4)},
                        @ref{K}(129),     @ref{K}(129),     @ref{K,,K(131)}.
   Machine_Radix    @ref{A.5.3}(2), see @ref{A.5.4}(2), see @ref{K}(2), see @ref{A.5.4}(2), see @ref{K,,K(133)},
                    @ref{K}.
   Machine_Rounds    @ref{A.5.3}(11), see @ref{A.5.4}(11), see @ref{A.5.4,,A.5.4(3)},
                     @ref{K}(137),     @ref{K}(137),     @ref{K,,K(139)}.
   Max    @ref{3.5}(19), see @ref{K}(19), see @ref{K,,K(141)}.
   Max_Size_In_Storage_Elements    @ref{13.11.1}(3), see @ref{K}(3), see @ref{K,,K(145)}.
   Min @ref{3.5}(16), see @ref{K}(147)
   Model    @ref{A.5.3}(68), see @ref{G.2.2}(7), see @ref{K}(68), see @ref{G.2.2}(7), see @ref{K,,K(151)}.
   Model_Emin @ref{A.5.3}(65), see @ref{G.2.2}(4), see @ref{K}(155)
   Model_Epsilon    @ref{A.5.3}(66), see @ref{K}(66), see @ref{K,,K(157)}.
   Model_Mantissa    @ref{A.5.3}(64), see @ref{G.2.2}(3), see @ref{K}(64), see @ref{G.2.2}(3), see @ref{K,,K(159)}.
   Model_Small    @ref{A.5.3}(67), see @ref{K}(67), see @ref{K,,K(161)}.
   Modulus    @ref{3.5.4}(17), see @ref{K}(17), see @ref{K,,K(163)}.
   Output    @ref{13.13.2}(19), see @ref{13.13.2}(29), see @ref{K}(19), see @ref{13.13.2}(29), see @ref{K,,K(165)},
             @ref{K}.
   Partition_ID    @ref{E.1}(9), see @ref{K}(9), see @ref{K,,K(173)}.
   Pos    @ref{3.5.5}(2), see @ref{K}(2), see @ref{K,,K(175)}.
   Position    @ref{13.5.2}(2), see @ref{K}(2), see @ref{K,,K(179)}.
   Pred    @ref{3.5}(25), see @ref{K}(25), see @ref{K,,K(181)}.
   Range    @ref{3.5}(14), see @ref{3.6.2}(7), see @ref{K}(14), see @ref{3.6.2}(7), see @ref{K,,K(187)},
            @ref{K}.
   Range(N)    @ref{3.6.2}(8), see @ref{K}(8), see @ref{K,,K(185)}.
   Read    @ref{13.13.2}(6), see @ref{13.13.2}(14), see @ref{K}(6), see @ref{13.13.2}(14), see @ref{K,,K(191)},
           @ref{K}.
   Remainder    @ref{A.5.3}(45), see @ref{K}(45), see @ref{K,,K(199)}.
   Round    @ref{3.5.10}(12), see @ref{K}(12), see @ref{K,,K(203)}.
   Rounding    @ref{A.5.3}(36), see @ref{K}(36), see @ref{K,,K(207)}.
   Safe_First    @ref{A.5.3}(71), see @ref{G.2.2}(5), see @ref{K}(71), see @ref{G.2.2}(5), see @ref{K,,K(211)}.
   Safe_Last    @ref{A.5.3}(72), see @ref{G.2.2}(6), see @ref{K}(72), see @ref{G.2.2}(6), see @ref{K,,K(213)}.
   Scale    @ref{3.5.10}(11), see @ref{K}(11), see @ref{K,,K(215)}.
   Scaling    @ref{A.5.3}(27), see @ref{K}(27), see @ref{K,,K(217)}.
   Signed_Zeros    @ref{A.5.3}(13), see @ref{K}(13), see @ref{K,,K(221)}.
   Size    @ref{13.3}(40), see @ref{13.3}(45), see @ref{K}(40), see @ref{13.3}(45), see @ref{K,,K(223)},
           @ref{K}.
   Small    @ref{3.5.10}(2), see @ref{K}(2), see @ref{K,,K(230)}.
   Storage_Pool    @ref{13.11}(13), see @ref{K}(13), see @ref{K,,K(232)}.
   Storage_Size    @ref{13.3}(60), see @ref{13.11}(14), see @ref{J.9}(60), see @ref{13.11}(14), see @ref{J.9,,J.9(2)},
                   @ref{K}(234), see @ref{K}(234), see @ref{K,,K(236)}.
   Succ    @ref{3.5}(22), see @ref{K}(22), see @ref{K,,K(238)}.
   Tag    @ref{3.9}(16), see @ref{3.9}(18), see @ref{K}(16), see @ref{3.9}(18), see @ref{K,,K(242)},
          @ref{K}.
   Terminated    @ref{9.9}(3), see @ref{K}(3), see @ref{K,,K(246)}.
   Truncation    @ref{A.5.3}(42), see @ref{K}(42), see @ref{K,,K(248)}.
   Unbiased_Rounding    @ref{A.5.3}(39), see @ref{K}(39), see @ref{K,,K(252)}.
   Unchecked_Access    @ref{13.10}(3), see @ref{H.4}(18), see @ref{K}(3), see @ref{H.4}(18), see @ref{K,,K(256)}.
   Val    @ref{3.5.5}(5), see @ref{K}(5), see @ref{K,,K(258)}.
   Valid    @ref{13.9.2}(3), see @ref{H}(6), see @ref{K}(3), see @ref{H}(6), see @ref{K,,K(262)}.
   Value    @ref{3.5}(52), see @ref{K}(52), see @ref{K,,K(264)}.
   Version    @ref{E.3}(3), see @ref{K}(3), see @ref{K,,K(268)}.
   Wide_Image    @ref{3.5}(28), see @ref{K}(28), see @ref{K,,K(270)}.
   Wide_Value    @ref{3.5}(40), see @ref{K}(40), see @ref{K,,K(274)}.
   Wide_Width    @ref{3.5}(38), see @ref{K}(38), see @ref{K,,K(278)}.
   Width    @ref{3.5}(39), see @ref{K}(39), see @ref{K,,K(280)}.
   Write    @ref{13.13.2}(3), see @ref{13.13.2}(11), see @ref{K}(3), see @ref{13.13.2}(11), see @ref{K,,K(282)},
            @ref{K}.
@end format

@c ---------------------------------------------------------------------------
@node Index.B, Index.C, Index.A, Index
@chapter index

@format
Backus-Naur Form (BNF)
   complete listing    @ref{P}.
   cross reference    @ref{P}.
   notation    @ref{1.1.4}.
   under Syntax heading    @ref{1.1.2}.
base    @ref{2.4.2}(3), see @ref{2.4.2}(3), see @ref{2.4.2,,2.4.2(6)}.
base 16 literal    @ref{2.4.2}.
   used    @ref{2.4.2}(2), see @ref{P}(2), see @ref{P,,P(1)}.
base 2 literal    @ref{2.4.2}.
base 8 literal    @ref{2.4.2}.
Base attribute    @ref{3.5}(15), see @ref{K}(15), see @ref{K,,K(17)}.
base decimal precision
   of a floating point type    @ref{3.5.7}(9), see @ref{3.5.7}(9), see @ref{3.5.7,,3.5.7(10)}.
base priority    @ref{D.1}.
base range
   of a decimal fixed point type    @ref{3.5.9}.
   of a fixed point type    @ref{3.5.9}.
   of a floating point type    @ref{3.5.7}(8), see @ref{3.5.7}(8), see @ref{3.5.7,,3.5.7(10)}.
   of a modular type    @ref{3.5.4}.
   of a scalar type    @ref{3.5}.
   of a signed integer type    @ref{3.5.4}.
   of an ordinary fixed point type    @ref{3.5.9}.
base subtype
   of a type    @ref{3.5}.
based_literal    @ref{2.4.2}.
   used    @ref{2.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
based_numeral    @ref{2.4.2}.
   used    @ref{2.4.2}(2), see @ref{P}(2), see @ref{P,,P(1)}.
basic letter
   a category of Character    @ref{A.3.2}.
basic_declaration    @ref{3.1}.
   used    @ref{3.11}(4), see @ref{P}(4), see @ref{P,,P(1)}.
basic_declarative_item    @ref{3.11}.
   used    @ref{3.11}(3), see @ref{7.1}(3), see @ref{P}(3), see @ref{7.1}(3), see @ref{P,,P(1)}.
Basic_Map    @ref{A.4.6}.
Basic_Set    @ref{A.4.6}.
become nonlimited    @ref{7.3.1}(5), see @ref{7.5}(5), see @ref{7.5,,7.5(16)}.
BEL    @ref{A.3.3}.
belong
   to a range    @ref{3.5}.
   to a subtype    @ref{3.2}.
Bias    @ref{12.2}.
bibliography    @ref{1.2}.
big endian    @ref{13.5.3}.
binary    @ref{B.4}.
   literal    @ref{2.4.2}.
binary adding operator    @ref{4.5.3}.
binary literal    @ref{2.4.2}.
binary operator    @ref{4.5}.
binary_adding_operator    @ref{4.5}.
   used    @ref{4.4}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Binary_Format    @ref{B.4}.
Binary_Operation    @ref{3.9.1}.
Binop_Ptr    @ref{3.10}.
bit field
   See record_representation_clause    @ref{13.5.1}.
bit ordering    @ref{13.5.3}.
bit string
   See logical operators on boolean arrays    @ref{4.5.1}.
Bit_Order    @ref{13.7}.
Bit_Order attribute    @ref{13.5.3}(4), see @ref{K}(4), see @ref{K,,K(19)}.
Bit_Order clause    @ref{13.3}(7), see @ref{13.5.3}(7), see @ref{13.5.3,,13.5.3(4)}.
Bit_Vector    @ref{3.6}.
blank
   in text input for enumeration and numeric types   @ref{A.10.6}.
block_statement    @ref{5.6}.
   used    @ref{5.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
blocked
   [partial]    @ref{D.2.1}.
   a task state    @ref{9}.
   during an entry call    @ref{9.5.3}.
   execution of a selective_accept    @ref{9.7.1}.
   on a delay_statement    @ref{9.6}.
   on an accept_statement    @ref{9.5.2}.
   waiting for activations to complete    @ref{9.2}.
   waiting for dependents to terminate    @ref{9.3}.
blocked interrupt    @ref{C.3}.
blocking, potentially   .see @ref{9.5.1}(8)
   Abort_Task    @ref{C.7.1}.
   delay_statement    @ref{9.6}(34), see @ref{D.9}(34), see @ref{D.9,,D.9(5)}.
   remote subprogram call    @ref{E.4}.
   RPC operations    @ref{E.5}.
   Suspend_Until_True    @ref{D.10}.
BMP    @ref{3.5.2}(2), see @ref{3.5.2}(2), see @ref{3.5.2,,3.5.2(3)}.
BNF (Backus-Naur Form)
   complete listing    @ref{P}.
   cross reference    @ref{P}.
   notation    @ref{1.1.4}.
   under Syntax heading    @ref{1.1.2}.
body    @ref{3.11}.
   used    @ref{3.11}(3), see @ref{P}(3), see @ref{P,,P(1)}.
body_stub    @ref{10.1.3}.
   used    @ref{3.11}(5), see @ref{P}(5), see @ref{P,,P(1)}.
Body_Version attribute    @ref{E.3}(4), see @ref{K}(4), see @ref{K,,K(21)}.
Boolean    @ref{3.5.3}(1), see @ref{A.1}(1), see @ref{A.1,,A.1(5)}.
boolean type    @ref{3.5.3}.
Bounded
   child of Ada.Strings    @ref{A.4.4}.
bounded error    @ref{1.1.2}(31),    @ref{1.1.5}(8),   @ref{6.2}(31),    @ref{1.1.5}(8),   @ref{6.2,,6.2(12)},
                 @ref{7.6.1}(14),    @ref{9.5.1}(8),   @ref{9.8}(14),    @ref{9.5.1}(8),   @ref{9.8,,9.8(20)},
                 @ref{10.2}(26),     @ref{13.9.1}(26),     @ref{13.9.1,,13.9.1(9)},
                 @ref{13.11.2}(11), see @ref{C.7.1}(17), see @ref{D.5}(11), see @ref{C.7.1}(17), see @ref{D.5,,D.5(11)},
                 @ref{E.1}(10),      @ref{E.3}(6),     @ref{J.7.1}(10),      @ref{E.3}(6),     @ref{J.7.1,,J.7.1(11)}.
Bounded_String    @ref{A.4.4}.
bounds
   of a discrete_range    @ref{3.6.1}.
   of an array    @ref{3.6}.
   of the index range of an array_aggregate    @ref{4.3.3}.
box
   compound delimiter    @ref{3.6}.
broadcast signal
   See protected object    @ref{9.4}.
   See requeue    @ref{9.5.4}.
Broken_Bar    @ref{A.3.3}.
BS    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
Buffer    @ref{3.7}(33), see @ref{9.11}(8), see @ref{9.11}(33), see @ref{9.11}(8), see @ref{9.11,,9.11(9)},
          @ref{12.5}.
Buffer_Size    @ref{3.5.4}(35), see @ref{A.9}(35), see @ref{A.9,,A.9(4)}.
Buffer_Type    @ref{A.9}.
by copy parameter passing    @ref{6.2}.
by reference parameter passing    @ref{6.2}.
by-copy type    @ref{6.2}.
by-reference type    @ref{6.2}.
   atomic or volatile    @ref{C.6}.
Byte    @ref{3.5.4}(36), see @ref{13.3}(80), see @ref{B.4}(36), see @ref{13.3}(80), see @ref{B.4,,B.4(29)}.
   See storage element    @ref{13.3}.
byte sex
   See ordering of storage elements in a word    @ref{13.5.3}.
Byte_Array    @ref{B.4}.
Byte_Mask    @ref{13.5.1}.
@end format

@c ---------------------------------------------------------------------------
@node Index.C, Index.D, Index.B, Index
@chapter index

@format
C    @ref{4.3.3}(42), see @ref{B.3}(77), see @ref{B.3.2}(42), see @ref{B.3}(77), see @ref{B.3.2,,B.3.2(46)}.
   child of Interfaces    @ref{B.3}.
C interface    @ref{B.3}.
C standard    @ref{1.2}.
C_float    @ref{B.3}.
Calendar    @ref{J.1}.
   child of Ada    @ref{9.6}.
call    @ref{6}.
call on a dispatching operation    @ref{3.9.2}.
callable    @ref{9.9}.
Callable attribute    @ref{9.9}(2), see @ref{K}(2), see @ref{K,,K(23)}.
callable construct    @ref{6}.
callable entity    @ref{6}.
called partition    @ref{E.4}.
Caller attribute    @ref{C.7.1}(14), see @ref{K}(14), see @ref{K,,K(25)}.
calling convention    @ref{6.3.1}(2), see @ref{B.1}(2), see @ref{B.1,,B.1(11)}.
   Ada    @ref{6.3.1}.
   associated with a designated profile    @ref{3.10}.
   entry    @ref{6.3.1}.
   Intrinsic    @ref{6.3.1}.
   protected    @ref{6.3.1}.
calling partition    @ref{E.4}.
calling stub    @ref{E.4}.
CAN    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
cancellation
   of a delay_statement    @ref{9.6}.
   of an entry call    @ref{9.5.3}.
cancellation of a remote subprogram call    @ref{E.4}.
canonical form    @ref{A.5.3}.
canonical semantics    @ref{11.6}.
canonical-form representation    @ref{A.5.3}.
Car    @ref{3.10.1}(19), see @ref{3.10.1}(21), see @ref{12.5.4}(19), see @ref{3.10.1}(21), see @ref{12.5.4,,12.5.4(10)},
      @ref{12.5.4}.
Car_Name    @ref{3.10.1}(20), see @ref{12.5.4}(20), see @ref{12.5.4,,12.5.4(10)}.
case insensitive    @ref{2.3}.
case_statement    @ref{5.4}.
   used    @ref{5.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
case_statement_alternative    @ref{5.4}.
   used    @ref{5.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
cast
   See type conversion    @ref{4.6}.
   See unchecked type conversion    @ref{13.9}.
catch (an exception)
   See handle    @ref{11}.
categorization pragma    @ref{E.2}.
   Remote_Call_Interface    @ref{E.2.3}.
   Remote_Types    @ref{E.2.2}.
   Shared_Passive    @ref{E.2.1}.
categorized library unit    @ref{E.2}.
catenation operator
   See concatenation operator    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.3,,4.5.3(3)}.
CCH    @ref{A.3.3}.
Cedilla    @ref{A.3.3}.
Ceiling attribute    @ref{A.5.3}(33), see @ref{K}(33), see @ref{K,,K(27)}.
ceiling priority
   of a protected object    @ref{D.3}.
Ceiling_Check
   [partial]    @ref{C.3.1}(11), see @ref{D.3}(11), see @ref{D.3,,D.3(13)}.
Cell    @ref{3.10.1}(15), see @ref{3.10.1}(15), see @ref{3.10.1,,3.10.1(16)}.
Cent_Sign    @ref{A.3.3}.
change of representation    @ref{13.6}.
char    @ref{B.3}.
char_array    @ref{B.3}.
CHAR_BIT    @ref{B.3}.
Char_Ptrs    @ref{B.3.2}.
Char_Star    @ref{B.3.2}.
Char_IO    @ref{A.10.10}.
character    @ref{2.1}(2), see @ref{3.5.2}(2), see @ref{A.1}(2), see @ref{3.5.2}(2), see @ref{A.1,,A.1(35)}.
   used    @ref{2.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
character set    @ref{2.1}.
character set standard
   16-bit    @ref{1.2}.
   7-bit     @ref{1.2}.
   8-bit     @ref{1.2}.
   control functions    @ref{1.2}.
character type    @ref{3.5.2}(1), see @ref{N}(1), see @ref{N,,N(5)}.
character_literal    @ref{2.5}.
   used    @ref{3.5.1}(4), see @ref{4.1}(2), see @ref{4.1.3}(4), see @ref{4.1}(2), see @ref{4.1.3,,4.1.3(3)},
           @ref{P}.
Character_Mapping    @ref{A.4.2}.
Character_Mapping_Function    @ref{A.4.2}.
Character_Range    @ref{A.4.2}.
Character_Ranges    @ref{A.4.2}.
Character_Sequence    @ref{A.4.2}.
Character_Set    @ref{A.4.2}(4), see @ref{A.4.7}(46), see @ref{B.5}(4), see @ref{A.4.7}(46), see @ref{B.5,,B.5(11)}.
characteristics    @ref{7.3}.
Characters
   child of Ada    @ref{A.3.1}.
chars_ptr    @ref{B.3.1}.
check
   language-defined    @ref{11.5}(2), see @ref{11.6}(2), see @ref{11.6,,11.6(1)}.
check, language-defined
   Access_Check    @ref{4.1}(13), see @ref{4.6}(13), see @ref{4.6,,4.6(49)}.
   Accessibility_Check    @ref{3.10.2}(29), see @ref{4.6}(29), see @ref{4.6,,4.6(48)},
         @ref{6.5}(17), see @ref{E.4}(17), see @ref{E.4,,E.4(18)}.
   Ceiling_Check    @ref{C.3.1}(11), see @ref{D.3}(11), see @ref{D.3,,D.3(13)}.
   Discriminant_Check    @ref{4.1.3}(15), see @ref{4.3}(15), see @ref{4.3,,4.3(6)},
                         @ref{4.3.2}(8),   @ref{4.6}(8),   @ref{4.6,,4.6(43)},
                         @ref{4.6}(45),    @ref{4.6}(45),    @ref{4.6,,4.6(51)},
                         @ref{4.6}(52),    @ref{4.7}(52),    @ref{4.7,,4.7(4)},
                         @ref{4.8}.
   Division_Check    @ref{3.5.4}(20), see @ref{4.5.5}(20), see @ref{4.5.5,,4.5.5(22)},
                     @ref{A.5.1}(28), see @ref{A.5.3}(28), see @ref{A.5.3,,A.5.3(47)},
                     @ref{G.1.1}(40), see @ref{G.1.2}(40), see @ref{G.1.2,,G.1.2(28)},
                     @ref{K}.
   Elaboration_Check    @ref{3.11}.
   Index_Check    @ref{4.1.1}(7),   @ref{4.1.2}(7), see @ref{4.3.3}(7),   @ref{4.1.2}(7), see @ref{4.3.3,,4.3.3(29)},
                  @ref{4.3.3}(30), see @ref{4.5.3}(8), see @ref{4.6}(30), see @ref{4.5.3}(8), see @ref{4.6,,4.6(51)},
                  @ref{4.7}(4),     @ref{4.8}(4),     @ref{4.8,,4.8(10)}.
   Length_Check    @ref{4.5.1}(8), see @ref{4.6}(37), see @ref{4.6}(8), see @ref{4.6}(37), see @ref{4.6,,4.6(52)}.
   Overflow_Check    @ref{3.5.4}(20), see @ref{4.4}(20), see @ref{4.4,,4.4(11)},
                     @ref{5.4}(13),    @ref{G.2.1}(13),    @ref{G.2.1,,G.2.1(11)},
                     @ref{G.2.2}(7),   @ref{G.2.3}(7),   @ref{G.2.3,,G.2.3(25)},
                     @ref{G.2.4}(2),   @ref{G.2.6}(2),   @ref{G.2.6,,G.2.6(3)}.
   Partition_Check   E.4(19)
   Range_Check    @ref{3.2.2}(11), see @ref{3.5}(11), see @ref{3.5,,3.5(24)},
                  @ref{3.5}(27),    @ref{3.5}(27),    @ref{3.5,,3.5(43)},
                  @ref{3.5}(44),    @ref{3.5}(44),    @ref{3.5,,3.5(51)},
                  @ref{3.5}(55),    @ref{3.5.5}(55),    @ref{3.5.5,,3.5.5(7)},
                  @ref{3.5.9}(19), see @ref{4.2}(19), see @ref{4.2,,4.2(11)},
                  @ref{4.3.3}(28), see @ref{4.5.1}(28), see @ref{4.5.1,,4.5.1(8)},
                  @ref{4.5.6}(6),   @ref{4.5.6}(6),   @ref{4.5.6,,4.5.6(13)},
                  @ref{4.6}(28),    @ref{4.6}(28),    @ref{4.6,,4.6(38)},
                  @ref{4.6}(46),    @ref{4.6}(46),    @ref{4.6,,4.6(51)},
                  @ref{4.7}(4),     @ref{13.13.2}(4),     @ref{13.13.2,,13.13.2(35)},
                  @ref{A.5.2}(39), see @ref{A.5.2}(39), see @ref{A.5.2,,A.5.2(40)},
                  @ref{A.5.3}(26), see @ref{A.5.3}(26), see @ref{A.5.3,,A.5.3(29)},
                  @ref{A.5.3}(50), see @ref{A.5.3}(50), see @ref{A.5.3,,A.5.3(53)},
                  @ref{A.5.3}(59), see @ref{A.5.3}(59), see @ref{A.5.3,,A.5.3(62)},
                  @ref{K}(11),      @ref{K}(11),      @ref{K,,K(41)},
                  @ref{K}(47),      @ref{K}(47),      @ref{K,,K(114)},
                  @ref{K}(122),     @ref{K}(122),     @ref{K,,K(184)},
                  @ref{K}(220),     @ref{K}(220),     @ref{K,,K(241)}.
   Reserved_Check    @ref{C.3.1}.
   Storage_Check    @ref{11.1}(6),    @ref{13.3}(6),    @ref{13.3,,13.3(67)},
                    @ref{13.11}(17), see @ref{D.7}(17), see @ref{D.7,,D.7(15)}.
   Tag_Check    @ref{3.9.2}(16), see @ref{4.6}(42), see @ref{4.6}(16), see @ref{4.6}(42), see @ref{4.6,,4.6(52)},
                @ref{5.2}(10),    @ref{6.5}(10),    @ref{6.5,,6.5(9)}.
child
   of a library unit    @ref{10.1.1}.
choice parameter    @ref{11.2}.
choice_parameter_specification    @ref{11.2}.
   used    @ref{11.2}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Circumflex    @ref{A.3.3}.
class    @ref{N}.
   See also package    @ref{7}.
   See also tag    @ref{3.9}.
   of types    @ref{3.2}.
Class attribute    @ref{3.9}(14), see @ref{7.3.1}(9), see @ref{K}(14), see @ref{7.3.1}(9), see @ref{K,,K(31)},
                   @ref{K}.
class determined for a formal type    @ref{12.5}.
class-wide type    @ref{3.4.1}(4), see @ref{3.7}(4), see @ref{3.7,,3.7(26)}.
cleanup
   See finalization    @ref{7.6.1}.
clock    @ref{9.6}(6), see @ref{9.6}(12), see @ref{D.8}(6), see @ref{9.6}(12), see @ref{D.8,,D.8(7)}.
clock jump    @ref{D.8}.
clock tick    @ref{D.8}.
Close    @ref{7.5}(19),   @ref{7.5}(20),     @ref{A.8.1}(19),   @ref{7.5}(20),     @ref{A.8.1,,A.8.1(8)},
         @ref{A.8.4}(8), see @ref{A.10.1}(11), see @ref{A.12.1}(8), see @ref{A.10.1}(11), see @ref{A.12.1,,A.12.1(10)}.
close result set    @ref{G.2.3}.
closed entry    @ref{9.5.3}.
   of a protected object    @ref{9.5.3}.
   of a task    @ref{9.5.3}.
closed under derivation    @ref{3.4}(28), see @ref{N}(6), see @ref{N}(28), see @ref{N}(6), see @ref{N,,N(41)}.
closure
   downward    @ref{3.10.2}.
COBOL    @ref{B.4}(104), see @ref{B.4}(104), see @ref{B.4,,B.4(113)}.
   child of Interfaces    @ref{B.4}.
COBOL interface    @ref{B.4}.
COBOL standard    @ref{1.2}.
COBOL_Character    @ref{B.4}.
COBOL_Employee_Record_Type    @ref{B.4}.
COBOL_Employee_IO    @ref{B.4}.
COBOL_Record    @ref{B.4}.
Code    @ref{4.7}.
code_statement    @ref{13.8}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
coding
   aspect of representation    @ref{13.4}.
Coefficient    @ref{3.5.7}.
Coin @ref{A.5.2}(58)
Col    @ref{A.10.1}.
colon    @ref{2.1}(15), see @ref{A.3.3}(10), see @ref{J.5}(15), see @ref{A.3.3}(10), see @ref{J.5,,J.5(6)}.
Color    @ref{3.2.1}(15), see @ref{3.5.1}(15), see @ref{3.5.1,,3.5.1(14)}.
Column    @ref{3.2.1}.
column number    @ref{A.10}.
Column_Ptr    @ref{3.5.4}.
comma    @ref{2.1}(15), see @ref{A.3.3}(15), see @ref{A.3.3,,A.3.3(8)}.
Command_Line
   child of Ada    @ref{A.15}.
Command_Name    @ref{A.15}.
comment    @ref{2.7}.
comments, instructions for submission    @ref{Introduction}.
Commercial_At    @ref{A.3.3}.
Communication_Error    @ref{E.5}.
comparison operator
   See relational operator    @ref{4.5.2}.
compatibility
   composite_constraint with an access subtype    @ref{3.10}.
   constraint with a subtype    @ref{3.2.2}.
   delta_constraint with an ordinary fixed point subtype
         @ref{J.3}.
   digits_constraint with a decimal fixed point subtype
         @ref{3.5.9}.
   digits_constraint with a floating point subtype    @ref{J.3}.
   discriminant constraint with a subtype    @ref{3.7.1}.
   index constraint with a subtype    @ref{3.6.1}.
   range with a scalar subtype    @ref{3.5}.
   range_constraint with a scalar subtype    @ref{3.5}.
compatible
   a type, with a convention    @ref{B.1}.
compilation    @ref{10.1.1}.
   separate    @ref{10.1}.
Compilation unit    @ref{10.1}(2), see @ref{10.1.1}(9), see @ref{N}(2), see @ref{10.1.1}(9), see @ref{N,,N(7)}.
compilation units needed
   by a compilation unit    @ref{10.2}.
   remote call interface    @ref{E.2.3}.
   shared passive library unit    @ref{E.2.1}.
compilation_unit    @ref{10.1.1}.
   used    @ref{10.1.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
compile-time error    @ref{1.1.2}(27), see @ref{1.1.5}(27), see @ref{1.1.5,,1.1.5(4)}.
compile-time semantics    @ref{1.1.2}.
complete context    @ref{8.6}.
completely defined    @ref{3.11.1}.
completion
   abnormal    @ref{7.6.1}.
   compile-time concept    @ref{3.11.1}.
   normal    @ref{7.6.1}.
   run-time concept    @ref{7.6.1}.
completion and leaving (completed and left)    @ref{7.6.1}.
completion legality
   entry_body    @ref{9.5.2}.
      [partial]    @ref{3.10.1}.
Complex    @ref{3.8}(28), see @ref{B.5}(9), see @ref{G.1.1}(28), see @ref{B.5}(9), see @ref{G.1.1,,G.1.1(3)}.
Complex_Elementary_Functions
   child of Ada.Numerics    @ref{G.1.2}.
Complex_Types
   child of Ada.Numerics    @ref{G.1.1}.
Complex_IO
   child of Ada.Text_IO    @ref{G.1.3}.
   child of Ada.Wide_Text_IO    @ref{G.1.4}.
component    @ref{3.2}(2), see @ref{9.4}(31), see @ref{9.4}(2), see @ref{9.4}(31), see @ref{9.4,,9.4(32)}.
component subtype    @ref{3.6}.
component_choice_list    @ref{4.3.1}.
   used    @ref{4.3.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
component_clause    @ref{13.5.1}.
   used    @ref{13.5.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
component_declaration    @ref{3.8}.
   used    @ref{3.8}(5), see @ref{9.4}(6), see @ref{P}(5), see @ref{9.4}(6), see @ref{P,,P(1)}.
component_definition    @ref{3.6}.
   used    @ref{3.6}(3), see @ref{3.6}(5), see @ref{3.8}(6), see @ref{P}(3), see @ref{3.6}(5), see @ref{3.8}(6), see @ref{P,,P(1)}.
component_item    @ref{3.8}.
   used    @ref{3.8}(4), see @ref{P}(4), see @ref{P,,P(1)}.
component_list    @ref{3.8}.
   used    @ref{3.8}(3), see @ref{3.8.1}(3), see @ref{P}(3), see @ref{3.8.1}(3), see @ref{P,,P(1)}.
Component_Size attribute    @ref{13.3}(69), see @ref{K}(69), see @ref{K,,K(36)}.
Component_Size clause    @ref{13.3}(7), see @ref{13.3}(7), see @ref{13.3,,13.3(70)}.
components
   of a record type    @ref{3.8}.
Compose attribute    @ref{A.5.3}(24), see @ref{K}(24), see @ref{K,,K(38)}.
Compose_From_Cartesian    @ref{G.1.1}.
Compose_From_Polar    @ref{G.1.1}.
composite type    @ref{3.2}(2), see @ref{N}(2), see @ref{N,,N(8)}.
composite_constraint    @ref{3.2.2}.
   used    @ref{3.2.2}(5), see @ref{P}(5), see @ref{P,,P(1)}.
compound delimiter    @ref{2.2}.
compound_statement    @ref{5.1}.
   used    @ref{5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
concatenation operator    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.3,,4.5.3(3)}.
concrete subprogram
   See nonabstract subprogram    @ref{3.9.3}.
concrete type
   See nonabstract type    @ref{3.9.3}.
concurrent processing
   See task    @ref{9}.
condition    @ref{5.3}.
   used    @ref{5.3}(2),    @ref{5.5}(3),    @ref{5.7}(2),    @ref{5.5}(3),    @ref{5.7,,5.7(2)},
           @ref{9.5.2}(7), see @ref{9.7.1}(3), see @ref{P}(7), see @ref{9.7.1}(3), see @ref{P,,P(1)}.
   See also exception    @ref{11}.
conditional_entry_call    @ref{9.7.3}.
   used    @ref{9.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
configuration
   of the partitions of a program    @ref{E}.
configuration pragma    @ref{10.1.5}.
   Locking_Policy    @ref{D.3}.
   Normalize_Scalars    @ref{H.1}.
   Queuing_Policy    @ref{D.4}.
   Restrictions    @ref{13.12}.
   Reviewable    @ref{H.3.1}.
   Suppress    @ref{11.5}.
   Task_Dispatching_Policy    @ref{D.2.2}.
conformance    @ref{6.3.1}.
   of an implementation with the Standard    @ref{1.1.3}.
   See also   full conformance, mode conformance,
      subtype conformance, type conformance
Conjugate    @ref{G.1.1}(12), see @ref{G.1.1}(12), see @ref{G.1.1,,G.1.1(15)}.
consistency
   among compilation units    @ref{10.1.4}.
constant    @ref{3.3}.
   See also literal    @ref{4.2}.
   See also static    @ref{4.9}.
   result of a function_call    @ref{6.4}.
constant object    @ref{3.3}.
constant view    @ref{3.3}.
Constants
   child of Ada.Strings.Maps    @ref{A.4.6}.
constituent
   of a construct    @ref{1.1.4}.
constrained    @ref{3.2}.
   object    @ref{3.3.1}(9), see @ref{3.10}(9), see @ref{6.4.1}(9), see @ref{3.10}(9), see @ref{6.4.1,,6.4.1(16)}.
   subtype    @ref{3.2}(9),     @ref{3.4}(6),     @ref{3.5}(9),     @ref{3.4}(6),     @ref{3.5,,3.5(7)},
              @ref{3.5.1}(10), see @ref{3.5.4}(9),   @ref{3.5.4}(10), see @ref{3.5.4}(9),   @ref{3.5.4,,3.5.4(10)},
              @ref{3.5.7}(11), see @ref{3.5.9}(13), see @ref{3.5.9}(11), see @ref{3.5.9}(13), see @ref{3.5.9,,3.5.9(16)},
              @ref{3.6}(15),    @ref{3.6}(16),    @ref{3.7}(15),    @ref{3.6}(16),    @ref{3.7,,3.7(26)},
              @ref{3.9}(15),    @ref{3.10}(14),   @ref{K}(15),    @ref{3.10}(14),   @ref{K,,K(33)}.
Constrained attribute    @ref{3.7.2}(3), see @ref{J.4}(2), see @ref{K}(3), see @ref{J.4}(2), see @ref{K,,K(42)}.
constrained by its initial value    @ref{3.3.1}(9), see @ref{3.10}(9), see @ref{3.10,,3.10(9)}.
   [partial]    @ref{4.8}.
constrained_array_definition    @ref{3.6}.
   used    @ref{3.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
constraint    @ref{3.2.2}.
   used    @ref{3.2.2}(3), see @ref{P}(3), see @ref{P,,P(1)}.
   [partial]    @ref{3.2}.
   of a first array subtype    @ref{3.6}.
   of an object    @ref{3.3.1}.
Constraint_Error    @ref{A.1}.
   raised by failure of run-time check
         @ref{3.2.2}(12),   @ref{3.5}(24),    @ref{3.5}(12),   @ref{3.5}(24),    @ref{3.5,,3.5(27)},
         @ref{3.5}(43),     @ref{3.5}(44),    @ref{3.5}(43),     @ref{3.5}(44),    @ref{3.5,,3.5(51)},
         @ref{3.5}(55),     @ref{3.5.4}(20), see @ref{3.5.5}(55),     @ref{3.5.4}(20), see @ref{3.5.5,,3.5.5(7)},
         @ref{3.5.9}(19),   @ref{3.9.2}(16), see @ref{4.1}(19),   @ref{3.9.2}(16), see @ref{4.1,,4.1(13)},
         @ref{4.1.1}(7),    @ref{4.1.2}(7),   @ref{4.1.3}(7),    @ref{4.1.2}(7),   @ref{4.1.3,,4.1.3(15)},
         @ref{4.2}(11),     @ref{4.3}(6),     @ref{4.3.2}(11),     @ref{4.3}(6),     @ref{4.3.2,,4.3.2(8)},
         @ref{4.3.3}(31),   @ref{4.4}(11),    @ref{4.5}(31),   @ref{4.4}(11),    @ref{4.5,,4.5(10)},
         @ref{4.5}(11),     @ref{4.5}(12),    @ref{4.5.1}(11),     @ref{4.5}(12),    @ref{4.5.1,,4.5.1(8)},
         @ref{4.5.3}(8),    @ref{4.5.5}(22), see @ref{4.5.6}(8),    @ref{4.5.5}(22), see @ref{4.5.6,,4.5.6(6)},
         @ref{4.5.6}(12),   @ref{4.5.6}(13), see @ref{4.6}(12),   @ref{4.5.6}(13), see @ref{4.6,,4.6(28)},
         @ref{4.6}(57),     @ref{4.6}(60),    @ref{4.7}(57),     @ref{4.6}(60),    @ref{4.7,,4.7(4)},
         @ref{4.8}(10),     @ref{5.2}(10),    @ref{5.4}(10),     @ref{5.2}(10),    @ref{5.4,,5.4(13)},
         @ref{6.5}(9),      @ref{11.1}(4),    @ref{11.4.1}(9),      @ref{11.1}(4),    @ref{11.4.1,,11.4.1(14)},
         @ref{11.5}(10),    @ref{13.9.1}(9), see @ref{13.13.2}(10),    @ref{13.9.1}(9), see @ref{13.13.2,,13.13.2(35)},
         @ref{A.4.3}(109), see @ref{A.4.7}(47), see @ref{A.5.1}(109), see @ref{A.4.7}(47), see @ref{A.5.1,,A.5.1(28)},
         @ref{A.5.1}(34),   @ref{A.5.2}(39), see @ref{A.5.2}(34),   @ref{A.5.2}(39), see @ref{A.5.2,,A.5.2(40)},
         @ref{A.5.3}(26),   @ref{A.5.3}(29), see @ref{A.5.3}(26),   @ref{A.5.3}(29), see @ref{A.5.3,,A.5.3(47)},
         @ref{A.5.3}(50),   @ref{A.5.3}(53), see @ref{A.5.3}(50),   @ref{A.5.3}(53), see @ref{A.5.3,,A.5.3(59)},
         @ref{A.5.3}(62),   @ref{A.15}(14),   @ref{B.3}(62),   @ref{A.15}(14),   @ref{B.3,,B.3(53)},
         @ref{B.3}(54),     @ref{B.4}(58),    @ref{E.4}(54),     @ref{B.4}(58),    @ref{E.4,,E.4(19)},
         @ref{G.1.1}(40),   @ref{G.1.2}(28), see @ref{G.2.1}(40),   @ref{G.1.2}(28), see @ref{G.2.1,,G.2.1(12)},
         @ref{G.2.2}(7),    @ref{G.2.3}(26), see @ref{G.2.4}(7),    @ref{G.2.3}(26), see @ref{G.2.4,,G.2.4(3)},
         @ref{G.2.6}(4),    @ref{K}(11),      @ref{K}(4),    @ref{K}(11),      @ref{K,,K(41)},
         @ref{K}(47),       @ref{K}(114),     @ref{K}(47),       @ref{K}(114),     @ref{K,,K(122)},
         @ref{K}(184),      @ref{K}(202),     @ref{K}(184),      @ref{K}(202),     @ref{K,,K(220)},
         @ref{K}(241),      @ref{K}(241),      @ref{K,,K(261)}.
Construct    @ref{1.1.4}(16), see @ref{N}(16), see @ref{N,,N(9)}.
constructor
   See initialization    @ref{3.3.1}(19), see @ref{7.6}(19), see @ref{7.6,,7.6(1)}.
   See initialization expression    @ref{3.3.1}.
   See Initialize    @ref{7.6}.
   See initialized alligator    @ref{4.8}.
Consumer    @ref{9.11}(5), see @ref{9.11}(5), see @ref{9.11,,9.11(6)}.
context free grammar
   complete listing    @ref{P}.
   cross reference    @ref{P}.
   notation    @ref{1.1.4}.
   under Syntax heading    @ref{1.1.2}.
context_clause    @ref{10.1.2}.
   used    @ref{10.1.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
context_item    @ref{10.1.2}.
   used    @ref{10.1.2}(2), see @ref{P}(2), see @ref{P,,P(1)}.
contiguous representation
   [partial]    @ref{13.5.2}(5), see @ref{13.7.1}(12), see @ref{13.9}(5), see @ref{13.7.1}(12), see @ref{13.9,,13.9(9)},
                @ref{13.9}(17),   @ref{13.11}(17),   @ref{13.11,,13.11(16)}.
Continue    @ref{D.11}.
control character
   See also format_effector    @ref{2.1}.
   See also other_control_function    @ref{2.1}.
   a category of Character    @ref{A.3.2}(22), see @ref{A.3.3}(22), see @ref{A.3.3,,A.3.3(4)},
                              @ref{A.3.3}.
Control_Set    @ref{A.4.6}.
Controlled    @ref{7.6}.
   aspect of representation    @ref{13.11.3}.
Controlled pragma    @ref{13.11.3}(3), see @ref{L}(3), see @ref{L,,L(7)}.
controlled type    @ref{7.6}(2), see @ref{7.6}(9), see @ref{N}(2), see @ref{7.6}(9), see @ref{N,,N(10)}.
Controller    @ref{9.1}.
controlling formal parameter    @ref{3.9.2}.
controlling operand @ref{3.9.2}(2)
controlling result    @ref{3.9.2}.
controlling tag
   for a call on a dispatching operation    @ref{3.9.2}.
controlling tag value    @ref{3.9.2}.
   for the expression in an assignment_statement    @ref{5.2}.
convention    @ref{6.3.1}(2), see @ref{B.1}(2), see @ref{B.1,,B.1(11)}.
   aspect of representation    @ref{B.1}.
Convention pragma    @ref{B.1}(7), see @ref{L}(7), see @ref{L,,L(8)}.
conversion    @ref{4.6}(1), see @ref{4.6}(1), see @ref{4.6,,4.6(28)}.
   access    @ref{4.6}(13), see @ref{4.6}(18), see @ref{4.6}(13), see @ref{4.6}(18), see @ref{4.6,,4.6(47)}.
   arbitrary order    @ref{1.1.4}.
   array    @ref{4.6}(9), see @ref{4.6}(9), see @ref{4.6,,4.6(36)}.
   composite (non-array)    @ref{4.6}(21), see @ref{4.6}(21), see @ref{4.6,,4.6(40)}.
   enumeration    @ref{4.6}(21), see @ref{4.6}(21), see @ref{4.6,,4.6(34)}.
   numeric    @ref{4.6}(8), see @ref{4.6}(8), see @ref{4.6,,4.6(29)}.
   unchecked    @ref{13.9}.
   value    @ref{4.6}.
   view    @ref{4.6}.
Conversion_Error    @ref{B.4}.
convertible    @ref{4.6}.
   required    @ref{3.7}(16), see @ref{3.7.1}(9), see @ref{4.6}(16), see @ref{3.7.1}(9), see @ref{4.6,,4.6(11)},
               @ref{4.6}(15), see @ref{6.4.1}(15), see @ref{6.4.1,,6.4.1(6)}.
Copy    @ref{E.4.2}(2), see @ref{E.4.2}(2), see @ref{E.4.2,,E.4.2(5)}.
copy back of parameters    @ref{6.4.1}.
copy parameter passing    @ref{6.2}.
Copy_Array    @ref{B.3.2}.
Copy_Sign attribute    @ref{A.5.3}(51), see @ref{K}(51), see @ref{K,,K(44)}.
Copy_Terminated_Array    @ref{B.3.2}.
Copyright_Sign    @ref{A.3.3}.
core language    @ref{1.1.2}.
corresponding constraint    @ref{3.4}.
corresponding discriminants    @ref{3.7}.
corresponding index
   for an array_aggregate    @ref{4.3.3}.
corresponding subtype    @ref{3.4}.
corresponding value
   of the target type of a conversion    @ref{4.6}.
Cos    @ref{A.5.1}(5), see @ref{G.1.2}(5), see @ref{G.1.2,,G.1.2(4)}.
Cosh    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(6)}.
Cot    @ref{A.5.1}(5), see @ref{G.1.2}(5), see @ref{G.1.2,,G.1.2(4)}.
Coth    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(6)}.
Count    @ref{A.4.3}(13), see @ref{A.4.3}(14), see @ref{A.4.3}(13), see @ref{A.4.3}(14), see @ref{A.4.3,,A.4.3(15)},
         @ref{A.4.4}(48), see @ref{A.4.4}(49), see @ref{A.4.4}(48), see @ref{A.4.4}(49), see @ref{A.4.4,,A.4.4(50)},
         @ref{A.4.5}(43), see @ref{A.4.5}(44), see @ref{A.4.5}(43), see @ref{A.4.5}(44), see @ref{A.4.5,,A.4.5(45)},
         @ref{A.8.4}(4),   @ref{A.10}(10),   @ref{A.10.1}(4),   @ref{A.10}(10),   @ref{A.10.1,,A.10.1(5)},
         @ref{A.12.1}.
Count attribute    @ref{9.9}(5), see @ref{K}(5), see @ref{K,,K(48)}.
Counter    @ref{3.4}.
cover
   a type    @ref{3.4.1}.
   of a choice and an exception    @ref{11.2}.
cover a value
   by a discrete_choice_list    @ref{3.8.1}.
   by a discrete_choice    @ref{3.8.1}.
CPU_Identifier    @ref{7.4}.
CR    @ref{A.3.3}.
create    @ref{3.1}(12),    @ref{A.8.1}(6), see @ref{A.8.4}(12),    @ref{A.8.1}(6), see @ref{A.8.4,,A.8.4(6)},
          @ref{A.10.1}(9), see @ref{A.12.1}(9), see @ref{A.12.1,,A.12.1(8)}.
creation
   of a protected object    @ref{C.3.1}.
   of a task object    @ref{D.1}.
   of an object    @ref{3.3}.
critical section
   See intertask communication    @ref{9.5}.
CSI    @ref{A.3.3}.
Currency_Sign    @ref{A.3.3}.
current column number    @ref{A.10}.
current index
   of an open direct file    @ref{A.8}.
current instance
   of a generic unit    @ref{8.6}.
   of a type    @ref{8.6}.
current line number    @ref{A.10}.
current mode
   of an open file    @ref{A.7}.
current page number    @ref{A.10}.
current size
   of an external file    @ref{A.8}.
Current_Error    @ref{A.10.1}(17), see @ref{A.10.1}(17), see @ref{A.10.1,,A.10.1(20)}.
Current_Handler    @ref{C.3.2}.
Current_Input    @ref{A.10.1}(17), see @ref{A.10.1}(17), see @ref{A.10.1,,A.10.1(20)}.
Current_Output    @ref{A.10.1}(17), see @ref{A.10.1}(17), see @ref{A.10.1,,A.10.1(20)}.
Current_State    @ref{D.10}.
Current_Task    @ref{C.7.1}.
@end format

@c ---------------------------------------------------------------------------
@node Index.D, Index.E, Index.C, Index
@chapter index

@format
dangling references
   prevention via accessibility rules    @ref{3.10.2}.
Data_Error    @ref{A.8.1}(15),   @ref{A.8.4}(18),   @ref{A.9}(15),   @ref{A.8.4}(18),   @ref{A.9,,A.9(9)},
              @ref{A.10.1}(85), see @ref{A.12.1}(26), see @ref{A.13}(85), see @ref{A.12.1}(26), see @ref{A.13,,A.13(4)}.
Date    @ref{3.8}.
Day    @ref{3.5.1}(14), see @ref{9.6}(14), see @ref{9.6,,9.6(13)}.
Day_Duration    @ref{9.6}.
Day_Number    @ref{9.6}.
DC1    @ref{A.3.3}.
DC2    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
DC3    @ref{A.3.3}.
DC4    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
DCS    @ref{A.3.3}.
Deallocate    @ref{13.11}.
deallocation of storage    @ref{13.11.2}.
Decimal
   child of Ada    @ref{F.2}.
decimal digit
   a category of Character    @ref{A.3.2}.
decimal fixed point type    @ref{3.5.9}(1), see @ref{3.5.9}(1), see @ref{3.5.9,,3.5.9(6)}.
Decimal_Conversions    @ref{B.4}.
Decimal_Digit_Set    @ref{A.4.6}.
Decimal_Element    @ref{B.4}.
decimal_fixed_point_definition    @ref{3.5.9}.
   used    @ref{3.5.9}(2), see @ref{P}(2), see @ref{P,,P(1)}.
decimal_literal    @ref{2.4.1}.
   used    @ref{2.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Decimal_Output    @ref{F.3.3}.
Decimal_IO    @ref{A.10.1}.
Declaration    @ref{3.1}(5), see @ref{3.1}(6), see @ref{N}(5), see @ref{3.1}(6), see @ref{N,,N(11)}.
declarative region
   of a construct    @ref{8.1}.
declarative_item    @ref{3.11}.
   used    @ref{3.11}(2), see @ref{P}(2), see @ref{P,,P(1)}.
declarative_part    @ref{3.11}.
   used    @ref{5.6}(2), see @ref{6.3}(2),    @ref{7.2}(2), see @ref{6.3}(2),    @ref{7.2,,7.2(2)},
           @ref{9.1}(6), see @ref{9.5.2}(5), see @ref{P}(6), see @ref{9.5.2}(5), see @ref{P,,P(1)}.
declare    @ref{3.1}(8), see @ref{3.1}(8), see @ref{3.1,,3.1(12)}.
declared pure    @ref{10.2.1}.
Decrement    @ref{B.3.2}.
deeper
   accessibility level    @ref{3.10.2}.
   statically    @ref{3.10.2}(4), see @ref{3.10.2}(4), see @ref{3.10.2,,3.10.2(17)}.
default entry queuing policy    @ref{9.5.3}.
default treatment    @ref{C.3}.
Default_Bit_Order    @ref{13.7}.
Default_Currency    @ref{F.3.3}.
default_expression    @ref{3.7}.
   used    @ref{3.7}(5),   @ref{3.8}(6), see @ref{6.1}(5),   @ref{3.8}(6), see @ref{6.1,,6.1(15)},
           @ref{12.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Default_Fill    @ref{F.3.3}.
Default_Message_Procedure    @ref{3.10}.
default_name    @ref{12.6}.
   used    @ref{12.6}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Default_Priority    @ref{13.7}(17), see @ref{D.1}(17), see @ref{D.1,,D.1(11)}.
Default_Radix_Mark    @ref{F.3.3}.
Default_Separator    @ref{F.3.3}.
deferred constant    @ref{7.4}.
deferred constant declaration    @ref{3.3.1}(6), see @ref{7.4}(6), see @ref{7.4,,7.4(2)}.
defining name    @ref{3.1}.
defining_character_literal    @ref{3.5.1}.
   used    @ref{3.5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
defining_designator    @ref{6.1}.
   used    @ref{6.1}(4), see @ref{12.3}(2), see @ref{P}(4), see @ref{12.3}(2), see @ref{P,,P(1)}.
defining_identifier    @ref{3.1}.
   used    @ref{3.2.1}(3),   @ref{3.2.2}(2),   @ref{3.3.1}(3),   @ref{3.2.2}(2),   @ref{3.3.1,,3.3.1(3)},
           @ref{3.5.1}(3),   @ref{3.10.1}(2), see @ref{5.5}(3),   @ref{3.10.1}(2), see @ref{5.5,,5.5(4)},
           @ref{6.1}(7),     @ref{7.3}(2),     @ref{7.3}(7),     @ref{7.3}(2),     @ref{7.3,,7.3(3)},
           @ref{8.5.1}(2),   @ref{8.5.2}(2),   @ref{9.1}(2),   @ref{8.5.2}(2),   @ref{9.1,,9.1(2)},
           @ref{9.1}(3),     @ref{9.1}(6),     @ref{9.4}(3),     @ref{9.1}(6),     @ref{9.4,,9.4(2)},
           @ref{9.4}(3),     @ref{9.4}(7),     @ref{9.5.2}(3),     @ref{9.4}(7),     @ref{9.5.2,,9.5.2(2)},
           @ref{9.5.2}(5),   @ref{9.5.2}(8),   @ref{10.1.3}(5),   @ref{9.5.2}(8),   @ref{10.1.3,,10.1.3(4)},
           @ref{10.1.3}(5), see @ref{10.1.3}(6), see @ref{11.2}(5), see @ref{10.1.3}(6), see @ref{11.2,,11.2(4)},
           @ref{12.5}(2),    @ref{12.7}(2),    @ref{P}(2),    @ref{12.7}(2),    @ref{P,,P(1)}.
defining_identifier_list    @ref{3.3.1}.
   used    @ref{3.3.1}(2), see @ref{3.3.2}(2), see @ref{3.7}(2), see @ref{3.3.2}(2), see @ref{3.7,,3.7(5)},
           @ref{3.8}(6),    @ref{6.1}(15),   @ref{11.1}(6),    @ref{6.1}(15),   @ref{11.1,,11.1(2)},
           @ref{12.4}(2),   @ref{P}(2),   @ref{P,,P(1)}.
defining_operator_symbol    @ref{6.1}.
   used    @ref{6.1}(6), see @ref{P}(6), see @ref{P,,P(1)}.
defining_program_unit_name    @ref{6.1}.
   used    @ref{6.1}(4),   @ref{6.1}(6),    @ref{7.1}(4),   @ref{6.1}(6),    @ref{7.1,,7.1(3)},
           @ref{7.2}(2),   @ref{8.5.3}(2), see @ref{8.5.5}(2),   @ref{8.5.3}(2), see @ref{8.5.5,,8.5.5(2)},
           @ref{12.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Definite attribute    @ref{12.5.1}(23), see @ref{K}(23), see @ref{K,,K(50)}.
definite subtype    @ref{3.3}.
Definition    @ref{3.1}(7), see @ref{N}(7), see @ref{N,,N(12)}.
Deg_To_Rad    @ref{4.9}.
Degree_Sign    @ref{A.3.3}.
DEL    @ref{A.3.3}(14), see @ref{J.5}(14), see @ref{J.5,,J.5(4)}.
delay_alternative    @ref{9.7.1}.
   used    @ref{9.7.1}(4), see @ref{9.7.2}(2), see @ref{P}(4), see @ref{9.7.2}(2), see @ref{P,,P(1)}.
delay_relative_statement    @ref{9.6}.
   used    @ref{9.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
delay_statement    @ref{9.6}.
   used    @ref{5.1}(4), see @ref{9.7.1}(6), see @ref{9.7.4}(4), see @ref{9.7.1}(6), see @ref{9.7.4,,9.7.4(4)},
           @ref{P}.
delay_until_statement    @ref{9.6}.
   used    @ref{9.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Delete    @ref{A.4.3}(29), see @ref{A.4.3}(30), see @ref{A.4.4}(29), see @ref{A.4.3}(30), see @ref{A.4.4,,A.4.4(64)},
          @ref{A.4.4}(65), see @ref{A.4.5}(59), see @ref{A.4.5}(65), see @ref{A.4.5}(59), see @ref{A.4.5,,A.4.5(60)},
          @ref{A.8.1}(8),   @ref{A.8.4}(8),   @ref{A.10.1}(8),   @ref{A.8.4}(8),   @ref{A.10.1,,A.10.1(11)},
          @ref{A.12.1}.
delimiter    @ref{2.2}.
delivery
   of an interrupt    @ref{C.3}.
delta
   of a fixed point type    @ref{3.5.9}.
Delta attribute    @ref{3.5.10}(3), see @ref{K}(3), see @ref{K,,K(52)}.
delta_constraint    @ref{J.3}.
   used    @ref{3.2.2}(6), see @ref{P}(6), see @ref{P,,P(1)}.
Denorm attribute    @ref{A.5.3}(9), see @ref{K}(9), see @ref{K,,K(54)}.
denormalized number    @ref{A.5.3}.
denote    @ref{8.6}.
   informal definition    @ref{3.1}.
   name used as a pragma argument    @ref{8.6}.
depend on a discriminant
   for a constraint or component_definition    @ref{3.7}.
   for a component    @ref{3.7}.
dependence
   elaboration    @ref{10.2}.
   of a task on a master    @ref{9.3}.
   of a task on another task    @ref{9.3}.
   semantic    @ref{10.1.1}.
depth
   accessibility level    @ref{3.10.2}.
dereference    @ref{4.1}.
Dereference_Error    @ref{B.3.1}.
derivation class
   for a type    @ref{3.4.1}.
derived from
   directly or indirectly    @ref{3.4.1}.
derived type    @ref{3.4}(1), see @ref{N}(1), see @ref{N,,N(13)}.
   [partial]    @ref{3.4}.
derived_type_definition    @ref{3.4}.
   used    @ref{3.2.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
descendant    @ref{10.1.1}.
   of a type    @ref{3.4.1}.
   relationship with scope    @ref{8.2}.
Descriptor    @ref{13.6}.
designate    @ref{3.10}.
designated profile
   of an access-to-subprogram type    @ref{3.10}.
designated subtype
   of a named access type    @ref{3.10}.
   of an anonymous access type    @ref{3.10}.
designated type
   of a named access type    @ref{3.10}.
   of an anonymous access type    @ref{3.10}.
designator    @ref{6.1}.
   used    @ref{6.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
destructor
   See finalization    @ref{7.6}(1), see @ref{7.6.1}(1), see @ref{7.6.1,,7.6.1(1)}.
Detach_Handler    @ref{C.3.2}.
determined class for a formal type    @ref{12.5}.
determines
   a type by a subtype_mark    @ref{3.2.2}.
Device    @ref{3.8.1}.
Device_Error    @ref{A.8.1}(15),   @ref{A.8.4}(15),   @ref{A.8.4,,A.8.4(18)},
                @ref{A.10.1}(85), see @ref{A.12.1}(26), see @ref{A.13}(85), see @ref{A.12.1}(26), see @ref{A.13,,A.13(4)}.
Device_Interface    @ref{C.3.2}.
Device_Priority    @ref{C.3.2}.
Diaeresis    @ref{A.3.3}.
Dice    @ref{A.5.2}.
Dice_Game    @ref{A.5.2}.
Die    @ref{A.5.2}.
digit    @ref{2.1}.
   used    @ref{2.1}(3),    @ref{2.3}(3), see @ref{2.4.1}(3),    @ref{2.3}(3), see @ref{2.4.1,,2.4.1(3)},
           @ref{2.4.2}(5), see @ref{P}(5), see @ref{P,,P(1)}.
digits
   of a decimal fixed point subtype    @ref{3.5.9},
                                       @ref{3.5.10}.
Digits attribute    @ref{3.5.8}(2), see @ref{3.5.10}(2), see @ref{3.5.10,,3.5.10(7)},
                    @ref{K}(56),     @ref{K}(56),     @ref{K,,K(58)}.
digits_constraint    @ref{3.5.9}.
   used    @ref{3.2.2}(6), see @ref{P}(6), see @ref{P,,P(1)}.
dimensionality
   of an array    @ref{3.6}.
direct access    @ref{A.8}.
direct file    @ref{A.8}.
direct_name    @ref{4.1}.
   used    @ref{3.8.1}(2), see @ref{4.1}(2),   @ref{5.1}(2), see @ref{4.1}(2),   @ref{5.1,,5.1(8)},
           @ref{9.5.2}(3), see @ref{13.1}(3), see @ref{J.7}(3), see @ref{13.1}(3), see @ref{J.7,,J.7(1)},
           @ref{P}.
Direct_IO    @ref{J.1}.
   child of Ada    @ref{A.8.4}(2), see @ref{A.9}(2), see @ref{A.9,,A.9(3)}.
Direction    @ref{A.4.1}.
directly specified
   of an aspect of representation of an entity    @ref{13.1}.
directly visible    @ref{8.3}(2), see @ref{8.3}(2), see @ref{8.3,,8.3(21)}.
   within a pragma in a context_clause    @ref{10.1.6}.
   within a pragma that appears at the place of a compilation unit
         @ref{10.1.6}.
   within a use_clause in a context_clause    @ref{10.1.6}.
   within a with_clause    @ref{10.1.6}.
   within the parent_unit_name of a library unit    @ref{10.1.6}.
   within the parent_unit_name of a subunit    @ref{10.1.6}.
Discard_Names pragma    @ref{C.5}(3), see @ref{L}(3), see @ref{L,,L(9)}.
discontiguous representation
   partial  @ref{13.5.2}(5), see @ref{13.7.1}(12), see @ref{13.9}(5), see @ref{13.7.1}(12), see @ref{13.9,,13.9(9)},
            @ref{13.9}(17),   @ref{13.11}(17),   @ref{13.11,,13.11(16)}.
discrete array type    @ref{4.5.2}.
discrete type    @ref{3.2}(3), see @ref{3.5}(1), see @ref{N}(3), see @ref{3.5}(1), see @ref{N,,N(14)}.
discrete_choice    @ref{3.8.1}.
   used    @ref{3.8.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
discrete_choice_list    @ref{3.8.1}.
   used    @ref{3.8.1}(3), see @ref{4.3.3}(5), see @ref{5.4}(3), see @ref{4.3.3}(5), see @ref{5.4,,5.4(3)},
           @ref{P}.
Discrete_Random
   child of Ada.Numerics    @ref{A.5.2}.
discrete_range    @ref{3.6.1}.
   used    @ref{3.6.1}(2), see @ref{3.8.1}(5), see @ref{4.1.2}(2), see @ref{3.8.1}(5), see @ref{4.1.2,,4.1.2(2)},
           @ref{P}.
discrete_subtype_definition    @ref{3.6}.
   used    @ref{3.6}(5),    @ref{5.5}(4), see @ref{9.5.2}(5),    @ref{5.5}(4), see @ref{9.5.2,,9.5.2(2)},
           @ref{9.5.2}(8), see @ref{P}(8), see @ref{P,,P(1)}.
discriminant    @ref{3.2}(5), see @ref{3.7}(1), see @ref{N}(5), see @ref{3.7}(1), see @ref{N,,N(15)}.
   of a variant_part    @ref{3.8.1}.
discriminant_association    @ref{3.7.1}.
   used    @ref{3.7.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Discriminant_Check    @ref{11.5}.
   [partial]    @ref{4.1.3}(15), see @ref{4.3}(6),   @ref{4.3.2}(15), see @ref{4.3}(6),   @ref{4.3.2,,4.3.2(8)},
                @ref{4.6}(43),    @ref{4.6}(45), see @ref{4.6}(43),    @ref{4.6}(45), see @ref{4.6,,4.6(51)},
                @ref{4.6}(52),    @ref{4.7}(4),   @ref{4.8}(52),    @ref{4.7}(4),   @ref{4.8,,4.8(10)}.
discriminant_constraint    @ref{3.7.1}.
   used    @ref{3.2.2}(7), see @ref{P}(7), see @ref{P,,P(1)}.
discriminant_part    @ref{3.7}.
   used    @ref{3.10.1}(2), see @ref{7.3}(2), see @ref{7.3}(2), see @ref{7.3}(2), see @ref{7.3,,7.3(3)},
           @ref{12.5}(2),    @ref{P}(2),    @ref{P,,P(1)}.
discriminant_specification    @ref{3.7}.
   used    @ref{3.7}(4), see @ref{P}(4), see @ref{P,,P(1)}.
discriminants
   known    @ref{3.7}.
   unknown    @ref{3.7}.
discriminated type    @ref{3.7}.
Disk_Unit    @ref{3.8.1}.
dispatching    @ref{3.9}.
dispatching call
   on a dispatching operation    @ref{3.9.2}.
dispatching operation    @ref{3.9.2}(1), see @ref{3.9.2}(1), see @ref{3.9.2,,3.9.2(2)}.
   [partial]    @ref{3.9}.
dispatching point    @ref{D.2.1}.
   [partial]    @ref{D.2.1}(8), see @ref{D.2.2}(8), see @ref{D.2.2,,D.2.2(12)}.
dispatching policy for tasks
   [partial]    @ref{D.2.1}.
dispatching, task    @ref{D.2.1}.
Display_Format    @ref{B.4}.
displayed magnitude (of a decimal value)    @ref{F.3.2}.
disruption of an assignment    @ref{9.8}(21), see @ref{13.9.1}(21), see @ref{13.9.1,,13.9.1(5)}.
   [partial]    @ref{11.6}.
distinct access paths    @ref{6.2}.
distributed program    @ref{E}.
distributed system    @ref{E}.
distributed systems    @ref{C}.
divide    @ref{2.1}(15), see @ref{F.2}(15), see @ref{F.2,,F.2(6)}.
divide operator    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
Dividend_Type    @ref{F.2}.
Division_Check    @ref{11.5}.
   [partial]    @ref{3.5.4}(20), see @ref{4.5.5}(20), see @ref{4.5.5,,4.5.5(22)},
                @ref{A.5.1}(28), see @ref{A.5.3}(28), see @ref{A.5.3,,A.5.3(47)},
                @ref{G.1.1}(40), see @ref{G.1.2}(40), see @ref{G.1.2,,G.1.2(28)},
                @ref{K}.
Division_Sign    @ref{A.3.3}.
Divisor_Type    @ref{F.2}.
DLE    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
Do_APC    @ref{E.5}.
Do_RPC    @ref{E.5}.
documentation (required of an implementation)    @ref{1.1.3},
                                                 @ref{M}.
documentation requirements    @ref{1.1.2}(34), see @ref{1.1.3}(34), see @ref{1.1.3,,1.1.3(18)},
                              @ref{13.11}(22), see @ref{A.5.2}(22), see @ref{A.5.2,,A.5.2(44)},
                              @ref{A.13}(15),   @ref{C.1}(15),   @ref{C.1,,C.1(6)},
                              @ref{C.3}(12),    @ref{C.3.2}(12),    @ref{C.3.2,,C.3.2(24)},
                              @ref{C.4}(12),    @ref{C.7.1}(12),    @ref{C.7.1,,C.7.1(19)},
                              @ref{C.7.2}(18), see @ref{D.2.2}(18), see @ref{D.2.2,,D.2.2(14)},
                              @ref{D.6}(3),     @ref{D.8}(3),     @ref{D.8,,D.8(33)},
                              @ref{D.9}(7),     @ref{D.12}(7),     @ref{D.12,,D.12(5)},
                              @ref{E.5}(25),    @ref{H.1}(25),    @ref{H.1,,H.1(5)},
                              @ref{H.2}(1),     @ref{H.3.2}(1),     @ref{H.3.2,,H.3.2(8)},
                              @ref{H.4}(25),    @ref{J.7.1}(25),    @ref{J.7.1,,J.7.1(12)}.
Dollar_Sign    @ref{A.3.3}.
Done    @ref{J.7.1}.
dot    @ref{2.1}.
dot selection
   See selected_component    @ref{4.1.3}.
Dot_Product    @ref{6.1}(39), see @ref{6.3}(39), see @ref{6.3,,6.3(11)}.
double    @ref{B.3}.
Double_Precision    @ref{B.5}.
Double_Square    @ref{3.7}.
downward closure  @ref{3.10.2}.
Dozen    @ref{4.6}.
drift rate    @ref{D.8}.
Drum_Ref    @ref{3.10}.
Drum_Unit    @ref{3.8.1}.
Duration    @ref{A.1}.
dynamic binding
   See dispatching operation    @ref{3.9}.
dynamic semantics    @ref{1.1.2}.
Dynamic_Priorities
   child of Ada    @ref{D.5}.
dynamically determined tag    @ref{3.9.2}.
dynamically enclosing
   of one execution by another    @ref{11.4}.
dynamically tagged    @ref{3.9.2}.
@end format

@c ---------------------------------------------------------------------------
@node Index.E, Index.F, Index.D, Index
@chapter index

@format
e    @ref{A.5}.
edited output    @ref{F.3}.
Editing
   child of Ada.Text_IO    @ref{F.3.3}.
   child of Ada.Wide_Text_IO    @ref{F.3.4}.
effect
   external    @ref{1.1.3}.
efficiency    @ref{11.5}(29), see @ref{11.6}(29), see @ref{11.6,,11.6(1)}.
Elaborate pragma    @ref{10.2.1}(20), see @ref{L}(20), see @ref{L,,L(10)}.
Elaborate_All pragma    @ref{10.2.1}(21), see @ref{L}(21), see @ref{L,,L(11)}.
Elaborate_Body pragma    @ref{10.2.1}(22), see @ref{L}(22), see @ref{L,,L(12)}.
elaborated    @ref{3.11}.
elaboration    @ref{3.1}(11), see @ref{N}(11), see @ref{N,,N(19)}.
   abstract_subprogram_declaration    @ref{6.1}.
   access_definition    @ref{3.10}.
   access_type_definition    @ref{3.10}.
   array_type_definition    @ref{3.6}.
   choice_parameter_specification    @ref{11.4}.
   component_declaration    @ref{3.8}.
   component_definition    @ref{3.6}(22), see @ref{3.8}(22), see @ref{3.8,,3.8(18)}.
   component_list    @ref{3.8}.
   declaration named by a pragma Import    @ref{B.1}.
   declarative_part    @ref{3.11}.
   deferred constant declaration    @ref{7.4}.
   delta_constraint    @ref{J.3}.
   derived_type_definition    @ref{3.4}.
   digits_constraint    @ref{3.5.9}.
   discrete_subtype_definition    @ref{3.6}.
   discriminant_constraint    @ref{3.7.1}.
   entry_declaration    @ref{9.5.2}.
   enumeration_type_definition    @ref{3.5.1}.
   exception_declaration    @ref{11.1}.
   fixed_point_definition    @ref{3.5.9}.
   floating_point_definition    @ref{3.5.7}.
   full type definition    @ref{3.2.1}.
   full_type_declaration    @ref{3.2.1}.
   generic body    @ref{12.2}.
   generic_declaration    @ref{12.1}.
   generic_instantiation    @ref{12.3}.
   incomplete_type_declaration    @ref{3.10.1}.
   index_constraint    @ref{3.6.1}.
   integer_type_definition    @ref{3.5.4}.
   loop_parameter_specification    @ref{5.5}.
   non-generic subprogram_body    @ref{6.3}.
   nongeneric package_body    @ref{7.2}.
   number_declaration    @ref{3.3.2}.
   object_declaration    @ref{3.3.1}(15), see @ref{7.6}(15), see @ref{7.6,,7.6(10)}.
   package_body of Standard    @ref{A.1}.
   package_declaration    @ref{7.1}.
   partition    @ref{E.1}(6), see @ref{E.5}(6), see @ref{E.5,,E.5(21)}.
   pragma    @ref{2.8}.
   private_extension_declaration    @ref{7.3}.
   private_type_declaration    @ref{7.3}.
   protected declaration    @ref{9.4}.
   protected_body    @ref{9.4}.
   protected_definition    @ref{9.4}.
   range_constraint    @ref{3.5}.
   real_type_definition    @ref{3.5.6}.
   record_definition    @ref{3.8}.
   record_extension_part    @ref{3.9.1}.
   record_type_definition    @ref{3.8}.
   renaming_declaration    @ref{8.5}.
   representation_clause    @ref{13.1}.
   single_protected_declaration    @ref{9.4}.
   single_task_declaration    @ref{9.1}.
   Storage_Size pragma    @ref{13.3}.
   subprogram_declaration    @ref{6.1}.
   subtype_declaration    @ref{3.2.2}.
   subtype_indication    @ref{3.2.2}.
   task declaration    @ref{9.1}.
   task_body    @ref{9.1}.
   task_definition    @ref{9.1}.
   use_clause    @ref{8.4}.
   variant_part    @ref{3.8.1}.
elaboration control    @ref{10.2.1}.
elaboration dependence
   library_item on another    @ref{10.2}.
Elaboration_Check    @ref{11.5}.
   [partial]    @ref{3.11}.
Elem    @ref{12.1}.
element    @ref{A.4.4}(26), see @ref{A.4.5}(20), see @ref{B.3.2}(26), see @ref{A.4.5}(20), see @ref{B.3.2,,B.3.2(4)}.
   of a storage pool    @ref{13.11}.
Element_Array    @ref{B.3.2}.
Element_Type    @ref{3.9.3}(15), see @ref{A.8.1}(2), see @ref{A.8.4}(15), see @ref{A.8.1}(2), see @ref{A.8.4,,A.8.4(2)},
                @ref{A.9}.
elementary type    @ref{3.2}(2), see @ref{N}(2), see @ref{N,,N(16)}.
Elementary_Functions
   child of Ada.Numerics    @ref{A.5.1}.
eligible
   a type, for a convention    @ref{B.1}.
else part
   of a selective_accept    @ref{9.7.1}.
EM    @ref{A.3.3}.
embedded systems    @ref{C}(1), see @ref{D}(1), see @ref{D,,D(1)}.
Empty    @ref{3.9.3}.
encapsulation
   See package    @ref{7}.
enclosing
   immediately    @ref{8.1}.
end of a line    @ref{2.2}.
End_Error    @ref{A.8.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1,,A.10.1(85)},
             @ref{A.12.1}(26), see @ref{A.13}(26), see @ref{A.13,,A.13(4)}.
End_Of_File    @ref{11.4.2}(4),   @ref{A.8.1}(13), see @ref{A.8.4}(4),   @ref{A.8.1}(13), see @ref{A.8.4,,A.8.4(16)},
               @ref{A.10.1}(34), see @ref{A.12.1}(34), see @ref{A.12.1,,A.12.1(12)}.
End_Of_Line    @ref{A.10.1}.
End_Of_Page    @ref{A.10.1}.
endian
   big    @ref{13.5.3}.
   little    @ref{13.5.3}.
ENQ    @ref{A.3.3}.
entity
   [partial]    @ref{3.1}.
entry
   closed    @ref{9.5.3}.
   open    @ref{9.5.3}.
   single    @ref{9.5.2}.
entry call    @ref{9.5.3}.
   simple    @ref{9.5.3}.
entry calling convention    @ref{6.3.1}.
entry family    @ref{9.5.2}.
entry index subtype    @ref{3.8}(18), see @ref{9.5.2}(18), see @ref{9.5.2,,9.5.2(20)}.
entry queue    @ref{9.5.3}.
entry queuing policy    @ref{9.5.3}.
   default policy    @ref{9.5.3}.
entry_barrier    @ref{9.5.2}.
   used    @ref{9.5.2}(5), see @ref{P}(5), see @ref{P,,P(1)}.
entry_body    @ref{9.5.2}.
   used    @ref{9.4}(8), see @ref{P}(8), see @ref{P,,P(1)}.
entry_body_formal_part    @ref{9.5.2}.
   used    @ref{9.5.2}(5), see @ref{P}(5), see @ref{P,,P(1)}.
entry_call_alternative    @ref{9.7.2}.
   used    @ref{9.7.2}(2), see @ref{9.7.3}(2), see @ref{P}(2), see @ref{9.7.3}(2), see @ref{P,,P(1)}.
entry_call_statement    @ref{9.5.3}.
   used    @ref{5.1}(4), see @ref{9.7.2}(3), see @ref{9.7.4}(4), see @ref{9.7.2}(3), see @ref{9.7.4,,9.7.4(4)},
           @ref{P}.
entry_declaration    @ref{9.5.2}.
   used    @ref{9.1}(5), see @ref{9.4}(5), see @ref{P}(5), see @ref{9.4}(5), see @ref{P,,P(1)}.
entry_index    @ref{9.5.2}.
   used    @ref{9.5.2}(3), see @ref{P}(3), see @ref{P,,P(1)}.
entry_index_specification    @ref{9.5.2}.
   used    @ref{9.5.2}(6), see @ref{P}(6), see @ref{P,,P(1)}.
Enum    @ref{12.5}(13), see @ref{A.10.1}(13), see @ref{A.10.1,,A.10.1(79)}.
Enum_IO    @ref{8.5.5}.
enumeration literal    @ref{3.5.1}.
enumeration type    @ref{3.2}(3), see @ref{3.5.1}(1), see @ref{N}(3), see @ref{3.5.1}(1), see @ref{N,,N(17)}.
enumeration_aggregate    @ref{13.4}.
   used    @ref{13.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
enumeration_literal_specification    @ref{3.5.1}.
   used    @ref{3.5.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
enumeration_representation_clause    @ref{13.4}.
   used    @ref{13.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
enumeration_type_definition    @ref{3.5.1}.
   used    @ref{3.2.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Enumeration_IO    @ref{A.10.1}.
environment declarative_part    @ref{10.1.4}.
   for the environment task of a partition    @ref{10.2}.
environment    @ref{10.1.4}.
environment task    @ref{10.2}.
EOF    @ref{8.5.2}.
EOT    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
EPA    @ref{A.3.3}.
epoch    @ref{D.8}.
equal operator    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
equality operator    @ref{4.5.2}.
   special inheritance rule for tagged types    @ref{3.4},
                                                @ref{4.5.2}.
equals sign    @ref{2.1}.
Equals_Sign    @ref{A.3.3}.
erroneous execution    @ref{1.1.2}(32),   @ref{1.1.5}(32),   @ref{1.1.5,,1.1.5(10)},
                       @ref{3.7.2}(4),    @ref{9.8}(4),    @ref{9.8,,9.8(21)},
                       @ref{9.10}(11),    @ref{11.5}(11),    @ref{11.5,,11.5(26)},
                       @ref{13.3}(13),    @ref{13.3}(13),    @ref{13.3,,13.3(27)},
                       @ref{13.9.1}(8),   @ref{13.9.1}(8),   @ref{13.9.1,,13.9.1(12)},
                       @ref{13.11}(21),   @ref{13.11.2}(21),   @ref{13.11.2,,13.11.2(16)},
                       @ref{A.10.3}(22), see @ref{A.13}(22), see @ref{A.13,,A.13(17)},
                       @ref{B.3.1}(51),   @ref{B.3.2}(51),   @ref{B.3.2,,B.3.2(35)},
                       @ref{C.3.1}(14),   @ref{C.7.1}(14),   @ref{C.7.1,,C.7.1(18)},
                       @ref{C.7.2}(14),   @ref{D.5}(14),   @ref{D.5,,D.5(12)},
                       @ref{D.11}(9),     @ref{H.4}(9),     @ref{H.4,,H.4(26)}.
error    @ref{11.1}.
   compile-time    @ref{1.1.2}(27), see @ref{1.1.5}(27), see @ref{1.1.5,,1.1.5(4)}.
   link-time    @ref{1.1.2}(29), see @ref{1.1.5}(29), see @ref{1.1.5,,1.1.5(4)}.
   run-time    @ref{1.1.2}(30), see @ref{1.1.5}(6), see @ref{11.5}(30), see @ref{1.1.5}(6), see @ref{11.5,,11.5(2)},
               @ref{11.6}.
   See also   bounded error, erroneous execution
ESA    @ref{A.3.3}.
ESC    @ref{A.3.3}.
Establish_RPC_Receiver    @ref{E.5}.
ETB    @ref{A.3.3}.
ETX    @ref{A.3.3}.
evaluation    @ref{3.1}(11), see @ref{N}(11), see @ref{N,,N(19)}.
   aggregate    @ref{4.3}.
   allocator    @ref{4.8}.
   array_aggregate    @ref{4.3.3}.
   attribute_reference    @ref{4.1.4}.
   concatenation    @ref{4.5.3}.
   dereference    @ref{4.1}.
   discrete_range    @ref{3.6.1}.
   extension_aggregate    @ref{4.3.2}.
   generic_association    @ref{12.3}.
   generic_association for a formal object of mode in
         @ref{12.4}.
   indexed_component    @ref{4.1.1}.
   initialized allocator    @ref{4.8}.
   membership test    @ref{4.5.2}.
   name    @ref{4.1}.
   name that has a prefix    @ref{4.1}.
   null literal    @ref{4.2}.
   numeric literal    @ref{4.2}.
   parameter_association    @ref{6.4.1}.
   prefix    @ref{4.1}.
   primary that is a name    @ref{4.4}.
   qualified_expression    @ref{4.7}.
   range    @ref{3.5}.
   range_attribute_reference    @ref{4.1.4}.
   record_aggregate    @ref{4.3.1}.
   record_component_association_list    @ref{4.3.1}.
   selected_component    @ref{4.1.3}.
   short-circuit control form    @ref{4.5.1}.
   slice    @ref{4.1.2}.
   string_literal    @ref{4.2}.
   uninitialized allocator    @ref{4.8}.
   Val    @ref{3.5.5}(7), see @ref{K}(7), see @ref{K,,K(261)}.
   Value    @ref{3.5}.
   value conversion    @ref{4.6}.
   view conversion    @ref{4.6}.
   Wide_Value    @ref{3.5}.
Exception    @ref{11}(1), see @ref{11.1}(1), see @ref{N}(1), see @ref{11.1}(1), see @ref{N,,N(18)}.
exception occurrence    @ref{11}.
exception_choice    @ref{11.2}.
   used    @ref{11.2}(3), see @ref{P}(3), see @ref{P,,P(1)}.
exception_declaration    @ref{11.1}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
exception_handler    @ref{11.2}.
   used    @ref{11.2}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Exception_Identity    @ref{11.4.1}.
Exception_Information    @ref{11.4.1}.
Exception_Message    @ref{11.4.1}.
Exception_Name    @ref{11.4.1}(2), see @ref{11.4.1}(2), see @ref{11.4.1,,11.4.1(5)}.
Exception_Occurrence    @ref{11.4.1}.
Exception_Occurrence_Access    @ref{11.4.1}.
exception_renaming_declaration    @ref{8.5.2}.
   used    @ref{8.5}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Exception_Id    @ref{11.4.1}.
Exceptions
   child of Ada    @ref{11.4.1}.
Exchange    @ref{12.1}(21), see @ref{12.2}(21), see @ref{12.2,,12.2(5)}.
Exchange_Handler    @ref{C.3.2}.
Exclam    @ref{J.5}.
Exclamation    @ref{A.3.3}.
execution    @ref{3.1}(11), see @ref{N}(11), see @ref{N,,N(19)}.
   abort_statement    @ref{9.8}.
   aborting the execution of a construct    @ref{9.8}.
   accept_statement    @ref{9.5.2}.
   Ada program    @ref{9}.
   assignment_statement    @ref{5.2}(7), see @ref{7.6}(7), see @ref{7.6,,7.6(17)},
                           @ref{7.6.1}.
   asynchronous_select with a delay_statement trigger
         @ref{9.7.4}.
   asynchronous_select with an entry call trigger    @ref{9.7.4}.
   block_statement    @ref{5.6}.
   call on a dispatching operation    @ref{3.9.2}.
   call on an inherited subprogram    @ref{3.4}.
   case_statement    @ref{5.4}.
   conditional_entry_call    @ref{9.7.3}.
   delay_statement    @ref{9.6}.
   dynamically enclosing    @ref{11.4}.
   entry_body    @ref{9.5.2}.
   entry_call_statement    @ref{9.5.3}.
   exit_statement    @ref{5.7}.
   goto_statement    @ref{5.8}.
   handled_sequence_of_statements    @ref{11.2}.
   handler    @ref{11.4}.
   if_statement    @ref{5.3}.
   instance of Unchecked_Deallocation    @ref{7.6.1}.
   loop_statement    @ref{5.5}.
   loop_statement with a for iteration_scheme    @ref{5.5}.
   loop_statement with a while iteration_scheme    @ref{5.5}.
   null_statement    @ref{5.1}.
   partition    @ref{10.2}.
   pragma    @ref{2.8}.
   program    @ref{10.2}.
   protected subprogram call    @ref{9.5.1}.
   raise_statement with an exception_name    @ref{11.3}.
   re-raise statement    @ref{11.3}.
   remote subprogram call    @ref{E.4}.
   requeue protected entry    @ref{9.5.4}.
   requeue task entry    @ref{9.5.4}.
   requeue_statement    @ref{9.5.4}.
   return_statement    @ref{6.5}.
   selective_accept    @ref{9.7.1}.
   sequence_of_statements    @ref{5.1}.
   subprogram call    @ref{6.4}.
   subprogram_body    @ref{6.3}.
   task    @ref{9.2}.
   task_body    @ref{9.2}.
   timed_entry_call    @ref{9.7.2}.
execution resource
   associated with a protected object    @ref{9.4}.
   required for a task to run    @ref{9}.
exit_statement    @ref{5.7}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Exp    @ref{A.5.1}(4), see @ref{B.1}(51), see @ref{G.1.2}(4), see @ref{B.1}(51), see @ref{G.1.2,,G.1.2(3)}.
expanded name    @ref{4.1.3}.
Expanded_Name    @ref{3.9}.
expected profile    @ref{8.6}.
   accept_statement entry_direct_name    @ref{9.5.2}.
   Access attribute_reference prefix    @ref{3.10.2}.
   attribute_definition_clause name    @ref{13.3}.
   character_literal    @ref{4.2}.
   formal subprogram actual    @ref{12.6}.
   formal subprogram default_name    @ref{12.6}.
   subprogram_renaming_declaration    @ref{8.5.4}.
expected type    @ref{8.6}.
   abort_statement task_name    @ref{9.8}.
   access attribute_reference    @ref{3.10.2}.
   actual parameter    @ref{6.4.1}.
   aggregate    @ref{4.3}.
   allocator    @ref{4.8}.
   array_aggregate    @ref{4.3.3}.
   array_aggregate component expression    @ref{4.3.3}.
   array_aggregate discrete_choice    @ref{4.3.3}.
   assignment_statement expression    @ref{5.2}.
   assignment_statement variable_name    @ref{5.2}.
   attribute_definition_clause expression or name    @ref{13.3}.
   attribute_designator expression    @ref{4.1.4}.
   case expression    @ref{5.4}.
   case_statement_alternative discrete_choice    @ref{5.4}.
   character_literal    @ref{4.2}.
   code_statement    @ref{13.8}.
   component_clause expressions    @ref{13.5.1}.
   component_declaration default_expression    @ref{3.8}.
   condition    @ref{5.3}.
   decimal fixed point type digits    @ref{3.5.9}.
   delay_relative_statement expression    @ref{9.6}.
   delay_until_statement expression    @ref{9.6}.
   delta_constraint expression    @ref{J.3}.
   dereference name    @ref{4.1}.
   discrete_subtype_definition range    @ref{3.6}.
   discriminant default_expression    @ref{3.7}.
   discriminant_association expression    @ref{3.7.1}.
   entry_index    @ref{9.5.2}.
   enumeration_representation_clause expressions    @ref{13.4}.
   extension_aggregate    @ref{4.3.2}.
   extension_aggregate ancestor expression    @ref{4.3.2}.
   first_bit    @ref{13.5.1}.
   fixed point type delta    @ref{3.5.9}.
   generic formal in object actual    @ref{12.4}.
   generic formal object default_expression    @ref{12.4}.
   index_constraint discrete_range    @ref{3.6.1}.
   indexed_component expression    @ref{4.1.1}.
   Interrupt_Priority pragma argument    @ref{D.1}.
   last_bit    @ref{13.5.1}.
   link name    @ref{B.1}.
   membership test simple_expression    @ref{4.5.2}.
   modular_type_definition expression    @ref{3.5.4}.
   null literal    @ref{4.2}.
   number_declaration expression    @ref{3.3.2}.
   object_declaration initialization expression    @ref{3.3.1}.
   parameter default_expression    @ref{6.1}.
   position    @ref{13.5.1}.
   Priority pragma argument    @ref{D.1}.
   range simple_expressions    @ref{3.5}.
   range_attribute_designator expression    @ref{4.1.4}.
   range_constraint range    @ref{3.5}.
   real_range_specification bounds    @ref{3.5.7}.
   record_aggregate    @ref{4.3.1}.
   record_component_association expression    @ref{4.3.1}.
   requested decimal precision    @ref{3.5.7}.
   restriction parameter expression    @ref{13.12}.
   return expression    @ref{6.5}.
   short-circuit control form relation    @ref{4.5.1}.
   signed_integer_type_definition simple_expression
         @ref{3.5.4}.
   slice discrete_range    @ref{4.1.2}.
   Storage_Size pragma argument    @ref{13.3}.
   string_literal    @ref{4.2}.
   type_conversion operand @ref{4.6}(6)
   variant_part discrete_choice    @ref{3.8.1}.
expiration time
   [partial]    @ref{9.6}.
   for a delay_relative_statement    @ref{9.6}.
   for a delay_until_statement    @ref{9.6}.
explicit declaration    @ref{3.1}(5), see @ref{N}(5), see @ref{N,,N(11)}.
explicit initial value    @ref{3.3.1}.
explicit_actual_parameter    @ref{6.4}.
   used    @ref{6.4}(5), see @ref{P}(5), see @ref{P,,P(1)}.
explicit_dereference    @ref{4.1}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
explicit_generic_actual_parameter    @ref{12.3}.
   used    @ref{12.3}(4), see @ref{P}(4), see @ref{P,,P(1)}.
explicitly assign    @ref{10.2}.
exponent    @ref{2.4.1}(4), see @ref{4.5.6}(4), see @ref{4.5.6,,4.5.6(11)}.
   used    @ref{2.4.1}(2), see @ref{2.4.2}(2), see @ref{P}(2), see @ref{2.4.2}(2), see @ref{P,,P(1)}.
Exponent attribute    @ref{A.5.3}(18), see @ref{K}(18), see @ref{K,,K(60)}.
exponentiation operator    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(7)}.
Export pragma    @ref{B.1}(6), see @ref{L}(6), see @ref{L,,L(13)}.
exported
   aspect of representation    @ref{B.1}.
exported entity    @ref{B.1}.
Expr_Ptr    @ref{3.9.1}.
expression    @ref{3.9}(33), see @ref{4.4}(1), see @ref{4.4}(33), see @ref{4.4}(1), see @ref{4.4,,4.4(2)}.
   used    @ref{2.8}(3),    @ref{3.3.1}(2), see @ref{3.3.2}(3),    @ref{3.3.1}(2), see @ref{3.3.2,,3.3.2(2)},
           @ref{3.5.4}(4), see @ref{3.5.7}(2), see @ref{3.5.9}(4), see @ref{3.5.7}(2), see @ref{3.5.9,,3.5.9(3)},
           @ref{3.5.9}(4), see @ref{3.5.9}(5), see @ref{3.7}(4), see @ref{3.5.9}(5), see @ref{3.7,,3.7(6)},
           @ref{3.7.1}(3), see @ref{3.8.1}(5), see @ref{4.1.1}(3), see @ref{3.8.1}(5), see @ref{4.1.1,,4.1.1(2)},
           @ref{4.1.4}(3), see @ref{4.1.4}(5), see @ref{4.3.1}(3), see @ref{4.1.4}(5), see @ref{4.3.1,,4.3.1(4)},
           @ref{4.3.2}(3), see @ref{4.3.3}(3), see @ref{4.3.3}(3), see @ref{4.3.3}(3), see @ref{4.3.3,,4.3.3(5)},
           @ref{4.4}(7),    @ref{4.6}(2),    @ref{4.7}(7),    @ref{4.6}(2),    @ref{4.7,,4.7(2)},
           @ref{5.2}(2),    @ref{5.3}(3),    @ref{5.4}(2),    @ref{5.3}(3),    @ref{5.4,,5.4(2)},
           @ref{6.4}(6),    @ref{6.5}(2),    @ref{9.5.2}(6),    @ref{6.5}(2),    @ref{9.5.2,,9.5.2(4)},
           @ref{9.6}(3),    @ref{9.6}(4),    @ref{12.3}(3),    @ref{9.6}(4),    @ref{12.3,,12.3(5)},
           @ref{13.3}(2),   @ref{13.3}(63), see @ref{13.5.1}(2),   @ref{13.3}(63), see @ref{13.5.1,,13.5.1(4)},
           @ref{13.12}(4), see @ref{B.1}(5),    @ref{B.1}(4), see @ref{B.1}(5),    @ref{B.1,,B.1(6)},
           @ref{B.1}(8),    @ref{B.1}(10),   @ref{C.3.1}(8),    @ref{B.1}(10),   @ref{C.3.1,,C.3.1(4)},
           @ref{D.1}(3),    @ref{D.1}(5),    @ref{J.3}(3),    @ref{D.1}(5),    @ref{J.3,,J.3(2)},
           @ref{J.7}(1),    @ref{J.8}(1),    @ref{L}(1),    @ref{J.8}(1),    @ref{L,,L(6)},
           @ref{L}(13),     @ref{L}(14),     @ref{L}(13),     @ref{L}(14),     @ref{L,,L(18)},
           @ref{L}(19),     @ref{L}(27),     @ref{L}(19),     @ref{L}(27),     @ref{L,,L(35)},
           @ref{P}.
extended_digit    @ref{2.4.2}.
   used    @ref{2.4.2}(4), see @ref{P}(4), see @ref{P,,P(1)}.
extension
   of a private type    @ref{3.9}(2), see @ref{3.9.1}(2), see @ref{3.9.1,,3.9.1(1)}.
   of a record type    @ref{3.9}(2), see @ref{3.9.1}(2), see @ref{3.9.1,,3.9.1(1)}.
   of a type    @ref{3.9}(2), see @ref{3.9.1}(2), see @ref{3.9.1,,3.9.1(1)}.
extension_aggregate    @ref{4.3.2}.
   used    @ref{4.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
external call    @ref{9.5}.
external effect
   of the execution of an Ada program    @ref{1.1.3}.
   volatile/atomic objects    @ref{C.6}.
external file    @ref{A.7}.
external interaction    @ref{1.1.3}.
external name    @ref{B.1}.
external requeue    @ref{9.5}.
External_Tag    @ref{3.9}.
External_Tag attribute    @ref{13.3}(75), see @ref{K}(75), see @ref{K,,K(64)}.
External_Tag clause    @ref{13.3}(7), see @ref{13.3}(75), see @ref{K}(7), see @ref{13.3}(75), see @ref{K,,K(65)}.
extra permission to avoid raising exceptions    @ref{11.6}.
extra permission to reorder actions    @ref{11.6}.
@end format

@c ---------------------------------------------------------------------------
@node Index.F, Index.G, Index.E, Index
@chapter index

@format
factor    @ref{4.4}.
   used    @ref{4.4}(5), see @ref{P}(5), see @ref{P,,P(1)}.
failure    @ref{A.15}.
   of a language-defined check    @ref{11.5}.
False    @ref{3.5.3}.
family
   entry    @ref{9.5.2}.
Feminine_Ordinal_Indicator    @ref{A.3.3}.
FF    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
Field    @ref{A.10.1}.
file
   as file object    @ref{A.7}.
file terminator    @ref{A.10}.
File_Access    @ref{A.10.1}.
File_Descriptor    @ref{7.5}.
File_Handle    @ref{11.4.2}.
File_Mode    @ref{A.8.1}(4), see @ref{A.8.4}(4), see @ref{A.10.1}(4), see @ref{A.8.4}(4), see @ref{A.10.1,,A.10.1(4)},
             @ref{A.12.1}.
File_Name    @ref{7.3}(22), see @ref{7.5}(18), see @ref{7.5}(22), see @ref{7.5}(18), see @ref{7.5,,7.5(19)}.
File_Not_Found    @ref{11.4.2}.
File_System    @ref{11.4.2}(2), see @ref{11.4.2}(2), see @ref{11.4.2,,11.4.2(6)}.
File_Type    @ref{A.8.1}(3), see @ref{A.8.4}(3), see @ref{A.10.1}(3), see @ref{A.8.4}(3), see @ref{A.10.1,,A.10.1(3)},
             @ref{A.12.1}.
Finalization
   child of Ada    @ref{7.6}.
   of a master    @ref{7.6.1}.
   of a protected object    @ref{9.4}(20), see @ref{C.3.1}(20), see @ref{C.3.1,,C.3.1(12)}.
   of a task object    @ref{J.7.1}.
   of an object    @ref{7.6.1}.
Finalize    @ref{7.6}(2), see @ref{7.6}(6), see @ref{7.6}(2), see @ref{7.6}(6), see @ref{7.6,,7.6(8)}.
Find    @ref{E.4.2}.
Find_Token    @ref{A.4.3}(16), see @ref{A.4.4}(51), see @ref{A.4.5}(16), see @ref{A.4.4}(51), see @ref{A.4.5,,A.4.5(46)}.
Fine_Delta    @ref{13.7}.
   named number in package System    @ref{13.7}.
First attribute    @ref{3.5}(12), see @ref{3.6.2}(3), see @ref{K}(12), see @ref{3.6.2}(3), see @ref{K,,K(68)},
                   @ref{K}.
first subtype    @ref{3.2.1}(6), see @ref{3.4.1}(6), see @ref{3.4.1,,3.4.1(5)}.
First(N) attribute    @ref{3.6.2}(4), see @ref{K}(4), see @ref{K,,K(66)}.
first_bit    @ref{13.5.1}.
   used    @ref{13.5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
First_Bit attribute    @ref{13.5.2}(3), see @ref{K}(3), see @ref{K,,K(72)}.
Fixed
   child of Ada.Strings    @ref{A.4.3}.
fixed point type    @ref{3.5.9}.
fixed_point_definition    @ref{3.5.9}.
   used    @ref{3.5.6}, P(1)
Fixed_IO    @ref{A.10.1}.
Flip_A_Coin @ref{A.5.2}(58)
Float    @ref{3.5.7}(12), see @ref{3.5.7}(14), see @ref{A.1}(12), see @ref{3.5.7}(14), see @ref{A.1,,A.1(21)}.
Float_Random
   child of Ada.Numerics    @ref{A.5.2}.
Float_Text_IO
   child of Ada    @ref{A.10.9}.
Float_Type    @ref{A.5.1}.
Float_Wide_Text_IO
   child of Ada    @ref{A.11}.
Float_IO    @ref{A.10.1}.
Floating    @ref{B.4}.
floating point type    @ref{3.5.7}.
floating_point_definition    @ref{3.5.7}.
   used    @ref{3.5.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Floor attribute    @ref{A.5.3}(30), see @ref{K}(30), see @ref{K,,K(74)}.
Flush    @ref{A.10.1}(21), see @ref{A.12.1}(21), see @ref{A.12.1,,A.12.1(25)}.
Fore attribute    @ref{3.5.10}(4), see @ref{K}(4), see @ref{K,,K(78)}.
form    @ref{A.8.1}(9), see @ref{A.8.4}(9), see @ref{A.10.1}(9), see @ref{A.8.4}(9), see @ref{A.10.1,,A.10.1(12)},
        @ref{A.12.1}.
   of an external file    @ref{A.7}.
formal object, generic    @ref{12.4}.
formal package, generic    @ref{12.7}.
formal parameter
   of a subprogram    @ref{6.1}.
formal subprogram, generic    @ref{12.6}.
formal subtype    @ref{12.5}.
formal type    @ref{12.5}.
formal_access_type_definition    @ref{12.5.4}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_array_type_definition    @ref{12.5.3}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_decimal_fixed_point_definition    @ref{12.5.2}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_derived_type_definition    @ref{12.5.1}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_discrete_type_definition    @ref{12.5.2}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_floating_point_definition    @ref{12.5.2}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_modular_type_definition    @ref{12.5.2}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_object_declaration    @ref{12.4}.
   used    @ref{12.1}(6), see @ref{P}(6), see @ref{P,,P(1)}.
formal_ordinary_fixed_point_definition    @ref{12.5.2}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_package_actual_part    @ref{12.7}.
   used    @ref{12.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
formal_package_declaration    @ref{12.7}.
   used    @ref{12.1}(6), see @ref{P}(6), see @ref{P,,P(1)}.
formal_part    @ref{6.1}.
   used    @ref{6.1}(12), see @ref{6.1}(13), see @ref{P}(12), see @ref{6.1}(13), see @ref{P,,P(1)}.
formal_private_type_definition    @ref{12.5.1}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_signed_integer_type_definition    @ref{12.5.2}.
   used    @ref{12.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
formal_subprogram_declaration    @ref{12.6}.
   used    @ref{12.1}(6), see @ref{P}(6), see @ref{P,,P(1)}.
formal_type_declaration    @ref{12.5}.
   used    @ref{12.1}(6), see @ref{P}(6), see @ref{P,,P(1)}.
formal_type_definition    @ref{12.5}.
   used    @ref{12.5}(2), see @ref{P}(2), see @ref{P,,P(1)}.
format_effector    @ref{2.1}.
   used    @ref{2.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Fortran
   child of Interfaces    @ref{B.5}.
Fortran interface    @ref{B.5}.
FORTRAN standard    @ref{1.2}.
Fortran_Character    @ref{B.5}.
Fortran_Integer    @ref{B.5}.
Fortran_Library    @ref{B.1}.
Fortran_Matrix    @ref{B.5}.
Fraction    @ref{3.5.9}.
Fraction attribute    @ref{A.5.3}(21), see @ref{K}(21), see @ref{K,,K(80)}.
Fraction_One_Half    @ref{A.3.3}.
Fraction_One_Quarter    @ref{A.3.3}.
Fraction_Three_Quarters    @ref{A.3.3}.
Free    @ref{13.11.2}(5), see @ref{A.4.5}(7), see @ref{B.3.1}(5), see @ref{A.4.5}(7), see @ref{B.3.1,,B.3.1(11)}.
freed
   See nonexistent    @ref{13.11.2}.
freeing storage    @ref{13.11.2}.
freezing
   by a constituent of a construct    @ref{13.14}.
   by an expression    @ref{13.14}.
   class-wide type caused by the freezing of the specific type
         @ref{13.14}.
   constituents of a full type definition    @ref{13.14}.
   designated subtype caused by an allocator    @ref{13.14}.
   entity    @ref{13.14}.
   entity caused by a body    @ref{13.14}.
   entity caused by a construct    @ref{13.14}.
   entity caused by a name    @ref{13.14}.
   entity caused by the end of an enclosing construct
         @ref{13.14}.
   first subtype caused by the freezing of the type
         @ref{13.14}.
   function call    @ref{13.14}.
   generic_instantiation    @ref{13.14}.
   nominal subtype caused by a name    @ref{13.14}.
   object_declaration    @ref{13.14}.
   specific type caused by the freezing of the class-wide type
         @ref{13.14}.
   subtype caused by a record extension    @ref{13.14}.
   subtypes of the profile of a callable entity    @ref{13.14}.
   type caused by a range    @ref{13.14}.
   type caused by an expression    @ref{13.14}.
   type caused by the freezing of a subtype    @ref{13.14}.
freezing points
   entity    @ref{13.14}.
FS    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
full conformance
   for discrete_subtype_definitions    @ref{6.3.1}.
   for known_discriminant_parts    @ref{6.3.1}.
   for expressions    @ref{6.3.1}.
   for profiles    @ref{6.3.1}.
   required    @ref{3.10.1}(4), see @ref{6.3}(4),      @ref{7.3}(4), see @ref{6.3}(4),      @ref{7.3,,7.3(9)},
               @ref{8.5.4}(5),   @ref{9.5.2}(14),   @ref{9.5.2}(5),   @ref{9.5.2}(14),   @ref{9.5.2,,9.5.2(16)},
               @ref{9.5.2}(17), see @ref{10.1.3}(11), see @ref{10.1.3}(17), see @ref{10.1.3}(11), see @ref{10.1.3,,10.1.3(12)}.
full constant declaration    @ref{3.3.1}.
full declaration    @ref{7.4}.
full stop    @ref{2.1}.
full type    @ref{3.2.1}.
full type definition    @ref{3.2.1}.
full view
   of a type    @ref{7.3}.
Full_Stop    @ref{A.3.3}.
full_type_declaration    @ref{3.2.1}.
   used    @ref{3.2.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
function    @ref{6}.
function instance    @ref{12.3}.
function_call    @ref{6.4}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.G, Index.H, Index.F, Index
@chapter index

@format
gaps    @ref{13.1}.
garbage collection    @ref{13.11.3}.
Gender    @ref{3.5.1}.
general access type    @ref{3.10}(7), see @ref{3.10}(7), see @ref{3.10,,3.10(8)}.
general_access_modifier    @ref{3.10}.
   used    @ref{3.10}(3), see @ref{P}(3), see @ref{P,,P(1)}.
generation
   of an interrupt    @ref{C.3}.
Generator    @ref{A.5.2}(7), see @ref{A.5.2}(7), see @ref{A.5.2,,A.5.2(19)}.
generic actual    @ref{12.3}.
generic actual parameter    @ref{12.3}.
generic actual subtype    @ref{12.5}.
generic actual type    @ref{12.5}.
generic body    @ref{12.2}.
generic contract issue    @ref{10.2.1}.
   [partial]    @ref{3.9.1}(3),    @ref{3.10.2}(3),    @ref{3.10.2,,3.10.2(28)},
                @ref{3.10.2}(32), see @ref{4.6}(32), see @ref{4.6,,4.6(17)},
                @ref{4.6}(20),     @ref{8.3}(20),     @ref{8.3,,8.3(26)},
                @ref{10.2.1}.
generic formal    @ref{12.1}.
generic formal object    @ref{12.4}.
generic formal package    @ref{12.7}.
generic formal subprogram    @ref{12.6}.
generic formal subtype    @ref{12.5}.
generic formal type    @ref{12.5}.
generic function    @ref{12.1}.
generic package    @ref{12.1}.
generic procedure    @ref{12.1}.
generic subprogram    @ref{12.1}.
generic unit    @ref{12}(1), see @ref{N}(1), see @ref{N,,N(20)}.
   See also dispatching operation    @ref{3.9}.
generic_actual_part    @ref{12.3}.
   used    @ref{12.3}(2), see @ref{12.7}(3), see @ref{P}(2), see @ref{12.7}(3), see @ref{P,,P(1)}.
generic_association    @ref{12.3}.
   used    @ref{12.3}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Generic_Bounded_Length    @ref{A.4.4}.
Generic_Complex_Elementary_Functions
   child of Ada.Numerics    @ref{G.1.2}.
Generic_Complex_Types
   child of Ada.Numerics    @ref{G.1.1}.
generic_declaration    @ref{12.1}.
   used    @ref{3.1}(3), see @ref{10.1.1}(5), see @ref{P}(3), see @ref{10.1.1}(5), see @ref{P,,P(1)}.
Generic_Elementary_Functions
   child of Ada.Numerics    @ref{A.5.1}.
generic_formal_parameter_declaration    @ref{12.1}.
   used    @ref{12.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
generic_formal_part    @ref{12.1}.
   used    @ref{12.1}(3), see @ref{12.1}(4), see @ref{P}(3), see @ref{12.1}(4), see @ref{P,,P(1)}.
generic_instantiation    @ref{12.3}.
   used    @ref{3.1}(3), see @ref{10.1.1}(5), see @ref{P}(3), see @ref{10.1.1}(5), see @ref{P,,P(1)}.
generic_package_declaration    @ref{12.1}.
   used    @ref{12.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
generic_renaming_declaration    @ref{8.5.5}.
   used    @ref{8.5}(2), see @ref{10.1.1}(6), see @ref{P}(2), see @ref{10.1.1}(6), see @ref{P,,P(1)}.
generic_subprogram_declaration    @ref{12.1}.
   used    @ref{12.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Get    @ref{10.1.1}(30), see @ref{A.10.1}(41), see @ref{A.10.1}(30), see @ref{A.10.1}(41), see @ref{A.10.1,,A.10.1(47)},
       @ref{A.10.1}(54), see @ref{A.10.1}(55), see @ref{A.10.1}(54), see @ref{A.10.1}(55), see @ref{A.10.1,,A.10.1(59)},
       @ref{A.10.1}(60), see @ref{A.10.1}(65), see @ref{A.10.1}(60), see @ref{A.10.1}(65), see @ref{A.10.1,,A.10.1(67)},
       @ref{A.10.1}(70), see @ref{A.10.1}(72), see @ref{A.10.1}(70), see @ref{A.10.1}(72), see @ref{A.10.1,,A.10.1(75)},
       @ref{A.10.1}(77), see @ref{A.10.1}(81), see @ref{A.10.1}(77), see @ref{A.10.1}(81), see @ref{A.10.1,,A.10.1(83)},
       @ref{G.1.3}(6),    @ref{G.1.3}(6),    @ref{G.1.3,,G.1.3(8)}.
Get_Immediate    @ref{A.10.1}(44), see @ref{A.10.1}(44), see @ref{A.10.1,,A.10.1(45)}.
Get_Key    @ref{7.3.1}(15), see @ref{7.3.1}(15), see @ref{7.3.1,,7.3.1(16)}.
Get_Line    @ref{A.10.1}.
Get_Priority    @ref{D.5}.
Global    @ref{9.3}.
global to    @ref{8.1}.
Glossary    @ref{N}.
goto_statement    @ref{5.8}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
govern a variant_part    @ref{3.8.1}.
govern a variant    @ref{3.8.1}.
grammar
   complete listing    @ref{P}.
   cross reference    @ref{P}.
   notation    @ref{1.1.4}.
   resolution of ambiguity    @ref{8.6}.
   under Syntax heading    @ref{1.1.2}.
graphic character
   a category of Character    @ref{A.3.2}.
graphic_character    @ref{2.1}.
   used    @ref{2.1}(2), see @ref{2.5}(2), see @ref{2.6}(3), see @ref{P}(2), see @ref{2.5}(2), see @ref{2.6}(3), see @ref{P,,P(1)}.
Graphic_Set    @ref{A.4.6}.
greater than operator    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
greater than or equal operator    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
greater-than sign    @ref{2.1}.
Greater_Than_Sign    @ref{A.3.3}.
GS    @ref{A.3.3}.
guard    @ref{9.7.1}.
   used    @ref{9.7.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.H, Index.I, Index.G, Index
@chapter index

@format
Half_Pi    @ref{4.9}.
handle
   an exception    @ref{11}(1), see @ref{N}(1), see @ref{N,,N(18)}.
   an exception occurrence    @ref{11.4}(1), see @ref{11.4}(1), see @ref{11.4,,11.4(7)}.
handled_sequence_of_statements    @ref{11.2}.
   used    @ref{5.6}(2), see @ref{6.3}(2),    @ref{7.2}(2), see @ref{6.3}(2),    @ref{7.2,,7.2(2)},
           @ref{9.1}(6), see @ref{9.5.2}(3), see @ref{9.5.2}(6), see @ref{9.5.2}(3), see @ref{9.5.2,,9.5.2(5)},
           @ref{P}.
Handler    @ref{C.3.2}.
Handling
   child of Ada.Characters    @ref{A.3.2}.
Hash_Index    @ref{3.5.4}.
head (of a queue)    @ref{D.2.1}.
Head    @ref{A.4.3}(35), see @ref{A.4.3}(36), see @ref{A.4.4}(35), see @ref{A.4.3}(36), see @ref{A.4.4,,A.4.4(70)},
        @ref{A.4.4}(71), see @ref{A.4.5}(65), see @ref{A.4.5}(71), see @ref{A.4.5}(65), see @ref{A.4.5,,A.4.5(66)}.
heap management
   See also alligator    @ref{4.8}.
   user-defined    @ref{13.11}.
held priority    @ref{D.11}.
Hello    @ref{3.3.1}.
heterogeneous input-output    @ref{A.12.1}.
Hexa    @ref{3.5.1}.
hexadecimal
   literal    @ref{2.4.2}.
hexadecimal digit
   a category of Character    @ref{A.3.2}.
hexadecimal literal    @ref{2.4.2}.
Hexadecimal_Digit_Set    @ref{A.4.6}.
hidden from all visibility    @ref{8.3}(5), see @ref{8.3}(5), see @ref{8.3,,8.3(14)}.
   by lack of a with_clause    @ref{8.3}.
   for a declaration completed by a subsequent declaration
         @ref{8.3}.
   for overridden declaration    @ref{8.3}.
   within the declaration itself    @ref{8.3}.
hidden from direct visibility    @ref{8.3}(5), see @ref{8.3}(5), see @ref{8.3,,8.3(21)}.
   by an inner homograph    @ref{8.3}.
   where hidden from all visibility    @ref{8.3}.
hiding    @ref{8.3}.
High_Order_First    @ref{13.5.3}(2), see @ref{B.4}(2), see @ref{B.4,,B.4(25)}.
highest precedence operator    @ref{4.5.6}.
highest_precedence_operator    @ref{4.5}.
Hold    @ref{D.11}.
homograph    @ref{8.3}.
HT    @ref{A.3.3}.
HTJ    @ref{A.3.3}.
HTS    @ref{A.3.3}.
Hyphen    @ref{A.3.3}.
hyphen-minus    @ref{2.1}.
@end format

@c ---------------------------------------------------------------------------
@node Index.I, Index.J, Index.H, Index
@chapter index

@format
i    @ref{G.1.1}(5), see @ref{G.1.1}(5), see @ref{G.1.1,,G.1.1(23)}.
identifier    @ref{2.3}.
   used    @ref{2.8}(2),    @ref{2.8}(3),    @ref{2.8}(2),    @ref{2.8}(3),    @ref{2.8,,2.8(21)},
           @ref{2.8}(23),   @ref{3.1}(4),    @ref{4.1}(23),   @ref{3.1}(4),    @ref{4.1,,4.1(3)},
           @ref{4.1.3}(3), see @ref{4.1.4}(3), see @ref{5.5}(3), see @ref{4.1.4}(3), see @ref{5.5,,5.5(2)},
           @ref{5.6}(2),    @ref{6.1}(5),    @ref{7.1}(2),    @ref{6.1}(5),    @ref{7.1,,7.1(3)},
           @ref{7.2}(2),    @ref{9.1}(4),    @ref{9.1}(2),    @ref{9.1}(4),    @ref{9.1,,9.1(6)},
           @ref{9.4}(4),    @ref{9.4}(7),    @ref{9.5.2}(4),    @ref{9.4}(7),    @ref{9.5.2,,9.5.2(3)},
           @ref{9.5.2}(5), see @ref{11.5}(4),   @ref{13.12}(5), see @ref{11.5}(4),   @ref{13.12,,13.12(4)},
           @ref{B.1}(5),    @ref{B.1}(6),    @ref{B.1}(5),    @ref{B.1}(6),    @ref{B.1,,B.1(7)},
           @ref{D.2.2}(2), see @ref{D.2.2}(3), see @ref{D.3}(2), see @ref{D.2.2}(3), see @ref{D.3,,D.3(3)},
           @ref{D.3}(4),    @ref{D.4}(3),    @ref{D.4}(4),    @ref{D.4}(3),    @ref{D.4,,D.4(4)},
           @ref{L}(8),      @ref{L}(13),     @ref{L}(8),      @ref{L}(13),     @ref{L,,L(14)},
           @ref{L}(20),     @ref{L}(21),     @ref{L}(20),     @ref{L}(21),     @ref{L,,L(23)},
           @ref{L}(29),     @ref{L}(36),     @ref{L}(29),     @ref{L}(36),     @ref{L,,L(37)},
           @ref{M}(95),     @ref{M}(98),     @ref{P}(95),     @ref{M}(98),     @ref{P,,P(1)}.
identifier specific to a pragma    @ref{2.8}.
identifier_letter    @ref{2.1}.
   used    @ref{2.1}(3), see @ref{2.3}(2), see @ref{2.3}(3), see @ref{P}(3), see @ref{2.3}(2), see @ref{2.3}(3), see @ref{P,,P(1)}.
Identity    @ref{A.4.2}(22), see @ref{A.4.7}(22), see @ref{A.4.7,,A.4.7(22)}.
Identity attribute    @ref{11.4.1}(9), see @ref{C.7.1}(9), see @ref{C.7.1,,C.7.1(12)},
                      @ref{K}(84),      @ref{K}(84),      @ref{K,,K(86)}.
idle task    @ref{D.11}.
if_statement    @ref{5.3}.
   used    @ref{5.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
illegal
   construct    @ref{1.1.2}.
   partition    @ref{1.1.2}.
Im    @ref{G.1.1}.
image    @ref{A.5.2}(14), see @ref{A.5.2}(26), see @ref{C.7.1}(14), see @ref{A.5.2}(26), see @ref{C.7.1,,C.7.1(3)},
         @ref{F.3.3}.
   of a value    @ref{3.5}(30), see @ref{K}(30), see @ref{K,,K(273)}.
Image attribute    @ref{3.5}(35), see @ref{K}(35), see @ref{K,,K(88)}.
Imaginary    @ref{B.5}(10), see @ref{G.1.1}(4), see @ref{G.1.1}(10), see @ref{G.1.1}(4), see @ref{G.1.1,,G.1.1(23)}.
immediate scope
   of (a view of) an entity    @ref{8.2}.
   of a declaration    @ref{8.2}.
immediately enclosing    @ref{8.1}.
immediately visible    @ref{8.3}(4), see @ref{8.3}(4), see @ref{8.3,,8.3(21)}.
immediately within @ref{8.1}(13)
implementation advice    @ref{1.1.2}.
implementation defined    @ref{1.1.3}.
   summary of characteristics    @ref{M}.
implementation permissions    @ref{1.1.2}.
implementation requirements    @ref{1.1.2}.
implementation-dependent
   See unspecified    @ref{1.1.3}.
implicit declaration    @ref{3.1}(5), see @ref{N}(5), see @ref{N,,N(11)}.
implicit initial values
   for a subtype    @ref{3.3.1}.
implicit subtype conversion    @ref{4.6}(59), see @ref{4.6}(59), see @ref{4.6,,4.6(60)}.
   Access attribute    @ref{3.10.2}.
   access discriminant    @ref{3.7}.
   array bounds    @ref{4.6}.
   array index    @ref{4.1.1}.
   assignment to view conversion    @ref{4.6}.
   assignment_statement    @ref{5.2}.
   bounds of a decimal fixed point type    @ref{3.5.9}.
   bounds of a fixed point type    @ref{3.5.9}.
   bounds of a floating point type    @ref{3.5.7}.
   bounds of a range    @ref{3.5}(9), see @ref{3.6}(9), see @ref{3.6,,3.6(18)}.
   bounds of signed integer type    @ref{3.5.4}.
   choices of aggregate    @ref{4.3.3}.
   component defaults    @ref{3.3.1}.
   delay expression    @ref{9.6}.
   derived type discriminants    @ref{3.4}.
   discriminant values    @ref{3.7.1}.
   entry index    @ref{9.5.2}.
   expressions in aggregate    @ref{4.3.1}.
   expressions of aggregate    @ref{4.3.3}.
   function return    @ref{6.5}.
   generic formal object of mode in @ref{12.4}(11)
   inherited enumeration literal    @ref{3.4}.
   initialization expression    @ref{3.3.1}.
   initialization expression of allocator    @ref{4.8}.
   named number value    @ref{3.3.2}.
   operand of concatenation    @ref{4.5.3}.
   parameter passing    @ref{6.4.1}(10), see @ref{6.4.1}(10), see @ref{6.4.1,,6.4.1(11)},
                        @ref{6.4.1}.
   pragma Interrupt_Priority    @ref{D.1}(17), see @ref{D.3}(17), see @ref{D.3,,D.3(9)}.
   pragma Priority    @ref{D.1}(17), see @ref{D.3}(17), see @ref{D.3,,D.3(9)}.
   qualified_expression    @ref{4.7}.
   reading a view conversion    @ref{4.6}.
   result of inherited function    @ref{3.4}.
implicit_dereference    @ref{4.1}.
   used    @ref{4.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Import pragma    @ref{B.1}(5), see @ref{L}(5), see @ref{L,,L(14)}.
imported
   aspect of representation    @ref{B.1}.
imported entity    @ref{B.1}.
in (membership test)    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(2)}.
inaccessible partition    @ref{E.1}.
inactive
   a task state    @ref{9}.
included
   one range in another    @ref{3.5}.
incomplete type    @ref{3.10.1}.
incomplete_type_declaration    @ref{3.10.1}.
   used    @ref{3.2.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Increment    @ref{6.1}(37), see @ref{B.3.2}(37), see @ref{B.3.2,,B.3.2(11)}.
indefinite subtype    @ref{3.3}(23), see @ref{3.7}(23), see @ref{3.7,,3.7(26)}.
independent subprogram    @ref{11.6}.
independently addressable    @ref{9.10}.
Index    @ref{12.1}(19),   @ref{12.5.3}(11), see @ref{A.4.3}(19),   @ref{12.5.3}(11), see @ref{A.4.3,,A.4.3(9)},
         @ref{A.4.3}(10), see @ref{A.4.3}(11),   @ref{A.4.4}(10), see @ref{A.4.3}(11),   @ref{A.4.4,,A.4.4(44)},
         @ref{A.4.4}(45), see @ref{A.4.4}(46),   @ref{A.4.5}(45), see @ref{A.4.4}(46),   @ref{A.4.5,,A.4.5(39)},
         @ref{A.4.5}(40), see @ref{A.4.5}(41),   @ref{A.8.4}(40), see @ref{A.4.5}(41),   @ref{A.8.4,,A.8.4(15)},
         @ref{A.12.1}(23), see @ref{B.3.2}(23), see @ref{B.3.2,,B.3.2(4)}.
   of an element of an open direct file    @ref{A.8}.
index range    @ref{3.6}.
index subtype    @ref{3.6}.
index type    @ref{3.6}.
Index_Check    @ref{11.5}.
   [partial]    @ref{4.1.1}(7),   @ref{4.1.2}(7), see @ref{4.3.3}(7),   @ref{4.1.2}(7), see @ref{4.3.3,,4.3.3(29)},
                @ref{4.3.3}(30), see @ref{4.5.3}(8), see @ref{4.6}(30), see @ref{4.5.3}(8), see @ref{4.6,,4.6(51)},
                @ref{4.7}(4),     @ref{4.8}(4),     @ref{4.8,,4.8(10)}.
index_constraint    @ref{3.6.1}.
   used    @ref{3.2.2}(7), see @ref{P}(7), see @ref{P,,P(1)}.
Index_Non_Blank    @ref{A.4.3}(12), see @ref{A.4.4}(12), see @ref{A.4.4,,A.4.4(47)},
                   @ref{A.4.5}.
index_subtype_definition    @ref{3.6}.
   used    @ref{3.6}(3), see @ref{P}(3), see @ref{P,,P(1)}.
indexed_component    @ref{4.1.1}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
indivisible    @ref{C.6}.
information hiding
   See package    @ref{7}.
   See private types and private extensions    @ref{7.3}.
information systems    @ref{C}(1), see @ref{F}(1), see @ref{F,,F(1)}.
informative    @ref{1.1.2}.
inheritance
   See also tagged types and type extension    @ref{3.9}.
   See derived types and classes    @ref{3.4}.
inherited
   from an ancestor type    @ref{3.4.1}.
inherited component    @ref{3.4}(11), see @ref{3.4}(11), see @ref{3.4,,3.4(12)}.
inherited discriminant    @ref{3.4}.
inherited entry    @ref{3.4}.
inherited protected subprogram    @ref{3.4}.
inherited subprogram    @ref{3.4}.
initialization
   of a protected object    @ref{9.4}(14), see @ref{C.3.1}(14), see @ref{C.3.1,,C.3.1(10)},
                            @ref{C.3.1}.
   of a task object    @ref{9.1}(12), see @ref{J.7.1}(12), see @ref{J.7.1,,J.7.1(7)}.
   of an object    @ref{3.3.1}.
initialization expression    @ref{3.3.1}(1), see @ref{3.3.1}(1), see @ref{3.3.1,,3.3.1(4)}.
Initialize    @ref{7.6}(2), see @ref{7.6}(6), see @ref{7.6}(2), see @ref{7.6}(6), see @ref{7.6,,7.6(8)}.
Initialize_Generator    @ref{A.5.2}.
initialized allocator    @ref{4.8}.
Inline pragma    @ref{6.3.2}(3), see @ref{L}(3), see @ref{L,,L(15)}.
Inner    @ref{10.1.3}(20), see @ref{10.1.3}(21), see @ref{10.1.3}(20), see @ref{10.1.3}(21), see @ref{10.1.3,,10.1.3(23)},
         @ref{10.1.3}.
innermost dynamically enclosing    @ref{11.4}.
input    @ref{A.6}.
Input attribute    @ref{13.13.2}(22), see @ref{13.13.2}(22), see @ref{13.13.2,,13.13.2(32)},
                   @ref{K}(92),        @ref{K}(92),        @ref{K,,K(96)}.
Input clause    @ref{13.3}(7), see @ref{13.13.2}(7), see @ref{13.13.2,,13.13.2(36)}.
input-output
   unspecified for access types    @ref{A.7}.
Insert    @ref{A.4.3}(25), see @ref{A.4.3}(26), see @ref{A.4.4}(25), see @ref{A.4.3}(26), see @ref{A.4.4,,A.4.4(60)},
          @ref{A.4.4}(61), see @ref{A.4.5}(55), see @ref{A.4.5}(61), see @ref{A.4.5}(55), see @ref{A.4.5,,A.4.5(56)}.
inspectable object    @ref{H.3.2}.
inspection point    @ref{H.3.2}.
Inspection_Point pragma    @ref{H.3.2}(3), see @ref{L}(3), see @ref{L,,L(16)}.
instance
   of a generic function    @ref{12.3}.
   of a generic package    @ref{12.3}.
   of a generic procedure    @ref{12.3}.
   of a generic subprogram    @ref{12.3}.
   of a generic unit    @ref{12.3}.
instructions for comment submission
@c xref gives error in TeX ???     @ref{Instructions for Comment Submission}.
Int    @ref{3.2.2}(15), see @ref{12.5}(13), see @ref{B.3}(15), see @ref{12.5}(13), see @ref{B.3,,B.3(7)}.
Int_Plus    @ref{8.5.4}.
Int_Vectors    @ref{12.3}.
Int_IO    @ref{A.10.8}.
Integer    @ref{3.5.4}(11), see @ref{3.5.4}(21), see @ref{A.1}(11), see @ref{3.5.4}(21), see @ref{A.1,,A.1(12)}.
integer literal    @ref{2.4}.
integer literals    @ref{3.5.4}(14), see @ref{3.5.4}(14), see @ref{3.5.4,,3.5.4(30)}.
integer type    @ref{3.5.4}(1), see @ref{N}(1), see @ref{N,,N(21)}.
Integer_Address    @ref{13.7.1}.
Integer_Text_IO
   child of Ada    @ref{A.10.8}.
integer_type_definition    @ref{3.5.4}.
   used    @ref{3.2.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Integer_Wide_Text_IO
   child of Ada    @ref{A.11}.
Integer_IO    @ref{A.10.1}.
interaction
   between tasks    @ref{9}.
interface to assembly language    @ref{C.1}.
interface to C    @ref{B.3}.
interface to COBOL    @ref{B.4}.
interface to Fortran    @ref{B.5}.
interface to other languages    @ref{B}.
Interfaces    @ref{B.2}.
Interfaces.COBOL    @ref{B.4}.
Interfaces.Fortran    @ref{B.5}.
Interfaces.C    @ref{B.3}.
Interfaces.C.Pointers    @ref{B.3.2}.
Interfaces.C.Strings    @ref{B.3.1}.
interfacing pragma    @ref{B.1}.
   Convention    @ref{B.1}.
   Export    @ref{B.1}.
   Import    @ref{B.1}.
internal call    @ref{9.5}.
internal code    @ref{13.4}.
internal requeue    @ref{9.5}.
Internal_Tag    @ref{3.9}.
interpretation
   of a complete context    @ref{8.6}.
   of a constituent of a complete context    @ref{8.6}.
   overload resolution    @ref{8.6}.
interrupt    @ref{C.3}.
   example using asynchronous_select    @ref{9.7.4},
                                        @ref{9.7.4}.
interrupt entry    @ref{J.7.1}.
interrupt handler    @ref{C.3}.
Interrupt_Handler    @ref{J.7.1}.
Interrupt_Handler pragma    @ref{C.3.1}(2), see @ref{L}(2), see @ref{L,,L(17)}.
Interrupt_Priority    @ref{13.7}(16), see @ref{D.1}(16), see @ref{D.1,,D.1(10)}.
Interrupt_Priority pragma    @ref{D.1}(5), see @ref{L}(5), see @ref{L,,L(18)}.
Interrupt_ID    @ref{C.3.2}.
Interrupts
   child of Ada    @ref{C.3.2}.
Intersection    @ref{3.9.3}.
intertask communication    @ref{9.5}.
   See also task    @ref{9}.
Intrinsic calling convention    @ref{6.3.1}.
invalid representation    @ref{13.9.1}.
Invert    @ref{B.5}.
Inverted_Exclamation    @ref{A.3.3}.
Inverted_Question    @ref{A.3.3}.
IO_Exceptions    @ref{J.1}.
   child of Ada    @ref{A.13}.
IO_Package    @ref{7.5}(18), see @ref{7.5}(18), see @ref{7.5,,7.5(20)}.
Is_Alphanumeric    @ref{A.3.2}.
Is_Attached    @ref{C.3.2}.
Is_Basic    @ref{A.3.2}.
Is_Callable    @ref{C.7.1}.
Is_Character    @ref{A.3.2}.
Is_Control    @ref{A.3.2}.
Is_Decimal_Digit    @ref{A.3.2}.
Is_Digit    @ref{A.3.2}.
Is_Graphic    @ref{A.3.2}.
Is_Held    @ref{D.11}.
Is_Hexadecimal_Digit    @ref{A.3.2}.
Is_ISO_646    @ref{A.3.2}.
Is_Letter    @ref{A.3.2}.
Is_Lower    @ref{A.3.2}.
Is_Open    @ref{A.8.1}(10), see @ref{A.8.4}(10), see @ref{A.10.1}(10), see @ref{A.8.4}(10), see @ref{A.10.1,,A.10.1(13)},
           @ref{A.12.1}.
Is_Reserved    @ref{C.3.2}.
Is_Special    @ref{A.3.2}.
Is_String    @ref{A.3.2}.
Is_Subset    @ref{A.4.2}(14), see @ref{A.4.7}(14), see @ref{A.4.7,,A.4.7(14)}.
Is_Terminated    @ref{C.7.1}.
Is_Upper    @ref{A.3.2}.
Is_In    @ref{A.4.2}(13), see @ref{A.4.7}(13), see @ref{A.4.7,,A.4.7(13)}.
ISO 10646    @ref{3.5.2}(2), see @ref{3.5.2}(2), see @ref{3.5.2,,3.5.2(3)}.
ISO 1989:1985    @ref{1.2}.
ISO/IEC 10646-1:1993    @ref{1.2}.
ISO/IEC 1539:1991    @ref{1.2}.
ISO/IEC 6429:1992    @ref{1.2}.
ISO/IEC 646:1991    @ref{1.2}.
ISO/IEC 8859-1:1987    @ref{1.2}.
ISO/IEC 9899:1990    @ref{1.2}.
ISO_646    @ref{A.3.2}.
ISO_646_Set    @ref{A.4.6}.
issue
   an entry call    @ref{9.5.3}.
italics
   nongraphic characters    @ref{3.5.2}.
   pseudo-names of anonymous types    @ref{3.2.1}(7), see @ref{A.1}(7), see @ref{A.1,,A.1(2)}.
   syntax rules    @ref{1.1.4}.
   terms introduced or defined    @ref{1.3}.
Item    @ref{3.7}(37),   @ref{12.1}(19), see @ref{12.1}(37),   @ref{12.1}(19), see @ref{12.1,,12.1(22)},
        @ref{12.1}(24), see @ref{12.5}(12), see @ref{12.5.3}(24), see @ref{12.5}(12), see @ref{12.5.3,,12.5.3(11)},
        @ref{12.8}(3),   @ref{12.8}(3),   @ref{12.8,,12.8(14)}.
Iterate    @ref{12.6}.
iteration_scheme    @ref{5.5}.
   used    @ref{5.5}(2), see @ref{P}(2), see @ref{P,,P(1)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.J, Index.K, Index.I, Index
@chapter index

@format
j    @ref{G.1.1}(5), see @ref{G.1.1}(5), see @ref{G.1.1,,G.1.1(23)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.K, Index.L, Index.J, Index
@chapter index

@format
Key    @ref{7.3}(22), see @ref{7.3.1}(22), see @ref{7.3.1,,7.3.1(15)}.
Key_Manager    @ref{7.3.1}(15), see @ref{7.3.1}(15), see @ref{7.3.1,,7.3.1(16)}.
Keyboard    @ref{9.1}.
Keyboard_Driver    @ref{9.1}.
Kilo    @ref{4.9}.
known discriminants    @ref{3.7}.
known_discriminant_part    @ref{3.7}.
   used    @ref{3.2.1}(3), see @ref{3.7}(2), see @ref{9.1}(3), see @ref{3.7}(2), see @ref{9.1,,9.1(2)},
           @ref{9.4}(2),    @ref{P}(2),    @ref{P,,P(1)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.L, Index.M, Index.K, Index
@chapter index

@format
L_Brace    @ref{J.5}.
L_Bracket    @ref{J.5}.
label    @ref{5.1}.
   used    @ref{5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
language
   interface to assembly    @ref{C.1}.
   interface to non-Ada    @ref{B}.
language-defined check    @ref{11.5}(2), see @ref{11.6}(2), see @ref{11.6,,11.6(1)}.
language-defined class
   [partial]    @ref{3.2}.
   of types    @ref{3.2}.
Language-Defined Library Units    @ref{A}.
   Ada    @ref{A.2}.
   Ada.Asynchronous_Task_Control    @ref{D.11}.
   Ada.Calendar    @ref{9.6}.
   Ada.Characters    @ref{A.3.1}.
   Ada.Characters.Handling    @ref{A.3.2}.
   Ada.Characters.Latin_1    @ref{A.3.3}.
   Ada.Command_Line    @ref{A.15}.
   Ada.Decimal    @ref{F.2}.
   Ada.Direct_IO    @ref{A.8.4}(2), see @ref{A.9}(2), see @ref{A.9,,A.9(3)}.
   Ada.Dynamic_Priorities    @ref{D.5}.
   Ada.Exceptions    @ref{11.4.1}.
   Ada.Finalization    @ref{7.6}.
   Ada.Float_Text_IO    @ref{A.10.9}.
   Ada.Float_Wide_Text_IO    @ref{A.11}.
   Ada.Integer_Text_IO    @ref{A.10.8}.
   Ada.Integer_Wide_Text_IO    @ref{A.11}.
   Ada.Interrupts    @ref{C.3.2}.
   Ada.Interrupts.Names    @ref{C.3.2}.
   Ada.IO_Exceptions    @ref{A.13}.
   Ada.Numerics    @ref{A.5}.
   Ada.Numerics.Complex_Elementary_Functions    @ref{G.1.2}.
   Ada.Numerics.Complex_Types    @ref{G.1.1}.
   Ada.Numerics.Discrete_Random    @ref{A.5.2}.
   Ada.Numerics.Elementary_Functions    @ref{A.5.1}.
   Ada.Numerics.Float_Random    @ref{A.5.2}.
   Ada.Numerics.Generic_Complex_Elementary_Functions
         @ref{G.1.2}.
   Ada.Numerics.Generic_Complex_Types    @ref{G.1.1}.
   Ada.Numerics.Generic_Elementary_Functions    @ref{A.5.1}.
   Ada.Real_Time    @ref{D.8}.
   Ada.Sequential_IO    @ref{A.8.1}.
   Ada.Storage_IO    @ref{A.9}.
   Ada.Streams    @ref{13.13.1}.
   Ada.Streams.Stream_IO    @ref{A.12.1}.
   Ada.Strings    @ref{A.4.1}.
   Ada.Strings.Bounded    @ref{A.4.4}.
   Ada.Strings.Fixed    @ref{A.4.3}.
   Ada.Strings.Maps    @ref{A.4.2}.
   Ada.Strings.Maps.Constants    @ref{A.4.6}.
   Ada.Strings.Unbounded    @ref{A.4.5}.
   Ada.Strings.Wide_Bounded    @ref{A.4.7}.
   Ada.Strings.Wide_Fixed    @ref{A.4.7}.
   Ada.Strings.Wide_Maps    @ref{A.4.7}.
   Ada.Strings.Wide_Maps.Wide_Constants    @ref{A.4.7}.
   Ada.Strings.Wide_Unbounded    @ref{A.4.7}.
   Ada.Synchronous_Task_Control    @ref{D.10}.
   Ada.Tags    @ref{3.9}.
   Ada.Task_Attributes    @ref{C.7.2}.
   Ada.Task_Identification    @ref{C.7.1}.
   Ada.Text_IO    @ref{A.10.1}.
   Ada.Text_IO.Complex_IO    @ref{G.1.3}.
   Ada.Text_IO.Editing    @ref{F.3.3}.
   Ada.Text_IO.Text_Streams    @ref{A.12.2}.
   Ada.Unchecked_Conversion    @ref{13.9}.
   Ada.Unchecked_Deallocation    @ref{13.11.2}.
   Ada.Wide_Text_IO    @ref{A.11}.
   Ada.Wide_Text_IO.Complex_IO    @ref{G.1.4}.
   Ada.Wide_Text_IO.Editing    @ref{F.3.4}.
   Ada.Wide_Text_IO.Text_Streams    @ref{A.12.3}.
   Interfaces    @ref{B.2}.
   Interfaces.C    @ref{B.3}.
   Interfaces.C.Pointers    @ref{B.3.2}.
   Interfaces.C.Strings    @ref{B.3.1}.
   Interfaces.COBOL    @ref{B.4}.
   Interfaces.Fortran    @ref{B.5}.
   Standard    @ref{A.1}.
   System    @ref{13.7}.
   System.Address_To_Access_Conversions    @ref{13.7.2}.
   System.Machine_Code    @ref{13.8}.
   System.RPC    @ref{E.5}.
   System.Storage_Elements    @ref{13.7.1}.
   System.Storage_Pools    @ref{13.11}.
Language-Defined Types
   Address, in System    @ref{13.7}.
   Alignment, in Ada.Strings    @ref{A.4.1}.
   Alphanumeric, in Interfaces.COBOL    @ref{B.4}.
   Attribute_Handle, in Ada.Task_Attributes    @ref{C.7.2}.
   Binary, in Interfaces.COBOL    @ref{B.4}.
   Binary_Format, in Interfaces.COBOL    @ref{B.4}.
   Bit_Order, in System    @ref{13.7}.
   Boolean, in Standard    @ref{A.1}.
   Bounded_String, in Ada.Strings.Bounded.Generic_Bounded_Length
         @ref{A.4.4}.
   Byte, in Interfaces.COBOL    @ref{B.4}.
   Byte_Array, in Interfaces.COBOL    @ref{B.4}.
   C_float, in Interfaces.C    @ref{B.3}.
   char, in Interfaces.C    @ref{B.3}.
   char_array, in Interfaces.C    @ref{B.3}.
   char_array_access, in Interfaces.C    @ref{B.3.1}.
   Character, in Standard    @ref{A.1}.
   Character_Set, in Ada.Strings.Maps    @ref{A.4.2}.
   chars_ptr, in Interfaces.C    @ref{B.3.1}.
   chars_ptr_array, in Interfaces.C    @ref{B.3.1}.
   COBOL_Character, in Interfaces.COBOL    @ref{B.4}.
   Complex, in Ada.Numerics.Generic_Complex_Types    @ref{G.1.1}.
   Controlled, in Ada.Finalization    @ref{7.6}.
   Count, in Ada.Direct_IO    @ref{A.8.4}.
   Count, in Ada.Text_IO    @ref{A.10.1}.
   Decimal_Element, in Interfaces.COBOL    @ref{B.4}.
   Direction, in Ada.Strings    @ref{A.4.1}.
   Display_Format, in Interfaces.COBOL    @ref{B.4}.
   double, in Interfaces.C    @ref{B.3}.
   Duration, in Standard    @ref{A.1}.
   Exception_Occurrence, in Ada.Exceptions    @ref{11.4.1}.
   Exception_Occurrence_Access, in Ada.Exceptions    @ref{11.4.1}.
   Exception_Id, in Ada.Exceptions    @ref{11.4.1}.
   File_Mode, in Ada.Direct_IO    @ref{A.8.4}.
   File_Mode, in Ada.Sequential_IO    @ref{A.8.1}.
   File_Mode, in Ada.Text_IO    @ref{A.10.1}.
   File_Type, in Ada.Direct_IO    @ref{A.8.4}.
   File_Type, in Ada.Sequential_IO    @ref{A.8.1}.
   File_Type, in Ada.Text_IO    @ref{A.10.1}.
   Float, in Standard    @ref{A.1}.
   Floating, in Interfaces.COBOL    @ref{B.4}.
   Generator, in Ada.Numerics.Discrete_Random    @ref{A.5.2}.
   Generator, in Ada.Numerics.Float_Random    @ref{A.5.2}.
   Imaginary, in Ada.Numerics.Generic_Complex_Types    @ref{G.1.1}.
   int, in Interfaces.C    @ref{B.3}.
   Integer, in Standard    @ref{A.1}.
   Integer_Address, in System.Storage_Elements    @ref{13.7.1}.
   Interrupt_ID, in Ada.Interrupts    @ref{C.3.2}.
   Limited_Controlled, in Ada.Finalization    @ref{7.6}.
   long, in Interfaces.C    @ref{B.3}.
   Long_Binary, in Interfaces.COBOL    @ref{B.4}.
   long_double, in Interfaces.C    @ref{B.3}.
   Long_Floating, in Interfaces.COBOL    @ref{B.4}.
   Membership, in Ada.Strings    @ref{A.4.1}.
   Name, in System    @ref{13.7}.
   Numeric, in Interfaces.COBOL    @ref{B.4}.
   Packed_Decimal, in Interfaces.COBOL    @ref{B.4}.
   Packed_Format, in Interfaces.COBOL    @ref{B.4}.
   Parameterless_Handler, in Ada.Interrupts    @ref{C.3.2}.
   Partition_ID, in System.RPC    @ref{E.5}.
   Picture, in Ada.Text_IO.Editing    @ref{F.3.3}.
   Picture, in Ada.Wide_Text_IO.Editing    @ref{F.3.4}.
   plain_char, in Interfaces.C    @ref{B.3}.
   Pointer, in Interfaces.C.Pointers    @ref{B.3.2}.
   ptrdiff_t, in Interfaces.C    @ref{B.3}.
   Root_Storage_Pool, in System.Storage_Pools    @ref{13.11}.
   Root_Stream_Type, in Ada.Streams    @ref{13.13.1}.
   Seconds_Count, in Ada.Real_Time    @ref{D.8}.
   short, in Interfaces.C    @ref{B.3}.
   signed_char, in Interfaces.C    @ref{B.3}.
   size_t, in Interfaces.C    @ref{B.3}.
   State, in Ada.Numerics.Discrete_Random    @ref{A.5.2}.
   State, in Ada.Numerics.Float_Random    @ref{A.5.2}.
   Storage_Array, in System.Storage_Elements    @ref{13.7.1}.
   Storage_Element, in System.Storage_Elements    @ref{13.7.1}.
   Storage_Offset, in System.Storage_Elements    @ref{13.7.1}.
   Stream_Access, in Ada.Streams.Stream_IO    @ref{A.12.1}.
   String, in Standard    @ref{A.1}.
   Suspension_Object, in Ada.Synchronous_Task_Control
         @ref{D.10}.
   Tag, in Tags    @ref{3.9}.
   Task_ID, in Ada.Task_Identification    @ref{C.7.1}.
   Time, in Ada.Calendar    @ref{9.6}.
   Time, in Ada.Real_Time    @ref{D.8}.
   Time_Span, in Ada.Real_Time    @ref{D.8}.
   Trim_End, in Ada.Strings    @ref{A.4.1}.
   Truncation, in Ada.Strings    @ref{A.4.1}.
   Type_Set, in Ada.Text_IO    @ref{A.10.1}.
   Unbounded_String, in Ada.Strings.Unbounded    @ref{A.4.5}.
   unsigned, in Interfaces.C    @ref{B.3}.
   unsigned_char, in Interfaces.C    @ref{B.3}.
   unsigned_long, in Interfaces.C    @ref{B.3}.
   unsigned_short, in Interfaces.C    @ref{B.3}.
   wchar_array, in Interfaces.C    @ref{B.3}.
   wchar_t, in Interfaces.C    @ref{B.3}.
   Wide_Character, in Standard    @ref{A.1}.
   Wide_Character_Set, in Ada.Strings.Wide_Maps    @ref{A.4.7}.
   Wide_String, in Standard    @ref{A.1}.
Last attribute    @ref{3.5}(13), see @ref{3.6.2}(5), see @ref{K}(13), see @ref{3.6.2}(5), see @ref{K,,K(102)},
                  @ref{K}.
Last(N) attribute    @ref{3.6.2}(6), see @ref{K}(6), see @ref{K,,K(100)}.
last_bit    @ref{13.5.1}.
   used    @ref{13.5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Last_Bit attribute    @ref{13.5.2}(4), see @ref{K}(4), see @ref{K,,K(106)}.
lateness    @ref{D.9}.
Latin-1    @ref{3.5.2}.
Latin_1
   child of Ada.Characters    @ref{A.3.3}.
layout
   aspect of representation    @ref{13.5}.
Layout_Error    @ref{A.10.1}(85), see @ref{A.13}(85), see @ref{A.13,,A.13(4)}.
LC_German_Sharp_S    @ref{A.3.3}.
LC_Icelandic_Eth    @ref{A.3.3}.
LC_Icelandic_Thorn    @ref{A.3.3}.
LC_A    @ref{A.3.3}(13), see @ref{J.5}(13), see @ref{J.5,,J.5(8)}.
LC_A_Acute    @ref{A.3.3}.
LC_A_Circumflex    @ref{A.3.3}.
LC_A_Diaeresis    @ref{A.3.3}.
LC_A_Grave    @ref{A.3.3}.
LC_A_Ring    @ref{A.3.3}.
LC_A_Tilde    @ref{A.3.3}.
LC_AE_Diphthong    @ref{A.3.3}.
LC_B    @ref{A.3.3}.
LC_C    @ref{A.3.3}.
LC_C_Cedilla    @ref{A.3.3}.
LC_D    @ref{A.3.3}.
LC_E    @ref{A.3.3}.
LC_E_Acute    @ref{A.3.3}.
LC_E_Circumflex    @ref{A.3.3}.
LC_E_Diaeresis    @ref{A.3.3}.
LC_E_Grave    @ref{A.3.3}.
LC_F    @ref{A.3.3}.
LC_G    @ref{A.3.3}.
LC_H    @ref{A.3.3}.
LC_I    @ref{A.3.3}.
LC_I_Acute    @ref{A.3.3}.
LC_I_Circumflex    @ref{A.3.3}.
LC_I_Diaeresis    @ref{A.3.3}.
LC_I_Grave    @ref{A.3.3}.
LC_J    @ref{A.3.3}.
LC_K    @ref{A.3.3}.
LC_L    @ref{A.3.3}.
LC_M    @ref{A.3.3}.
LC_N    @ref{A.3.3}.
LC_N_Tilde    @ref{A.3.3}.
LC_O    @ref{A.3.3}.
LC_O_Acute    @ref{A.3.3}.
LC_O_Circumflex    @ref{A.3.3}.
LC_O_Diaeresis    @ref{A.3.3}.
LC_O_Grave    @ref{A.3.3}.
LC_O_Oblique_Stroke    @ref{A.3.3}.
LC_O_Tilde    @ref{A.3.3}.
LC_P    @ref{A.3.3}.
LC_Q    @ref{A.3.3}.
LC_R    @ref{A.3.3}.
LC_S    @ref{A.3.3}.
LC_T    @ref{A.3.3}.
LC_U    @ref{A.3.3}.
LC_U_Acute    @ref{A.3.3}.
LC_U_Circumflex    @ref{A.3.3}.
LC_U_Diaeresis    @ref{A.3.3}.
LC_U_Grave    @ref{A.3.3}.
LC_V    @ref{A.3.3}.
LC_W    @ref{A.3.3}.
LC_X    @ref{A.3.3}.
LC_Y    @ref{A.3.3}.
LC_Y_Acute    @ref{A.3.3}.
LC_Y_Diaeresis    @ref{A.3.3}.
LC_Z    @ref{A.3.3}(14), see @ref{J.5}(14), see @ref{J.5,,J.5(8)}.
Leading_Nonseparate    @ref{B.4}.
Leading_Part attribute    @ref{A.5.3}(54), see @ref{K}(54), see @ref{K,,K(108)}.
Leading_Separate    @ref{B.4}.
leaving    @ref{7.6.1}.
left    @ref{7.6.1}.
left curly bracket    @ref{2.1}.
left parenthesis    @ref{2.1}.
left square bracket    @ref{2.1}.
Left_Angle_Quotation    @ref{A.3.3}.
Left_Curly_Bracket    @ref{A.3.3}.
Left_Parenthesis    @ref{A.3.3}.
Left_Square_Bracket    @ref{A.3.3}.
legal
   construct    @ref{1.1.2}.
   partition    @ref{1.1.2}.
legality rules    @ref{1.1.2}.
length    @ref{A.4.4}(9), see @ref{A.4.5}(6), see @ref{B.4}(9), see @ref{A.4.5}(6), see @ref{B.4,,B.4(34)},
          @ref{B.4}(39),   @ref{B.4}(44),   @ref{F.3.3}(39),   @ref{B.4}(44),   @ref{F.3.3,,F.3.3(11)}.
   of a dimension of an array    @ref{3.6}.
   of a one-dimensional array    @ref{3.6}.
Length attribute    @ref{3.6.2}(9), see @ref{K}(9), see @ref{K,,K(117)}.
Length(N) attribute    @ref{3.6.2}(10), see @ref{K}(10), see @ref{K,,K(115)}.
Length_Check    @ref{11.5}.
   [partial]    @ref{4.5.1}(8), see @ref{4.6}(37), see @ref{4.6}(8), see @ref{4.6}(37), see @ref{4.6,,4.6(52)}.
Length_Error    @ref{12.1}.
Length_Range    @ref{A.4.4}.
less than operator    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
less than or equal operator    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
less-than sign    @ref{2.1}.
Less_Than_Sign    @ref{A.3.3}.
letter
   a category of Character    @ref{A.3.2}.
Letter_Set    @ref{A.4.6}.
letter_or_digit    @ref{2.3}.
   used    @ref{2.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Level    @ref{3.5.1}.
   accessibility    @ref{3.10.2}.
   library    @ref{3.10.2}.
lexical element    @ref{2.2}.
lexicographic order    @ref{4.5.2}.
LF    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
library    @ref{10.1.4}.
   informal introduction    @ref{10}.
library level    @ref{3.10.2}.
library unit    @ref{10.1}(3), see @ref{10.1.1}(9), see @ref{N}(3), see @ref{10.1.1}(9), see @ref{N,,N(22)}.
   informal introduction    @ref{10}.
   See also   language-defined library units
library unit pragma    @ref{10.1.5}.
   All_Calls_Remote    @ref{E.2.3}.
   categorization pragmas    @ref{E.2}.
   Elaborate_Body    @ref{10.2.1}.
   Preelaborate    @ref{10.2.1}.
   Pure    @ref{10.2.1}.
library_item    @ref{10.1.1}.
   used    @ref{10.1.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
   informal introduction    @ref{10}.
library_unit_body    @ref{10.1.1}.
   used    @ref{10.1.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
library_unit_declaration    @ref{10.1.1}.
   used    @ref{10.1.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
library_unit_renaming_declaration    @ref{10.1.1}.
   used    @ref{10.1.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
lifetime    @ref{3.10.2}.
Light    @ref{3.5.1}.
Limit    @ref{3.3.1}(33), see @ref{7.5}(33), see @ref{7.5,,7.5(20)}.
limited type    @ref{7.5}(1), see @ref{7.5}(3), see @ref{N}(1), see @ref{7.5}(3), see @ref{N,,N(23)}.
   becoming nonlimited    @ref{7.3.1}(5), see @ref{7.5}(5), see @ref{7.5,,7.5(16)}.
Limited_Controlled    @ref{7.6}.
line    @ref{2.2}(2), see @ref{3.6}(28), see @ref{A.10.1}(2), see @ref{3.6}(28), see @ref{A.10.1,,A.10.1(38)}.
line terminator    @ref{A.10}.
Line_Length    @ref{A.10.1}.
Line_Size    @ref{3.5.4}.
Link    @ref{3.10.1}(15), see @ref{12.5.4}(15), see @ref{12.5.4,,12.5.4(8)}.
link name    @ref{B.1}.
link-time error
   See post-compilation error    @ref{1.1.2}(29), see @ref{1.1.5}(29), see @ref{1.1.5,,1.1.5(4)}.
Linker_Options pragma    @ref{B.1}(8), see @ref{L}(8), see @ref{L,,L(19)}.
linking
   See partition building    @ref{10.2}.
List    @ref{7.3}.
List pragma    @ref{2.8}(21), see @ref{L}(21), see @ref{L,,L(20)}.
literal    @ref{3.9.1}(13), see @ref{4.2}(13), see @ref{4.2,,4.2(1)}.
   See also aggregate    @ref{4.3}.
   based    @ref{2.4.2}.
   decimal    @ref{2.4.1}.
   numeric    @ref{2.4}.
little endian    @ref{13.5.3}.
load time    @ref{C.4}.
Local    @ref{9.3}.
local to    @ref{8.1}.
Local_Coordinate    @ref{3.4}.
local_name    @ref{13.1}.
   used    @ref{13.2}(3),    @ref{13.3}(2),    @ref{13.4}(3),    @ref{13.3}(2),    @ref{13.4,,13.4(2)},
           @ref{13.5.1}(2), see @ref{13.5.1}(3), see @ref{13.11.3}(2), see @ref{13.5.1}(3), see @ref{13.11.3,,13.11.3(3)},
           @ref{B.1}(5),     @ref{B.1}(6),     @ref{B.1}(5),     @ref{B.1}(6),     @ref{B.1,,B.1(7)},
           @ref{C.5}(3),     @ref{C.6}(3),     @ref{C.6}(3),     @ref{C.6}(3),     @ref{C.6,,C.6(4)},
           @ref{C.6}(5),     @ref{C.6}(6),     @ref{E.4.1}(5),     @ref{C.6}(6),     @ref{E.4.1,,E.4.1(3)},
           @ref{L}(3),       @ref{L}(4),       @ref{L}(3),       @ref{L}(4),       @ref{L,,L(5)},
           @ref{L}(7),       @ref{L}(8),       @ref{L}(7),       @ref{L}(8),       @ref{L,,L(9)},
           @ref{L}(13),      @ref{L}(14),      @ref{L}(13),      @ref{L}(14),      @ref{L,,L(24)},
           @ref{L}(38),      @ref{L}(39),      @ref{P}(38),      @ref{L}(39),      @ref{P,,P(1)}.
localization    @ref{3.5.2}(4), see @ref{3.5.2}(4), see @ref{3.5.2,,3.5.2(5)}.
Lock    @ref{D.12}(9), see @ref{D.12}(9), see @ref{D.12,,D.12(10)}.
locking policy    @ref{D.3}.
Locking_Policy pragma    @ref{D.3}(3), see @ref{L}(3), see @ref{L,,L(21)}.
Log    @ref{A.5.1}(4), see @ref{G.1.2}(4), see @ref{G.1.2,,G.1.2(3)}.
Logical    @ref{B.5}.
logical operator    @ref{4.5.1}.
   See also not operator    @ref{4.5.6}.
logical_operator    @ref{4.5}.
Long    @ref{4.9}(43), see @ref{B.3}(43), see @ref{B.3,,B.3(7)}.
Long_Binary    @ref{B.4}.
long_double    @ref{B.3}.
Long_Float    @ref{3.5.7}(15), see @ref{3.5.7}(16), see @ref{3.5.7}(15), see @ref{3.5.7}(16), see @ref{3.5.7,,3.5.7(17)}.
Long_Floating    @ref{B.4}.
Long_Integer    @ref{3.5.4}(22), see @ref{3.5.4}(25), see @ref{3.5.4}(22), see @ref{3.5.4}(25), see @ref{3.5.4,,3.5.4(28)}.
Look_Ahead    @ref{A.10.1}.
loop parameter    @ref{5.5}.
loop_parameter_specification    @ref{5.5}.
   used    @ref{5.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
loop_statement    @ref{5.5}.
   used    @ref{5.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
low line    @ref{2.1}.
low-level programming    @ref{C}.
Low_Limit    @ref{3.3.1}.
Low_Line    @ref{A.3.3}.
Low_Order_First    @ref{13.5.3}(2), see @ref{B.4}(2), see @ref{B.4,,B.4(25)}.
lower bound
   of a range    @ref{3.5}.
lower-case letter
   a category of Character    @ref{A.3.2}.
lower_case_identifier_letter    @ref{2.1}.
Lower_Case_Map    @ref{A.4.6}.
Lower_Set    @ref{A.4.6}.
@end format

@c ---------------------------------------------------------------------------
@node Index.M, Index.N, Index.L, Index
@chapter index

@format
Machine attribute    @ref{A.5.3}(60), see @ref{K}(60), see @ref{K,,K(119)}.
machine code insertion    @ref{13.8}(1), see @ref{C.1}(1), see @ref{C.1,,C.1(2)}.
machine numbers
   of a floating point type    @ref{3.5.7}.
Machine_Code    @ref{J.1}.
   child of System    @ref{13.8}.
Machine_Emax attribute    @ref{A.5.3}(8), see @ref{K}(8), see @ref{K,,K(123)}.
Machine_Emin attribute    @ref{A.5.3}(7), see @ref{K}(7), see @ref{K,,K(125)}.
Machine_Mantissa attribute    @ref{A.5.3}(6), see @ref{K}(6), see @ref{K,,K(127)}.
Machine_Overflows attribute    @ref{A.5.3}(12), see @ref{A.5.4}(12), see @ref{A.5.4,,A.5.4(4)},
                               @ref{K}(129),     @ref{K}(129),     @ref{K,,K(131)}.
Machine_Radix attribute    @ref{A.5.3}(2), see @ref{A.5.4}(2), see @ref{A.5.4,,A.5.4(2)},
                           @ref{K}(133),    @ref{K}(133),    @ref{K,,K(135)}.
Machine_Radix clause    @ref{13.3}(7), see @ref{F.1}(7), see @ref{F.1,,F.1(1)}.
Machine_Rounds attribute    @ref{A.5.3}(11), see @ref{A.5.4}(11), see @ref{A.5.4,,A.5.4(3)},
                            @ref{K}(137),     @ref{K}(137),     @ref{K,,K(139)}.
macro
   See generic unit    @ref{12}.
Macron    @ref{A.3.3}.
Main @ref{10.1.1}(33), see @ref{11.4.2}(10)
main subprogram
   for a partition    @ref{10.2}.
Major    @ref{3.5.1}.
Male    @ref{3.2.2}.
malloc
   See allocator    @ref{4.8}.
Maps
   child of Ada.Strings    @ref{A.4.2}.
Mark_Release_Pool_Type    @ref{13.11}.
marshalling    @ref{E.4}.
Masculine_Ordinal_Indicator    @ref{A.3.3}.
Mask    @ref{4.7}.
Mass    @ref{3.5.7}(21), see @ref{12.5}(21), see @ref{12.5,,12.5(13)}.
master    @ref{7.6.1}.
match
   a character to a pattern character    @ref{A.4.2}.
   a character to a pattern character, with
     respect to a character mapping function    @ref{A.4.2}.
   a string to a pattern string    @ref{A.4.2}.
matching components    @ref{4.5.2}.
Matrix    @ref{3.6}.
Matrix_Rec    @ref{3.7}.
Max    @ref{3.3.2}.
Max attribute    @ref{3.5}(19), see @ref{K}(19), see @ref{K,,K(141)}.
Max_Base_Digits    @ref{3.5.7}(6), see @ref{13.7}(6), see @ref{13.7,,13.7(8)}.
   named number in package System    @ref{13.7}.
Max_Binary_Modulus    @ref{3.5.4}(7), see @ref{13.7}(7), see @ref{13.7,,13.7(7)}.
   named number in package System    @ref{13.7}.
Max_Decimal_Digits    @ref{F.2}.
Max_Delta    @ref{F.2}.
Max_Digits    @ref{3.5.7}(6), see @ref{13.7}(6), see @ref{13.7,,13.7(8)}.
   named number in package System    @ref{13.7}.
Max_Digits_Binary    @ref{B.4}.
Max_Digits_Long_Binary    @ref{B.4}.
Max_Image_Width    @ref{A.5.2}(13), see @ref{A.5.2}(13), see @ref{A.5.2,,A.5.2(25)}.
Max_Int    @ref{3.5.4}(14), see @ref{13.7}(14), see @ref{13.7,,13.7(6)}.
   named number in package System    @ref{13.7}.
Max_Length    @ref{A.4.4}.
Max_Line_Size    @ref{3.3.2}.
Max_Mantissa    @ref{13.7}.
   named number in package System    @ref{13.7}.
Max_Nonbinary_Modulus    @ref{3.5.4}(7), see @ref{13.7}(7), see @ref{13.7,,13.7(7)}.
   named number in package System    @ref{13.7}.
Max_Scale    @ref{F.2}.
Max_Size_In_Storage_Elements attribute    @ref{13.11.1},
                                          @ref{K}.
maximum box error
   for a component of the result of evaluating
     a complex function    @ref{G.2.6}.
maximum line length    @ref{A.10}.
maximum page length    @ref{A.10}.
maximum relative error
   for a component of the result of evaluating
     a complex function    @ref{G.2.6}.
   for the evaluation of an elementary function    @ref{G.2.4}.
Medium    @ref{13.3}.
Mega    @ref{4.9}.
Membership    @ref{A.4.1}.
membership test    @ref{4.5.2}.
Memory_Size    @ref{13.7}.
mentioned in a with_clause    @ref{10.1.2}.
message
   See dispatching call    @ref{3.9.2}.
Message_Procedure    @ref{3.10}.
method
   See dispatching subprogram    @ref{3.9.2}.
metrics    @ref{1.1.2}(35), see @ref{C.3.1}(15), see @ref{C.7.2}(35), see @ref{C.3.1}(15), see @ref{C.7.2,,C.7.2(20)},
           @ref{D}(2),       @ref{D.5}(13),    @ref{D.6}(2),       @ref{D.5}(13),    @ref{D.6,,D.6(4)},
           @ref{D.8}(37),    @ref{D.9}(9),     @ref{D.12}(37),    @ref{D.9}(9),     @ref{D.12,,D.12(6)}.
Micro_Sign    @ref{A.3.3}.
Microseconds    @ref{D.8}.
Middle_Dot    @ref{A.3.3}.
Midweek    @ref{3.4}.
Milliseconds    @ref{D.8}.
Min attribute    @ref{3.5}(16), see @ref{K}(16), see @ref{K,,K(147)}.
Min_Cell    @ref{6.1}.
Min_Delta    @ref{F.2}.
Min_Int    @ref{3.5.4}(14), see @ref{13.7}(14), see @ref{13.7,,13.7(6)}.
   named number in package System    @ref{13.7}.
Min_Scale    @ref{F.2}.
Minimum    @ref{8.5.4}.
minus    @ref{2.1}.
minus operator    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4,,4.5.4(1)}.
Mix    @ref{12.5.3}.
Mix_Code    @ref{13.4}.
Mixed    @ref{3.5.1}.
mixed-language programs    @ref{B}(1), see @ref{C.1}(1), see @ref{C.1,,C.1(4)}.
mod operator    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
mod_clause    @ref{J.8}.
   used    @ref{13.5.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
mode    @ref{6.1}(16),    @ref{8.5}(7),   @ref{13.5.1}(16),    @ref{8.5}(7),   @ref{13.5.1,,13.5.1(26)},
        @ref{A.8.1}(9),   @ref{A.8.4}(9), see @ref{A.10.1}(9),   @ref{A.8.4}(9), see @ref{A.10.1,,A.10.1(12)},
        @ref{A.12.1}.
   used    @ref{6.1}(15), see @ref{12.4}(2), see @ref{P}(15), see @ref{12.4}(2), see @ref{P,,P(1)}.
mode conformance    @ref{6.3.1}.
   required    @ref{8.5.4}(4), see @ref{12.5.4}(5), see @ref{12.6}(4), see @ref{12.5.4}(5), see @ref{12.6,,12.6(7)},
               @ref{12.6}.
mode of operation
   nonstandard    @ref{1.1.5}.
   standard    @ref{1.1.5}.
Mode_Error    @ref{A.8.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1,,A.10.1(85)},
              @ref{A.12.1}(26), see @ref{A.13}(26), see @ref{A.13,,A.13(4)}.
Mode_Mask    @ref{13.5.1}.
Model attribute    @ref{A.5.3}(68), see @ref{G.2.2}(7), see @ref{K}(68), see @ref{G.2.2}(7), see @ref{K,,K(151)}.
model interval    @ref{G.2.1}.
   associated with a value    @ref{G.2.1}.
model number    @ref{G.2.1}.
model-oriented attributes
   of a floating point subtype    @ref{A.5.3}.
Model_Emin attribute    @ref{A.5.3}(65), see @ref{G.2.2}(65), see @ref{G.2.2,,G.2.2(4)},
                        @ref{K}.
Model_Epsilon attribute    @ref{A.5.3}(66), see @ref{K}(66), see @ref{K,,K(157)}.
Model_Mantissa attribute    @ref{A.5.3}(64), see @ref{G.2.2}(64), see @ref{G.2.2,,G.2.2(3)},
                            @ref{K}.
Model_Small attribute    @ref{A.5.3}(67), see @ref{K}(67), see @ref{K,,K(161)}.
modular type    @ref{3.5.4}.
modular_type_definition    @ref{3.5.4}.
   used    @ref{3.5.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Modular_IO    @ref{A.10.1}.
module
   See package    @ref{7}.
modulus    @ref{G.1.1}.
   of a modular type    @ref{3.5.4}.
Modulus attribute    @ref{3.5.4}(17), see @ref{K}(17), see @ref{K,,K(163)}.
Money    @ref{3.5.9}(28), see @ref{F.1}(28), see @ref{F.1,,F.1(4)}.
Month    @ref{9.6}.
Month_Number    @ref{9.6}.
Move    @ref{A.4.3}.
multi-dimensional array    @ref{3.6}.
Multiplication_Sign    @ref{A.3.3}.
multiply    @ref{2.1}.
multiply operator    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
multiplying operator    @ref{4.5.5}.
multiplying_operator    @ref{4.5}.
   used    @ref{4.4}(5), see @ref{P}(5), see @ref{P,,P(1)}.
MW    @ref{A.3.3}.
My_Read    @ref{13.3}.
My_Write    @ref{8.5.4}(14), see @ref{13.13.2}(14), see @ref{13.13.2,,13.13.2(40)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.N, Index.O, Index.M, Index
@chapter index

@format
n-dimensional array_aggregate    @ref{4.3.3}.
NAK    @ref{A.3.3}.
name    @ref{4.1}(2),    @ref{13.7}(4),   @ref{13.11.2}(2),    @ref{13.7}(4),   @ref{13.11.2,,13.11.2(3)},
        @ref{A.8.1}(9), see @ref{A.8.4}(9), see @ref{A.10.1}(9), see @ref{A.8.4}(9), see @ref{A.10.1,,A.10.1(12)},
        @ref{A.12.1}.
   used    @ref{2.8}(3),      @ref{3.2.2}(4),    @ref{4.1}(3),      @ref{3.2.2}(4),    @ref{4.1,,4.1(4)},
           @ref{4.1}(5),      @ref{4.1}(6),      @ref{4.4}(5),      @ref{4.1}(6),      @ref{4.4,,4.4(7)},
           @ref{4.6}(2),      @ref{5.2}(2),      @ref{5.7}(2),      @ref{5.2}(2),      @ref{5.7,,5.7(2)},
           @ref{5.8}(2),      @ref{6.3.2}(3),    @ref{6.4}(2),      @ref{6.3.2}(3),    @ref{6.4,,6.4(2)},
           @ref{6.4}(3),      @ref{6.4}(6),      @ref{8.4}(3),      @ref{6.4}(6),      @ref{8.4,,8.4(3)},
           @ref{8.5.1}(2),    @ref{8.5.2}(2),    @ref{8.5.3}(2),    @ref{8.5.2}(2),    @ref{8.5.3,,8.5.3(2)},
           @ref{8.5.4}(2),    @ref{8.5.5}(2),    @ref{9.5.3}(2),    @ref{8.5.5}(2),    @ref{9.5.3,,9.5.3(2)},
           @ref{9.5.4}(2),    @ref{9.8}(2),      @ref{10.1.1}(2),    @ref{9.8}(2),      @ref{10.1.1,,10.1.1(8)},
           @ref{10.1.2}(4),   @ref{10.2.1}(3),   @ref{10.2.1}(4),   @ref{10.2.1}(3),   @ref{10.2.1,,10.2.1(14)},
           @ref{10.2.1}(20), see @ref{10.2.1}(21), see @ref{10.2.1}(20), see @ref{10.2.1}(21), see @ref{10.2.1,,10.2.1(22)},
           @ref{11.2}(5),     @ref{11.3}(2),     @ref{11.5}(5),     @ref{11.3}(2),     @ref{11.5,,11.5(4)},
           @ref{12.3}(2),     @ref{12.3}(5),     @ref{12.6}(2),     @ref{12.3}(5),     @ref{12.6,,12.6(4)},
           @ref{12.7}(2),     @ref{13.1}(3),     @ref{13.3}(2),     @ref{13.1}(3),     @ref{13.3,,13.3(2)},
           @ref{C.3.1}(2),    @ref{C.3.1}(4),    @ref{E.2.1}(2),    @ref{C.3.1}(4),    @ref{E.2.1,,E.2.1(3)},
           @ref{E.2.2}(3),    @ref{E.2.3}(3),    @ref{E.2.3}(3),    @ref{E.2.3}(3),    @ref{E.2.3,,E.2.3(5)},
           @ref{H.3.2}(3),    @ref{L}(2),        @ref{L}(3),    @ref{L}(2),        @ref{L,,L(6)},
           @ref{L}(10),       @ref{L}(11),       @ref{L}(10),       @ref{L}(11),       @ref{L,,L(12)},
           @ref{L}(15),       @ref{L}(16),       @ref{L}(15),       @ref{L}(16),       @ref{L,,L(17)},
           @ref{L}(26),       @ref{L}(28),       @ref{L}(26),       @ref{L}(28),       @ref{L,,L(30)},
           @ref{L}(31),       @ref{L}(34),       @ref{L}(31),       @ref{L}(34),       @ref{L,,L(36)},
           @ref{P}.
   [partial]    @ref{3.1}.
   of (a view of) an entity    @ref{3.1}.
   of a pragma    @ref{2.8}.
   of an external file    @ref{A.7}.
name resolution rules    @ref{1.1.2}.
Name_Error    @ref{A.8.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1,,A.10.1(85)},
              @ref{A.12.1}(26), see @ref{A.13}(26), see @ref{A.13,,A.13(4)}.
Name_Server    @ref{E.4.2}.
named association    @ref{6.4}(7), see @ref{12.3}(7), see @ref{12.3,,12.3(6)}.
named component association    @ref{4.3.1}.
named discriminant association    @ref{3.7.1}.
named entry index    @ref{9.5.2}.
named number    @ref{3.3}.
named type    @ref{3.2.1}.
named_array_aggregate    @ref{4.3.3}.
   used    @ref{4.3.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Names
   child of Ada.Interrupts    @ref{C.3.2}.
names of special_characters    @ref{2.1}.
Nanoseconds    @ref{D.8}.
Native_Binary    @ref{B.4}.
Natural    @ref{3.5.4}(12), see @ref{3.5.4}(13), see @ref{A.1}(12), see @ref{3.5.4}(13), see @ref{A.1,,A.1(13)}.
NBH    @ref{A.3.3}.
needed
   of a compilation unit by another    @ref{10.2}.
   remote call interface    @ref{E.2.3}.
   shared passive library unit    @ref{E.2.1}.
needed component
   extension_aggregate record_component_association_list
         @ref{4.3.2}.
   record_aggregate record_component_association_list
         @ref{4.3.1}.
NEL    @ref{A.3.3}.
new
   See allocator    @ref{4.8}.
New_Char_Array    @ref{B.3.1}.
New_Line    @ref{A.10.1}.
New_Page    @ref{A.10.1}.
New_String    @ref{B.3.1}.
New_Tape    @ref{E.4.2}.
Next    @ref{8.5.4}.
Next_Action    @ref{9.1}.
Next_Frame    @ref{6.1}.
Next_Lexeme    @ref{9.1}.
Next_Work_Item    @ref{9.1}.
Ninety_Six    @ref{3.6.3}.
No_Break_Space    @ref{A.3.3}.
Node    @ref{12.5.4}.
nominal subtype    @ref{3.3}(23), see @ref{3.3.1}(23), see @ref{3.3.1,,3.3.1(8)}.
   associated with a type_conversion    @ref{4.6}.
   associated with a dereference    @ref{4.1}.
   associated with an indexed_component    @ref{4.1.1}.
   of a component    @ref{3.6}.
   of a formal parameter    @ref{6.1}.
   of a generic formal object    @ref{12.4}.
   of a record component    @ref{3.8}.
   of the result of a function_call    @ref{6.4}.
non-normative
   See informative    @ref{1.1.2}.
nondispatching call
   on a dispatching operation    @ref{3.9.2}.
nonexistent    @ref{13.11.2}(10), see @ref{13.11.2}(10), see @ref{13.11.2,,13.11.2(16)}.
nongraphic character    @ref{3.5}.
nonlimited type    @ref{7.5}.
   becoming nonlimited    @ref{7.3.1}(5), see @ref{7.5}(5), see @ref{7.5,,7.5(16)}.
nonstandard integer type    @ref{3.5.4}.
nonstandard mode    @ref{1.1.5}.
nonstandard real type    @ref{3.5.6}.
normal completion    @ref{7.6.1}.
normal library unit    @ref{E.2}.
normal state of an object    @ref{11.6}(6), see @ref{13.9.1}(6), see @ref{13.9.1,,13.9.1(4)}.
   [partial]    @ref{9.8}(21), see @ref{A.13}(21), see @ref{A.13,,A.13(17)}.
Normalize_Scalars pragma    @ref{H.1}(3), see @ref{L}(3), see @ref{L,,L(22)}.
normalized exponent    @ref{A.5.3}.
normalized number    @ref{A.5.3}.
normative    @ref{1.1.2}.
not equal operator    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
not in (membership test)    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(2)}.
not operator    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(3)}.
Not_Sign    @ref{A.3.3}.
notes    @ref{1.1.2}.
notwithstanding    @ref{10.1.6}(2), see @ref{B.1}(22), see @ref{B.1}(2), see @ref{B.1}(22), see @ref{B.1,,B.1(38)},
                   @ref{C.3.1}(19), see @ref{E.2.1}(19), see @ref{E.2.1,,E.2.1(8)},
         @ref{E.2.1}(11), see @ref{E.2.3}(18), see @ref{J.3}(11), see @ref{E.2.3}(18), see @ref{J.3,,J.3(6)}.
NUL    @ref{A.3.3}(5), see @ref{B.3}(20), see @ref{J.5}(5), see @ref{B.3}(20), see @ref{J.5,,J.5(4)}.
null access value    @ref{4.2}.
null array    @ref{3.6.1}.
null constraint    @ref{3.2}.
null pointer
   See null access value    @ref{4.2}.
null range    @ref{3.5}.
null record    @ref{3.8}.
null slice    @ref{4.1.2}.
null string literal    @ref{2.6}.
null value
   of an access type    @ref{3.10}.
Null_Address    @ref{13.7}.
   constant in System    @ref{13.7}.
Null_Bounded_String    @ref{A.4.4}.
Null_Key    @ref{7.3.1}(15), see @ref{7.4}(15), see @ref{7.4,,7.4(13)}.
Null_Occurrence    @ref{11.4.1}.
Null_Ptr    @ref{B.3.1}.
Null_Set    @ref{A.4.2}(5), see @ref{A.4.7}(5), see @ref{A.4.7,,A.4.7(5)}.
null_statement    @ref{5.1}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Null_Task_ID    @ref{C.7.1}.
Null_Unbounded_String    @ref{A.4.5}.
Null_Id    @ref{11.4.1}.
Num    @ref{A.10.1}(52), see @ref{A.10.1}(57), see @ref{A.10.1}(52), see @ref{A.10.1}(57), see @ref{A.10.1,,A.10.1(63)},
       @ref{A.10.1}(68), see @ref{A.10.1}(73), see @ref{B.4}(68), see @ref{A.10.1}(73), see @ref{B.4,,B.4(31)},
         @ref{F.3.3}.
number sign    @ref{2.1}.
Number_Base    @ref{A.10.1}(6), see @ref{A.10.8}(6), see @ref{A.10.8,,A.10.8(3)}.
number_declaration    @ref{3.3.2}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Number_Sign    @ref{A.3.3}.
numeral    @ref{2.4.1}.
   used    @ref{2.4.1}(2), see @ref{2.4.1}(4), see @ref{2.4.2}(2), see @ref{2.4.1}(4), see @ref{2.4.2,,2.4.2(3)},
           @ref{P}.
Numeric    @ref{B.4}.
numeric type    @ref{3.5}.
Numeric_Error    @ref{J.6}.
numeric_literal    @ref{2.4}.
   used    @ref{4.4}(7), see @ref{P}(7), see @ref{P,,P(1)}.
Numerics    @ref{G}.
   child of Ada    @ref{A.5}.
@end format

@c ---------------------------------------------------------------------------
@node Index.O, Index.P, Index.N, Index
@chapter index

@format
object    @ref{3.3}(2), see @ref{13.7.2}(2), see @ref{13.11.2}(2), see @ref{13.7.2}(2), see @ref{13.11.2,,13.11.2(3)},
          @ref{N}.
   [partial]    @ref{3.2}.
object-oriented programming (OOP)
   See dispatching operations of tagged types    @ref{3.9.2}.
   See tagged types and type extensions    @ref{3.9}.
object_declaration    @ref{3.3.1}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Object_Pointer    @ref{13.7.2}.
object_renaming_declaration    @ref{8.5.1}.
   used    @ref{8.5}(2), see @ref{P}(2), see @ref{P,,P(1)}.
obsolescent feature    @ref{J}.
occur immediately within @ref{8.1}(13)
occurrence
   of an interrupt    @ref{C.3}.
octal
   literal    @ref{2.4.2}.
octal literal    @ref{2.4.2}.
On_Stacks    @ref{12.8}.
On_Vectors    @ref{12.1}(24), see @ref{12.2}(24), see @ref{12.2,,12.2(9)}.
one's complement
   modular types    @ref{3.5.4}.
one-dimensional array    @ref{3.6}.
only as a completion
   entry_body    @ref{9.5.2}.
OOP (object-oriented programming)
   See dispatching operations of tagged types    @ref{3.9.2}.
   See tagged types and type extensions    @ref{3.9}.
opaque type
   See private types and private extensions    @ref{7.3}.
Open    @ref{7.5}(19),     @ref{7.5}(20),   @ref{11.4.2}(19),     @ref{7.5}(20),   @ref{11.4.2,,11.4.2(3)},
        @ref{11.4.2}(6),   @ref{A.8.1}(7), see @ref{A.8.4}(6),   @ref{A.8.1}(7), see @ref{A.8.4,,A.8.4(7)},
        @ref{A.10.1}(10), see @ref{A.12.1}(10), see @ref{A.12.1,,A.12.1(9)}.
open alternative    @ref{9.7.1}.
open entry    @ref{9.5.3}.
   of a protected object    @ref{9.5.3}.
   of a task    @ref{9.5.3}.
operand
   of a type_conversion    @ref{4.6}.
   of a qualified_expression    @ref{4.7}.
operand interval    @ref{G.2.1}.
operand type
   of a type_conversion    @ref{4.6}.
operates on a type    @ref{3.2.3}.
operator    @ref{6.6}.
   &    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.3,,4.5.3(3)}.
   *    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   **    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(7)}.
   +    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4,,4.5.4(1)}.
   =    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   -    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4,,4.5.4(1)}.
   /    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   /=    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   <    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   <=    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   >    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   >=    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   abs    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(1)}.
   ampersand @ref{4.4}(1), see @ref{4.5.3}(3)
   and @ref{4.4}(1), see @ref{4.5.1}(2)
   binary    @ref{4.5}.
   binary adding    @ref{4.5.3}.
   concatenation    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.3,,4.5.3(3)}.
   divide    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   equal    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   equality    @ref{4.5.2}.
   exponentiation    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(7)}.
   greater than    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   greater than or equal    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   highest precedence    @ref{4.5.6}.
   less than    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   less than or equal    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   logical    @ref{4.5.1}.
   minus    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4,,4.5.4(1)}.
   mod    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   multiply    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   multiplying    @ref{4.5.5}.
   not    @ref{4.4}(1), see @ref{4.5.6}(1), see @ref{4.5.6,,4.5.6(3)}.
   not equal    @ref{4.4}(1), see @ref{4.5.2}(1), see @ref{4.5.2,,4.5.2(1)}.
   or    @ref{4.4}(1), see @ref{4.5.1}(1), see @ref{4.5.1,,4.5.1(2)}.
   ordering    @ref{4.5.2}.
   plus    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4,,4.5.4(1)}.
   predefined    @ref{4.5}.
   relational    @ref{4.5.2}.
   rem    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   times    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
   unary    @ref{4.5}.
   unary adding    @ref{4.5.4}.
   user-defined    @ref{6.6}.
   xor    @ref{4.4}(1), see @ref{4.5.1}(1), see @ref{4.5.1,,4.5.1(2)}.
operator precedence    @ref{4.5}.
operator_symbol    @ref{6.1}.
   used    @ref{4.1}(3),   @ref{4.1.3}(3), see @ref{6.1}(3),   @ref{4.1.3}(3), see @ref{6.1,,6.1(5)},
           @ref{6.1}(11), see @ref{P}(11), see @ref{P,,P(1)}.
optimization    @ref{11.5}(29), see @ref{11.6}(29), see @ref{11.6,,11.6(1)}.
Optimize pragma    @ref{2.8}(23), see @ref{L}(23), see @ref{L,,L(23)}.
Option    @ref{12.5.3}.
or else (short-circuit control form)    @ref{4.4},
                                        @ref{4.5.1}.
or operator    @ref{4.4}(1), see @ref{4.5.1}(1), see @ref{4.5.1,,4.5.1(2)}.
ordering operator    @ref{4.5.2}.
ordinary fixed point type    @ref{3.5.9}(1), see @ref{3.5.9}(1), see @ref{3.5.9,,3.5.9(8)}.
ordinary_fixed_point_definition    @ref{3.5.9}.
   used    @ref{3.5.9}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Origin @ref{3.9.1}(12)
OSC    @ref{A.3.3}.
other_control_function    @ref{2.1}.
   used    @ref{2.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Other_Procedure    @ref{3.10}.
output    @ref{A.6}.
Output attribute    @ref{13.13.2}(19), see @ref{13.13.2}(19), see @ref{13.13.2,,13.13.2(29)},
                    @ref{K}(165),       @ref{K}(165),       @ref{K,,K(169)}.
Output clause    @ref{13.3}(7), see @ref{13.13.2}(7), see @ref{13.13.2,,13.13.2(36)}.
overall interpretation
   of a complete context    @ref{8.6}.
Overflow_Check    @ref{11.5}.
   [partial]    @ref{3.5.4}(20), see @ref{4.4}(11),   @ref{5.4}(20), see @ref{4.4}(11),   @ref{5.4,,5.4(13)},
                @ref{G.2.1}(11), see @ref{G.2.2}(7), see @ref{G.2.3}(11), see @ref{G.2.2}(7), see @ref{G.2.3,,G.2.3(25)},
                @ref{G.2.4}(2),   @ref{G.2.6}(2),   @ref{G.2.6,,G.2.6(3)}.
overload resolution    @ref{8.6}.
overloadable    @ref{8.3}.
overloaded    @ref{8.3}.
   enumeration literal    @ref{3.5.1}.
overloading rules    @ref{1.1.2}(26), see @ref{8.6}(26), see @ref{8.6,,8.6(2)}.
override    @ref{8.3}(9), see @ref{12.3}(9), see @ref{12.3,,12.3(17)}.
   a primitive subprogram    @ref{3.2.3}.
Overwrite    @ref{A.4.3}(27), see @ref{A.4.3}(28), see @ref{A.4.4}(27), see @ref{A.4.3}(28), see @ref{A.4.4,,A.4.4(62)},
             @ref{A.4.4}(63), see @ref{A.4.5}(57), see @ref{A.4.5}(63), see @ref{A.4.5}(57), see @ref{A.4.5,,A.4.5(58)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.P, Index.Q, Index.O, Index
@chapter index

@format
P    @ref{9.2}(11), see @ref{12.5.3}(11), see @ref{12.5.4}(11), see @ref{12.5.3}(11), see @ref{12.5.4,,12.5.4(8)}.
Pack pragma    @ref{13.2}(3), see @ref{L}(3), see @ref{L,,L(24)}.
Package    @ref{7}(1), see @ref{N}(1), see @ref{N,,N(25)}.
package instance    @ref{12.3}.
package_body    @ref{7.2}.
   used    @ref{3.11}(6), see @ref{10.1.1}(7), see @ref{P}(6), see @ref{10.1.1}(7), see @ref{P,,P(1)}.
package_body_stub    @ref{10.1.3}.
   used    @ref{10.1.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
package_declaration    @ref{7.1}.
   used    @ref{3.1}(3), see @ref{10.1.1}(5), see @ref{P}(3), see @ref{10.1.1}(5), see @ref{P,,P(1)}.
package_renaming_declaration    @ref{8.5.3}.
   used    @ref{8.5}(2), see @ref{10.1.1}(6), see @ref{P}(2), see @ref{10.1.1}(6), see @ref{P,,P(1)}.
package_specification    @ref{7.1}.
   used    @ref{7.1}(2), see @ref{12.1}(4), see @ref{P}(2), see @ref{12.1}(4), see @ref{P,,P(1)}.
packed    @ref{13.2}.
Packed_Decimal    @ref{B.4}.
Packed_Descriptor    @ref{13.6}.
Packed_Format    @ref{B.4}.
Packed_Signed    @ref{B.4}.
Packed_Unsigned    @ref{B.4}.
packing
   aspect of representation    @ref{13.2}.
padding bits    @ref{13.1}.
Page    @ref{13.3}(80), see @ref{A.10.1}(80), see @ref{A.10.1,,A.10.1(39)}.
Page pragma    @ref{2.8}(22), see @ref{L}(22), see @ref{L,,L(25)}.
page terminator    @ref{A.10}.
Page_Length    @ref{A.10.1}.
Page_Num    @ref{3.5.4}.
Painted_Point    @ref{3.9.1}.
Pair    @ref{6.4}.
parallel processing
   See task    @ref{9}.
Parallel_Simulation    @ref{A.5.2}.
parameter
   See also discriminant    @ref{3.7}.
   See also loop parameter    @ref{5.5}.
   See formal parameter    @ref{6.1}.
   See generic formal parameter    @ref{12}.
parameter assigning back    @ref{6.4.1}.
parameter copy back    @ref{6.4.1}.
parameter mode    @ref{6.1}.
parameter passing    @ref{6.4.1}.
parameter_and_result_profile    @ref{6.1}.
   used    @ref{3.10}(5), see @ref{6.1}(4), see @ref{P}(5), see @ref{6.1}(4), see @ref{P,,P(1)}.
parameter_association    @ref{6.4}.
   used    @ref{6.4}(4), see @ref{P}(4), see @ref{P,,P(1)}.
parameter_profile    @ref{6.1}.
   used    @ref{3.10}(5),   @ref{6.1}(4),    @ref{9.5.2}(5),   @ref{6.1}(4),    @ref{9.5.2,,9.5.2(2)},
           @ref{9.5.2}(3), see @ref{9.5.2}(6), see @ref{P}(3), see @ref{9.5.2}(6), see @ref{P,,P(1)}.
parameter_specification    @ref{6.1}.
   used    @ref{6.1}(14), see @ref{P}(14), see @ref{P,,P(1)}.
Parameterless_Handler    @ref{C.3.2}.
Params_Stream_Type    @ref{E.5}.
Parent    @ref{10.1.3}(20), see @ref{10.1.3}(21), see @ref{10.1.3}(20), see @ref{10.1.3}(21), see @ref{10.1.3,,10.1.3(23)}.
parent body
   of a subunit    @ref{10.1.3}.
parent declaration
   of a library_item    @ref{10.1.1}.
   of a library unit    @ref{10.1.1}.
parent subtype    @ref{3.4}.
parent type    @ref{3.4}.
parent unit
   of a library unit    @ref{10.1.1}.
parent_unit_name    @ref{10.1.1}.
   used    @ref{6.1}(5), see @ref{6.1}(7),     @ref{7.1}(5), see @ref{6.1}(7),     @ref{7.1,,7.1(3)},
           @ref{7.2}(2), see @ref{10.1.3}(7), see @ref{P}(2), see @ref{10.1.3}(7), see @ref{P,,P(1)}.
Parser    @ref{9.1}.
part
   of an object or value    @ref{3.2}.
partial view
   of a type    @ref{7.3}.
partition    @ref{10.2}(2), see @ref{N}(2), see @ref{N,,N(26)}.
partition building    @ref{10.2}.
partition communication subsystem (PCS)    @ref{E.5}.
Partition_Check
   [partial]    @ref{E.4}.
Partition_ID    @ref{E.5}.
Partition_ID attribute    @ref{E.1}(9), see @ref{K}(9), see @ref{K,,K(173)}.
pass by copy    @ref{6.2}.
pass by reference    @ref{6.2}.
passive partition    @ref{E.1}.
PCS (partition communication subsystem)    @ref{E.5}.
pending interrupt occurrence    @ref{C.3}.
per-object constraint    @ref{3.8}.
per-object expression    @ref{3.8}.
Percent    @ref{J.5}.
Percent_Sign    @ref{A.3.3}.
perfect result set    @ref{G.2.3}.
periodic task
   See delay_until_statement    @ref{9.6}.
   example    @ref{9.6}.
Peripheral    @ref{3.8.1}.
Peripheral_Ref    @ref{3.10}.
Person    @ref{3.10.1}(19), see @ref{3.10.1}(19), see @ref{3.10.1,,3.10.1(22)}.
Person_Name    @ref{3.10.1}.
Pi    @ref{A.5}.
Pic_String    @ref{F.3.3}.
Picture    @ref{F.3.3}.
picture String
   for edited output    @ref{F.3.1}.
Picture_Error    @ref{F.3.3}.
Pilcrow_Sign    @ref{A.3.3}.
plain_char    @ref{B.3}.
PLD    @ref{A.3.3}.
PLU    @ref{A.3.3}.
plus operator    @ref{4.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4}(1), see @ref{4.5.3}(1), see @ref{4.5.4,,4.5.4(1)}.
plus sign    @ref{2.1}.
Plus_Minus_Sign    @ref{A.3.3}.
Plus_Sign    @ref{A.3.3}.
PM    @ref{A.3.3}.
point    @ref{1}(2.15), see @ref{3.9}(2.15), see @ref{3.9,,3.9(32)}.
pointer    @ref{B.3.2}.
   See access value    @ref{3.10}.
   See type System.Address    @ref{13.7}.
pointer type
   See access type    @ref{3.10}.
Pointer_Error    @ref{B.3.2}.
Pointers
   child of Interfaces.C    @ref{B.3.2}.
polymorphism    @ref{3.9}(1), see @ref{3.9.2}(1), see @ref{3.9.2,,3.9.2(1)}.
pool element    @ref{3.10}(7), see @ref{13.11}(7), see @ref{13.11,,13.11(11)}.
pool type    @ref{13.11}.
pool-specific access type    @ref{3.10}(7), see @ref{3.10}(7), see @ref{3.10,,3.10(8)}.
Pop    @ref{12.8}(3), see @ref{12.8}(7), see @ref{12.8}(3), see @ref{12.8}(7), see @ref{12.8,,12.8(14)}.
Pos attribute    @ref{3.5.5}(2), see @ref{K}(2), see @ref{K,,K(175)}.
position    @ref{13.5.1}.
   used    @ref{13.5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Position attribute    @ref{13.5.2}(2), see @ref{K}(2), see @ref{K,,K(179)}.
position number    @ref{3.5}.
   of an enumeration value    @ref{3.5.1}.
   of an integer value    @ref{3.5.4}.
positional association    @ref{6.4}(7), see @ref{12.3}(7), see @ref{12.3,,12.3(6)}.
positional component association    @ref{4.3.1}.
positional discriminant association    @ref{3.7.1}.
positional_array_aggregate    @ref{4.3.3}.
   used    @ref{4.3.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Positive    @ref{3.5.4}(12), see @ref{3.5.4}(13), see @ref{3.6.3}(12), see @ref{3.5.4}(13), see @ref{3.6.3,,3.6.3(3)},
            @ref{A.1}.
Positive_Count    @ref{A.8.4}(4),   @ref{A.10}(4),   @ref{A.10,,A.10(10)},
                  @ref{A.10.1}(5), see @ref{A.12.1}(5), see @ref{A.12.1,,A.12.1(7)}.
possible interpretation    @ref{8.6}.
   for direct_names    @ref{8.3}.
   for selector_names    @ref{8.3}.
post-compilation error    @ref{1.1.2}.
post-compilation rules    @ref{1.1.2}(29), see @ref{10.1.3}(29), see @ref{10.1.3,,10.1.3(15)},
                          @ref{10.1.5}(8), see @ref{10.2}(8), see @ref{10.2,,10.2(2)},
                          @ref{12.3}(19),   @ref{13.12}(19),   @ref{13.12,,13.12(8)},
                          @ref{D.2.2}(4),   @ref{D.3}(4),   @ref{D.3,,D.3(5)},
                          @ref{D.4}(5),     @ref{E}(5),     @ref{E,,E(2)},
                          @ref{E.1}(2),     @ref{E.2.1}(2),     @ref{E.2.1,,E.2.1(10)},
                          @ref{E.2.3}(17), see @ref{H.1}(17), see @ref{H.1,,H.1(4)},
                          @ref{H.3.1}.
potentially blocking operation    @ref{9.5.1}.
   Abort_Task    @ref{C.7.1}.
   delay_statement    @ref{9.6}(34), see @ref{D.9}(34), see @ref{D.9,,D.9(5)}.
   remote subprogram call    @ref{E.4}.
   RPC operations    @ref{E.5}.
   Suspend_Until_True    @ref{D.10}.
potentially use-visible    @ref{8.4}.
Pound_Sign    @ref{A.3.3}.
Power_16    @ref{3.3.2}.
Pragma    @ref{2.8}(1), see @ref{2.8}(2), see @ref{L}(1), see @ref{N}(1), see @ref{2.8}(2), see @ref{L}(1), see @ref{N,,N(27)}.
pragma argument    @ref{2.8}.
pragma name    @ref{2.8}.
pragma, categorization    @ref{E.2}.
   Remote_Call_Interface    @ref{E.2.3}.
   Remote_Types    @ref{E.2.2}.
   Shared_Passive    @ref{E.2.1}.
pragma, configuration    @ref{10.1.5}.
   Locking_Policy    @ref{D.3}.
   Normalize_Scalars    @ref{H.1}.
   Queuing_Policy    @ref{D.4}.
   Restrictions    @ref{13.12}.
   Reviewable    @ref{H.3.1}.
   Suppress    @ref{11.5}.
   Task_Dispatching_Policy    @ref{D.2.2}.
pragma, identifier specific to    @ref{2.8}.
pragma, interfacing
   Convention    @ref{B.1}.
   Export    @ref{B.1}.
   Import    @ref{B.1}.
   Linker_Options    @ref{B.1}.
pragma, library unit    @ref{10.1.5}.
   All_Calls_Remote    @ref{E.2.3}.
   categorization pragmas    @ref{E.2}.
   Elaborate_Body    @ref{10.2.1}.
   Preelaborate    @ref{10.2.1}.
   Pure    @ref{10.2.1}.
pragma, program unit    @ref{10.1.5}.
   Convention    @ref{B.1}.
   Export    @ref{B.1}.
   Import    @ref{B.1}.
   Inline    @ref{6.3.2}.
   library unit pragmas    @ref{10.1.5}.
pragma, representation    @ref{13.1}.
   Asynchronous    @ref{E.4.1}.
   Atomic    @ref{C.6}.
   Atomic_Components    @ref{C.6}.
   Controlled    @ref{13.11.3}.
   Convention    @ref{B.1}.
   Discard_Names    @ref{C.5}.
   Export    @ref{B.1}.
   Import    @ref{B.1}.
   Pack    @ref{13.2}.
   Volatile    @ref{C.6}.
   Volatile_Components    @ref{C.6}.
pragma_argument_association    @ref{2.8}.
   used    @ref{2.8}(2), see @ref{P}(2), see @ref{P,,P(1)}.
pragmas
   All_Calls_Remote    @ref{E.2.3}(5), see @ref{L}(5), see @ref{L,,L(2)}.
   Asynchronous    @ref{E.4.1}(3), see @ref{L}(3), see @ref{L,,L(3)}.
   Atomic    @ref{C.6}(3), see @ref{L}(3), see @ref{L,,L(4)}.
   Atomic_Components    @ref{C.6}(5), see @ref{L}(5), see @ref{L,,L(5)}.
   Attach_Handler    @ref{C.3.1}(4), see @ref{L}(4), see @ref{L,,L(6)}.
   Controlled    @ref{13.11.3}(3), see @ref{L}(3), see @ref{L,,L(7)}.
   Convention    @ref{B.1}(7), see @ref{L}(7), see @ref{L,,L(8)}.
   Discard_Names    @ref{C.5}(3), see @ref{L}(3), see @ref{L,,L(9)}.
   Elaborate    @ref{10.2.1}(20), see @ref{L}(20), see @ref{L,,L(10)}.
   Elaborate_All    @ref{10.2.1}(21), see @ref{L}(21), see @ref{L,,L(11)}.
   Elaborate_Body    @ref{10.2.1}(22), see @ref{L}(22), see @ref{L,,L(12)}.
   Export    @ref{B.1}(6), see @ref{L}(6), see @ref{L,,L(13)}.
   Import    @ref{B.1}(5), see @ref{L}(5), see @ref{L,,L(14)}.
   Inline    @ref{6.3.2}(3), see @ref{L}(3), see @ref{L,,L(15)}.
   Inspection_Point    @ref{H.3.2}(3), see @ref{L}(3), see @ref{L,,L(16)}.
   Interrupt_Handler    @ref{C.3.1}(2), see @ref{L}(2), see @ref{L,,L(17)}.
   Interrupt_Priority    @ref{D.1}(5), see @ref{L}(5), see @ref{L,,L(18)}.
   Linker_Options    @ref{B.1}(8), see @ref{L}(8), see @ref{L,,L(19)}.
   List    @ref{2.8}(21), see @ref{L}(21), see @ref{L,,L(20)}.
   Locking_Policy    @ref{D.3}(3), see @ref{L}(3), see @ref{L,,L(21)}.
   Normalize_Scalars    @ref{H.1}(3), see @ref{L}(3), see @ref{L,,L(22)}.
   Optimize    @ref{2.8}(23), see @ref{L}(23), see @ref{L,,L(23)}.
   Pack    @ref{13.2}(3), see @ref{L}(3), see @ref{L,,L(24)}.
   Page    @ref{2.8}(22), see @ref{L}(22), see @ref{L,,L(25)}.
   Preelaborate    @ref{10.2.1}(3), see @ref{L}(3), see @ref{L,,L(26)}.
   Priority    @ref{D.1}(3), see @ref{L}(3), see @ref{L,,L(27)}.
   Pure    @ref{10.2.1}(14), see @ref{L}(14), see @ref{L,,L(28)}.
   Queuing_Policy    @ref{D.4}(3), see @ref{L}(3), see @ref{L,,L(29)}.
   Remote_Call_Interface    @ref{E.2.3}(3), see @ref{L}(3), see @ref{L,,L(30)}.
   Remote_Types    @ref{E.2.2}(3), see @ref{L}(3), see @ref{L,,L(31)}.
   Restrictions    @ref{13.12}(3), see @ref{L}(3), see @ref{L,,L(32)}.
   Reviewable    @ref{H.3.1}(3), see @ref{L}(3), see @ref{L,,L(33)}.
   Shared_Passive    @ref{E.2.1}(3), see @ref{L}(3), see @ref{L,,L(34)}.
   Storage_Size    @ref{13.3}(63), see @ref{L}(63), see @ref{L,,L(35)}.
   Suppress    @ref{11.5}(4), see @ref{L}(4), see @ref{L,,L(36)}.
   Task_Dispatching_Policy    @ref{D.2.2}(2), see @ref{L}(2), see @ref{L,,L(37)}.
   Volatile    @ref{C.6}(4), see @ref{L}(4), see @ref{L,,L(38)}.
   Volatile_Components    @ref{C.6}(6), see @ref{L}(6), see @ref{L,,L(39)}.
precedence of operators    @ref{4.5}.
Pred attribute    @ref{3.5}(25), see @ref{K}(25), see @ref{K,,K(181)}.
predefined environment    @ref{A}.
predefined exception    @ref{11.1}.
predefined library unit
   See   language-defined library units
predefined operation
   of a type    @ref{3.2.3}.
predefined operations
   of a discrete type    @ref{3.5.5}.
   of a fixed point type    @ref{3.5.10}.
   of a floating point type    @ref{3.5.8}.
   of a record type    @ref{3.8}.
   of an access type    @ref{3.10.2}.
   of an array type    @ref{3.6.2}.
predefined operator    @ref{4.5}.
   [partial]    @ref{3.2.1}.
predefined type    @ref{3.2.1}.
   See   language-defined types
preelaborable
   of an elaborable construct    @ref{10.2.1}.
Preelaborate pragma    @ref{10.2.1}(3), see @ref{L}(3), see @ref{L,,L(26)}.
preelaborated    @ref{10.2.1}.
   [partial]    @ref{10.2.1}(11), see @ref{E.2.1}(11), see @ref{E.2.1,,E.2.1(9)}.
preempted task    @ref{D.2.1}.
preemptible resource    @ref{D.2.1}.
preference
   for root numeric operators and ranges    @ref{8.6}.
preference control
   See requeue    @ref{9.5.4}.
prefix    @ref{4.1}.
   used    @ref{4.1.1}(2), see @ref{4.1.2}(2), see @ref{4.1.3}(2), see @ref{4.1.2}(2), see @ref{4.1.3,,4.1.3(2)},
           @ref{4.1.4}(2), see @ref{4.1.4}(4), see @ref{6.4}(2), see @ref{4.1.4}(4), see @ref{6.4,,6.4(2)},
           @ref{6.4}(3),    @ref{P}(3),    @ref{P,,P(1)}.
prescribed result
   for the evaluation of a complex arithmetic operation
         @ref{G.1.1}.
   for the evaluation of a complex elementary function
         @ref{G.1.2}.
   for the evaluation of an elementary function    @ref{A.5.1}.
primary    @ref{4.4}.
   used    @ref{4.4}(6), see @ref{P}(6), see @ref{P,,P(1)}.
primitive function    @ref{A.5.3}.
primitive operation
   [partial]    @ref{3.2}.
primitive operations    @ref{N}.
   of a type    @ref{3.2.3}.
primitive operator
   of a type    @ref{3.2.3}.
primitive subprograms
   of a type    @ref{3.2.3}.
Print_Header    @ref{6.1}.
Priority    @ref{13.7}(16), see @ref{D.1}(10), see @ref{D.1}(16), see @ref{D.1}(10), see @ref{D.1,,D.1(15)}.
priority inheritance    @ref{D.1}.
priority inversion    @ref{D.2.2}.
priority of an entry call    @ref{D.4}.
Priority pragma    @ref{D.1}(3), see @ref{L}(3), see @ref{L,,L(27)}.
private declaration of a library unit    @ref{10.1.1}.
private descendant
   of a library unit    @ref{10.1.1}.
private extension    @ref{3.2}(4), see @ref{3.9}(2), see @ref{3.9.1}(4), see @ref{3.9}(2), see @ref{3.9.1,,3.9.1(1)},
                     @ref{N}.
   [partial]    @ref{7.3}.
private library unit    @ref{10.1.1}.
private operations    @ref{7.3.1}.
private part    @ref{8.2}.
   of a package    @ref{7.1}.
   of a protected unit    @ref{9.4}.
   of a task unit    @ref{9.1}.
private type    @ref{3.2}(4), see @ref{N}(4), see @ref{N,,N(30)}.
   [partial]    @ref{7.3}.
private types and private extensions    @ref{7.3}.
private_extension_declaration    @ref{7.3}.
   used    @ref{3.2.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
private_type_declaration    @ref{7.3}.
   used    @ref{3.2.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Probability    @ref{3.5.7}.
procedure    @ref{6}.
procedure instance    @ref{12.3}.
procedure_call_statement    @ref{6.4}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
processing node    @ref{E}.
Producer    @ref{9.11}(2), see @ref{9.11}(2), see @ref{9.11,,9.11(3)}.
profile    @ref{6.1}.
   associated with a dereference    @ref{4.1}.
   fully conformant    @ref{6.3.1}.
   mode conformant    @ref{6.3.1}.
   subtype conformant    @ref{6.3.1}.
   type conformant    @ref{6.3.1}.
profile resolution rule
   name with a given expected profile    @ref{8.6}.
Prog    @ref{B.4}.
program    @ref{10.2}(1), see @ref{N}(1), see @ref{N,,N(32)}.
program execution    @ref{10.2}.
program library
   See library    @ref{10}(2), see @ref{10.1.4}(2), see @ref{10.1.4,,10.1.4(9)}.
Program unit    @ref{10.1}(1), see @ref{N}(1), see @ref{N,,N(31)}.
program unit pragma    @ref{10.1.5}.
   Convention    @ref{B.1}.
   Export    @ref{B.1}.
   Import    @ref{B.1}.
   Inline    @ref{6.3.2}.
   library unit pragmas    @ref{10.1.5}.
Program_Error    @ref{A.1}.
   raised by failure of run-time check
         @ref{1.1.3}(20),    @ref{1.1.5}(8),     @ref{1.1.5}(20),    @ref{1.1.5}(8),     @ref{1.1.5,,1.1.5(12)},
         @ref{3.5.5}(8),     @ref{3.10.2}(29),   @ref{3.11}(8),     @ref{3.10.2}(29),   @ref{3.11,,3.11(14)},
         @ref{4.6}(57),      @ref{6.2}(12),      @ref{6.4}(57),      @ref{6.2}(12),      @ref{6.4,,6.4(11)},
         @ref{6.5}(20),      @ref{7.6.1}(15),    @ref{7.6.1}(20),      @ref{7.6.1}(15),    @ref{7.6.1,,7.6.1(16)},
         @ref{7.6.1}(17),    @ref{7.6.1}(18),    @ref{9.4}(17),    @ref{7.6.1}(18),    @ref{9.4,,9.4(20)},
         @ref{9.5.1}(17),    @ref{9.5.3}(7),     @ref{9.7.1}(17),    @ref{9.5.3}(7),     @ref{9.7.1,,9.7.1(21)},
         @ref{9.8}(20),      @ref{10.2}(26),     @ref{11.1}(20),      @ref{10.2}(26),     @ref{11.1,,11.1(4)},
         @ref{11.5}(19),     @ref{13.7.1}(16),   @ref{13.9.1}(19),     @ref{13.7.1}(16),   @ref{13.9.1,,13.9.1(9)},
         @ref{13.11.2}(13), see @ref{13.11.2}(14), see @ref{A.7}(13), see @ref{13.11.2}(14), see @ref{A.7,,A.7(14)},
         @ref{C.3.1}(10),    @ref{C.3.1}(11),    @ref{C.3.2}(10),    @ref{C.3.1}(11),    @ref{C.3.2,,C.3.2(17)},
         @ref{C.3.2}(20),    @ref{C.3.2}(21),    @ref{C.3.2}(20),    @ref{C.3.2}(21),    @ref{C.3.2,,C.3.2(22)},
         @ref{C.7.1}(15),    @ref{C.7.1}(17),    @ref{C.7.2}(15),    @ref{C.7.1}(17),    @ref{C.7.2,,C.7.2(13)},
         @ref{D.3}(13),      @ref{D.5}(9),       @ref{D.5}(13),      @ref{D.5}(9),       @ref{D.5,,D.5(11)},
         @ref{D.10}(10),     @ref{D.11}(8),      @ref{E.1}(10),     @ref{D.11}(8),      @ref{E.1,,E.1(10)},
         @ref{E.3}(6),       @ref{E.4}(18),      @ref{J.7.1}(6),       @ref{E.4}(18),      @ref{J.7.1,,J.7.1(7)}.
Program_Status_Word    @ref{13.5.1}.
propagate    @ref{11.4}.
   an exception occurrence by an execution, to a dynamically
        enclosing execution    @ref{11.4}.
proper_body    @ref{3.11}.
   used    @ref{3.11}(5), see @ref{10.1.3}(7), see @ref{P}(5), see @ref{10.1.3}(7), see @ref{P,,P(1)}.
protected action    @ref{9.5.1}.
   complete    @ref{9.5.1}.
   start    @ref{9.5.1}.
protected calling convention    @ref{6.3.1}.
protected declaration    @ref{9.4}.
protected entry    @ref{9.4}.
protected function    @ref{9.5.1}.
protected object    @ref{9}(3), see @ref{9.4}(3), see @ref{9.4,,9.4(1)}.
protected operation    @ref{9.4}.
protected procedure    @ref{9.5.1}.
protected subprogram    @ref{9.4}(1), see @ref{9.5.1}(1), see @ref{9.5.1,,9.5.1(1)}.
Protected type    @ref{N}.
protected unit    @ref{9.4}.
protected_body    @ref{9.4}.
   used    @ref{3.11}(6), see @ref{P}(6), see @ref{P,,P(1)}.
protected_body_stub    @ref{10.1.3}.
   used    @ref{10.1.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
protected_definition    @ref{9.4}.
   used    @ref{9.4}(2), see @ref{9.4}(3), see @ref{P}(2), see @ref{9.4}(3), see @ref{P,,P(1)}.
protected_element_declaration    @ref{9.4}.
   used    @ref{9.4}(4), see @ref{P}(4), see @ref{P,,P(1)}.
protected_operation_declaration    @ref{9.4}.
   used    @ref{9.4}(4), see @ref{9.4}(6), see @ref{P}(4), see @ref{9.4}(6), see @ref{P,,P(1)}.
protected_operation_item    @ref{9.4}.
   used    @ref{9.4}(7), see @ref{P}(7), see @ref{P,,P(1)}.
protected_type_declaration    @ref{9.4}.
   used    @ref{3.2.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
ptrdiff_t    @ref{B.3}.
PU1    @ref{A.3.3}.
PU2    @ref{A.3.3}.
public declaration of a library unit    @ref{10.1.1}.
public descendant
   of a library unit    @ref{10.1.1}.
public library unit    @ref{10.1.1}.
pure    @ref{10.2.1}.
Pure pragma    @ref{10.2.1}(14), see @ref{L}(14), see @ref{L,,L(28)}.
Push    @ref{6.3}(9), see @ref{12.8}(3), see @ref{12.8}(6), see @ref{12.8}(9), see @ref{12.8}(3), see @ref{12.8}(6), see @ref{12.8,,12.8(14)}.
Put    @ref{6.4}(26),     @ref{10.1.1}(30), see @ref{A.10.1}(26),     @ref{10.1.1}(30), see @ref{A.10.1,,A.10.1(42)},
       @ref{A.10.1}(48), see @ref{A.10.1}(55), see @ref{A.10.1}(48), see @ref{A.10.1}(55), see @ref{A.10.1,,A.10.1(60)},
       @ref{A.10.1}(66), see @ref{A.10.1}(67), see @ref{A.10.1}(66), see @ref{A.10.1}(67), see @ref{A.10.1,,A.10.1(71)},
       @ref{A.10.1}(72), see @ref{A.10.1}(76), see @ref{A.10.1}(72), see @ref{A.10.1}(76), see @ref{A.10.1,,A.10.1(77)},
       @ref{A.10.1}(82), see @ref{A.10.1}(83), see @ref{F.3.3}(82), see @ref{A.10.1}(83), see @ref{F.3.3,,F.3.3(14)},
       @ref{F.3.3}(15),   @ref{F.3.3}(16),   @ref{G.1.3}(15),   @ref{F.3.3}(16),   @ref{G.1.3,,G.1.3(7)},
       @ref{G.1.3}.
Put_Item    @ref{12.6}.
Put_Line    @ref{A.10.1}.
Put_List    @ref{12.6}.
@end format

@c ---------------------------------------------------------------------------
@node Index.Q, Index.R, Index.P, Index
@chapter Index

@format
qualified_expression    @ref{4.7}.
   used    @ref{4.4}(7), see @ref{4.8}(2), see @ref{13.8}(2), see @ref{P}(7), see @ref{4.8}(2), see @ref{13.8}(2), see @ref{P,,P(1)}.
Query    @ref{J.5}.
Question    @ref{3.6.3}(7), see @ref{A.3.3}(7), see @ref{A.3.3,,A.3.3(10)}.
queuing policy    @ref{D.4}(1), see @ref{D.4}(1), see @ref{D.4,,D.4(6)}.
Queuing_Policy pragma    @ref{D.4}(3), see @ref{L}(3), see @ref{L,,L(29)}.
Quotation    @ref{A.3.3}.
quotation mark    @ref{2.1}.
quoted string
   See string_literal    @ref{2.6}.
Quotient_Type    @ref{F.2}.
@end format

@c ---------------------------------------------------------------------------
@node Index.R, Index.S, Index.Q, Index
@chapter index

@format
R    @ref{12.5.3}(15), see @ref{12.5.4}(15), see @ref{12.5.4,,12.5.4(13)}.
R_Brace    @ref{J.5}.
R_Bracket    @ref{J.5}.
Rad_To_Deg    @ref{4.9}.
Rainbow    @ref{3.2.2}(15), see @ref{3.5.1}(15), see @ref{3.5.1,,3.5.1(16)}.
raise
   an exception    @ref{11}(1), see @ref{11.3}(4), see @ref{N}(1), see @ref{11.3}(4), see @ref{N,,N(18)}.
   an exception occurrence    @ref{11.4}.
Raise_Exception    @ref{11.4.1}.
raise_statement    @ref{11.3}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Random    @ref{6.1}(38), see @ref{A.5.2}(8), see @ref{A.5.2}(38), see @ref{A.5.2}(8), see @ref{A.5.2,,A.5.2(20)}.
random number    @ref{A.5.2}.
Random_Coin @ref{A.5.2}(58)
Random_Die    @ref{A.5.2}.
range    @ref{3.5}(3), see @ref{3.5}(3), see @ref{3.5,,3.5(4)}.
   used    @ref{3.5}(2), see @ref{3.6}(6), see @ref{3.6.1}(2), see @ref{3.6}(6), see @ref{3.6.1,,3.6.1(3)},
           @ref{4.4}(3), see @ref{P}(3), see @ref{P,,P(1)}.
   of a scalar subtype    @ref{3.5}.
Range attribute    @ref{3.5}(14), see @ref{3.6.2}(14), see @ref{3.6.2,,3.6.2(7)},
                   @ref{K}(187),   @ref{K}(187),   @ref{K,,K(189)}.
Range(N) attribute    @ref{3.6.2}(8), see @ref{K}(8), see @ref{K,,K(185)}.
range_attribute_designator    @ref{4.1.4}.
   used    @ref{4.1.4}(4), see @ref{P}(4), see @ref{P,,P(1)}.
range_attribute_reference    @ref{4.1.4}.
   used    @ref{3.5}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Range_Check    @ref{11.5}.
   [partial]    @ref{3.2.2}(11), see @ref{3.5}(24),      @ref{3.5}(11), see @ref{3.5}(24),      @ref{3.5,,3.5(27)},
                @ref{3.5}(43),    @ref{3.5}(44),      @ref{3.5}(43),    @ref{3.5}(44),      @ref{3.5,,3.5(51)},
                @ref{3.5}(55),    @ref{3.5.5}(7),     @ref{3.5.9}(55),    @ref{3.5.5}(7),     @ref{3.5.9,,3.5.9(19)},
                @ref{4.2}(11),    @ref{4.3.3}(28),    @ref{4.5.1}(11),    @ref{4.3.3}(28),    @ref{4.5.1,,4.5.1(8)},
                @ref{4.5.6}(6),   @ref{4.5.6}(13),    @ref{4.6}(6),   @ref{4.5.6}(13),    @ref{4.6,,4.6(28)},
                @ref{4.6}(38),    @ref{4.6}(46),      @ref{4.6}(38),    @ref{4.6}(46),      @ref{4.6,,4.6(51)},
                @ref{4.7}(4),     @ref{13.13.2}(35), see @ref{A.5.2}(4),     @ref{13.13.2}(35), see @ref{A.5.2,,A.5.2(39)},
                @ref{A.5.2}(40), see @ref{A.5.3}(26),    @ref{A.5.3}(40), see @ref{A.5.3}(26),    @ref{A.5.3,,A.5.3(29)},
                @ref{A.5.3}(50), see @ref{A.5.3}(53),    @ref{A.5.3}(50), see @ref{A.5.3}(53),    @ref{A.5.3,,A.5.3(59)},
                @ref{A.5.3}(62), see @ref{K}(11),        @ref{K}(62), see @ref{K}(11),        @ref{K,,K(41)},
                @ref{K}(47),      @ref{K}(114),       @ref{K}(47),      @ref{K}(114),       @ref{K,,K(122)},
                @ref{K}(184),     @ref{K}(220),       @ref{K}(184),     @ref{K}(220),       @ref{K,,K(241)}.
range_constraint    @ref{3.5}.
   used    @ref{3.2.2}(6), see @ref{3.5.9}(6), see @ref{3.5.9,,3.5.9(5)},
           @ref{J.3}(2),    @ref{P}(2),    @ref{P,,P(1)}.
Rank    @ref{12.5}(16), see @ref{B.5}(16), see @ref{B.5,,B.5(31)}.
Rational    @ref{7.1}.
Rational_Numbers    @ref{7.1}(12), see @ref{7.2}(10), see @ref{10.1.1}(12), see @ref{7.2}(10), see @ref{10.1.1,,10.1.1(32)}.
Rational_Numbers.Reduce    @ref{10.1.1}.
Rational_Numbers.IO    @ref{10.1.1}.
Rational_IO    @ref{10.1.1}.
RCI
   generic    @ref{E.2.3}.
   library unit    @ref{E.2.3}.
   package    @ref{E.2.3}.
Re    @ref{G.1.1}.
re-raise statement    @ref{11.3}.
read    @ref{7.5}(19),     @ref{7.5}(20),     @ref{9.1}(19),     @ref{7.5}(20),     @ref{9.1,,9.1(24)},
        @ref{9.5.2}(33),   @ref{9.11}(8),     @ref{9.11}(33),   @ref{9.11}(8),     @ref{9.11,,9.11(10)},
        @ref{11.4.2}(4),   @ref{11.4.2}(7),   @ref{13.13.1}(4),   @ref{11.4.2}(7),   @ref{13.13.1,,13.13.1(5)},
        @ref{A.8.1}(12),   @ref{A.8.4}(12),   @ref{A.9}(12),   @ref{A.8.4}(12),   @ref{A.9,,A.9(6)},
        @ref{A.12.1}(15), see @ref{A.12.1}(16), see @ref{D.12}(15), see @ref{A.12.1}(16), see @ref{D.12,,D.12(9)},
        @ref{D.12}(10),    @ref{E.5}(10),    @ref{E.5,,E.5(7)}.
   the value of an object    @ref{3.3}.
Read attribute    @ref{13.13.2}(6), see @ref{13.13.2}(6), see @ref{13.13.2,,13.13.2(14)},
                  @ref{K}(191),      @ref{K}(191),      @ref{K,,K(195)}.
Read clause    @ref{13.3}(7), see @ref{13.13.2}(7), see @ref{13.13.2,,13.13.2(36)}.
ready
   a task state    @ref{9}.
ready queue    @ref{D.2.1}.
ready task    @ref{D.2.1}.
Real    @ref{3.5.7}(21), see @ref{B.5}(6), see @ref{G.1.1}(21), see @ref{B.5}(6), see @ref{G.1.1,,G.1.1(2)}.
real literal    @ref{2.4}.
real literals    @ref{3.5.6}.
real time    @ref{D.8}.
real type    @ref{3.2}(3), see @ref{3.5.6}(1), see @ref{N}(3), see @ref{3.5.6}(1), see @ref{N,,N(34)}.
real-time systems    @ref{C}(1), see @ref{D}(1), see @ref{D,,D(1)}.
Real_Plus    @ref{8.5.4}.
real_range_specification    @ref{3.5.7}.
   used    @ref{3.5.7}(2), see @ref{3.5.9}(2), see @ref{3.5.9,,3.5.9(3)},
           @ref{3.5.9}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Real_Time
   child of Ada    @ref{D.8}.
real_type_definition    @ref{3.5.6}.
   used    @ref{3.2.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Real_IO    @ref{A.10.9}.
receiving stub    @ref{E.4}.
reclamation of storage    @ref{13.11.2}.
recommended level of support    @ref{13.1}.
   enumeration_representation_clause    @ref{13.4}.
   record_representation_clause    @ref{13.5.1}.
   Address attribute    @ref{13.3}.
   Alignment attribute for objects    @ref{13.3}.
   Alignment attribute for subtypes    @ref{13.3}.
   bit ordering    @ref{13.5.3}.
   Component_Size attribute    @ref{13.3}.
   pragma Pack    @ref{13.2}.
   required in Systems Programming Annex    @ref{C.2}.
   Size attribute    @ref{13.3}(42), see @ref{13.3}(42), see @ref{13.3,,13.3(54)}.
   unchecked conversion    @ref{13.9}.
   with respect to nonstatic expressions    @ref{13.1}.
record    @ref{3.8}.
record extension    @ref{3.4}(5), see @ref{3.9.1}(1), see @ref{N}(5), see @ref{3.9.1}(1), see @ref{N,,N(35)}.
record layout
   aspect of representation    @ref{13.5}.
record type    @ref{3.8}(1), see @ref{N}(1), see @ref{N,,N(36)}.
record_aggregate    @ref{4.3.1}.
   used    @ref{4.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
record_component_association    @ref{4.3.1}.
   used    @ref{4.3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
record_component_association_list    @ref{4.3.1}.
   used    @ref{4.3.1}(2), see @ref{4.3.2}(2), see @ref{P}(2), see @ref{4.3.2}(2), see @ref{P,,P(1)}.
record_definition    @ref{3.8}.
   used    @ref{3.8}(2), see @ref{3.9.1}(2), see @ref{P}(2), see @ref{3.9.1}(2), see @ref{P,,P(1)}.
record_extension_part    @ref{3.9.1}.
   used    @ref{3.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
record_representation_clause    @ref{13.5.1}.
   used    @ref{13.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
record_type_definition    @ref{3.8}.
   used    @ref{3.2.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Red_Blue    @ref{3.2.2}.
Reference    @ref{C.3.2}(10), see @ref{C.7.2}(10), see @ref{C.7.2,,C.7.2(5)}.
reference parameter passing    @ref{6.2}.
references    @ref{1.2}.
Register    @ref{E.4.2}.
Registered_Trade_Mark_Sign    @ref{A.3.3}.
Reinitialize    @ref{C.7.2}.
relation    @ref{4.4}.
   used    @ref{4.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
relational operator    @ref{4.5.2}.
relational_operator    @ref{4.5}.
   used    @ref{4.4}(3), see @ref{P}(3), see @ref{P,,P(1)}.
relaxed mode    @ref{G.2}.
Release    @ref{9.4}(27), see @ref{9.4}(27), see @ref{9.4,,9.4(29)}.
   execution resource associated with protected object
         @ref{9.5.1}.
rem operator    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
Remainder attribute    @ref{A.5.3}(45), see @ref{K}(45), see @ref{K,,K(199)}.
Remainder_Type    @ref{F.2}.
remote access    @ref{E.1}.
remote access type    @ref{E.2.2}.
remote access-to-class-wide type    @ref{E.2.2}.
remote access-to-subprogram type    @ref{E.2.2}.
remote call interface    @ref{E.2}(4), see @ref{E.2.3}(4), see @ref{E.2.3,,E.2.3(7)}.
remote procedure call
   asynchronous    @ref{E.4.1}.
remote subprogram    @ref{E.2.3}.
remote subprogram binding    @ref{E.4}.
remote subprogram call    @ref{E.4}.
remote types library unit    @ref{E.2}(4), see @ref{E.2.2}(4), see @ref{E.2.2,,E.2.2(4)}.
Remote_Call_Interface pragma    @ref{E.2.3}(3), see @ref{L}(3), see @ref{L,,L(30)}.
Remote_Types pragma    @ref{E.2.2}(3), see @ref{L}(3), see @ref{L,,L(31)}.
Remove    @ref{E.4.2}.
renamed entity    @ref{8.5}.
renamed view    @ref{8.5}.
renaming-as-body    @ref{8.5.4}.
renaming-as-declaration    @ref{8.5.4}.
renaming_declaration    @ref{8.5}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
rendezvous    @ref{9.5.2}.
Replace_Element    @ref{A.4.4}(27), see @ref{A.4.5}(27), see @ref{A.4.5,,A.4.5(21)}.
Replace_Slice    @ref{A.4.3}(23), see @ref{A.4.3}(23), see @ref{A.4.3,,A.4.3(24)},
                 @ref{A.4.4}(58), see @ref{A.4.4}(58), see @ref{A.4.4,,A.4.4(59)},
                 @ref{A.4.5}(53), see @ref{A.4.5}(53), see @ref{A.4.5,,A.4.5(54)}.
Replicate    @ref{A.4.4}(78), see @ref{A.4.4}(79), see @ref{A.4.4}(78), see @ref{A.4.4}(79), see @ref{A.4.4,,A.4.4(80)}.
representation
   change of    @ref{13.6}.
representation aspect    @ref{13.1}.
representation attribute    @ref{13.3}.
representation item    @ref{13.1}.
representation of an object    @ref{13.1}.
representation pragma    @ref{13.1}.
   Asynchronous    @ref{E.4.1}.
   Atomic    @ref{C.6}.
   Atomic_Components    @ref{C.6}.
   Controlled    @ref{13.11.3}.
   Convention    @ref{B.1}.
   Discard_Names    @ref{C.5}.
   Export    @ref{B.1}.
   Import    @ref{B.1}.
   Pack    @ref{13.2}.
   Volatile    @ref{C.6}.
   Volatile_Components    @ref{C.6}.
representation-oriented attributes
   of a fixed point subtype    @ref{A.5.4}.
   of a floating point subtype    @ref{A.5.3}.
representation_clause    @ref{13.1}.
   used    @ref{3.8}(5), see @ref{3.11}(4), see @ref{9.1}(5), see @ref{3.11}(4), see @ref{9.1,,9.1(5)},
           @ref{9.4}(5), see @ref{9.4}(8),   @ref{P}(5), see @ref{9.4}(8),   @ref{P,,P(1)}.
represented in canonical form    @ref{A.5.3}.
Request    @ref{9.1}(26), see @ref{9.5.2}(26), see @ref{9.5.2,,9.5.2(33)}.
requested decimal precision
   of a floating point type    @ref{3.5.7}.
requeue    @ref{9.5.4}.
requeue-with-abort    @ref{9.5.4}.
requeue_statement    @ref{9.5.4}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
requires a completion    @ref{3.11.1}(1), see @ref{3.11.1}(1), see @ref{3.11.1,,3.11.1(6)}.
   incomplete_type_declaration    @ref{3.10.1}.
   protected_declaration    @ref{9.4}.
   task_declaration    @ref{9.1}.
   generic_package_declaration    @ref{7.1}.
   generic_subprogram_declaration    @ref{6.1}.
   package_declaration    @ref{7.1}.
   subprogram_declaration    @ref{6.1}.
   declaration of a partial view    @ref{7.3}.
   declaration to which a pragma Elaborate_Body applies
         @ref{10.2.1}.
   deferred constant declaration    @ref{7.4}.
   protected entry_declaration    @ref{9.5.2}.
Reraise_Occurrence    @ref{11.4.1}.
reserved interrupt    @ref{C.3}.
reserved word    @ref{2.9}.
Reserved_128    @ref{A.3.3}.
Reserved_129    @ref{A.3.3}.
Reserved_132    @ref{A.3.3}.
Reserved_153    @ref{A.3.3}.
Reserved_Check
   [partial]    @ref{C.3.1}.
Reset    @ref{A.5.2}(9),   @ref{A.5.2}(12), see @ref{A.5.2}(9),   @ref{A.5.2}(12), see @ref{A.5.2,,A.5.2(21)},
         @ref{A.5.2}(24), see @ref{A.8.1}(8),   @ref{A.8.4}(24), see @ref{A.8.1}(8),   @ref{A.8.4,,A.8.4(8)},
         @ref{A.10.1}(11), see @ref{A.12.1}(11), see @ref{A.12.1,,A.12.1(10)}.
resolution rules    @ref{1.1.2}.
resolve
   overload resolution    @ref{8.6}.
Resource    @ref{9.4}(27), see @ref{9.4}(27), see @ref{9.4,,9.4(28)}.
restriction    @ref{13.12}.
   used    @ref{13.12}(3), see @ref{L}(3), see @ref{L,,L(32)}.
Restrictions
   Immediate_Reclamation    @ref{H.4}.
   Max_Asynchronous_Select_Nesting    @ref{D.7}.
   Max_Protected_Entries    @ref{D.7}.
   Max_Select_Alternatives    @ref{D.7}.
   Max_Storage_At_Blocking    @ref{D.7}.
   Max_Task_Entries    @ref{D.7}.
   Max_Tasks    @ref{D.7}.
   No_Abort_Statements    @ref{D.7}.
   No_Access_Subprograms    @ref{H.4}.
   No_Allocators    @ref{H.4}.
   No_Asynchronous_Control    @ref{D.7}.
   No_Delay    @ref{H.4}.
   No_Dispatch    @ref{H.4}.
   No_Dynamic_Priorities    @ref{D.7}.
   No_Exceptions    @ref{H.4}.
   No_Fixed_Point    @ref{H.4}.
   No_Floating_Point    @ref{H.4}.
   No_Implicit_Heap_Allocations    @ref{D.7}.
   No_Local_Allocators    @ref{H.4}.
   No_Nested_Finalization    @ref{D.7}.
   No_Protected_Types    @ref{H.4}.
   No_Recursion    @ref{H.4}.
   No_Reentrancy    @ref{H.4}.
   No_Task_Allocators    @ref{D.7}.
   No_Task_Hierarchy    @ref{D.7}.
   No_Terminate_Alternatives    @ref{D.7}.
   No_Unchecked_Access    @ref{H.4}.
   No_Unchecked_Conversion    @ref{H.4}.
   No_Unchecked_Deallocation    @ref{H.4}.
   No_IO    @ref{H.4}.
Restrictions pragma    @ref{13.12}(3), see @ref{L}(3), see @ref{L,,L(32)}.
result interval
   for a component of the result of evaluating
     a complex function    @ref{G.2.6}.
   for the evaluation of a predefined arithmetic
     operation    @ref{G.2.1}.
   for the evaluation of an elementary function    @ref{G.2.4}.
result subtype
   of a function    @ref{6.5}.
Result_Subtype    @ref{A.5.2}.
return expression    @ref{6.5}.
return-by-reference type    @ref{6.5}.
return_statement    @ref{6.5}.
   used    @ref{5.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Reverse_Solidus    @ref{A.3.3}.
Reviewable pragma    @ref{H.3.1}(3), see @ref{L}(3), see @ref{L,,L(33)}.
Rewind    @ref{E.4.2}(2), see @ref{E.4.2}(2), see @ref{E.4.2,,E.4.2(5)}.
RI    @ref{A.3.3}.
right curly bracket    @ref{2.1}.
right parenthesis    @ref{2.1}.
right square bracket    @ref{2.1}.
Right_Angle_Quotation    @ref{A.3.3}.
Right_Curly_Bracket    @ref{A.3.3}.
Right_Indent    @ref{6.1}.
Right_Parenthesis    @ref{A.3.3}.
Right_Square_Bracket    @ref{A.3.3}.
Roman    @ref{3.6}.
Roman_Digit    @ref{3.5.2}.
root library unit    @ref{10.1.1}.
root type
   of a class    @ref{3.4.1}.
root_integer    @ref{3.5.4}.
   [partial]    @ref{3.4.1}.
root_real    @ref{3.5.6}.
   [partial]    @ref{3.4.1}.
Root_Storage_Pool    @ref{13.11}.
Root_Stream_Type    @ref{13.13.1}.
rooted at a type    @ref{3.4.1}.
Rosso    @ref{8.5.4}.
Rot    @ref{8.5.4}.
rotate    @ref{B.2}.
Rotate_Left    @ref{B.2}.
Rotate_Right    @ref{B.2}.
Rouge    @ref{8.5.4}.
Round attribute    @ref{3.5.10}(12), see @ref{K}(12), see @ref{K,,K(203)}.
Rounding attribute    @ref{A.5.3}(36), see @ref{K}(36), see @ref{K,,K(207)}.
Row    @ref{12.1}.
RPC
   child of System    @ref{E.5}.
RPC-receiver    @ref{E.5}.
RPC_Receiver    @ref{E.5}.
RS    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
run-time check
   See language-defined check    @ref{11.5}.
run-time error    @ref{1.1.2}(30), see @ref{1.1.5}(30), see @ref{1.1.5,,1.1.5(6)},
                  @ref{11.5}(2),    @ref{11.6}(2),    @ref{11.6,,11.6(1)}.
run-time polymorphism    @ref{3.9.2}.
run-time semantics    @ref{1.1.2}.
run-time type
   See tag    @ref{3.9}.
running a program
   See program execution    @ref{10.2}.
running task    @ref{D.2.1}.
@end format

@c ---------------------------------------------------------------------------
@node Index.S, Index.T, Index.R, Index
@chapter index

@format
S'Adjacent    @ref{A.5.3}(49), see @ref{K}(49), see @ref{K,,K(10)}.
S'Ceiling    @ref{A.5.3}(34), see @ref{K}(34), see @ref{K,,K(29)}.
S'Class'Input    @ref{13.13.2}(33), see @ref{K}(33), see @ref{K,,K(94)}.
S'Class'Output    @ref{13.13.2}(30), see @ref{K}(30), see @ref{K,,K(167)}.
S'Class'Read    @ref{13.13.2}(15), see @ref{K}(15), see @ref{K,,K(193)}.
S'Class'Write    @ref{13.13.2}(12), see @ref{K}(12), see @ref{K,,K(284)}.
S'Compose    @ref{A.5.3}(25), see @ref{K}(25), see @ref{K,,K(40)}.
S'Copy_Sign    @ref{A.5.3}(52), see @ref{K}(52), see @ref{K,,K(46)}.
S'Exponent    @ref{A.5.3}(19), see @ref{K}(19), see @ref{K,,K(62)}.
S'Floor    @ref{A.5.3}(31), see @ref{K}(31), see @ref{K,,K(76)}.
S'Fraction    @ref{A.5.3}(22), see @ref{K}(22), see @ref{K,,K(82)}.
S'Input    @ref{13.13.2}(23), see @ref{K}(23), see @ref{K,,K(98)}.
S'Leading_Part    @ref{A.5.3}(55), see @ref{K}(55), see @ref{K,,K(110)}.
S'Machine    @ref{A.5.3}(61), see @ref{K}(61), see @ref{K,,K(121)}.
S'Model    @ref{A.5.3}(69), see @ref{K}(69), see @ref{K,,K(153)}.
S'Output    @ref{13.13.2}(20), see @ref{K}(20), see @ref{K,,K(171)}.
S'Read    @ref{13.13.2}(7), see @ref{K}(7), see @ref{K,,K(197)}.
S'Remainder    @ref{A.5.3}(46), see @ref{K}(46), see @ref{K,,K(201)}.
S'Rounding    @ref{A.5.3}(37), see @ref{K}(37), see @ref{K,,K(209)}.
S'Scaling    @ref{A.5.3}(28), see @ref{K}(28), see @ref{K,,K(219)}.
S'Truncation    @ref{A.5.3}(43), see @ref{K}(43), see @ref{K,,K(250)}.
S'Unbiased_Rounding    @ref{A.5.3}(40), see @ref{K}(40), see @ref{K,,K(254)}.
S'Write    @ref{13.13.2}(4), see @ref{K}(4), see @ref{K,,K(288)}.
safe range
   of a floating point type    @ref{3.5.7}(9), see @ref{3.5.7}(9), see @ref{3.5.7,,3.5.7(10)}.
Safe_First attribute    @ref{A.5.3}(71), see @ref{G.2.2}(71), see @ref{G.2.2,,G.2.2(5)},
                        @ref{K}.
Safe_Last attribute    @ref{A.5.3}(72), see @ref{G.2.2}(72), see @ref{G.2.2,,G.2.2(6)},
                       @ref{K}.
safety-critical systems    @ref{H}.
Salary    @ref{3.5.9}.
Salary_Conversions    @ref{B.4}(108), see @ref{B.4}(108), see @ref{B.4,,B.4(120)}.
Salary_Type    @ref{B.4}(105), see @ref{B.4}(105), see @ref{B.4,,B.4(114)}.
Same_Denominator    @ref{7.2}.
satisfies
   a discriminant constraint    @ref{3.7.1}.
   a range constraint    @ref{3.5}.
   an index constraint    @ref{3.6.1}.
   for an access value    @ref{3.10}.
Save    @ref{A.5.2}(12), see @ref{A.5.2}(12), see @ref{A.5.2,,A.5.2(24)}.
Save_Occurrence    @ref{11.4.1}.
scalar type    @ref{3.2}(3), see @ref{3.5}(1), see @ref{N}(3), see @ref{3.5}(1), see @ref{N,,N(37)}.
scalar_constraint    @ref{3.2.2}.
   used    @ref{3.2.2}(5), see @ref{P}(5), see @ref{P,,P(1)}.
scale
   of a decimal fixed point subtype    @ref{3.5.10},
                                       @ref{K}.
Scale attribute    @ref{3.5.10}(11), see @ref{K}(11), see @ref{K,,K(215)}.
Scaling attribute    @ref{A.5.3}(27), see @ref{K}(27), see @ref{K,,K(217)}.
SCHAR_MAX    @ref{B.3}.
SCHAR_MIN    @ref{B.3}.
Schedule    @ref{3.6}.
scope
   informal definition    @ref{3.1}.
   of (a view of) an entity    @ref{8.2}.
   of a use_clause    @ref{8.4}.
   of a with_clause    @ref{10.1.2}.
   of a declaration    @ref{8.2}.
Seconds    @ref{9.6}.
Seconds_Count    @ref{D.8}.
Section_Sign    @ref{A.3.3}.
secure systems    @ref{H}.
Seize    @ref{9.4}(27), see @ref{9.4}(28), see @ref{9.5.2}(27), see @ref{9.4}(28), see @ref{9.5.2,,9.5.2(33)}.
select an entry call
   from an entry queue    @ref{9.5.3}(13), see @ref{9.5.3}(13), see @ref{9.5.3,,9.5.3(16)}.
   immediately    @ref{9.5.3}.
select_alternative    @ref{9.7.1}.
   used    @ref{9.7.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
select_statement    @ref{9.7}.
   used    @ref{5.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
selected_component    @ref{4.1.3}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
selection
   of an entry caller    @ref{9.5.2}.
selective_accept    @ref{9.7.1}.
   used    @ref{9.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
selector_name    @ref{4.1.3}.
   used    @ref{3.7.1}(3), see @ref{4.1.3}(2), see @ref{4.3.1}(3), see @ref{4.1.3}(2), see @ref{4.3.1,,4.3.1(5)},
           @ref{6.4}(5),    @ref{12.3}(4),   @ref{P}(5),    @ref{12.3}(4),   @ref{P,,P(1)}.
semantic dependence
   of one compilation unit upon another    @ref{10.1.1}.
semicolon    @ref{2.1}(15), see @ref{A.3.3}(15), see @ref{A.3.3,,A.3.3(10)}.
separate compilation    @ref{10.1}.
separator    @ref{2.2}.
Sequence    @ref{4.6}.
sequence of characters
   of a string_literal    @ref{2.6}.
sequence_of_statements    @ref{5.1}.
   used    @ref{5.3}(2),    @ref{5.4}(3),    @ref{5.5}(2),    @ref{5.4}(3),    @ref{5.5,,5.5(2)},
           @ref{9.7.1}(2), see @ref{9.7.1}(5), see @ref{9.7.1}(2), see @ref{9.7.1}(5), see @ref{9.7.1,,9.7.1(6)},
           @ref{9.7.2}(3), see @ref{9.7.3}(2), see @ref{9.7.4}(3), see @ref{9.7.3}(2), see @ref{9.7.4,,9.7.4(3)},
           @ref{9.7.4}(5), see @ref{11.2}(2),   @ref{11.2}(5), see @ref{11.2}(2),   @ref{11.2,,11.2(3)},
           @ref{P}.
sequential
   actions    @ref{9.10}(11), see @ref{C.6}(11), see @ref{C.6,,C.6(17)}.
sequential access    @ref{A.8}.
sequential file    @ref{A.8}.
Sequential_IO    @ref{J.1}.
   child of Ada    @ref{A.8.1}.
Server    @ref{9.1}(23), see @ref{9.7.1}(23), see @ref{9.7.1,,9.7.1(24)}.
service
   an entry queue    @ref{9.5.3}.
Set    @ref{3.9.3}(15), see @ref{6.4}(15), see @ref{6.4,,6.4(27)},
       @ref{D.12}(9),    @ref{D.12}(9),    @ref{D.12,,D.12(10)}.
Set_Col    @ref{A.10.1}.
Set_Component    @ref{9.4}(31), see @ref{9.4}(31), see @ref{9.4,,9.4(33)}.
Set_Error    @ref{A.10.1}.
Set_False    @ref{D.10}.
Set_Index    @ref{A.8.4}(14), see @ref{A.12.1}(14), see @ref{A.12.1,,A.12.1(22)}.
Set_Input    @ref{A.10.1}.
Set_Line    @ref{A.10.1}.
Set_Line_Length    @ref{A.10.1}.
Set_Mask    @ref{13.8}(13), see @ref{13.8}(13), see @ref{13.8,,13.8(14)}.
Set_Mode    @ref{A.12.1}.
Set_Output    @ref{A.10.1}.
Set_Page_Length    @ref{A.10.1}.
Set_Priority    @ref{D.5}.
Set_True    @ref{D.10}.
Set_Value    @ref{C.7.2}.
Set_Im    @ref{G.1.1}.
Set_Re    @ref{G.1.1}.
Sets    @ref{3.9.3}.
shared passive library unit    @ref{E.2}(4), see @ref{E.2.1}(4), see @ref{E.2.1,,E.2.1(4)}.
shared variable
   protection of    @ref{9.10}.
Shared_Array    @ref{9.4}(31), see @ref{9.4}(31), see @ref{9.4,,9.4(32)}.
Shared_Passive pragma    @ref{E.2.1}(3), see @ref{L}(3), see @ref{L,,L(34)}.
Sharp    @ref{J.5}.
shift    @ref{B.2}.
Shift_Left    @ref{B.2}.
Shift_Right    @ref{B.2}.
Shift_Right_Arithmetic    @ref{B.2}.
Short    @ref{13.3}(82), see @ref{B.3}(82), see @ref{B.3,,B.3(7)}.
short-circuit control form    @ref{4.5.1}.
Short_Float    @ref{3.5.7}.
Short_Integer    @ref{3.5.4}.
Shut_Down    @ref{9.1}.
SI    @ref{A.3.3}.
Sigma    @ref{12.1}(24), see @ref{12.2}(24), see @ref{12.2,,12.2(12)}.
signal (an exception)
   See raise    @ref{11}.
signal
   See interrupt    @ref{C.3}.
   as defined between actions    @ref{9.10}.
signal handling
   example    @ref{9.7.4}.
signed integer type    @ref{3.5.4}.
signed_char    @ref{B.3}.
signed_integer_type_definition    @ref{3.5.4}.
   used    @ref{3.5.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Signed_Zeros attribute    @ref{A.5.3}(13), see @ref{K}(13), see @ref{K,,K(221)}.
simple entry call    @ref{9.5.3}.
simple_expression    @ref{4.4}.
   used    @ref{3.5}(3), see @ref{3.5.4}(3),   @ref{3.5.7}(3), see @ref{3.5.4}(3),   @ref{3.5.7,,3.5.7(3)},
           @ref{4.4}(3), see @ref{13.5.1}(5), see @ref{13.5.1}(3), see @ref{13.5.1}(5), see @ref{13.5.1,,13.5.1(6)},
           @ref{P}.
simple_statement    @ref{5.1}.
   used    @ref{5.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Sin @ref{A.5.1}(5), see @ref{G.1.2}(4)
single
   class expected type    @ref{8.6}.
single entry    @ref{9.5.2}.
Single_Precision_Complex_Types    @ref{B.5}.
single_protected_declaration    @ref{9.4}.
   used    @ref{3.3.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
single_task_declaration    @ref{9.1}.
   used    @ref{3.3.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
Singular    @ref{11.1}.
Sinh    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(6)}.
size    @ref{A.8.4}(15), see @ref{A.12.1}(15), see @ref{A.12.1,,A.12.1(23)}.
   of an object    @ref{13.1}.
Size attribute    @ref{13.3}(40), see @ref{13.3}(40), see @ref{13.3,,13.3(45)},
                  @ref{K}(223),    @ref{K}(223),    @ref{K,,K(228)}.
Size clause    @ref{13.3}(7), see @ref{13.3}(41), see @ref{13.3}(7), see @ref{13.3}(41), see @ref{13.3,,13.3(48)}.
size_t    @ref{B.3}.
Skip_Line    @ref{A.10.1}.
Skip_Page    @ref{A.10.1}.
slice    @ref{4.1.2}(2), see @ref{A.4.4}(28), see @ref{A.4.5}(2), see @ref{A.4.4}(28), see @ref{A.4.5,,A.4.5(22)}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
small
   of a fixed point type    @ref{3.5.9}.
Small attribute    @ref{3.5.10}(2), see @ref{K}(2), see @ref{K,,K(230)}.
Small clause    @ref{3.5.10}(2), see @ref{13.3}(2), see @ref{13.3,,13.3(7)}.
Small_Int    @ref{3.2.2}(15), see @ref{3.5.4}(15), see @ref{3.5.4,,3.5.4(35)}.
SO    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
Soft_Hyphen    @ref{A.3.3}.
SOH    @ref{A.3.3}.
solidus    @ref{2.1}(15), see @ref{A.3.3}(15), see @ref{A.3.3,,A.3.3(8)}.
Source    @ref{13.9}.
SPA    @ref{A.3.3}.
Space    @ref{A.3.3}(8), see @ref{A.4.1}(8), see @ref{A.4.1,,A.4.1(4)}.
space_character    @ref{2.1}.
   used    @ref{2.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
special graphic character
   a category of Character    @ref{A.3.2}.
special_character    @ref{2.1}.
   used    @ref{2.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
   names    @ref{2.1}.
Special_Key    @ref{3.4}.
Special_Set    @ref{A.4.6}.
Specialized Needs Annexes    @ref{1.1.2}.
specifiable (of an attribute and for an entity)    @ref{13.3}.
specifiable
   of Address for entries    @ref{J.7.1}.
   of Address for stand-alone objects and for program units
         @ref{13.3}.
   of Alignment for first subtypes and objects    @ref{13.3}.
   of Bit_Order for record types and record extensions
         @ref{13.5.3}.
   of Component_Size for array types    @ref{13.3}.
   of External_Tag for a tagged type    @ref{13.3}(75), see @ref{K}(75), see @ref{K,,K(65)}.
   of Input for a type    @ref{13.13.2}.
   of Machine_Radix for decimal first subtypes    @ref{F.1}.
   of Output for a type    @ref{13.13.2}.
   of Read for a type    @ref{13.13.2}.
   of Size for first subtypes    @ref{13.3}.
   of Size for stand-alone objects    @ref{13.3}.
   of Small for fixed point types    @ref{3.5.10}.
   of Storage_Pool for a non-derived access-to-object type
         @ref{13.11}.
   of Storage_Size for a task first subtype    @ref{J.9}.
   of Storage_Size for a non-derived access-to-object type
         @ref{13.11}.
   of Write for a type    @ref{13.13.2}.
specific type    @ref{3.4.1}.
specified (not!)    @ref{1.1.3}.
specified
   of an aspect of representation of an entity    @ref{13.1}.
specified discriminant    @ref{3.7}.
Spin @ref{9.7.3}(6)
Split    @ref{9.6}(14), see @ref{D.8}(14), see @ref{D.8,,D.8(16)}.
Sqrt    @ref{A.5.1}(4), see @ref{B.1}(4), see @ref{B.1,,B.1(51)}, G.1.2(3)
Square    @ref{3.2.2}(15), see @ref{3.7}(35), see @ref{12.3}(15), see @ref{3.7}(35), see @ref{12.3,,12.3(24)}.
Squaring    @ref{12.1}(22), see @ref{12.2}(22), see @ref{12.2,,12.2(7)}.
SS2    @ref{A.3.3}.
SS3    @ref{A.3.3}.
SSA    @ref{A.3.3}.
ST    @ref{A.3.3}.
Stack    @ref{12.8}(3), see @ref{12.8}(4), see @ref{12.8}(3), see @ref{12.8}(4), see @ref{12.8,,12.8(14)}.
Stack_Bool    @ref{12.8}.
Stack_Int    @ref{12.8}.
Stack_Real    @ref{12.8}.
stand-alone constant    @ref{3.3.1}.
   corresponding to a formal object of mode in @ref{12.4}(10)
stand-alone object    @ref{3.3.1}.
stand-alone variable    @ref{3.3.1}.
Standard    @ref{A.1}.
standard error file    @ref{A.10}.
standard input file    @ref{A.10}.
standard mode    @ref{1.1.5}.
standard output file    @ref{A.10}.
standard storage pool    @ref{13.11}.
Standard_Error    @ref{A.10.1}(16), see @ref{A.10.1}(16), see @ref{A.10.1,,A.10.1(19)}.
Standard_Input    @ref{A.10.1}(16), see @ref{A.10.1}(16), see @ref{A.10.1,,A.10.1(19)}.
Standard_Output    @ref{A.10.1}(16), see @ref{A.10.1}(16), see @ref{A.10.1,,A.10.1(19)}.
State    @ref{3.8.1}(24), see @ref{13.5.1}(24), see @ref{13.5.1,,13.5.1(26)},
         @ref{A.5.2}(11), see @ref{A.5.2}(11), see @ref{A.5.2,,A.5.2(23)}.
State_Mask    @ref{13.5.1}.
statement    @ref{5.1}.
   used    @ref{5.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
statement_identifier    @ref{5.1}.
   used    @ref{5.1}(7), see @ref{5.5}(2), see @ref{5.6}(2), see @ref{P}(7), see @ref{5.5}(2), see @ref{5.6}(2), see @ref{P,,P(1)}.
static    @ref{4.9}.
   constant    @ref{4.9}.
   constraint    @ref{4.9}.
   delta constraint    @ref{4.9}.
   digits constraint    @ref{4.9}.
   discrete_range    @ref{4.9}.
   discriminant constraint    @ref{4.9}.
   expression    @ref{4.9}.
   function    @ref{4.9}.
   index constraint    @ref{4.9}.
   range    @ref{4.9}.
   range constraint    @ref{4.9}.
   scalar subtype    @ref{4.9}.
   string subtype    @ref{4.9}.
   subtype    @ref{4.9}(26), see @ref{12.4}(26), see @ref{12.4,,12.4(9)}.
static semantics    @ref{1.1.2}.
statically
   constrained    @ref{4.9}.
   denote    @ref{4.9}.
statically compatible
   for a constraint and a scalar subtype    @ref{4.9.1}.
   for a constraint and an access or composite subtype
         @ref{4.9.1}.
   for two subtypes    @ref{4.9.1}.
statically deeper    @ref{3.10.2}(4), see @ref{3.10.2}(4), see @ref{3.10.2,,3.10.2(17)}.
statically determined tag    @ref{3.9.2}.
   [partial]    @ref{3.9.2}(15), see @ref{3.9.2}(15), see @ref{3.9.2,,3.9.2(19)}.
statically matching
   effect on subtype-specific aspects    @ref{13.1}.
   for constraints    @ref{4.9.1}.
   for ranges    @ref{4.9.1}.
   for subtypes    @ref{4.9.1}.
   required    @ref{3.9.2}(10), see @ref{3.10.2}(27), see @ref{4.6}(10), see @ref{3.10.2}(27), see @ref{4.6,,4.6(12)},
               @ref{4.6}(16),    @ref{6.3.1}(16),   @ref{6.3.1}(16),    @ref{6.3.1}(16),   @ref{6.3.1,,6.3.1(17)},
               @ref{6.3.1}(23), see @ref{7.3}(13),     @ref{12.5.1}(23), see @ref{7.3}(13),     @ref{12.5.1,,12.5.1(14)},
               @ref{12.5.3}(6), see @ref{12.5.3}(7),   @ref{12.5.4}(6), see @ref{12.5.3}(7),   @ref{12.5.4,,12.5.4(3)},
               @ref{12.7}.
statically tagged    @ref{3.9.2}.
Status_Error    @ref{A.8.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1,,A.10.1(85)},
                @ref{A.12.1}(26), see @ref{A.13}(26), see @ref{A.13,,A.13(4)}.
storage deallocation
   unchecked    @ref{13.11.2}.
storage element    @ref{13.3}.
storage management
   user-defined    @ref{13.11}.
storage node    @ref{E}.
storage place
   of a component    @ref{13.5}.
storage place attributes
   of a component    @ref{13.5.2}.
storage pool    @ref{3.10}.
storage pool element    @ref{13.11}.
storage pool type    @ref{13.11}.
Storage_Array    @ref{13.7.1}.
Storage_Check    @ref{11.5}.
   [partial]    @ref{11.1}(6),    @ref{13.3}(6),    @ref{13.3,,13.3(67)},
                @ref{13.11}(17), see @ref{D.7}(17), see @ref{D.7,,D.7(15)}.
Storage_Count    @ref{13.7.1}.
   subtype in package System.Storage_Elements    @ref{13.7.1}.
Storage_Element    @ref{13.7.1}.
Storage_Elements
   child of System    @ref{13.7.1}.
Storage_Error    @ref{A.1}.
   raised by failure of run-time check
         @ref{4.8}(14),    @ref{11.1}(4),   @ref{11.1}(14),    @ref{11.1}(4),   @ref{11.1,,11.1(6)},
         @ref{11.5}(23),   @ref{13.3}(67), see @ref{13.11}(23),   @ref{13.3}(67), see @ref{13.11,,13.11(17)},
         @ref{13.11}(18), see @ref{A.7}(14),   @ref{D.7}(18), see @ref{A.7}(14),   @ref{D.7,,D.7(15)}.
Storage_Offset    @ref{13.7.1}.
Storage_Pool attribute    @ref{13.11}(13), see @ref{K}(13), see @ref{K,,K(232)}.
Storage_Pool clause    @ref{13.3}(7), see @ref{13.11}(7), see @ref{13.11,,13.11(15)}.
Storage_Pools
   child of System    @ref{13.11}.
Storage_Size    @ref{13.11}.
Storage_Size attribute    @ref{13.3}(60), see @ref{13.11}(60), see @ref{13.11,,13.11(14)},
                          @ref{J.9}(2),    @ref{K}(2),    @ref{K,,K(234)},
                          @ref{K}.
Storage_Size clause    @ref{13.3}(7), see @ref{13.11}(7), see @ref{13.11,,13.11(15)}.
   See also pragma Storage_Size    @ref{13.3}.
Storage_Size pragma    @ref{13.3}(63), see @ref{L}(63), see @ref{L,,L(35)}.
Storage_Unit    @ref{13.7}.
   named number in package System    @ref{13.7}.
Storage_IO
   child of Ada    @ref{A.9}.
Strcpy    @ref{B.3}(78), see @ref{B.3.2}(78), see @ref{B.3.2,,B.3.2(48)}.
stream    @ref{13.13}(1),   @ref{A.12.1}(1),   @ref{A.12.1,,A.12.1(13)},
          @ref{A.12.2}(4), see @ref{A.12.3}(4), see @ref{A.12.3,,A.12.3(4)}.
stream type    @ref{13.13}.
Stream_Access    @ref{A.12.1}(4), see @ref{A.12.2}(3), see @ref{A.12.3}(4), see @ref{A.12.2}(3), see @ref{A.12.3,,A.12.3(3)}.
Stream_Element    @ref{13.13.1}.
Stream_Element_Array    @ref{13.13.1}.
Stream_Element_Count    @ref{13.13.1}.
Stream_Element_Offset    @ref{13.13.1}.
Stream_IO
   child of Ada.Streams    @ref{A.12.1}.
Streams
   child of Ada    @ref{13.13.1}.
strict mode    @ref{G.2}.
String    @ref{3.6.3}(4), see @ref{A.1}(4), see @ref{A.1,,A.1(37)}.
string type    @ref{3.6.3}.
String_Access    @ref{A.4.5}.
string_element    @ref{2.6}.
   used    @ref{2.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
string_literal    @ref{2.6}.
   used    @ref{4.4}(7), see @ref{6.1}(9), see @ref{P}(7), see @ref{6.1}(9), see @ref{P,,P(1)}.
Strings
   child of Ada    @ref{A.4.1}.
   child of Interfaces.C    @ref{B.3.1}.
Strlen    @ref{B.3.1}.
structure
   See record type    @ref{3.8}.
STS    @ref{A.3.3}.
STX    @ref{A.3.3}(5), see @ref{J.5}(5), see @ref{J.5,,J.5(4)}.
SUB    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
subaggregate
   of an array_aggregate    @ref{4.3.3}.
subcomponent    @ref{3.2}.
subprogram    @ref{6}.
   abstract    @ref{3.9.3}.
subprogram call    @ref{6.4}.
subprogram instance    @ref{12.3}.
subprogram_body    @ref{6.3}.
   used    @ref{3.11}(6),    @ref{9.4}(6),    @ref{9.4,,9.4(8)},
           @ref{10.1.1}(7), see @ref{P}(7), see @ref{P,,P(1)}.
subprogram_body_stub    @ref{10.1.3}.
   used    @ref{10.1.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
subprogram_declaration    @ref{6.1}.
   used    @ref{3.1}(3),     @ref{9.4}(5), see @ref{9.4}(3),     @ref{9.4}(5), see @ref{9.4,,9.4(8)},
           @ref{10.1.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
subprogram_default    @ref{12.6}.
   used    @ref{12.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
subprogram_renaming_declaration    @ref{8.5.4}.
   used    @ref{8.5}(2), see @ref{10.1.1}(6), see @ref{P}(2), see @ref{10.1.1}(6), see @ref{P,,P(1)}.
subprogram_specification    @ref{6.1}.
   used    @ref{6.1}(2),    @ref{6.1}(3),     @ref{6.3}(2),    @ref{6.1}(3),     @ref{6.3,,6.3(2)},
           @ref{8.5.4}(2), see @ref{10.1.3}(3), see @ref{12.1}(2), see @ref{10.1.3}(3), see @ref{12.1,,12.1(3)},
           @ref{12.6}(2),   @ref{P}(2),   @ref{P,,P(1)}.
subsystem    @ref{10.1}(3), see @ref{N}(3), see @ref{N,,N(22)}.
Subtraction    @ref{3.9.1}.
subtype (of an object)
   See actual subtype of an object    @ref{3.3}(23), see @ref{3.3.1}(23), see @ref{3.3.1,,3.3.1(9)}.
subtype    @ref{3.2}(8), see @ref{N}(8), see @ref{N,,N(38)}.
subtype conformance    @ref{6.3.1}.
   [partial]    @ref{3.10.2}(34), see @ref{9.5.4}(34), see @ref{9.5.4,,9.5.4(17)}.
   required    @ref{3.9.2}(10), see @ref{3.10.2}(32), see @ref{4.6}(10), see @ref{3.10.2}(32), see @ref{4.6,,4.6(19)},
               @ref{8.5.4}(5),   @ref{9.5.4}(5),    @ref{13.3}(5),   @ref{9.5.4}(5),    @ref{13.3,,13.3(6)}.
subtype conversion
   See also implicit subtype conversion    @ref{4.6}.
   See type conversion    @ref{4.6}.
subtype-specific
   of a representation item    @ref{13.1}.
   of an aspect    @ref{13.1}.
subtype_declaration    @ref{3.2.2}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
subtype_indication    @ref{3.2.2}.
   used    @ref{3.2.2}(2), see @ref{3.3.1}(2), see @ref{3.4}(2), see @ref{3.3.1}(2), see @ref{3.4,,3.4(2)},
           @ref{3.6}(6),    @ref{3.6}(7),    @ref{3.6.1}(6),    @ref{3.6}(7),    @ref{3.6.1,,3.6.1(3)},
           @ref{3.10}(3),   @ref{4.8}(2),    @ref{7.3}(3),   @ref{4.8}(2),    @ref{7.3,,7.3(3)},
           @ref{P}.
subtype_mark    @ref{3.2.2}.
   used    @ref{3.2.2}(3), see @ref{3.6}(4),    @ref{3.7}(3), see @ref{3.6}(4),    @ref{3.7,,3.7(5)},
           @ref{3.10}(6),   @ref{4.3.2}(3), see @ref{4.4}(6),   @ref{4.3.2}(3), see @ref{4.4,,4.4(3)},
           @ref{4.6}(2),    @ref{4.7}(2),    @ref{6.1}(2),    @ref{4.7}(2),    @ref{6.1,,6.1(13)},
           @ref{6.1}(15),   @ref{8.4}(4),    @ref{8.5.1}(15),   @ref{8.4}(4),    @ref{8.5.1,,8.5.1(2)},
           @ref{12.3}(5),   @ref{12.4}(2),   @ref{12.5.1}(5),   @ref{12.4}(2),   @ref{12.5.1,,12.5.1(3)},
           @ref{P}.
subtypes
   of a profile    @ref{6.1}.
subunit    @ref{10.1.3}(7), see @ref{10.1.3}(7), see @ref{10.1.3,,10.1.3(8)}.
   used    @ref{10.1.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Succ attribute    @ref{3.5}(22), see @ref{K}(22), see @ref{K,,K(238)}.
Suit    @ref{3.5.1}.
Sum    @ref{12.1}(24), see @ref{12.2}(24), see @ref{12.2,,12.2(10)}.
super
   See view conversion    @ref{4.6}.
Superscript_One    @ref{A.3.3}.
Superscript_Three    @ref{A.3.3}.
Superscript_Two    @ref{A.3.3}.
Suppress pragma    @ref{11.5}(4), see @ref{L}(4), see @ref{L,,L(36)}.
suppressed check    @ref{11.5}.
Suspend_Until_True    @ref{D.10}.
Suspension_Object    @ref{D.10}.
Swap    @ref{12.3}.
Switch    @ref{6.1}.
SYN    @ref{A.3.3}(6), see @ref{J.5}(6), see @ref{J.5,,J.5(4)}.
synchronization    @ref{9}.
Synchronous_Task_Control
   child of Ada    @ref{D.10}.
syntactic category    @ref{1.1.4}.
syntax
   complete listing    @ref{P}.
   cross reference    @ref{P}.
   notation    @ref{1.1.4}.
   under Syntax heading    @ref{1.1.2}.
System    @ref{13.7}.
System.Address_To_Access_Conversions    @ref{13.7.2}.
System.Machine_Code    @ref{13.8}.
System.RPC    @ref{E.5}.
System.Storage_Elements    @ref{13.7.1}.
System.Storage_Pools    @ref{13.11}.
System_Name    @ref{13.7}.
systems programming    @ref{C}.
@end format

@c ---------------------------------------------------------------------------
@node Index.T, Index.U, Index.S, Index
@chapter index

@format
T    @ref{13.11}.
Table    @ref{3.2.1}(15),   @ref{3.6}(28), see @ref{12.5}(15),   @ref{3.6}(28), see @ref{12.5,,12.5(14)},
         @ref{12.5.3}(11), see @ref{12.8}(5), see @ref{12.8}(11), see @ref{12.8}(5), see @ref{12.8,,12.8(14)}.
Tag    @ref{3.9}.
Tag attribute    @ref{3.9}(16), see @ref{3.9}(16), see @ref{3.9,,3.9(18)},
                 @ref{K}(242),   @ref{K}(242),   @ref{K,,K(244)}.
tag indeterminate    @ref{3.9.2}.
tag of an object    @ref{3.9}.
   class-wide object    @ref{3.9}.
   object created by an allocator    @ref{3.9}.
   preserved by type conversion and parameter passing
         @ref{3.9}.
   returned by a function    @ref{3.9}(23), see @ref{3.9}(23), see @ref{3.9,,3.9(24)}.
   stand-alone object, component, or aggregate    @ref{3.9}.
Tag_Check    @ref{11.5}.
   [partial]    @ref{3.9.2}(16), see @ref{4.6}(42), see @ref{4.6}(16), see @ref{4.6}(42), see @ref{4.6,,4.6(52)},
                @ref{5.2}(10),    @ref{6.5}(10),    @ref{6.5,,6.5(9)}.
Tag_Error    @ref{3.9}.
tagged type    @ref{3.9}(2), see @ref{N}(2), see @ref{N,,N(39)}.
Tags
   child of Ada    @ref{3.9}.
tail (of a queue)    @ref{D.2.1}.
Tail    @ref{A.4.3}(37), see @ref{A.4.3}(38), see @ref{A.4.4}(37), see @ref{A.4.3}(38), see @ref{A.4.4,,A.4.4(72)},
        @ref{A.4.4}(73), see @ref{A.4.5}(67), see @ref{A.4.5}(73), see @ref{A.4.5}(67), see @ref{A.4.5,,A.4.5(68)}.
Take    @ref{3.9.3}.
Tan    @ref{A.5.1}(5), see @ref{G.1.2}(5), see @ref{G.1.2,,G.1.2(4)}.
Tanh    @ref{A.5.1}(7), see @ref{G.1.2}(7), see @ref{G.1.2,,G.1.2(6)}.
Tape    @ref{E.4.2}.
Tape_Client    @ref{E.4.2}.
Tape_Driver    @ref{E.4.2}(4), see @ref{E.4.2}(4), see @ref{E.4.2,,E.4.2(5)}.
Tape_Ptr    @ref{E.4.2}.
Tapes    @ref{E.4.2}.
target    @ref{13.9}.
   of an assignment_statement    @ref{5.2}.
   of an assignment operation    @ref{5.2}.
target entry
   of a requeue_statement    @ref{9.5.4}.
target object
   of a requeue_statement    @ref{9.5}.
   of a call on an entry or a protected subprogram    @ref{9.5}.
target statement
   of a goto_statement    @ref{5.8}.
target subtype
   of a type_conversion    @ref{4.6}.
task    @ref{9}.
   activation    @ref{9.2}.
   completion    @ref{9.3}.
   dependence    @ref{9.3}.
   execution    @ref{9.2}.
   termination    @ref{9.3}.
task declaration    @ref{9.1}.
task dispatching    @ref{D.2.1}.
task dispatching point    @ref{D.2.1}.
   [partial]    @ref{D.2.1}(8), see @ref{D.2.2}(8), see @ref{D.2.2,,D.2.2(12)}.
task dispatching policy    @ref{D.2.2}.
   [partial]    @ref{D.2.1}.
task priority    @ref{D.1}.
task state
   abnormal    @ref{9.8}.
   blocked    @ref{9}.
   callable    @ref{9.9}.
   held    @ref{D.11}.
   inactive    @ref{9}.
   ready    @ref{9}.
   terminated    @ref{9}.
Task type    @ref{N}.
task unit    @ref{9}.
Task_Attributes
   child of Ada    @ref{C.7.2}.
task_body    @ref{9.1}.
   used    @ref{3.11}(6), see @ref{P}(6), see @ref{P,,P(1)}.
task_body_stub    @ref{10.1.3}.
   used    @ref{10.1.3}(2), see @ref{P}(2), see @ref{P,,P(1)}.
task_definition    @ref{9.1}.
   used    @ref{9.1}(2), see @ref{9.1}(3), see @ref{P}(2), see @ref{9.1}(3), see @ref{P,,P(1)}.
Task_Dispatching_Policy pragma    @ref{D.2.2}(2), see @ref{L}(2), see @ref{L,,L(37)}.
Task_Identification
   child of Ada    @ref{C.7.1}.
task_item    @ref{9.1}.
   used    @ref{9.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
task_type_declaration    @ref{9.1}.
   used    @ref{3.2.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Task_ID    @ref{C.7.1}.
Tasking_Error    @ref{A.1}.
   raised by failure of run-time check
         @ref{9.2}(5),       @ref{9.5.3}(21),    @ref{11.1}(5),       @ref{9.5.3}(21),    @ref{11.1,,11.1(4)},
         @ref{13.11.2}(13), see @ref{13.11.2}(14), see @ref{C.7.2}(13), see @ref{13.11.2}(14), see @ref{C.7.2,,C.7.2(13)},
         @ref{D.5}(8),       @ref{D.11}(8),       @ref{D.11,,D.11(8)}.
template    @ref{12}.
   See generic unit    @ref{12}.
   for a formal package    @ref{12.7}.
term    @ref{4.4}.
   used    @ref{4.4}, P(1)
terminal interrupt
   example    @ref{9.7.4}.
terminate_alternative    @ref{9.7.1}.
   used    @ref{9.7.1}(4), see @ref{P}(4), see @ref{P,,P(1)}.
terminated
   a task state    @ref{9}.
Terminated attribute    @ref{9.9}(3), see @ref{K}(3), see @ref{K,,K(246)}.
termination
   of a partition    @ref{E.1}.
Terminator_Error    @ref{B.3}.
Test    @ref{B.3}.
Test_Call    @ref{B.4}.
Test_External_Formats    @ref{B.4}.
Test_Pointers    @ref{B.3.2}.
tested type
   of a membership test    @ref{4.5.2}.
text of a program    @ref{2.2}.
Text_Streams
   child of Ada.Text_IO    @ref{A.12.2}(3), see @ref{A.12.3}(3), see @ref{A.12.3,,A.12.3(3)}.
Text_IO    @ref{J.1}.
   child of Ada    @ref{A.10.1}.
throw (an exception)
   See raise    @ref{11}.
tick    @ref{2.1}(15), see @ref{13.7}(10), see @ref{D.8}(15), see @ref{13.7}(10), see @ref{D.8,,D.8(7)}.
   named number in package System    @ref{13.7}.
Tilde    @ref{A.3.3}.
Time    @ref{9.6}(10), see @ref{D.8}(10), see @ref{D.8,,D.8(4)}.
time base    @ref{9.6}.
time limit
   example    @ref{9.7.4}.
time type    @ref{9.6}.
Time-dependent Reset procedure
   of the random number generator    @ref{A.5.2}.
time-out
   See asynchronous_select    @ref{9.7.4}.
   See selective_accept    @ref{9.7.1}.
   See timed_entry_call    @ref{9.7.2}.
   example    @ref{9.7.4}.
Time_Error    @ref{9.6}.
Time_First    @ref{D.8}.
Time_Last    @ref{D.8}.
Time_Span    @ref{D.8}.
Time_Span_First    @ref{D.8}.
Time_Span_Last    @ref{D.8}.
Time_Span_Unit    @ref{D.8}.
Time_Span_Zero    @ref{D.8}.
Time_Unit    @ref{D.8}.
Time_Of    @ref{9.6}(15), see @ref{D.8}(15), see @ref{D.8,,D.8(16)}.
timed_entry_call    @ref{9.7.2}.
   used    @ref{9.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
timer interrupt
   example    @ref{9.7.4}.
times operator    @ref{4.4}(1), see @ref{4.5.5}(1), see @ref{4.5.5,,4.5.5(1)}.
timing
   See delay_statement    @ref{9.6}.
TM    @ref{8.5.3}.
To_Ada    @ref{B.3}(22), see @ref{B.3}(26), see @ref{B.3}(22), see @ref{B.3}(26), see @ref{B.3,,B.3(28)},
          @ref{B.3}(32), see @ref{B.3}(37), see @ref{B.3}(32), see @ref{B.3}(37), see @ref{B.3,,B.3(39)},
          @ref{B.4}(17), see @ref{B.4}(19), see @ref{B.5}(17), see @ref{B.4}(19), see @ref{B.5,,B.5(13)},
          @ref{B.5}(14), see @ref{B.5}(14), see @ref{B.5,,B.5(16)}.
To_Address    @ref{13.7.1}(10), see @ref{13.7.2}(10), see @ref{13.7.2,,13.7.2(3)}.
To_Basic    @ref{A.3.2}(6), see @ref{A.3.2}(6), see @ref{A.3.2,,A.3.2(7)}.
To_Binary    @ref{B.4}(45), see @ref{B.4}(45), see @ref{B.4,,B.4(48)}.
To_Bounded_String    @ref{A.4.4}.
To_Character    @ref{A.3.2}.
To_COBOL    @ref{B.4}(17), see @ref{B.4}(17), see @ref{B.4,,B.4(18)}.
To_Decimal    @ref{B.4}(35), see @ref{B.4}(35), see @ref{B.4,,B.4(40)},
              @ref{B.4}(44), see @ref{B.4}(44), see @ref{B.4,,B.4(47)}.
To_Display    @ref{B.4}.
To_Domain @ref{A.4.2}(24), see @ref{A.4.7}(24)
To_Duration    @ref{D.8}.
To_Fortran    @ref{B.5}(13), see @ref{B.5}(14), see @ref{B.5}(13), see @ref{B.5}(14), see @ref{B.5,,B.5(15)}.
To_Integer    @ref{13.7.1}.
To_ISO_646    @ref{A.3.2}(11), see @ref{A.3.2}(11), see @ref{A.3.2,,A.3.2(12)}.
To_Long_Binary    @ref{B.4}.
To_Lower    @ref{A.3.2}(6), see @ref{A.3.2}(6), see @ref{A.3.2,,A.3.2(7)}.
To_Mapping    @ref{A.4.2}(23), see @ref{A.4.7}(23), see @ref{A.4.7,,A.4.7(23)}.
To_Packed    @ref{B.4}.
To_Picture    @ref{F.3.3}.
To_Pointer    @ref{13.7.2}.
To_Range    @ref{A.4.2}(24), see @ref{A.4.7}(24), see @ref{A.4.7,,A.4.7(25)}.
To_Ranges    @ref{A.4.2}(10), see @ref{A.4.7}(10), see @ref{A.4.7,,A.4.7(10)}.
To_Sequence    @ref{A.4.2}(19), see @ref{A.4.7}(19), see @ref{A.4.7,,A.4.7(19)}.
To_Set    @ref{A.4.2}(8),   @ref{A.4.2}(9), see @ref{A.4.2}(8),   @ref{A.4.2}(9), see @ref{A.4.2,,A.4.2(17)},
          @ref{A.4.2}(18), see @ref{A.4.7}(8), see @ref{A.4.7}(18), see @ref{A.4.7}(8), see @ref{A.4.7,,A.4.7(9)},
          @ref{A.4.7}(17), see @ref{A.4.7}(17), see @ref{A.4.7,,A.4.7(18)}.
To_String    @ref{A.3.2}(16), see @ref{A.4.4}(12), see @ref{A.4.5}(16), see @ref{A.4.4}(12), see @ref{A.4.5,,A.4.5(11)}.
To_Time_Span    @ref{D.8}.
To_Unbounded_String    @ref{A.4.5}(9), see @ref{A.4.5}(9), see @ref{A.4.5,,A.4.5(10)}.
To_Upper    @ref{A.3.2}(6), see @ref{A.3.2}(6), see @ref{A.3.2,,A.3.2(7)}.
To_Wide_Character    @ref{A.3.2}.
To_Wide_String    @ref{A.3.2}.
To_C    @ref{B.3}(21), see @ref{B.3}(25), see @ref{B.3}(21), see @ref{B.3}(25), see @ref{B.3,,B.3(27)},
        @ref{B.3}(32), see @ref{B.3}(36), see @ref{B.3}(32), see @ref{B.3}(36), see @ref{B.3,,B.3(38)}.
token
   See lexical element    @ref{2.2}.
Tolerance    @ref{3.3.1}.
Trailing_Nonseparate    @ref{B.4}.
Trailing_Separate    @ref{B.4}.
transfer of control    @ref{5.1}.
Translate    @ref{A.4.3}(18), see @ref{A.4.3}(19), see @ref{A.4.3}(18), see @ref{A.4.3}(19), see @ref{A.4.3,,A.4.3(20)},
             @ref{A.4.3}(21), see @ref{A.4.4}(53), see @ref{A.4.4}(21), see @ref{A.4.4}(53), see @ref{A.4.4,,A.4.4(54)},
             @ref{A.4.4}(55), see @ref{A.4.4}(56), see @ref{A.4.5}(55), see @ref{A.4.4}(56), see @ref{A.4.5,,A.4.5(48)},
             @ref{A.4.5}(49), see @ref{A.4.5}(50), see @ref{A.4.5}(49), see @ref{A.4.5}(50), see @ref{A.4.5,,A.4.5(51)}.
Traverse_Tree    @ref{6.1}.
triggering_alternative    @ref{9.7.4}.
   used    @ref{9.7.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
triggering_statement    @ref{9.7.4}.
   used    @ref{9.7.4}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Trim    @ref{A.4.3}(31), see @ref{A.4.3}(32), see @ref{A.4.3}(31), see @ref{A.4.3}(32), see @ref{A.4.3,,A.4.3(33)},
        @ref{A.4.3}(34), see @ref{A.4.4}(67), see @ref{A.4.4}(34), see @ref{A.4.4}(67), see @ref{A.4.4,,A.4.4(68)},
        @ref{A.4.4}(69), see @ref{A.4.5}(61), see @ref{A.4.5}(69), see @ref{A.4.5}(61), see @ref{A.4.5,,A.4.5(62)},
        @ref{A.4.5}(63), see @ref{A.4.5}(63), see @ref{A.4.5,,A.4.5(64)}.
Trim_End    @ref{A.4.1}.
True    @ref{3.5.3}.
Truncation    @ref{A.4.1}.
Truncation attribute    @ref{A.5.3}(42), see @ref{K}(42), see @ref{K,,K(248)}.
two's complement
   modular types    @ref{3.5.4}.
Two_Pi    @ref{3.3.2}.
type    @ref{3.2}(1), see @ref{N}(1), see @ref{N,,N(41)}.
   See also tag    @ref{3.9}.
   abstract    @ref{3.9.3}.
   See also   language-defined types
type conformance    @ref{6.3.1}.
   [partial]    @ref{3.4}(17), see @ref{8.3}(17), see @ref{8.3,,8.3(8)},
                @ref{8.3}(26), see @ref{10.1.4}(26), see @ref{10.1.4,,10.1.4(4)}.
   required    @ref{3.11.1}(5), see @ref{4.1.4}(5), see @ref{4.1.4,,4.1.4(14)},
               @ref{8.6}(26),    @ref{9.5.4}(26),    @ref{9.5.4,,9.5.4(3)}.
type conversion    @ref{4.6}.
   See also qualified_expression    @ref{4.7}.
   access    @ref{4.6}(13), see @ref{4.6}(18), see @ref{4.6}(13), see @ref{4.6}(18), see @ref{4.6,,4.6(47)}.
   arbitrary order    @ref{1.1.4}.
   array    @ref{4.6}(9), see @ref{4.6}(9), see @ref{4.6,,4.6(36)}.
   composite (non-array)    @ref{4.6}(21), see @ref{4.6}(21), see @ref{4.6,,4.6(40)}.
   enumeration    @ref{4.6}(21), see @ref{4.6}(21), see @ref{4.6,,4.6(34)}.
   numeric    @ref{4.6}(8), see @ref{4.6}(8), see @ref{4.6,,4.6(29)}.
   unchecked    @ref{13.9}.
type conversion, implicit
   See implicit subtype conversion    @ref{4.6}.
type extension    @ref{3.9}(2), see @ref{3.9.1}(2), see @ref{3.9.1,,3.9.1(1)}.
type of a discrete_range    @ref{3.6.1}.
type of a range    @ref{3.5}.
type parameter
   See discriminant    @ref{3.7}.
type profile
   See profile, type conformant    @ref{6.3.1}.
type resolution rules    @ref{8.6}.
   if any type in a specified class of types is expected
         @ref{8.6}.
   if expected type is specific    @ref{8.6}.
   if expected type is universal or class-wide    @ref{8.6}.
type tag
   See tag    @ref{3.9}.
type-related
   aspect    @ref{13.1}.
   representation item    @ref{13.1}.
type_conversion    @ref{4.6}.
   used    @ref{4.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
   See also unchecked type conversion    @ref{13.9}.
type_declaration    @ref{3.2.1}.
   used    @ref{3.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
type_definition    @ref{3.2.1}.
   used    @ref{3.2.1}(3), see @ref{P}(3), see @ref{P,,P(1)}.
Type_Set    @ref{A.10.1}(7), see @ref{A.10.10}(7), see @ref{A.10.10,,A.10.10(3)}.
types
   of a profile    @ref{6.1}.
@end format

@c ---------------------------------------------------------------------------
@node Index.U, Index.V, Index.T, Index
@chapter index

@format
UC_Icelandic_Eth    @ref{A.3.3}.
UC_Icelandic_Thorn    @ref{A.3.3}.
UC_A_Acute    @ref{A.3.3}.
UC_A_Circumflex    @ref{A.3.3}.
UC_A_Diaeresis    @ref{A.3.3}.
UC_A_Grave    @ref{A.3.3}.
UC_A_Ring    @ref{A.3.3}.
UC_A_Tilde    @ref{A.3.3}.
UC_AE_Diphthong    @ref{A.3.3}.
UC_C_Cedilla    @ref{A.3.3}.
UC_E_Acute    @ref{A.3.3}.
UC_E_Circumflex    @ref{A.3.3}.
UC_E_Diaeresis    @ref{A.3.3}.
UC_E_Grave    @ref{A.3.3}.
UC_I_Acute    @ref{A.3.3}.
UC_I_Circumflex    @ref{A.3.3}.
UC_I_Diaeresis    @ref{A.3.3}.
UC_I_Grave    @ref{A.3.3}.
UC_N_Tilde    @ref{A.3.3}.
UC_O_Acute    @ref{A.3.3}.
UC_O_Circumflex    @ref{A.3.3}.
UC_O_Diaeresis    @ref{A.3.3}.
UC_O_Grave    @ref{A.3.3}.
UC_O_Oblique_Stroke    @ref{A.3.3}.
UC_O_Tilde    @ref{A.3.3}.
UC_U_Acute    @ref{A.3.3}.
UC_U_Circumflex    @ref{A.3.3}.
UC_U_Diaeresis    @ref{A.3.3}.
UC_U_Grave    @ref{A.3.3}.
UC_Y_Acute    @ref{A.3.3}.
UCHAR_MAX    @ref{B.3}.
ultimate ancestor
   of a type    @ref{3.4.1}.
unary adding operator    @ref{4.5.4}.
unary operator    @ref{4.5}.
unary_adding_operator    @ref{4.5}.
   used    @ref{4.4}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Unbiased_Rounding attribute    @ref{A.5.3}(39), see @ref{K}(39), see @ref{K,,K(252)}.
Unbounded    @ref{A.10.1}.
   child of Ada.Strings    @ref{A.4.5}.
Unbounded_String    @ref{A.4.5}.
unchecked storage deallocation    @ref{13.11.2}.
unchecked type conversion    @ref{13.9}.
Unchecked_Access attribute    @ref{13.10}(3), see @ref{H.4}(3), see @ref{H.4,,H.4(18)},
                              @ref{K}.
   See also Access attribute    @ref{3.10.2}.
Unchecked_Conversion    @ref{J.1}.
   child of Ada    @ref{13.9}.
Unchecked_Deallocation    @ref{J.1}.
   child of Ada    @ref{13.11.2}.
unconstrained    @ref{3.2}.
   object    @ref{3.3.1}(9), see @ref{3.10}(9), see @ref{6.4.1}(9), see @ref{3.10}(9), see @ref{6.4.1,,6.4.1(16)}.
   subtype    @ref{3.2}(9),     @ref{3.4}(6),     @ref{3.5}(9),     @ref{3.4}(6),     @ref{3.5,,3.5(7)},
              @ref{3.5.1}(10), see @ref{3.5.4}(9),   @ref{3.5.4}(10), see @ref{3.5.4}(9),   @ref{3.5.4,,3.5.4(10)},
              @ref{3.5.7}(11), see @ref{3.5.9}(13), see @ref{3.5.9}(11), see @ref{3.5.9}(13), see @ref{3.5.9,,3.5.9(16)},
              @ref{3.6}(15),    @ref{3.6}(16),    @ref{3.7}(15),    @ref{3.6}(16),    @ref{3.7,,3.7(26)},
              @ref{3.9}(15),    @ref{3.10}(14),   @ref{K}(15),    @ref{3.10}(14),   @ref{K,,K(33)}.
unconstrained_array_definition    @ref{3.6}.
   used    @ref{3.6}(2), see @ref{P}(2), see @ref{P,,P(1)}.
undefined result    @ref{11.6}.
underline    @ref{2.1}(15), see @ref{J.5}(15), see @ref{J.5,,J.5(6)}.
   used    @ref{2.3}(2),    @ref{2.4.1}(2),    @ref{2.4.1,,2.4.1(3)},
           @ref{2.4.2}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Uniformly_Distributed    @ref{A.5.2}.
uninitialized allocator    @ref{4.8}.
uninitialized variables    @ref{13.9.1}.
   [partial]    @ref{3.3.1}.
Union    @ref{3.9.3}.
unit consistency    @ref{E.3}.
Unit_Set    @ref{3.9.3}.
universal type    @ref{3.4.1}.
universal_fixed
   [partial]    @ref{3.5.6}.
universal_integer    @ref{3.5.4}.
   [partial]    @ref{3.5.4}.
universal_real
   [partial]    @ref{3.5.6}.
unknown discriminants    @ref{3.7}.
unknown_discriminant_part    @ref{3.7}.
   used    @ref{3.7}(2), see @ref{P}(2), see @ref{P,,P(1)}.
unmarshalling    @ref{E.4}.
unpolluted    @ref{13.13.1}.
unsigned    @ref{B.3}, B.4(23)
unsigned type
   See modular type    @ref{3.5.4}.
Unsigned_    @ref{B.2}.
unsigned_char    @ref{B.3}.
unsigned_long    @ref{B.3}.
unsigned_short    @ref{B.3}.
unspecified    @ref{1.1.3}.
   [partial]    @ref{2.1}(5),      @ref{4.5.2}(13), see @ref{4.5.5}(5),      @ref{4.5.2}(13), see @ref{4.5.5,,4.5.5(21)},
                @ref{6.2}(11),     @ref{7.2}(5),     @ref{9.8}(11),     @ref{7.2}(5),     @ref{9.8,,9.8(14)},
                @ref{10.2}(26),    @ref{11.1}(6),    @ref{11.5}(26),    @ref{11.1}(6),    @ref{11.5,,11.5(27)},
                @ref{13.1}(18),    @ref{13.7.2}(5), see @ref{13.9.1}(18),    @ref{13.7.2}(5), see @ref{13.9.1,,13.9.1(7)},
                @ref{13.11}(20),   @ref{A.1}(1),     @ref{A.5.1}(20),   @ref{A.1}(1),     @ref{A.5.1,,A.5.1(34)},
                @ref{A.5.2}(28),   @ref{A.5.2}(34), see @ref{A.7}(28),   @ref{A.5.2}(34), see @ref{A.7,,A.7(6)},
                @ref{A.10}(8),     @ref{A.10.7}(8), see @ref{A.10.7}(8),     @ref{A.10.7}(8), see @ref{A.10.7,,A.10.7(12)},
                @ref{A.10.7}(19), see @ref{A.14}(1),    @ref{A.15}(19), see @ref{A.14}(1),    @ref{A.15,,A.15(20)},
                @ref{D.2.2}(6),    @ref{D.8}(19),    @ref{G.1.1}(6),    @ref{D.8}(19),    @ref{G.1.1,,G.1.1(40)},
                @ref{G.1.2}(33),   @ref{G.1.2}(48), see @ref{H}(33),   @ref{G.1.2}(48), see @ref{H,,H(4)},
                @ref{H.2}.
Up_To_K    @ref{3.2.2}.
update    @ref{B.3.1}(18), see @ref{B.3.1}(18), see @ref{B.3.1,,B.3.1(19)}.
   the value of an object    @ref{3.3}.
Update_Error    @ref{B.3.1}.
upper bound
   of a range    @ref{3.5}.
upper-case letter
   a category of Character    @ref{A.3.2}.
upper_case_identifier_letter    @ref{2.1}.
Upper_Case_Map    @ref{A.4.6}.
Upper_Set    @ref{A.4.6}.
US    @ref{A.3.3}.
usage name    @ref{3.1}.
use-visible    @ref{8.3}(4), see @ref{8.4}(4), see @ref{8.4,,8.4(9)}.
use_clause    @ref{8.4}.
   used    @ref{3.11}(4), see @ref{10.1.2}(4), see @ref{10.1.2,,10.1.2(3)},
           @ref{12.1}(5), see @ref{P}(5), see @ref{P,,P(1)}.
Use_Error    @ref{A.8.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1}(15),   @ref{A.8.4}(18), see @ref{A.10.1,,A.10.1(85)},
             @ref{A.12.1}(26), see @ref{A.13}(26), see @ref{A.13,,A.13(4)}.
use_package_clause    @ref{8.4}.
   used    @ref{8.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
use_type_clause    @ref{8.4}.
   used    @ref{8.4}(2), see @ref{P}(2), see @ref{P,,P(1)}.
User    @ref{9.1}.
user-defined assignment    @ref{7.6}.
user-defined heap management    @ref{13.11}.
user-defined operator    @ref{6.6}.
user-defined storage management    @ref{13.11}.
@end format

@c ---------------------------------------------------------------------------
@node Index.V, Index.W, Index.U, Index
@chapter index

@format
Val attribute    @ref{3.5.5}(5), see @ref{K}(5), see @ref{K,,K(258)}.
Valid    @ref{B.4}(33),   @ref{B.4}(38), see @ref{B.4}(33),   @ref{B.4}(38), see @ref{B.4,,B.4(43)},
         @ref{F.3.3}(5), see @ref{F.3.3}(5), see @ref{F.3.3,,F.3.3(12)}.
Valid attribute    @ref{13.9.2}(3), see @ref{H}(6), see @ref{K}(3), see @ref{H}(6), see @ref{K,,K(262)}.
Value    @ref{A.4.2}(21), see @ref{A.5.2}(14), see @ref{A.5.2}(21), see @ref{A.5.2}(14), see @ref{A.5.2,,A.5.2(26)},
         @ref{B.3.1}(13), see @ref{B.3.1}(14), see @ref{B.3.1}(13), see @ref{B.3.1}(14), see @ref{B.3.1,,B.3.1(15)},
         @ref{B.3.1}(16), see @ref{B.3.2}(6),   @ref{B.3.2}(16), see @ref{B.3.2}(6),   @ref{B.3.2,,B.3.2(7)},
         @ref{C.7.2}.
Value attribute    @ref{3.5}(52), see @ref{K}(52), see @ref{K,,K(264)}.
value conversion    @ref{4.6}.
Var_Line    @ref{3.6.1}.
variable    @ref{3.3}.
variable object    @ref{3.3}.
variable view    @ref{3.3}.
variant    @ref{3.8.1}.
   used    @ref{3.8.1}(2), see @ref{P}(2), see @ref{P,,P(1)}.
   See also tagged type    @ref{3.9}.
variant_part    @ref{3.8.1}.
   used    @ref{3.8}(4), see @ref{P}(4), see @ref{P,,P(1)}.
Vector    @ref{3.6}(26), see @ref{12.1}(24), see @ref{12.5.3}(26), see @ref{12.1}(24), see @ref{12.5.3,,12.5.3(11)}.
version
   of a compilation unit    @ref{E.3}.
Version attribute    @ref{E.3}(3), see @ref{K}(3), see @ref{K,,K(268)}.
vertical line    @ref{2.1}.
Vertical_Line    @ref{A.3.3}.
view    @ref{3.1}(7), see @ref{N}(12), see @ref{N}(7), see @ref{N}(12), see @ref{N,,N(42)}.
view conversion    @ref{4.6}.
virtual function
   See dispatching subprogram    @ref{3.9.2}.
Virtual_Length    @ref{B.3.2}.
visibility
   direct    @ref{8.3}(2), see @ref{8.3}(2), see @ref{8.3,,8.3(21)}.
   immediate    @ref{8.3}(4), see @ref{8.3}(4), see @ref{8.3,,8.3(21)}.
   use clause    @ref{8.3}(4), see @ref{8.4}(4), see @ref{8.4,,8.4(9)}.
visibility rules    @ref{8.3}.
visible    @ref{8.3}(2), see @ref{8.3}(2), see @ref{8.3,,8.3(14)}.
   within a pragma in a context_clause    @ref{10.1.6}.
   within a pragma that appears at the place of a compilation unit
         @ref{10.1.6}.
   within a with_clause    @ref{10.1.6}.
   within a use_clause in a context_clause    @ref{10.1.6}.
   within the parent_unit_name of a library unit    @ref{10.1.6}.
   within the parent_unit_name of a subunit    @ref{10.1.6}.
visible part    @ref{8.2}.
   of a formal package    @ref{12.7}.
   of a generic unit    @ref{8.2}.
   of a package (other than a generic formal package)
         @ref{7.1}.
   of a protected unit    @ref{9.4}.
   of a task unit    @ref{9.1}.
   of a view of a callable entity    @ref{8.2}.
   of a view of a composite type    @ref{8.2}.
volatile    @ref{C.6}.
Volatile pragma    @ref{C.6}(4), see @ref{L}(4), see @ref{L,,L(38)}.
Volatile_Components pragma    @ref{C.6}(6), see @ref{L}(6), see @ref{L,,L(39)}.
Volt    @ref{3.5.9}.
VT    @ref{A.3.3}.
VTS    @ref{A.3.3}.
@end format

@c ---------------------------------------------------------------------------
@node Index.W, Index.X, Index.V, Index
@chapter index

@format
wchar_t    @ref{B.3}.
Weekday    @ref{3.5.1}.
well-formed picture String
   for edited output    @ref{F.3.1}.
Wide_Bounded
   child of Ada.Strings    @ref{A.4.7}.
Wide_Character    @ref{3.5.2}(3), see @ref{A.1}(3), see @ref{A.1,,A.1(36)}.
Wide_Character_Mapping    @ref{A.4.7}.
Wide_Character_Mapping_Function    @ref{A.4.7}.
Wide_Character_Range    @ref{A.4.7}.
Wide_Character_Sequence    @ref{A.4.7}.
Wide_Character_Set    @ref{A.4.7}.
Wide_Constants
   child of Ada.Strings.Wide_Maps    @ref{A.4.7}.
Wide_Fixed
   child of Ada.Strings    @ref{A.4.7}.
Wide_Image attribute    @ref{3.5}(28), see @ref{K}(28), see @ref{K,,K(270)}.
Wide_Maps
   child of Ada.Strings    @ref{A.4.7}.
wide_nul    @ref{B.3}.
Wide_Space    @ref{A.4.1}.
Wide_String    @ref{3.6.3}(4), see @ref{A.1}(4), see @ref{A.1,,A.1(41)}.
Wide_Text_IO
   child of Ada    @ref{A.11}.
Wide_Unbounded
   child of Ada.Strings    @ref{A.4.7}.
Wide_Value attribute    @ref{3.5}(40), see @ref{K}(40), see @ref{K,,K(274)}.
Wide_Width attribute    @ref{3.5}(38), see @ref{K}(38), see @ref{K,,K(278)}.
Width attribute    @ref{3.5}(39), see @ref{K}(39), see @ref{K,,K(280)}.
with_clause    @ref{10.1.2}.
   used    @ref{10.1.2}(3), see @ref{P}(3), see @ref{P,,P(1)}.
   mentioned in @ref{10.1.2}(6)
within
   immediately    @ref{8.1}.
word    @ref{13.3}(8), see @ref{13.5.1}(8), see @ref{13.5.1,,13.5.1(25)}.
Word_Size    @ref{13.7}.
   named number in package System    @ref{13.7}.
Worker    @ref{A.5.2}.
Write    @ref{7.5}(19),     @ref{7.5}(20),     @ref{9.1}(19),     @ref{7.5}(20),     @ref{9.1,,9.1(24)},
         @ref{9.11}(8),     @ref{9.11}(9),     @ref{13.13.1}(8),     @ref{9.11}(9),     @ref{13.13.1,,13.13.1(6)},
         @ref{A.8.1}(12),   @ref{A.8.4}(13),   @ref{A.9}(12),   @ref{A.8.4}(13),   @ref{A.9,,A.9(7)},
         @ref{A.12.1}(18), see @ref{A.12.1}(19), see @ref{E.5}(18), see @ref{A.12.1}(19), see @ref{E.5,,E.5(8)}.
Write attribute    @ref{13.13.2}(3), see @ref{13.13.2}(3), see @ref{13.13.2,,13.13.2(11)},
                   @ref{K}(282),      @ref{K}(282),      @ref{K,,K(286)}.
Write clause    @ref{13.3}(7), see @ref{13.13.2}(7), see @ref{13.13.2,,13.13.2,,13.13.2,,13.13.2(36)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.X, Index.Y, Index.W, Index
@chapter index

@format
xor operator    @ref{4.4}(1), see @ref{4.5.1}(1), see @ref{4.5.1,,4.5.1(2)}.
@end format

@c ---------------------------------------------------------------------------
@node Index.Y, , Index.X, Index
@chapter index

@format
Year    @ref{9.6}.
Year_Number    @ref{9.6}.
Yen_Sign    @ref{A.3.3}.
@end format

@bye
