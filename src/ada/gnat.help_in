1  GNAT

   Invoke the GNAT compilation system to build a program, compile a
   file, bind a program, link a program, split a source file into
   multiple units, preprocess a source file, or generate
   cross-reference information.


2  Model_Of_Compilation

   Although similar to that used by other languages, such as C and C++,
   GNAT's compilation model is substantially different from the
   traditional Ada compilation models, which are based on a library.


3  Source_Representation

   Ada source programs are represented in standard text files, using
   Latin-1 coding. Latin-1 is ASCII with the additional characters used
   for representing foreign languages (see HELP GNAT COMPILE
   /IDENTIFIER_CHARACTER_SET) for support of non-USA character sets). The
   format effector characters are represented using their standard ASCII
   encodings, as follows:

   o Vertical tab, 16#0B#
   o Horizontal tab, 16#09#
   o Carriage return, 16#0D#
   o Line feed, 16#0A#
   o Form feed, 16#0C#

   Each file contains a single Ada compilation unit, including any
   pragmas associated with the unit. For example, this means you must
   place a package declaration (a package "spec") and the corresponding
   body in separate files. An Ada "compilation" (which is a sequence of
   compilation units) is represented using a sequence of files.
   Similarly, you will place each subunit or child unit in a separate
   file.

   The file name is determined by the name of the unit the file contains.
   The name is formed by taking the full expanded name of the unit and
   replacing the separating dots with hyphens and using lower case for
   all letters except that a hyphen in the second character position is
   replaced by a plus sign. The filetype is ADS for a spec and ADB for a
   body.

   Following these rules can result in very long file names if
   corresponding unit names are very long (for example, if child units or
   subunits are heavily nested). An option is available to shorten such
   long file names (called file name "krunching").  Of course, no file
   shortening algorithm can guarantee uniqueness over all possible unit
   names; if file name krunching is used it is your responsibility to
   ensure no name clashes occur.


3  An_Ada_Program

   An Ada program consists of a set of source files, and the first step
   in compiling the program is to generate the corresponding object
   files.  These are generated by compiling a subset of these source
   files.  The files you need to compile are the following:

   o If a package spec has no body, compile the package spec to produce
     the object file for the package.

   o If a package has both a spec and a body, compile the body to produce
     the object file for the package. The source file for the package spec
     need not be compiled in this case since there is only one object
     file, which contains the code for both the spec and body of the
     package.

   o For a subprogram, compile the subprogram body to produce the object
     file for the subprogram. The spec, if one is present, is as usual in
     a separate file, and need not be compiled.

   o In the case of subunits, only compile the parent unit.  A single
     object file is generated for the entire subunit tree, which includes
     all the subunits.

   o Compile child units completely independently from their parent
     units (though, of course, the spec of the parent unit must be
     present).

   o Do not compile Generic units (specs and bodies).

   The preceeding rules describe the set of files that must be compiled
   to generate the object files for a program. Each object file has the
   same name as the corresponding source file, except that the filetype
   is OBJ as usual.

   You may wish to compile other files for the purpose of checking
   syntactic and semantic correctness. For example, in the case where a
   package has a separate spec and body, you would not normally compile
   the spec.  However, it is convenient in practice to compile the spec
   to make sure it is correct before compiling clients ofthis spec, since
   such compilations will fail if there is an error in the spec.

   GNAT provides the option for compiling such files purely for the
   purposes of checking correctness; such compilations are not required
   as part of the process of building a program.


3 File_Dependencies

   A given object file clearly depends on the source file which is
   compiled to produce it. Here we are using "depends" in the sense of
   the UNIX "make" utility; in other words, an object file depends on a
   source file if changes to the source file require the object file to
   be recompiled.

   In addition to this basic dependency, a given object may depend on
   additional source files as follows:

   o If a file being compiled with's a unit "X", the object file depends
     on the file containing the spec of unit "X". This includes files
     that are with'ed implicitly either because they are parents of
     with'ed child units or they are runtime units required by the
     language constructs used in a particular unit.

   o If a file being compiled instantiates a library level generic unit,
     the object file depends on both the spec and body files for this
     generic unit.

   o If a file being compiled instantiates a generic unit defined within
     a package, the object file depends on the body file for the package
     as well as the spec file.

   o If a file being compiled contains a call to a subprogram for which
     pragma Inline applies and inlining is activated with the
     /INLINE qualifier, the object file depends on the file
     containing the body of this subprogram as well as on the file
     containing the spec.

   o The object file for a parent unit depends on the body files for
     all subunits of the parent unit.

   These rules are applied transitively: if unit "A" with's unit "B",
   whose elaboration calls an inlined procedure in package "C", the
   object file for unit "A" will depend on the body of "C", in file
   C.ADB.

   The set of dependent files described by these rules includes all the
   files on which the unit is semantically dependent, as described in the
   Ada 95 Language Reference Manual. However it is larger because of the
   inclusion of generic, inline, and subunit dependencies.

   An object file must be recreated by recompiling the corresponding
   source file if any of the source files on which it depends are
   modified. For example, if the "make" utility is used to control
   compilation, the rule for an Ada object file must mention all the
   source files on which the object file depends.


3  Binding_And_Linking

   When using languages such as C and C++, the only remaining step in
   building an executable program once the source files have been
   compiled is linking the object modules together.  This means it is
   possible to link an inconsistent version of a program in which two
   units have included different versions of the same header.

   The rules in Ada do not permit such an inconsistent program to be
   built.  For example, if two clients have different versions of the
   same package, it is not possible to build a program containing these
   two clients.  These rules are enforced by the GNAT binder, which also
   determines an elaboration order consistent with the Ada rules.

   The GNAT binder is run after all the object files for a program have
   been compiled. It is given the name of the main program unit, and from
   this it determines the set of units required by the program, reading
   the corresponding ALI files. It generates error messages if the
   program is inconsistent or if no valid order of elaboration exists.

   If no errors are detected, the binder produces a main program, in C,
   that contains calls to the required elaboration procedures, followed
   by a call to the main program. This C program is compiled using the
   C compiler included in the GNAT system to generate the object file for
   the main program. The name of the C file is B_xxx.C where "xxx" is the
   name of the main program unit.

   Finally, the linker is used to build the resulting executable program,
   using the object from the main program from the bind step as well as
   the object files for the Ada units of the program.


3  Mixed_Language_Programming

   You build a program that contains some Ada files and some other
   language files in one of two ways, depending on whether the main
   program is in Ada or not.

   If the main program is in Ada, you proceed as follows:
   Compile the Ada units to produce a set of object files and ALI files.

   o Compile the other language files to generate object files.
   o Run the Ada binder on the Ada main program.
   o Compile the Ada main program.
   o Link the Ada main program, Ada objects and other language objects.

   If the main program is in some language other than Ada, you use a
   special option of the binder to generate callable routines to
   initialize and finalize the Ada units. You must insert calls to these
   routines in the main program, or some other appropriate point.  The
   call to initialize the Ada units must occur before the first Ada
   subprogram is called, and the call to finalize the Ada units must
   occur after the last Ada subprogram returns. You use the same
   procedure for building the program as described previously.  In this
   case, however, the binder places the initialization and finalization
   subprograms into file B_xxx.C instead of the main program.


3  C_Model_Comparison

   The GNAT model of compilation is close to the C and C++ models. You
   can think of Ada specs as corresponding to header files in C. As in C,
   you don't need to compile specs; they are compiled when they are used.
   The Ada "with" is similar in effect to the "#include" of a C header.

   One notable difference is that, in Ada, you may compile specs
   separately to check them for semantic and syntactic accuracy. This is
   not always possible with C headers because they are fragments of
   programs that have no specific syntactic or semantic rules.

   The other major difference is the requirement for running the binder,
   which performs two important functions. First, it checks for
   consistency. In C or C++, the only defense against putting together
   inconsistent programs is outside the compiler, in a make file, for
   example. The binder satisfies the Ada requirement that it be
   impossible to construct an inconsistent program when the compiler is
   used in normal mode.

   The other important function of the binder is to deal with elaboration
   issues. There are also elaboration issues in C++ that are handled
   automatically.  This automatic handling has the advantage of being
   simpler to use, but the C++ programmer has no control over
   elaboration.  Where GNAT BIND might complain there was no valid order
   of elaboration, a C++ compiler would simply construct a program that
   malfunctioned at runtime.


3  Traditional_Ada_Model_Comparison

   This entry is intended to be useful to Ada programmers who have
   previously used an Ada compiler (such as DEC Ada) implementing the
   traditional Ada library model, as described in the Ada 95 Languages
   Reference Manual.  If you have not used such a system, you need not
   read this entry.

   In GNAT, there no "library" in the normal sense. Instead, the set of
   source files themselves acts as the library. Compiling Ada programs
   does not generate any centralized information, but rather an object
   file and a ALI file, which are of interest only to the binder and
   linker.

   In a traditional system, the compiler reads information not only from
   the source file being compiled, but also from the centralized library.
   This means that the effect of a compilation depends on what has been
   previously compiled. In particular:

   o When a unit is with'ed, the unit seen by the compiler corresponds
     to the version of the unit most recently compiled into the library.

   o Inlining is effective only if the necessary body has already been
     compiled into the library.

   o Compiling a unit may obsolete other units in the library.

   In GNAT, compiling one unit never affects the compilation of any other
   units since the compiler reads only source files. Only changes to
   source files can affect the results of a compilation. In particular:

   o When a unit is with'ed, the unit seen by the compiler corresponds
     to the source version of the unit that is currently accessible to
     the compiler.

   o Inlining requires the appropriate source files for the package or
     subprogram bodies to be available to the compiler. Inlining is
     always effective, independent of the order in which units are
     complied.

   o Compiling a unit never affects any other compilations. The editing
     of sources may cause previous compilations to be out of date if
     they depended on the source file being modified.

   The important result of these differences are that order of
   compilation is never significant in GNAT. There is no situation in
   which you are required to do one compilation before another. What
   shows up as order of compilation requirements in the traditional Ada
   library becomes, in GNAT, simple source dependencies; in other words,
   it shows up as a set of rules saying what source files must be present
   when a file is compiled.


2  Language_Topics

   For more information, refer to the GNAT Reference Manual.


2  BIND

   Invoke the GNAT binder.

   Format:

     GNAT BIND [main-program-ALI file]

     GNAT BIND /NOMAIN [ALI file1] [ALI file2] ...


3  Overview

   The GNAT BIND command performs four separate functions:

   o Checks that a program is consistent, in accordance with the rules in
     chapter 10 of the Ada Language Reference Manual. In particular, error
     messages are generated if a program uses inconsistent versions of a
     given unit.

   o Checks that an acceptable order of elaboration exists for the program
     and issues an error message if it cannot find an order of elaboration
     satisfying the rules in Chapter 10 of the Ada Language Reference
     Manual.

   o Generates a main program incorporating the given elaboration order.
     This program is a small C source file that must be subsequently
     compiled using the C compiler. The two most important functions of
     this program are to call the elaboration routines of units in an
     appropriate order and to call the main program.

   o Determines the set of object files required by the given main
     program.  This information is output as comments in the generated
     C program, to be read by the GNAT LINK command used to link the
     Ada application.


3  Parameters

    Specify the filename of the main program either without any filetype
    or with a filetype or ALI or else a list of similar filenames if
    there is no main program (specify /NOMAIN in that case).


>>>Qualifiers
3  Examples

   $ GNATBIND HELLO.ALI

	The main program "Hello" (source program in HELLO.ADB) is bound using
	the standard switch settings. The generated main program is
	B_HELLO.C. This is the normal, default use of the binder.

   $ GNATBIND MAIN_PROGRAM.ALI /OUTPUT=MAINPROG.C /READ_SOURCES=NONE -
       /ELABORATION_DEPENDENCIES

	The main program "Main_Program" (source program in MAIN_PROGRAM.ADB_
	is bound, excluding source files from the consistency checking. A full
	list of elaboration dependencies is output to SYS$OUTPUT, and the file
	MAINPROG.C is generated.

   $ GNATBIND /NOMAIN MATH.ALI DBASE.ALI /OUTPUT=ADA-CONTROL.C

	The main program is in a language other than Ada, but calls to
	subprograms in packages "Math" and "Dbase" appear. This command
	generates the file ADA-CONTROL.C containing the "adainit" and
	"adafinal" routines to be called before and after accessing the Ada
	subprograms.


2  CHOP

   Split a single file into multiple files, one per unit.

   Format:

     GNAT CHOP input-filename [output-directory]


3  Overview

   The basic compilation model of GNAT requires a file submitted to the
   compiler have only one unit and there must be a strict correspondence
   between the file name and the unit name.

   The GNAT CHOP utility allows both of these rules to be relaxed,
   allowing GNAT to process files which contain multiple compilation
   units and files with arbitrary file names. The approach used by GNAT
   CHOP is to read the specified file and generate one or more output
   files, containing one unit per file and with proper file names as
   required by GNAT.

   If you want to permanently restructure a set of "foreign" files so
   that they match the GNAT rules and do the remaining development using
   the GNAT structure, you can simply use GNAT CHOP once, generate the
   new set of files and work with them from that point on.

   Alternatively, if you want to keep your files in the "foreign" format,
   perhaps to maintain compatibility with some other Ada compilation
   system, you can set up a procedure where you use GNAT CHOP each time
   you compile, regarding the source files that it writes as temporary
   files that you throw away.

   Note that COMPILE qualifiers are also allowed.


3  Parameters

input-filename

   The file name of the file to be chopped.  There are no restrictions on
   the form of this file name.  The file itself contains one or more Ada
   files, in normal GNAT format, concatenated together.


output-directory

   An optional directory name, which specifies where the chopped files
   are to be placed.


>>>Qualifiers
3  Examples

   $ GNAT CHOP /OVERWRITE HELLO_S.ADA DISK$GNAT:[ICHIBIAH.FILES]

	Chops the source file HELLO_S.ADA. The output files will be placed in
	the directory DISK$GNAT:[ICHBIAH.FILES], overwriting any files with
	matching names in that directory (no files in the current directory
	are modified).

   $ GNAT CHOP /REFERENCE COLLECT.

	Chops the source file COLLECT into the current directory. All output
        files have "Source_Reference" pragmas, so error messages will refer
        back to the file COLLECT. with proper line numbers.

   $ GNAT CHOP ARCHIVE.

	Chops the source file ARCHIVE. into the current directory.  One useful
	application of GNAT CHOP is in sending sets of sources around, for
	example in email messages. The required sources are simply
	concatenated (for example, using the APPEND /NEW command), and then
        GNAT CHOP is used at the other end to reconstitute the original
        file names.


2  COMPILE

   Invoke the GNAT compiler to compile an Ada program.

   Format:

     GNAT COMPILE input-file


3  Parameters

input-file

   The name of the file containing the Ada source program to be compiled.


>>>Qualifiers
2  FIND

   The compiler generates cross-referencing information, which is saved in
   the .ALI files. This information indicates where in the source each
   entity is declared and referenced.

   The tools XREF and FIND take advantage of this information to provide the
   user with the capability to easily locate the declaration and references
   to an entity. These tools are quite similar, the difference being that
   FIND is intended for locating definitions and/or references to a
   specified entity or entities, whereas XREF is oriented to generating a
   full report of all cross-references.


3  Parameters

pattern[:sourcefile[:line[:column]]]

   An entity will be output only if it matches the regular expression
   found in pattern.

   Omitting the pattern is equivalent to specifying *, which will match
   any entity. Note that if you do not provide a pattern, you have to
   provide both a sourcefile and a line.

   Entity names are given in Latin-1, with upper-lower case equivalence
   for matching purposes. At the current time there is no support for
   8-bit codes other than Latin-1, or for wide characters in identifiers.

   sourcefile:

   FIND will look for references, bodies or declarations of symbols
   referenced in sourcefile, at the specified line and at the specified
   column.

   line:

   A decimal integer identifying the line number containing the reference
   to the entity (or entities) to be located.

   column:

   A decimal integer identifying the exact location on the line of the
   first character of the identifier for the entity reference. Columns
   are numbered from 1.


filespec[,...]

   The search will be restricted to these files. If none are given, then
   the search will be done for every library file in the search path.
   These file must appear only after the pattern or sourcefile.


>>>Qualifiers
2  KRUNCH

   Used to determine the krunched name for a given file, when krunched
   to a specified maximum length.


3  Parameters

file

   Filename to be krunched.


>>>Qualifiers
2  LINK

   Link an Ada program by invoking the system linker with a correct list
   of object files and library references.  GNAT LINK automatically
   determines the list of files and references for the Ada part of a
   program. It uses the binder file generated by the binder to determine
   this list.

   Format:

     GNAT LINK mainprog-file [extra-objects]


3  Parameters

ali-file

   MAINPROG.ALI references the ALI file of the main program.  The ALI
   filetype of this file can be omitted. From this reference, GNAT LINK
   locates the corresponding binder file (B_MAINPROG.C) and, using the
   information in this file along with the list of non-Ada objects and
   linker options, constructs a LINK command file to create the
   executable.


extra-objects-and-libraries-and-shareables-and-options

   These parameters are passed to the linker uninterpreted. They
   typically include the names of object files for units written in other
   languages than Ada and any library references required to resolve
   references in any of these foreign language units, or in "pragma
   Import" statements in any Ada units.

   GNAT LINK determines the list of objects required by the Ada program
   and prepends them to the list of objects passed to the linker.  GNAT
   LINK also gathers any arguments set by the use of "pragma
   Linker_Options" and adds them to the list of arguments presented to
   the linker.


>>>Qualifiers
2  LIST

   Utility that displays information about compiled units, including
   dependencies on the correspondings sources files, and consistency of
   compilations.


3  Parameters

object_or_ali_file

   File to be browsed.


>>>Qualifiers
2  MAKE

   As you work on a program, you keep track of which units you modify and
   make sure you not only recompile these units, but also any units that
   depend on units you have modified.

   The GNAT MAKE command takes care of these details automatically.

   Format:
     GNAT MAKE main-file


3  Overview

   A typical development cycle when working on an Ada program consists of
   the following steps:

   Edit some sources to fix bugs.

   o Add enhancements.
   o Compile all sources affected.
   o Rebind and relink.
   o Test.

   The third step can be tricky, because not only do the modified files
   have to be compiled, but any files depending on these files must also
   be recompiled. The dependency rules in Ada can be quite complex,
   especially in the presence of overloading, "use" clauses, generics
   and inlined subprograms.

   GNAT MAKE automatically takes care of the third and fourth steps of
   this process. It determines which sources need to be compiled,
   compiles them, and binds and links the resulting object files.

   Unlike some other Ada make programs, the dependencies are always
   accurately recomputed from the new sources. The source based approach
   of the GNAT compilation model makes this possible. This means that if
   changes to the source program cause corresponding changes in
   dependencies, they will always be tracked exactly correctly by GNAT
   MAKE.


3  Parameters

main-file

   The compilation unit that is the main program. There are two ways to
   specify this:

   o By giving the name of the compilation unit.  In this case GNAT MAKE
     will use the /SOURCE_SEARCH and /SEARCH qualifiers to locate the
     appropriate file.

   o By giving the name of the source containing it.  If no relative or
     absolute directory is specified, the input source file will be
     searched for in the directory where GNAT MAKE was invoked.  GNAT
     MAKE will not use the /SOURCE_SEARCH and /SEARCH qualifiers to
     locate the appropriate file.


>>>Qualifiers
3  Notes

   Please note the following:

   o If you enter "$ GNAT MAKE file.ADB", where file.ADB is a subunit or
     body of a generic unit, GNAT MAKE recompiles file.ADB (because it
     finds no ALI) and stops, issuing a warning.

   o GNAT MAKE does not examine OBJ files, only ALI files.  Deleting OBJ
     files will not force a recompile. You can force everything to be
     recompiled either by deleting the ALI files or by using the
     /FORCE_COMPILE qualifier.

   o If GNAT MAKE finds no ALI files, it recompiles the main program and
     all other units required by the main program. Thus GNAT MAKE can be
     used for the initial compile, as well as during the re-edit
     development cycle.


3  How_It_Works

   Generally GNAT MAKE automatically performs all necessary
   recompilations and you don't need to worry about how it works.
   However, it may be useful to have some basic understanding of the GNAT
   MAKE approach and in particular to understand how it uses the results
   of previous compilations without incorrectly depending on them.

   First a definition: an object file is considered "up to date" if the
   corresponding ALI file exists and if all the source files listed in
   the dependency section of this ALI file have time stamps matching
   those in the ALI file. This means that neither the source file itself
   nor any files that it depends on have been modified, and hence there
   is no need to recompile this file.

   GNAT MAKE works by first checking if the specified main program is up
   to date. If so, it is done, and no compilations are required. If not,
   it compiles the main program to build a new ALI file that reflects the
   latest sources. It examines this ALI file to find all the source files
   on which the main program depends, and recursively applies the
   up-to-date test on all these files.

   This process ensures that GNAT MAKE only trusts the dependencies in an
   existing ALI file if they are known to be correct.  Otherwise it
   always recompiles to determine a new, guaranteed accurate set of
   dependencies. Thus the program is compiled "upside down" from what may
   be more familiar as the required order of compilation in some other
   Ada systems. In particular, clients are compiled before the units on
   which they depend. The ability of GNAT to compile in any order is
   critical in allowing an order of compilation to be chosen that
   guarantees that GNAT MAKE will recompute a correct set of new
   dependencies if necessary.


3  Examples

	$ GNAT MAKE HELLO.ADB

   Compile all files necessary to bind and link the main program
   HELLO.ADB (containing unit "Hello") and bind and link the resulting
   object files to generate an executable file HELLO.EXE.

	$ GNAT MAKE /QUIT Main_Unit -
	    /COMPILER_SWITCHES /OPTIMIZE=ALL -
	    /BINDER_SWITCHES /ORDER_OF_ELABORATION

   Compile all files necessary to bind and link the main program unit
   "Main_Unit" (from file MAIN_UNIT.ADB). All compilations will be done
   with all optimizations and the order of elaboration will be listed by
   the binder. GNAT MAKE will operate in quiet mode, not displaying
   commands it is executing.


2  PREPROCESS

   This program provides a simple preprocessing capability for Ada
   programs.  It is designed for use with GNAT, but is not dependent on
   any special features of GNAT.

   Format:
      GNAT PREPROCESS input-file output-file def-file


3  Parameters

infile-file

   The name of the input file, which is an Ada source file containing
   preprocessor directives.  See "Input_Format" for the format of
   this file.


output-file

   The name of the output file, which is an Ada source in standard Ada
   form. When used with GNAT, this file name will normally have an ADS or
   ADB filetype.


def-file

   The name of a text file containing definitions of
   symbols to be referenced by the preprocessor.

   It contains lines of the form

     symbol := value

   where 'symbol' is an identifier, following normal Ada
   (case-insensitive) rules for its syntax, and 'value' is one of
   the following:

   o Empty, corresponding to a null substitution.

   o A string literal using normal Ada syntax.

   o Any sequence of characters from the set (letters, digits, period,
     underline).

   Comment lines may also appear in the definitions file, starting with
   the usual --, and comments may be added to the definitions lines.


3  Input_Format

   The input text may contain preprocessor conditional inclusion lines,
   and also general symbol substitution sequences.

   The preprocessor conditional inclusion commands have the form

    #if [not] symbol [then]
       lines
    #elsif [not] symbol [then]
       lines
    #elsif [not] symbol [then]
       lines
    ...
    #else
       lines
    #end if;

   For these Boolean tests, the symbol must have either the value True or
   False. If the value is True, then the corresponding lines are included,
   and if the value is False, they are excluded. It is an error to
   reference a symbol not defined in the symbol definitions file, or
   to reference a symbol that has a value other than True or False.

   The use of the not operator inverts the sense of this logical test, so
   that the lines are included only if the symbol is not defined.

   The THEN keyword is optional as shown

   The # must be in column one, but otherwise the format is free form.
   Spaces or tabs may appear between the # and the keyword. The keywords
   and the symbols are case insensitive as in normal Ada code. Comments
   may be used on a preprocessor line, but other than that, no other
   tokens may appear on a preprocessor line.

   Any number of #elsif clauses can be present, including none at all.

   The #else is optional, as in Ada.

   Symbol substitution is obtained by using the sequence

   $symbol

   anywhere within a source line, except in a comment. The identifier
   following the $ must match one of the symbols defined in the symbol
   definition file, and the result is to substitute the value of the
   symbol in place of $symbol in the output file.


>>>Qualifiers
2  PRETTY

   The GNAT pretty-printer. GNAT PRETTY takes a compilable Ada source as input
   and generates the reformatted version of the source as output. Different
   formatting styles can be specified by means of qualifiers.

   As a part of its processing, GNAT PRETTY has to compile the argument source.
   Therefore, only legal Ada sources can be reformatted by GNAT PRETTY.
   Moreover, if the argument source depends semantically upon units located
   outside the current directory, the corresponding search path should be
   provided by appropriate qualifiers.


3  Parameters

filename

   The name of the source file to reformat. May contain directory information.

   By default GNAT PRETTY puts the formatted source into the file which name
   is obtained by appending the '.PP' suffix to the name of the argument file
   (if the file with this name already exists, it is unconditionally
    overridden). The output can be directed to a specific file or to the
   standard output, using proper qualifiers. All diagnostic information is
   sent to the standard error.

   GNAT PRETTY needs the tree file created for the argument source file. If
   possible, it reuses the existing tree file, otherwise it creates it by
   compiling the argument source (that is why GNAT PRETTY may need /SEARCH
   qualifiers to define the source search path for this compilation).
   If GNAT PRETTY creates the tree file, it removes it at the end if its run.
   If the ALI file was created together with the tree file, it is also removed,
   but if the ALI file existed before creation the tree file and is it was not
   overridden as a part of creating the tree, GNAT PRETTY does not remove this
   ALI file.

>>>Qualifiers
2  SHARED

   Link a shareable image library by invoking the system linker with a
   correct list of object files and library references.

   Format:

     GNAT SHARED /IMAGE=new_shared_library object1 object2 ...


3  Parameters

objects-and-libraries-and-shareables-and-options

   These parameters are passed to the linker uninterpreted. They
   typically include the names of object files for units written in other
   languages than Ada and any library references required to resolve
   references in any of these foreign language units, or in "pragma
   Import" statements in any Ada units.

   Wildcard file specifications are expanded.


>>>Qualifiers
2  STUB

   Creates body stubs, that is, empty but compilable bodies for library unit
   declarations.

   To create a body stub, the tool STUB has to compile the library unit
   declaration. Therefore, bodies can be created only for legal library units.
   Moreover, if a library unit depends semantically upon units located outside
   the current directory, the source search path needs to be provided.

   Format:
      GNAT STUB [qualifiers] filespec [directory]


3  Parameters

filespec

   The name of the source file that contains a library unit declaration for
   which a body must be created. The file spec may contain the path
   information. The file spec does not have to follow the GNAT file name
   conventions. If the file spec does not follow GNAT file naming conventions,
   the name of the body file must be provided explicitly as the value of
   qualifier /OUTPUT. If the file spec follows the GNAT file naming conventions
   and no qualifier /OUTPUT is provided, the name of the created body file is
   deducted from the argument file spec by replacing the `.ADS' suffix with
   the `.ADB' suffix.

[directory]

   Indicates the directory in which the body stub is to be placed
   (the default is the current default directory).


>>>Qualifiers
2  XREF

   The compiler generates cross-referencing information, which is saved in
   the .ALI files. This information indicates where in the source each
   entity is declared and referenced.

   The tools XREF and FIND take advantage of this information to provide the
   user with the capability to easily locate the declaration and references
   to an entity. These tools are quite similar, the difference being that
   FIND is intended for locating definitions and/or references to a
   specified entity or entities, whereas XREF is oriented to generating a
   full report of all cross-references.


3  Parameters

filespec[,...]

   The search will be restricted to these files. If none are given, then
   the search will be done for every library file in the search path.
   These file must appear only after the pattern or sourcefile.


>>>Qualifiers
