2009-03-26  Douglas B Rupp  <rupp@adacore.com>

	* config/alpha/vms.h (LINK_SPEC): Handle -gdwarf-2.

2009-02-22  Douglas B Rupp  <rupp@adacore.com>

	* config/vms/vms-crtl.h (CRTL_NAMES): Add translation for recvmsg
	and sengmsg.
	* config/vms/vms-crtl-64.h (CRTL_NAMES): Fix translation for recmsg
	and sendmsg.

2008-08-14  Tristan Gingold  <gingold@adacore.com>

	* Makefile.in: Remove emutls.c from libgcc.

(Do not submit : ugly work-around ivms linker bug)

2008-07-19  Douglas B Rupp  <rupp@adacore.com>

	* config/ia64/vms_symvec_libgcc_s.opt (_Unwind_GetIPInfo): Add entry

2008-06-23  Douglas B Rupp  <rupp@adacore.com>

	* config/vms/vms.opt: Allow -mno-malloc64
	* doc/invoke.texi: Document -mno-malloc64.

2008-05-26  Douglas B Rupp  <rupp@adacore.com>

	* config/alpha/vms.h (ASM_SPEC): Add -source-listing switch
	* config/ia64/vms.h (ASM_SPEC): Likewise

(To be submitted [vms])

2008-03-20  Olivier Hainque  <hainque@adacore.com>

	* config/alpha/vms.h (MALLOC_ALIGNMENT): Refine to account
	for TARGET_MALLOC64.

(To be submitted [vms])
	
2008-03-13  Douglas B Rupp  <rupp@gnat.com>

	* config/ia64/ia64.c (ia64_start_function):
	Call new function dwarf2out_vms_debug_main_pointer.
	* dwarf2out.c (dwarf2_debug_hooks): Enable dwarf2out_end_prologue.
	(vms_debug_main_subr_die): New static variable.
	(dwarf2out_vms_debug_main_pointer): New function.
	(output_comp_die): Put vms_debug_main_subr_die first.

(To be submitted [vms])

2008-03-02  Douglas B Rupp  <rupp@gnat.com>

	* config/alpha/vms64.h (TARGET_OS_CPP_BUILTINS): Default __LONG_POINTERS=1
	(TARGET_DEFAULT): Default MASK_MALLOC64 set.
	* config/ia64/vms64.h: Likewise

(To be submitted [vms])

2008-02-22  Douglas B Rupp  <rupp@gnat.com>

	* config/ia64/vms.h (TARGET_DEFAULT): Set MASK_DWARF2_ASM

(To be submitted [vms])

2008-02-11  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/ia64.c (ia64_attribute_table): Add "common_object"
	entry.
	(SECTION_VMS_OVERLAY): Define.
	(ia64_vms_common_object_attribute): Added.  Handle the "common_object"
	attribute.
	(ia64_vms_elf_asm_named_section): Added.  Generate .section pseudo-op
	for common_object.
	(ia64_vms_output_aligned_decl_common): Added.  Generate pseudo-op for
	common_object declarations.
	(ia64_vms_initialize_trampoline): Comment (is unused).
	(ia64_section_type_flags): Set section flag for common_object.

	* config/ia64/ia64-protos.h: Add prototype for 
	ia64_vms_initialize_trampoline.
	* config/ia64/vms.h (ASM_OUTPUT_ALIGNED_DECL_COMMON): Define.
	(TARGET_ASM_NAMED_SECTION): Define.

(To be submitted [vms])

2008-02-07  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/vms.h: Define 
	DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET

(To be submitted [vms])

2008-02-07  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/ia64.c (ia64_function_arg_offset): Always returns 0
	when TARGET_ABI_OPEN_VMS.
	(ia64_function_arg): Fix OpenVMS ABI issues for varargs.
	(ia64_function_arg_advance): Likewise.

(To be submitted [vms])

2008-01-30  Olivier Hainque  <hainque@adacore.com>

	* config/ia64/ia64.c (ia64_function_arg): For OpenVMS, emit the
	Argument Information register set in the incoming/sibcall case as
	well.

(To be submitted [vms])

2008-01-29  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/vms.h: Set MAX_OFILE_ALIGNMENT.

(To be submitted [vms])

2008-01-22  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/vms_symvec_libgcc_s.opt: Adjust list of exported
	symbols.

(To be submitted [ia64-vms])

2008-01-21  Olivier Hainque  <hainque@adacore.com>

	* config/ia64/ia64.h (LONG_DOUBLE_TYPE_SIZE): Force to 64 on VMS.
	(LIBCGC2_LONG_DOUBLE_TYPE_SIZE): Likewise.

(To be submitted [ia64-vms])

2008-01-17  Tristan Gingold  <gingold@adacore.com>

	* config/alpha/alpha.md (allocate_stack): Avoid wrap-around 0 issue
	by comparing size.

(To be submitted [alpha-vms])

2008-01-17  Tristan Gingold  <gingold@adacore.com>

	* cgraph.c (decl_assembler_name_equal): Return false if the declaration
	has no assembler name.

(To be submitted [vms])

2008-01-16  Tristan Gingold  <gingold@adacore.com>

	* libcpp/configure.ac: Define TARGET_OBJECT_SUFFIX.  Set to ".obj" on
	VMS targets.
	* libcpp/config.in: Regenerate

(To be submitted [vms])

2008-01-11  Olivier Hainque  <hainque@adacore.com>

	* config/alpha/vms.h (MALLOC_ALIGNMENT): Define.

(To be submitted [vms])

2008-01-09  Olivier Hainque  <hainque@adacore.com>

	* alpha.c (alpha_sa_size): Force procedure type to PT_STACK when
	frame_pointer_needed on OpenVMS.

(To be submitted [vms])

2008-01-09  Olivier Hainque  <hainque@adacore.com>

	* config/alpha/alpha.c (alpha_pv_save_sive, alpha_using_fp): Remove.
	(alpha_vms_can_eliminate): New function. Support for CAN_ELIMINATE
	with proper processing for PT_NULL.
	(alpha_vms_initial_elimination_offset): New function. Support for
	INITIAL_ELIMINATION_OFFSET with proper processing for PT_NULL.
	* config/alpha/alpha-protos.h (alpha_pv_save_size): Remove prototype.
	(alpha_using_fp): Likewise.
	(alpha_vms_can_eliminate): Add prototype.
	(alpha_vms_initial_elimination_offset): Likewise.
	* config/alpha/vms.h (CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET):
	Call alpha_vms_can_eliminate and alpha_vms_initial_elimination_offset.

(To be submitted [vms])

2007-12-18  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/vms-ehfb.h: Define MD_FALLBACK_FRAME_STATE_FOR,
	renames md_fallback_frame_state_for to ia64_vms_fallback_frame_state.
	Fix return status.
	* config/alpha/vms-ehfb.h: Fix return status.

(To be submitted [vms])

2007-12-17  Tristan Gingold  <gingold@adacore.com>

	* config/ia64/vms-ehfb.h: Define MD_FALLBACK_FRAME_STATE_FOR,
	renames md_fallback_frame_state_for to ia64_vms_fallback_frame_state.
	* config/ia64/vms.h: Define MD_UNWIND_SUPPORT.

(To be submitted [vms])

2007-12-14  Tristan Gingold  <gingold@adacore.com>

	* config/alpha/vms-ehfb.h: Define MD_FALLBACK_FRAME_STATE_FOR,
	renames md_fallback_frame_state_for to alpha_vms_fallback_frame_state.
	* config/alpha/vms.h: Define MD_UNWIND_SUPPORT.

(To be submitted [vms])

2007-12-14  Tristan Gingold  <gingold@adacore.com>

	* varasm.c (finish_aliases_1): Allow aliases whose target is a number.

(To be submitted [vms])

--- config/depstand.m4.0	2005-11-19 10:43:18.000000000 -0800
+++ config/depstand.m4	2007-12-04 15:14:14.000000000 -0800
@@ -40,11 +40,11 @@ AC_CACHE_CHECK([dependency style of $dep
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -108,7 +108,7 @@ AC_CACHE_CHECK([dependency style of $dep
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_$1_dependencies_compiler_type=none
 fi
--- configure.0	2007-12-04 15:25:15.000000000 -0800
+++ configure	2007-12-04 15:14:14.000000000 -0800
@@ -533,8 +533,34 @@ ac_compile='${CC-cc} -c $CFLAGS $CPPFLAG
 ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
-ac_exeext=
-ac_objext=o
+ac_build_exeext=
+ac_build_objext=o
+ac_host_exeext=
+ac_host_objext=o
+ac_target_exeext=
+ac_target_objext=o
+
+case "${build}" in
+*-*-*vms*)
+  ac_build_exeext=.exe
+  ac_build_objext=obj
+  ;;
+esac
+
+case "${host}" in
+*-*-*vms*)
+  ac_host_exeext=.exe
+  ac_host_objext=obj
+  ;;
+esac
+
+case "${target}" in
+*-*-*vms*)
+  ac_target_exeext=.exe
+  ac_target_objext=obj
+  ;;
+esac
+
 if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
@@ -1946,7 +1972,7 @@ ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+ac_link='${CC-cc} -o conftest${ac_target_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
@@ -1956,7 +1982,7 @@ cat > conftest.$ac_ext << EOF
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1954: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1954: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_target_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1974,7 +2000,7 @@ ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+ac_link='${CC-cc} -o conftest${ac_target_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
@@ -2093,7 +2119,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_GNATBIND="${ac_tool_prefix}gnatbind"
       break
     fi
@@ -2164,7 +2190,7 @@ acx_cv_cc_gcc_supports_ada=no
 # given a .adb file, but produce no object file.  So we must check
 # if an object file was really produced to guard against this.
 errors=`(${CC} -c conftest.adb) 2>&1 || echo failure`
-if test x"$errors" = x && test -f conftest.$ac_objext; then
+if test x"$errors" = x && test -f conftest.$ac_host_objext; then
   acx_cv_cc_gcc_supports_ada=yes
 fi
 rm -f conftest.*
@@ -2322,7 +2348,7 @@ int main() {
 mpfr_t n; mpfr_init(n);
 ; return 0; }
 EOF
-if { (eval echo configure:2320: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2320: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_target_exeext}; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 else
@@ -2407,7 +2433,6 @@ if test -d ${srcdir}/gcc; then
   new_enable_languages=c
   missing_languages=`echo ",$enable_languages," | sed -e s/,all,/,/ -e s/,c,/,/ `
   potential_languages=c
-
   for lang_frag in ${srcdir}/gcc/*/config-lang.in .. ; do
     case ${lang_frag} in
       ..) ;;
@@ -3332,7 +3357,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_YACC="$ac_prog"
       break
     fi
@@ -3372,7 +3397,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_BISON="$ac_prog"
       break
     fi
@@ -3411,7 +3436,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_M4="$ac_prog"
       break
     fi
@@ -3450,7 +3475,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_LEX="$ac_prog"
       break
     fi
@@ -3490,7 +3515,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_FLEX="$ac_prog"
       break
     fi
@@ -3529,7 +3554,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_MAKEINFO="$ac_prog"
       break
     fi
@@ -3582,7 +3607,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_EXPECT="$ac_prog"
       break
     fi
@@ -3623,7 +3648,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_RUNTEST="$ac_prog"
       break
     fi
@@ -3671,7 +3696,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_AR="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -3702,7 +3727,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_AR="${ncn_progname}"
       break
     fi
@@ -3746,7 +3771,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_AS="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -3777,7 +3802,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_AS="${ncn_progname}"
       break
     fi
@@ -3821,7 +3846,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_DLLTOOL="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -3852,7 +3877,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_DLLTOOL="${ncn_progname}"
       break
     fi
@@ -3896,7 +3921,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_LD="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -3927,7 +3952,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_LD="${ncn_progname}"
       break
     fi
@@ -3971,7 +3996,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_LIPO="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4002,7 +4027,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_LIPO="${ncn_progname}"
       break
     fi
@@ -4046,7 +4071,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_NM="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4077,7 +4102,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_NM="${ncn_progname}"
       break
     fi
@@ -4121,7 +4146,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_RANLIB="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4152,7 +4177,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_RANLIB="${ncn_progname}"
       break
     fi
@@ -4191,7 +4216,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_STRIP="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4222,7 +4247,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_STRIP="${ncn_progname}"
       break
     fi
@@ -4261,7 +4286,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_WINDRES="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4292,7 +4317,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_WINDRES="${ncn_progname}"
       break
     fi
@@ -4336,7 +4361,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_OBJCOPY="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4367,7 +4392,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_OBJCOPY="${ncn_progname}"
       break
     fi
@@ -4411,7 +4436,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_OBJDUMP="${ncn_tool_prefix}${ncn_progname}"
       break
     fi
@@ -4442,7 +4467,7 @@ else
   ac_dummy="$PATH"
   for ac_dir in $ac_dummy; do
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
+    if test -f $ac_dir/$ac_word${ac_build_exeext}; then
       ac_cv_prog_OBJDUMP="${ncn_progname}"
       break
     fi
--- fixincludes/configure.0	2005-11-19 10:47:21.000000000 -0800
+++ fixincludes/configure	2007-12-04 15:14:14.000000000 -0800
@@ -251,7 +251,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -309,7 +309,7 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT WARN_CFLAGS WARN_PEDANTIC WERROR target_noncanonical TARGET CPP EGREP MAINT LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT NO_MINUS_C_MINUS_O OUTPUT_OPTION WARN_CFLAGS WARN_PEDANTIC WERROR target_noncanonical TARGET CPP EGREP MAINT LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -2353,6 +2353,105 @@ ac_link='$CC -o conftest$ac_exeext $CFLA
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
+if test "x$CC" != xcc; then
+  echo "$as_me:$LINENO: checking whether $CC and cc understand -c and -o together" >&5
+echo $ECHO_N "checking whether $CC and cc understand -c and -o together... $ECHO_C" >&6
+else
+  echo "$as_me:$LINENO: checking whether cc understands -c and -o together" >&5
+echo $ECHO_N "checking whether cc understands -c and -o together... $ECHO_C" >&6
+fi
+set dummy $CC; ac_cc=`echo $2 |
+		      sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
+if eval "test \"\${ac_cv_prog_cc_${ac_cc}_c_o+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+# Make sure it works both with $CC and with simple cc.
+# We do the test twice because some compilers refuse to overwrite an
+# existing .o file with -o, though they will create one.
+ac_try='$CC -c conftest.$ac_ext -o conftest.$ac_objext >&5'
+if { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+   test -f conftest.$ac_objext && { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); };
+then
+  eval ac_cv_prog_cc_${ac_cc}_c_o=yes
+  if test "x$CC" != xcc; then
+    # Test first that cc exists at all.
+    if { ac_try='cc -c conftest.$ac_ext >&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+      ac_try='cc -c conftest.$ac_ext -o conftest.$ac_objext >&5'
+      if { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 test -f conftest.$ac_objext && { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); };
+      then
+	# cc works too.
+	:
+      else
+	# cc exists but doesn't like -o.
+	eval ac_cv_prog_cc_${ac_cc}_c_o=no
+      fi
+    fi
+  fi
+else
+  eval ac_cv_prog_cc_${ac_cc}_c_o=no
+fi
+rm -f conftest*
+
+fi
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define NO_MINUS_C_MINUS_O 1
+_ACEOF
+
+fi
+
+# autoconf is lame and doesn't give us any substitution variable for this.
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
+  NO_MINUS_C_MINUS_O=yes
+else
+  OUTPUT_OPTION='-o $@'
+fi
+
+
+
 # Figure out what compiler warnings we can enable.
 # See config/warnings.m4 for details.
 
@@ -5246,7 +5345,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
@@ -5793,6 +5892,8 @@ s,@CPPFLAGS@,$CPPFLAGS,;t t
 s,@ac_ct_CC@,$ac_ct_CC,;t t
 s,@EXEEXT@,$EXEEXT,;t t
 s,@OBJEXT@,$OBJEXT,;t t
+s,@NO_MINUS_C_MINUS_O@,$NO_MINUS_C_MINUS_O,;t t
+s,@OUTPUT_OPTION@,$OUTPUT_OPTION,;t t
 s,@WARN_CFLAGS@,$WARN_CFLAGS,;t t
 s,@WARN_PEDANTIC@,$WARN_PEDANTIC,;t t
 s,@WERROR@,$WERROR,;t t
--- fixincludes/configure.ac.0	2005-11-19 10:47:21.000000000 -0800
+++ fixincludes/configure.ac	2007-12-04 15:14:14.000000000 -0800
@@ -6,6 +6,16 @@ AC_CONFIG_AUX_DIR(..)
 AC_CANONICAL_SYSTEM
 AC_PROG_CC
 
+AC_PROG_CC_C_O
+# autoconf is lame and doesn't give us any substitution variable for this.
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
+  NO_MINUS_C_MINUS_O=yes
+else
+  OUTPUT_OPTION='-o $@'
+fi
+AC_SUBST(NO_MINUS_C_MINUS_O)
+AC_SUBST(OUTPUT_OPTION)
+
 # Figure out what compiler warnings we can enable.
 # See config/warnings.m4 for details.
 
--- fixincludes/Makefile.in.0	2005-11-19 10:47:21.000000000 -0800
+++ fixincludes/Makefile.in	2007-12-04 15:14:14.000000000 -0800
@@ -27,6 +27,9 @@ SHELL=@SHELL@
 # in the kernel.  So, we use `echo' instead. 
 STAMP = echo timestamp >
 
+# Some compilers can't handle cc -c blah.c -o foo/blah.o.
+OUTPUT_OPTION = @OUTPUT_OPTION@
+
 CC = @CC@
 CFLAGS = @CFLAGS@
 WARN_CFLAGS = @WARN_CFLAGS@ @WARN_PEDANTIC@ @WERROR@
@@ -69,7 +72,7 @@ default : all
 # Now figure out from those variables how to compile and link.
 
 .c.o:
-	$(CC) -c $(CFLAGS) $(WARN_CFLAGS) $(CPPFLAGS) $(FIXINC_CFLAGS) $<
+	$(CC) -c $(CFLAGS) $(WARN_CFLAGS) $(CPPFLAGS) $(FIXINC_CFLAGS) $< $(OUTPUT_OPTION)
 
 # The only suffixes we want for implicit rules are .c and .o.
 .SUFFIXES:
--- gcc/bitmap.c.0	2005-11-19 10:38:35.000000000 -0800
+++ gcc/bitmap.c	2007-12-04 15:14:14.000000000 -0800
@@ -1217,14 +1217,16 @@ debug_bitmap_file (FILE *file, bitmap he
 {
   bitmap_element *ptr;
 
-  fprintf (file, "\nfirst = %p current = %p indx = %u\n",
+  fprintf (file, "\nfirst = " HOST_PTR_PRINTF
+	  " current = " HOST_PTR_PRINTF " indx = %u\n",
 	   (void *) head->first, (void *) head->current, head->indx);
 
   for (ptr = head->first; ptr; ptr = ptr->next)
     {
       unsigned int i, j, col = 26;
 
-      fprintf (file, "\t%p next = %p prev = %p indx = %u\n\t\tbits = {",
+      fprintf (file, "\t" HOST_PTR_PRINTF " next = " HOST_PTR_PRINTF
+	      " prev = " HOST_PTR_PRINTF " indx = %u\n\t\tbits = {",
 	       (void*) ptr, (void*) ptr->next, (void*) ptr->prev, ptr->indx);
 
       for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)
--- gcc/c-decl.c.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/c-decl.c	2007-12-04 15:14:14.000000000 -0800
@@ -466,7 +466,7 @@ c_print_identifier (FILE *file, tree nod
     {
       tree rid = ridpointers[C_RID_CODE (node)];
       indent_to (file, indent + 4);
-      fprintf (file, "rid %p \"%s\"",
+      fprintf (file, "rid " HOST_PTR_PRINTF " \"%s\"",
 	       (void *) rid, IDENTIFIER_POINTER (rid));
     }
 }
--- gcc/config/alpha/alpha.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/config/alpha/alpha.c	2007-12-04 15:14:14.000000000 -0800
@@ -55,6 +55,7 @@ Boston, MA 02110-1301, USA.  */
 #include "tree-gimple.h"
 #include "tree-flow.h"
 #include "tree-stdarg.h"
+#include "libfuncs.h"
 
 /* Specify which cpu to schedule for.  */
 enum processor_type alpha_tune;
@@ -4806,6 +4807,9 @@ struct machine_function GTY(())
 
   /* For TARGET_LD_BUGGY_LDGP.  */
   struct rtx_def *gp_save_rtx;
+
+  /* For VMS condition handlers.  */
+  bool uses_condition_handler;  
 };
 
 /* How to allocate a 'struct machine_function'.  */
@@ -4817,6 +4821,63 @@ alpha_init_machine_status (void)
 		ggc_alloc_cleared (sizeof (struct machine_function)));
 }
 
+/* Support for frame based VMS condition handlers.  */
+
+/* A VMS condition handler may be established for a function with a call to
+   __builtin_establish_vms_condition_handler, and cancelled with a call to
+   __builtin_revert_vms_condition_handler.
+
+   The VMS Condition Handling Facility knows about the existence of a handler
+   from the procedure descriptor .handler field.  As the VMS native compilers,
+   we store the user specified handler's address at a fixed location in the
+   stack frame and point the procedure descriptor at a common wrapper which
+   fetches the real handler's address and issues an indirect call.
+
+   The indirection wrapper is "__gcc_shell_handler", provided by libgcc.
+
+   We force the procedure kind to PT_STACK, and the fixed frame location is
+   fp+8, just before the register save area. We use the handler_data field in
+   the procedure descriptor to state the fp offset at which the installed
+   handler address can be found.  */
+
+#define VMS_COND_HANDLER_FP_OFFSET 8
+
+/* Expand code to store the currently installed user VMS condition handler
+   into TARGET and install HANDLER as the new condition handler.  */
+
+void
+alpha_expand_builtin_establish_vms_condition_handler (rtx target, rtx handler)
+{
+  rtx handler_slot_address
+    = plus_constant (hard_frame_pointer_rtx, VMS_COND_HANDLER_FP_OFFSET);
+
+  rtx handler_slot
+    = gen_rtx_MEM (DImode, handler_slot_address);
+
+  emit_move_insn (target, handler_slot);
+  emit_move_insn (handler_slot, handler);
+
+  /* Notify the start/prologue/epilogue emitters that the condition handler
+     slot is needed.  In addition to reserving the slot space, this will force
+     the procedure kind to PT_STACK so ensure that the hard_frame_pointer_rtx
+     use above is correct.  */
+  cfun->machine->uses_condition_handler = true;
+}
+
+/* Expand code to store the current VMS condition handler into TARGET and
+   nullify it.  */
+
+void
+alpha_expand_builtin_revert_vms_condition_handler (rtx target)
+{
+  /* We implement this by establishing a null condition handler, with the tiny
+     side effect of setting uses_condition_handler.  This is a little bit
+     pessimistic if no actual builtin_establish call is ever issued, which is
+     not a real problem and expected never to happen anyway.  */
+
+  alpha_expand_builtin_establish_vms_condition_handler (target, const0_rtx);
+}
+
 /* Functions to save and restore alpha_return_addr_rtx.  */
 
 /* Start the ball rolling with RETURN_ADDR_RTX.  */
@@ -5516,15 +5577,42 @@ void
 alpha_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt,
 			     int fnofs, int cxtofs, int jmpofs)
 {
-  rtx temp, temp1, addr;
+  rtx temp, temp1, addr, traddr;
   /* VMS really uses DImode pointers in memory at this point.  */
   enum machine_mode mode = TARGET_ABI_OPEN_VMS ? Pmode : ptr_mode;
+  const char *fnname;
+  char *trname;
 
 #ifdef POINTERS_EXTEND_UNSIGNED
   fnaddr = convert_memory_address (mode, fnaddr);
   cxt = convert_memory_address (mode, cxt);
 #endif
 
+  if (TARGET_ABI_OPEN_VMS)
+    {
+      /* Construct the name of the trampoline entry point */
+      fnname = XSTR (fnaddr, 0);
+      trname = (char *) alloca (strlen (fnname) + 5);
+      strcpy (trname, fnname);
+      strcat (trname, "..tr");
+      traddr = gen_rtx_SYMBOL_REF
+	(mode, ggc_alloc_string (trname, strlen (trname) + 1));
+
+      /* Trampoline (or "bounded") procedure descriptor is constructed from
+	 the function's procedure descriptor with certain fields zeroed IAW
+	 the VMS calling standard. This is stored in the first quadword */
+      temp1 = force_reg (DImode, gen_rtx_MEM (DImode, fnaddr));
+      temp1 = expand_and (DImode, temp1,
+			  GEN_INT (0xffff0fff0000fff0), NULL_RTX);
+      addr = memory_address (mode, plus_constant (tramp, 0));
+      emit_move_insn (gen_rtx_MEM (DImode, addr), temp1);
+
+      /* Trampoline transfer address is stored in the second quadword
+	 of the trampoline */
+      addr = memory_address (mode, plus_constant (tramp, 8));
+      emit_move_insn (gen_rtx_MEM (mode, addr), traddr);
+    }
+
   /* Store function address and CXT.  */
   addr = memory_address (mode, plus_constant (tramp, fnofs));
   emit_move_insn (gen_rtx_MEM (mode, addr), fnaddr);
@@ -5737,9 +5825,13 @@ alpha_return_in_memory (tree type, tree 
     {
       mode = TYPE_MODE (type);
 
-      /* All aggregates are returned in memory.  */
+      /* All aggregates are returned in memory, except on OpenVMS where
+	 records that fit 64 bits should be returned by immediate value
+	 as required by section 3.8.7.1 of the OpenVMS Calling Standard.  */
       if (AGGREGATE_TYPE_P (type))
-	return true;
+	return !TARGET_ABI_OPEN_VMS
+	       || TREE_CODE (type) == ARRAY_TYPE
+	       || (unsigned HOST_WIDE_INT) int_size_in_bytes(type) > 8;
     }
 
   size = GET_MODE_SIZE (mode);
@@ -5808,6 +5900,9 @@ function_value (tree valtype, tree func 
   switch (class)
     {
     case MODE_INT:
+      /* Do the same thing as PROMOTE_MODE except for libcalls on VMS,
+	 where we have them returning both SImode and DImode.  */
+      if (!TARGET_ABI_OPEN_VMS || (valtype && !AGGREGATE_TYPE_P (valtype)))
       PROMOTE_MODE (mode, dummy, valtype);
       /* FALLTHRU */
 
@@ -5833,6 +5928,13 @@ function_value (tree valtype, tree func 
 				         GEN_INT (GET_MODE_SIZE (cmode)))));
       }
 
+    case MODE_RANDOM:
+      /* We should only reach here for BLKmode on VMS.  */
+      if (!TARGET_ABI_OPEN_VMS || mode != BLKmode)
+	abort ();
+      regnum = 0;
+      break;
+
     default:
       gcc_unreachable ();
     }
@@ -6167,12 +6269,11 @@ alpha_va_start (tree valist, rtx nextarg
 
   if (TARGET_ABI_OPEN_VMS)
     {
-      nextarg = plus_constant (nextarg, offset);
-      nextarg = plus_constant (nextarg, NUM_ARGS * UNITS_PER_WORD);
-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,
-		 make_tree (ptr_type_node, nextarg));
+      t = make_tree (ptr_type_node, virtual_incoming_args_rtx);
+      t = build (PLUS_EXPR, ptr_type_node, t,
+		 build_int_cst (NULL_TREE, offset + NUM_ARGS * UNITS_PER_WORD));
+      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);
       TREE_SIDE_EFFECTS (t) = 1;
-
       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);
     }
   else
@@ -6347,6 +6448,8 @@ enum alpha_builtin
   ALPHA_BUILTIN_RPCC,
   ALPHA_BUILTIN_THREAD_POINTER,
   ALPHA_BUILTIN_SET_THREAD_POINTER,
+  ALPHA_BUILTIN_ESTABLISH_VMS_CONDITION_HANDLER,
+  ALPHA_BUILTIN_REVERT_VMS_CONDITION_HANDLER,
 
   /* TARGET_MAX */
   ALPHA_BUILTIN_MINUB8,
@@ -6402,6 +6505,8 @@ static unsigned int const code_for_built
   CODE_FOR_builtin_rpcc,
   CODE_FOR_load_tp,
   CODE_FOR_set_tp,
+  CODE_FOR_builtin_establish_vms_condition_handler,
+  CODE_FOR_builtin_revert_vms_condition_handler,
 
   /* TARGET_MAX */
   CODE_FOR_builtin_minub8,
@@ -6500,6 +6605,12 @@ alpha_init_builtins (void)
 
   dimode_integer_type_node = lang_hooks.types.type_for_mode (DImode, 0);
 
+  /* Fwrite on VMS is non-standard */
+#if TARGET_ABI_OPEN_VMS
+  implicit_built_in_decls[(int) BUILT_IN_FWRITE] = NULL_TREE;
+  implicit_built_in_decls[(int) BUILT_IN_FWRITE_UNLOCKED] = NULL_TREE;
+#endif
+
   attrs[0] = tree_cons (get_identifier ("nothrow"), NULL, NULL);
   attrs[1] = tree_cons (get_identifier ("const"), NULL, attrs[0]);
 
@@ -6540,6 +6651,16 @@ alpha_init_builtins (void)
 			       ALPHA_BUILTIN_SET_THREAD_POINTER, BUILT_IN_MD,
 			       NULL, attrs[0]);
 
+  ftype = build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE);
+  lang_hooks.builtin_function ("__builtin_establish_vms_condition_handler", ftype,
+		    ALPHA_BUILTIN_ESTABLISH_VMS_CONDITION_HANDLER, BUILT_IN_MD,
+		    NULL, NULL_TREE);
+
+  ftype = build_function_type_list (ptr_type_node, void_type_node, NULL_TREE);
+  lang_hooks.builtin_function ("__builtin_revert_vms_condition_handler", ftype,
+		    ALPHA_BUILTIN_REVERT_VMS_CONDITION_HANDLER, BUILT_IN_MD,
+		    NULL, NULL_TREE);
+
   alpha_v8qi_u = build_vector_type (unsigned_intQI_type_node, 8);
   alpha_v8qi_s = build_vector_type (intQI_type_node, 8);
   alpha_v4hi_u = build_vector_type (unsigned_intHI_type_node, 4);
@@ -7269,7 +7390,10 @@ alpha_sa_size (void)
 	  if (! fixed_regs[i] && call_used_regs[i] && ! regs_ever_live[i])
 	    vms_save_fp_regno = i;
 
-      if (vms_save_fp_regno == -1 && alpha_procedure_type == PT_REGISTER)
+      /* A VMS condition handler requires a stack procedure in our
+	 implementation. (not required by the calling standard). */
+      if ((vms_save_fp_regno == -1 && alpha_procedure_type == PT_REGISTER)
+	  || cfun->machine->uses_condition_handler)
 	vms_base_regno = REG_PV, alpha_procedure_type = PT_STACK;
       else if (alpha_procedure_type == PT_NULL)
 	vms_base_regno = REG_PV;
@@ -7278,9 +7402,10 @@ alpha_sa_size (void)
       vms_unwind_regno = (vms_base_regno == REG_PV
 			  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);
 
-      /* If this is a stack procedure, allow space for saving FP and RA.  */
+      /* If this is a stack procedure, allow space for saving FP, RA and
+	 a condition handler slot if needed.  */
       if (alpha_procedure_type == PT_STACK)
-	sa_size += 2;
+	sa_size += 2 + cfun->machine->uses_condition_handler;
     }
   else
     {
@@ -7338,15 +7463,51 @@ alpha_using_fp (void)
 
 #if TARGET_ABI_OPEN_VMS
 
+#define COMMON_OBJECT "common_object"
+
+static tree
+common_object_handler (tree *node, tree name ATTRIBUTE_UNUSED,
+		       tree args ATTRIBUTE_UNUSED, int flags ATTRIBUTE_UNUSED,
+		       bool *no_add_attrs ATTRIBUTE_UNUSED)
+{
+  tree decl = *node;
+  if (! DECL_P (decl))
+    abort ();
+
+  DECL_COMMON (decl) = 1;
+  return NULL_TREE;
+}
+
 const struct attribute_spec vms_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
-  { "overlaid",   0, 0, true,  false, false, NULL },
-  { "global",     0, 0, true,  false, false, NULL },
-  { "initialize", 0, 0, true,  false, false, NULL },
-  { NULL,         0, 0, false, false, false, NULL }
+  { COMMON_OBJECT,   0, 1, true,  false, false, common_object_handler },
+  { NULL,            0, 0, false, false, false, NULL }
 };
 
+void
+vms_output_aligned_decl_common(FILE *file, tree decl, const char *name,
+			       unsigned HOST_WIDE_INT size,
+			       unsigned int align)
+{
+  tree attr = DECL_ATTRIBUTES (decl);
+  fprintf (file, "%s", COMMON_ASM_OP);
+  assemble_name (file, name);
+  fprintf (file, "," HOST_WIDE_INT_PRINT_UNSIGNED, size);
+  /* ??? Unlike on OSF/1, the alignment factor is not in log units.  */
+  fprintf (file, ",%u", align / BITS_PER_UNIT);
+  if (attr)
+    {
+      attr = lookup_attribute (COMMON_OBJECT, attr);
+      if (attr)
+        fprintf (file, ",%s",
+		 IDENTIFIER_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+    }
+  fputc ('\n', file);
+}
+
+#undef COMMON_OBJECT
+
 #endif
 
 static int
@@ -7551,7 +7712,7 @@ alpha_expand_prologue (void)
   frame_size = compute_frame_size (get_frame_size (), sa_size);
 
   if (TARGET_ABI_OPEN_VMS)
-    reg_offset = 8;
+    reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;
   else
     reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);
 
@@ -7762,10 +7923,11 @@ alpha_expand_prologue (void)
   if (TARGET_ABI_OPEN_VMS)
     {
       if (alpha_procedure_type == PT_REGISTER)
-	/* Register frame procedures save the fp.
-	   ?? Ought to have a dwarf2 save for this.  */
-	emit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),
-			hard_frame_pointer_rtx);
+	/* Register frame procedures save the fp, and this must be notified in
+	   the FDE to let the unwinder know in case the subprogram triggers a
+	   signal.  */
+	FRP (emit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),
+			     hard_frame_pointer_rtx));
 
       if (alpha_procedure_type != PT_NULL && vms_base_regno != REG_PV)
 	emit_insn (gen_force_movdi (gen_rtx_REG (DImode, vms_base_regno),
@@ -7850,6 +8012,7 @@ alpha_start_function (FILE *file, const 
   /* Offset from base reg to register save area.  */
   HOST_WIDE_INT reg_offset;
   char *entry_label = (char *) alloca (strlen (fnname) + 6);
+  char *tramp_label = (char *) alloca (strlen (fnname) + 6);
   int i;
 
   /* Don't emit an extern directive for functions defined in the same file.  */
@@ -7860,12 +8023,23 @@ alpha_start_function (FILE *file, const 
       TREE_ASM_WRITTEN (name_tree) = 1;
     }
 
+#if TARGET_ABI_OPEN_VMS
+  if (vms_debug_main
+      && strncmp (vms_debug_main, fnname, strlen (vms_debug_main)) == 0)
+    {
+      targetm.asm_out.globalize_label (asm_out_file, VMS_DEBUG_MAIN_POINTER);
+      ASM_OUTPUT_DEF (asm_out_file, VMS_DEBUG_MAIN_POINTER, fnname);
+      text_section ();
+      vms_debug_main = NULL;
+    }
+#endif
+
   alpha_fnname = fnname;
   sa_size = alpha_sa_size ();
   frame_size = compute_frame_size (get_frame_size (), sa_size);
 
   if (TARGET_ABI_OPEN_VMS)
-    reg_offset = 8;
+    reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;
   else
     reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);
 
@@ -7911,6 +8085,21 @@ alpha_start_function (FILE *file, const 
 	  fputs ("..ng:\n", file);
 	}
     }
+  /* Nested functions on VMS that are potentially called via trampoline
+     get a special transfer entry point that loads the called functions
+     procedure descriptor and static chain */
+  if (TARGET_ABI_OPEN_VMS)
+    {
+      if (!(DECL_CONTEXT (decl) == NULL_TREE) && !TREE_PUBLIC (decl)
+	  && ! (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl))))
+	{
+	  strcpy (tramp_label, fnname);
+	  strcat (tramp_label, "..tr");
+	  ASM_OUTPUT_LABEL (file, tramp_label);
+	  fprintf (file, "\tldq $1,24($27)\n");
+	  fprintf (file, "\tldq $27,16($27)\n");
+	}
+    }
 
   strcpy (entry_label, fnname);
   if (TARGET_ABI_OPEN_VMS)
@@ -7990,6 +8179,16 @@ alpha_start_function (FILE *file, const 
     }
 
 #if TARGET_ABI_OPEN_VMS
+  /* If a user condition handler has been installed at some point, emit
+     the procedure descriptor bits to point the Condition Handling Facility
+     at the indirection wrapper, and state the fp offset at which the user
+     handler may be found.  */
+  if (cfun->machine->uses_condition_handler)
+    {
+      fprintf (file, "\t.handler __gcc_shell_handler\n");
+      fprintf (file, "\t.handler_data %d\n", VMS_COND_HANDLER_FP_OFFSET);
+    }
+
   /* Ifdef'ed cause link_section are only available then.  */
   readonly_data_section ();
   fprintf (file, "\t.align 3\n");
@@ -8050,7 +8249,7 @@ alpha_expand_epilogue (void)
   if (TARGET_ABI_OPEN_VMS)
     {
        if (alpha_procedure_type == PT_STACK)
-          reg_offset = 8;
+          reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;
        else
           reg_offset = 0;
     }
@@ -8292,6 +8491,15 @@ alpha_end_function (FILE *file, const ch
     }
 }
 
+#if TARGET_ABI_OPEN_VMS
+void avms_asm_output_external (FILE *file, tree decl ATTRIBUTE_UNUSED, const char *name)
+{
+#ifdef DO_CRTL_NAMES
+  DO_CRTL_NAMES;
+#endif
+}
+#endif
+
 #if TARGET_ABI_OSF
 /* Emit a tail call to FUNCTION after adjusting THIS by DELTA.
 
@@ -9464,6 +9672,7 @@ enum reloc_kind {KIND_LINKAGE, KIND_CODE
 struct alpha_links GTY(())
 {
   int num;
+  const char *target;
   rtx linkage;
   enum links_kind lkind;
   enum reloc_kind rkind;
@@ -9516,17 +9725,17 @@ alpha_arg_info_reg_val (CUMULATIVE_ARGS 
   return GEN_INT (regval);
 }
 
-/* Make (or fake) .linkage entry for function call.
-
-   IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.
-
-   Return an SYMBOL_REF rtx for the linkage.  */
+/* Register the need for a (fake) .linkage entry for calls to function NAME.
+   IS_LOCAL is 1 if this is for a definition, 0 if this is for a real call.
+   Return a SYMBOL_REF suited to the call instruction.  */
 
 rtx
 alpha_need_linkage (const char *name, int is_local)
 {
   splay_tree_node node;
   struct alpha_links *al;
+  const char *target;
+  tree id;
 
   if (name[0] == '*')
     name++;
@@ -9581,19 +9790,18 @@ alpha_need_linkage (const char *name, in
   /* Assume external if no definition.  */
   al->lkind = (is_local ? KIND_UNUSED : KIND_EXTERN);
 
-  /* Ensure we have an IDENTIFIER so assemble_name can mark it used.  */
-  get_identifier (name);
+  /* Ensure we have an IDENTIFIER so assemble_name can mark it used
+     and find the ultimate alias target like assemble_name.  */
+  id = get_identifier (name);
+  target = NULL;
+  while (IDENTIFIER_TRANSPARENT_ALIAS (id))
+    {
+      id = TREE_CHAIN (id);
+      target = IDENTIFIER_POINTER (id);
+    }
 
-  /* Construct a SYMBOL_REF for us to call.  */
-  {
-    size_t name_len = strlen (name);
-    char *linksym = alloca (name_len + 6);
-    linksym[0] = '$';
-    memcpy (linksym + 1, name, name_len);
-    memcpy (linksym + 1 + name_len, "..lk", 5);
-    al->linkage = gen_rtx_SYMBOL_REF (Pmode,
-				      ggc_alloc_string (linksym, name_len + 5));
-  }
+  al->target = target ? target : name;
+  al->linkage = gen_rtx_SYMBOL_REF (Pmode, name);
 
   splay_tree_insert (alpha_links_tree, (splay_tree_key) name,
 		     (splay_tree_value) al);
@@ -9601,13 +9809,19 @@ alpha_need_linkage (const char *name, in
   return al->linkage;
 }
 
+/* Return a SYMBOL_REF representing the reference to the .linkage entry
+   of function FUNC built for calls made from CFUNDECL.  LFLAG is 1 if
+   this is the reference to the linkage pointer value, 0 if this is the
+   reference to the function entry value.  RFLAG is 1 if this a reduced
+   reference (code address only), 0 if this is a full reference.  */
+
 rtx
-alpha_use_linkage (rtx linkage, tree cfundecl, int lflag, int rflag)
+alpha_use_linkage (rtx func, tree cfundecl, int lflag, int rflag)
 {
   splay_tree_node cfunnode;
   struct alpha_funcs *cfaf;
   struct alpha_links *al;
-  const char *name = XSTR (linkage, 0);
+  const char *name = XSTR (func, 0);
 
   cfaf = (struct alpha_funcs *) 0;
   al = (struct alpha_links *) 0;
@@ -9632,7 +9846,6 @@ alpha_use_linkage (rtx linkage, tree cfu
     {
       size_t name_len;
       size_t buflen;
-      char buf [512];
       char *linksym;
       splay_tree_node node = 0;
       struct alpha_links *anl;
@@ -9641,6 +9854,7 @@ alpha_use_linkage (rtx linkage, tree cfu
 	name++;
 
       name_len = strlen (name);
+      linksym = alloca (name_len + 50);
 
       al = (struct alpha_links *) ggc_alloc (sizeof (struct alpha_links));
       al->num = cfaf->num;
@@ -9650,12 +9864,11 @@ alpha_use_linkage (rtx linkage, tree cfu
 	{
 	  anl = (struct alpha_links *) node->value;
 	  al->lkind = anl->lkind;
+	  name = anl->target;
 	}
 
-      sprintf (buf, "$%d..%s..lk", cfaf->num, name);
-      buflen = strlen (buf);
-      linksym = alloca (buflen + 1);
-      memcpy (linksym, buf, buflen + 1);
+      sprintf (linksym, "$%d..%s..lk", cfaf->num, name);
+      buflen = strlen (linksym);
 
       al->linkage = gen_rtx_SYMBOL_REF
 	(Pmode, ggc_alloc_string (linksym, buflen + 1));
@@ -9742,31 +9955,6 @@ alpha_write_linkage (FILE *stream, const
     }
 }
 
-/* Given a decl, a section name, and whether the decl initializer
-   has relocs, choose attributes for the section.  */
-
-#define SECTION_VMS_OVERLAY	SECTION_FORGET
-#define SECTION_VMS_GLOBAL SECTION_MACH_DEP
-#define SECTION_VMS_INITIALIZE (SECTION_VMS_GLOBAL << 1)
-
-static unsigned int
-vms_section_type_flags (tree decl, const char *name, int reloc)
-{
-  unsigned int flags = default_section_type_flags (decl, name, reloc);
-
-  if (decl && DECL_ATTRIBUTES (decl)
-      && lookup_attribute ("overlaid", DECL_ATTRIBUTES (decl)))
-    flags |= SECTION_VMS_OVERLAY;
-  if (decl && DECL_ATTRIBUTES (decl)
-      && lookup_attribute ("global", DECL_ATTRIBUTES (decl)))
-    flags |= SECTION_VMS_GLOBAL;
-  if (decl && DECL_ATTRIBUTES (decl)
-      && lookup_attribute ("initialize", DECL_ATTRIBUTES (decl)))
-    flags |= SECTION_VMS_INITIALIZE;
-
-  return flags;
-}
-
 /* Switch to an arbitrary section NAME with attributes as specified
    by FLAGS.  ALIGN specifies any known alignment requirements for
    the section; 0 if the default should be used.  */
@@ -9778,12 +9966,6 @@ vms_asm_named_section (const char *name,
   fputc ('\n', asm_out_file);
   fprintf (asm_out_file, ".section\t%s", name);
 
-  if (flags & SECTION_VMS_OVERLAY)
-    fprintf (asm_out_file, ",OVR");
-  if (flags & SECTION_VMS_GLOBAL)
-    fprintf (asm_out_file, ",GBL");
-  if (flags & SECTION_VMS_INITIALIZE)
-    fprintf (asm_out_file, ",NOMOD");
   if (flags & SECTION_DEBUG)
     fprintf (asm_out_file, ",NOWRT");
 
@@ -9823,7 +10005,7 @@ alpha_need_linkage (const char *name ATT
 }
 
 rtx
-alpha_use_linkage (rtx linkage ATTRIBUTE_UNUSED,
+alpha_use_linkage (rtx func ATTRIBUTE_UNUSED,
 		   tree cfundecl ATTRIBUTE_UNUSED,
 		   int lflag ATTRIBUTE_UNUSED,
 		   int rflag ATTRIBUTE_UNUSED)
@@ -10620,16 +10802,26 @@ alpha_init_libfuncs (void)
       set_optab_libfunc (smod_optab, DImode, "OTS$REM_L");
       set_optab_libfunc (umod_optab, SImode, "OTS$REM_UI");
       set_optab_libfunc (umod_optab, DImode, "OTS$REM_UL");
+      abort_libfunc = init_one_libfunc ("decc$abort");
+      memcmp_libfunc = init_one_libfunc ("decc$memcmp");
+#ifdef MEM_LIBFUNCS_INIT
+      MEM_LIBFUNCS_INIT;
+#endif
     }
 }
 
+static bool
+vms_valid_pointer_mode (enum machine_mode mode)
+{
+  return (mode == SImode || mode == DImode);
+}
 
 /* Initialize the GCC target structure.  */
 #if TARGET_ABI_OPEN_VMS
 # undef TARGET_ATTRIBUTE_TABLE
 # define TARGET_ATTRIBUTE_TABLE vms_attribute_table
-# undef TARGET_SECTION_TYPE_FLAGS
-# define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags
+# undef TARGET_VALID_POINTER_MODE
+# define TARGET_VALID_POINTER_MODE vms_valid_pointer_mode
 #endif
 
 #if TARGET_ABI_UNICOSMK
@@ -10654,7 +10846,7 @@ alpha_init_libfuncs (void)
 
 /* Default unaligned ops are provided for ELF systems.  To get unaligned
    data for non-ELF systems, we have to turn off auto alignment.  */
-#ifndef OBJECT_FORMAT_ELF
+#if !defined (OBJECT_FORMAT_ELF) || TARGET_ABI_OPEN_VMS
 #undef TARGET_ASM_UNALIGNED_HI_OP
 #define TARGET_ASM_UNALIGNED_HI_OP "\t.align 0\n\t.word\t"
 #undef TARGET_ASM_UNALIGNED_SI_OP
--- gcc/config/alpha/alpha.md.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/config/alpha/alpha.md	2007-12-04 15:14:14.000000000 -0800
@@ -5051,6 +5051,24 @@
     return "call_pal 0x9f";
 }
   [(set_attr "type" "callpal")])
+
+;; Special builtins for establishing and reverting VMS condition handlers.
+
+(define_expand "builtin_establish_vms_condition_handler"
+  [(set (reg:DI 0) (match_operand:DI 0 "register_operand" ""))
+   (use (match_operand:DI 1 "address_operand" ""))]
+  "TARGET_ABI_OPEN_VMS"
+{
+  alpha_expand_builtin_establish_vms_condition_handler (operands[0],
+                                                        operands[1]);
+})
+
+(define_expand "builtin_revert_vms_condition_handler"
+  [(set (reg:DI 0) (match_operand:DI 0 "register_operand" ""))]
+  "TARGET_ABI_OPEN_VMS"
+{
+  alpha_expand_builtin_revert_vms_condition_handler (operands[0]);
+})
 
 ;; Finally, we have the basic data motion insns.  The byte and word insns
 ;; are done via define_expand.  Start with the floating-point insns, since
@@ -6589,8 +6607,7 @@
 	      (clobber (reg:DI 27))])]
   "TARGET_ABI_OPEN_VMS"
 {
-  operands[4] = gen_rtx_SYMBOL_REF (Pmode, "OTS$MOVE");
-  alpha_need_linkage (XSTR (operands[4], 0), 0);
+  operands[4] = alpha_need_linkage ("OTS$MOVE", 0);
 })
 
 (define_insn "*movmemdi_1"
@@ -6657,8 +6674,7 @@
   if (operands[2] != const0_rtx)
     FAIL;
 
-  operands[4] = gen_rtx_SYMBOL_REF (Pmode, "OTS$ZERO");
-  alpha_need_linkage (XSTR (operands[4], 0), 0);
+  operands[4] = alpha_need_linkage ("OTS$ZERO", 0);
 })
 
 (define_insn "*clrmemdi_1"
--- gcc/config/alpha/alpha-protos.h.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/config/alpha/alpha-protos.h	2007-12-04 15:14:14.000000000 -0800
@@ -76,6 +76,9 @@ extern rtx alpha_expand_zap_mask (HOST_W
 extern void alpha_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),
 					       enum machine_mode,
 					       rtx, rtx, rtx);
+extern void alpha_expand_builtin_establish_vms_condition_handler (rtx, rtx);
+extern void alpha_expand_builtin_revert_vms_condition_handler (rtx);
+
 extern rtx alpha_return_addr (int, rtx);
 extern rtx alpha_gp_save_rtx (void);
 extern void print_operand (FILE *, rtx, int);
@@ -119,6 +122,10 @@ extern rtx alpha_use_linkage (rtx, tree,
 #if TARGET_ABI_OPEN_VMS
 extern enum avms_arg_type alpha_arg_type (enum machine_mode);
 extern rtx alpha_arg_info_reg_val (CUMULATIVE_ARGS);
+extern void avms_asm_output_external (FILE *, tree, const char *);
+extern void vms_output_aligned_decl_common (FILE *, tree, const char *,
+					    unsigned HOST_WIDE_INT,
+					    unsigned int);
 #endif
 
 extern rtx unicosmk_add_call_info_word (rtx);
--- gcc/config/alpha/t-vms.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/t-vms	2007-12-04 15:14:14.000000000 -0800
@@ -1,26 +1,49 @@
-LIB2FUNCS_EXTRA = $(srcdir)/config/alpha/vms_tramp.asm
+LIB2FUNCS_EXTRA = $(srcdir)/config/alpha/vms-gcc_shell_handler.c
 
-# VMS_EXTRA_PARTS is defined in x-vms and represent object files that
-# are only needed for VMS targets, but can only be compiled on a VMS host
-# (because they need DEC C).
-EXTRA_PARTS = vms-dwarf2.o vms-dwarf2eh.o $(VMS_EXTRA_PARTS)
+EXTRA_PARTS = vms-dwarf2.o vms-dwarf2eh.o $(VMS_EXTRA_PARTS) \
+  crtbegin.o crtbeginS.o crtend.o crtendS.o
 
 # This object must be linked with in order to make the executable debuggable.
 # vms-ld handles it automatically when passed -g.
 vms-dwarf2.o : $(srcdir)/config/alpha/vms-dwarf2.asm
-	gcc -c -x assembler $< -o $@
+	$(GCC_FOR_TARGET) -c -x assembler $< -o $@
 
 vms-dwarf2eh.o : $(srcdir)/config/alpha/vms-dwarf2eh.asm
-	gcc -c -x assembler $< -o $@
-
-# Assemble startup files.
-vcrt0.o: $(CRT0_S) $(GCC_PASSES)
-	decc -c /names=as_is $(srcdir)/config/alpha/vms-crt0.c -o vcrt0.o
-
-pcrt0.o: $(CRT0_S) $(GCC_PASSES)
-	decc -c /names=as_is $(srcdir)/config/alpha/vms-psxcrt0.c -o pcrt0.o
+	$(GCC_FOR_TARGET) -c -x assembler $< -o $@
 
 MULTILIB_OPTIONS = mcpu=ev6
 MULTILIB_DIRNAMES = ev6
+MULTILIB_OSDIRNAMES = ev6
 LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
+
+shlib_version:=$(shell echo $(BASEVER_c) | sed -e 's/\./,/' -e 's/\.//g')
+SHLIB_EXT = .exe
+SHLIB_OBJS = @shlib_objs@
+SHLIB_NAME = @shlib_base_name@.exe
+SHLIB_MULTILIB =
+SHLIB_INSTALL = $(INSTALL_DATA) $(SHLIB_NAME) $$(DESTDIR)$$(libsubdir)/$(SHLIB_NAME)
+SHLIB_SYMVEC = \
+  grep -F -e "\$$BSS\$$" -e "\$$DATA\$$" -e " sdata " -e " data.rel " -e " data.rel.ro " -e " sbss " \
+        -e "\$$LINK\$$" -e "\$$READONLY\$$" | \
+  sed -e "s/.*\$$LINK\$$   \(.*\)/SYMBOL_VECTOR=(\1=PROCEDURE)/" \
+      -e "s/.*\$$DATA\$$   \(.*\)/SYMBOL_VECTOR=(\1=DATA)/" \
+      -e "s/.* sbss     \(.*\)/SYMBOL_VECTOR=(\1=DATA)/" \
+      -e "s/.* sdata    \(.*\)/SYMBOL_VECTOR=(\1=DATA)/" \
+      -e "s/.* data.rel \(.*\)/SYMBOL_VECTOR=(\1=DATA)/" \
+      -e "s/.* data.rel.ro \(.*\)/SYMBOL_VECTOR=(\1=DATA)/" \
+      -e "s/.*\$$BSS\$$    \(.*\)/SYMBOL_VECTOR=(\1=DATA)/" \
+      -e "s/.*\$$READONLY\$$ \(.*\)/SYMBOL_VECTOR=(\1=DATA)/"
+SHLIB_SYMVECX2 := $(subst $$,$$$$,$(SHLIB_SYMVEC))
+SHLIB_LINK = \
+  echo "case_sensitive=yes" > SYMVEC_$$$$$$$$.opt; \
+  objdump --syms $(SHLIB_OBJS) | \
+  $(SHLIB_SYMVECX2) >> SYMVEC_$$$$$$$$.opt ; \
+  echo "case_sensitive=NO" >> SYMVEC_$$$$$$$$.opt; \
+  $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -nodefaultlibs \
+  -shared --for-linker=/noinform -o $(SHLIB_NAME) $(SHLIB_OBJS) \
+  --for-linker=SYMVEC_$$$$$$$$.opt \
+  --for-linker=gsmatch=equal,$(shlib_version)
+
+# Skip more bytes in compare to account for time stamp in object file header
+skip_bytes = 64
--- gcc/config/alpha/t-vms64.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/t-vms64	1969-12-31 16:00:00.000000000 -0800
@@ -1,8 +0,0 @@
-# Assemble startup files.
-vcrt0.o: $(CRT0_S) $(GCC_PASSES)
-	decc -c /names=as_is /pointer_size=64  \
-	     $(srcdir)/config/alpha/vms-crt0-64.c -o vcrt0.o
-
-pcrt0.o: $(CRT0_S) $(GCC_PASSES)
-	decc -c /names=as_is /pointer_size=64 \
-	     $(srcdir)/config/alpha/vms-psxcrt0-64.c -o pcrt0.o
--- gcc/config/alpha/vms64.h.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/vms64.h	2007-12-04 15:14:14.000000000 -0800
@@ -16,17 +16,36 @@ GNU General Public License for more deta
 
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()                \
+    do {                                        \
+        builtin_define_std ("vms");             \
+        builtin_define_std ("VMS");             \
+        builtin_define ("__ALPHA");             \
+        builtin_assert ("system=vms");          \
+        builtin_define ("__IEEE_FLOAT");        \
+        builtin_define ("__LONG_POINTERS=0");   \
+    } while (0)
+
+#undef SUBTARGET_SWITCHES
+#define SUBTARGET_SWITCHES \
+  { "malloc64",    MASK_MALLOC64,     "Malloc data into P2 space" },
 
-/* Defaults to BITS_PER_WORD, e.g. 64 which is what is wanted.
-  This is incompatible with DEC C, but matches DEC Ada */
 #undef LONG_TYPE_SIZE
+#define LONG_TYPE_SIZE 64
+
+#undef POINTER_SIZE
+#define POINTER_SIZE 64
+
+/* Eventhough pointers are 64bits, only 32bit ever remain significant in code
+   addresses.  */
+#define MASK_RETURN_ADDR (GEN_INT (0xffffffff))
 
 /* Defaults to "long int" */
 #undef SIZE_TYPE
 #undef PTRDIFF_TYPE
 
-#undef POINTERS_EXTEND_UNSIGNED
-#undef POINTER_SIZE
-#define POINTER_SIZE 64
+#  include "config/vms/vms-crtl-64.h"
--- gcc/config/alpha/vms-cc.c.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-cc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,356 +0,0 @@
-/* VMS DEC C wrapper.
-   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-   Contributed by Douglas B. Rupp (rupp@gnat.com).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-/* This program is a wrapper around the VMS DEC C compiler.
-   It translates Unix style command line options into corresponding
-   VMS style qualifiers and then spawns the DEC C compiler.  */
-
-#include "config.h"
-#include "system.h"
-#include "coretypes.h"
-#include "tm.h"
-
-#undef PATH_SEPARATOR
-#undef PATH_SEPARATOR_STR
-#define PATH_SEPARATOR ','
-#define PATH_SEPARATOR_STR ","
-
-/* These can be set by command line arguments */
-static int verbose = 0;
-static int save_temps = 0;
-
-static int comp_arg_max = -1;
-static const char **comp_args = 0;
-static int comp_arg_index = -1;
-static char *objfilename = 0;
-
-static char *system_search_dirs = (char *) "";
-static char *search_dirs;
-
-static char *default_defines = (char *) "";
-static char *defines;
-
-/* Translate a Unix syntax directory specification into VMS syntax.
-   If indicators of VMS syntax found, return input string.  */
-static char *to_host_dir_spec (char *);
-
-/* Translate a Unix syntax file specification into VMS syntax.
-   If indicators of VMS syntax found, return input string.  */
-static char *to_host_file_spec (char *);
-
-/* Add a translated arg to the list to be passed to DEC CC.  */
-static void addarg (const char *);
-
-/* Preprocess the number of args in P_ARGC and contained in ARGV.
-   Look for special flags, etc. that must be handled first.  */
-static void preprocess_args (int *, char **);
-
-/* Process the number of args in P_ARGC and contained in ARGV. Look
-   for special flags, etc. that must be handled for the VMS compiler.  */
-static void process_args (int *, char **);
-
-/* Action routine called by decc$to_vms */
-static int translate_unix (char *, int);
-
-/* Add the argument contained in STR to the list of arguments to pass to the
-   compiler.  */
-
-static void
-addarg (const char *str)
-{
-  int i;
-
-  if (++comp_arg_index >= comp_arg_max)
-    {
-      const char **new_comp_args
-	= (const char **) xcalloc (comp_arg_max + 1000, sizeof (char *));
-
-      for (i = 0; i <= comp_arg_max; i++)
-	new_comp_args [i] = comp_args [i];
-
-      if (comp_args)
-	free (comp_args);
-
-      comp_arg_max += 1000;
-      comp_args = new_comp_args;
-    }
-
-  comp_args [comp_arg_index] = str;
-}
-
-static void
-preprocess_args (int *p_argc, char *argv[])
-{
-  int i;
-
-  for (i = 1; i < *p_argc; i++)
-    {
-      if (strcmp (argv[i], "-o") == 0)
-	{
-	  char *buff, *ptr;
-
-	  i++;
-	  ptr = to_host_file_spec (argv[i]);
-	  objfilename = xstrdup (ptr);
-	  buff = concat ("/obj=", ptr, NULL);
-	  addarg (buff);
-	}
-    }
-}
-
-static void
-process_args (int *p_argc, char *argv[])
-{
-  int i;
-
-  for (i = 1; i < *p_argc; i++)
-    {
-      if (strlen (argv[i]) < 2)
-	continue;
-
-      if (strncmp (argv[i], "-I", 2) == 0)
-	{
-	  char *ptr;
-	  int new_len, search_dirs_len;
-
-	  ptr = to_host_dir_spec (&argv[i][2]);
-	  new_len = strlen (ptr);
-	  search_dirs_len = strlen (search_dirs);
-
-	  search_dirs = xrealloc (search_dirs, search_dirs_len + new_len + 2);
-	  if (search_dirs_len > 0)
-	    strcat (search_dirs, PATH_SEPARATOR_STR);
-	  strcat (search_dirs, ptr);
-	}
-      else if (strncmp (argv[i], "-D", 2) == 0)
-	{
-	  char *ptr;
-	  int new_len, defines_len;
-
-	  ptr = &argv[i][2];
-	  new_len = strlen (ptr);
-	  defines_len = strlen (defines);
-
-	  defines = xrealloc (defines, defines_len + new_len + 4);
-	  if (defines_len > 0)
-	    strcat (defines, ",");
-
-	  strcat (defines, "\"");
-	  strcat (defines, ptr);
-	  strcat (defines, "\"");
-	}
-      else if (strcmp (argv[i], "-v") == 0)
-	verbose = 1;
-      else if (strcmp (argv[i], "-g0") == 0)
-	addarg ("/nodebug");
-      else if (strcmp (argv[i], "-O0") == 0)
-	addarg ("/noopt");
-      else if (strncmp (argv[i], "-g", 2) == 0)
-	addarg ("/debug");
-      else if (strcmp (argv[i], "-E") == 0)
-	addarg ("/preprocess");
-      else if (strcmp (argv[i], "-save-temps") == 0)
-	save_temps = 1;
-    }
-}
-
-/* The main program.  Spawn the VMS DEC C compiler after fixing up the
-   Unix-like flags and args to be what VMS DEC C wants.  */
-
-typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;
-
-int
-main (int argc, char **argv)
-{
-  int i;
-  char cwdev [128], *devptr;
-  int devlen;
-  char *cwd = getcwd (0, 1024);
-
-  devptr = strchr (cwd, ':');
-  devlen = (devptr - cwd) + 1;
-  strncpy (cwdev, cwd, devlen);
-  cwdev [devlen] = '\0';
-
-  search_dirs = xstrdup (system_search_dirs);
-  defines = xstrdup (default_defines);
-
-  addarg ("cc");
-  preprocess_args (&argc , argv);
-  process_args (&argc , argv);
-
-  if (strlen (search_dirs) > 0)
-    {
-      addarg ("/include=(");
-      addarg (search_dirs);
-      addarg (")");
-    }
-
-  if (strlen (defines) > 0)
-    {
-      addarg ("/define=(");
-      addarg (defines);
-      addarg (")");
-    }
-
-  for (i = 1; i < argc; i++)
-    {
-      int arg_len = strlen (argv[i]);
-
-      if (strcmp (argv[i], "-o") == 0)
-	i++;
-      else if (strcmp (argv[i], "-v" ) == 0
-	       || strcmp (argv[i], "-E") == 0
-	       || strcmp (argv[i], "-c") == 0
-	       || strncmp (argv[i], "-g", 2 ) == 0
-	       || strncmp (argv[i], "-O", 2 ) == 0
-	       || strcmp (argv[i], "-save-temps") == 0
-	       || (arg_len > 2 && strncmp (argv[i], "-I", 2) == 0)
-	       || (arg_len > 2 && strncmp (argv[i], "-D", 2) == 0))
-	;
-
-      /* Unix style file specs and VMS style switches look alike, so assume
-	 an arg consisting of one and only one slash, and that being first, is
-	 really a switch.  */
-      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))
-	addarg (argv[i]);
-      else
-	{
-	  /* Assume filename arg */
-	  char buff [256], *ptr;
-
-	  ptr = to_host_file_spec (argv[i]);
-	  arg_len = strlen (ptr);
-
-	  if (ptr[0] == '[')
-	    sprintf (buff, "%s%s", cwdev, ptr);
-	  else if (strchr (ptr, ':'))
-	    sprintf (buff, "%s", ptr);
-	  else
-	    sprintf (buff, "%s%s", cwd, ptr);
-
-	  ptr = xstrdup (buff);
-	  addarg (ptr);
-	}
-    }
-
-  addarg (NULL);
-
-  if (verbose)
-    {
-      int i;
-
-      for (i = 0; i < comp_arg_index; i++)
-	printf ("%s ", comp_args [i]);
-
-      putchar ('\n');
-    }
-
-  {
-    int i;
-    int len = 0;
-
-    for (i = 0; comp_args[i]; i++)
-      len = len + strlen (comp_args[i]) + 1;
-
-    {
-      char *allargs = (char *) alloca (len + 1);
-      Descr cmd;
-      int status;
-      int status1 = 1;
-
-      for (i = 0; i < len + 1; i++)
-	allargs [i] = 0;
-
-      for (i = 0; comp_args [i]; i++)
-	{
-	  strcat (allargs, comp_args [i]);
-	  strcat (allargs, " ");
-	}
-
-      cmd.adr = allargs;
-      cmd.len = len;
-      cmd.mbz = 0;
-
-      i = LIB$SPAWN (&cmd, 0, 0, 0, 0, 0, &status);
-
-      if ((i & 1) != 1)
-	{
-	  LIB$SIGNAL (i);
-	  exit (1);
-	}
-
-      if ((status & 1) == 1 && (status1 & 1) == 1)
-	exit (0);
-
-      exit (1);
-    }
-  }
-}
-
-static char new_host_filespec [255];
-static char new_host_dirspec [255];
-static char filename_buff [256];
-
-static int
-translate_unix (char *name, int type ATTRIBUTE_UNUSED)
-{
-  strcpy (filename_buff, name);
-  return 0;
-}
-
-static char *
-to_host_dir_spec (char *dirspec)
-{
-  int len = strlen (dirspec);
-
-  strcpy (new_host_dirspec, dirspec);
-
-  if (strchr (new_host_dirspec, ']') || strchr (new_host_dirspec, ':'))
-    return new_host_dirspec;
-
-  while (len > 1 && new_host_dirspec [len-1] == '/')
-    {
-      new_host_dirspec [len-1] = 0;
-      len--;
-    }
-
-  decc$to_vms (new_host_dirspec, translate_unix, 1, 2);
-  strcpy (new_host_dirspec, filename_buff);
-
-  return new_host_dirspec;
-
-}
-
-static char *
-to_host_file_spec (char *filespec)
-{
-  strcpy (new_host_filespec, "");
-  if (strchr (filespec, ']') || strchr (filespec, ':'))
-    strcpy (new_host_filespec, filespec);
-  else
-    {
-      decc$to_vms (filespec, translate_unix, 1, 1);
-      strcpy (new_host_filespec, filename_buff);
-    }
-
-  return new_host_filespec;
-}
--- gcc/config/alpha/vms-crt0-64.c.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/vms-crt0-64.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,99 +0,0 @@
-/* VMS 64bit crt0 returning VMS style condition codes .
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   Contributed by Douglas B. Rupp (rupp@gnat.com).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-In addition to the permissions in the GNU General Public License, the
-Free Software Foundation gives you unlimited permission to link the
-compiled version of this file into combinations with other programs,
-and to distribute those combinations without any restriction coming
-from the use of this file.  (The General Public License restrictions
-do apply in other respects; for example, they cover modification of
-the file, and distribution when not linked into a combine
-executable.)
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-#if !defined(__DECC)
-You Lose! This file can only be compiled with DEC C.
-#else
-
-/* This file can only be compiled with DEC C, due to the call to
-   lib$establish and the pragmas pointer_size.  */
-
-#pragma __pointer_size short
-
-#include <stdlib.h>
-#include <string.h>
-#include <ssdef.h>
-
-extern void decc$main ();
-
-extern int main ();
-
-static int
-handler (sigargs, mechargs)
-     void *sigargs;
-     void *mechargs;
-{
-  return SS$_RESIGNAL;
-}
-
-int
-__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
-     void *arg1, *arg2, *arg3;
-     void *image_file_desc;
-     void *arg5, *arg6;
-{
-  int argc;
-  char **argv;
-  char **envp;
-
-#pragma __pointer_size long
-
-  int i;
-  char **long_argv;
-  char **long_envp;
-
-#pragma __pointer_size short
-
-  lib$establish (handler);
-  decc$main (arg1, arg2, arg3, image_file_desc,
-	     arg5, arg6, &argc, &argv, &envp);
-
-#pragma __pointer_size long
-
-  /* Reallocate argv with 64 bit pointers.  */
-  long_argv = (char **) malloc (sizeof (char *) * (argc + 1));
-
-  for (i = 0; i < argc; i++)
-    long_argv[i] = strdup (argv[i]);
-
-  long_argv[argc] = (char *) 0;
-
-  long_envp = (char **) malloc (sizeof (char *) * 5);
-
-  for (i = 0; envp[i]; i++)
-    long_envp[i] = strdup (envp[i]);
-
-  long_envp[i] = (char *) 0;
-
-#pragma __pointer_size short
-
-  return main (argc, long_argv, long_envp);
-}
-#endif
--- gcc/config/alpha/vms-crt0.c.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-crt0.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,71 +0,0 @@
-/* VMS crt0 returning VMS style condition codes .
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   Contributed by Douglas B. Rupp (rupp@gnat.com).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-In addition to the permissions in the GNU General Public License, the
-Free Software Foundation gives you unlimited permission to link the
-compiled version of this file into combinations with other programs,
-and to distribute those combinations without any restriction coming
-from the use of this file.  (The General Public License restrictions
-do apply in other respects; for example, they cover modification of
-the file, and distribution when not linked into a combine
-executable.)
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-#if !defined(__DECC)
-You Lose! This file can only be compiled with DEC C.
-#else
-
-/* This file can only be compiled with DEC C, due to the call to
-   lib$establish.  */
-
-#include <stdlib.h>
-#include <string.h>
-#include <ssdef.h>
-
-extern void decc$main ();
-
-extern int main ();
-
-static int
-handler (sigargs, mechargs)
-     void *sigargs;
-     void *mechargs;
-{
-  return SS$_RESIGNAL;
-}
-
-int
-__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
-     void *arg1, *arg2, *arg3;
-     void *image_file_desc;
-     void *arg5, *arg6;
-{
-  int argc;
-  char **argv;
-  char **envp;
-
-  lib$establish (handler);
-
-  decc$main(arg1, arg2, arg3, image_file_desc, arg5, arg6,
-	    &argc, &argv, &envp);
-
-  return main (argc, argv, envp);
-}
-#endif
--- gcc/config/alpha/vms-dwarf2.asm.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-dwarf2.asm	2007-12-04 15:14:14.000000000 -0800
@@ -25,8 +25,8 @@ GNU General Public License for more deta
 
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
 
 /* Linking with this file forces Dwarf2 debug sections to be
    sequentially loaded by the VMS linker, enabling GDB to read them.  */
--- gcc/config/alpha/vms-dwarf2eh.asm.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-dwarf2eh.asm	2007-12-04 15:14:14.000000000 -0800
@@ -25,13 +25,11 @@ GNU General Public License for more deta
 
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
 
 /* Linking with this file forces the Dwarf2 EH section to be
    individually loaded by the VMS linker an the unwinder to read it.  */
 
 .section	.eh_frame,NOWRT
 		.align 0
-		.global __EH_FRAME_BEGIN__
-__EH_FRAME_BEGIN__:
--- gcc/config/alpha/vms-ehfb.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/alpha/vms-ehfb.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,284 @@
+/* Fallback frame unwinding for Alpha/VMS.
+   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2003,
+   Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <vms/pdscdef.h>
+#include <vms/libicb.h>
+#include <vms/chfctxdef.h>
+#include <vms/chfdef.h>
+
+typedef void * ADDR;
+typedef unsigned long long REG;
+typedef PDSCDEF * PV;
+
+#define REG_AT(addr) (*(REG *)(addr))
+#define ADDR_AT(addr) (*(ADDR *)(addr))
+
+/* Compute pointer to procedure descriptor (Procedure Value) from Frame
+   Pointer FP, according to the rules in [ABI-3.5.1 Current Procedure].  */
+#define PV_FOR(FP) \
+  (((FP) != 0) \
+    ? (((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP)) : 0)
+
+extern int SYS$GL_CALL_HANDL;
+/* This is actually defined as a "long", but in system code where longs
+   are always 4bytes while GCC longs might be 8bytes.  */
+
+#define UPDATE_FS_FOR_CFA_GR(FS, GRN, LOC, CFA) \
+do { \
+(FS)->regs.reg[GRN].how = REG_SAVED_OFFSET;      \
+(FS)->regs.reg[GRN].loc.offset = (_Unwind_Sword) ((REG) (LOC) - (REG) (CFA)); \
+} while (0);
+
+#define GIVEUP_ON_FAILURE(STATUS) { if ((((STATUS) & 1) != 1)) return 0; }
+#define DENOTES_EXC_DISPATCHER(PV) ((PV) == (ADDR) (REG) SYS$GL_CALL_HANDL)
+
+#define RA_COLUMN (DWARF_ALT_FRAME_RETURN_COLUMN)
+
+static int
+md_fallback_frame_state_for
+(struct _Unwind_Context *CONTEXT, _Unwind_FrameState *FS)
+{
+  static int eh_debug = -1;
+
+  /* Our goal is to update FS to reflect the state one step up CONTEXT, that
+     is: the CFA, return address and *saved* registers locations associated
+     with the function designated by CONTEXT->ra.  We are called when the
+     libgcc unwinder has not found any dwarf FDE for this address, which
+     typically happens when trying to propagate a language exception through a
+     signal global vector or frame based handler.
+
+     The CONTEXT->reg[] entries reflect the state/location of register saves
+     so designate values live at the CONTEXT->ra point.  Of precious value to
+     us here is the frame pointer (r29), which gets us a procedure value.  */
+
+  PV pv = (CONTEXT->reg[29] != 0) ? PV_FOR (ADDR_AT (CONTEXT->reg[29])) : 0;
+
+  int pkind = pv ? pv->pdsc$w_flags & 0xf : 0;
+  /* VMS procedure kind, as indicated by the procedure descriptor.  We only
+     know how to deal with FP_STACK or FP_REGISTER here.  */
+
+  ADDR new_cfa = 0;
+  /* CFA we will establish for the caller, computed in different ways,
+     e.g. depending whether we cross an exception dispatcher frame.  */
+
+  CHFCTX *chfctx = 0;
+  /* Pointer to the VMS CHF context associated with an exception dispatcher
+     frame, if we happen to come across one.  */
+
+  int i,j;
+
+  if (eh_debug == -1)
+    {
+      char * eh_debug_env = getenv ("EH_DEBUG");
+      eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;
+    }
+
+  if (eh_debug)
+    printf ("MD_FALLBACK running ...\n");
+
+  /* We only know how to deal with stack or reg frame procedures, so give
+     up if we're handed anything else.  */
+  if (pkind != PDSC$K_KIND_FP_STACK && pkind != PDSC$K_KIND_FP_REGISTER)
+    return 0;
+  
+  if (eh_debug)
+    printf ("FALLBACK: CTX FP = 0x%p, PV = 0x%p, EN = 0x%x, RA = 0x%p\n",
+	    ADDR_AT (CONTEXT->reg[29]), pv, pv->pdsc$q_entry, CONTEXT->ra);
+
+  (FS)->retaddr_column = RA_COLUMN;
+
+  /* If PV designates a VMS exception vector or condition handler, we need to
+     do as if the caller was the signaling point and estabish the state of the
+     intermediate VMS code (CFA, RA and saved register locations) as if it was
+     a single regular function.  This requires special processing.
+
+     The datastructures available from an condition dispatcher frame (signal
+     context) do not contain the values of most callee-saved registers, so
+     whathever PV designates, we need to account for the registers it saves.
+
+     Besides, we need to express all the locations with respect to a
+     consistent CFA value, so we compute this first.  */
+
+  if (DENOTES_EXC_DISPATCHER (pv))
+    {
+      /* The CFA to establish is the signaling point's stack pointer. We
+	 compute it using the system invocation context unwinding services and
+	 save the CHF context data pointer along the way for later uses.  */
+
+      INVO_CONTEXT_BLK icb;
+      int status, invo_handle;
+
+      if (eh_debug)
+	printf ("FALLBACK: SYS$HANDLER\n");
+
+      icb.libicb$q_ireg [29] = REG_AT (CONTEXT->reg[29]);
+      icb.libicb$q_ireg [30] = 0;
+      invo_handle = LIB$GET_INVO_HANDLE (&icb);
+
+      status = LIB$GET_INVO_CONTEXT (invo_handle, &icb);
+      GIVEUP_ON_FAILURE (status);
+
+      chfctx = (CHFCTX *) icb.libicb$ph_chfctx_addr;
+
+      status = LIB$GET_PREV_INVO_CONTEXT (&icb);
+      GIVEUP_ON_FAILURE (status);
+
+      new_cfa = (ADDR) icb.libicb$q_ireg[30];      
+    }
+  else
+    {
+      /* The CFA to establish is the SP value on entry of the procedure
+	 designated by PV, which we compute as the corresponding frame base
+	 register value + frame size.  Note that the frame base may differ
+	 from CONTEXT->cfa, typically if the caller has performed dynamic
+	 stack allocations.  */
+      
+      int  base_reg  = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;
+      ADDR base_addr = ADDR_AT (CONTEXT->reg[base_reg]);
+      
+      new_cfa = base_addr + pv->pdsc$l_size;
+    }
+
+  /* State to compute the caller's CFA by adding an offset to the current
+     one in CONTEXT.  */
+  (FS)->cfa_how = CFA_REG_OFFSET;
+  (FS)->cfa_reg = __builtin_dwarf_sp_column ();
+  (FS)->cfa_offset = new_cfa - CONTEXT->cfa;
+
+  /* Regular unwind first, accounting for the register saves performed by
+     the procedure designated by PV.  */
+
+  switch (pkind)
+    {
+    case PDSC$K_KIND_FP_STACK:
+      {
+	/* The saved registers are all located in the Register Save Area,
+	   except for the procedure value register (R27) found at the frame
+	   base address.  */
+
+	int  base_reg  = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;
+	ADDR base_addr = ADDR_AT (CONTEXT->reg[base_reg]);
+	ADDR rsa_addr  = base_addr + pv->pdsc$w_rsa_offset;
+
+	if (eh_debug)
+	  printf ("FALLBACK: STACK frame procedure\n");
+
+	UPDATE_FS_FOR_CFA_GR (FS, 27, base_addr, new_cfa);
+
+	/* The first RSA entry is for the return address register, R26.  */
+
+	UPDATE_FS_FOR_CFA_GR (FS, 26, rsa_addr, new_cfa);
+	UPDATE_FS_FOR_CFA_GR (FS, RA_COLUMN, rsa_addr, new_cfa);
+
+	/* The following entries are for registers marked as saved according
+	   to ireg_mask.  */
+	for (i = 0, j = 0; i < 32; i++)
+	  if ((1 << i) & pv->pdsc$l_ireg_mask)
+	    UPDATE_FS_FOR_CFA_GR (FS, i, rsa_addr + 8 * ++j, new_cfa);
+	
+	/* ??? floating point registers ?  */
+
+	break;
+      }
+
+    case PDSC$K_KIND_FP_REGISTER:
+      {
+	if (eh_debug)
+	  printf ("FALLBACK: REGISTER frame procedure\n");
+
+	(FS)->regs.reg[RA_COLUMN].how = REG_SAVED_REG;
+	(FS)->regs.reg[RA_COLUMN].loc.reg = pv->pdsc$b_save_ra;
+	
+	(FS)->regs.reg[29].how = REG_SAVED_REG;
+	(FS)->regs.reg[29].loc.reg = pv->pdsc$b_save_fp;
+	
+	break;
+      }
+
+    default:
+      /* Should never reach here.  */
+      return 0;
+    }
+
+  /* If PV designates an exception dispatcher, we have to adjust the return
+     address column to get at the signal occurrence point, and account for
+     for what the CHF context contains.  */
+
+  if (DENOTES_EXC_DISPATCHER (pv))
+    {
+      /* The PC of the instruction causing the condition is available from the
+	 signal argument vector.  Extra saved register values are available
+	 from the mechargs array.  */
+
+      CHF$SIGNAL_ARRAY *sigargs
+	= (CHF$SIGNAL_ARRAY *) chfctx->chfctx$q_sigarglst;
+
+      CHF$MECH_ARRAY *mechargs
+	= (CHF$MECH_ARRAY *) chfctx->chfctx$q_mcharglst;
+
+      ADDR condpc_addr
+	= &((int *)(&sigargs->chf$l_sig_name)) [sigargs->chf$is_sig_args-2];
+
+      ADDR rei_frame_addr = mechargs->chf$q_mch_esf_addr;
+
+      /* Adjust the return address location.  */
+
+      UPDATE_FS_FOR_CFA_GR (FS, RA_COLUMN, condpc_addr, new_cfa);
+
+      /* The frame pointer at the condition point is available from the
+	 chf context directly.  */
+
+      UPDATE_FS_FOR_CFA_GR (FS, 29, &chfctx->chfctx$q_expt_fp, new_cfa);
+
+      /* Registers available from the mechargs array.  */
+
+      UPDATE_FS_FOR_CFA_GR (FS, 0, &mechargs->chf$q_mch_savr0, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 1, &mechargs->chf$q_mch_savr1, new_cfa);
+
+      UPDATE_FS_FOR_CFA_GR (FS, 16, &mechargs->chf$q_mch_savr16, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 17, &mechargs->chf$q_mch_savr17, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 18, &mechargs->chf$q_mch_savr18, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 19, &mechargs->chf$q_mch_savr19, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 20, &mechargs->chf$q_mch_savr20, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 21, &mechargs->chf$q_mch_savr21, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 22, &mechargs->chf$q_mch_savr22, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 23, &mechargs->chf$q_mch_savr23, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 24, &mechargs->chf$q_mch_savr24, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 25, &mechargs->chf$q_mch_savr25, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 26, &mechargs->chf$q_mch_savr26, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 27, &mechargs->chf$q_mch_savr27, new_cfa);
+      UPDATE_FS_FOR_CFA_GR (FS, 28, &mechargs->chf$q_mch_savr28, new_cfa);
+      
+      /* Registers R2 to R7 are available from the rei frame pointer.  */
+      
+      for (i = 2; i <= 7; i ++)
+	UPDATE_FS_FOR_CFA_GR (FS, i, rei_frame_addr+(i - 2)*8, new_cfa);
+      
+      /* ??? floating point registers ?  */
+    }
+
+  return 1;
+}
+
+
+
--- gcc/config/alpha/vms-gcc_shell_handler.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/alpha/vms-gcc_shell_handler.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,127 @@
+/* Copyright (C) 2005  Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* This file implements __gcc_shell_handler, the static VMS condition handler
+   used as the indirection wrapper around user level handlers installed with
+   establish_vms_condition_handler GCC builtin.
+
+   [ABI] in comments refers to the "HP OpenVMS calling standard" document
+   dated January 2005.  */
+
+#include <vms/chfdef.h>
+#include <vms/pdscdef.h>
+#include <vms/ssdef.h>
+
+typedef void * ADDR;
+typedef unsigned long long REG;
+
+#define REG_AT(addr) (*(REG *)(addr))
+
+/* Compute pointer to procedure descriptor (Procedure Value) from Frame
+   Pointer FP, according to the rules in [ABI-3.5.1 Current Procedure].  */
+#define PV_FOR(FP) \
+  (((FP) != 0) \
+    ? (((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP)) : 0)
+
+long
+__gcc_shell_handler (struct chf$signal_array *sig_arr,
+		     struct chf$mech_array *mech_arr);
+
+/* Helper for __gcc_shell_handler.  Fetch the pointer to procedure currently
+   registered as the VMS condition handler for the live function with a frame
+   pointer FP.  */
+
+static ADDR
+get_dyn_handler_pointer (REG fp)
+{
+  /* From the frame pointer we find the procedure descriptor, and fetch
+     the handler_data field from there.  This field contains the offset
+     from FP at which the address of the currently installed handler is
+     to be found.  */
+  
+  PDSCDEF * pd = PV_FOR (fp);
+  /* Procedure descriptor pointer for the live subprogram with FP as the frame
+     pointer, and to which _gcc_shell_handler is attached as a condition
+     handler.  */
+
+  REG handler_slot_offset;
+  /* Offset from FP at which the address of the currently established real
+     condition handler is to be found.  This offset is available from the
+     handler_data field of the procedure descriptor.  */
+
+  REG handler_data_offset;
+  /* The handler_data field position in the procedure descriptor, which
+     depends on the kind of procedure at hand.  */
+
+  switch (pd->pdsc$w_flags & 0xf)
+    {
+    case PDSC$K_KIND_FP_STACK:    /* [3.4.2 PD for stack frame procedures]  */
+      handler_data_offset = 40;
+      break;
+	
+    case PDSC$K_KIND_FP_REGISTER: /* [3.4.5 PD for reg frame procedures]  */
+      handler_data_offset = 32;
+      break;
+      
+    default:
+      handler_data_offset = 0;
+      break;
+    }
+
+  /* If we couldn't determine the handler_data field position, give up.  */
+  if (handler_data_offset == 0)
+    return 0;
+
+  /* Otherwise, fetch the fp offset at which the real handler address is to be
+     found, then fetch and return the latter in turn.  */
+     
+  handler_slot_offset = REG_AT ((REG)pd + handler_data_offset);
+
+  return (ADDR) REG_AT (fp + handler_slot_offset);
+}
+
+/* The static VMS condition handler for GCC code.  Fetch the address of the
+   currently established condition handler, then resignal if there is none or
+   call the handler with the VMS condition arguments.  */
+
+long
+__gcc_shell_handler (struct chf$signal_array *sig_arr,
+		     struct chf$mech_array *mech_arr)
+{
+  long ret;
+  long (*user_handler) (struct chf$signal_array *, struct chf$mech_array *);
+
+  user_handler = get_dyn_handler_pointer (mech_arr->chf$q_mch_frame);
+  if (!user_handler)
+    ret = SS$_RESIGNAL;
+  else
+    ret = user_handler (sig_arr, mech_arr);
+
+  return ret;
+}
+   
--- gcc/config/alpha/vms.h.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/config/alpha/vms.h	2007-12-04 15:14:14.000000000 -0800
@@ -1,5 +1,5 @@
 /* Output variables, constants and external declarations, for GNU compiler.
-   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2004, 2005
+   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2004
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -16,12 +16,16 @@ GNU General Public License for more deta
 
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
 
 #define TARGET_OBJECT_SUFFIX ".obj"
 #define TARGET_EXECUTABLE_SUFFIX ".exe"
 
+/* Alpha/VMS object format is not really Elf, but this makes compiling
+   crtstuff.c and dealing with shared library initialization much easier */
+#define OBJECT_FORMAT_ELF
+
 /* This enables certain macros in alpha.h, which will make an indirect
    reference to an external symbol an invalid address.  This needs to be
    defined before we include alpha.h, since it determines which macros
@@ -51,6 +55,8 @@ Boston, MA 02110-1301, USA.  */
 #undef TARGET_VERSION
 #define TARGET_VERSION fprintf (stderr, " (%s)", TARGET_NAME);           
 
+#define VMS_DEBUG_MAIN_POINTER "TRANSFER$BREAK$GO"
+
 #undef PCC_STATIC_STRUCT_RETURN
 
 /* "long" is 32 bits, but 64 bits for Ada.  */
@@ -63,6 +69,8 @@ Boston, MA 02110-1301, USA.  */
 #define POINTER_SIZE 32
 #define POINTERS_EXTEND_UNSIGNED 0
 
+#define HANDLE_SYSV_PRAGMA 1
+
 #define MAX_OFILE_ALIGNMENT 524288  /* 8 x 2^16 by DEC Ada Test CD40VRA */
 
 #undef FIXED_REGISTERS
@@ -139,7 +147,7 @@ Boston, MA 02110-1301, USA.  */
 { switch (FROM)								\
     {									\
     case FRAME_POINTER_REGNUM:						\
-      (OFFSET) = alpha_sa_size () + alpha_pv_save_size ();		\
+      (OFFSET) = ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ());\
       break;								\
     case ARG_POINTER_REGNUM:						\
       (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()	\
@@ -194,18 +202,27 @@ typedef struct {int num_args; enum avms_
      (CUM).num_args += ALPHA_ARG_SIZE (MODE, TYPE, NAMED);		\
     }
 
-/* ABI has stack checking, but it's broken.  */
-#undef STACK_CHECK_BUILTIN
-#define STACK_CHECK_BUILTIN 0
+#undef RETURN_IN_MEMORY
+#define RETURN_IN_MEMORY(TYPE) \
+  (TREE_CODE (TYPE) == ARRAY_TYPE || int_size_in_bytes(TYPE) > 8)
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+#undef  ASM_WEAKEN_LABEL
+#define ASM_WEAKEN_LABEL(FILE, NAME)                            \
+   do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME);  \
+        fputc ('\n', FILE); } while (0)
 
 #define LINK_SECTION_ASM_OP "\t.link"
 #define READONLY_DATA_SECTION_ASM_OP "\t.rdata"
 #define LITERALS_SECTION_ASM_OP "\t.literals"
 #define CTORS_SECTION_ASM_OP "\t.ctors"
 #define DTORS_SECTION_ASM_OP "\t.dtors"
+#define SDATA_SECTION_ASM_OP "\t.sdata"
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)              \
+   asm (SECTION_OP "\n\t.long " #FUNC"\n");
 
 #undef EXTRA_SECTIONS
-#define EXTRA_SECTIONS	in_link, in_literals
+#define EXTRA_SECTIONS	in_link, in_literals, in_sdata
 
 #undef EXTRA_SECTION_FUNCTIONS
 #define EXTRA_SECTION_FUNCTIONS					\
@@ -226,10 +243,20 @@ literals_section (void)						\
       fprintf (asm_out_file, "%s\n", LITERALS_SECTION_ASM_OP); 	\
       in_section = in_literals;					\
     }								\
+}                                                               \
+void								\
+sdata_section (void)						\
+{								\
+  if (in_section != in_sdata)				        \
+    {								\
+      fprintf (asm_out_file, "%s\n", SDATA_SECTION_ASM_OP); 	\
+      in_section = in_sdata;					\
+    }								\
 }
 
 extern void link_section (void);
 extern void literals_section (void);
+extern void sdata_section (void);
 
 #undef ASM_OUTPUT_ADDR_DIFF_ELT
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) gcc_unreachable ()
@@ -251,14 +278,9 @@ extern void literals_section (void);
 
 #define COMMON_ASM_OP "\t.comm\t"
 
-#undef ASM_OUTPUT_ALIGNED_COMMON
-#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)		\
-do {									\
-  fprintf ((FILE), "%s", COMMON_ASM_OP);				\
-  assemble_name ((FILE), (NAME));					\
-  fprintf ((FILE), "," HOST_WIDE_INT_PRINT_UNSIGNED ",%u\n", (SIZE), (ALIGN) / BITS_PER_UNIT);	\
-} while (0)
-
+#undef ASM_OUTPUT_ALIGNED_DECL_COMMON
+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \
+  vms_output_aligned_decl_common (FILE, DECL, NAME, SIZE, ALIGN)
 
 /* Output assembler code for a block containing the constant parts
    of a trampoline, leaving space for the variable parts.
@@ -269,12 +291,6 @@ do {									\
    use it for addressability of the two data items.  */
 
 #undef TRAMPOLINE_TEMPLATE
-#define TRAMPOLINE_TEMPLATE(FILE)		\
-{						\
-  fprintf (FILE, "\t.quad 0\n");		\
-  fprintf (FILE, "\t.linkage __tramp\n");	\
-  fprintf (FILE, "\t.quad 0\n");		\
-}
 
 /* Length in units of the trampoline for entering a nested function.  */
 
@@ -317,8 +333,66 @@ do {									\
   gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 8))
 
 #define LINK_EH_SPEC "vms-dwarf2eh.o%s "
+#define LINK_GCC_C_SEQUENCE_SPEC "%G"
+
+#ifdef IN_LIBGCC2
 
-#define MD_UNWIND_SUPPORT "config/alpha/vms-unwind.h"
+/* Get the definition for MD_FALLBACK_FRAME_STATE_FOR from a separate
+   file. This avoids having to recompile the world instead of libgcc only
+   when changes to this macro are exercised.  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR_SOURCE "config/alpha/vms-ehfb.h"
+
+#endif
+
+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) \
+  avms_asm_output_external (FILE, DECL, NAME)
+
+typedef struct crtl_name_spec
+{
+  const char *const name;
+  const char *deccname;
+  int referenced;
+} crtl_name_spec;
+
+#include "config/vms/vms-crtl.h"
+
+/* Alias CRTL names to 32/64bit DECCRTL functions. 
+   Fixme: This should do a binary search. */
+#define DO_CRTL_NAMES                                                      \
+  do                                                                       \
+    {                                                                      \
+      int i;                                                               \
+      static crtl_name_spec vms_crtl_names[] = CRTL_NAMES;                 \
+      static int malloc64_init = 0;                                        \
+                                                                           \
+      if ((malloc64_init == 0) && TARGET_MALLOC64)          		   \
+	{                                                                  \
+          for (i=0; vms_crtl_names [i].name; i++)                          \
+            {                                                              \
+	      if (strcmp ("calloc", vms_crtl_names [i].name) == 0)         \
+                vms_crtl_names [i].deccname = "decc$_calloc64";            \
+              else                                                         \
+	      if (strcmp ("malloc", vms_crtl_names [i].name) == 0)         \
+                vms_crtl_names [i].deccname = "decc$_malloc64";            \
+              else                                                         \
+	      if (strcmp ("realloc", vms_crtl_names [i].name) == 0)        \
+                vms_crtl_names [i].deccname = "decc$_realloc64";           \
+              else                                                         \
+	      if (strcmp ("strdup", vms_crtl_names [i].name) == 0)         \
+                vms_crtl_names [i].deccname = "decc$_strdup64";            \
+	    }                                                              \
+            malloc64_init = 1;                                             \
+        }                                                                  \
+      for (i=0; vms_crtl_names [i].name; i++)                              \
+	if (!vms_crtl_names [i].referenced &&                              \
+	    (strcmp (name, vms_crtl_names [i].name) == 0))                 \
+	  {                                                                \
+	    fprintf (file, "\t%s=%s\n",                        \
+		     name, vms_crtl_names [i].deccname);                   \
+	    vms_crtl_names [i].referenced = 1;                             \
+	  }                                                                \
+    } while (0)
 
 /* This is how to output an assembler line
    that says to advance the location counter
@@ -352,22 +426,18 @@ do {									\
 #undef ASM_FINAL_SPEC
 
 /* The VMS convention is to always provide minimal debug info
-   for a traceback unless specifically overridden.  Defaulting this here
-   is a kludge.  */
-
-#define OPTIMIZATION_OPTIONS(OPTIMIZE, OPTIMIZE_SIZE) \
-{                                                  \
-   write_symbols = VMS_DEBUG;                      \
-   debug_info_level = (enum debug_info_level) 1;   \
-}
+   for a traceback unless specifically overridden. */
 
-/* Override traceback debug info on -g0.  */
 #undef OVERRIDE_OPTIONS
-#define OVERRIDE_OPTIONS                           \
-{                                                  \
-   if (write_symbols == NO_DEBUG)                  \
-     debug_info_level = (enum debug_info_level) 0; \
-   override_options ();                            \
+#define OVERRIDE_OPTIONS                            \
+{                                                   \
+  if (write_symbols == NO_DEBUG                     \
+      && debug_info_level == DINFO_LEVEL_NONE)      \
+    {                                               \
+      write_symbols = VMS_DEBUG;                    \
+      debug_info_level = (enum debug_info_level) 1; \
+    }                                               \
+   override_options ();                             \
 }
 
 /* Link with vms-dwarf2.o if -g (except -g0). This causes the
@@ -377,26 +447,16 @@ do {									\
 %{g2:-g2 vms-dwarf2.o%s} %{g3:-g3 vms-dwarf2.o%s} %{shared} %{v} %{map}"
 
 #undef STARTFILE_SPEC
-#define STARTFILE_SPEC "%{!shared:%{mvms-return-codes:vcrt0.o%s} \
-%{!mvms-return-codes:pcrt0.o%s}}"
+#define STARTFILE_SPEC \
+"%{!shared:%{mvms-return-codes:vcrt0.o%s} %{!mvms-return-codes:pcrt0.o%s} \
+    crtbegin.o%s} \
+ %{!static:%{shared:crtbeginS.o%s}}"
 
-#undef LIB_SPEC
-#define LIB_SPEC "-lc"
+#define ENDFILE_SPEC \
+"%{!shared:crtend.o%s} %{!static:%{shared:crtendS.o%s}}"
 
 #define NAME__MAIN "__gccmain"
 #define SYMBOL__MAIN __gccmain
-
-#define MD_EXEC_PREFIX "/gnu/lib/gcc-lib/"
-#define MD_STARTFILE_PREFIX "/gnu/lib/gcc-lib/"
-
-/* Specify the list of include file directories.  */
-#define INCLUDE_DEFAULTS		   \
-{					   \
-  { "/gnu/lib/gcc-lib/include", 0, 0, 0 }, \
-  { "/gnu_gxx_include", 0, 1, 1 },	   \
-  { "/gnu_cc_include", 0, 0, 0 },	   \
-  { "/gnu/include", 0, 0, 0 },	           \
-  { 0, 0, 0, 0 }			   \
-}
+#define INIT_SECTION_ASM_OP "\t.section LIB$INITIALIZE,GBL,NOWRT"
 
 #define LONGLONG_STANDALONE 1
--- gcc/config/alpha/vms-ld.c.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-ld.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,764 +0,0 @@
-/* VMS linker wrapper.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
-   Free Software Foundation, Inc.
-   Contributed by Douglas B. Rupp (rupp@gnat.com).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-/* This program is a wrapper around the VMS linker.
-   It translates Unix style command line options into corresponding
-   VMS style qualifiers and then spawns the VMS linker.  */
-
-#include "config.h"
-#include "system.h"
-#include "coretypes.h"
-#include "tm.h"
-
-typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;
-
-#undef PATH_SEPARATOR
-#undef PATH_SEPARATOR_STR
-#define PATH_SEPARATOR ','
-#define PATH_SEPARATOR_STR ","
-
-/* Local variable declarations.  */
-
-/* File specification for vms-dwarf2.o.  */
-static char *vmsdwarf2spec = 0;
-
-/* File specification for vms-dwarf2eh.o.  */
-static char *vmsdwarf2ehspec = 0;
-
-/* verbose = 1 if -v passed.  */
-static int verbose = 0;
-
-/* save_temps = 1 if -save-temps passed.  */
-static int save_temps = 0;
-
-/* By default don't generate executable file if there are errors
-   in the link. Override with --noinhibit-exec.  */
-static int inhibit_exec = 1;
-
-/* debug = 1 if -g passed.  */
-static int debug = 0;
-
-/* By default prefer to link with shareable image libraries.
-   Override with -static.  */
-static int staticp = 0;
-
-/* By default generate an executable, not a shareable image library.
-   Override with -shared.  */
-static int share = 0;
-
-/* Remember if IDENTIFICATION given on command line.  */
-static int ident = 0;
-
-/* Keep track of arg translations.  */
-static int link_arg_max = -1;
-static const char **link_args = 0;
-static int link_arg_index = -1;
-
-/* Keep track of filenames */
-static char optfilefullname [267];
-static char *sharefilename = 0;
-static char *exefilename = 0;
-
-/* System search dir list. Leave blank since link handles this
-   internally.  */
-static char *system_search_dirs = "";
-
-/* Search dir list passed on command line (with -L).  */
-static char *search_dirs;
-
-/* Local function declarations.  */
-
-/* Add STR to the list of arguments to pass to the linker. Expand the list as
-   necessary to accommodate.  */
-static void addarg (const char *);
-
-/* Check to see if NAME is a regular file, i.e. not a directory */
-static int is_regular_file (char *);
-
-/* Translate a Unix syntax file specification FILESPEC into VMS syntax.
-   If indicators of VMS syntax found, return input string.  */
-static char *to_host_file_spec (char *);
-
-/* Locate the library named LIB_NAME in the set of paths PATH_VAL.  */
-static char *locate_lib (char *, char *);
-
-/* Given a library name NAME, i.e. foo,  Look for libfoo.lib and then
-   libfoo.a in the set of directories we are allowed to search in.  */
-static const char *expand_lib (char *);
-
-/* Preprocess the number of args P_ARGC in ARGV.
-   Look for special flags, etc. that must be handled first.  */
-static void preprocess_args (int *, char **);
-
-/* Preprocess the number of args P_ARGC in ARGV.  Look for
-   special flags, etc. that must be handled for the VMS linker.  */
-static void process_args (int *, char **);
-
-/* Action routine called by decc$to_vms. NAME is a file name or
-   directory name. TYPE is unused.  */
-static int translate_unix (char *, int);
-
-int main (int, char **);
-
-static void
-addarg (const char *str)
-{
-  int i;
-
-  if (++link_arg_index >= link_arg_max)
-    {
-      const char **new_link_args
-	= (const char **) xcalloc (link_arg_max + 1000, sizeof (char *));
-
-      for (i = 0; i <= link_arg_max; i++)
-	new_link_args [i] = link_args [i];
-
-      if (link_args)
-	free (link_args);
-
-      link_arg_max += 1000;
-      link_args = new_link_args;
-    }
-
-  link_args [link_arg_index] = str;
-}
-
-static char *
-locate_lib (char *lib_name, char *path_val)
-{
-  int lib_len = strlen (lib_name);
-  char *eptr, *sptr;
-
-  for (sptr = path_val; *sptr; sptr = eptr)
-    {
-      char *buf, *ptr;
-
-      while (*sptr == PATH_SEPARATOR)
-	sptr ++;
-
-      eptr = strchr (sptr, PATH_SEPARATOR);
-      if (eptr == 0)
-	eptr = strchr (sptr, 0);
-
-      buf = alloca ((eptr-sptr) + lib_len + 4 + 2);
-      strncpy (buf, sptr, eptr-sptr);
-      buf [eptr-sptr] = 0;
-      strcat (buf, "/");
-      strcat (buf, lib_name);
-      ptr = strchr (buf, 0);
-
-      if (debug || staticp)
-	{
-	  /* For debug or static links, look for shareable image libraries
-	     last.  */
-	  strcpy (ptr, ".a");
-	  if (is_regular_file (buf))
-	    return xstrdup (to_host_file_spec (buf));
-
-	  strcpy (ptr, ".olb");
-	  if (is_regular_file (buf))
-	    return xstrdup (to_host_file_spec (buf));
-
-	  strcpy (ptr, ".exe");
-	  if (is_regular_file (buf))
-	    return xstrdup (to_host_file_spec (buf));
-	}
-      else
-	{
-	  /* Otherwise look for shareable image libraries first.  */
-	  strcpy (ptr, ".exe");
-	  if (is_regular_file (buf))
-	    return xstrdup (to_host_file_spec (buf));
-
-	  strcpy (ptr, ".a");
-	  if (is_regular_file (buf))
-	    return xstrdup (to_host_file_spec (buf));
-
-	  strcpy (ptr, ".olb");
-	  if (is_regular_file (buf))
-	    return xstrdup (to_host_file_spec (buf));
-	}
-    }
-
-  return 0;
-}
-
-static const char *
-expand_lib (char *name)
-{
-  char *lib, *lib_path;
-
-  if (strcmp (name, "c") == 0)
-    /* IEEE VAX C compatible library for non-prefixed (e.g. no DECC$)
-       C RTL functions.  */
-    return "sys$library:vaxcrtltx.olb";
-
-  else if (strcmp (name, "m") == 0)
-    /* No separate library for math functions */
-    return "";
-
-  else
-    {
-      lib = xmalloc (strlen (name) + 14);
-
-      strcpy (lib, "lib");
-      strcat (lib, name);
-      lib_path = locate_lib (lib, search_dirs);
-
-      if (lib_path)
-	return lib_path;
-    }
-
-  fprintf (stderr,
-	   "Couldn't locate library: lib%s.exe, lib%s.a or lib%s.olb\n",
-	   name, name, name);
-
-  exit (1);
-}
-
-static int
-is_regular_file (char *name)
-{
-  int ret;
-  struct stat statbuf;
-
-  ret = stat (name, &statbuf);
-  return !ret && S_ISREG (statbuf.st_mode);
-}
-
-static void
-preprocess_args (int *p_argc, char **argv)
-{
-  int i;
-
-  for (i = 1; i < *p_argc; i++)
-    if (strlen (argv[i]) >= 6 && strncmp (argv[i], "-shared", 7) == 0)
-      share = 1;
-
-  for (i = 1; i < *p_argc; i++)
-    if (strcmp (argv[i], "-o") == 0)
-      {
-	char *buff, *ptr;
-	int out_len;
-	int len;
-
-	i++;
-	ptr = to_host_file_spec (argv[i]);
-	exefilename = xstrdup (ptr);
-	out_len = strlen (ptr);
-	buff = xmalloc (out_len + 18);
-
-	if (share)
-	  strcpy (buff, "/share=");
-	else
-	  strcpy (buff, "/exe=");
-
-	strcat (buff, ptr);
-	addarg (buff);
-
-	if (share)
-	  {
-	    sharefilename = xmalloc (out_len+5);
-	    if (ptr == strchr (argv[i], ']'))
-	      strcpy (sharefilename, ++ptr);
-	    else if (ptr == strchr (argv[i], ':'))
-	      strcpy (sharefilename, ++ptr);
-	    else if (ptr == strrchr (argv[i], '/'))
-	      strcpy (sharefilename, ++ptr);
-	    else
-	      strcpy (sharefilename, argv[i]);
-
-	    len = strlen (sharefilename);
-	    if (strncasecmp (&sharefilename[len-4], ".exe", 4) == 0)
-	      sharefilename[len-4] = 0;
-
-	    for (ptr = sharefilename; *ptr; ptr++)
-	      *ptr = TOUPPER (*ptr);
-	  }
-      }
-}
-
-static void
-process_args (int *p_argc, char **argv)
-{
-  int i;
-
-  for (i = 1; i < *p_argc; i++)
-    {
-      if (strlen (argv[i]) < 2)
-	continue;
-
-      if (strncmp (argv[i], "-L", 2) == 0)
-	{
-	  char *nbuff, *ptr;
-	  int new_len, search_dirs_len;
-
-	  ptr = &argv[i][2];
-	  new_len = strlen (ptr);
-	  search_dirs_len = strlen (search_dirs);
-
-	  nbuff = xmalloc (new_len + 1);
-	  strcpy (nbuff, ptr);
-
-	  /* Remove trailing slashes.  */
-	  while (new_len > 1 && nbuff [new_len - 1] == '/')
-	    {
-	      nbuff [new_len - 1] = 0;
-	      new_len--;
-	    }
-
-	  search_dirs = xrealloc (search_dirs, search_dirs_len + new_len + 2);
-	  if (search_dirs_len > 0)
-	    strcat (search_dirs, PATH_SEPARATOR_STR);
-
-	  strcat (search_dirs, nbuff);
-	  free (nbuff);
-	}
-
-      /* -v turns on verbose option here and is passed on to gcc.  */
-      else if (strcmp (argv[i], "-v") == 0)
-	verbose = 1;
-      else if (strcmp (argv[i], "-g0") == 0)
-	addarg ("/notraceback");
-      else if (strncmp (argv[i], "-g", 2) == 0)
-	{
-	  addarg ("/debug");
-	  debug = 1;
-	}
-      else if (strcmp (argv[i], "-static") == 0)
-	staticp = 1;
-      else if (strcmp (argv[i], "-map") == 0)
-	{
-	  char *buff, *ptr;
-
-	  buff = xmalloc (strlen (exefilename) + 5);
-	  strcpy (buff, exefilename);
-	  ptr = strchr (buff, '.');
-	  if (ptr)
-	    *ptr = 0;
-
-	  strcat (buff, ".map");
-	  addarg ("/map=");
-	  addarg (buff);
-	  addarg ("/full");
-	}
-      else if (strcmp (argv[i], "-save-temps") == 0)
-	save_temps = 1;
-      else if (strcmp (argv[i], "--noinhibit-exec") == 0)
-	inhibit_exec = 0;
-    }
-}
-
-/* The main program.  Spawn the VMS linker after fixing up the Unix-like flags
-   and args to be what the VMS linker wants.  */
-
-int
-main (int argc, char **argv)
-{
-  int i;
-  char cwdev [128], *devptr;
-  int devlen;
-  int optfd;
-  FILE *optfile;
-  char *cwd = getcwd (0, 1024);
-  char *optfilename;
-
-  devptr = strchr (cwd, ':');
-  devlen = (devptr - cwd) + 1;
-  strncpy (cwdev, cwd, devlen);
-  cwdev [devlen] = '\0';
-
-  search_dirs = xstrdup (system_search_dirs);
-
-  addarg ("link");
-
-  /* Pass to find args that have to be append first.  */
-  preprocess_args (&argc , argv);
-
-  /* Pass to find the rest of the args.  */
-  process_args (&argc , argv);
-
-  /* Create a temp file to hold args, otherwise we can easily exceed the VMS
-     command line length limits.  */
-  optfilename = alloca (strlen ("LDXXXXXX") + 1);
-  strcpy (optfilename, "LDXXXXXX");
-  optfd = mkstemp (optfilename);
-  getcwd (optfilefullname, 256, 1); /* VMS style cwd.  */
-  strcat (optfilefullname, optfilename);
-  strcat (optfilefullname, ".");
-  optfile = fdopen (optfd, "w");
-
-  /* Write out the IDENTIFICATION argument first so that it can be overridden
-     by an options file.  */
-  for (i = 1; i < argc; i++)
-    {
-      int arg_len = strlen (argv[i]);
-
-      if (arg_len > 6 && strncasecmp (argv[i], "IDENT=", 6) == 0)
-	{
-	  /* Comes from command line. If present will always appear before
-	     IDENTIFICATION=... and will override.  */
-
-	  if (!ident)
-	    ident = 1;
-	}
-      else if (arg_len > 15
-	       && strncasecmp (argv[i], "IDENTIFICATION=", 15) == 0)
-	{
-	  /* Comes from pragma Ident ().  */
-
-	  if (!ident)
-	    {
-	      fprintf (optfile, "case_sensitive=yes\n");
-	      fprintf (optfile, "IDENTIFICATION=\"%15.15s\"\n", &argv[i][15]);
-	      fprintf (optfile, "case_sensitive=NO\n");
-	      ident = 1;
-	    }
-	}
-    }
-
-  for (i = 1; i < argc; i++)
-    {
-      int arg_len = strlen (argv[i]);
-
-      if (strcmp (argv[i], "-o") == 0)
-	i++;
-      else if (arg_len > 2 && strncmp (argv[i], "-l", 2) == 0)
-	{
-	  const char *libname = expand_lib (&argv[i][2]);
-	  const char *ext;
-	  int len;
-
-	  if ((len = strlen (libname)) > 0)
-	    {
-	      char buff [256];
-
-	      if (len > 4 && strcasecmp (&libname [len-4], ".exe") == 0)
-		ext = "/shareable";
-	      else
-		ext = "/library";
-
-	      if (libname[0] == '[')
-		sprintf (buff, "%s%s", cwdev, libname);
-	      else
-		sprintf (buff, "%s", libname);
-
-	      fprintf (optfile, "%s%s\n", buff, ext);
-	    }
-	}
-
-      else if (strcmp (argv[i], "-v" ) == 0
-	       || strncmp (argv[i], "-g", 2 ) == 0
-	       || strcmp (argv[i], "-static" ) == 0
-	       || strcmp (argv[i], "-map" ) == 0
-	       || strcmp (argv[i], "-save-temps") == 0
-	       || strcmp (argv[i], "--noinhibit-exec") == 0
-	       || (arg_len > 2 && strncmp (argv[i], "-L", 2) == 0)
-	       || (arg_len >= 6 && strncmp (argv[i], "-share", 6) == 0))
-	;
-      else if (arg_len > 1 && argv[i][0] == '@')
-	{
-	  FILE *atfile;
-	  char *ptr, *ptr1;
-	  struct stat statbuf;
-	  char *buff;
-	  int len;
-
-	  if (stat (&argv[i][1], &statbuf))
-	    {
-	      fprintf (stderr, "Couldn't open linker response file: %s\n",
-		       &argv[i][1]);
-	      exit (1);
-	    }
-
-	  buff = xmalloc (statbuf.st_size + 1);
-	  atfile = fopen (&argv[i][1], "r");
-	  fgets (buff, statbuf.st_size + 1, atfile);
-	  fclose (atfile);
-
-	  len = strlen (buff);
-	  if (buff [len - 1] == '\n')
-	    {
-	      buff [len - 1] = 0;
-	      len--;
-	    }
-
-	  ptr = buff;
-
-	  do
-	  {
-	     ptr1 = strchr (ptr, ' ');
-	     if (ptr1)
-	       *ptr1 = 0;
-	     ptr = to_host_file_spec (ptr);
-	     if (ptr[0] == '[')
-	       fprintf (optfile, "%s%s\n", cwdev, ptr);
-	     else
-	       fprintf (optfile, "%s\n", ptr);
-	     ptr = ptr1 + 1;
-	  } while (ptr1);
-	}
-
-      /* Unix style file specs and VMS style switches look alike, so assume an
-	 arg consisting of one and only one slash, and that being first, is
-	 really a switch.  */
-      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))
-	addarg (argv[i]);
-      else if (arg_len > 4
-	       && strncasecmp (&argv[i][arg_len-4], ".OPT", 4) == 0)
-	{
-	  FILE *optfile1;
-	  char buff [256];
-
-	  optfile1 = fopen (argv[i], "r");
-	  while (fgets (buff, 256, optfile1))
-	    fputs (buff, optfile);
-
-	  fclose (optfile1);
-	}
-      else if (arg_len > 7 && strncasecmp (argv[i], "GSMATCH", 7) == 0)
-	fprintf (optfile, "%s\n", argv[i]);
-      else if (arg_len > 6 && strncasecmp (argv[i], "IDENT=", 6) == 0)
-	{
-	  /* Comes from command line and will override pragma.  */
-	  fprintf (optfile, "case_sensitive=yes\n");
-	  fprintf (optfile, "IDENT=\"%15.15s\"\n", &argv[i][6]);
-	  fprintf (optfile, "case_sensitive=NO\n");
-	  ident = 1;
-	}
-      else if (arg_len > 15
-	       && strncasecmp (argv[i], "IDENTIFICATION=", 15) == 0)
-	;
-      else
-	{
-	  /* Assume filename arg.  */
-	  const char *addswitch = "";
-	  char buff [256];
-	  int buff_len;
-	  int is_cld = 0;
-
-	  argv[i] = to_host_file_spec (argv[i]);
-	  arg_len = strlen (argv[i]);
-
-	  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], ".exe") == 0)
-	    addswitch = "/shareable";
-
-	  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], ".cld") == 0)
-	    {
-	      addswitch = "/shareable";
-	      is_cld = 1;
-	    }
-
-	  if (arg_len > 2 && strcasecmp (&argv[i][arg_len-2], ".a") == 0)
-	    addswitch = "/lib";
-
-	  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], ".olb") == 0)
-	    addswitch = "/lib";
-
-	  if (argv[i][0] == '[')
-	    sprintf (buff, "%s%s%s\n", cwdev, argv[i], addswitch);
-	  else if (strchr (argv[i], ':'))
-	    sprintf (buff, "%s%s\n", argv[i], addswitch);
-	  else
-	    sprintf (buff, "%s%s%s\n", cwd, argv[i], addswitch);
-
-	  buff_len = strlen (buff);
-
-	  if (buff_len >= 15
-	      && strcasecmp (&buff[buff_len - 15], "vms-dwarf2eh.o\n") == 0)
-	    vmsdwarf2ehspec = xstrdup (buff);
-	  else if (buff_len >= 13
-	      && strcasecmp (&buff[buff_len - 13],"vms-dwarf2.o\n") == 0)
-	    vmsdwarf2spec = xstrdup (buff);
-	  else if (is_cld)
-	    {
-	      addarg (buff);
-	      addarg (",");
-	    }
-	  else
-	    fprintf (optfile, buff);
-	}
-    }
-
-#if 0
-  if (share)
-    fprintf (optfile, "symbol_vector=(main=procedure)\n");
-#endif
-
-  if (vmsdwarf2ehspec)
-    {
-      fprintf (optfile, "case_sensitive=yes\n");
-      fprintf (optfile, "cluster=DWARF2eh,,,%s", vmsdwarf2ehspec);
-      fprintf (optfile, "collect=DWARF2eh,eh_frame\n");
-      fprintf (optfile, "case_sensitive=NO\n");
-    }
-
-  if (debug && vmsdwarf2spec)
-    {
-      fprintf (optfile, "case_sensitive=yes\n");
-      fprintf (optfile, "cluster=DWARF2debug,,,%s", vmsdwarf2spec);
-      fprintf (optfile, "collect=DWARF2debug,debug_abbrev,debug_aranges,-\n");
-      fprintf (optfile, " debug_frame,debug_info,debug_line,debug_loc,-\n");
-      fprintf (optfile, " debug_macinfo,debug_pubnames,debug_str,-\n");
-      fprintf (optfile, " debug_zzzzzz\n");
-      fprintf (optfile, "case_sensitive=NO\n");
-    }
-
-  if (debug && share)
-    {
-      fprintf (optfile, "case_sensitive=yes\n");
-      fprintf (optfile, "symbol_vector=(-\n");
-      fprintf (optfile,
-	       "%s$DWARF2.DEBUG_ABBREV/$dwarf2.debug_abbrev=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile,
-	       "%s$DWARF2.DEBUG_ARANGES/$dwarf2.debug_aranges=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile, "%s$DWARF2.DEBUG_FRAME/$dwarf2.debug_frame=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile, "%s$DWARF2.DEBUG_INFO/$dwarf2.debug_info=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile, "%s$DWARF2.DEBUG_LINE/$dwarf2.debug_line=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile, "%s$DWARF2.DEBUG_LOC/$dwarf2.debug_loc=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile,
-	       "%s$DWARF2.DEBUG_MACINFO/$dwarf2.debug_macinfo=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile,
-	       "%s$DWARF2.DEBUG_PUBNAMES/$dwarf2.debug_pubnames=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile, "%s$DWARF2.DEBUG_STR/$dwarf2.debug_str=DATA,-\n",
-	       sharefilename);
-      fprintf (optfile, "%s$DWARF2.DEBUG_ZZZZZZ/$dwarf2.debug_zzzzzz=DATA)\n",
-	       sharefilename);
-      fprintf (optfile, "case_sensitive=NO\n");
-    }
-
-  fclose (optfile);
-  addarg (optfilefullname);
-  addarg ("/opt");
-
-  addarg (NULL);
-
-  if (verbose)
-    {
-      int i;
-
-      for (i = 0; i < link_arg_index; i++)
-	printf ("%s ", link_args [i]);
-      putchar ('\n');
-    }
-
-  {
-    int i;
-    int len = 0;
-
-    for (i = 0; link_args[i]; i++)
-      len = len + strlen (link_args[i]) + 1;
-
-    {
-      char *allargs = (char *) alloca (len + 1);
-      Descr cmd;
-      int status;
-      int status1 = 1;
-
-      for (i = 0; i < len + 1; i++)
-	allargs [i] = 0;
-
-      for (i = 0; link_args [i]; i++)
-	{
-	  strcat (allargs, link_args [i]);
-	  strcat (allargs, " ");
-	}
-
-      cmd.adr = allargs;
-      cmd.len = len;
-      cmd.mbz = 0;
-
-      i = LIB$SPAWN (&cmd, 0, 0, 0, 0, 0, &status);
-      if ((i & 1) != 1)
-	{
-	  LIB$SIGNAL (i);
-	  exit (1);
-	}
-
-      if (debug && !share)
-	{
-	  strcpy (allargs, "@gnu:[bin]set_exe ");
-	  strcat (allargs, exefilename);
-	  strcat (allargs, " /nodebug /silent");
-	  len = strlen (allargs);
-	  cmd.adr = allargs;
-	  cmd.len = len;
-	  cmd.mbz = 0;
-
-	  if (verbose)
-	    printf (allargs);
-
-	  i = LIB$SPAWN (&cmd, 0, 0, 0, 0, 0, &status1);
-
-	  if ((i & 1) != 1)
-	    {
-	      LIB$SIGNAL (i);
-	      exit (1);
-	    }
-	}
-
-      if (!save_temps)
-	remove (optfilefullname);
-
-      if ((status & 1) == 1 && (status1 & 1) == 1)
-	exit (0);
-
-      if (exefilename && inhibit_exec == 1)
-	remove (exefilename);
-
-      exit (1);
-    }
-  }
-}
-
-static char new_host_filespec [255];
-static char filename_buff [256];
-
-static int
-translate_unix (char *name, int type ATTRIBUTE_UNUSED)
-{
-  strcpy (filename_buff, name);
-  return 0;
-}
-
-static char *
-to_host_file_spec (char *filespec)
-{
-  strcpy (new_host_filespec, "");
-  if (strchr (filespec, ']') || strchr (filespec, ':'))
-    strcpy (new_host_filespec, filespec);
-  else
-    {
-      decc$to_vms (filespec, translate_unix, 1, 1);
-      strcpy (new_host_filespec, filename_buff);
-    }
-
-  return new_host_filespec;
-}
--- gcc/config/alpha/vms-psxcrt0-64.c.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-psxcrt0-64.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,128 +0,0 @@
-/* VMS 64bit crt0 returning Unix style condition codes .
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   Contributed by Douglas B. Rupp (rupp@gnat.com).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-In addition to the permissions in the GNU General Public License, the
-Free Software Foundation gives you unlimited permission to link the
-compiled version of this file into combinations with other programs,
-and to distribute those combinations without any restriction coming
-from the use of this file.  (The General Public License restrictions
-do apply in other respects; for example, they cover modification of
-the file, and distribution when not linked into a combine
-executable.)
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-#if !defined(__DECC)
-You Lose! This file can only be compiled with DEC C.
-#else
-
-/* This file can only be compiled with DEC C, due to the call to
-   lib$establish and the pragmas pointer_size.  */
-
-#pragma __pointer_size short
-
-#include <stdlib.h>
-#include <string.h>
-#include <ssdef.h>
-#include <stsdef.h>
-#include <errnodef.h>
-
-extern void decc$main ();
-extern int main ();
-
-static int
-handler (sigargs, mechargs)
-     void *sigargs;
-     void *mechargs;
-{
-  return SS$_RESIGNAL;
-}
-
-int
-__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
-     void *arg1, *arg2, *arg3;
-     void *image_file_desc;
-     void *arg5, *arg6)
-{
-  int argc;
-  char **argv;
-  char **envp;
-
-#pragma __pointer_size long
-
-  int i;
-  char **long_argv;
-  char **long_envp;
-  int status;
-
-#pragma __pointer_size short
-
-  lib$establish (handler);
-  decc$main (arg1, arg2, arg3, image_file_desc,
-	     arg5, arg6, &argc, &argv, &envp);
-
-#pragma __pointer_size long
-
-  /* Reallocate argv with 64 bit pointers.  */
-  long_argv = (char **) malloc (sizeof (char *) * (argc + 1));
-
-  for (i = 0; i < argc; i++)
-    long_argv[i] = strdup (argv[i]);
-
-  long_argv[argc] = (char *) 0;
-
-  long_envp = (char **) malloc (sizeof (char *) * 5);
-
-  for (i = 0; envp[i]; i++)
-    long_envp[i] = strdup (envp[i]);
-
-  long_envp[i] = (char *) 0;
-
-#pragma __pointer_size short
-
-  status = main (argc, long_argv, long_envp);
-
-  /* Map into a range of 0 - 255.  */
-  status = status & 255;
-
-  if (status > 0)
-    {
-      int save_status = status;
-
-      status = C$_EXIT1 + ((status - 1) << STS$V_MSG_NO);
-
-      /* An exit failure status requires a "severe" error.  All status values
-	 are defined in errno with a successful (1) severity but can be
-	 changed to an error (2) severity by adding 1.  In addition for
-	 compatibility with UNIX exit() routines we inhibit a run-time error
-	 message from being generated on exit(1).  */
-
-      if (save_status == 1)
-	{
-	  status++;
-	  status |= STS$M_INHIB_MSG;
-	}
-    }
-
-  if (status == 0)
-    status = SS$_NORMAL;
-
-  return status;
-}
-#endif
--- gcc/config/alpha/vms-psxcrt0.c.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/vms-psxcrt0.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,99 +0,0 @@
-/* VMS crt0 returning Unix style condition codes .
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   Contributed by Douglas B. Rupp (rupp@gnat.com).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-In addition to the permissions in the GNU General Public License, the
-Free Software Foundation gives you unlimited permission to link the
-compiled version of this file into combinations with other programs,
-and to distribute those combinations without any restriction coming
-from the use of this file.  (The General Public License restrictions
-do apply in other respects; for example, they cover modification of
-the file, and distribution when not linked into a combine
-executable.)
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-#if !defined(__DECC)
-You Lose! This file can only be compiled with DEC C.
-#else
-
-/* This file can only be compiled with DEC C, due to the call to
-   lib$establish.  */
-
-#include <stdlib.h>
-#include <string.h>
-#include <ssdef.h>
-#include <stsdef.h>
-#include <errnodef.h>
-
-extern void decc$main ();
-extern int main ();
-
-static int
-handler (sigargs, mechargs)
-     void *sigargs;
-     void *mechargs;
-{
-  return SS$_RESIGNAL;
-}
-
-int
-__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
-     void *arg1, *arg2, *arg3;
-     void *image_file_desc;
-     void *arg5, *arg6;
-{
-  int argc;
-  char **argv;
-  char **envp;
-  int status;
-
-  lib$establish (handler);
-  decc$main (arg1, arg2, arg3, image_file_desc, arg5, arg6,
-	     &argc, &argv, &envp);
-
-  status = main (argc, argv, envp);
-
-  /* Map into a range of 0 - 255.  */
-  status = status & 255;
-
-  if (status > 0)
-    {
-      int save_status = status;
-
-      status = C$_EXIT1 + ((status - 1) << STS$V_MSG_NO);
-
-      /* An exit failure status requires a "severe" error
-	 All status values are defined in errno with a successful
-	 (1) severity but can be changed to an error (2) severity by adding 1.
-	 In addition for compatibility with UNIX exit() routines we inhibit
-	 a run-time error message from being generated on exit(1).  */
-
-      if (save_status == 1)
-	{
-	  status++;
-	  status |= STS$M_INHIB_MSG;
-	}
-    }
-
-  if (status == 0)
-    status = SS$_NORMAL;
-
-  return status;
-}
-#endif
--- gcc/config/alpha/vms_tramp.asm.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms_tramp.asm	2007-12-04 15:14:14.000000000 -0800
@@ -25,8 +25,8 @@ GNU General Public License for more deta
 
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
 
 ;# Alpha OpenVMS trampoline
 ;#
--- gcc/config/alpha/vms-unwind.h.0	2005-11-19 10:37:43.000000000 -0800
+++ gcc/config/alpha/vms-unwind.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,72 +0,0 @@
-/* DWARF2 EH unwinding support for Alpha VMS.
-   Copyright (C) 2004 Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-#include <pdscdef.h>
-
-#define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state
-
-static _Unwind_Reason_Code
-alpha_fallback_frame_state (struct _Unwind_Context *context,
-			    _Unwind_FrameState *fs)
-{
-  PDSCDEF *pv = *((PDSCDEF **) context->reg [29]);
-
-  if (pv && ((long) pv & 0x7) == 0) /* low bits 0 means address */
-    pv = *(PDSCDEF **) pv;
-
-  if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_STACK))
-    {
-      int i, j;
-
-      fs->cfa_offset = pv->pdsc$l_size;
-      fs->cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;
-      fs->retaddr_column = 26;
-      fs->cfa_how = CFA_REG_OFFSET;
-      fs->regs.reg[27].loc.offset = -pv->pdsc$l_size;
-      fs->regs.reg[27].how = REG_SAVED_OFFSET;
-      fs->regs.reg[26].loc.offset
-	= -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset);
-      fs->regs.reg[26].how = REG_SAVED_OFFSET;
-
-      for (i = 0, j = 0; i < 32; i++)
-	if (1<<i & pv->pdsc$l_ireg_mask)
-	  {
-	    fs->regs.reg[i].loc.offset
-	      = -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset - 8 * ++j);
-	    fs->regs.reg[i].how = REG_SAVED_OFFSET;
-	  }
-
-      return _URC_NO_REASON;
-    }
-  else if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_REGISTER))
-    {
-      fs->cfa_offset = pv->pdsc$l_size;
-      fs->cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;
-      fs->retaddr_column = 26;
-      fs->cfa_how = CFA_REG_OFFSET;
-      fs->regs.reg[26].loc.reg = pv->pdsc$b_save_ra;
-      fs->regs.reg[26].how = REG_SAVED_REG;
-      fs->regs.reg[29].loc.reg = pv->pdsc$b_save_fp;
-      fs->regs.reg[29].how = REG_SAVED_REG;
-
-      return _URC_NO_REASON;
-    }
-  return _URC_END_OF_STACK;
-}
--- gcc/config/alpha/xm-vms.h.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/xm-vms.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,57 +0,0 @@
-/* Configuration for GNU C-compiler for openVMS/Alpha.
-   Copyright (C) 1996, 1997, 2001, 2004 Free Software Foundation, Inc.
-   Contributed by Klaus Kaempf (kkaempf@progis.de).
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to
-the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.  */
-
-/* A couple of conditionals for execution machine are controlled here.  */
-#ifndef VMS
-#define VMS
-#endif
-
-/* Define a local equivalent (sort of) for unlink */
-#define unlink remove
-
-/* Causes exit() to be redefined to __posix_exit() and
-   Posix compatible failure and success codes to be used */
-#define _POSIX_EXIT 1
-
-/* Open files in stream mode if not otherwise explicitly specified */
-#define __UNIX_FOPEN 1
-
-/* Write to stdout using fputc to avoid record terminators in pipes */
-#define __UNIX_FWRITE 1
-
-#define STDC_HEADERS 1
-
-#define HOST_EXECUTABLE_SUFFIX ".exe"
-#define HOST_OBJECT_SUFFIX ".obj"
-
-#define DUMPFILE_FORMAT "_%02d_"
-
-#define DELETE_IF_ORDINARY(NAME,ST,VERBOSE_FLAG)           \
-do                                                         \
-  {                                                        \
-    while (stat (NAME, &ST) >= 0 && S_ISREG (ST.st_mode))  \
-      if (unlink (NAME) < 0)                               \
-	{                                                  \
-	  if (VERBOSE_FLAG)                                \
-	    perror_with_name (NAME);                       \
-	  break;                                           \
-	}                                                  \
-  } while (0)
--- gcc/config/alpha/x-vms.0	2005-11-19 10:37:44.000000000 -0800
+++ gcc/config/alpha/x-vms	1969-12-31 16:00:00.000000000 -0800
@@ -1,21 +0,0 @@
-# Under VMS, directory names cannot contain dots.
-version:=$(shell echo $(BASEVER_c) | sed -e 's/\./_/g')
-
-libsubdir=$(libdir)/gcc-lib
-
-# Rules for linker and compiler wrappers.  These are only useful on
-# a VMS host.
-EXTRA_PROGRAMS=ld.exe decc.exe
-vms-ld.o : $(srcdir)/config/alpha/vms-ld.c
-	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
-ld.exe : vms-ld.o
-	$(CC) -o $@ vms-ld.o ../libiberty/libiberty.a
-
-vms-cc.o : $(srcdir)/config/alpha/vms-cc.c
-	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
-decc.exe : vms-cc.o
-	$(CC) -o $@ vms-cc.o ../libiberty/libiberty.a
-
-# These extra parts can only be compiled on a VMS host and are only needed
-# on a VMS target.  The rules are in t-vms.
-VMS_EXTRA_PARTS=vcrt0.o pcrt0.o
--- gcc/config/ia64/crtinit.asm.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/crtinit.asm	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1 @@
+	.global LIB$INITIALIZE#
--- gcc/config/ia64/fde-glibc.c.0	2005-11-19 10:37:49.000000000 -0800
+++ gcc/config/ia64/fde-glibc.c	2007-12-04 15:14:14.000000000 -0800
@@ -148,7 +148,7 @@ _Unwind_IteratePhdrCallback (struct dl_p
 
 struct unw_table_entry *
 _Unwind_FindTableEntry (void *pc, unsigned long *segment_base,
-                        unsigned long *gp)
+                        unsigned long *gp, struct unw_table_entry *ent)
 {
   struct unw_ia64_callback_data data;
 
--- gcc/config/ia64/fde-vms.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/fde-vms.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,160 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   Contributed by Douglas B Rupp <rupp@gnat.com>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+/* Locate the FDE entry for a given address, using VMS Starlet routines
+   to avoid register/deregister calls at DSO load/unload.  */
+
+#include "tconfig.h"
+#include "tsystem.h"
+#include "coretypes.h"
+#include "tm.h"
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "unwind-ia64.h"
+
+#define __int64 long
+#include <vms/ossddef.h>
+#ifndef SS$_NORMAL
+#define SS$_NORMAL 1
+#endif
+
+typedef struct
+{
+  unsigned long start_offset;
+  unsigned long end_offset;
+  unsigned long info_offset;
+  unsigned long gp_value;
+}  vms_unw_table_entry;
+
+typedef unsigned long long uqword;
+
+/* ENTRY is the unwind table entry found for a PC part of call chain we're
+   unwinding through.  Return whether we should force the generic unwinder
+   to resort to "fallback" processing.  */
+   
+static int
+force_fallback_processing_for (void * pc, vms_unw_table_entry * entry)
+{
+  static int eh_debug = -1;
+
+  uqword * unw_info_block = (uqword *)entry->info_offset;
+  uqword header = *unw_info_block;
+
+  /* We need to force fallback processing in two cases:
+
+     1/ The exception dispatch frame, since only our fallback
+        processing knows how to properly unwind through it, and
+
+     2/ A bottom of stack frame, since only our fallback processing
+        will ensure we don't try to unwind further past it, which
+        would get us into unknown territory and likely cause a severe
+        crash along the way.
+
+     The two cases are indicated by non-default values for specific
+     bits in the OS Specific Data (OSSD) General Information block
+     associated with such frames.  */
+
+  ossddef * ossd;
+
+  if (eh_debug == -1)
+    {
+      char * EH_DEBUG = getenv ("EH_DEBUG");
+      eh_debug = EH_DEBUG ? atoi (EH_DEBUG) : 0;
+    }
+
+  if (eh_debug)
+    {
+      printf ("pc @ 0x%p, block @ 0x%p, header = 0x%016llx\n",
+	      pc, unw_info_block, header);
+      printf ("mode = %d, length = %ld, handler = %d\n",
+	      (int)UNW_IVMS_MODE (header), UNW_LENGTH (header),
+	      UNW_FLAG_EHANDLER (header) || UNW_FLAG_EHANDLER (header));
+    }
+
+  /* An OSSD block is there for IVMS_MODE == 3 only.  */
+  if (UNW_IVMS_MODE (header) != 3)
+    return 0;
+
+  /* The OSSD block is found past the header, unwind descriptor area
+     and condition handler pointer, if any.  */  
+  ossd = (ossddef *)
+    /* Beware: uqword pointer arithmetic below */
+    (unw_info_block
+     + 1
+     + UNW_LENGTH (header)
+     + (UNW_FLAG_EHANDLER (header) || UNW_FLAG_EHANDLER (header)));
+
+  /* "A General Information segment may be omitted if all of its fields
+      would have their default values.  If a General Information segment
+      is present, it must be the first in the OSSD area."  So ...  */
+  
+  if (eh_debug)
+    printf ("ossd @ 0x%p\n", ossd);
+      
+  if (eh_debug && ossd->ossd$v_type == OSSD$K_GENERAL_INFO)
+    printf ("exc_frame = %d - bot_frame = %d - base_frame = %d\n",
+	    ossd->ossd$v_exception_frame, 
+	    ossd->ossd$v_bottom_of_stack,
+	    ossd->ossd$v_base_frame);
+				
+  return
+    ossd->ossd$v_type == OSSD$K_GENERAL_INFO
+    && (ossd->ossd$v_exception_frame
+	|| ossd->ossd$v_bottom_of_stack || ossd->ossd$v_base_frame);
+}
+
+/* Return a pointer to the unwind table entry for the function
+   containing PC, 0 if we cannot find an entry or if the one we find
+   calls for fallback processing.  */
+
+struct unw_table_entry *
+_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,
+                        unsigned long *gp, struct unw_table_entry *ent)
+{
+  vms_unw_table_entry vueblock;
+
+  if (SYS$GET_UNWIND_ENTRY_INFO (pc, &vueblock, 0) != SS$_NORMAL)
+    return 0;
+
+  /* If there is no unwind information, use fallback.  */
+  if (vueblock.info_offset == 0)
+    return 0;
+
+  /* If we need to force fallback processing, just pretend there is
+     no entry.  */
+  if (force_fallback_processing_for (pc, &vueblock))
+    return 0;
+
+  *segment_base = 0; /* ??? Fixme. ??? */
+  *gp = vueblock.gp_value;
+  ent->start_offset = vueblock.start_offset;
+  ent->end_offset = vueblock.end_offset;
+  ent->info_offset = vueblock.info_offset;
+
+  return ent;
+}
--- gcc/config/ia64/ia64.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/config/ia64/ia64.c	2007-12-04 15:14:14.000000000 -0800
@@ -42,6 +42,7 @@ Boston, MA 02110-1301, USA.  */
 #include "function.h"
 #include "ggc.h"
 #include "basic-block.h"
+#include "libfuncs.h"
 #include "toplev.h"
 #include "sched-int.h"
 #include "timevar.h"
@@ -255,6 +256,8 @@ static void ia64_sysv4_init_libfuncs (vo
      ATTRIBUTE_UNUSED;
 static void ia64_vms_init_libfuncs (void)
      ATTRIBUTE_UNUSED;
+static bool ia64_vms_valid_pointer_mode (enum machine_mode mode)
+     ATTRIBUTE_UNUSED;
 
 static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);
 static void ia64_encode_section_info (tree, rtx, int);
@@ -382,14 +385,14 @@ static const struct attribute_spec ia64_
 #define TARGET_ASM_OUTPUT_DWARF_DTPREL ia64_output_dwarf_dtprel
 #endif
 
-/* ??? ABI doesn't allow us to define this.  */
-#if 0
+/* ??? Non VMS ABI doesn't allow us to define this.  */
+#if TARGET_ABI_OPEN_VMS
 #undef TARGET_PROMOTE_FUNCTION_ARGS
 #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true
 #endif
 
-/* ??? ABI doesn't allow us to define this.  */
-#if 0
+/* ??? Non VMS ABI doesn't allow us to define this.  */
+#if TARGET_ABI_OPEN_VMS
 #undef TARGET_PROMOTE_FUNCTION_RETURN
 #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true
 #endif
@@ -400,6 +403,11 @@ static const struct attribute_spec ia64_
 #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true
 #endif
 
+#if TARGET_ABI_OPEN_VMS
+#undef TARGET_VALID_POINTER_MODE
+#define TARGET_VALID_POINTER_MODE ia64_vms_valid_pointer_mode
+#endif
+
 #undef TARGET_STRUCT_VALUE_RTX
 #define TARGET_STRUCT_VALUE_RTX ia64_struct_value_rtx
 #undef TARGET_RETURN_IN_MEMORY
@@ -1935,6 +1943,10 @@ ia64_expand_call (rtx retval, rtx addr, 
 
   if (sibcall_p)
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), b0);
+
+  if (TARGET_ABI_OPEN_VMS)
+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn),
+	     gen_rtx_REG (DImode, GR_REG (25)));
 }
 
 void
@@ -3427,6 +3439,28 @@ ia64_expand_prologue (void)
   finish_spill_pointers ();
 }
 
+/* Output the textual info surrounding the prologue.  */
+
+void
+ia64_start_function (FILE *file, const char *fnname,
+		     tree decl ATTRIBUTE_UNUSED)
+{
+#if TARGET_ABI_OPEN_VMS
+  if (vms_debug_main
+      && strncmp (vms_debug_main, fnname, strlen (vms_debug_main)) == 0)
+    {
+      targetm.asm_out.globalize_label (asm_out_file, VMS_DEBUG_MAIN_POINTER);
+      ASM_OUTPUT_DEF (asm_out_file, VMS_DEBUG_MAIN_POINTER, fnname);
+      vms_debug_main = NULL;
+    }
+#endif
+
+  fputs ("\t.proc ", file);
+  assemble_name (file, fnname);
+  fputc ('\n', file);
+  ASM_OUTPUT_LABEL (file, fnname);
+}
+
 /* Called after register allocation to add any instructions needed for the
    epilogue.  Using an epilogue insn is favored compared to putting all of the
    instructions in output_function_prologue(), since it allows the scheduler
@@ -3954,7 +3988,7 @@ ia64_dbx_register_number (int regno)
 void
 ia64_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)
 {
-  rtx addr_reg, eight = GEN_INT (8);
+  rtx reg, addr_reg, eight = GEN_INT (8);
 
   /* The Intel assembler requires that the global __ia64_trampoline symbol
      be declared explicitly */
@@ -3981,8 +4015,18 @@ ia64_initialize_trampoline (rtx addr, rt
 
   /* The first two words are the fake descriptor:
      __ia64_trampoline, ADDR+16.  */
-  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
-		  gen_rtx_SYMBOL_REF (Pmode, "__ia64_trampoline"));
+  reg = gen_reg_rtx (Pmode);
+  emit_move_insn (reg, gen_rtx_SYMBOL_REF (Pmode, "__ia64_trampoline"));
+#if TARGET_ABI_OPEN_VMS
+  /* HP decided to break the ELF ABI on VMS (to deal with an ambiguity in
+     their Macro-32 compiler) and changed the semantics of the LTOFF22
+     relocation for functions to make it identical to LTOFF_FPTR22 for
+     functions. So, unlike Linux, on VMS the destination operand will get
+     the function descriptor instead of the bare code address, the latter
+     being what we want, so an extra dereference is needed.  */
+  emit_move_insn (reg, gen_rtx_MEM (Pmode, reg));
+#endif
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), reg);
   emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
 
   emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
@@ -3996,6 +4040,51 @@ ia64_initialize_trampoline (rtx addr, rt
   /* The fourth word is the static chain.  */
   emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), static_chain);
 }
+
+void
+ia64_vms_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)
+{
+  rtx addr_reg, eight = GEN_INT (8);
+
+  /* The Intel assembler requires that the global symbols
+     be declared explicitly */
+  if (!TARGET_GNU_AS)
+    {
+      static bool declared_ia64_vms_trampoline = false;
+
+      if (!declared_ia64_vms_trampoline)
+	{
+	  declared_ia64_vms_trampoline = true;
+	  fputs ("\t.global\tOTS$JUMP_TO_BPV\n", asm_out_file);
+	}
+    }
+
+  /* Load up our iterator.  */
+  addr_reg = gen_reg_rtx (Pmode);
+  emit_move_insn (addr_reg, addr);
+
+  /* The first two words are the fake descriptor:
+     OTS$JUMP_TO_BPV, pseudo GP.  */
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
+		  gen_rtx_SYMBOL_REF (Pmode, "OTS$JUMP_TO_BPV"));
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
+		  copy_to_reg (plus_constant (addr, 0)));
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  /* The fourth word is the target descriptor.  */
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), fnaddr);
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
+		  gen_rtx_REG (DImode, GR_REG(1)));
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  /* The sixth word is the static chain.  */
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), static_chain);
+}
 
 /* Do any needed setup for a variadic function.  CUM has not been updated
    for the last named argument which has type TYPE and mode MODE.
@@ -4164,6 +4253,19 @@ ia64_function_arg (CUMULATIVE_ARGS *cum,
   int offset = ia64_function_arg_offset (cum, type, words);
   enum machine_mode hfa_mode = VOIDmode;
 
+  if (TARGET_ABI_OPEN_VMS && mode == VOIDmode && type == void_type_node
+      && named == 1 && incoming == 0)
+    {
+      unsigned HOST_WIDE_INT regval = cum->words;
+      int i;
+
+      for (i = 0; i < 8; i++)
+	regval |= ((int) cum->atypes[i]) << (i * 3 + 8);
+
+      emit_move_insn (gen_rtx_REG (DImode, GR_REG (25)),
+		      GEN_INT (regval));
+    }
+
   /* If all argument slots are used, then it must go on the stack.  */
   if (cum->words + offset >= MAX_ARGUMENT_SLOTS)
     return 0;
@@ -4345,6 +4447,20 @@ ia64_arg_partial_bytes (CUMULATIVE_ARGS 
   return (MAX_ARGUMENT_SLOTS - cum->words - offset) * UNITS_PER_WORD;
 }
 
+enum ivms_arg_type
+ia64_arg_type (enum machine_mode mode)
+{
+  switch (mode)
+    {
+    case SFmode:
+      return FS;
+    case DFmode:
+      return FT;
+    default:
+      return I64;
+    }
+}
+
 /* Update CUM to point after this argument.  This is patterned after
    ia64_function_arg.  */
 
@@ -4358,8 +4474,12 @@ ia64_function_arg_advance (CUMULATIVE_AR
 
   /* If all arg slots are already full, then there is nothing to do.  */
   if (cum->words >= MAX_ARGUMENT_SLOTS)
-    return;
+    {
+      cum->words += words + offset;
+      return;
+    }
 
+  cum->atypes[cum->words] = ia64_arg_type (mode);
   cum->words += words + offset;
 
   /* Check for and handle homogeneous FP aggregates.  */
@@ -4547,6 +4667,7 @@ ia64_function_value (tree valtype, tree 
 {
   enum machine_mode mode;
   enum machine_mode hfa_mode;
+  int unsignedp ATTRIBUTE_UNUSED;
 
   mode = TYPE_MODE (valtype);
   hfa_mode = hfa_element_mode (valtype, 0);
@@ -4617,6 +4738,11 @@ ia64_function_value (tree valtype, tree 
 	  return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));
 	}
 
+#if TARGET_ABI_OPEN_VMS
+      if (! AGGREGATE_TYPE_P (valtype))
+	PROMOTE_FUNCTION_MODE (mode, unsignedp, valtype);
+#endif
+
       return gen_rtx_REG (mode, GR_RET_FIRST);
     }
 }
@@ -5199,6 +5325,22 @@ ia64_asm_output_external (FILE *file, tr
 {
   int save_referenced;
 
+  /* ??? The Intel assembler creates a reference that needs to be satisfied by
+     the linker when we do this, so we need to be careful not to do this for
+     builtin functions which have no library equivalent.  Unfortunately, we
+     can't tell here whether or not a function will actually be called by
+     expand_expr, so we pull in library functions even if we may not need
+     them later.  */
+  if (TREE_CODE (decl) == FUNCTION_DECL
+      && ((DECL_BUILT_IN_CLASS (decl) == BUILT_IN_MD)
+	  || !DECL_ASSEMBLER_NAME_SET_P (decl)
+	  || (DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA)))
+    return;
+
+#ifdef DO_CRTL_NAMES
+      DO_CRTL_NAMES;
+#endif
+
   /* GNU as does not need anything here, but the HP linker does need
      something for external functions.  */
 
@@ -5208,18 +5350,6 @@ ia64_asm_output_external (FILE *file, tr
 	  || strstr (name, "__builtin_") == name))
     return;
 
-  /* ??? The Intel assembler creates a reference that needs to be satisfied by
-     the linker when we do this, so we need to be careful not to do this for
-     builtin functions which have no library equivalent.  Unfortunately, we
-     can't tell here whether or not a function will actually be called by
-     expand_expr, so we pull in library functions even if we may not need
-     them later.  */
-  if (! strcmp (name, "__builtin_next_arg")
-      || ! strcmp (name, "alloca")
-      || ! strcmp (name, "__builtin_constant_p")
-      || ! strcmp (name, "__builtin_args_info"))
-    return;
-
   if (TARGET_HPUX_LD)
     ia64_hpux_add_extern_decl (decl);
   else
@@ -5369,6 +5499,9 @@ ia64_override_options (void)
   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;
 
   init_machine_status = ia64_init_machine_status;
+
+  if (TARGET_ABI_OPEN_VMS)
+    flag_no_common = 1;
 }
 
 static struct machine_function *
@@ -8668,6 +8801,12 @@ ia64_init_builtins (void)
     (*lang_hooks.types.register_builtin_type) (long_double_type_node,
 					       "__float128");
 
+  /* Fwrite on VMS is non-standard */
+#if TARGET_ABI_OPEN_VMS
+  implicit_built_in_decls[(int) BUILT_IN_FWRITE] = NULL_TREE;
+  implicit_built_in_decls[(int) BUILT_IN_FWRITE_UNLOCKED] = NULL_TREE;
+#endif
+
 #define def_builtin(name, type, code)					\
   lang_hooks.builtin_function ((name), (type), (code), BUILT_IN_MD,	\
 			       NULL, NULL_TREE)
@@ -8851,6 +8990,11 @@ ia64_vms_init_libfuncs (void)
   set_optab_libfunc (smod_optab, DImode, "OTS$REM_L");
   set_optab_libfunc (umod_optab, SImode, "OTS$REM_UI");
   set_optab_libfunc (umod_optab, DImode, "OTS$REM_UL");
+  abort_libfunc = init_one_libfunc ("decc$abort");
+  memcmp_libfunc = init_one_libfunc ("decc$memcmp");
+#ifdef MEM_LIBFUNCS_INIT
+  MEM_LIBFUNCS_INIT;
+#endif
 }
 
 /* Rename the TFmode libfuncs available from soft-fp in glibc using
@@ -8874,6 +9018,12 @@ ia64_sysv4_init_libfuncs (void)
   /* We leave out _U_Qfmin, _U_Qfmax and _U_Qfabs since soft-fp in
      glibc doesn't have them.  */
 }
+
+static bool
+ia64_vms_valid_pointer_mode (enum machine_mode mode)
+{
+  return (mode == SImode || mode == DImode);
+}
 
 /* Switch to the section to which we should output X.  The only thing
    special we do here is to honor small data.  */
@@ -9114,7 +9264,8 @@ static rtx
 ia64_struct_value_rtx (tree fntype,
 		       int incoming ATTRIBUTE_UNUSED)
 {
-  if (fntype && ia64_struct_retval_addr_is_first_parm_p (fntype))
+  if (TARGET_ABI_OPEN_VMS ||
+      (fntype && ia64_struct_retval_addr_is_first_parm_p (fntype)))
     return NULL_RTX;
   return gen_rtx_REG (Pmode, GR_REG (8));
 }
--- gcc/config/ia64/ia64.h.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/config/ia64/ia64.h	2007-12-04 15:14:14.000000000 -0800
@@ -74,6 +74,8 @@ extern unsigned int ia64_section_thresho
 #define TARGET_HPUX		0
 #define TARGET_HPUX_LD		0
 
+#define TARGET_ABI_OPEN_VMS 0
+
 #ifndef TARGET_ILP32
 #define TARGET_ILP32 0
 #endif
@@ -280,8 +282,9 @@ while (0)
 
 #define DOUBLE_TYPE_SIZE 64
 
-/* long double is XFmode normally, TFmode for HPUX.  */
-#define LONG_DOUBLE_TYPE_SIZE (TARGET_HPUX ? 128 : 80)
+/* long double is XFmode normally, TFmode for HPUX and VMS.  */
+#define LONG_DOUBLE_TYPE_SIZE \
+  ((TARGET_HPUX || TARGET_ABI_OPEN_VMS) ? 128 : 80)
 
 /* We always want the XFmode operations from libgcc2.c.  */
 #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 80
@@ -1136,12 +1139,15 @@ enum reg_class
    `FUNCTION_ARG' and other related values.  For some target machines, the type
    `int' suffices and can hold the number of bytes of argument so far.  */
 
+enum ivms_arg_type {I64, FF, FD, FG, FS, FT};
+
 typedef struct ia64_args
 {
   int words;			/* # words of arguments so far  */
   int int_regs;			/* # GR registers used so far  */
   int fp_regs;			/* # FR registers used so far  */
   int prototype;		/* whether function prototyped  */
+  enum ivms_arg_type atypes[8];
 } CUMULATIVE_ARGS;
 
 /* A C statement (sans semicolon) for initializing the variable CUM for the
@@ -1153,6 +1159,9 @@ do {									\
   (CUM).int_regs = 0;							\
   (CUM).fp_regs = 0;							\
   (CUM).prototype = ((FNTYPE) && TYPE_ARG_TYPES (FNTYPE)) || (LIBNAME);	\
+  (CUM).atypes[0] = (CUM).atypes[1] = (CUM).atypes[2] = I64;	        \
+  (CUM).atypes[3] = (CUM).atypes[4] = (CUM).atypes[5] = I64;            \
+  (CUM).atypes[6] = (CUM).atypes[7] = I64;                              \
 } while (0)
 
 /* Like `INIT_CUMULATIVE_ARGS' but overrides it for the purposes of finding the
@@ -1167,6 +1176,9 @@ do {									\
   (CUM).int_regs = 0;							\
   (CUM).fp_regs = 0;							\
   (CUM).prototype = 1;							\
+  (CUM).atypes[0] = (CUM).atypes[1] = (CUM).atypes[2] = I64;	        \
+  (CUM).atypes[3] = (CUM).atypes[4] = (CUM).atypes[5] = I64;            \
+  (CUM).atypes[6] = (CUM).atypes[7] = I64;                              \
 } while (0)
 
 /* A C statement (sans semicolon) to update the summarizer variable CUM to
@@ -1554,7 +1566,7 @@ do {									\
 
 #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \
 do {									\
-  sprintf (LABEL, "*.%s%d", PREFIX, NUM);				\
+  sprintf (LABEL, (TARGET_GNU_AS ? "*.%s%d" : "*?%s%d"), PREFIX, NUM);	\
 } while (0)
 
 /* ??? Not sure if using a ? in the name for Intel as is safe.  */
@@ -1568,8 +1580,11 @@ do {									\
 do {									\
   assemble_name (STREAM, NAME);						\
   fputs (" = ", STREAM);						\
+  if (ISDIGIT (*VALUE))							\
+    ia64_asm_output_label = 1;						\
   assemble_name (STREAM, VALUE);					\
   fputc ('\n', STREAM);							\
+  ia64_asm_output_label = 0;						\
 } while (0)
 
 
@@ -1765,7 +1780,7 @@ do {									\
    `%I' options of `asm_fprintf' (see `final.c').  */
 
 #define REGISTER_PREFIX ""
-#define LOCAL_LABEL_PREFIX "."
+#define LOCAL_LABEL_PREFIX (TARGET_GNU_AS ? "." : "?")
 #define USER_LABEL_PREFIX ""
 #define IMMEDIATE_PREFIX ""
 
@@ -1780,9 +1795,17 @@ do {									\
 #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)	\
   do {								\
   if (TARGET_ILP32)						\
-    fprintf (STREAM, "\tdata4 @pcrel(.L%d)\n", VALUE);		\
+    {                                                           \
+      fprintf (STREAM, "\tdata4 @pcrel(");                      \
+      fprintf (STREAM, "%s", LOCAL_LABEL_PREFIX);               \
+      fprintf (STREAM, "L%d)\n", VALUE);		        \
+    }                                                           \
   else								\
-    fprintf (STREAM, "\tdata8 @pcrel(.L%d)\n", VALUE);		\
+    {                                                           \
+      fprintf (STREAM, "\tdata8 @pcrel(");                      \
+      fprintf (STREAM, "%s", LOCAL_LABEL_PREFIX);               \
+      fprintf (STREAM, "L%d)\n", VALUE);		        \
+    }                                                           \
   } while (0)
 
 /* Jump tables only need 8 byte alignment.  */
@@ -1887,7 +1910,7 @@ do {									\
    add brackets around the label.  */
 
 #define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \
-  fprintf (FILE, TARGET_GNU_AS ? "[.%s%d:]\n" : ".%s%d:\n", PREFIX, NUM)
+  fprintf (FILE, TARGET_GNU_AS ? "[.%s%d:]\n" : "?%s%d:\n", PREFIX, NUM)
 
 /* Use section-relative relocations for debugging offsets.  Unlike other
    targets that fake this by putting the section VMA at 0, IA-64 has
@@ -1929,7 +1952,7 @@ do {									\
 /* An alias for a machine mode name.  This is the machine mode that elements of
    a jump-table should have.  */
 
-#define CASE_VECTOR_MODE ptr_mode
+#define CASE_VECTOR_MODE Pmode
 
 /* Define as C expression which evaluates to nonzero if the tablejump
    instruction expects the table to contain offsets from the address of the
--- gcc/config/ia64/ia64.md.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/config/ia64/ia64.md	2007-12-04 15:14:14.000000000 -0800
@@ -6273,7 +6273,12 @@
   [(set (match_operand:BI 0 "register_operand" "+c")
        (unspec:BI [(match_dup 0)] UNSPEC_PRED_REL_MUTEX))]
   ""
-  ".pred.rel.mutex %0, %I0"
+{
+  if (TARGET_GNU_AS)
+    return ".pred.rel.mutex %0, %I0";
+  else
+    return ".pred.rel \\\"mutex\\\", %0, %I0";
+}
   [(set_attr "itanium_class" "ignore")
    (set_attr "predicable" "no")])
 
--- gcc/config/ia64/ia64-protos.h.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/config/ia64/ia64-protos.h	2007-12-04 15:14:14.000000000 -0800
@@ -89,6 +89,7 @@ extern void ia64_function_arg_advance (C
 				       tree, int);
 extern int ia64_function_arg_boundary (enum machine_mode, tree);
 extern void ia64_asm_output_external (FILE *, tree, const char *);
+extern void ia64_start_function (FILE *, const char *, tree);
 #endif /* TREE_CODE */
 
 extern int ia64_register_move_cost (enum machine_mode, enum reg_class,
--- gcc/config/ia64/lib1funcs.asm.0	2005-11-19 10:37:49.000000000 -0800
+++ gcc/config/ia64/lib1funcs.asm	2007-12-04 15:14:14.000000000 -0800
@@ -46,7 +46,7 @@ __divtf3:
 	frcpa.s0 f10, p6 = farg0, farg1
 	;;
 (p6)	cmp.ne p7, p0 = r0, r0
-	.pred.rel.mutex p6, p7
+	.pred.rel "mutex" p6, p7
 (p6)	fnma.s1 f11 = farg1, f10, f1
 (p6)	fma.s1 f12 = farg0, f10, f0
 	;;
@@ -88,7 +88,7 @@ __divdf3:
 	frcpa.s0 f10, p6 = farg0, farg1
 	;;
 (p6)	cmp.ne p7, p0 = r0, r0
-	.pred.rel.mutex p6, p7
+	.pred.rel "mutex" p6, p7
 (p6)	fmpy.s1 f11 = farg0, f10
 (p6)	fnma.s1 f12 = farg1, f10, f1
 	;;
@@ -130,7 +130,7 @@ __divsf3:
 	frcpa.s0 f10, p6 = farg0, farg1
 	;;
 (p6)	cmp.ne p7, p0 = r0, r0
-	.pred.rel.mutex p6, p7
+	.pred.rel "mutex" p6, p7
 (p6)	fmpy.s1 f8 = farg0, f10
 (p6)	fnma.s1 f9 = farg1, f10, f1
 	;;
--- gcc/config/ia64/sysv4.h.0	2006-02-03 18:10:29.000000000 -0800
+++ gcc/config/ia64/sysv4.h	2007-12-04 15:14:14.000000000 -0800
@@ -73,6 +73,12 @@ do {						\
     fputc ('#', STREAM);			\
 } while (0)
 
+#undef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \
+do {									\
+  sprintf (LABEL, (TARGET_GNU_AS ? "*.%s%d" : "*?%s%d"), PREFIX, NUM);	\
+} while (0)
+
 /* Intel assembler requires both flags and type if declaring a non-predefined
    section.  */
 #undef INIT_SECTION_ASM_OP
@@ -103,12 +109,7 @@ do {						\
 
 #undef ASM_DECLARE_FUNCTION_NAME
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \
-do {									\
-  fputs ("\t.proc ", FILE);						\
-  assemble_name (FILE, NAME);						\
-  fputc ('\n', FILE);							\
-  ASM_OUTPUT_LABEL (FILE, NAME);					\
-} while (0)
+  ia64_start_function(FILE,NAME,DECL)
 
 /* We redefine this to use the ia64 .endp pseudo-op.  */
 
--- gcc/config/ia64/t-vms.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/t-vms	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,56 @@
+LIB1ASMSRC    = ia64/lib1funcs.asm
+
+# We use different names for the DImode div/mod files so that they won't
+# conflict with libgcc2.c files.  We used to use __ia64 as a prefix, now
+# we use __ as the prefix.  Note that L_divdi3 in libgcc2.c actually defines
+# a TImode divide function, so there is no actual overlap here between
+# libgcc2.c and lib1funcs.asm.
+LIB1ASMFUNCS  = __divxf3 __divdf3 __divsf3 \
+	__divdi3 __moddi3 __udivdi3 __umoddi3 \
+	__divsi3 __modsi3 __udivsi3 __umodsi3 __save_stack_nonlocal \
+	__nonlocal_goto __restore_stack_nonlocal __trampoline
+
+LIB2FUNCS_EXTRA =
+
+# VMS_EXTRA_PARTS is defined in x-vms and represent object files that
+# are only needed for VMS targets, but can only be compiled on a VMS host
+# (because they need DEC C).
+EXTRA_PARTS = $(VMS_EXTRA_PARTS) crtbegin.o crtbeginS.o crtend.o crtendS.o crtinitS.o
+
+CRTSTUFF_T_CFLAGS = -O0
+CRTSTUFF_T_CFLAGS_S = -O0
+
+crtinitS.o: $(srcdir)/config/ia64/crtinit.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) -I. -c -o crtinitS.o -x assembler-with-cpp \
+		$(srcdir)/config/ia64/crtinit.asm
+
+# LIB2ADDEH = $(srcdir)/unwind-sjlj.c
+LIB2ADDEH = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/config/ia64/fde-vms.c $(srcdir)/gthr-gnat.c
+
+# ??? Hack to get -P option used when compiling lib1funcs.asm, because Intel
+# assembler does not accept # line number as a comment.
+# ??? This breaks C++ pragma interface/implementation, which is used in the
+# C++ part of libgcc2, hence it had to be disabled.  Must find some other way
+# to support the Intel assembler.
+#LIBGCC2_DEBUG_CFLAGS = -g1 -P
+
+# genattrtab generates very long string literals.
+insn-attrtab.o-warn = -Wno-error
+
+# Skip more bytes in compare to account for time stamp in object file header
+skip_bytes = 512
+
+# Shared library macros
+shlib_version:=$(shell echo $(BASEVER_c) | sed -e 's/\./,/' -e 's/\.//g')
+SHLIB_EXT = .exe
+SHLIB_OBJS = @shlib_objs@
+SHLIB_NAME = @shlib_base_name@.exe
+SHLIB_MULTILIB =
+SHLIB_INSTALL = $(INSTALL_DATA) $(SHLIB_NAME) $$(DESTDIR)$$(libsubdir)/$(SHLIB_ NAME)
+SHLIB_LINK = \
+  $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -nodefaultlibs \
+  -shared --for-linker=/noinform -o $(SHLIB_NAME) $(SHLIB_OBJS) \
+  --for-linker=$(srcdir)/config/ia64/VMS_SYMVEC_@shlib_base_name@.opt \
+  --for-linker=gsmatch=equal,$(shlib_version)
+
--- gcc/config/ia64/unwind-ia64.c.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/config/ia64/unwind-ia64.c	2007-12-04 15:14:14.000000000 -0800
@@ -45,12 +45,12 @@
 
 #ifndef __USING_SJLJ_EXCEPTIONS__
 
-#define UNW_VER(x)		((x) >> 48)
-#define UNW_FLAG_MASK		0x0000ffff00000000
-#define UNW_FLAG_OSMASK		0x0000f00000000000
-#define UNW_FLAG_EHANDLER(x)	((x) & 0x0000000100000000L)
-#define UNW_FLAG_UHANDLER(x)	((x) & 0x0000000200000000L)
-#define UNW_LENGTH(x)		((x) & 0x00000000ffffffffL)
+
+/* By default, assume personality routine interface compatibility with
+   our expectations.  */
+#ifndef MD_UNW_COMPATIBLE_PERSONALITY_P
+#define MD_UNW_COMPATIBLE_PERSONALITY_P(HEADER) 1
+#endif
 
 enum unw_application_register
 {
@@ -446,7 +446,13 @@ decode_abreg (unsigned char abreg, int m
 {
   switch (abreg)
     {
+#if TARGET_ABI_OPEN_VMS
+    /* OpenVMS Calling Standard specifies R3 - R31 */
+    case 0x03 ... 0x1f: return UNW_REG_R2 + (abreg - 0x02);
+#else
+    /* Standard Intel ABI specifies GR 4 - 7 */
     case 0x04 ... 0x07: return UNW_REG_R4 + (abreg - 0x04);
+#endif
     case 0x22 ... 0x25: return UNW_REG_F2 + (abreg - 0x22);
     case 0x30 ... 0x3f: return UNW_REG_F16 + (abreg - 0x30);
     case 0x41 ... 0x45: return UNW_REG_B1 + (abreg - 0x41);
@@ -1730,14 +1736,14 @@ _Unwind_GetRegionStart (struct _Unwind_C
 void *
 _Unwind_FindEnclosingFunction (void *pc)
 {
-  struct unw_table_entry *ent;
+  struct unw_table_entry *entp, ent;
   unsigned long segment_base, gp;
 
-  ent = _Unwind_FindTableEntry (pc, &segment_base, &gp);
-  if (ent == NULL)
+  entp = _Unwind_FindTableEntry (pc, &segment_base, &gp, &ent);
+  if (entp == NULL)
     return NULL;
   else
-    return (void *)(segment_base + ent->start_offset);
+    return (void *)(segment_base + entp->start_offset);
 }
 
 /* Get the value of the CFA as saved in CONTEXT.  In GCC/Dwarf2 parlance,
@@ -1765,7 +1771,7 @@ _Unwind_GetBSP (struct _Unwind_Context *
 static _Unwind_Reason_Code
 uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)
 {
-  struct unw_table_entry *ent;
+  struct unw_table_entry *entp, ent;
   unsigned long *unw, header, length;
   unsigned char *insn, *insn_end;
   unsigned long segment_base;
@@ -1776,9 +1782,9 @@ uw_frame_state_for (struct _Unwind_Conte
     r->when = UNW_WHEN_NEVER;
   context->lsda = 0;
 
-  ent = _Unwind_FindTableEntry ((void *) context->rp,
-				&segment_base, &context->gp);
-  if (ent == NULL)
+  entp = _Unwind_FindTableEntry ((void *) context->rp,
+				&segment_base, &context->gp, &ent);
+  if (entp == NULL)
     {
       /* Couldn't find unwind info for this function.  Try an
 	 os-specific fallback mechanism.  This will necessarily
@@ -1803,17 +1809,34 @@ uw_frame_state_for (struct _Unwind_Conte
       return _URC_END_OF_STACK;
     }
 
-  context->region_start = ent->start_offset + segment_base;
+  context->region_start = entp->start_offset + segment_base;
   fs->when_target = ((context->rp & -16) - context->region_start) / 16 * 3
 		    + (context->rp & 15);
 
-  unw = (unsigned long *) (ent->info_offset + segment_base);
+  unw = (unsigned long *) (entp->info_offset + segment_base);
   header = *unw;
   length = UNW_LENGTH (header);
 
-  /* ??? Perhaps check UNW_VER / UNW_FLAG_OSMASK.  */
+  /* Some operating systems use the personality routine slot in way not
+     compatible with what we expect.  For instance, OpenVMS uses this slot to
+     designate "condition handlers" with very different arguments than what we
+     would be providing.  Such cases are typically identified from OS specific
+     bits in the unwind information block header, and checked by the target
+     MD_UNW_COMPATIBLE_PERSONALITY_P macro. 
+
+     We just pretend there is no personality from our standpoint in such
+     situations, and expect GCC not to set the identifying bits itself so that
+     compatible personalities for GCC compiled code are called.
+
+     Of course, this raises the question of what combinations of native/GCC
+     calls can be expected to behave properly exception handling-wise.  We are
+     not to provide a magic answer here, merely to prevent crashes assuming
+     users know what they are doing.
+
+     ??? Perhaps check UNW_VER / UNW_FLAG_OSMASK as well.  */
 
-  if (UNW_FLAG_EHANDLER (header) | UNW_FLAG_UHANDLER (header))
+  if (MD_UNW_COMPATIBLE_PERSONALITY_P (header)
+      && (UNW_FLAG_EHANDLER (header) | UNW_FLAG_UHANDLER (header)))
     {
       fs->personality =
 	*(_Unwind_Personality_Fn *) (unw[length + 1] + context->gp);
--- gcc/config/ia64/unwind-ia64.h.0	2005-11-19 10:37:49.000000000 -0800
+++ gcc/config/ia64/unwind-ia64.h	2007-12-04 15:14:14.000000000 -0800
@@ -26,7 +26,19 @@ struct unw_table_entry
   unsigned long info_offset;
 };
 
+/* Accessors to fields of an unwind info block header.  In this common file to
+   be visible from all the units involved in a target implementation.  */
+   
+#ifndef __USING_SJLJ_EXCEPTIONS__
+#define UNW_VER(x)		((x) >> 48)
+#define UNW_FLAG_MASK		0x0000ffff00000000
+#define UNW_FLAG_OSMASK		0x0000f00000000000
+#define UNW_FLAG_EHANDLER(x)	((x) & 0x0000000100000000L)
+#define UNW_FLAG_UHANDLER(x)	((x) & 0x0000000200000000L)
+#define UNW_LENGTH(x)		((x) & 0x00000000ffffffffL)
+#endif
+
 extern struct unw_table_entry *
 _Unwind_FindTableEntry (void *pc, unsigned long *segment_base,
-			unsigned long *gp)
+			unsigned long *gp, struct unw_table_entry *ent)
 			__attribute__ ((__visibility__ ("hidden")));
--- gcc/config/ia64/vms64.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/vms64.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,39 @@
+/* Output variables, constants and external declarations, for GNU compiler.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Contributed by Douglas Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()		\
+    do {					\
+	builtin_define_std ("vms");		\
+	builtin_define_std ("VMS");		\
+	builtin_define ("__IA64");		\
+	builtin_assert ("system=vms");		\
+	builtin_define ("__IEEE_FLOAT");	\
+	builtin_define ("__LONG_POINTERS=0");	\
+    } while (0)
+
+#undef LONG_TYPE_SIZE
+#define LONG_TYPE_SIZE 64
+
+#undef POINTER_SIZE
+#define POINTER_SIZE 64
+
+#include "config/vms/vms-crtl-64.h"
--- gcc/config/ia64/vms-ehfb.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/vms-ehfb.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,305 @@
+/* Output variables, constants and external declarations, for GNU compiler.
+   Copyright (C) 2005
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include <vms/libicb.h>
+#include <vms/chfdef.h>
+#include <vms/chfctxdef.h>
+
+#define __int64 long long
+#include <vms/intstkdef.h>
+
+#include <stdio.h>
+#include <string.h>
+
+#define UNW_SUCCESS 1
+#define UNW_FAILURE 0
+
+#define DYN$C_SSENTRY 66
+/* ??? would rather get the proper header file.  */
+
+extern INVO_CONTEXT_BLK * LIB$I64_CREATE_INVO_CONTEXT (void);
+
+extern int LIB$I64_IS_EXC_DISPATCH_FRAME (void *);
+extern int LIB$I64_IS_AST_DISPATCH_FRAME (void *);
+
+extern int LIB$I64_INIT_INVO_CONTEXT (INVO_CONTEXT_BLK *, int, int);
+extern int LIB$I64_GET_CURR_INVO_CONTEXT (INVO_CONTEXT_BLK *);
+extern int LIB$I64_GET_PREV_INVO_CONTEXT (INVO_CONTEXT_BLK *);
+
+typedef unsigned long ulong;
+typedef unsigned int uint;
+typedef unsigned long uw_reg;
+typedef uw_reg * uw_loc;
+
+typedef char fp_reg[16];
+
+#define DENOTES_VMS_DISPATCHER_FRAME(icb) \
+(LIB$I64_IS_EXC_DISPATCH_FRAME (&(icb)->libicb$ih_pc))
+
+#define DENOTES_BOTTOM_OF_STACK(icb) ((icb)->libicb$v_bottom_of_stack)
+
+#define FAIL_IF(COND) \
+do { if (COND) { context->rp = 0; return UNW_FAILURE; } } while (0);
+/* Clearing context->rp is required to prevent the ia64 gcc unwinder from
+   attempting to keep on walking the call chain.  */
+
+static int
+md_fallback_frame_state_for
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  int i, status;
+
+  INVO_CONTEXT_BLK local_icb;
+  INVO_CONTEXT_BLK *icb = &local_icb;
+    
+  CHFCTX * chfctx;
+  CHF$MECH_ARRAY * chfmech;
+  CHF64$SIGNAL_ARRAY *chfsig64;
+  INTSTK * intstk;
+
+  static int eh_debug = -1;
+  int try_bs_copy = 0;
+  /* Non zero to attempt copy of alternate backing store contents for
+     dirty partition in interrupted context. ??? Alpha code, only activated
+     on specific request via specific bit in EH_DEBUG.  */
+
+  if (eh_debug == -1)
+    {
+      char * EH_DEBUG = getenv ("EH_DEBUG");
+      const uint try_bs_copy_mask = (1 << 16);
+
+      eh_debug = EH_DEBUG ? atoi (EH_DEBUG) : 0;
+      
+      /* Fetch and clear the try_bs_copy bit.  */
+      try_bs_copy = (uint)eh_debug & try_bs_copy_mask;
+      eh_debug &= ~try_bs_copy_mask;
+    }
+
+  /* We're called to attempt unwinding through a frame for which no unwind
+     info is available, typical of an operating system exception dispatcher
+     frame.  The code below knows how to handle this case, and only this one,
+     returning a failure code if it finds it is not in this situation.
+
+     Note that we're called from deep down in the exception propagation call
+     chain, possibly below an exception dispatcher but for a frame above it
+     like some os entry point.  */
+
+  if (eh_debug)
+    printf ("FALLBACK - ctxt->rp=0x%lx, sp=0x%lx, psp=0x%lx, bsp=0x%lx\n",
+	    context->rp, context->sp, context->psp, context->bsp);
+
+  /* Step 0 :
+     -------------------------------------------------------------------------
+     VMS-unwind up until we reach a VMS dispatcher frame corresponding to the
+     context we are trying to unwind through. Fail if get past this context or
+     if we reach the bottom of stack along the way.
+     -------------------------------------------------------------------------
+  */
+
+  status = LIB$I64_INIT_INVO_CONTEXT (icb, LIBICB$K_INVO_CONTEXT_VERSION, 0);
+  FAIL_IF (status == 0);
+
+  status = LIB$I64_GET_CURR_INVO_CONTEXT (icb);
+
+  /* Beware: we might be unwinding through nested condition handlers, so the
+     dispatcher frame we seek might not be the first one on the way up.  Loop
+     thus.  */     
+  do {
+    
+    /* Seek the next dispatcher frame up the "current" point.  Stop if we
+       either get past the target context or hit the bottom-of-stack along
+       the way.  */
+    status = LIB$I64_GET_PREV_INVO_CONTEXT (icb);
+    FAIL_IF (status == 0);
+    FAIL_IF ((uw_reg)icb->libicb$ih_sp > (uw_reg)context->psp
+	     || DENOTES_BOTTOM_OF_STACK (icb));
+    
+    if (eh_debug)
+      printf ("frame%s sp @ 0x%llx, pc @ 0x%llx bsp=0x%llx\n",
+	      DENOTES_VMS_DISPATCHER_FRAME (icb) ? " (dispatcher)" : "",
+	      icb->libicb$ih_sp, icb->libicb$ih_pc, icb->libicb$ih_bsp);
+
+    /* Continue until the target frame is found.  */
+  } while ((uw_reg)icb->libicb$ih_bsp != (uw_reg)context->bsp);
+
+  /* If this is not a dispatcher frame, this is certainly a frame for a leaf
+     subprogram.  Use default unwind information.  */
+  if (! DENOTES_VMS_DISPATCHER_FRAME (icb))
+    return UNW_FAILURE;
+
+  /* At this point, we know we are really trying to unwind past an exception
+     dispatcher frame, and have it described in ICB.  Proceed.  */
+
+  /* Step 1 :
+     ------------------------------------------------------------------------
+     We have the VMS dispatcher frame ICB handy and know we are trying to
+     unwind past it.  Fetch pointers to useful datastructures from there, then
+     unwind one step further up to the interrupted user context from which
+     some required values will be easily accessible.
+     ------------------------------------------------------------------------
+  */
+
+  chfctx = icb->libicb$ph_chfctx_addr;
+  FAIL_IF (chfctx == 0);
+  
+  chfmech = (CHF$MECH_ARRAY *)chfctx->chfctx$q_mcharglst;
+  FAIL_IF (chfmech == 0);
+
+  chfsig64 = (CHF64$SIGNAL_ARRAY *)chfmech->chf$ph_mch_sig64_addr;
+  FAIL_IF (chfsig64 == 0);
+ 
+  intstk = (INTSTK *)chfmech->chf$q_mch_esf_addr;
+  FAIL_IF (intstk == 0 || intstk->intstk$b_subtype == DYN$C_SSENTRY);
+
+  status = LIB$I64_GET_PREV_INVO_CONTEXT (icb);
+  FAIL_IF (status == 0);
+
+  if (eh_debug)
+    printf ("User frame, "
+	    "chfmech @ 0x%lx, chfsig64 @ 0x%lx, intstk @ 0x%lx\n",
+	    (ulong)chfmech, (ulong)chfsig64, (ulong)intstk);
+
+  /* Step 2 :
+     ------------------------------------------------------------------------
+     Point the GCC context locations/values required for further unwinding at
+     their corresponding locations/values in the datastructures at hand.
+     ------------------------------------------------------------------------
+  */
+
+  /* Static General Register locations, including scratch registers in case
+     the unwinder needs to refer to a value stored in one of them.  */
+  {
+    uw_reg * ctxregs = (uw_reg *)&intstk->intstk$q_regbase;
+
+    for (i = 2; i <= 3; i++)
+      context->ireg[i - 2].loc = (uw_loc)&ctxregs[i];
+    for (i = 8; i <= 11; i++)
+      context->ireg[i - 2].loc = (uw_loc)&ctxregs[i];
+    for (i = 14; i <= 31; i++)
+      context->ireg[i - 2].loc = (uw_loc)&ctxregs[i];
+  }
+
+  /* Static Floating Point Register locations, as available from the
+     mechargs array, which happens to include all the to be preserved
+     ones + others.  */
+  {
+    fp_reg * ctxregs;
+
+    ctxregs = (fp_reg *)&chfmech->chf$fh_mch_savf2;
+    for (i = 2; i <= 5 ; i++)
+      context->fr_loc[i - 2] = (uw_loc)&ctxregs[i - 2];
+
+    ctxregs = (fp_reg *)&chfmech->chf$fh_mch_savf12;
+    for (i = 12; i <= 31 ; i++)
+      context->fr_loc[i - 2] = (uw_loc)&ctxregs[i - 12];
+  }
+
+  /* Relevant application register locations.  */
+
+  context->fpsr_loc = (uw_loc)&intstk->intstk$q_fpsr;
+  context->lc_loc   = (uw_loc)&intstk->intstk$q_lc;
+  context->unat_loc = (uw_loc)&intstk->intstk$q_unat;
+
+  /* Branch register locations.  */
+  
+  {
+    uw_reg * ctxregs = (uw_reg *)&intstk->intstk$q_b0;
+
+    for (i = 0; i < 8; i++)
+      context->br_loc[i] = (uw_loc)&ctxregs[i];
+  }
+
+  /* Necessary register values.  */
+
+  /* ??? Still unclear if we need to account for possible flushes to an
+     alternate backing store (maybe the unwinding performed above did the
+     trick already) and how this would be handled.  Blind alpha tentative
+     below for experimentation purposes in malfunctioning cases.  */
+  {
+    ulong q_bsp      = (ulong) intstk->intstk$q_bsp;
+    ulong q_bspstore = (ulong) intstk->intstk$q_bspstore;
+    ulong q_bspbase  = (ulong) intstk->intstk$q_bspbase;
+    ulong ih_bspbase = (ulong) icb->libicb$ih_bspbase;
+    
+    if (eh_debug)
+      printf ("q_bspstore = 0x%lx, q_bsp = 0x%lx, q_bspbase = 0x%lx\n"
+	      "ih_bspbase = 0x%lx\n",
+	      q_bspstore, q_bsp, q_bspbase, ih_bspbase);
+
+    /* We witness many situations where q_bspbase is set while ih_bspbase is
+       null, and every attempt made with q_bspbase badly failed while doing
+       nothing resulted in proper behavior.  */
+    if (q_bspstore < q_bsp && ih_bspbase && try_bs_copy)
+      {
+	ulong dirty_size = q_bsp - q_bspstore;
+	ulong q_rnat = (ulong) intstk->intstk$q_rnat;
+
+	if (eh_debug)
+	  printf ("Attempting an alternate backing store copy ...\n");
+
+	ia64_copy_rbs
+	  (context, q_bspstore, ih_bspbase, dirty_size, q_rnat);
+	/* Not clear if these are the proper arguments here.  This is what
+	   looked the closest to what is performed in the Linux case.  */
+      }
+    
+  }
+
+  context->bsp = (uw_reg)intstk->intstk$q_bsp;
+  fs->no_reg_stack_frame = 1;
+
+  context->pr  = (uw_reg)intstk->intstk$q_preds;
+  context->gp  = (uw_reg)intstk->intstk$q_gp;
+
+  /* We're directly setting up the "context" for a VMS exception handler.
+     The "previous SP" for it is the SP upon the handler's entry, that is
+     the SP at the condition/interruption/exception point.  */  
+  context->psp = (uw_reg)icb->libicb$ih_sp;
+
+  /* Previous Frame State location.  What eventually ends up in pfs_loc is
+     installed with ar.pfs = pfs_loc; br.ret; so setup to target intstk->q_ifs
+     to have the interrupted context restored and not that of its caller if
+     we happen to have a handler in the interrupted context itself.  */
+  fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_PSPREL;
+  fs->curr.reg[UNW_REG_PFS].val
+    = (uw_reg)&intstk->intstk$q_ifs - (uw_reg)context->psp;
+  fs->curr.reg[UNW_REG_PFS].when = -1;
+
+  /* If we need to unwind further up, past the interrupted context, we need to
+     hand out the interrupted context's pfs, still.  */
+  context->signal_pfs_loc = (uw_loc) &intstk->intstk$q_pfs;
+
+  /* Finally, rules for RP .  */
+  {
+    uw_reg * post_sigarray
+      = (uw_reg *)chfsig64 + 1 + chfsig64->chf64$l_sig_args;
+
+    uw_reg * ih_pc_loc = post_sigarray - 2;
+
+    fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_PSPREL;
+    fs->curr.reg[UNW_REG_RP].val
+      = (uw_reg)ih_pc_loc - (uw_reg)context->psp;
+    fs->curr.reg[UNW_REG_RP].when = -1;
+  }
+
+  return UNW_SUCCESS;
+}
+     
--- gcc/config/ia64/vms.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/vms.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,262 @@
+/* Output variables, constants and external declarations, for GNU compiler.
+   Copyright (C) 2003
+   Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define TARGET_OBJECT_SUFFIX ".obj"
+#define TARGET_EXECUTABLE_SUFFIX ".exe"
+
+#define OBJECT_FORMAT_ELF
+
+#define TARGET_OS_CPP_BUILTINS()		\
+    do {					\
+	builtin_define_std ("vms");		\
+	builtin_define_std ("VMS");		\
+	builtin_define ("__IA64");		\
+	builtin_assert ("system=vms");		\
+	builtin_define ("__IEEE_FLOAT");	\
+    } while (0)
+
+/* By default, allow $ to be part of an identifier.  */
+#define DOLLARS_IN_IDENTIFIERS 2
+
+#undef TARGET_ABI_OPEN_VMS
+#define TARGET_ABI_OPEN_VMS 1
+
+#undef TARGET_NAME   
+#define TARGET_NAME "OpenVMS/IA64"
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (%s)", TARGET_NAME);           
+
+/* Need .debug_line info generated from gcc and gas */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT MASK_GNU_AS
+
+#define VMS_DEBUG_MAIN_POINTER "TRANSFER$BREAK$GO"
+
+/* "long" is 32 bits, but 64 bits for Ada.  */
+#undef LONG_TYPE_SIZE
+#define LONG_TYPE_SIZE 32
+#define ADA_LONG_TYPE_SIZE 64
+
+/* Pointer is 32 bits but the hardware has 64-bit addresses, sign extended.  */
+#undef POINTER_SIZE
+#define POINTER_SIZE 32
+#define POINTERS_EXTEND_UNSIGNED 0
+
+/* Widest floating-point type efficiently supported by hardware and OS.  */
+#undef WIDEST_HARDWARE_FP_SIZE
+#define WIDEST_HARDWARE_FP_SIZE 64
+
+/* HP OpenVMS Calling Standard dated June, 2004, that describes
+   HP OpenVMS I64 Version 8.2EFT
+   chapter 4 "OpenVMS I64 Conventions"
+   section 4.7 "Procedure Linkage"
+   subsection 4.7.5.2, "Normal Register Parameters"
+
+   "Unsigned integral (except unsigned 32-bit), set, and VAX
+   floating-point values passed in registers are zero-filled;
+   signed integral values as well as unsigned 32-bit integral
+   values are sign-extended to 64 bits.  For all other types
+   passed in the general registers, unused bits are undefined."  */
+#define PROMOTE_FUNCTION_MODE(MODE,UNSIGNEDP,TYPE)	\
+  if (GET_MODE_CLASS (MODE) == MODE_INT			\
+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)		\
+    {							\
+      if ((MODE) == SImode)				\
+	(UNSIGNEDP) = 0;				\
+      (MODE) = DImode;					\
+    }
+
+/* The structure return address arrives as an "argument" on VMS.  */
+#undef PCC_STATIC_STRUCT_RETURN
+
+/* VMS debugger expects a separator */
+#define DWARF2_DIR_SHOULD_END_WITH_SEPARATOR 1
+
+/* VMS debugger needs the file timestamp */
+#define DWARF2_FILE_TIME_NAME(FILENAME)                              \
+ ({                                                                  \
+   long long cdt;                                                    \
+   ((vms_file_stats_name (FILENAME, &cdt, 0, 0, 0) == 0) ? cdt : 0); \
+ })
+
+/* VMS debugger needs the file size */
+#define DWARF2_FILE_SIZE_NAME(FILENAME)                              \
+ ({                                                                  \
+   long siz;                                                         \
+   ((vms_file_stats_name (FILENAME, 0, &siz, 0, 0) == 0) ? siz : 0); \
+ })
+
+/* VMS debugger needs the filename with version appended */
+/* Longest filename on VMS is 255 characters. Largest version is 32768 */
+#define DWARF2_FILE_NAME(FILENAME,DIRLEN)                            \
+ ({                                                                  \
+   int ver;                                                          \
+   char buff [255 + 7];                                              \
+   vms_file_stats_name (FILENAME, 0, 0, 0, &ver);                    \
+   snprintf (buff, 255 + 7, "%s;%d", FILENAME + DIRLEN, ver);        \
+   buff;                                                             \
+ })
+
+#define ASM_OUTPUT_DWARF_DELTA_UNITS(FILE,SIZE,LABEL1,LABEL2,UNITS) \
+do {                                \
+  fprintf (FILE, "\tdata4.ua\t ("); \
+  assemble_name (FILE, LABEL1);     \
+  fprintf (FILE, "-");              \
+  assemble_name (FILE, LABEL2);     \
+  fprintf (FILE, ")/16*3");         \
+} while (0)
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC \
+"%{!shared:%{mvms-return-codes:vcrt0.o%s} %{!mvms-return-codes:pcrt0.o%s} \
+    crtbegin.o%s} \
+ %{!static:%{shared:crtinitS.o%s crtbeginS.o%s}}"
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC \
+"%{!shared:crtend.o%s} %{!static:%{shared:crtendS.o%s}}"
+
+#define LINK_GCC_C_SEQUENCE_SPEC "%G"
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{g*} %{map} %{save-temps} %{shared} %{v}"
+
+#ifdef LIB_SPEC
+#undef LIB_SPEC
+#endif
+#define LIB_SPEC ""
+
+#ifdef ASM_SPEC
+#undef ASM_SPEC
+#endif
+#define ASM_SPEC                                          \
+  "%{mno-gnu-as:-N so -N vms_upcase -W DVLoc_off}         \
+   %{mconstant-gp:-M const_gp} %{mauto-pic:-M no_plabel}"
+
+#undef ASM_OUTPUT_EXTERNAL_LIBCALL
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)			\
+do {								\
+  (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0));	\
+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, XSTR (FUN, 0), "function");	\
+} while (0)
+
+/* Set the function to change the names of the division and modulus
+   functions.   */
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS ia64_vms_init_libfuncs
+
+#define NAME__MAIN "__gccmain"
+#define SYMBOL__MAIN __gccmain
+
+#define CTOR_LIST_BEGIN asm (".global\tLIB$INITIALIZE#\n");                  \
+STATIC func_ptr __CTOR_LIST__[1]                                             \
+  __attribute__ ((__unused__, section(".ctors"), aligned(sizeof(func_ptr)))) \
+  = { (func_ptr) (-1) };
+
+#undef INIT_SECTION_ASM_OP
+#define INIT_SECTION_ASM_OP ".section\tLIB$INITIALIZE#,\"a\",@progbits"
+
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)      \
+  asm (SECTION_OP "\n\tdata4 @fptr(" #FUNC"#)\n");      \
+  FORCE_CODE_SECTION_ALIGN                            \
+  asm (TEXT_SECTION_ASM_OP);
+
+#undef FINI_SECTION_ASM_OP
+
+/* Maybe same as HPUX?  Needs to be checked. */
+#define JMP_BUF_SIZE  (8 * 76)
+
+typedef struct crtl_name_spec
+{
+  const char *const name;
+  const char *deccname;
+  int referenced;
+} crtl_name_spec;
+
+#include "config/vms/vms-crtl.h"
+
+/* Alias CRTL names to 32/64bit DECCRTL functions.
+   Fixme: This should do a binary search. */
+#define DO_CRTL_NAMES                                                      \
+  do                                                                       \
+    {                                                                      \
+      int i;                                                               \
+      static crtl_name_spec vms_crtl_names[] = CRTL_NAMES;                 \
+      static int malloc64_init = 0;                                        \
+                                                                           \
+      if ((malloc64_init == 0) && TARGET_MALLOC64)                         \
+	{                                                                  \
+          for (i=0; vms_crtl_names [i].name; i++)                          \
+            {                                                              \
+	      if (strcmp ("calloc", vms_crtl_names [i].name) == 0)         \
+                vms_crtl_names [i].deccname = "decc$_calloc64";            \
+              else                                                         \
+	      if (strcmp ("malloc", vms_crtl_names [i].name) == 0)         \
+                vms_crtl_names [i].deccname = "decc$_malloc64";            \
+              else                                                         \
+	      if (strcmp ("realloc", vms_crtl_names [i].name) == 0)        \
+                vms_crtl_names [i].deccname = "decc$_realloc64";           \
+              else                                                         \
+	      if (strcmp ("strdup", vms_crtl_names [i].name) == 0)         \
+                vms_crtl_names [i].deccname = "decc$_strdup64";            \
+	    }                                                              \
+            malloc64_init = 1;                                             \
+        }                                                                  \
+      for (i=0; vms_crtl_names [i].name; i++)                              \
+	if (!vms_crtl_names [i].referenced &&                              \
+	    (strcmp (name, vms_crtl_names [i].name) == 0))                 \
+	  {                                                                \
+	    fprintf (file, "\t.alias %s, \"%s\"\n",                        \
+		     name, vms_crtl_names [i].deccname);                   \
+	    vms_crtl_names [i].referenced = 1;                             \
+	  }                                                                \
+    } while (0)
+
+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)                   \
+  do {                                                     \
+       flag_merge_constants = 0;                           \
+  } while (0)
+
+#if 0
+/* A C expression for the size in bytes of the trampoline, as an integer.  */
+
+#undef TRAMPOLINE_SIZE
+#define TRAMPOLINE_SIZE		48
+
+/* A C statement to initialize the variable parts of a trampoline.  */
+
+#undef INITIALIZE_TRAMPOLINE
+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \
+  ia64_vms_initialize_trampoline((ADDR), (FNADDR), (STATIC_CHAIN))
+#endif
+
+/* Define this to be nonzero if static stack checking is supported.  */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+#define MD_FALLBACK_FRAME_STATE_FOR_SOURCE "config/ia64/vms-ehfb.h"
+
+#define UNW_IVMS_MODE(HEADER) (((HEADER) >> 44) & 0x3L)
+#define MD_UNW_COMPATIBLE_PERSONALITY_P(HEADER) (!UNW_IVMS_MODE (HEADER))
+
+/* Minimum amount of stack required to recover from an anticipated stack
+   overflow detection.  The default value conveys an estimate of the amount
+   of stack required to propagate an exception.  */
+#define STACK_CHECK_PROTECT (24 * 1024)
--- gcc/config/ia64/vms_symvec_libgcc_s.opt.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/ia64/vms_symvec_libgcc_s.opt	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,91 @@
+! Symbol vector listing all the universal symbols to be exported when
+! building libgcc_s.exe shareable image on IVMS for Gcc 3.4.5.
+
+case_sensitive=yes
+SYMBOL_VECTOR=(__divdf3=PROCEDURE)
+SYMBOL_VECTOR=(__divdi3=PROCEDURE)
+SYMBOL_VECTOR=(__divsf3=PROCEDURE)
+SYMBOL_VECTOR=(__divsi3=PROCEDURE)
+SYMBOL_VECTOR=(__divxf3=PROCEDURE)
+SYMBOL_VECTOR=(__moddi3=PROCEDURE)
+SYMBOL_VECTOR=(__modsi3=PROCEDURE)
+SYMBOL_VECTOR=(__ia64_nonlocal_goto=PROCEDURE)
+SYMBOL_VECTOR=(__ia64_restore_stack_nonlocal=PROCEDURE)
+SYMBOL_VECTOR=(__ia64_save_stack_nonlocal=PROCEDURE)
+SYMBOL_VECTOR=(__ia64_trampoline=PROCEDURE)
+SYMBOL_VECTOR=(__udivdi3=PROCEDURE)
+SYMBOL_VECTOR=(__udivsi3=PROCEDURE)
+SYMBOL_VECTOR=(__umoddi3=PROCEDURE)
+SYMBOL_VECTOR=(__umodsi3=PROCEDURE)
+SYMBOL_VECTOR=(__absvti2=PROCEDURE)
+SYMBOL_VECTOR=(__absvdi2=PROCEDURE)
+SYMBOL_VECTOR=(__absvsi2=PROCEDURE)
+SYMBOL_VECTOR=(__addvti3=PROCEDURE)
+SYMBOL_VECTOR=(__addvdi3=PROCEDURE)
+SYMBOL_VECTOR=(__addvsi3=PROCEDURE)
+SYMBOL_VECTOR=(__ashlti3=PROCEDURE)
+SYMBOL_VECTOR=(__ashrti3=PROCEDURE)
+SYMBOL_VECTOR=(__clear_cache=PROCEDURE)
+SYMBOL_VECTOR=(__clzti2=PROCEDURE)
+SYMBOL_VECTOR=(__clzdi2=PROCEDURE)
+SYMBOL_VECTOR=(__cmpti2=PROCEDURE)
+SYMBOL_VECTOR=(__ctzti2=PROCEDURE)
+SYMBOL_VECTOR=(__ctzdi2=PROCEDURE)
+SYMBOL_VECTOR=(__divti3=PROCEDURE)
+SYMBOL_VECTOR=(__enable_execute_stack=PROCEDURE)
+SYMBOL_VECTOR=(__ffsti2=PROCEDURE)
+SYMBOL_VECTOR=(__ffsdi2=PROCEDURE)
+SYMBOL_VECTOR=(__fixdfti=PROCEDURE)
+SYMBOL_VECTOR=(__fixsfti=PROCEDURE)
+SYMBOL_VECTOR=(__fixunsdfti=PROCEDURE)
+SYMBOL_VECTOR=(__fixunsdfdi=PROCEDURE)
+SYMBOL_VECTOR=(__fixunssfti=PROCEDURE)
+SYMBOL_VECTOR=(__fixunssfdi=PROCEDURE)
+SYMBOL_VECTOR=(__fixunsxfti=PROCEDURE)
+SYMBOL_VECTOR=(__fixunsxfdi=PROCEDURE)
+SYMBOL_VECTOR=(__fixxfti=PROCEDURE)
+SYMBOL_VECTOR=(__floattidf=PROCEDURE)
+SYMBOL_VECTOR=(__floattisf=PROCEDURE)
+SYMBOL_VECTOR=(__floattixf=PROCEDURE)
+SYMBOL_VECTOR=(__lshrti3=PROCEDURE)
+SYMBOL_VECTOR=(__modti3=PROCEDURE)
+SYMBOL_VECTOR=(__multi3=PROCEDURE)
+SYMBOL_VECTOR=(__mulvti3=PROCEDURE)
+SYMBOL_VECTOR=(__mulvdi3=PROCEDURE)
+SYMBOL_VECTOR=(__mulvsi3=PROCEDURE)
+SYMBOL_VECTOR=(__negti2=PROCEDURE)
+SYMBOL_VECTOR=(__negvti2=PROCEDURE)
+SYMBOL_VECTOR=(__negvdi2=PROCEDURE)
+SYMBOL_VECTOR=(__negvsi2=PROCEDURE)
+SYMBOL_VECTOR=(__parityti2=PROCEDURE)
+SYMBOL_VECTOR=(__paritydi2=PROCEDURE)
+SYMBOL_VECTOR=(__popcountti2=PROCEDURE)
+SYMBOL_VECTOR=(__popcountdi2=PROCEDURE)
+SYMBOL_VECTOR=(__subvti3=PROCEDURE)
+SYMBOL_VECTOR=(__subvdi3=PROCEDURE)
+SYMBOL_VECTOR=(__subvsi3=PROCEDURE)
+SYMBOL_VECTOR=(__ucmpti2=PROCEDURE)
+SYMBOL_VECTOR=(__udiv_w_sdiv=PROCEDURE)
+SYMBOL_VECTOR=(__udivti3=PROCEDURE)
+SYMBOL_VECTOR=(__udivmodti4=PROCEDURE)
+SYMBOL_VECTOR=(__umodti3=PROCEDURE)
+SYMBOL_VECTOR=(__gthread_active_p=PROCEDURE)
+SYMBOL_VECTOR=(__gthread_mutex_lock=PROCEDURE)
+SYMBOL_VECTOR=(__gthread_mutex_unlock=PROCEDURE)
+SYMBOL_VECTOR=(__gcc_personality_v0=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetGR=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_SetGR=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetIP=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_SetIP=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetLanguageSpecificData=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetRegionStart=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_FindEnclosingFunction=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetCFA=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetBSP=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_RaiseException=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_ForcedUnwind=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_Resume=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_Resume_or_Rethrow=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_DeleteException=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_Backtrace=PROCEDURE)
+case_sensitive=NO
--- gcc/config/vms/t-vms.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/t-vms	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,38 @@
+STMP_FIXPROTO =
+STMP_FIXINC =
+LIMITS_H_TEST = false
+
+# Under VMS, directory names cannot contain dots.
+version:=$(shell echo $(BASEVER_c) | sed -e 's/\./_/g')
+
+# VMS_EXTRA_PARTS must be compiled by DEC C
+VMS_EXTRA_PARTS=vcrt0.o pcrt0.o
+
+DECC=`echo $(CC) | sed -e 's/stage[123]\/xgcc.exe -B.*/decc.exe/' -e 's/xgcc -B.*/decc$(exeext)/' -e 's/^gcc/decc/' -e 's/^decc/.\/decc/' -e 's/\(.*\)-gcc/\1-decc/'`
+
+# Assemble startup files.
+vcrt0.o: $(CRT0_S) $(GCC_PASSES)
+	$(DECC) -c /names=as_is $(srcdir)/config/vms/vms-crt0.c -o vcrt0.o
+
+pcrt0.o: $(CRT0_S) $(GCC_PASSES)
+	$(DECC) -c /names=as_is $(srcdir)/config/vms/vms-psxcrt0.c -o pcrt0.o
+
+EXTRA_PROGRAMS=ld$(exeext) ar$(exeext)
+
+EXTRA_PASSES=decc$(exeext)
+
+vms-ld.o : $(srcdir)/config/vms/vms-ld.c
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+ld$(exeext) : vms-ld.o
+	$(CC) -o $@ vms-ld.o ../libiberty/libiberty.a
+
+vms-ar.o : $(srcdir)/config/vms/vms-ar.c
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+ar$(exeext) : vms-ar.o
+	$(CC) -o $@ vms-ar.o ../libiberty/libiberty.a
+
+vms-cc.o : $(srcdir)/config/vms/vms-cc.c
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+decc$(exeext) : vms-cc.o
+	$(CC) -o $@ vms-cc.o ../libiberty/libiberty.a
+
--- gcc/config/vms/t-vms64.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/t-vms64	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,8 @@
+# Assemble startup files.
+vcrt0.o: $(CRT0_S) $(GCC_PASSES)
+	$(DECC) -c /names=as_is /pointer_size=64  \
+	     $(srcdir)/config/vms/vms-crt0-64.c -o vcrt0.o
+
+pcrt0.o: $(CRT0_S) $(GCC_PASSES)
+	$(DECC) -c /names=as_is /pointer_size=64 \
+	     $(srcdir)/config/vms/vms-psxcrt0-64.c -o pcrt0.o
--- gcc/config/vms/vms-ar.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-ar.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,518 @@
+/* VMS archive wrapper.
+   Copyright (C) 1998,2003,2004 Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define FATAL_EXIT_CODE (44 | 0x10000000)
+#define SUCCESS_EXIT_CODE 1
+
+static int link_arg_max = -1;
+static char **link_args = (char **) 0;
+static int link_arg_index = -1;
+static int replace_mode = 0;
+static int create_mode = 0;
+static int extract_mode = 0;
+static int verbose_mode = 0;
+static char arcmd[] = "library";
+static char modecmd [32];
+static char libname [256];
+static char *rcp_target;
+static char *rcp_target_username;
+
+#ifdef CROSS_COMPILE
+static int remote = 1; /* 1 == rcp mode, 2 == nfs mode (set by env var) */
+#else
+static int remote = 0;
+#endif
+
+#define TEMP_FILE "arXXXXXX"
+#define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)
+#define SUFFIX ".com"
+#define SUFFIX_LEN (sizeof(SUFFIX) - 1)
+
+static char * to_host_file_spec (char *filespec);
+static char * to_host_dir_spec (char *dirspec);
+static int is_regular_file (char *name);
+
+/* Check to see if the file named in NAME is a regular file, i.e. not a
+   directory */
+
+static int
+is_regular_file (name)
+     char *name;
+{
+  int ret;
+  struct stat statbuf;
+
+  ret = stat(name, &statbuf);
+  return !ret && S_ISREG (statbuf.st_mode);
+}
+
+/* Add the argument contained in STR to the list of arguments to pass to the
+   linker */
+
+static void
+addarg (str)
+     char *str;
+{
+  int i;
+
+  if (++link_arg_index >= link_arg_max)
+    {
+      char **new_link_args
+	= (char **) calloc (link_arg_max + 1000, sizeof (char *));
+
+      for (i = 0; i <= link_arg_max; i++)
+	new_link_args [i] = link_args [i];
+
+      if (link_args)
+	free (link_args);
+
+      link_arg_max += 1000;
+      link_args = new_link_args;
+    }
+
+  link_args [link_arg_index] = str;
+}
+
+
+typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;
+
+main (argc, argv)
+     int argc;
+     char *argv[];
+{
+  int i, nexti, iarg, ilastarg;
+  FILE *comfile;
+  int comfd;
+  int outlen, maxoutlen = 4000;
+  char *cwd;
+  char *temp_filename;
+  char command [256];
+  int status;
+
+  cwd = getcwd (0, 1024);
+
+  rcp_target = getenv ("GCC_CROSS_TARGET");
+  rcp_target_username = getenv ("GCC_CROSS_TARGET_USER");
+  if (remote && (!rcp_target || !rcp_target_username))
+    {
+      fputs ("GCC_CROSS_TARGET or GCC_CROSS_TARGET_USER undefined\n",
+             stderr);
+      return 1;
+    }
+
+  if ((remote == 1) && atoi (getenv ("GCC_CROSS_TARGET_NFS")))
+    remote = 2;
+
+  if (argv[1][0] != '-')
+    {
+      for (i = 0; i < strlen (argv[1]); i++)
+	{
+	  if (argv[1][i] == 'r')
+	    {
+	      replace_mode = 1;
+	    }
+	  else if (argv[1][i] == 'c')
+	    {
+	      create_mode = 1;
+	    }
+	  else if (argv[1][i] == 'x')
+	    {
+	      extract_mode = 1;
+	    }
+	  else if (argv[1][i] == 'v')
+	    {
+	      verbose_mode = 1;
+	    }
+	}
+      nexti = 2;
+    }
+  else
+    {
+      for (i = 1; i < argc; i++)
+	{
+	  int arg_len = strlen (argv[i]);
+	  
+	  if (argv[i][0] != '-')
+	    {
+	      nexti = i;
+	      break;
+	    }
+	  else if (strcmp (argv[i], "-r") == 0)
+	    {
+	      replace_mode = 1;
+	    }
+	  else if (strcmp (argv[i], "-c") == 0)
+	    {
+	      create_mode = 1;
+	    }
+	  else if (strcmp (argv[i], "-x") == 0)
+	    {
+	      extract_mode = 1;
+	    }
+	  else if (strcmp (argv[i], "-v") == 0)
+	    {
+	      verbose_mode = 1;
+	    }
+	}
+    }
+
+  if (extract_mode)
+    {
+      if (is_regular_file (argv[nexti]))
+	{
+	  char *buff = to_host_file_spec (argv[nexti]);
+	  char *nbuff = (char *) malloc (strlen (buff) + 1);
+
+	  strcpy (nbuff, buff);
+	  addarg (nbuff);
+	}
+      else
+	{
+	  char *libname = argv[nexti];
+
+	  if (strcmp (&libname [strlen (libname) - 2], ".a") == 0)
+	    {
+	      char *nlibname;
+
+	      nlibname = (char *)malloc (strlen (libname) + 3);
+	      strcpy (nlibname, libname);
+	      strcpy (&nlibname [strlen (nlibname) - 2], ".olb");
+	      if (is_regular_file (nlibname))
+		{
+		  char *buff = to_host_file_spec (nlibname);
+		  char *nbuff = (char *) malloc (strlen (buff) + 1);
+
+		  strcpy (nbuff, buff);
+		  addarg (nbuff);
+		}
+	      else
+		{
+		  exit (FATAL_EXIT_CODE);
+		}
+	    }
+	  else
+	    {
+	      exit (FATAL_EXIT_CODE);
+	    }
+	}
+    }
+  else
+    {
+      strcpy (libname, to_host_file_spec (argv[nexti]));
+    }
+
+  if (replace_mode)
+    {
+      strcat (modecmd, "/replace");
+    }
+
+  if (create_mode && !is_regular_file (argv[nexti]) ||
+      create_mode && !replace_mode)
+    {
+      strcat (modecmd, "/create");
+    }
+
+  nexti++;
+  if (extract_mode)
+    {
+      if (nexti == argc)
+	{
+	  strcat (modecmd, "/extract=(*");
+	}
+      else
+	{
+	  strcat (modecmd, "/extract=(");
+	}
+    }
+
+  for (i = nexti; i < argc; i++)
+    {
+      char *newarg = (char *)malloc (strlen (argv[i]) + 3);
+      char tmparg [256];
+
+      if (extract_mode)
+	strcpy (newarg, "\"");
+
+      
+      strcpy (tmparg, argv[i]);
+
+      if (extract_mode && strcmp (&tmparg [strlen (tmparg) - 4], ".obj") == 0)
+	{
+	  tmparg [strlen (tmparg) - 4] = 0;
+	}
+
+      strcpy (newarg, tmparg);
+
+      if (extract_mode)
+	strcat (newarg, "\"");
+      else
+	strcpy (newarg, to_host_file_spec (newarg));
+
+      addarg (newarg);
+
+    }
+
+  if (extract_mode)
+    {
+      addarg (")");
+    }
+
+  addarg (NULL);
+
+  iarg = 0;
+  ilastarg = 0;
+
+  temp_filename = (char *) malloc (TEMP_FILE_LEN + SUFFIX_LEN + 1);
+  strcpy (temp_filename, TEMP_FILE);
+  strcpy (temp_filename + TEMP_FILE_LEN, SUFFIX);
+  comfd = mkstemps (temp_filename, SUFFIX_LEN);
+  comfile = fdopen (comfd, "w");
+
+  fprintf (comfile, "$set def %s\n", to_host_dir_spec (cwd));
+  while (link_args [iarg])
+    {
+       if (outlen > maxoutlen || iarg == 0)
+         {
+           fprintf (comfile, "$library %s %s -\n", modecmd, libname);
+           outlen = 0;
+           if (create_mode && iarg == 0)
+	      strcpy (modecmd, "/replace");
+         }
+
+       fprintf (comfile, "%s", link_args [iarg]);
+       outlen += strlen (link_args [iarg]) + 2;
+
+       if (outlen > maxoutlen || !link_args [iarg+1])
+         fprintf (comfile, "\n");
+       else
+         fprintf (comfile, ",-\n");
+
+       iarg++;
+    }
+
+  fclose (comfile);
+
+  if (remote == 2)
+    sprintf (command, "rsh -l %s %s @%s%s\n",
+       rcp_target_username, rcp_target, to_host_dir_spec (cwd), temp_filename);
+  else
+    sprintf (command, "@%s%s\n", to_host_dir_spec (cwd), temp_filename);
+
+  status = system (command);
+
+  exit (status);
+}
+
+static char new_host_filespec [255];
+static char new_host_dirspec [255];
+static char filename_buff [256];
+
+static int
+translate_unix (name, type)
+     char *name;
+     int type;
+{
+  strcpy (filename_buff, name);
+  return 0;
+}
+
+#ifndef VMS
+#ifdef CROSS_COMPILE
+int
+gcc_to_vms (unix_style_filespec, action_routine, allow_wild, no_directory)
+  const char *unix_style_filespec;
+  int (*action_routine) (char *openvms_style_filespec, int type_of_file);
+  int allow_wild;
+  int no_directory;
+{
+  char *p1, *p2;
+  char *filename = alloca (256);
+  char *filespec = alloca (strlen (unix_style_filespec) + 1);
+  char *vmsfilespec = alloca (strlen (unix_style_filespec) + 2);
+
+  strcpy (filespec, unix_style_filespec);
+  vmsfilespec [0] = 0;
+  filename [0] = 0;
+
+  vmsfilespec[0] = 0;
+  p1 = filespec;
+  p2 = strrchr (p1, '/');
+  if (no_directory == 1)
+    {
+      if (p2)
+        {
+           *p2 = 0;
+          strcpy (filename, p2+1);
+        }
+      else
+        {
+          strcpy (vmsfilespec, p1);
+          return (*action_routine) (vmsfilespec, 1);
+        }
+    }
+
+  if (*p1 == '/')
+    {
+      p2 = strchr (p1+1, '/');
+      if (p2 == 0)
+	p2 = p1 + strlen (p1);
+
+      strncat (vmsfilespec, p1+1, (p2 - p1) - 1);
+      strcat (vmsfilespec, ":");
+      p1 = p2;
+
+      if (*p1 == 0)
+        {
+          strcat (vmsfilespec, filename);
+          return (*action_routine) (vmsfilespec, 1);
+        }
+      else
+        {
+	  strcat (vmsfilespec, "[");
+        }
+    }
+  else
+    {
+      if (*p1 == '.')
+         {
+           p1++;
+           strcat (vmsfilespec, "[");
+         }
+      else
+         strcat (vmsfilespec, "[.");
+      p2 = strchr (p1, '/');
+      if (p2 == 0)
+	p2 = p1 + strlen (p1);
+      strncat (vmsfilespec, p1, (p2 - p1));
+      p1 = p2;
+
+      if ((*p1 == 0) || (strcmp (p1, "/.") == 0))
+        {
+	  strcat (vmsfilespec, "]");
+          strcat (vmsfilespec, filename);
+          return (*action_routine) (vmsfilespec, 1);
+        }
+      else
+	{
+	  strcat (vmsfilespec, ".");
+	}
+
+    }
+
+  while (*p1)
+    {
+      char *p3;
+
+      p2 = strchr (p1+1, '/');
+      if (p2 == 0)
+	p2 = p1 + strlen (p1);
+
+      if ((*(p1+1) == '.') && (*(p1+2) == '.'))
+        {
+          strcat (vmsfilespec, "-");
+        }
+      else if (*(p1+1) == '.' && (*p1+2) == '/')
+        {
+          p1 = p2;
+          continue;
+        }
+      else
+        {
+          p3 = p1 + 1;
+          while (p3 < p2)
+            {
+              if (*(p3) == '.')
+                *p3 = '_';
+              p3++;
+            }
+          strncat (vmsfilespec, p1+1, (p2 - p1) - 1);
+        }
+
+      if (*p2 == 0)
+        strcat (vmsfilespec, "]");
+      else
+        strcat (vmsfilespec, ".");
+
+      p1 = p2;
+    }
+
+  strcat (vmsfilespec, filename);
+  return (*action_routine) (vmsfilespec, 1);
+
+}
+#endif
+#endif
+
+static char *
+to_host_file_spec (char *filespec)
+{
+  /* fprintf (stderr, "to_host_file_spec: %s\n", filespec); */
+  strcpy (new_host_filespec, "");
+  if (strchr (filespec, ']') || strchr (filespec, ':'))
+    strcpy (new_host_filespec, filespec);
+  else
+    {
+      strcpy (filename_buff, filespec);
+#ifndef VMS
+#ifdef CROSS_COMPILE
+      if (remote == 2)
+	gcc_to_vms (filespec, translate_unix, 1, 1);
+#endif
+#else
+      decc$to_vms (filespec, translate_unix, 1, 1);
+#endif
+      strcpy (new_host_filespec, filename_buff);
+    }
+
+  return new_host_filespec;
+}
+
+static char *
+to_host_dir_spec (char *dirspec)
+{
+  /* fprintf (stderr, "to_host_dir_spec: %s\n", dirspec); */
+  strcpy (new_host_dirspec, "");
+  if (strchr (dirspec, ']') || strchr (dirspec, ':'))
+    strcpy (new_host_dirspec, dirspec);
+  else
+    {
+      strcpy (filename_buff, dirspec);
+#ifndef VMS
+#ifdef CROSS_COMPILE
+      if (remote == 2)
+	gcc_to_vms (dirspec, translate_unix, 1, 2);
+#endif
+#else
+      decc$to_vms (dirspec, translate_unix, 1, 2);
+#endif
+      strcpy (new_host_dirspec, filename_buff);
+    }
+
+  return new_host_dirspec;
+}
--- gcc/config/vms/vms-cc.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-cc.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,439 @@
+/* VMS DEC C wrapper.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This program is a wrapper around the VMS DEC C compiler.
+   It translates Unix style command line options into corresponding
+   VMS style qualifiers and then spawns the DEC C compiler.  */
+
+#define _POSIX_EXIT 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+# define WIFEXITED(s)   (((s)&0x7F)==0)
+# define WEXITSTATUS(s) (((s)>>8)&0xFF)
+#undef PATH_SEPARATOR
+#undef PATH_SEPARATOR_STR
+#define PATH_SEPARATOR ','
+#define PATH_SEPARATOR_STR ","
+
+static char *rcp_target;
+static char *rcp_username;
+
+#ifdef CROSS_COMPILE
+static int remote = 1;
+#else
+static int remote = 0;
+#endif
+
+/* These can be set by command line arguments */
+static int verbose = 0;
+static int save_temps = 0;
+
+static int comp_arg_max = -1;
+static const char **comp_args = 0;
+static int comp_arg_index = -1;
+static char *objfilename = 0;
+static char *objfileshortname = 0;
+
+static char *system_search_dirs = (char *) "";
+static char *search_dirs;
+
+static char *default_defines = (char *) "";
+static char *defines;
+
+/* Translate a Unix syntax directory specification into VMS syntax.
+   If indicators of VMS syntax found, return input string.  */
+static char *to_host_dir_spec (char *);
+
+/* Translate a Unix syntax file specification into VMS syntax.
+   If indicators of VMS syntax found, return input string.  */
+static char *to_host_file_spec (char *);
+
+/* Add a translated arg to the list to be passed to DEC CC.  */
+static void addarg (const char *);
+
+/* Preprocess the number of args in P_ARGC and contained in ARGV.
+   Look for special flags, etc. that must be handled first.  */
+static void preprocess_args (int *, char **);
+
+/* Process the number of args in P_ARGC and contained in ARGV. Look
+   for special flags, etc. that must be handled for the VMS compiler.  */
+static void process_args (int *, char **);
+
+/* Action routine called by decc$to_vms */
+static int translate_unix (char *, int);
+
+/* Add the argument contained in STR to the list of arguments to pass to the
+   compiler.  */
+
+static void
+addarg (const char *str)
+{
+  int i;
+
+  if (++comp_arg_index >= comp_arg_max)
+    {
+      const char **new_comp_args
+	= (const char **) xcalloc (comp_arg_max + 1000, sizeof (char *));
+
+      for (i = 0; i <= comp_arg_max; i++)
+	new_comp_args [i] = comp_args [i];
+
+      if (comp_args)
+	free (comp_args);
+
+      comp_arg_max += 1000;
+      comp_args = new_comp_args;
+    }
+
+  comp_args [comp_arg_index] = str;
+}
+
+static void
+preprocess_args (int *p_argc, char *argv[])
+{
+  int i;
+  char *cc_program = "cc";
+
+  for (i = 1; i < *p_argc; i++)
+    if (strstr (argv [i], "--cc=") != NULL)
+      cc_program = argv[i] + 5;
+
+  addarg (cc_program);
+
+  for (i = 1; i < *p_argc; i++)
+    {
+      if (strcmp (argv[i], "-o") == 0)
+	{
+	  char *buff, *ptr;
+
+	  i++;
+	  ptr = to_host_file_spec (argv[i]);
+	  objfilename = xstrdup (ptr);
+          objfileshortname = basename (objfilename);
+
+	  if (remote)
+	    buff = concat ("/obj=", objfileshortname, NULL);
+	  else
+	    buff = concat ("/obj=", objfilename, NULL);
+	  addarg (buff);
+	}
+    }
+}
+
+static void
+process_args (int *p_argc, char *argv[])
+{
+  int i;
+
+  for (i = 1; i < *p_argc; i++)
+    {
+      if (strlen (argv[i]) < 2)
+	continue;
+
+      if (strncmp (argv[i], "-I", 2) == 0)
+	{
+	  char *ptr;
+	  int new_len, search_dirs_len;
+
+	  ptr = to_host_dir_spec (&argv[i][2]);
+	  new_len = strlen (ptr);
+	  search_dirs_len = strlen (search_dirs);
+
+	  search_dirs = xrealloc (search_dirs, search_dirs_len + new_len + 2);
+	  if (search_dirs_len > 0)
+	    strcat (search_dirs, PATH_SEPARATOR_STR);
+	  strcat (search_dirs, ptr);
+	}
+      else if (strncmp (argv[i], "-D", 2) == 0)
+	{
+	  char *ptr;
+	  int new_len, defines_len;
+
+	  ptr = &argv[i][2];
+	  new_len = strlen (ptr);
+	  defines_len = strlen (defines);
+
+	  defines = xrealloc (defines, defines_len + new_len + 4);
+	  if (defines_len > 0)
+	    strcat (defines, ",");
+
+	  strcat (defines, "\"");
+	  strcat (defines, ptr);
+	  strcat (defines, "\"");
+	}
+      else if (strcmp (argv[i], "-v") == 0)
+	verbose = 1;
+      else if (strcmp (argv[i], "-g0") == 0)
+	addarg ("/nodebug");
+      else if (strcmp (argv[i], "-O0") == 0)
+	addarg ("/noopt");
+      else if (strncmp (argv[i], "-g", 2) == 0)
+	addarg ("/debug");
+      else if (strcmp (argv[i], "-E") == 0)
+	addarg ("/preprocess");
+      else if (strcmp (argv[i], "-save-temps") == 0)
+	save_temps = 1;
+    }
+}
+
+/* The main program.  Spawn the VMS DEC C compiler after fixing up the
+   Unix-like flags and args to be what VMS DEC C wants.  */
+
+int
+main (int argc, char **argv)
+{
+  int i, len;
+  char cwdev [128], *devptr;
+  int devlen;
+  char *cwd, *rcpfile;
+  char *allargs;
+  int status;
+
+  rcp_target = getenv ("GCC_CROSS_TARGET");
+  rcp_username = getenv ("GCC_CROSS_TARGET_USER");
+  if (remote && (!rcp_target || !rcp_username))
+    {
+      fputs ("GCC_CROSS_TARGET or GCC_CROSS_TARGET_USER undefined\n", stderr);
+      return 1;
+    }
+ 
+#ifdef VMS
+  cwd = getcwd (0, 1024, 1);
+#else
+  cwd = getcwd (0, 1024);
+  strcat (cwd, "/");
+#endif
+
+  devptr = strchr (cwd, ':');
+  if (devptr)
+    devlen = (devptr - cwd) + 1;
+  else
+    devlen = 0;
+  strncpy (cwdev, cwd, devlen);
+  cwdev [devlen] = '\0';
+
+  search_dirs = xstrdup (system_search_dirs);
+  defines = xstrdup (default_defines);
+
+  preprocess_args (&argc , argv);
+  process_args (&argc , argv);
+
+  if (strlen (search_dirs) > 0)
+    {
+      addarg ("/include=(");
+      addarg (search_dirs);
+      addarg (")");
+    }
+
+  if (strlen (defines) > 0)
+    {
+      addarg ("/define=(");
+      addarg (defines);
+      addarg (")");
+    }
+
+  for (i = 1; i < argc; i++)
+    {
+      int arg_len = strlen (argv[i]);
+
+      if (strcmp (argv[i], "-o") == 0)
+	i++;
+      else if (strcmp (argv[i], "-v" ) == 0
+	       || strcmp (argv[i], "-E") == 0
+	       || strcmp (argv[i], "-c") == 0
+	       || strncmp (argv[i], "-g", 2 ) == 0
+	       || strncmp (argv[i], "-O", 2 ) == 0
+	       || strncmp (argv[i], "--cc=", 5 ) == 0
+	       || strcmp (argv[i], "-save-temps") == 0
+	       || (arg_len > 2 && strncmp (argv[i], "-I", 2) == 0)
+	       || (arg_len > 2 && strncmp (argv[i], "-D", 2) == 0))
+	;
+
+      /* Unix style file specs and VMS style switches look alike, so assume
+	 an arg consisting of one and only one slash, and that being first, is
+	 really a switch.  */
+      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))
+	addarg (argv[i]);
+      else
+	{
+	  /* Assume filename arg */
+	  char buff [256], *ptr;
+
+	  ptr = to_host_file_spec (argv[i]);
+	  arg_len = strlen (ptr);
+
+#ifdef VMS
+	  if (ptr[0] == '[')
+	    sprintf (buff, "%s%s", cwdev, ptr);
+	  else if (strchr (ptr, ':'))
+	    sprintf (buff, "%s", ptr);
+	  else
+	    sprintf (buff, "%s%s", cwd, ptr);
+#else
+	  strcpy (buff, ptr);
+#endif
+
+	  ptr = xstrdup (buff);
+	  if (remote)
+	    addarg (basename (ptr));
+	  else
+	    addarg (ptr);
+          rcpfile = ptr;
+	}
+    }
+
+  addarg (NULL);
+
+  if (verbose)
+    {
+      int i;
+
+      for (i = 0; i < comp_arg_index; i++)
+	printf ("%s ", comp_args [i]);
+
+      putchar ('\n');
+    }
+
+  for (i = 0, len = 0; comp_args[i]; i++)
+    len = len + strlen (comp_args[i]) + 1;
+
+  allargs = (char *) xmalloc (len + 1);
+
+  for (i = 0; i < len + 1; i++)
+    allargs [i] = 0;
+
+  for (i = 0; comp_args [i]; i++)
+    {
+      strcat (allargs, comp_args [i]);
+      strcat (allargs, " ");
+    }
+
+  if (remote)
+    {
+      char buff [256];
+
+      sprintf (buff, "rcp %s \"%s@%s:\"\n", rcpfile, rcp_username, rcp_target);
+      system (buff);
+
+      sprintf (buff, "rsh %s -l %s \"%s\"\n", rcp_target, rcp_username, allargs);
+      system (buff);
+
+      /* Alpha objects have to be converted to udf before rcp otherwise
+	 the variable length record counts are lost. Itanium objects
+	 are udf anyway. */
+      sprintf (buff, "rsh %s -l %s \"set file/attr=(rfm:udf,rat=none) %s\"\n",
+	       rcp_target, rcp_username, objfileshortname);
+      system (buff);
+
+      sprintf (buff, "rcp \"%s@%s:%s\" %s\n",
+        rcp_username, rcp_target, objfileshortname, objfilename);
+      system (buff);
+
+      status = 0;
+    }
+  else
+    {
+      FILE *ccfile;
+      char buff [256];
+
+      ccfile = popen (allargs, "r");
+      if (!ccfile)
+        {
+          perror ("cc popen link");
+	  exit (1);
+        }
+
+      fgets (buff, sizeof (buff), ccfile);
+      while (!feof (ccfile) ) {
+        fputs (buff, stdout);
+        fgets (buff, sizeof (buff), ccfile);
+      }
+      status = WEXITSTATUS (pclose (ccfile));
+      if ((status & 1) != 1)
+        {
+          perror ("cc pclose link");
+          exit (1);
+        }
+    }
+
+  exit (0);
+}
+
+static char new_host_filespec [255];
+static char new_host_dirspec [255];
+static char filename_buff [256];
+
+static int
+translate_unix (char *name, int type ATTRIBUTE_UNUSED)
+{
+  strcpy (filename_buff, name);
+  return 0;
+}
+
+static char *
+to_host_dir_spec (char *dirspec)
+{
+  int len = strlen (dirspec);
+
+  strcpy (new_host_dirspec, dirspec);
+
+  if (strchr (new_host_dirspec, ']') || strchr (new_host_dirspec, ':'))
+    return new_host_dirspec;
+
+  while (len > 1 && new_host_dirspec [len-1] == '/')
+    {
+      new_host_dirspec [len-1] = 0;
+      len--;
+    }
+
+#ifdef VMS
+  decc$to_vms (new_host_dirspec, translate_unix, 1, 2);
+#else
+  strcpy (filename_buff, dirspec);
+#endif
+  strcpy (new_host_dirspec, filename_buff);
+
+  return new_host_dirspec;
+
+}
+
+static char *
+to_host_file_spec (char *filespec)
+{
+  strcpy (new_host_filespec, "");
+  if (strchr (filespec, ']') || strchr (filespec, ':'))
+    strcpy (new_host_filespec, filespec);
+  else
+    {
+#ifdef VMS
+      decc$to_vms (filespec, translate_unix, 1, 1);
+#else
+      strcpy (filename_buff, filespec);
+#endif
+      strcpy (new_host_filespec, filename_buff);
+    }
+
+  return new_host_filespec;
+}
--- gcc/config/vms/vms-crt0-64.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-crt0-64.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,100 @@
+/* VMS 64bit crt0 returning VMS style condition codes .
+   Copyright (C) 2001-2005 Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#if !defined(__DECC)
+You Lose! This file can only be compiled with DEC C.
+#else
+
+/* This file can only be compiled with DEC C, due to the call to
+   lib$establish and the pragmas pointer_size.  */
+
+#pragma __pointer_size short
+
+#include <stdlib.h>
+#include <string.h>
+#include <ssdef.h>
+
+extern void decc$main ();
+
+extern int main ();
+
+static int
+handler (sigargs, mechargs)
+     void *sigargs;
+     void *mechargs;
+{
+  return SS$_RESIGNAL;
+}
+
+int
+__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
+     void *arg1, *arg2, *arg3;
+     void *image_file_desc;
+     void *arg5, *arg6;
+{
+  int argc;
+  char **argv;
+  char **envp;
+
+#pragma __pointer_size long
+
+  int i;
+  char **long_argv;
+  char **long_envp;
+
+#pragma __pointer_size short
+
+  lib$establish (handler);
+  decc$main (arg1, arg2, arg3, image_file_desc,
+	     arg5, arg6, &argc, &argv, &envp);
+
+#pragma __pointer_size long
+
+  /* Reallocate argv with 64 bit pointers. */
+  long_argv = (char **) _malloc32 (sizeof (char *) * (argc + 1));
+
+  for (i = 0; i < argc; i++)
+    long_argv[i] = (char *) _strdup32 (argv[i]);
+
+  long_argv[argc] = (char *) 0;
+
+  for (i = 0; envp[i]; i++);
+  long_envp = (char **) _malloc32 (sizeof (char *) * (i + 1));
+
+  for (i = 0; envp[i]; i++)
+    long_envp[i] = (char *) _strdup32 (envp[i]);
+
+  long_envp[i] = (char *) 0;
+
+#pragma __pointer_size short
+
+  return main (argc, long_argv, long_envp);
+}
+#endif
--- gcc/config/vms/vms-crt0.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-crt0.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,71 @@
+/* VMS crt0 returning VMS style condition codes .
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#if !defined(__DECC)
+You Lose! This file can only be compiled with DEC C.
+#else
+
+/* This file can only be compiled with DEC C, due to the call to
+   lib$establish.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <ssdef.h>
+
+extern void decc$main ();
+
+extern int main ();
+
+static int
+handler (sigargs, mechargs)
+     void *sigargs;
+     void *mechargs;
+{
+  return SS$_RESIGNAL;
+}
+
+int
+__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
+     void *arg1, *arg2, *arg3;
+     void *image_file_desc;
+     void *arg5, *arg6;
+{
+  int argc;
+  char **argv;
+  char **envp;
+
+  lib$establish (handler);
+
+  decc$main(arg1, arg2, arg3, image_file_desc, arg5, arg6,
+	    &argc, &argv, &envp);
+
+  return main (argc, argv, envp);
+}
+#endif
--- gcc/config/vms/vms-crtl-64.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-crtl-64.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,172 @@
+/* 
+   Correlation array of 64bit standard CRTL names with DECCRTL
+   function names. Currently contains only a partial list,
+   e.g. those functions use in GNAT and GCC. Memory allocation
+   routines are 32bit but this can be overridden by -mmalloc
+   subtarget switch.
+
+   Note: Please keep in alphabetical order.
+*/
+
+#undef CRTL_NAMES
+#define CRTL_NAMES                          \
+{                                           \
+{"_calloc32",    "decc$calloc",       0},   \
+{"_malloc32",    "decc$malloc",       0},   \
+{"_realloc32",   "decc$realloc",      0},   \
+{"_strdup32",    "decc$strdup",       0},   \
+{"abs",          "decc$abs",          0},   \
+{"abort",        "decc$abort",        0},   \
+{"access",       "decc$access",       0},   \
+{"accept",       "decc$accept",       0},   \
+{"acos",         "decc$tacos",        0},   \
+{"alarm",        "decc$alarm",        0},   \
+{"asin",         "decc$tasin",        0},   \
+{"atan",         "decc$tatan",        0},   \
+{"atan2",        "decc$tatan2",       0},   \
+{"atexit",       "decc$atexit",       0},   \
+{"atoi",         "decc$atoi",         0},   \
+{"atoll",        "decc$atoll",        0},   \
+{"atoq",         "decc$atoq",         0},   \
+{"basename",     "decc$_basename64",  0},   \
+{"bcmp",         "decc$bcmp",         0},   \
+{"bcopy",        "decc$bcopy",        0},   \
+{"bsearch",      "decc$_bsearch64",   0},   \
+{"bzero",        "decc$bzero",        0},   \
+{"calloc",       "decc$calloc",       0},   \
+{"ceil",         "decc$tceil",        0},   \
+{"chdir",        "decc$chdir",        0},   \
+{"chown",        "decc$chown",        0},   \
+{"clearerr",     "decc$clearerr",     0},   \
+{"clock",        "decc$clock",        0},   \
+{"close",        "decc$close",        0},   \
+{"cos",          "decc$tcos",         0},   \
+{"connect",      "decc$connect",      0},   \
+{"ctime",        "decc$ctime",        0},   \
+{"dup",          "decc$dup",          0},   \
+{"dup2",         "decc$dup2",         0},   \
+{"exit",         "decc$exit",         0},   \
+{"exp",          "decc$texp",         0},   \
+{"fabs",         "decc$tfabs",        0},   \
+{"fclose",       "decc$fclose",       0},   \
+{"fdopen",       "decc$fdopen",       0},   \
+{"fgetc",        "decc$fgetc",        0},   \
+{"fgets",        "decc$_fgets64",     0},   \
+{"fflush",       "decc$fflush",       0},   \
+{"ffs",          "decc$ffs",          0},   \
+{"floor",        "decc$tfloor",       0},   \
+{"fopen",        "decc$fopen",        0},   \
+{"fputc",        "decc$fputc",        0},   \
+{"fputs",        "decc$fputs",        0},   \
+{"free",         "decc$free",         0},   \
+{"fread",        "decc$fread",        0},   \
+{"freopen",      "decc$freopen",      0},   \
+{"fseek",        "decc$fseek",        0},   \
+{"ftell",        "decc$ftell",        0},   \
+{"fwrite",       "decc$fwrite",       0},   \
+{"getcwd",       "decc$_getcwd64",    0},   \
+{"getegid",      "decc$getegid",      0},   \
+{"getenv",       "decc$getenv",       0},   \
+{"geteuid",      "decc$geteuid",      0},   \
+{"getgid",       "decc$getgid",       0},   \
+{"gethostbyname","decc$gethostbyname",0},   \
+{"getpagesize",  "decc$getpagesize",  0},   \
+{"getpid",       "decc$getpid",       0},   \
+{"getservbyname","decc$getservbyname",0},   \
+{"gettimeofday", "decc$gettimeofday", 0},   \
+{"getuid",       "decc$getuid",       0},   \
+{"htons",        "decc$htons",        0},   \
+{"iconv",        "decc$iconv",        0},   \
+{"index",        "decc$_index64",     0},   \
+{"isatty",       "decc$isatty",       0},   \
+{"isdigit",      "decc$isdigit",      0},   \
+{"kill",         "decc$kill",         0},   \
+{"log",          "decc$tlog",         0},   \
+{"log10",        "decc$tlog10",       0},   \
+{"lseek",        "decc$lseek",        0},   \
+{"ioctl",        "decc$ioctl",        0},   \
+{"malloc",       "decc$malloc",       0},   \
+{"mbstowcs",     "decc$_mbstowcs64",  0},   \
+{"memchr",       "decc$_memchr64",    0},   \
+{"memcmp",       "decc$memcmp",       0},   \
+{"memcpy",       "decc$_memcpy64",    0},   \
+{"memmove",      "decc$_memmove64",   0},   \
+{"memset",       "decc$_memset64",    0},   \
+{"mkstemp",      "decc$mkstemp",      0},   \
+{"mktemp",       "decc$_mktemp64",    0},   \
+{"mmap",         "decc$_mmap64",      0},   \
+{"munmap",       "decc$munmap",       0},   \
+{"nl_langinfo",  "decc$nl_langinfo",  0},   \
+{"pclose",       "decc$pclose",       0},   \
+{"popen",        "decc$popen",        0},   \
+{"pow",          "decc$tpow",         0},   \
+{"printf",       "decc$txprintf",     0},   \
+{"putenv",       "decc$putenv",       0},   \
+{"puts",         "decc$puts",         0},   \
+{"random",       "decc$random",       0},   \
+{"read",         "decc$read",         0},   \
+{"realloc",      "decc$realloc",      0},   \
+{"recv",         "decc$recv",         0},   \
+{"recvfrom",     "decc$recvfrom",     0},   \
+{"recvmsg",      "decc$__bsd44___recvmsg64", 0}, \
+{"rename",       "decc$rename",       0},   \
+{"rewind",       "decc$rewind",       0},   \
+{"rindex",       "decc$_rindex64",    0},   \
+{"rmdir",        "decc$rmdir",        0},   \
+{"send",         "decc$send",         0},   \
+{"sendmsg",      "decc$__bsd44___sendmsg64", 0}, \
+{"sendto",       "decc$sendto",       0},   \
+{"setenv",       "decc$setenv",       0},   \
+{"setlocale",    "decc$setlocale",    0},   \
+{"setvbuf",      "decc$setvbuf",      0},   \
+{"signal",       "decc$signal",       0},   \
+{"sigsetmask",   "decc$sigsetmask",   0},   \
+{"sin",          "decc$tsin",         0},   \
+{"snprintf",     "decc$txsnprintf",   0},   \
+{"socket",       "decc$socket",       0},   \
+{"sqrt",         "decc$tsqrt",        0},   \
+{"strcasecmp",   "decc$strcasecmp",   0},   \
+{"strchr",       "decc$_strchr64",    0},   \
+{"strcpy",       "decc$_strcpy64",    0},   \
+{"strdup",       "decc$strdup",       0},   \
+{"strerror",     "decc$strerror",     0},   \
+{"strlen",       "decc$strlen",       0},   \
+{"strncasecmp",  "decc$strncasecmp",  0},   \
+{"strncmp",      "decc$strncmp",      0},   \
+{"strncpy",      "decc$_strncpy64",   0},   \
+{"strrchr",      "decc$_strrchr64",   0},   \
+{"strstr",       "decc$_strstr64",    0},   \
+{"strtod",       "decc$t_strtod64",   0},   \
+{"strtol",       "decc$_strtoll64",   0},   \
+{"strtoul",      "decc$_strtoull64",  0},   \
+{"sysconf",      "decc$sysconf",      0},   \
+{"system",       "decc$system",       0},   \
+{"tan",          "decc$ttan",         0},   \
+{"time",         "decc$time",         0},   \
+{"times",        "decc$times",        0},   \
+{"tmpfile",      "decc$tmpfile",      0},   \
+{"tmpnam",       "decc$_tmpnam64",    0},   \
+{"ungetc",       "decc$ungetc",       0},   \
+{"unlink",       "decc$unlink",       0},   \
+{"umask",        "decc$umask",        0},   \
+{"utime",        "decc$utime",        0},   \
+{"wait",         "decc$wait",         0},   \
+{"waitpid",      "decc$waitpid",      0},   \
+{"wcswidth",     "decc$wcswidth",     0},   \
+{"write",        "decc$write",        0},   \
+{"vfprintf",     "decc$txvfprintf",   0},   \
+{"vprintf",      "decc$txvprintf",    0},   \
+{"vsprintf",     "decc$txvsprintf",   0},   \
+{"vsnprintf",    "decc$txvsnprintf",  0},   \
+{NULL, NULL, 0}                             \
+}
+
+/* Initialize of libfuncs that are 32/64 bit memory specific */
+
+#undef MEM_LIBFUNCS_INIT
+#define MEM_LIBFUNCS_INIT                                 \
+do {                                                      \
+  memcpy_libfunc = init_one_libfunc ("decc$_memcpy64");   \
+  memmove_libfunc = init_one_libfunc ("decc$_memmove64"); \
+  memset_libfunc = init_one_libfunc ("decc$_memset64");   \
+} while (0)
--- gcc/config/vms/vms-crtl.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-crtl.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,168 @@
+/* 
+   Correlation array of standard CRTL names with DECCRTL
+   function names. Currently contains only a partial list,
+   e.g. those functions use in GNAT and GCC
+
+   Note: Please keep in alphabetical order.
+*/
+
+#define CRTL_NAMES                          \
+{                                           \
+{"_calloc32",    "decc$calloc",       0},   \
+{"_malloc32",    "decc$malloc",       0},   \
+{"_realloc32",   "decc$realloc",      0},   \
+{"_strdup32",    "decc$strdup",       0},   \
+{"abs",          "decc$abs",          0},   \
+{"abort",        "decc$abort",        0},   \
+{"access",       "decc$access",       0},   \
+{"accept",       "decc$accept",       0},   \
+{"acos",         "decc$tacos",        0},   \
+{"alarm",        "decc$alarm",        0},   \
+{"asin",         "decc$tasin",        0},   \
+{"atan",         "decc$tatan",        0},   \
+{"atan2",        "decc$tatan2",       0},   \
+{"atexit",       "decc$atexit",       0},   \
+{"atoi",         "decc$atoi",         0},   \
+{"atoll",        "decc$atoll",        0},   \
+{"atoq",         "decc$atoq",         0},   \
+{"basename",     "decc$basename",     0},   \
+{"bcmp",         "decc$bcmp",         0},   \
+{"bcopy",        "decc$bcopy",        0},   \
+{"bsearch",      "decc$bsearch",      0},   \
+{"bzero",        "decc$bzero",        0},   \
+{"calloc",       "decc$calloc",       0},   \
+{"ceil",         "decc$tceil",        0},   \
+{"chdir",        "decc$chdir",        0},   \
+{"chown",        "decc$chown",        0},   \
+{"clearerr",     "decc$clearerr",     0},   \
+{"clock",        "decc$clock",        0},   \
+{"close",        "decc$close",        0},   \
+{"cos",          "decc$tcos",         0},   \
+{"connect",      "decc$connect",      0},   \
+{"ctime",        "decc$ctime",        0},   \
+{"dup",          "decc$dup",          0},   \
+{"dup2",         "decc$dup2",         0},   \
+{"exit",         "decc$exit",         0},   \
+{"exp",          "decc$texp",         0},   \
+{"fabs",         "decc$tfabs",        0},   \
+{"fclose",       "decc$fclose",       0},   \
+{"fdopen",       "decc$fdopen",       0},   \
+{"fgetc",        "decc$fgetc",        0},   \
+{"fgets",        "decc$fgets",        0},   \
+{"fflush",       "decc$fflush",       0},   \
+{"ffs",          "decc$ffs",          0},   \
+{"floor",        "decc$tfloor",       0},   \
+{"fopen",        "decc$fopen",        0},   \
+{"fputc",        "decc$fputc",        0},   \
+{"fputs",        "decc$fputs",        0},   \
+{"free",         "decc$free",         0},   \
+{"fread",        "decc$fread",        0},   \
+{"freopen",      "decc$freopen",      0},   \
+{"fseek",        "decc$fseek",        0},   \
+{"ftell",        "decc$ftell",        0},   \
+{"fwrite",       "decc$fwrite",       0},   \
+{"getcwd",       "decc$getcwd",       0},   \
+{"getegid",      "decc$getegid",      0},   \
+{"getenv",       "decc$getenv",       0},   \
+{"geteuid",      "decc$geteuid",      0},   \
+{"getgid",       "decc$getgid",       0},   \
+{"gethostbyname","decc$gethostbyname",0},   \
+{"getpagesize",  "decc$getpagesize",  0},   \
+{"getpid",       "decc$getpid",       0},   \
+{"getservbyname","decc$getservbyname",0},   \
+{"gettimeofday", "decc$gettimeofday", 0},   \
+{"getuid",       "decc$getuid",       0},   \
+{"htons",        "decc$htons",        0},   \
+{"iconv",        "decc$iconv",        0},   \
+{"index",        "decc$index",        0},   \
+{"isatty",       "decc$isatty",       0},   \
+{"isdigit",      "decc$isdigit",      0},   \
+{"kill",         "decc$kill",         0},   \
+{"log",          "decc$tlog",         0},   \
+{"log10",        "decc$tlog10",       0},   \
+{"lseek",        "decc$lseek",        0},   \
+{"ioctl",        "decc$ioctl",        0},   \
+{"malloc",       "decc$malloc",       0},   \
+{"mbstowcs",     "decc$mbstowcs",     0},   \
+{"memchr",       "decc$memchr",       0},   \
+{"memcmp",       "decc$memcmp",       0},   \
+{"memcpy",       "decc$memcpy",       0},   \
+{"memmove",      "decc$memmove",      0},   \
+{"memset",       "decc$memset",       0},   \
+{"mkstemp",      "decc$mkstemp",      0},   \
+{"mktemp",       "decc$mktemp",       0},   \
+{"mmap",         "decc$mmap",         0},   \
+{"munmap",       "decc$munmap",       0},   \
+{"nl_langinfo",  "decc$nl_langinfo",  0},   \
+{"pclose",       "decc$pclose",       0},   \
+{"popen",        "decc$popen",        0},   \
+{"pow",          "decc$tpow",         0},   \
+{"printf",       "decc$txprintf",     0},   \
+{"putenv",       "decc$putenv",       0},   \
+{"puts",         "decc$puts",         0},   \
+{"random",       "decc$random",       0},   \
+{"read",         "decc$read",         0},   \
+{"realloc",      "decc$realloc",      0},   \
+{"recv",         "decc$recv",         0},   \
+{"recvfrom",     "decc$recvfrom",     0},   \
+{"recvmsg",      "decc$__bsd44___recvmsg32", 0}, \
+{"rename",       "decc$rename",       0},   \
+{"rewind",       "decc$rewind",       0},   \
+{"rindex",       "decc$rindex",       0},   \
+{"rmdir",        "decc$rmdir",        0},   \
+{"send",         "decc$send",         0},   \
+{"sendmsg",      "decc$__bsd44___sendmsg32", 0}, \
+{"sendto",       "decc$sendto",       0},   \
+{"setenv",       "decc$setenv",       0},   \
+{"setlocale",    "decc$setlocale",    0},   \
+{"setvbuf",      "decc$setvbuf",      0},   \
+{"signal",       "decc$signal",       0},   \
+{"sigsetmask",   "decc$sigsetmask",   0},   \
+{"sin",          "decc$tsin",         0},   \
+{"snprintf",     "decc$txsnprintf",   0},   \
+{"socket",       "decc$socket",       0},   \
+{"sqrt",         "decc$tsqrt",        0},   \
+{"strcasecmp",   "decc$strcasecmp",   0},   \
+{"strchr",       "decc$strchr",       0},   \
+{"strcpy",       "decc$strcpy",       0},   \
+{"strdup",       "decc$strdup",       0},   \
+{"strerror",     "decc$strerror",     0},   \
+{"strlen",       "decc$strlen",       0},   \
+{"strncasecmp",  "decc$strncasecmp",  0},   \
+{"strncmp",      "decc$strncmp",      0},   \
+{"strncpy",      "decc$strncpy",      0},   \
+{"strrchr",      "decc$strrchr",      0},   \
+{"strstr",       "decc$strstr",       0},   \
+{"strtod",       "decc$tstrtod",      0},   \
+{"strtol",       "decc$strtoll",      0},   \
+{"strtoul",      "decc$strtoull",     0},   \
+{"sysconf",      "decc$sysconf",      0},   \
+{"system",       "decc$system",       0},   \
+{"tan",          "decc$ttan",         0},   \
+{"time",         "decc$time",         0},   \
+{"times",        "decc$times",        0},   \
+{"tmpfile",      "decc$tmpfile",      0},   \
+{"tmpnam",       "decc$tmpnam",       0},   \
+{"ungetc",       "decc$ungetc",       0},   \
+{"unlink",       "decc$unlink",       0},   \
+{"umask",        "decc$umask",        0},   \
+{"utime",        "decc$utime",        0},   \
+{"wait",         "decc$wait",         0},   \
+{"waitpid",      "decc$waitpid",      0},   \
+{"wcswidth",     "decc$wcswidth",     0},   \
+{"write",        "decc$write",        0},   \
+{"vfprintf",     "decc$txvfprintf",   0},   \
+{"vprintf",      "decc$txvprintf",    0},   \
+{"vsprintf",     "decc$txvsprintf",   0},   \
+{"vsnprintf",    "decc$txvsnprintf",  0},   \
+{NULL, NULL, 0}                             \
+}
+
+/* Initialize of libfuncs that are 32/64 bit memory specific */
+
+#define MEM_LIBFUNCS_INIT                              \
+do {                                                   \
+  memcpy_libfunc = init_one_libfunc ("decc$memcpy");   \
+  memmove_libfunc = init_one_libfunc ("decc$memmove"); \
+  memset_libfunc = init_one_libfunc ("decc$memset");   \
+} while (0)
--- gcc/config/vms/vms-ld.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-ld.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,1516 @@
+/* VMS linker wrapper.
+   Copyright (C) 2005,2006,2007
+   Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This program is a wrapper around the VMS linker.
+   It translates Unix style command line options into corresponding
+   VMS style qualifiers and then spawns the VMS linker.  */
+
+/* #include "config.h" */
+/* #include "system.h" */
+/* #include "coretypes.h" */
+/* #include "tm.h" */
+
+#define _POSIX_EXIT 1
+
+#ifdef IN_GCC
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include <ctype.h>
+#else
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#define xstrdup strdup
+#define xmalloc malloc
+#define xcalloc calloc
+#define xrealloc realloc
+#endif
+
+#define LNM__STRING 2
+#define LNM_C_NAMLENGTH 255
+#define PSL_C_SUPER 2
+#define PSL_C_USER 3
+
+#undef PATH_SEPARATOR
+#undef PATH_SEPARATOR_STR
+#define PATH_SEPARATOR ','
+#define PATH_SEPARATOR_STR ","
+
+/* %s ~= $link /exe='exenam 'optnam./opt */
+
+static const char *remotelink_cmd=\
+"\
+$!set verify\n\
+$ exenam = f$parse (p1,,, \"NAME\")\n\
+$ exeext = f$parse (p1,,, \"TYPE\")\n\
+$ optnam = p2\n\
+$ inhibit = p3\n\
+$ share = p4\n\
+$ cwd = p5\n\
+$ if cwd.nes.\"\"\n\
+$ then\n\
+$   set def 'cwd\n\
+$ endif\n\
+$ if f$getsyi (\"ARCH_TYPE\").eq.2\n\
+$ then\n\
+$   open/read optnamchan 'optnam\n\
+$   optnamloop:\n\
+$   read/end_of_file=optnamend optnamchan objfile\n\
+$   if f$locate (\"cluster=\", objfile).eq.0\n\
+$   then\n\
+$     objfile=f$element(3,\",\",objfile)\n\
+$   endif\n\
+$   ext = f$parse (objfile,,, \"TYPE\")\n\
+$   if (ext.eqs.\".OBJ\").or. (ext.eqs.\".O\")\n\
+$   then\n\
+$     set file/attr=(rfm=var,rat=none) 'objfile\n\
+$   endif\n\
+$   goto optnamloop\n\
+$   optnamend:\n\
+$ endif\n\
+$ if f$search (\"''exenam'.exe\").nes.\"\"\n\
+$ then\n\
+$   del 'exenam.exe.0\n\
+$ endif\n\
+%s\n\
+$ if $status\n\
+$ then\n\
+$!  Link sucessful\n\
+$   if share.eq.0\n\
+$   then\n\
+$     if f$locate (\"V8\",f$getsyi (\"VERSION\")).eq.0\n\
+$     then\n\
+$       if f$trnlnm(\"GNAT$LD_NOCALL_DEBUG\").nes.\"\" then -\n\
+          set image/flags=nocall_debug 'exenam\n\
+$       if f$trnlnm(\"GNAT$LD_MKTHREADS\").nes.\"\" then -\n\
+          set image/flags=mkthreads 'exenam\n\
+$       if f$trnlnm(\"GNAT$LD_UPCALLS\").nes.\"\" then -\n\
+          set image/flags=upcalls 'exenam\n\
+$     else\n\
+$       if f$trnlnm(\"GNAT$LD_NOCALL_DEBUG\").nes.\"\" then -\n\
+          @gnu:[bin]set_exe 'exenam /nodebug\n\
+$       if f$trnlnm(\"GNAT$LD_MKTHREADS\").nes.\"\" then -\n\
+          threadcp /enable=multiple_kernel 'exenam\n\
+$       if f$trnlnm(\"GNAT$LD_UPCALLS\").nes.\"\" then -\n\
+          threadcp /enable=upcalls 'exenam\n\
+$     endif\n\
+$   endif\n\
+$   del 'optnam.0\n\
+$!  define/user sys$output 'exenam.sh\n\
+$!  write sys$output \"ssh %s \"\"mcr []''exenam'.exe\"\"\"\n\
+$!  set file/attr=(rfm=stmlf,rat=none) 'exenam.sh\n\
+$!  del 'exenam.sh.0\n\
+$ else\n\
+$!  Link failed\n\
+$   if inhibit.eq.1 then del 'optnam.0, 'exenam.exe.0\n\
+$ endif\n\
+$ self = f$environment  (\"PROCEDURE\")\n\
+$ del 'self\n\
+";
+
+/* Local variable declarations.  */
+static char *rcp_target;
+static char *rcp_target_username;
+static int ld_nocall_debug = 0;
+static int ld_mkthreads = 0;
+static int ld_upcalls = 0;
+
+/* Operation in cross remote mode */
+#ifdef CROSS_COMPILE
+static int remote = 1; /* 1 == rcp mode, 2 == nfs mode (set by env var) */
+#else
+static int remote = 0;
+#endif
+
+/* File specification for vms-dwarf2.o.  */
+static char *vmsdwarf2spec = 0;
+
+/* File specification for vms-dwarf2eh.o.  */
+static char *vmsdwarf2ehspec = 0;
+
+/* verbose = 1 if -v passed.  */
+static int verbose = 0;
+
+/* save_temps = 1 if -save-temps passed.  */
+static int save_temps = 0;
+
+/* By default don't generate executable file if there are errors
+   in the link. Override with --noinhibit-exec.  */
+static int inhibit_exec = 1;
+
+/* debug = 1 if -g passed.  */
+static int debug = 0;
+
+/* By default prefer to link with static libraries.
+   Override with -shared.  */
+static int staticp = 1;
+
+/* By default generate an executable, not a shareable image library.
+   Override with -shared.  */
+static int share = 0;
+
+/* Remember if IDENTIFICATION given on command line.  */
+static int ident = 0;
+
+/* Keep track of arg translations.  */
+static int link_arg_max = -1;
+static const char **link_args = 0;
+static int link_arg_index = -1;
+
+static int rcp_arg_max = -1;
+static const char **rcp_args = 0;
+static int rcp_arg_index = -1;
+
+/* Keep track of filenames */
+static char *sharefullfilename = (char *) "";
+static char *exefullfilename = (char *) "";
+
+static char *exefilename = (char *) "";
+
+/* System search dir list. Leave blank since link handles this
+   internally.  */
+static char *system_search_dirs = (char *) "";
+
+/* Search dir list passed on command line (with -L).  */
+static char *search_dirs;
+
+/* Local function declarations.  */
+
+/* Add STR to the list of arguments to pass to the linker. Expand the list as
+   necessary to accommodate.  */
+static void addarg (const char *);
+static void rcparg (const char *);
+
+/* Check to see if NAME is a regular file, i.e. not a directory */
+static int is_regular_file (char *);
+
+/* Translate a Unix syntax file specification FILESPEC into VMS syntax.
+   If indicators of VMS syntax found, return input string.  */
+static char *to_host_file_spec (char *);
+
+/* Locate the library named LIB_NAME in the set of paths PATH_VAL.  */
+static char *locate_lib (char *, char *);
+
+/* Given a library name NAME, i.e. foo,  Look for libfoo.lib and then
+   libfoo.a in the set of directories we are allowed to search in.  */
+static const char *expand_lib (char *);
+
+/* Preprocess the number of args P_ARGC in ARGV.
+   Look for special flags, etc. that must be handled first.  */
+static void preprocess_args (int *, char **);
+
+/* Preprocess the number of args P_ARGC in ARGV.  Look for
+   special flags, etc. that must be handled for the VMS linker.  */
+static void process_args (int *, char **);
+
+/* Link with OpenVMS 7.1 libraries if logical name set */
+static void maybe_set_link_compat (void);
+
+/* set environment defined executable attributes */
+static int set_exe (const char *);
+
+#ifdef VMS
+/* Action routine called by decc$to_vms. NAME is a file name or
+   directory name. TYPE is unused.  */
+static int translate_unix (char *, int);
+#endif
+
+int main (int, char **);
+
+static void
+addarg (const char *str)
+{
+  int i;
+
+  if (++link_arg_index >= link_arg_max)
+    {
+      const char **new_link_args
+	= (const char **) xcalloc (link_arg_max + 1000, sizeof (char *));
+
+      for (i = 0; i <= link_arg_max; i++)
+	new_link_args [i] = link_args [i];
+
+      if (link_args)
+	free (link_args);
+
+      link_arg_max += 1000;
+      link_args = new_link_args;
+    }
+
+  if (str)
+    link_args [link_arg_index] = xstrdup (str);
+  else
+    link_args [link_arg_index] = str;
+
+}
+
+static void
+rcparg (const char *str)
+{
+  int i;
+
+  if (++rcp_arg_index >= rcp_arg_max)
+    {
+      const char **new_rcp_args
+	= (const char **) xcalloc (rcp_arg_max + 1000, sizeof (char *));
+
+      for (i = 0; i <= rcp_arg_max; i++)
+	new_rcp_args [i] = rcp_args [i];
+
+      if (rcp_args)
+	free (rcp_args);
+
+      rcp_arg_max += 1000;
+      rcp_args = new_rcp_args;
+    }
+
+  if (str)
+    rcp_args [rcp_arg_index] = xstrdup (str);
+  else
+    rcp_args [rcp_arg_index] = str;
+}
+
+static char *
+locate_lib (char *lib_name, char *path_val)
+{
+  int lib_len = strlen (lib_name);
+  char *eptr, *sptr;
+
+  for (sptr = path_val; *sptr; sptr = eptr)
+    {
+      char *buf, *ptr;
+
+      while (*sptr == PATH_SEPARATOR)
+	sptr ++;
+
+      eptr = strchr (sptr, PATH_SEPARATOR);
+      if (eptr == 0)
+	eptr = strchr (sptr, 0);
+
+      buf = xmalloc ((eptr-sptr) + lib_len + 4 + 2);
+      strncpy (buf, sptr, eptr-sptr);
+      buf [eptr-sptr] = 0;
+      strcat (buf, "/");
+      strcat (buf, lib_name);
+      ptr = strchr (buf, 0);
+
+      if (staticp)
+	{
+	  /* For static links, look for shareable image libraries
+	     last.  */
+	  strcpy (ptr, ".a");
+	  if (is_regular_file (buf))
+	    return xstrdup (to_host_file_spec (buf));
+
+	  strcpy (ptr, ".olb");
+	  if (is_regular_file (buf))
+	    return xstrdup (to_host_file_spec (buf));
+
+	  strcpy (ptr, ".exe");
+	  if (is_regular_file (buf))
+	    return xstrdup (to_host_file_spec (buf));
+	}
+      else
+	{
+	  /* Otherwise look for shareable image libraries first.  */
+	  strcpy (ptr, ".exe");
+	  if (is_regular_file (buf))
+	    return xstrdup (to_host_file_spec (buf));
+
+	  strcpy (ptr, ".a");
+	  if (is_regular_file (buf))
+	    return xstrdup (to_host_file_spec (buf));
+
+	  strcpy (ptr, ".olb");
+	  if (is_regular_file (buf))
+	    return xstrdup (to_host_file_spec (buf));
+	}
+    }
+
+  return 0;
+}
+
+static const char *
+expand_lib (char *name)
+{
+  char *lib, *lib_path;
+
+  if (strcmp (name, "c") == 0)
+    return "";
+
+  else if (strcmp (name, "m") == 0)
+    /* No separate library for math functions */
+    return "";
+
+  else
+    {
+      lib = xmalloc (strlen (name) + 14);
+
+      strcpy (lib, "lib");
+      strcat (lib, name);
+      lib_path = locate_lib (lib, search_dirs);
+
+      if (lib_path)
+	return lib_path;
+    }
+
+  fprintf (stderr,
+	   "Couldn't locate library: lib%s.exe, lib%s.a or lib%s.olb\n",
+	   name, name, name);
+
+  exit (1);
+}
+
+static int
+is_regular_file (char *name)
+{
+  int ret;
+  struct stat statbuf;
+
+  ret = stat (name, &statbuf);
+  return !ret && S_ISREG (statbuf.st_mode);
+}
+
+static void
+preprocess_args (int *p_argc, char **argv)
+{
+  int i;
+
+  for (i = 1; i < *p_argc; i++)
+    if (strlen (argv[i]) >= 6 && strncmp (argv[i], "-shared", 7) == 0)
+      share = 1;
+
+  for (i = 1; i < *p_argc; i++)
+    if (strcmp (argv[i], "-o") == 0)
+      {
+	char *buff, *ptr;
+	int out_len;
+	int len;
+
+	i++;
+        ptr = xstrdup (argv[i]);
+        exefilename = basename (ptr);
+	ptr = xstrdup (to_host_file_spec (argv[i]));
+	exefullfilename = xstrdup (ptr);
+	out_len = strlen (ptr);
+	buff = xmalloc (out_len + 18);
+
+	if (share)
+	  strcpy (buff, "/share=");
+	else
+	  strcpy (buff, "/exe=");
+
+	if (remote == 1)
+	  strcat (buff, basename (ptr));
+	else
+	  strcat (buff, ptr);
+
+	addarg (buff);
+
+	if (share)
+	  {
+	    sharefullfilename = xmalloc (out_len+5);
+	    if (ptr == strchr (argv[i], ']'))
+	      strcpy (sharefullfilename, ++ptr);
+	    else if (ptr == strchr (argv[i], ':'))
+	      strcpy (sharefullfilename, ++ptr);
+	    else if (ptr == strrchr (argv[i], '/'))
+	      strcpy (sharefullfilename, ++ptr);
+	    else
+	      strcpy (sharefullfilename, argv[i]);
+
+	    len = strlen (sharefullfilename);
+	    if (strncasecmp (&sharefullfilename[len-4], ".exe", 4) == 0)
+	      sharefullfilename[len-4] = 0;
+
+	    for (ptr = sharefullfilename; *ptr; ptr++)
+	      *ptr = toupper (*ptr);
+	  }
+      }
+
+  if (strlen (exefullfilename) == 0 && !share)
+    {
+      exefilename = (char *) "a_out.exe";
+      exefullfilename = (char *) "a_out.exe";
+      addarg (xstrdup ("/exe=a_out.exe"));
+    }
+}
+
+static void
+process_args (int *p_argc, char **argv)
+{
+  int i;
+
+  for (i = 1; i < *p_argc; i++)
+    {
+      if (strlen (argv[i]) < 2)
+	continue;
+
+      if (strncmp (argv[i], "-L", 2) == 0)
+	{
+	  char *nbuff, *ptr;
+	  int new_len, search_dirs_len;
+
+	  ptr = &argv[i][2];
+	  new_len = strlen (ptr);
+	  search_dirs_len = strlen (search_dirs);
+
+	  nbuff = xmalloc (new_len + 1);
+	  strcpy (nbuff, ptr);
+
+	  /* Remove trailing slashes.  */
+	  while (new_len > 1 && nbuff [new_len - 1] == '/')
+	    {
+	      nbuff [new_len - 1] = 0;
+	      new_len--;
+	    }
+
+	  search_dirs = xrealloc (search_dirs, search_dirs_len + new_len + 2);
+	  if (search_dirs_len > 0)
+	    strcat (search_dirs, PATH_SEPARATOR_STR);
+
+	  strcat (search_dirs, nbuff);
+	  free (nbuff);
+	}
+
+      /* -v turns on verbose option here and is passed on to gcc.  */
+      else if (strcmp (argv[i], "-v") == 0)
+	verbose = 1;
+      else if (strcmp (argv[i], "--version") == 0)
+	{
+	  fprintf (stdout, "VMS Linker\n");
+          exit (0);
+	}
+      else if (strcmp (argv[i], "--help") == 0)
+	{
+	  fprintf (stdout, "VMS Linker\n");
+          exit (0);
+	}
+      else if (strcmp (argv[i], "-g0") == 0)
+	addarg ("/notraceback");
+      else if (strncmp (argv[i], "-g", 2) == 0)
+	{
+	  addarg ("/debug");
+	  debug = 1;
+	}
+      else if (strcmp (argv[i], "-static") == 0)
+	staticp = 1;
+      else if (strcmp (argv[i], "-map") == 0)
+	{
+	  char *buff, *ptr;
+
+	  buff = xmalloc (strlen (exefullfilename) + 5);
+	  strcpy (buff, exefullfilename);
+	  ptr = strrchr (buff, '.');
+	  if (ptr)
+	    *ptr = 0;
+
+	  strcat (buff, ".map");
+	  addarg ("/map=");
+	  addarg (buff);
+	  addarg ("/full");
+	}
+      else if (strcmp (argv[i], "-save-temps") == 0)
+	save_temps = 1;
+      else if (strcmp (argv[i], "--noinhibit-exec") == 0)
+	inhibit_exec = 0;
+    }
+}
+
+#ifdef VMS
+typedef struct dsc {
+  unsigned short len, mbz;
+  char *adr;
+} Descriptor;
+
+struct lst {
+  unsigned short buflen, item_code;
+  void *bufaddr;
+  void *retlenaddr;
+};
+
+static struct {
+  struct lst items [1];
+  unsigned int terminator;
+} item_lst1;
+
+static struct {
+  struct lst items [2];
+  unsigned int terminator;
+} item_lst2;
+
+/* Checks if logical names are defined for setting system library path and
+   linker program to enable compatibility with earlier VMS versions. */
+
+static void
+maybe_set_link_compat ()
+{
+  char lnm_buff [LNM_C_NAMLENGTH];
+  unsigned int lnm_buff_len;
+  int status;
+  Descriptor tabledsc, linkdsc;
+
+  tabledsc.adr = "LNM$JOB";
+  tabledsc.len = strlen (tabledsc.adr);
+  tabledsc.mbz = 0;
+
+  linkdsc.adr = "GCC_LD_SYS$LIBRARY";
+  linkdsc.len = strlen (linkdsc.adr);
+  linkdsc.mbz = 0;
+
+  item_lst1.items[0].buflen = LNM_C_NAMLENGTH;
+  item_lst1.items[0].item_code = LNM__STRING;
+  item_lst1.items[0].bufaddr = lnm_buff;
+  item_lst1.items[0].retlenaddr = &lnm_buff_len;
+  item_lst1.terminator = 0;
+
+  status = SYS$TRNLNM
+    (0,          /* attr */
+     &tabledsc,  /* tabnam */
+     &linkdsc,   /* lognam */
+     0,          /* acmode */
+     &item_lst1);
+
+  /* if GCC_LD_SYS$LIBRARY is defined, redefine SYS$LIBRARY to search
+     the equivalence name first for system libraries, then the default
+     system library directory */
+
+  if ((status & 1) == 1)
+    {
+      unsigned char acmode = PSL_C_USER; /* Don't retain after image exit */
+      char *syslib = "SYS$SYSROOT:[SYSLIB]"; /* Default SYS$LIBRARY */
+
+      /* Only visible to current and child processes */
+      tabledsc.adr = "LNM$PROCESS";
+      tabledsc.len = strlen (tabledsc.adr);
+      tabledsc.mbz = 0;
+
+      linkdsc.adr = "SYS$LIBRARY";
+      linkdsc.len = strlen (linkdsc.adr);
+      linkdsc.mbz = 0;
+
+      item_lst2.items[0].buflen = lnm_buff_len;
+      item_lst2.items[0].item_code = LNM__STRING;
+      item_lst2.items[0].bufaddr = lnm_buff;
+      item_lst2.items[0].retlenaddr = 0;
+
+      item_lst2.items[1].buflen = strlen (syslib);
+      item_lst2.items[1].item_code = LNM__STRING;
+      item_lst2.items[1].bufaddr = syslib;
+      item_lst2.items[1].retlenaddr = 0;
+      item_lst2.terminator = 0;
+
+      status = SYS$CRELNM
+	(0,          /* attr */
+	 &tabledsc,  /* tabnam */
+	 &linkdsc,   /* lognam */
+	 &acmode,    /* acmode */
+	 &item_lst2);
+
+    }
+
+  tabledsc.adr = "LNM$JOB";
+  tabledsc.len = strlen (tabledsc.adr);
+  tabledsc.mbz = 0;
+
+  linkdsc.adr = "GCC_LD_LINK";
+  linkdsc.len = strlen (linkdsc.adr);
+  linkdsc.mbz = 0;
+
+  item_lst1.items[0].buflen = LNM_C_NAMLENGTH;
+  item_lst1.items[0].item_code = LNM__STRING;
+  item_lst1.items[0].bufaddr = lnm_buff;
+  item_lst1.items[0].retlenaddr = &lnm_buff_len;
+  item_lst1.terminator = 0;
+
+  status = SYS$TRNLNM
+    (0,          /* attr */
+     &tabledsc,  /* tabnam */
+     &linkdsc,   /* lognam */
+     0,          /* acmode */
+     &item_lst1);
+
+  /* if GCC_LD_LINK is defined, redefine LINK to use the equivalence name
+     (sometimes the LINK program version is used by VMS to determine
+     compatibility) */
+
+  if ((status & 1) == 1)
+    {
+      unsigned char acmode = PSL_C_USER; /* Don't retain after image exit */
+
+      /* Only visible to current and child processes */
+      tabledsc.adr = "LNM$PROCESS";
+      tabledsc.len = strlen (tabledsc.adr);
+      tabledsc.mbz = 0;
+
+      linkdsc.adr = "LINK";
+      linkdsc.len = strlen (linkdsc.adr);
+      linkdsc.mbz = 0;
+
+      item_lst1.items[0].buflen = lnm_buff_len;
+      item_lst1.items[0].item_code = LNM__STRING;
+      item_lst1.items[0].bufaddr = lnm_buff;
+      item_lst1.items[0].retlenaddr = 0;
+      item_lst1.terminator = 0;
+
+      status = SYS$CRELNM
+	(0,          /* attr */
+	 &tabledsc,  /* tabnam */
+	 &linkdsc,   /* lognam */
+	 &acmode,    /* acmode */
+	 &item_lst1);
+    }
+}
+#else
+static void
+maybe_set_link_compat () {;}
+#endif
+
+static int set_exe (const char *arg)
+{
+  char allargs [1024], buff [256];
+  FILE *linkfile;
+
+  strcpy (allargs, "$@gnu:[bin]set_exe ");
+  strcat (allargs, exefullfilename);
+  strcat (allargs, " ");
+  strcat (allargs, arg);
+  linkfile = popen (allargs, "r");
+
+  if (verbose)
+    printf ("%s\n", allargs);
+
+  if (!linkfile)
+    {
+      perror ("ld popen set_exe");
+      return (1);
+    }
+
+  fgets (buff, sizeof (buff), linkfile);
+  while (!feof (linkfile) ) {
+    fputs (buff, stdout);
+    fgets (buff, sizeof (buff), linkfile);
+  }
+
+  if (pclose (linkfile) != 0)
+    {
+      perror ("ld pclose set_exe");
+      return (1);
+    }
+
+  return (0);
+}
+
+/* The main program.  Spawn the VMS linker after fixing up the Unix-like flags
+   and args to be what the VMS linker wants.  */
+
+int
+main (int argc, char **argv)
+{
+  int i;
+  char cwdev [128], *devptr;
+  int devlen;
+  FILE *optfile;
+  char *cwd, *ptr;
+  char *optfilename;
+  char *comfilename = '\0';
+  int status;
+
+  rcp_target = getenv ("GCC_CROSS_TARGET");
+  rcp_target_username = getenv ("GCC_CROSS_TARGET_USER");
+  if (remote && (!rcp_target || !rcp_target_username))
+    {
+      fputs ("GCC_CROSS_TARGET or GCC_CROSS_TARGET_USER undefined\n",
+             stderr);
+      return 1;
+    }
+
+  if ((remote == 1) && atoi (getenv ("GCC_CROSS_TARGET_NFS")))
+    remote = 2;
+
+  if (!remote )
+    { 
+      if (getenv ("GNAT$LD_NOCALL_DEBUG"))
+        ld_nocall_debug = 1;
+      if (getenv ("GNAT$LD_MKTHREADS"))
+        ld_mkthreads = 1;
+      if (getenv ("GNAT$LD_UPCALLS"))
+        ld_upcalls = 1;
+    }
+
+  if (getenv ("GNAT$LD_SHARED_LIBS"))
+    staticp = 0;
+
+#ifdef VMS
+  cwd = getcwd (0, 1024, 1);
+#else
+  cwd = getcwd (0, 1024);
+  strcat (cwd, "/");
+#endif
+
+  devptr = strchr (cwd, ':');
+  if (devptr)
+    devlen = (devptr - cwd) + 1;
+  else
+    devlen = 0;
+  strncpy (cwdev, cwd, devlen);
+  cwdev [devlen] = '\0';
+
+  maybe_set_link_compat ();
+
+  search_dirs = xstrdup (system_search_dirs);
+
+  addarg ("link");
+
+  /* Pass to find args that have to be append first.  */
+  preprocess_args (&argc , argv);
+
+  /* Pass to find the rest of the args.  */
+  process_args (&argc , argv);
+
+  if (!verbose)
+    addarg ("/noinform");
+
+  /* Create a temp file to hold args, otherwise we can easily exceed the VMS
+     command line length limits.  */
+
+  optfilename = xmalloc (strlen (exefilename) + 13);
+  strcpy (optfilename, exefilename);
+  ptr = strrchr (optfilename, '.');
+  if (ptr)
+    *ptr = 0;
+  strcat (optfilename, ".opt_tmpfile");
+  optfile = fopen (optfilename, "w");
+
+  if (remote)
+    {
+      comfilename = xmalloc (strlen (exefilename) + 13);
+      strcpy (comfilename, exefilename);
+      ptr = strrchr (comfilename, '.');
+      if (ptr)
+        *ptr = 0;
+      strcat (comfilename, ".com_tmpfile");
+    }
+
+  /* Write out the IDENTIFICATION argument first so that it can be overridden
+     by an options file.  */
+  for (i = 1; i < argc; i++)
+    {
+      int arg_len = strlen (argv[i]);
+
+      if (arg_len > 6 && strncasecmp (argv[i], "IDENT=", 6) == 0)
+	{
+	  /* Comes from command line. If present will always appear before
+	     IDENTIFICATION=... and will override.  */
+
+	  if (!ident)
+	    ident = 1;
+	}
+      else if (arg_len > 15
+	       && strncasecmp (argv[i], "IDENTIFICATION=", 15) == 0)
+	{
+	  /* Comes from pragma Ident ().  */
+
+	  if (!ident)
+	    {
+	      fprintf (optfile, "case_sensitive=yes\n");
+	      fprintf (optfile, "IDENTIFICATION=\"%15.15s\"\n", &argv[i][15]);
+	      fprintf (optfile, "case_sensitive=NO\n");
+	      ident = 1;
+	    }
+	}
+    }
+
+  for (i = 1; i < argc; i++)
+    {
+      int arg_len = strlen (argv[i]);
+
+      if (strcmp (argv[i], "-o") == 0)
+	i++;
+      else if (arg_len > 2 && strncmp (argv[i], "-l", 2) == 0)
+	{
+	  char *libname = (char *) expand_lib (&argv[i][2]);
+	  const char *ext;
+	  int len;
+
+	  if ((len = strlen (libname)) > 0)
+	    {
+	      char *buff;
+
+	      buff = (char *) xmalloc (strlen (cwdev) + strlen (libname) + 2);
+
+	      if (remote)
+		{
+		  /* Libraries assumed to already be in working dir
+		     on remote machine */
+		  if (remote)
+		    libname = basename (libname);
+		  len = strlen (libname);
+	          sprintf (buff, "%s\n", libname);
+	          /* rcparg (buff); */
+		}
+
+	      if (len > 4 && strcasecmp (&libname [len-4], ".exe") == 0)
+		ext = "/shareable";
+	      else
+		ext = "/library";
+
+	      if (libname[0] == '[' || libname[0] == '/')
+		{
+		  sprintf (buff, "%s%s", cwdev, libname);
+		}
+	      else
+		{
+		  sprintf (buff, "%s", libname);
+		}
+
+	      fprintf (optfile, "%s%s%s\n",
+		       (remote == 1) ? "sys$login:" : "", buff, ext);
+	    }
+	}
+
+      else if (strcmp (argv[i], "-v" ) == 0
+	       || strncmp (argv[i], "-g", 2 ) == 0
+	       || strcmp (argv[i], "-static" ) == 0
+	       || strcmp (argv[i], "-map" ) == 0
+	       || strcmp (argv[i], "-save-temps") == 0
+	       || strcmp (argv[i], "--noinhibit-exec") == 0
+	       || (arg_len > 2 && strncmp (argv[i], "-L", 2) == 0)
+	       || (arg_len >= 6 && strncmp (argv[i], "-share", 6) == 0))
+	;
+      else if (strncmp (argv[i], "--opt=", 6) == 0)
+	fprintf (optfile, "%s\n", argv[i] + 6);
+      else if (arg_len > 1 && argv[i][0] == '@')
+	{
+	  FILE *atfile;
+	  char *ptr, *ptr1;
+	  struct stat statbuf;
+	  char *buff;
+	  int len;
+
+	  if (stat (&argv[i][1], &statbuf))
+	    {
+	      fprintf (stderr, "Couldn't open linker response file: %s\n",
+		       &argv[i][1]);
+	      exit (1);
+	    }
+
+	  buff = xmalloc (statbuf.st_size + 1);
+	  atfile = fopen (&argv[i][1], "r");
+	  fgets (buff, statbuf.st_size + 1, atfile);
+	  fclose (atfile);
+
+	  len = strlen (buff);
+	  if (buff [len - 1] == '\n')
+	    {
+	      buff [len - 1] = 0;
+	      len--;
+	    }
+
+	  ptr = buff;
+
+	  do
+	  {
+	     ptr1 = strchr (ptr, ' ');
+	     if (ptr1)
+	       *ptr1 = 0;
+	     ptr = to_host_file_spec (ptr);
+	     if (ptr[0] == '[')
+	       fprintf (optfile, "%s%s\n", cwdev, ptr);
+	     else
+	       fprintf (optfile, "%s\n", ptr);
+	     ptr = ptr1 + 1;
+	  } while (ptr1);
+	}
+
+      /* Unix style file specs and VMS style switches look alike, so assume an
+	 arg consisting of one and only one slash, and that being first, is
+	 really a switch.  */
+      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))
+	addarg (argv[i]);
+      else if (arg_len > 4
+	       && strncasecmp (&argv[i][arg_len-4], ".opt", 4) == 0)
+	{
+	  FILE *optfile1;
+	  char buff [256];
+
+	  /* Disable __UNIX_FOPEN redefinition in case user supplied .opt
+	     file is not stream oriented. */
+
+	  optfile1 = (fopen) (argv[i], "r");
+	  if (optfile1 == 0)
+	    {
+	      perror (argv[i]);
+	      status = 1;
+	      goto cleanup_and_exit;
+	    }
+	  
+	  while (fgets (buff, 256, optfile1))
+	    fputs (buff, optfile);
+
+	  fclose (optfile1);
+	}
+      else if (arg_len > 7 && strncasecmp (argv[i], "GSMATCH", 7) == 0)
+	fprintf (optfile, "%s\n", argv[i]);
+      else if (arg_len > 6 && strncasecmp (argv[i], "IDENT=", 6) == 0)
+	{
+	  /* Comes from command line and will override pragma.  */
+	  fprintf (optfile, "case_sensitive=yes\n");
+	  fprintf (optfile, "IDENT=\"%15.15s\"\n", &argv[i][6]);
+	  fprintf (optfile, "case_sensitive=NO\n");
+	  ident = 1;
+	}
+      else if (arg_len > 15
+	       && strncasecmp (argv[i], "IDENTIFICATION=", 15) == 0)
+	;
+      else
+	{
+	  /* Assume filename arg.  */
+	  const char *addswitch = "";
+	  char *buff, *buff1;
+	  int buff_len;
+	  int is_cld = 0;
+
+	  argv[i] = to_host_file_spec (argv[i]);
+	  arg_len = strlen (argv[i]);
+
+	  /* Handle shareable image libraries */
+
+	  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], ".exe") == 0)
+	    addswitch = "/shareable";
+
+	  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], ".cld") == 0)
+	    {
+	      addswitch = "/shareable";
+	      is_cld = 1;
+	    }
+
+	  /* Handle object libraries */
+
+	  if (arg_len > 2 && strcasecmp (&argv[i][arg_len-2], ".a") == 0)
+	    addswitch = "/lib";
+
+	  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], ".olb") == 0)
+	    addswitch = "/lib";
+
+	  /* Absolutize file location */
+
+	  if (argv[i][0] == '[' || argv[i][0] == '/')
+	    {
+	      buff1 = (char *) xmalloc (strlen (cwdev) + strlen (argv[i]) + 1);
+	      sprintf (buff1, "%s%s", cwdev, argv[i]);
+	    }
+	  else if (strchr (argv[i], ':'))
+	    {
+	      buff1 = (char *) xmalloc (strlen (argv[i]) + 1);
+	      sprintf (buff1, "%s", argv[i]);
+	    }
+	  else
+	    {
+	      buff1 = (char *) xmalloc (strlen (cwd) + strlen (argv[i]) + 1);
+	      sprintf (buff1, "%s%s", cwd, argv[i]);
+	    }
+
+	  buff1 = to_host_file_spec (buff1);
+	  buff = (char *) xmalloc (strlen (buff1) + strlen (addswitch) + 2);
+
+	  if (remote == 1 && strlen (addswitch))
+	    {
+	      /* Libraries assumed to already be in working dir
+		 on remote machine */
+	      buff1 = basename (buff1);
+	      sprintf (buff, "%s\n", buff1);
+	      /* rcparg (buff); */
+	    }
+
+	  sprintf (buff, "%s%s", buff1, addswitch);
+
+	  buff_len = strlen (buff);
+
+	  if (buff_len >= 15
+	      && strcasecmp (&buff[buff_len - 14], "vms-dwarf2eh.o") == 0)
+	    {
+	      if (remote == 1)
+		{
+		  rcparg (buff);
+	          vmsdwarf2ehspec = xstrdup (basename (buff));
+		}
+	      else
+	        vmsdwarf2ehspec = xstrdup (buff);
+	    }
+	  else if (buff_len >= 13
+	      && strcasecmp (&buff[buff_len - 12],"vms-dwarf2.o") == 0)
+            {
+	      if (remote == 1)
+		{
+		  rcparg (buff);
+	          vmsdwarf2spec = xstrdup (basename (buff));
+		}
+	      else
+	        vmsdwarf2spec = xstrdup (buff);
+            }
+	  else if (is_cld)
+	    {
+	      addarg (buff);
+	      addarg (",");
+	    }
+	  else
+	    {
+	      int len = strlen (buff);
+
+	      if ((remote ==  1) && (
+		  (len > 2 && strncasecmp (&buff[len-2], ".o", 2) == 0)
+		   || (len > 4 && strncasecmp (&buff[len-4], ".obj", 4) == 0)))
+		{
+		  rcparg (buff);
+		  fprintf (optfile, "%s\n", basename (buff));
+		}
+	      else
+	        {
+		  fprintf (optfile, "%s\n", buff);
+		}
+	    }
+	}
+    }
+
+#if 0
+  if (share)
+    fprintf (optfile, "symbol_vector=(main=procedure)\n");
+#endif
+
+  if (vmsdwarf2ehspec)
+    {
+      /* Sequentialize exception handling info */
+
+      fprintf (optfile, "case_sensitive=yes\n");
+      fprintf (optfile, "cluster=DWARF2eh,,,%s\n", vmsdwarf2ehspec);
+      fprintf (optfile, "collect=DWARF2eh,eh_frame\n");
+      fprintf (optfile, "case_sensitive=NO\n");
+    }
+
+  if (debug && vmsdwarf2spec)
+    {
+      /* Sequentialize the debug info */
+
+      fprintf (optfile, "case_sensitive=yes\n");
+      fprintf (optfile, "cluster=DWARF2debug,,,%s\n", vmsdwarf2spec);
+      fprintf (optfile, "collect=DWARF2debug,debug_abbrev,debug_aranges,-\n");
+      fprintf (optfile, " debug_frame,debug_info,debug_line,debug_loc,-\n");
+      fprintf (optfile, " debug_macinfo,debug_pubnames,debug_str,-\n");
+      fprintf (optfile, " debug_zzzzzz\n");
+      fprintf (optfile, "case_sensitive=NO\n");
+    }
+
+#ifdef VMS_DEBUGGING_INFO
+/* VMS_DEBUGGING_INFO is defined in alpha/vms.h but not ia64/vms.h */
+  if (debug && share)
+    {
+      /* Sequentialize the shared library debug info */
+
+      char *sharefilename = basename (sharefullfilename);
+
+      fprintf (optfile, "case_sensitive=yes\n");
+      fprintf (optfile, "symbol_vector=(-\n");
+      fprintf (optfile,
+	       "%s$DWARF2.DEBUG_ABBREV/$dwarf2.debug_abbrev=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile,
+	       "%s$DWARF2.DEBUG_ARANGES/$dwarf2.debug_aranges=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile, "%s$DWARF2.DEBUG_FRAME/$dwarf2.debug_frame=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile, "%s$DWARF2.DEBUG_INFO/$dwarf2.debug_info=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile, "%s$DWARF2.DEBUG_LINE/$dwarf2.debug_line=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile, "%s$DWARF2.DEBUG_LOC/$dwarf2.debug_loc=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile,
+	       "%s$DWARF2.DEBUG_MACINFO/$dwarf2.debug_macinfo=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile,
+	       "%s$DWARF2.DEBUG_PUBNAMES/$dwarf2.debug_pubnames=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile, "%s$DWARF2.DEBUG_STR/$dwarf2.debug_str=DATA,-\n",
+	       sharefilename);
+      fprintf (optfile, "%s$DWARF2.DEBUG_ZZZZZZ/$dwarf2.debug_zzzzzz=DATA)\n",
+	       sharefilename);
+      fprintf (optfile, "case_sensitive=NO\n");
+    }
+#endif
+
+  fprintf (optfile, "PSECT_ATTR=LIB$INITIALIZE,GBL\n");
+  fclose (optfile);
+  addarg (optfilename);
+  addarg ("/opt");
+
+  if (remote == 1)
+    {
+      rcparg (optfilename);
+      rcparg (comfilename);
+    }
+
+  addarg (NULL);
+  rcparg (NULL);
+
+  if (verbose)
+    {
+      int i;
+
+      for (i = 0; i < link_arg_index; i++)
+	printf ("%s ", link_args [i]);
+      putchar ('\n');
+
+      if (remote == 1)
+	{
+	  printf ("rcp ");
+	  for (i = 0; i < rcp_arg_index; i++)
+	    printf ("%s ", rcp_args [i]);
+	  putchar ('\n');
+	}
+      }
+
+  {
+    int i;
+    int len = 0;
+    int rcplen = 0;
+    char *rcpbuff;
+
+    for (i = 0; link_args[i]; i++)
+      len = len + strlen (link_args[i]) + 1;
+
+    for (i = 0; rcp_args[i]; i++)
+      rcplen = rcplen + strlen (rcp_args[i]) + 1;
+
+    if (remote == 1)
+      {
+        rcpbuff = (char *) xmalloc (rcplen + strlen (rcp_target) +
+                                    strlen (rcp_target_username) + 8);
+        strcpy (rcpbuff, "rcp ");
+
+	for (i = 0; rcp_args [i]; i++)
+	  {
+	    strcat (rcpbuff, rcp_args [i]);
+	    strcat (rcpbuff, " ");
+	  }
+
+	sprintf (rcpbuff + strlen (rcpbuff), "%s@%s:\n",
+		 rcp_target_username, rcp_target);
+      }
+
+
+    {
+      char *allargs = (char *) xmalloc (len + 2);
+      int status = 0;
+      char buff [256];
+      FILE *linkfile;
+
+      for (i = 0; i < len + 2; i++)
+	allargs [i] = 0;
+
+      strcpy (allargs, "$");
+      for (i = 0; link_args [i]; i++)
+	{
+	  strcat (allargs, link_args [i]);
+	  strcat (allargs, " ");
+	}
+
+      if (remote)
+	{
+	  FILE *comfile;
+	  char *buff = (char *) xmalloc (
+	    strlen (rcp_target) +
+	    strlen (rcp_target_username) +
+	    strlen (comfilename) +
+	    strlen (exefilename) +
+	    strlen (optfilename) +
+	    64);
+
+	  comfile = fopen (comfilename, "w");
+	  if (verbose) fprintf (stdout, "%s\n", allargs);
+	  fprintf (comfile, remotelink_cmd, allargs, rcp_target);
+	  fclose (comfile);
+
+	  if (remote == 1)
+	    {
+	      if (verbose) fprintf (stdout, "%s", rcpbuff);
+	      system (rcpbuff);
+	    }
+
+          sprintf (buff, "sync;rsh %s -l %s \"@%s%s \\\"%s\\\" %s %d %d %s\"\n",
+	     rcp_target,
+	     rcp_target_username,
+	     (remote == 2 ? to_host_file_spec (cwd) : ""),
+	     comfilename,
+	     exefilename,
+	     optfilename,
+	     inhibit_exec,
+	     share,
+	     (remote == 2 ? to_host_file_spec (cwd) : ""));
+	  if (verbose) fprintf (stdout, buff);
+	  system (buff);
+
+	  if (remote == 1)
+	    {
+	      sprintf (buff, "rcp \"%s@%s:%s%s\" %s\n",
+		   rcp_target_username, rcp_target,
+		   exefilename, (strchr (exefilename, '.') ? "" : ".exe"),
+		   exefullfilename);
+	      if (verbose) fprintf (stdout, buff);
+	      status = system (buff); 
+	    }
+	}
+      else
+	{
+          linkfile = popen (allargs, "r");
+          if (!linkfile)
+	    {
+	      perror ("ld popen link");
+	      status = 1;
+	      goto cleanup_and_exit;
+	    }
+
+          fgets (buff, sizeof (buff), linkfile);
+          while (!feof (linkfile) ) {
+            fputs (buff, stdout);
+            fgets (buff, sizeof (buff), linkfile);
+          }
+          status = pclose (linkfile);
+          if (status != 0)
+	    {
+	      perror ("ld pclose link");
+	      goto cleanup_and_exit;
+	    }
+
+          if (debug && !share && ld_nocall_debug)
+	    {
+	      status = set_exe ("/flags=nocall_debug");
+	      if (status != 0)
+	        goto cleanup_and_exit;
+	    }
+
+          if (!share && ld_mkthreads)
+	    {
+	      status = set_exe ("/flags=mkthreads");
+	      if (status != 0)
+	        goto cleanup_and_exit;
+	    }
+
+          if (!share && ld_upcalls)
+	    {
+	      status = set_exe ("/flags=upcalls");
+	      if (status != 0)
+	        goto cleanup_and_exit;
+	    }
+	}
+
+    cleanup_and_exit:
+      if (!save_temps)
+	{
+	  remove (optfilename);
+	 }
+
+      if (remote)
+	{
+	  if (comfilename && !save_temps)
+	    remove (comfilename);
+	}
+
+      if (status == 0)
+	exit (0);
+
+      if (exefullfilename && inhibit_exec == 1)
+	remove (exefullfilename);
+
+      exit (1);
+    }
+  }
+}
+
+static char new_host_filespec [255];
+static char filename_buff [256];
+
+static int
+translate_unix (char *name, int type)
+{
+  strcpy (filename_buff, name);
+  return 0;
+}
+
+#ifndef VMS
+#ifdef CROSS_COMPILE
+int
+gcc_to_vms (unix_style_filespec, action_routine, allow_wild, no_directory)
+  const char *unix_style_filespec;
+  int (*action_routine) (char *openvms_style_filespec, int type_of_file);
+  int allow_wild;
+  int no_directory;
+{
+  char *p1, *p2;
+  char *filename = alloca (256);
+  char *filespec = alloca (strlen (unix_style_filespec) + 1);
+  char *vmsfilespec = alloca (strlen (unix_style_filespec) + 2);
+
+  strcpy (filespec, unix_style_filespec);
+  vmsfilespec [0] = 0;
+
+  vmsfilespec[0] = 0;
+  p1 = filespec;
+  p2 = strrchr (p1, '/');
+  if (p2)
+    {
+       *p2 = 0;
+      strcpy (filename, p2+1);
+    }
+  else
+    {
+      strcpy (vmsfilespec, p1);
+      return (*action_routine) (vmsfilespec, 1);
+    }
+
+  if (*p1 == '/')
+    {
+      p2 = strchr (p1+1, '/');
+      if (p2 == 0)
+	p2 = p1 + strlen (p1);
+
+      strncat (vmsfilespec, p1+1, (p2 - p1) - 1);
+      strcat (vmsfilespec, ":");
+      p1 = p2;
+
+      if (*p1 == 0)
+        {
+          strcat (vmsfilespec, filename);
+          return (*action_routine) (vmsfilespec, 1);
+        }
+      else
+        {
+	  strcat (vmsfilespec, "[");
+        }
+    }
+  else
+    {
+      if ((*p1 == '.') && (*(p1+1) == '.'))
+        {
+           strcat (vmsfilespec, "[-");
+           p1++;
+           p1++;
+        }
+      else if (*p1 == '.')
+         {
+           strcat (vmsfilespec, "[");
+           p1++;
+         }
+      else
+         strcat (vmsfilespec, "[.");
+
+      p2 = strchr (p1, '/');
+      if (p2 == 0)
+	p2 = p1 + strlen (p1);
+      strncat (vmsfilespec, p1, (p2 - p1));
+      p1 = p2;
+
+      if (*p1 == 0)
+        {
+	  strcat (vmsfilespec, "]");
+          strcat (vmsfilespec, filename);
+          return (*action_routine) (vmsfilespec, 1);
+        }
+      else
+	{
+	  strcat (vmsfilespec, ".");
+	}
+
+    }
+
+  while (*p1)
+    {
+      char *p3;
+
+      p2 = strchr (p1+1, '/');
+      if (p2 == 0)
+	p2 = p1 + strlen (p1);
+
+      if ((*(p1+1) == '.') && (*(p1+2) == '.'))
+        {
+          strcat (vmsfilespec, "-");
+        }
+      else if (*(p1+1) == '.')
+        {
+          p1 = p2;
+          continue;
+        }
+      else
+        {
+          p3 = p1 + 1;
+          while (p3 < p2)
+            {
+              if (*(p3) == '.')
+                *p3 = '_';
+              p3++;
+            }
+          strncat (vmsfilespec, p1+1, (p2 - p1) - 1);
+        }
+
+      if (*p2 == 0)
+        strcat (vmsfilespec, "]");
+      else
+        strcat (vmsfilespec, ".");
+
+      p1 = p2;
+    }
+
+  strcat (vmsfilespec, filename);
+  return (*action_routine) (vmsfilespec, 1);
+
+}
+#endif
+#endif
+
+static char *
+to_host_file_spec (char *filespec)
+{
+  /* fprintf (stderr, "to_host_file_spec: %s\n", filespec); */
+  strcpy (new_host_filespec, "");
+  if (strchr (filespec, ']') || strchr (filespec, ':'))
+    strcpy (new_host_filespec, filespec);
+  else
+    {
+      strcpy (filename_buff, filespec);
+#ifndef VMS
+#ifdef CROSS_COMPILE
+      if (remote == 2)
+	gcc_to_vms (filespec, translate_unix, 1, 1);
+#endif
+#else
+      decc$to_vms (filespec, translate_unix, 1, 1);
+#endif
+      strcpy (new_host_filespec, filename_buff);
+    }
+
+  return new_host_filespec;
+}
--- gcc/config/vms/vms.opt.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms.opt	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,8 @@
+
+mmalloc64
+Target Report RejectNegative Mask(MALLOC64)
+Malloc data into P2 space
+
+mdebug-main=
+Target RejectNegative Joined Var(vms_debug_main)
+Set name of main routine for the debugger
--- gcc/config/vms/vms-psxcrt0-64.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-psxcrt0-64.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,129 @@
+/* VMS 64bit crt0 returning Unix style condition codes .
+   Copyright (C) 2001-2005 Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#if !defined(__DECC)
+You Lose! This file can only be compiled with DEC C.
+#else
+
+/* This file can only be compiled with DEC C, due to the call to
+   lib$establish and the pragmas pointer_size.  */
+
+#pragma __pointer_size short
+
+#include <stdlib.h>
+#include <string.h>
+#include <ssdef.h>
+#include <stsdef.h>
+#include <errnodef.h>
+
+extern void decc$main ();
+extern int main ();
+
+static int
+handler (sigargs, mechargs)
+     void *sigargs;
+     void *mechargs;
+{
+  return SS$_RESIGNAL;
+}
+
+int
+__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
+     void *arg1, *arg2, *arg3;
+     void *image_file_desc;
+     void *arg5, *arg6;
+{
+  int argc;
+  char **argv;
+  char **envp;
+
+#pragma __pointer_size long
+
+  int i;
+  char **long_argv;
+  char **long_envp;
+  int status;
+
+#pragma __pointer_size short
+
+  lib$establish (handler);
+  decc$main (arg1, arg2, arg3, image_file_desc,
+	     arg5, arg6, &argc, &argv, &envp);
+
+#pragma __pointer_size long
+
+  /* Reallocate argv with 64 bit pointers. */
+  long_argv = (char **) _malloc32 (sizeof (char *) * (argc + 1));
+
+  for (i = 0; i < argc; i++)
+    long_argv[i] = (char *) _strdup32 (argv[i]);
+
+  long_argv[argc] = (char *) 0;
+
+  for (i = 0; envp[i]; i++);
+  long_envp = (char **) _malloc32 (sizeof (char *) * (i + 1));
+
+  for (i = 0; envp[i]; i++)
+    long_envp[i] = (char *) _strdup32 (envp[i]);
+
+  long_envp[i] = (char *) 0;
+
+#pragma __pointer_size short
+
+  status = main (argc, long_argv, long_envp);
+
+  /* Map into a range of 0 - 255.  */
+  status = status & 255;
+
+  if (status > 0)
+    {
+      int save_status = status;
+
+      status = C$_EXIT1 + ((status - 1) << STS$V_MSG_NO);
+
+      /* An exit failure status requires a "severe" error.  All status values
+	 are defined in errno with a successful (1) severity but can be
+	 changed to an error (2) severity by adding 1.  In addition for
+	 compatibility with UNIX exit() routines we inhibit a run-time error
+	 message from being generated on exit(1).  */
+
+      if (save_status == 1)
+	{
+	  status++;
+	  status |= STS$M_INHIB_MSG;
+	}
+    }
+
+  if (status == 0)
+    status = SS$_NORMAL;
+
+  return status;
+}
+#endif
--- gcc/config/vms/vms-psxcrt0.c.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/vms-psxcrt0.c	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,99 @@
+/* VMS crt0 returning Unix style condition codes .
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   Contributed by Douglas B. Rupp (rupp@gnat.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#if !defined(__DECC)
+You Lose! This file can only be compiled with DEC C.
+#else
+
+/* This file can only be compiled with DEC C, due to the call to
+   lib$establish.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <ssdef.h>
+#include <stsdef.h>
+#include <errnodef.h>
+
+extern void decc$main ();
+extern int main ();
+
+static int
+handler (sigargs, mechargs)
+     void *sigargs;
+     void *mechargs;
+{
+  return SS$_RESIGNAL;
+}
+
+int
+__main (arg1, arg2, arg3, image_file_desc, arg5, arg6)
+     void *arg1, *arg2, *arg3;
+     void *image_file_desc;
+     void *arg5, *arg6;
+{
+  int argc;
+  char **argv;
+  char **envp;
+  int status;
+
+  lib$establish (handler);
+  decc$main (arg1, arg2, arg3, image_file_desc, arg5, arg6,
+	     &argc, &argv, &envp);
+
+  status = main (argc, argv, envp);
+
+  /* Map into a range of 0 - 255.  */
+  status = status & 255;
+
+  if (status > 0)
+    {
+      int save_status = status;
+
+      status = C$_EXIT1 + ((status - 1) << STS$V_MSG_NO);
+
+      /* An exit failure status requires a "severe" error
+	 All status values are defined in errno with a successful
+	 (1) severity but can be changed to an error (2) severity by adding 1.
+	 In addition for compatibility with UNIX exit() routines we inhibit
+	 a run-time error message from being generated on exit(1).  */
+
+      if (save_status == 1)
+	{
+	  status++;
+	  status |= STS$M_INHIB_MSG;
+	}
+    }
+
+  if (status == 0)
+    status = SS$_NORMAL;
+
+  return status;
+}
+#endif
--- gcc/config/vms/xm-vms64.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/xm-vms64.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,22 @@
+/* Configuration for GNU C-compiler for OpenVMS/Integrity.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define HOST_LONG_FORMAT "ll"
+#define HOST_PTR_PRINTF "%llx"
--- gcc/config/vms/xm-vms.h.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/xm-vms.h	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,57 @@
+/* Configuration for GNU C-compiler for OpenVMS/Integrity.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* A couple of conditionals for execution machine are controlled here.  */
+#ifndef VMS
+#define VMS
+#endif
+
+/* Causes exit() to be redefined to __posix_exit() and
+   Posix compatible failure and success codes to be used */
+#define _POSIX_EXIT 1
+
+/* Open files in stream mode if not otherwise explicitly specified */
+#define __UNIX_FOPEN 1
+
+/* Write to stdout using fputc to avoid record terminators in pipes */
+#define __UNIX_FWRITE 1
+
+#define STDC_HEADERS 1
+
+#define HOST_EXECUTABLE_SUFFIX ".exe"
+#define HOST_OBJECT_SUFFIX ".obj"
+
+#define DUMPFILE_FORMAT "_%02d_"
+
+#define DELETE_IF_ORDINARY(NAME,ST,VERBOSE_FLAG)           \
+do                                                         \
+  {                                                        \
+    while (stat (NAME, &ST) >= 0 && S_ISREG (ST.st_mode))  \
+      if (unlink (NAME) < 0)                               \
+	{                                                  \
+	  if (VERBOSE_FLAG)                                \
+	    perror_with_name (NAME);                       \
+	  break;                                           \
+	}                                                  \
+  } while (0)
+
+#define STANDARD_EXEC_PREFIX "/gnu/libexec/gcc/"
+#define STANDARD_STARTFILE_PREFIX "/gnu/lib/"
+#define STANDARD_INCLUDE_DIR "/gnu/include"
--- gcc/config/vms/x-vms.0	1969-12-31 16:00:00.000000000 -0800
+++ gcc/config/vms/x-vms	2007-12-04 15:14:14.000000000 -0800
@@ -0,0 +1,11 @@
+# Under VMS, directory names cannot contain dots.
+# version:=$(shell echo $(BASEVER_c) | sed -e 's/\./_/g')
+
+LN = cp -p
+LN_S = cp -p
+
+# Doesn't work on VMS
+USE_COLLECT2=
+
+# There are no man pages on VMS
+POD2MAN = false
--- gcc/config.build.0	2005-11-19 10:38:39.000000000 -0800
+++ gcc/config.build	2007-12-04 15:14:14.000000000 -0800
@@ -56,12 +56,12 @@ case $build in
     # a broken tar, so we use cpio instead.
     build_install_headers_dir=install-headers-cpio
     ;;
-  alpha*-dec-*vms*)
-    build_xm_file=alpha/xm-vms.h
+  alpha64-dec-*vms*)
+    build_xm_file="vms/xm-vms.h vms/xm-vms64.h"
     build_exeext=.exe
     build_install_headers_dir=install-headers-cp
     prefix=/gnu
-    local_prefix=/gnu
+    local_prefix=/gnu/local
     ;;
   hppa1.0-*-hpux1[01]* | \
   hppa*64*-*-hpux11* | \
@@ -111,6 +111,13 @@ case $build in
   i386-*-vsta) 
     # Intel 80386's running VSTa kernel
     ;;
+  ia64-hp-*vms*)
+    build_xm_file="vms/xm-vms.h vms/xm-vms64.h"
+    build_exeext=.exe
+    build_install_headers_dir=install-headers-cp
+    prefix=/gnu
+    local_prefix=/gnu/local
+    ;;
   m68000-hp-hpux* | m68k-hp-hpux*) 
     # HP 9000 series 300
     build_install_headers_dir=install-headers-cpio
--- gcc/config.gcc.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/config.gcc	2007-12-04 15:14:14.000000000 -0800
@@ -634,17 +634,12 @@ alpha*-dec-osf[45]*)
 	;;
 alpha64-dec-*vms*)
 	tm_file="${tm_file} alpha/vms.h alpha/vms64.h"
-	xm_file="alpha/xm-vms.h"
-	tmake_file="alpha/t-alpha alpha/t-vms alpha/t-vms64 alpha/t-ieee"
-	prefix=/gnu
-	local_prefix=/gnu
-	;;
-alpha*-dec-*vms*)
-	tm_file="${tm_file} alpha/vms.h"
-	xm_file=alpha/xm-vms.h
-	tmake_file="alpha/t-alpha alpha/t-vms alpha/t-ieee"
-	prefix=/gnu
-	local_prefix=/gnu
+	xm_file="alpha/xm-vms.h vms/xm-vms64.h"
+	tmake_file="alpha/t-alpha vms/t-vms vms/t-vms64 alpha/t-vms alpha/t-ieee"
+	xmake_file=vms/x-vms
+	exeext=.exe
+	install_headers_dir=install-headers-cp
+	extra_options="${extra_options} vms/vms.opt"
 	;;
 arc-*-elf*)
 	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
@@ -1331,6 +1326,20 @@ ia64*-*-hpux*)
 	# in ia64/t-hpux, and also fix the definition of putenv in
 	# sys-protos.h (const char not char).
 	;;
+ia64-hp-*vms*)
+	tm_file="${tm_file} elfos.h ia64/sysv4.h ia64/elf.h ia64/vms.h ia64/vms64.h"
+	xm_file="vms/xm-vms.h vms/xm-vms64.h"
+	tmake_file="vms/t-vms vms/t-vms64 ia64/t-vms"
+	xmake_file=vms/x-vms
+	target_cpu_default="0"
+	if test x$gas = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_AS"
+	fi
+	exeext=.exe
+	install_headers_dir=install-headers-cp
+	extra_options="${extra_options} vms/vms.opt"
+	;;
 iq2000*-*-elf*)
         tm_file="svr4.h elfos.h iq2000/iq2000.h"
         tmake_file=iq2000/t-iq2000
--- gcc/config.host.0	2006-02-05 18:09:45.000000000 -0800
+++ gcc/config.host	2007-12-04 15:14:14.000000000 -0800
@@ -96,16 +96,13 @@ esac
 
 # Machine-specific settings.
 case ${host} in
-  alpha*-dec-*vms*)
-    host_xm_file=alpha/xm-vms.h
-    host_xmake_file=alpha/x-vms
+  alpha64-dec-*vms*)
+    host_xm_file="vms/xm-vms.h vms/xm-vms64.h"
+    host_xmake_file=vms/x-vms
     host_exeext=.exe
     host_can_use_collect2=no
-    # This removes the cpu type and manufacturer components and
-    #  replaces "." with "_" in the operating system version.
-    target_noncanonical=`echo $host | sed 's/.*-.*-\(.*\)$/\1/' | sed 's/\./_/g'`
     prefix=/gnu
-    local_prefix=/gnu
+    local_prefix=/gnu/local
     ;;
   hppa1.1-*-pro*)
     host_xmake_file="pa/x-ada"
@@ -180,6 +177,14 @@ case ${host} in
     out_host_hook_obj="${out_host_hook_obj} host-i386-darwin.o"
     host_xmake_file="${host_xmake_file} i386/x-darwin"
     ;;
+  ia64-hp-*vms*)
+    host_xm_file="vms/xm-vms.h vms/xm-vms64.h"
+    host_xmake_file=vms/x-vms
+    host_exeext=.exe
+    host_can_use_collect2=no
+    prefix=/gnu
+    local_prefix=/gnu/local
+    ;;
   powerpc-*-beos*)
     host_can_use_collect2=no
     ;;
--- gcc/configure.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/configure	2007-12-04 15:14:14.000000000 -0800
@@ -251,7 +251,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -12284,7 +12284,7 @@ else
 	# To prevent recursion we set host and build for the new
 	# invocation of configure to the build for this invocation
 	# of configure.
-	tempdir=build.$$
+	tempdir=build_$$
 	rm -rf $tempdir
 	mkdir $tempdir
 	cd $tempdir
@@ -16755,7 +16755,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
--- gcc/configure.ac.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/configure.ac	2007-12-04 15:14:14.000000000 -0800
@@ -1416,7 +1416,7 @@ else
 	# To prevent recursion we set host and build for the new
 	# invocation of configure to the build for this invocation
 	# of configure. 
-	tempdir=build.$$
+	tempdir=build_$$
 	rm -rf $tempdir
 	mkdir $tempdir
 	cd $tempdir
--- gcc/c-ppoutput.c.0	2005-11-19 10:38:38.000000000 -0800
+++ gcc/c-ppoutput.c	2007-12-04 15:14:14.000000000 -0800
@@ -27,6 +27,10 @@ Foundation, 51 Franklin Street, Fifth Fl
 #include "c-common.h"		/* For flags.  */
 #include "c-pragma.h"		/* For parse_in.  */
 
+#ifndef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+#endif
+
 /* Encapsulates state used to convert a stream of tokens into a text
    file.  */
 static struct
@@ -256,9 +260,16 @@ print_line (source_location src_loc, con
       p = cpp_quote_string (to_file_quoted,
 			    (unsigned char *) map->to_file, to_file_len);
       *p = '\0';
-      fprintf (print.outf, "# %u \"%s\"%s",
-	       print.src_line == 0 ? 1 : print.src_line,
-	       to_file_quoted, special_flags);
+
+      if (cpp_get_options (parse_in)->lang == CLK_ASM)
+	fprintf (print.outf, "%s %u \"%s\"%s",
+		 ASM_COMMENT_START,
+		 print.src_line == 0 ? 1 : print.src_line,
+	         to_file_quoted, special_flags);
+      else
+	fprintf (print.outf, "# %u \"%s\"%s",
+		 print.src_line == 0 ? 1 : print.src_line,
+		 to_file_quoted, special_flags);
 
       if (map->sysp == 2)
 	fputs (" 3 4", print.outf);
@@ -374,7 +385,10 @@ pp_dir_change (cpp_reader *pfile ATTRIBU
   /* cpp_quote_string does not nul-terminate, so we have to do it ourselves.  */
   p = cpp_quote_string (to_file_quoted, (unsigned char *) dir, to_file_len);
   *p = '\0';
-  fprintf (print.outf, "# 1 \"%s//\"\n", to_file_quoted);
+  if (cpp_get_options (parse_in)->lang == CLK_ASM)
+    fprintf (print.outf, "%s 1 \"%s//\"\n", ASM_COMMENT_START, to_file_quoted);
+  else
+    fprintf (print.outf, "# 1 \"%s//\"\n", to_file_quoted);
 }
 
 /* The file name, line number or system header flags have changed, as
--- gcc/crtstuff.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/crtstuff.c	2007-12-04 15:14:14.000000000 -0800
@@ -314,6 +314,13 @@ __do_global_dtors_aux (void)
 /* Stick a call to __do_global_dtors_aux into the .fini section.  */
 #ifdef FINI_SECTION_ASM_OP
 CRT_CALL_STATIC_FUNCTION (FINI_SECTION_ASM_OP, __do_global_dtors_aux)
+#elif TARGET_ABI_OPEN_VMS
+static void __attribute__((used))
+__do_global_dtors_aux_1 (void)
+{
+  atexit (__do_global_dtors_aux);
+}
+CRT_CALL_STATIC_FUNCTION (INIT_SECTION_ASM_OP, __do_global_dtors_aux_1)
 #else /* !defined(FINI_SECTION_ASM_OP) */
 static func_ptr __do_global_dtors_aux_fini_array_entry[]
   __attribute__ ((__unused__, section(".fini_array")))
--- gcc/dbxout.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/dbxout.c	2007-12-04 15:22:29.000000000 -0800
@@ -373,6 +373,7 @@ const struct gcc_debug_hooks dbx_debug_h
   dbxout_source_line,		         /* source_line */
   dbxout_begin_prologue,	         /* begin_prologue */
   debug_nothing_int_charstar,	         /* end_prologue */
+  debug_nothing_int_charstar,	         /* begin_epilogue */
   dbxout_end_epilogue,		         /* end_epilogue */
 #ifdef DBX_FUNCTION_FIRST
   dbxout_begin_function,
@@ -409,6 +410,7 @@ const struct gcc_debug_hooks xcoff_debug
   xcoffout_source_line,
   xcoffout_begin_prologue,	         /* begin_prologue */
   debug_nothing_int_charstar,	         /* end_prologue */
+  debug_nothing_int_charstar,	         /* begin_epilogue */
   xcoffout_end_epilogue,
   debug_nothing_tree,		         /* begin_function */
   xcoffout_end_function,
--- gcc/debug.c.0	2005-11-19 10:38:36.000000000 -0800
+++ gcc/debug.c	2007-12-04 15:14:14.000000000 -0800
@@ -36,6 +36,7 @@ const struct gcc_debug_hooks do_nothing_
   debug_nothing_int_charstar,	         /* source_line */
   debug_nothing_int_charstar,	         /* begin_prologue */
   debug_nothing_int_charstar,	         /* end_prologue */
+  debug_nothing_int_charstar,	         /* begin_epilogue */
   debug_nothing_int_charstar,	         /* end_epilogue */
   debug_nothing_tree,		         /* begin_function */
   debug_nothing_int,		         /* end_function */
--- gcc/debug.h.0	2005-12-20 18:09:23.000000000 -0800
+++ gcc/debug.h	2007-12-04 15:14:14.000000000 -0800
@@ -70,6 +70,9 @@ struct gcc_debug_hooks
      function.  */
   void (* end_prologue) (unsigned int line, const char *file);
 
+  /* Called at beginning of epilogue code. */
+  void (* begin_epilogue) (unsigned int line, const char *file);
+
   /* Record end of epilogue code.  */
   void (* end_epilogue) (unsigned int line, const char *file);
 
@@ -154,6 +157,8 @@ extern const struct gcc_debug_hooks vmsd
 /* Dwarf2 frame information.  */
 
 extern void dwarf2out_begin_prologue (unsigned int, const char *);
+extern void dwarf2out_end_prologue (unsigned int, const char *);
+extern void dwarf2out_begin_epilogue (unsigned int, const char *);
 extern void dwarf2out_end_epilogue (unsigned int, const char *);
 extern void dwarf2out_frame_init (void);
 extern void dwarf2out_frame_finish (void);
--- gcc/doc/hostconfig.texi.0	2005-11-19 10:29:44.000000000 -0800
+++ gcc/doc/hostconfig.texi	2007-12-04 15:14:14.000000000 -0800
@@ -217,6 +217,10 @@ not to pass unnecessary arguments to sub
 If defined, the string used to indicate an argument of type @code{long
 long} to functions like @code{printf}.  The default value is
 @code{"ll"}. 
+
+@item HOST_LONG_FORMAT
+If defined, the string used to indicate an argument of type @code{long}
+to functions like @code{printf}.  The default value is @code{"l"}. 
 @end ftable
 
 In addition, if @command{configure} generates an incorrect definition of
--- gcc/doc/invoke.texi.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/doc/invoke.texi	2007-12-04 15:14:14.000000000 -0800
@@ -487,7 +487,7 @@ Objective-C and Objective-C++ Dialects}.
 -mmemory-latency=@var{time}}
 
 @emph{DEC Alpha/VMS Options}
-@gccoptlist{-mvms-return-codes}
+@gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mmalloc64}
 
 @emph{FRV Options}
 @gccoptlist{-mgpr-32  -mgpr-64  -mfpr-32  -mfpr-64 @gol
@@ -552,6 +552,9 @@ Objective-C and Objective-C++ Dialects}.
 -mfixed-range=@var{register-range} -mtls-size=@var{tls-size} @gol
 -mtune=@var{cpu-type} -mt -pthread -milp32 -mlp64}
 
+@emph{IA-64/VMS Options}
+@gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mmalloc64}
+
 @emph{M32R/D Options}
 @gccoptlist{-m32r2 -m32rx -m32r @gol
 -mdebug @gol
@@ -7332,6 +7335,7 @@ platform.
 * HPPA Options::
 * i386 and x86-64 Options::
 * IA-64 Options::
+* IA-64/VMS Options::
 * M32C Options::
 * M32R/D Options::
 * M680x0 Options::
@@ -8603,8 +8607,17 @@ These @samp{-m} options are defined for 
 @table @gcctabopt
 @item -mvms-return-codes
 @opindex mvms-return-codes
-Return VMS condition codes from main.  The default is to return POSIX
+Return VMS condition codes from main. The default is to return POSIX
 style condition (e.g.@ error) codes.
+
+@item -mdebug-main=@var{prefix}
+@opindex mdebug-main=@var{prefix}
+Flag the first routine whose name starts with @var{prefix} as the main
+routine for the debugger.
+
+@item -mmalloc64
+@opindex mmalloc64
+Default to 64bit memory allocation routines.
 @end table
 
 @node FRV Options
@@ -9800,6 +9813,27 @@ to 64 bits.  These are HP-UX specific fl
 
 @end table
 
+@node IA-64/VMS Options
+@subsection IA-64/VMS Options
+
+These @samp{-m} options are defined for the IA-64/VMS implementations:
+
+@table @gcctabopt
+@item -mvms-return-codes
+@opindex mvms-return-codes
+Return VMS condition codes from main. The default is to return POSIX
+style condition (e.g.@ error) codes.
+
+@item -mdebug-main=@var{prefix}
+@opindex mdebug-main=@var{prefix}
+Flag the first routine whose name starts with @var{prefix} as the main
+routine for the debugger.
+
+@item -mmalloc64
+@opindex mmalloc64
+Default to 64bit memory allocation routines.
+@end table
+
 @node M32C Options
 @subsection M32C Options
 @cindex M32C options
--- gcc/doc/tm.texi.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/doc/tm.texi	2007-12-04 15:14:14.000000000 -0800
@@ -8243,11 +8243,35 @@ line debug info sections.  This will res
 tables, and hence is desirable if it works.
 @end defmac
 
+@defmac DWARF2_FILE_TIME_NAME (@var{filename})
+Define this macro to return the modification date/time value for filename.
+@end defmac
+
+@defmac DWARF2_FILE_SIZE_NAME (@var{filename})
+Define this macro to return the file size for filename.
+@end defmac
+
+@defmac DWARF2_DIR_SHOULD_END_WITH_SEPARATOR
+Define this macro to be a nonzero value if the directory specifications which
+are output in the debug info should end with a separator.
+@end defmac
+
+@defmac DWARF2_FILE_NAME (@var{filename}, @var{dirlen})
+Define this macro to return the dwarf2 filename, given the full filename
+and the length of the directory prefix
+@end defmac
+
 @defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})
 A C statement to issue assembly directives that create a difference
 between the two given labels, using an integer of the given size.
 @end defmac
 
+@defmac ASM_OUTPUT_DWARF_DELTA_UNITS (@var{stream}, @var{size}, @var{label1}, @var{label2}, @var{units})
+A C statement to issue assembly directives that create a difference
+between the two given labels in system defined units, e.g. instruction
+slots on IA64 VMS, using an integer of the given size.
+@end defmac
+
 @defmac ASM_OUTPUT_DWARF_OFFSET (@var{stream}, @var{size}, @var{label})
 A C statement to issue assembly directives that create a
 section-relative reference to the given label, using an integer of the
--- gcc/dwarf2asm.c.0	2005-11-19 10:38:34.000000000 -0800
+++ gcc/dwarf2asm.c	2007-12-04 15:14:14.000000000 -0800
@@ -119,6 +119,34 @@ dw2_asm_output_delta (int size, const ch
   va_end (ap);
 }
 
+/* Output the difference between two symbols in instruction units
+   in a given size.  */
+
+void
+dw2_asm_output_delta_units (int size ATTRIBUTE_UNUSED,
+			    const char *lab1, const char *lab2,
+		            const int units ATTRIBUTE_UNUSED,
+			    const char *comment, ...)
+{
+  va_list ap;
+
+  va_start (ap, comment);
+
+#ifndef ASM_OUTPUT_DWARF_DELTA_UNITS
+  dw2_asm_output_delta (size, lab1, lab2, comment);
+#else
+  ASM_OUTPUT_DWARF_DELTA_UNITS (asm_out_file, size, lab1, lab2, units);
+  if (flag_debug_asm && comment)
+    {
+      fprintf (asm_out_file, "\t%s ", ASM_COMMENT_START);
+      vfprintf (asm_out_file, comment, ap);
+    }
+  fputc ('\n', asm_out_file);
+#endif
+
+  va_end (ap);
+}
+
 /* Output a section-relative reference to a label.  In general this
    can only be done for debugging symbols.  E.g. on most targets with
    the GNU linker, this is accomplished with a direct reference and
--- gcc/dwarf2asm.h.0	2005-11-19 10:38:34.000000000 -0800
+++ gcc/dwarf2asm.h	2007-12-04 15:14:14.000000000 -0800
@@ -29,6 +29,10 @@ extern void dw2_asm_output_delta (int, c
 				  const char *, ...)
      ATTRIBUTE_NULL_PRINTF_4;
 
+extern void dw2_asm_output_delta_units (int, const char *, const char *,
+				        const int, const char *, ...)
+     ATTRIBUTE_NULL_PRINTF_5;
+
 extern void dw2_asm_output_offset (int, const char *, const char *, ...)
      ATTRIBUTE_NULL_PRINTF_3;
 
--- gcc/dwarf2.h.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/dwarf2.h	2007-12-04 15:14:14.000000000 -0800
@@ -353,6 +353,8 @@ enum dwarf_attribute
     DW_AT_body_end   = 0x2106,
     DW_AT_GNU_vector = 0x2107,
     /* VMS extensions.  */
+    DW_AT_HP_prologue = 0x2005,
+    DW_AT_HP_epilogue = 0x2008,
     DW_AT_VMS_rtnbeg_pd_address = 0x2201,
     /* GNAT Extensions.  */
     DW_AT_GNAT_encoding = 0x2301,
--- gcc/dwarf2out.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/dwarf2out.c	2007-12-04 15:14:14.000000000 -0800
@@ -195,6 +195,18 @@ DEF_VEC_ALLOC_P(rtx,gc);
    must be kept around forever.  */
 static GTY(()) VEC(rtx,gc) *used_rtx_array;
 
+#ifndef DWARF2_FILE_NAME
+#define DWARF2_FILE_NAME(FILENAME, DIRLEN) FILENAME + DIRLEN
+#endif
+
+#ifndef DWARF2_FILE_TIME_NAME
+#define DWARF2_FILE_TIME_NAME(FILENAME) 0
+#endif
+
+#ifndef DWARF2_FILE_SIZE_NAME
+#define DWARF2_FILE_SIZE_NAME(FILENAME) 0
+#endif
+
 /* A pointer to the base of a list of incomplete types which might be
    completed at some later time.  incomplete_types_list needs to be a
    VEC(tree,gc) because we want to tell the garbage collector about
@@ -275,6 +287,8 @@ typedef struct dw_fde_struct GTY(())
   const char *dw_fde_begin;
   const char *dw_fde_current_label;
   const char *dw_fde_end;
+  const char *dw_fde_end_prologue;
+  const char *dw_fde_begin_epilogue;
   const char *dw_fde_hot_section_label;
   const char *dw_fde_hot_section_end_label;
   const char *dw_fde_unlikely_section_label;
@@ -424,6 +438,14 @@ static void def_cfa_1 (const char *, dw_
 #define FUNC_END_LABEL		"LFE"
 #endif
 
+#ifndef PROLOGUE_END_LABEL
+#define PROLOGUE_END_LABEL	"LPE"
+#endif
+
+#ifndef EPILOGUE_BEGIN_LABEL
+#define EPILOGUE_BEGIN_LABEL	"LEB"
+#endif
+
 #ifndef FRAME_BEGIN_LABEL
 #define FRAME_BEGIN_LABEL	"Lframe"
 #endif
@@ -2556,6 +2578,8 @@ dwarf2out_begin_prologue (unsigned int l
   fde->dw_fde_unlikely_section_end_label = NULL;
   fde->dw_fde_switched_sections = false;
   fde->dw_fde_end = NULL;
+  fde->dw_fde_end_prologue = NULL;
+  fde->dw_fde_begin_epilogue = NULL;
   fde->dw_fde_cfi = NULL;
   fde->funcdef_number = current_function_funcdef_no;
   fde->nothrow = TREE_NOTHROW (current_function_decl);
@@ -2572,6 +2596,48 @@ dwarf2out_begin_prologue (unsigned int l
 #endif
 }
 
+/* Output a marker (i.e. a label) for the end of the generated code
+   for a function prologue.  This gets called *after* the prologue code has
+   been generated.  */
+
+void
+dwarf2out_end_prologue (unsigned int line ATTRIBUTE_UNUSED,
+			const char *file ATTRIBUTE_UNUSED)
+{
+  dw_fde_ref fde;
+  char label[MAX_ARTIFICIAL_LABEL_BYTES];
+
+  /* Output a label to mark the endpoint of the code generated for this
+     function.  */
+  ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,
+			       current_function_funcdef_no);
+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, PROLOGUE_END_LABEL,
+			  current_function_funcdef_no);
+  fde = &fde_table[fde_table_in_use - 1];
+  fde->dw_fde_end_prologue = xstrdup (label);
+}
+
+/* Output a marker (i.e. a label) for the beginning of the generated code
+   for a function epilogue.  This gets called *before* the prologue code has
+   been generated.  */
+
+void
+dwarf2out_begin_epilogue (unsigned int line ATTRIBUTE_UNUSED,
+			  const char *file ATTRIBUTE_UNUSED)
+{
+  dw_fde_ref fde;
+  char label[MAX_ARTIFICIAL_LABEL_BYTES];
+
+  /* Output a label to mark the endpoint of the code generated for this
+     function.  */
+  ASM_GENERATE_INTERNAL_LABEL (label, EPILOGUE_BEGIN_LABEL,
+			       current_function_funcdef_no);
+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, EPILOGUE_BEGIN_LABEL,
+			  current_function_funcdef_no);
+  fde = &fde_table[fde_table_in_use - 1];
+  fde->dw_fde_begin_epilogue = xstrdup (label);
+}
+
 /* Output a marker (i.e. a label) for the absolute end of the generated code
    for a function definition.  This gets called *after* the epilogue code has
    been generated.  */
@@ -2660,7 +2726,8 @@ enum dw_val_class
   dw_val_class_fde_ref,
   dw_val_class_lbl_id,
   dw_val_class_lbl_offset,
-  dw_val_class_str
+  dw_val_class_str,
+  dw_val_class_delta
 };
 
 /* Describe a double word constant value.  */
@@ -2708,6 +2775,12 @@ typedef struct dw_val_struct GTY(())
       struct indirect_string_node * GTY ((tag ("dw_val_class_str"))) val_str;
       char * GTY ((tag ("dw_val_class_lbl_id"))) val_lbl_id;
       unsigned char GTY ((tag ("dw_val_class_flag"))) val_flag;
+      struct dw_val_delta_union
+	{
+	  char * lbl1;
+	  char * lbl2;
+	  int units;
+	} GTY ((tag ("dw_val_class_delta"))) val_delta;
     }
   GTY ((desc ("%1.val_class"))) v;
 }
@@ -3592,6 +3665,7 @@ const struct gcc_debug_hooks dwarf2_debu
   dwarf2out_source_line,
   dwarf2out_begin_prologue,
   debug_nothing_int_charstar,	/* end_prologue */
+  dwarf2out_begin_epilogue,
   dwarf2out_end_epilogue,
   dwarf2out_begin_function,
   debug_nothing_int,		/* end_function */
@@ -4215,6 +4289,11 @@ static void prune_unused_types_walk_attr
 static void prune_unused_types_prune (dw_die_ref);
 static void prune_unused_types (void);
 static int maybe_emit_file (int);
+static inline const char *AT_delta1 (dw_attr_ref);
+static inline const char *AT_delta2 (dw_attr_ref);
+static inline int AT_delta_units (dw_attr_ref);
+static inline void add_AT_delta (dw_die_ref, enum dwarf_attribute,
+				 const char *, const char *, int);
 
 /* Section names used to hold DWARF debugging information.  */
 #ifndef DEBUG_INFO_SECTION
@@ -4675,14 +4754,24 @@ dwarf_attr_name (unsigned int attr)
       return "DW_AT_MIPS_tail_loop_begin";
     case DW_AT_MIPS_epilog_begin:
       return "DW_AT_MIPS_epilog_begin";
+#if TARGET_ABI_OPEN_VMS
+    case DW_AT_HP_prologue:
+      return "DW_AT_HP_prologue";
+#else
     case DW_AT_MIPS_loop_unroll_factor:
       return "DW_AT_MIPS_loop_unroll_factor";
+#endif
     case DW_AT_MIPS_software_pipeline_depth:
       return "DW_AT_MIPS_software_pipeline_depth";
     case DW_AT_MIPS_linkage_name:
       return "DW_AT_MIPS_linkage_name";
+#if TARGET_ABI_OPEN_VMS
+    case DW_AT_HP_epilogue:
+      return "DW_AT_HP_epilogue";
+#else
     case DW_AT_MIPS_stride:
       return "DW_AT_MIPS_stride";
+#endif
     case DW_AT_MIPS_abstract_name:
       return "DW_AT_MIPS_abstract_name";
     case DW_AT_MIPS_clone_origin:
@@ -5191,6 +5280,22 @@ AT_addr (dw_attr_ref a)
   return a->dw_attr_val.v.val_addr;
 }
 
+/* Add a delta attribute value to a DIE.  */
+
+static inline void
+add_AT_delta (dw_die_ref die, enum dwarf_attribute attr_kind, const char *lbl1, const char *lbl2, int units)
+{
+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));
+
+  attr->dw_attr_next = NULL;
+  attr->dw_attr = attr_kind;
+  attr->dw_attr_val.val_class = dw_val_class_delta;
+  attr->dw_attr_val.v.val_delta.lbl1 = xstrdup (lbl1);
+  attr->dw_attr_val.v.val_delta.lbl2 = xstrdup (lbl2);
+  attr->dw_attr_val.v.val_delta.units = units;
+  add_dwarf_attr (die, attr);
+}
+
 /* Add a label identifier attribute value to a DIE.  */
 
 static inline void
@@ -5249,6 +5354,39 @@ add_AT_range_list (dw_die_ref die, enum 
   add_dwarf_attr (die, attr);
 }
 
+/* Return the start label of a delta attribute  */
+
+static inline const char *
+AT_delta1 (dw_attr_ref a)
+{
+  if (a && (AT_class (a) == dw_val_class_delta))
+    return a->dw_attr_val.v.val_delta.lbl1;
+
+  abort ();
+}
+
+/* Return the end label of a delta attribute  */
+
+static inline const char *
+AT_delta2 (dw_attr_ref a)
+{
+  if (a && (AT_class (a) == dw_val_class_delta))
+    return a->dw_attr_val.v.val_delta.lbl2;
+
+  abort ();
+}
+
+/* Return the units value of a delta attribute  */
+
+static inline int
+AT_delta_units (dw_attr_ref a)
+{
+  if (a && (AT_class (a) == dw_val_class_delta))
+    return a->dw_attr_val.v.val_delta.units;
+
+  abort ();
+}
+
 static inline const char *
 AT_lbl (dw_attr_ref a)
 {
@@ -5768,6 +5906,10 @@ print_die (dw_die_ref die, FILE *outfile
 	  else
 	    fprintf (outfile, "die -> <null>");
 	  break;
+	case dw_val_class_delta:
+	  fprintf (outfile, "delta: (%s-%s)/f(%d)",
+		   AT_delta2 (a), AT_delta1 (a), AT_delta_units (a));
+	  break;
 	case dw_val_class_lbl_id:
 	case dw_val_class_lbl_offset:
 	  fprintf (outfile, "label: %s", AT_lbl (a));
@@ -5982,6 +6124,7 @@ attr_checksum (dw_attr_ref at, struct md
       break;
 
     case dw_val_class_fde_ref:
+    case dw_val_class_delta:
     case dw_val_class_lbl_id:
     case dw_val_class_lbl_offset:
       break;
@@ -6083,6 +6226,7 @@ same_dw_val_p (dw_val_node *v1, dw_val_n
       return same_die_p (v1->v.val_die_ref.die, v2->v.val_die_ref.die, mark);
 
     case dw_val_class_fde_ref:
+    case dw_val_class_delta:
     case dw_val_class_lbl_id:
     case dw_val_class_lbl_offset:
       return 1;
@@ -6656,6 +6800,9 @@ size_of_die (dw_die_ref die)
 	case dw_val_class_fde_ref:
 	  size += DWARF_OFFSET_SIZE;
 	  break;
+	case dw_val_class_delta:
+	  size += 4;
+	  break;
 	case dw_val_class_lbl_id:
 	  size += DWARF2_ADDR_SIZE;
 	  break;
@@ -6849,6 +6996,8 @@ value_format (dw_attr_ref a)
 	return DW_FORM_ref;
     case dw_val_class_fde_ref:
       return DW_FORM_data;
+    case dw_val_class_delta:
+      return DW_FORM_data4;
     case dw_val_class_lbl_id:
       return DW_FORM_addr;
     case dw_val_class_lbl_offset:
@@ -7166,6 +7315,14 @@ output_die (dw_die_ref die)
 	  }
 	  break;
 
+	case dw_val_class_delta:
+	  if (AT_delta_units (a))
+	    dw2_asm_output_delta_units (4, AT_delta2 (a), AT_delta1 (a),
+				        AT_delta_units (a), "%s", name);
+	  else
+	    dw2_asm_output_delta (4, AT_delta2 (a), AT_delta1 (a), "%s", name);
+	  break;
+
 	case dw_val_class_lbl_id:
 	  dw2_asm_output_addr (DWARF2_ADDR_SIZE, AT_lbl (a), "%s", name);
 	  break;
@@ -7757,7 +7914,12 @@ output_file_names (void)
     if (dirs[i].used != 0)
       {
 	dirs[i].used = idx++;
-	dw2_asm_output_nstring (dirs[i].path, dirs[i].length - 1,
+	dw2_asm_output_nstring (dirs[i].path,
+#ifdef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR
+				dirs[i].length,
+#else
+				dirs[i].length - 1,
+#endif
 				"Directory Entry: 0x%x", dirs[i].used);
       }
 
@@ -7774,17 +7936,20 @@ output_file_names (void)
       int file_idx = backmap[i];
       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;
 
-      dw2_asm_output_nstring (files[file_idx].path + dirs[dir_idx].length, -1,
-			      "File Entry: 0x%lx", (unsigned long) i);
+      dw2_asm_output_nstring
+       (DWARF2_FILE_NAME (files[file_idx].path, dirs[dir_idx].length),
+                          -1, "File Entry: 0x%lx", (unsigned long) i);
 
       /* Include directory index.  */
       dw2_asm_output_data_uleb128 (dirs[dir_idx].used, NULL);
 
       /* Modification time.  */
-      dw2_asm_output_data_uleb128 (0, NULL);
+      dw2_asm_output_data_uleb128
+	(DWARF2_FILE_TIME_NAME (files[file_idx].path), NULL);
 
       /* File length in bytes.  */
-      dw2_asm_output_data_uleb128 (0, NULL);
+      dw2_asm_output_data_uleb128
+	(DWARF2_FILE_SIZE_NAME (files[file_idx].path), NULL);
     }
 
   dw2_asm_output_data (1, 0, "End file name table");
@@ -10603,8 +10768,21 @@ static void
 add_comp_dir_attribute (dw_die_ref die)
 {
   const char *wd = get_src_pwd ();
+
   if (wd != NULL)
-    add_AT_string (die, DW_AT_comp_dir, wd);
+    {
+      int wdlen;
+      char *wd1;
+
+      wdlen = strlen (wd);
+      wd1 = alloca (wdlen + 2);
+      strcpy (wd1, wd);
+#ifdef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR
+      wd1 [wdlen] = DIR_SEPARATOR;
+      wd1 [wdlen + 1] = 0;
+#endif
+      add_AT_string (die, DW_AT_comp_dir, wd1);
+    }
 }
 
 /* Given a tree node describing an array bound (either lower or upper) output
@@ -11794,6 +11972,20 @@ gen_subprogram_die (tree decl, dw_die_re
 				       current_function_funcdef_no);
 	  add_AT_lbl_id (subr_die, DW_AT_high_pc, label_id);
 	  
+#if TARGET_ABI_OPEN_VMS
+      {
+        dw_fde_ref fde = &fde_table[current_funcdef_fde];
+
+        if (fde->dw_fde_end_prologue)
+          add_AT_delta (subr_die, DW_AT_HP_prologue,
+	    fde->dw_fde_begin, fde->dw_fde_end_prologue, 1);
+
+        if (fde->dw_fde_begin_epilogue)
+          add_AT_delta (subr_die, DW_AT_HP_epilogue,
+	    fde->dw_fde_begin, fde->dw_fde_begin_epilogue, 1);
+      }
+#endif
+
 	  add_pubname (decl, subr_die);
 	  add_arange (decl, subr_die);
 	}
--- gcc/except.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/except.c	2007-12-04 15:14:14.000000000 -0800
@@ -3571,6 +3571,12 @@ output_function_exception_table (const c
 
 #ifdef TARGET_UNWIND_INFO
   /* TODO: Move this into target file.  */
+  fputs ("\t.type\t", asm_out_file);
+  output_addr_const (asm_out_file, eh_personality_libfunc);
+  fputs (", @function", asm_out_file);
+  fputs ("\n\t.global\t", asm_out_file);
+  output_addr_const (asm_out_file, eh_personality_libfunc);
+  fputs ("\n", asm_out_file);
   fputs ("\t.personality\t", asm_out_file);
   output_addr_const (asm_out_file, eh_personality_libfunc);
   fputs ("\n\t.handlerdata\n", asm_out_file);
--- gcc/final.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/final.c	2007-12-04 15:14:14.000000000 -0800
@@ -1705,7 +1705,6 @@ final_scan_insn (rtx insn, FILE *file, i
 	case NOTE_INSN_DELETED:
 	case NOTE_INSN_LOOP_BEG:
 	case NOTE_INSN_LOOP_END:
-	case NOTE_INSN_FUNCTION_END:
 	case NOTE_INSN_REPEATED_LINE_NUMBER:
 	case NOTE_INSN_EXPECTED_VALUE:
 	case NOTE_INSN_UPDATE_SJLJ_CONTEXT:
@@ -1804,6 +1803,10 @@ final_scan_insn (rtx insn, FILE *file, i
 
 	  break;
 
+	case NOTE_INSN_FUNCTION_END:
+	  (*debug_hooks->begin_epilogue) (last_linenum, last_filename);
+	  break;
+
 	case NOTE_INSN_BLOCK_BEG:
 	  if (debug_info_level == DINFO_LEVEL_NORMAL
 	      || debug_info_level == DINFO_LEVEL_VERBOSE
--- gcc/function.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/function.c	2007-12-04 15:14:14.000000000 -0800
@@ -5398,7 +5398,9 @@ epilogue_done:
 	 there are line number notes before where we inserted the
 	 prologue we should move them, and (2) we should generate a
 	 note before the end of the first basic block, if there isn't
-	 one already there.
+	 one already there.  Also move the NOTE_INSN_FUNCTION_BEG and
+	 (possibly) NOTE_INSN_FUNCTION_END notes, as those can be
+	 relevant for debug info generation.
 
 	 ??? This behavior is completely broken when dealing with
 	 multiple entry functions.  We simply place the note always
@@ -5409,7 +5411,10 @@ epilogue_done:
       for (insn = prologue_end; insn; insn = prev)
 	{
 	  prev = PREV_INSN (insn);
-	  if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)
+	  if (NOTE_P (insn)
+	      && (NOTE_LINE_NUMBER (insn) > 0
+		  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG
+		  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END))
 	    {
 	      /* Note that we cannot reorder the first insn in the
 		 chain, since rest_of_compilation relies on that
--- gcc/genconditions.c.0	2005-11-19 10:38:37.000000000 -0800
+++ gcc/genconditions.c	2007-12-04 15:14:14.000000000 -0800
@@ -88,9 +88,9 @@ write_header (void)
 #include \"system.h\"\n\
 /* If we don't have __builtin_constant_p, or it's not acceptable in array\n\
    initializers, fall back to assuming that all conditions potentially\n\
-   vary at run time.  It works in 3.0.1 and later; 3.0 only when not\n\
-   optimizing.  */\n\
-#if GCC_VERSION < 3001\n\
+   vary at run time. It works in 3.0.1 and later if optimizing;\n\
+   3.0 only when not optimizing.  */\n\
+#if ((GCC_VERSION < 3001) || !__OPTIMIZE__)\n\
 #include \"dummy-conditions.c\"\n\
 #else\n\
 #include \"coretypes.h\"\n\
--- gcc/genmultilib.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/genmultilib	2007-12-04 15:14:14.000000000 -0800
@@ -134,9 +134,9 @@ fi
 
 echo "static const char *const multilib_raw[] = {"
 
-mkdir tmpmultilib.$$ || exit 1
+mkdir tmpmultilib_$$ || exit 1
 # Use cd ./foo to avoid CDPATH output.
-cd ./tmpmultilib.$$ || exit 1
+cd ./tmpmultilib_$$ || exit 1
 
 # What we want to do is select all combinations of the sets in
 # options.  Each combination which includes a set of mutually
@@ -422,6 +422,6 @@ if [ "x${disable_multilib}" = xyes ]; th
 fi
 
 cd ..
-rm -r tmpmultilib.$$
+rm -r tmpmultilib_$$
 
 exit 0
--- gcc/hwint.h.0	2005-11-19 10:38:39.000000000 -0800
+++ gcc/hwint.h	2007-12-04 15:14:14.000000000 -0800
@@ -16,6 +16,12 @@
 #define HOST_BITS_PER_LONG  (CHAR_BIT * SIZEOF_LONG)
 
 /* The string that should be inserted into a printf style format to
+   indicate a "long" operand.  */
+#ifndef HOST_LONG_FORMAT 
+#define HOST_LONG_FORMAT "l"
+#endif
+
+/* The string that should be inserted into a printf style format to
    indicate a "long long" operand.  */
 #ifndef HOST_LONG_LONG_FORMAT 
 #define HOST_LONG_LONG_FORMAT "ll"
@@ -70,14 +76,16 @@ extern char sizeof_long_long_must_be_8[s
 /* Various printf format strings for HOST_WIDE_INT.  */
 
 #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG
-# define HOST_WIDE_INT_PRINT "l"
+# define HOST_WIDE_INT_PRINT HOST_LONG_FORMAT
 # define HOST_WIDE_INT_PRINT_C "L"
   /* 'long' might be 32 or 64 bits, and the number of leading zeroes
      must be tweaked accordingly.  */
 # if HOST_BITS_PER_WIDE_INT == 64
-#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX "0x%lx%016lx"
+#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX \
+     "0x%" HOST_LONG_FORMAT "x%016" HOST_LONG_FORMAT "x"
 # else
-#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX "0x%lx%08lx"
+#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX \
+     "0x%" HOST_LONG_FORMAT "x%08" HOST_LONG_FORMAT "x"
 # endif
 #else
 # define HOST_WIDE_INT_PRINT HOST_LONG_LONG_FORMAT
--- gcc/Makefile.in.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/Makefile.in	2007-12-04 15:14:14.000000000 -0800
@@ -332,7 +332,9 @@ GCC_CFLAGS=$(CFLAGS_FOR_TARGET) $(INTERN
 # ---------------------------------------------------
 
 AR_FOR_TARGET := $(shell \
-  if [ -f $(objdir)/../binutils/ar ] ; then \
+  if [ -f $(objdir)/ar ] ; then \
+    echo $(objdir)/ar ; \
+  elif [ -f $(objdir)/../binutils/ar ] ; then \
     echo $(objdir)/../binutils/ar ; \
   else \
     if [ "$(host)" = "$(target)" ] ; then \
@@ -502,6 +504,9 @@ man7dir = $(mandir)/man7
 # Dir for temp files.
 tmpdir = /tmp
 
+# Default number of bytes to skip in stage compare
+ skip_bytes = 16
+
 # Directory in which to put HTML
 htmldir = $(objdir)/HTML/gcc-$(version)
 
@@ -2588,6 +2593,7 @@ build/insn-conditions.o : insn-condition
   $(GTM_H) $(RTL_H) $(TM_P_H) $(REGS_H) function.h $(RECOG_H) real.h output.h \
   $(FLAGS_H) hard-reg-set.h $(RESOURCE_H) toplev.h reload.h gensupport.h \
   insn-constants.h coretypes.h
+	$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) insn-conditions.c $(OUTPUT_OPTION)
 
 build/dummy-conditions.o : dummy-conditions.c
 
@@ -4266,17 +4272,17 @@ fastcompare fastcompare3 fastcompare4 fa
 	    for file in $$dir/*$(objext); do \
 	      case "$@" in \
 		slowcompare* ) \
-		  tail +16c ./$$file > tmp-foo1; \
-		  tail +16c stage$$stage/$$file > tmp-foo2; \
+		  tail +$(skip_bytes)c ./$$file > tmp-foo1; \
+		  tail +$(skip_bytes)c stage$$stage/$$file > tmp-foo2; \
 		  cmp tmp-foo1 tmp-foo2 > /dev/null 2>&1; \
 		  cmpret=$$?; \
 		  ;; \
 		fastcompare* ) \
-		  cmp $$file stage$$stage/$$file 16 16 > /dev/null 2>&1; \
+		  cmp $$file stage$$stage/$$file $(skip_bytes) $(skip_bytes) > /dev/null 2>&1; \
 		  cmpret=$$?; \
 		  ;; \
 		gnucompare* ) \
-		  cmp --ignore-initial=16 $$file stage$$stage/$$file > /dev/null 2>&1; \
+		  cmp --ignore-initial=$(skip_bytes) $$file stage$$stage/$$file > /dev/null 2>&1; \
 		  cmpret=$$?; \
 		  ;; \
 	      esac ; \
--- gcc/mips-tfile.c.0	2007-12-04 15:25:15.000000000 -0800
+++ gcc/mips-tfile.c	2007-12-04 15:14:14.000000000 -0800
@@ -4014,7 +4014,8 @@ write_varray (varray_t *vp,    /* virtua
     return;
 
   if (debug)
-    fprintf (stderr, "\twarray\tvp = %p, offset = %7lu, size = %7lu, %s\n",
+    fprintf (stderr, "\twarray\tvp = " HOST_PTR_PRINTF
+	    ", offset = %7lu, size = %7lu, %s\n",
 	     (void *) vp, (unsigned long) offset,
 	     vp->num_allocated * vp->object_size, str);
 
@@ -4053,7 +4054,8 @@ write_object (void)
   off_t offset;
 
   if (debug)
-    fprintf (stderr, "\n\twrite\tvp = %p, offset = %7u, size = %7lu, %s\n",
+    fprintf (stderr, "\n\twrite\tvp = " HOST_PTR_PRINTF
+	    ", offset = %7u, size = %7lu, %s\n",
 	     (void *) &symbolic_header, 0,
 	     (unsigned long) sizeof (symbolic_header), "symbolic header");
 
@@ -4083,7 +4085,8 @@ write_object (void)
 	pfatal_with_name (object_name);
 
       if (debug)
-	fprintf (stderr, "\twrite\tvp = %p, offset = %7lu, size = %7lu, %s\n",
+	fprintf (stderr, "\twrite\tvp = " HOST_PTR_PRINTF
+		", offset = %7lu, size = %7lu, %s\n",
 		 (void *) &orig_linenum, (long) symbolic_header.cbLineOffset,
 		 (long) symbolic_header.cbLine, "Line numbers");
 
@@ -4114,7 +4117,8 @@ write_object (void)
 	pfatal_with_name (object_name);
 
       if (debug)
-	fprintf (stderr, "\twrite\tvp = %p, offset = %7lu, size = %7lu, %s\n",
+	fprintf (stderr, "\twrite\tvp = " HOST_PTR_PRINTF
+		", offset = %7lu, size = %7lu, %s\n",
 		 (void *) &orig_opt_syms, (long) symbolic_header.cbOptOffset,
 		 num_write, "Optimizer symbols");
 
@@ -4202,7 +4206,8 @@ write_object (void)
 	   file_ptr = file_ptr->next_file)
 	{
 	  if (debug)
-	    fprintf (stderr, "\twrite\tvp = %p, offset = %7lu, size = %7lu, %s\n",
+	    fprintf (stderr, "\twrite\tvp = " HOST_PTR_PRINTF
+		    ", offset = %7lu, size = %7lu, %s\n",
 		     (void *) &file_ptr->fdr, file_offset,
 		     (unsigned long) sizeof (FDR), "File header");
 
@@ -4234,7 +4239,8 @@ write_object (void)
 	pfatal_with_name (object_name);
 
       if (debug)
-	fprintf (stderr, "\twrite\tvp = %p, offset = %7lu, size = %7lu, %s\n",
+	fprintf (stderr, "\twrite\tvp = " HOST_PTR_PRINTF
+		", offset = %7lu, size = %7lu, %s\n",
 		 (void *) &orig_rfds, (long) symbolic_header.cbRfdOffset,
 		 num_write, "Relative file descriptors");
 
@@ -5045,7 +5051,7 @@ allocate_cluster (Size_t npages)
     pfatal_with_name ("allocate_cluster");
 
   if (debug > 3)
-    fprintf (stderr, "\talloc\tnpages = %lu, value = %p\n",
+    fprintf (stderr, "\talloc\tnpages = %lu, value = " HOST_PTR_PRINTF "\n",
 	     (unsigned long) npages, (void *) ptr);
 
   return ptr;
--- gcc/print-rtl.c.0	2005-11-19 10:38:37.000000000 -0800
+++ gcc/print-rtl.c	2007-12-04 15:14:14.000000000 -0800
@@ -287,7 +287,7 @@ print_rtx (rtx in_rtx)
 		if (flag_dump_unnumbered)
 		  fprintf (outfile, "#");
 		else
-		  fprintf (outfile, "%p",
+		  fprintf (outfile, HOST_PTR_PRINTF,
 			   (char *) NOTE_BLOCK (in_rtx));
 		sawclose = 1;
 		break;
@@ -539,7 +539,7 @@ print_rtx (rtx in_rtx)
 	break;
 
       case 't':
-	fprintf (outfile, " %p", (void *) XTREE (in_rtx, i));
+	fprintf (outfile, " " HOST_PTR_PRINTF, (void *) XTREE (in_rtx, i));
 	break;
 
       case '*':
--- gcc/print-tree.c.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/print-tree.c	2007-12-04 15:14:14.000000000 -0800
@@ -73,7 +73,7 @@ print_node_brief (FILE *file, const char
      name if any.  */
   if (indent > 0)
     fprintf (file, " ");
-  fprintf (file, "%s <%s %p",
+  fprintf (file, "%s <%s " HOST_PTR_PRINTF,
 	   prefix, tree_code_name[(int) TREE_CODE (node)], (char *) node);
 
   if (class == tcc_declaration)
@@ -218,7 +218,7 @@ print_node (FILE *file, const char *pref
   indent_to (file, indent);
 
   /* Print the slot this node is in, and its code, and address.  */
-  fprintf (file, "%s <%s %p",
+  fprintf (file, "%s <%s " HOST_PTR_PRINTF,
 	   prefix, tree_code_name[(int) TREE_CODE (node)], (void *) node);
 
   /* Print the name, if any.  */
@@ -492,7 +492,7 @@ print_node (FILE *file, const char *pref
 	       && DECL_STRUCT_FUNCTION (node) != 0)
 	{
 	  indent_to (file, indent + 4);
-	  fprintf (file, "saved-insns %p",
+	  fprintf (file, "saved-insns " HOST_PTR_PRINTF,
 		   (void *) DECL_STRUCT_FUNCTION (node));
 	}
 
@@ -752,7 +752,7 @@ print_node (FILE *file, const char *pref
 	  break;
 
     	case STATEMENT_LIST:
-	  fprintf (file, " head %p tail %p stmts",
+	  fprintf (file, " head " HOST_PTR_PRINTF " tail " HOST_PTR_PRINTF " stmts",
 		   (void *) node->stmt_list.head, (void *) node->stmt_list.tail);
 	  {
 	    tree_stmt_iterator i;
@@ -760,7 +760,7 @@ print_node (FILE *file, const char *pref
 	      {
 		/* Not printing the addresses of the (not-a-tree)
 		   'struct tree_stmt_list_node's.  */
-		fprintf (file, " %p", (void *)tsi_stmt (i));
+		fprintf (file, " " HOST_PTR_PRINTF, (void *)tsi_stmt (i));
 	      }
 	    fprintf (file, "\n");
 	    for (i = tsi_start (node); !tsi_end_p (i); tsi_next (&i))
@@ -801,13 +801,13 @@ print_node (FILE *file, const char *pref
 	    {
 	      indent_to (file, indent + 3);
 	      if (SSA_NAME_PTR_INFO (node))
-		fprintf (file, " ptr-info %p",
+		fprintf (file, " ptr-info " HOST_PTR_PRINTF,
 			 (void *) SSA_NAME_PTR_INFO (node));
 	      if (SSA_NAME_VALUE (node))
-		fprintf (file, " value %p",
+		fprintf (file, " value " HOST_PTR_PRINTF,
 			 (void *) SSA_NAME_VALUE (node));
 	      if (SSA_NAME_AUX (node))
-		fprintf (file, " aux %p", SSA_NAME_AUX (node));
+		fprintf (file, " aux " HOST_PTR_PRINTF, SSA_NAME_AUX (node));
 	    }
 	  break;
 
--- gcc/sdbout.c.0	2005-11-19 10:38:37.000000000 -0800
+++ gcc/sdbout.c	2007-12-04 15:14:14.000000000 -0800
@@ -324,6 +324,7 @@ const struct gcc_debug_hooks sdb_debug_h
   sdbout_begin_prologue,	         /* begin_prologue */
   debug_nothing_int_charstar,	         /* end_prologue */
 #endif
+  debug_nothing_int_charstar,	         /* begin_epilogue */
   sdbout_end_epilogue,		         /* end_epilogue */
   sdbout_begin_function,	         /* begin_function */
   sdbout_end_function,		         /* end_function */
--- gcc/system.h.0	2007-12-04 15:25:14.000000000 -0800
+++ gcc/system.h	2007-12-04 15:14:14.000000000 -0800
@@ -47,6 +47,9 @@ Software Foundation, 51 Franklin Street,
 #endif
 
 /* Use the unlocked open routines from libiberty.  */
+#ifdef fopen /* fopen is a #define on VMS */
+#undef fopen
+#endif
 #define fopen(PATH,MODE) fopen_unlocked(PATH,MODE)
 #define fdopen(FILDES,MODE) fdopen_unlocked(FILDES,MODE)
 #define freopen(PATH,MODE,STREAM) freopen_unlocked(PATH,MODE,STREAM)
@@ -511,6 +514,19 @@ extern int vsnprintf(char *, size_t, con
 # define mkdir(a,b) mkdir(a)
 #endif
 
+/* Provide a way to print an address via printf.  */
+#ifndef HOST_PTR_PRINTF
+# ifdef HAVE_PRINTF_PTR
+#  define HOST_PTR_PRINTF "%p"
+# elif SIZEOF_INT == SIZEOF_VOID_P
+#  define HOST_PTR_PRINTF "%x"
+# elif SIZEOF_LONG == SIZEOF_VOID_P
+#  define HOST_PTR_PRINTF "%lx"
+# else
+#  define HOST_PTR_PRINTF "%llx"
+# endif
+#endif /* ! HOST_PTR_PRINTF */
+
 /* By default, colon separates directories in a path.  */
 #ifndef PATH_SEPARATOR
 #define PATH_SEPARATOR ':'
@@ -728,7 +744,7 @@ extern void fancy_abort (const char *, i
         TARGET_ESC TARGET_FF TARGET_NEWLINE TARGET_TAB TARGET_VT	   \
         LINK_LIBGCC_SPECIAL DONT_ACCESS_GBLS_AFTER_EPILOGUE		   \
 	TARGET_OPTIONS TARGET_SWITCHES EXTRA_CC_MODES FINALIZE_PIC	   \
-	PREDICATE_CODES SPECIAL_MODE_PREDICATES HOST_PTR_PRINTF		   \
+	PREDICATE_CODES SPECIAL_MODE_PREDICATES 			   \
 	STACK_CHECK_PROBE_INTERVAL
 
 /* Hooks that are no longer used.  */
--- gcc/vmsdbgout.c.0	2005-11-19 10:38:36.000000000 -0800
+++ gcc/vmsdbgout.c	2007-12-04 15:14:14.000000000 -0800
@@ -1,8 +1,7 @@
 /* Output VMS debug format symbol table information from GCC.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    Contributed by Douglas B. Rupp (rupp@gnat.com).
-   Updated by Bernard W. Giroud (bgiroud@users.sourceforge.net).
 
 This file is part of GCC.
 
@@ -18,8 +17,8 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING.  If not, write to the Free
-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301, USA.  */
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
 
 #include "config.h"
 #include "system.h"
@@ -104,26 +103,12 @@ static unsigned int file_info_table_in_u
    table.  */
 #define FILE_TABLE_INCREMENT 64
 
-/* A structure to hold basic information for the VMS end
-   routine.  */
-
-typedef struct vms_func_struct
-{
-  const char *vms_func_name;
-  unsigned funcdef_number;
-}
-vms_func_node;
-
-typedef struct vms_func_struct *vms_func_ref;
-
+static char **funcnam_table;
+static unsigned int *funcnum_table;
 static unsigned int func_table_allocated;
 static unsigned int func_table_in_use;
 #define FUNC_TABLE_INCREMENT 256
 
-/* A pointer to the base of a table that contains frame description
-   information for each routine.  */
-static vms_func_ref func_table;
-
 /* Local pointer to the name of the main input file.  Initialized in
    avmdbgout_init.  */
 static const char *primary_filename;
@@ -181,6 +166,7 @@ static void vmsdbgout_end_epilogue (unsi
 static void vmsdbgout_begin_function (tree);
 static void vmsdbgout_decl (tree);
 static void vmsdbgout_global_decl (tree);
+static void vmsdbgout_type_decl (tree, int);
 static void vmsdbgout_abstract_function (tree);
 
 /* The debug hooks structure.  */
@@ -198,17 +184,18 @@ const struct gcc_debug_hooks vmsdbg_debu
    vmsdbgout_source_line,
    vmsdbgout_begin_prologue,
    vmsdbgout_end_prologue,
+   debug_nothing_int_charstar,	/* begin_epilogue */
    vmsdbgout_end_epilogue,
    vmsdbgout_begin_function,
    vmsdbgout_end_function,
    vmsdbgout_decl,
    vmsdbgout_global_decl,
-   debug_nothing_tree_int,	  /* type_decl */
-   debug_nothing_tree_tree,       /* imported_module_or_decl */
-   debug_nothing_tree,		  /* deferred_inline_function */
+   vmsdbgout_type_decl,
+   debug_nothing_tree_tree,     /* imported_module_or_decl */
+   debug_nothing_tree,		/* deferred_inline_function */
    vmsdbgout_abstract_function,
-   debug_nothing_rtx,		  /* label */
-   debug_nothing_int,		  /* handle_pch */
+   debug_nothing_rtx,		/* label */
+   debug_nothing_int,		/* handle_pch */
    debug_nothing_rtx,		  /* var_location */
    debug_nothing_void,            /* switch_text_section */
    0                              /* start_end_main_source_file */
@@ -429,13 +416,15 @@ addr_const_to_string (char *str, rtx x)
   char buf1[256];
   char buf2[256];
 
- restart:
+restart:
   str[0] = '\0';
   switch (GET_CODE (x))
     {
     case PC:
-      gcc_assert (flag_pic);
-      strcat (str, ",");
+      if (flag_pic)
+	strcat (str, ",");
+      else
+	abort ();
       break;
 
     case SYMBOL_REF:
@@ -795,9 +784,8 @@ write_rtnbeg (int rtnnum, int dosizeonly
   char label[MAX_ARTIFICIAL_LABEL_BYTES];
   DST_ROUTINE_BEGIN rtnbeg;
   DST_PROLOG prolog;
-  vms_func_ref fde = &func_table[rtnnum];
 
-  rtnname = (char *)fde->vms_func_name;
+  rtnname = funcnam_table [rtnnum];
   rtnnamelen = strlen (rtnname);
   rtnentryname = concat (rtnname, "..en", NULL);
 
@@ -868,7 +856,8 @@ write_rtnbeg (int rtnnum, int dosizeonly
       totsize += write_debug_header (&prolog.dst_a_prolog_header, "prolog",
 				     dosizeonly);
 
-      ASM_GENERATE_INTERNAL_LABEL (label, FUNC_PROLOG_LABEL, fde->funcdef_number);
+      ASM_GENERATE_INTERNAL_LABEL (label, FUNC_PROLOG_LABEL,
+				   funcnum_table [rtnnum]);
       totsize += write_debug_addr (label, "prolog breakpoint addr",
 				   dosizeonly);
     }
@@ -886,8 +875,6 @@ write_rtnend (int rtnnum, int dosizeonly
   char label1[MAX_ARTIFICIAL_LABEL_BYTES];
   char label2[MAX_ARTIFICIAL_LABEL_BYTES];
   int totsize;
-  vms_func_ref fde = &func_table[rtnnum];
-  int corrected_rtnnum = fde->funcdef_number;
 
   totsize = 0;
 
@@ -902,8 +889,10 @@ write_rtnend (int rtnnum, int dosizeonly
   totsize += write_debug_data1 (rtnend.dst_b_rtnend_unused, "unused",
 				dosizeonly);
 
-  ASM_GENERATE_INTERNAL_LABEL (label1, FUNC_BEGIN_LABEL, corrected_rtnnum);
-  ASM_GENERATE_INTERNAL_LABEL (label2, FUNC_END_LABEL, corrected_rtnnum);
+  ASM_GENERATE_INTERNAL_LABEL (label1, FUNC_BEGIN_LABEL,
+			       funcnum_table [rtnnum]);
+  ASM_GENERATE_INTERNAL_LABEL (label2, FUNC_END_LABEL,
+			       funcnum_table [rtnnum]);
   totsize += write_debug_delta4 (label2, label1, "routine size", dosizeonly);
 
   return totsize;
@@ -1372,13 +1361,12 @@ vmsdbgout_ignore_block (tree block)
   return retval;
 }
 
-/* Add an entry for function DECL into the func_table.  */
+/* Add an entry for function DECL into the funcnam_table.  */
 
 static void
 vmsdbgout_begin_function (tree decl)
 {
   const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);
-  vms_func_ref fde;
 
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
     (*dwarf2_debug_hooks.begin_function) (decl);
@@ -1386,16 +1374,16 @@ vmsdbgout_begin_function (tree decl)
   if (func_table_in_use == func_table_allocated)
     {
       func_table_allocated += FUNC_TABLE_INCREMENT;
-      func_table
-        = (vms_func_ref) xrealloc (func_table,
-				   func_table_allocated * sizeof (vms_func_node));
+      funcnam_table = xrealloc (funcnam_table,
+			     func_table_allocated * sizeof (char *));
+      funcnum_table = xrealloc (funcnum_table,
+			     func_table_allocated * sizeof (unsigned int));
     }
 
   /* Add the new entry to the end of the function name table.  */
-  fde = &func_table[func_table_in_use++];
-  fde->vms_func_name = xstrdup (name);
-  fde->funcdef_number = current_function_funcdef_no;
-
+  funcnam_table[func_table_in_use] = xstrdup (name);
+  funcnum_table[func_table_in_use] = current_function_funcdef_no;
+  func_table_in_use++;
 }
 
 static char fullname_buff [4096];
@@ -1412,13 +1400,9 @@ full_name (const char *filename)
   fgetname (fp, fullname_buff, 1);
   fclose (fp);
 #else
-  getcwd (fullname_buff, sizeof (fullname_buff));
-
-  strcat (fullname_buff, "/");
-  strcat (fullname_buff, filename);
-
-  /* ??? Insert hairy code here to translate Unix style file specification
-     to VMS style.  */
+  /* Unix paths really mess up VMS debug. Better to just output the
+     base filename */
+  strcpy (fullname_buff, filename);
 #endif
 
   return fullname_buff;
@@ -1441,47 +1425,16 @@ lookup_filename (const char *file_name)
   register char *fn;
   register unsigned i;
   char *fnam;
-  long long cdt;
-  long ebk;
-  short ffb;
-  char rfo;
   char flen;
-  struct stat statbuf;
+  long long cdt = 0;
+  long ebk = 0;
+  short ffb = 0;
+  char rfo = 0;
+  long siz = 0;
+  int ver = 0;
 
-  if (stat (file_name, &statbuf) == 0)
-    {
-      long gmtoff;
-#ifdef VMS
-      struct tm *ts;
-
-      /* Adjust for GMT.  */
-      ts = (struct tm *) localtime (&statbuf.st_ctime);
-      gmtoff = ts->tm_gmtoff;
-
-      /* VMS has multiple file format types.  */
-      rfo = statbuf.st_fab_rfm;
-#else
-      /* Is GMT adjustment an issue with a cross-compiler? */
-      gmtoff = 0;
-
-      /* Assume stream LF type file.  */
-      rfo = 2;
-#endif
-      cdt = 10000000 * (statbuf.st_ctime + gmtoff + vms_epoch_offset);
-      ebk = statbuf.st_size / 512 + 1;
-      ffb = statbuf.st_size - ((statbuf.st_size / 512) * 512);
-      fnam = full_name (file_name);
-      flen = strlen (fnam);
-    }
-  else
-    {
-      cdt = 0;
-      ebk = 0;
-      ffb = 0;
-      rfo = 0;
-      fnam = (char *) "";
-      flen = 0;
-    }
+  fnam = full_name (file_name);
+  flen = strlen (fnam);
 
   /* Check to see if the file name that was searched on the previous call
      matches this file name. If so, return the index.  */
@@ -1514,6 +1467,12 @@ lookup_filename (const char *file_name)
 				   * sizeof (dst_file_info_entry)));
     }
 
+  if (vms_file_stats_name (file_name, &cdt, &siz, &rfo, &ver) == 0)
+    {
+      ebk = siz / 512 + 1;
+      ffb = siz - ((siz / 512) * 512);
+    }
+
   /* Add the new entry to the end of the filename table.  */
   file_info_table[file_info_table_in_use].file_name = xstrdup (fnam);
   file_info_table[file_info_table_in_use].max_line = 0;
@@ -1542,7 +1501,7 @@ vmsdbgout_source_line (register unsigned
       dst_line_info_ref line_info;
 
       targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL,
-				      line_info_table_in_use);
+				 line_info_table_in_use);
 
       /* Expand the line info table if necessary.  */
       if (line_info_table_in_use == line_info_table_allocated)
@@ -1606,7 +1565,8 @@ vmsdbgout_init (const char *main_input_f
   /* Skip the first entry - file numbers begin at 1 */
   file_info_table_in_use = 1;
 
-  func_table = (vms_func_ref) xcalloc (FUNC_TABLE_INCREMENT, sizeof (vms_func_node));
+  funcnam_table = xcalloc (FUNC_TABLE_INCREMENT, sizeof (char *));
+  funcnum_table = xcalloc (FUNC_TABLE_INCREMENT, sizeof (unsigned int));
   func_table_allocated = FUNC_TABLE_INCREMENT;
   func_table_in_use = 1;
 
@@ -1675,6 +1635,15 @@ vmsdbgout_global_decl (tree decl)
 /* Not implemented in VMS Debug.  */
 
 static void
+vmsdbgout_type_decl (tree decl, int local)
+{
+  if (write_symbols == VMS_AND_DWARF2_DEBUG)
+    (*dwarf2_debug_hooks.type_decl) (decl, local);
+}
+
+/* Not implemented in VMS Debug.  */
+
+static void
 vmsdbgout_abstract_function (tree decl)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
@@ -1732,3 +1701,251 @@ vmsdbgout_finish (const char *main_input
   write_modend (0);
 }
 #endif /* VMS_DEBUGGING_INFO */
+
+#if TARGET_ABI_OPEN_VMS
+/* Need for both Dwarf2 on IVMS and VMS Debug on AVMS */
+
+#ifdef VMS
+#define __NEW_STARLET 1
+#include <vms/rms.h>
+#include <vms/atrdef.h>
+#include <vms/fibdef.h>
+#include <vms/stsdef.h>
+#include <vms/iodef.h>
+#include <vms/fatdef.h>
+#include <errno.h>
+#include <vms/descrip.h>
+#include <string.h>
+#include <unixlib.h>
+
+#define MAXPATH 256
+
+/* descrip.h doesn't have everything ... */
+typedef struct fibdef* __fibdef_ptr32 __attribute__ (( mode (SI) )); 
+struct dsc$descriptor_fib
+{
+  unsigned int fib$l_len;
+  __fibdef_ptr32 fib$l_addr;
+};
+
+/* I/O Status Block.  */
+struct IOSB
+{
+  unsigned short status, count;
+  unsigned int devdep;
+};
+
+static char *tryfile;
+
+/* Variable length string.  */
+struct vstring
+{
+  short length;
+  char string[NAM$C_MAXRSS+1];
+};
+
+static char filename_buff [MAXPATH];
+static char vms_filespec [MAXPATH];
+
+/* Callback function for filespec style conversion */
+
+static int
+translate_unix (char *name, int type ATTRIBUTE_UNUSED)
+{
+  strncpy (filename_buff, name, MAXPATH);
+  filename_buff [MAXPATH - 1] = (char) 0;
+  return 0;
+}
+
+/* Wrapper for DECC function that converts a Unix filespec
+   to VMS style filespec */
+
+static char *
+to_vms_file_spec (char *filespec)
+{
+  strncpy (vms_filespec, "", MAXPATH);
+  decc$to_vms (filespec, translate_unix, 1, 1);
+  strncpy (vms_filespec, filename_buff, MAXPATH);
+
+  vms_filespec [MAXPATH - 1] = (char) 0;
+
+  return vms_filespec;
+}
+
+#else
+#define VMS_EPOCH_OFFSET 35067168000000000
+#define VMS_GRANULARITY_FACTOR 10000000
+#endif
+
+/* Return VMS file date, size, format, version given a name */
+
+int vms_file_stats_name (char *, long long *, long *, char *, int *);
+
+int
+vms_file_stats_name (filename, cdt, siz, rfo, ver)
+   char *filename;
+   long long *cdt;
+   long *siz;
+   char *rfo;
+   int *ver;
+{
+#ifdef VMS
+  struct FAB fab;
+  struct NAM nam;
+
+  unsigned long long create;
+  FAT recattr;
+  char ascnamebuff [256];
+
+  ATRDEF atrlst[]
+    = {
+      { ATR$S_CREDATE,  ATR$C_CREDATE,  &create },
+      { ATR$S_RECATTR,  ATR$C_RECATTR,  &recattr },
+      { ATR$S_ASCNAME,  ATR$C_ASCNAME,  &ascnamebuff },
+      { 0, 0, 0}
+    };
+
+  FIBDEF fib;
+  struct dsc$descriptor_fib fibdsc = {sizeof (fib), (void *) &fib};
+
+  struct IOSB iosb;
+
+  long status;
+  unsigned short chan;
+
+  struct vstring file;
+  struct dsc$descriptor_s filedsc
+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) file.string};
+  struct vstring device;
+  struct dsc$descriptor_s devicedsc
+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) device.string};
+  struct vstring result;
+  struct dsc$descriptor_s resultdsc
+    = {NAM$C_MAXRSS, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, (void *) result.string};
+
+  if (strcmp (filename, "<internal>") == 0
+      || strcmp (filename, "<built-in>") == 0)
+    {
+      if (cdt)
+	*cdt = 0;
+
+      if (siz)
+	*siz = 0;
+
+      if (rfo)
+	*rfo = 0;
+
+      if (ver)
+        *ver = 0;
+
+      return 0;
+    }
+
+  tryfile = to_vms_file_spec (filename);
+
+  /* Allocate and initialize a FAB and NAM structures.  */
+  fab = cc$rms_fab;
+  nam = cc$rms_nam;
+
+  nam.nam$l_esa = file.string;
+  nam.nam$b_ess = NAM$C_MAXRSS;
+  nam.nam$l_rsa = result.string;
+  nam.nam$b_rss = NAM$C_MAXRSS;
+  fab.fab$l_fna = tryfile;
+  fab.fab$b_fns = strlen (tryfile);
+  fab.fab$l_nam = &nam;
+
+  /* Validate filespec syntax and device existence.  */
+  status = SYS$PARSE (&fab, 0, 0);
+  if ((status & 1) != 1)
+    return 1;
+
+  file.string[nam.nam$b_esl] = 0;
+
+  /* Find matching filespec.  */
+  status = SYS$SEARCH (&fab, 0, 0);
+  if ((status & 1) != 1)
+    return 1;
+
+  file.string[nam.nam$b_esl] = 0;
+  result.string[result.length=nam.nam$b_rsl] = 0;
+
+  /* Get the device name and assign an IO channel.  */
+  strncpy (device.string, nam.nam$l_dev, nam.nam$b_dev);
+  devicedsc.dsc$w_length  = nam.nam$b_dev;
+  chan = 0;
+  status = SYS$ASSIGN (&devicedsc, &chan, 0, 0, 0);
+  if ((status & 1) != 1)
+    return 1;
+
+  /* Initialize the FIB and fill in the directory id field.  */
+  memset (&fib, 0, sizeof (fib));
+  fib.fib$w_did[0]  = nam.nam$w_did[0];
+  fib.fib$w_did[1]  = nam.nam$w_did[1];
+  fib.fib$w_did[2]  = nam.nam$w_did[2];
+  fib.fib$l_acctl = 0;
+  fib.fib$l_wcc = 0;
+  strcpy (file.string, (strrchr (result.string, ']') + 1));
+  filedsc.dsc$w_length = strlen (file.string);
+  result.string[result.length = 0] = 0;
+
+  /* Open and close the file to fill in the attributes.  */
+  status
+    = SYS$QIOW (0, chan, IO$_ACCESS|IO$M_ACCESS, &iosb, 0, 0,
+		&fibdsc, &filedsc, &result.length, &resultdsc, &atrlst, 0);
+  if ((status & 1) != 1)
+    return 1;
+  if ((iosb.status & 1) != 1)
+    return 1;
+
+  result.string[result.length] = 0;
+  status = SYS$QIOW (0, chan, IO$_DEACCESS, &iosb, 0, 0, &fibdsc, 0, 0, 0,
+		     &atrlst, 0);
+  if ((status & 1) != 1)
+    return 1;
+  if ((iosb.status & 1) != 1)
+    return 1;
+
+  /* Deassign the channel and exit.  */
+  status = SYS$DASSGN (chan);
+  if ((status & 1) != 1)
+    return 1;
+
+  if (cdt) *cdt = create;
+  if (siz) *siz = (512 * 65536 * recattr.fat$w_efblkh) +
+                  (512 * (recattr.fat$w_efblkl - 1)) +
+                  recattr.fat$w_ffbyte;
+  if (rfo) *rfo = recattr.fat$v_rtype;
+  if (ver) *ver = strtol (strrchr (ascnamebuff, ';')+1, 0, 10);
+
+  return 0;
+#else
+  struct stat buff;
+  struct tm *ts;
+  long gmtoff;
+
+  if ((stat (filename, &buff)) != 0)
+     return 1;
+
+  if (cdt)
+    {
+      ts = localtime (&buff.st_mtime);
+      gmtoff = ts->tm_gmtoff;
+      *cdt = (long long) (((buff.st_mtim.tv_sec + gmtoff) * VMS_GRANULARITY_FACTOR)
+                          + (buff.st_mtim.tv_nsec / 100))
+                         + VMS_EPOCH_OFFSET;
+    }
+
+  if (siz)
+    *siz = buff.st_size;
+
+  if (rfo)
+    *rfo = 2; /* Stream LF format */
+
+  if (ver)
+    *ver = 0;
+
+  return 0;
+#endif
+}
+#endif
--- gnattools/configure.0	2005-11-19 10:47:14.000000000 -0800
+++ gnattools/configure	2007-12-04 15:14:14.000000000 -0800
@@ -880,7 +880,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -1455,21 +1455,13 @@ test -n "$target_alias" &&
 # These demand that AC_CANONICAL_SYSTEM be called beforehand.
 
 ####
-# NCN_CHECK_TARGET_TOOL(variable, prog-to-check-for,[value-if-not-found],[path])
-# Like AC_CHECK_TOOL, but tries a prefix of the target, not the host.
-# Code is pretty much lifted from autoconf2.53.
-
-
-
-####
-# NCN_STRICT_CHECK_TOOL(variable, prog-to-check-for,[value-if-not-found],[path])
-# Like AC_CHECK_TOOL, but requires the prefix if build!=host.
-
+# NCN_STRICT_CHECK_TOOLS(variable, progs-to-check-for,[value-if-not-found],[path])
+# Like plain AC_CHECK_TOOLS, but require prefix if build!=target.
 
 
 ####
-# NCN_STRICT_CHECK_TARGET_TOOL(variable, prog-to-check-for,[value-if-not-found],[path])
-# Like NCN_CHECK_TARGET_TOOL, but requires the prefix if build!=target.
+# NCN_STRICT_CHECK_TARGET_TOOLS(variable, progs-to-check-for,[value-if-not-found],[path])
+# Like CVS Autoconf AC_CHECK_TARGET_TOOLS, but require prefix if build!=target.
 
 
 ###
@@ -1501,6 +1493,7 @@ test -n "$target_alias" &&
 
 
 
+
  case ${build_alias} in
   "") build_noncanonical=${build} ;;
   *) build_noncanonical=${build_alias} ;;
@@ -1566,41 +1559,42 @@ case "${target}" in
   | xscale*-wrs-vx* \
   | xscale*-wrs-coff \
   | mips*-wrs-vx*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-vxworks.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-vxworks.adb"
     ;;
   sparc-sun-solaris*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-solaris.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-solaris.adb"
     ;;
   *86-*-solaris2*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-solaris.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-solaris.adb"
     ;;
   *86-*-linux* \
   | powerpc*-*-linux*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-linux.adb \
+    mlib-tgt-specific.adb<mlib-tgt-linux.adb \
     indepsw.adb<indepsw-linux.adb"
     ;;
   *ia64-*-linux* \
   | alpha*-*-linux )
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-linux.adb \
+    mlib-tgt-specific.adb<mlib-tgt-linux.adb \
     indepsw.adb<indepsw-linux.adb"
     ;;
   *x86_64-*-linux* \
   | s390*-*-linux*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-linux.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
     ;;
   *86-*-freebsd*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-linux.adb"
+    mlib-tgt-specific.adb<mlib-tgt-linux.adb"
     ;;
   mips-sgi-irix*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-irix.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-irix.adb"
     ;;
   hppa*-hp-hpux10*) # Unlike hpux11
     ;;
   hppa*-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-hpux.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-hpux.adb"
     ;;
   *-ibm-aix*)
     TOOLS_TARGET_PAIRS="\
@@ -1608,12 +1602,12 @@ case "${target}" in
     indepsw.adb<indepsw-aix.adb"
     ;;
   alpha*-dec-osf*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-tru64.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-tru64.adb"
     ;;
   alpha*-dec-vms* | alpha*-dec-openvms* | alpha*-dec-vms* \
   | alpha*-hp-vms* | alpha*-hp-openvms* | alpha*-hp-vms*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-vms-alpha.adb \
+    mlib-tgt-specific.adb<mlib-tgt-vms-alpha.adb \
     symbols.adb<symbols-vms-alpha.adb"
 
     EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
@@ -1621,22 +1615,22 @@ case "${target}" in
   ia64*-dec-vms* | ia64*-dec-openvms* | ia64*-dec-vms* \
   | ia64*-hp-vms* | ia64*-hp-openvms* | ia64*-hp-vms*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-vms-ia64.adb \
+    mlib-tgt-specific.adb<mlib-tgt-vms-ia64.adb \
     symbols.adb<symbols-vms-ia64.adb"
 
     EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
     ;;
   *-*-cygwin32* | *-*-mingw32* | *-*-pe)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-mingw.adb \
+    mlib-tgt-specific.adb<mlib-tgt-mingw.adb \
     indepsw.adb<indepsw-mingw.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
   powerpc-*-darwin*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-darwin.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-darwin.adb"
     ;;
   *-*-lynxos)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-lynxos.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-lynxos.adb"
     ;;
 esac
 
@@ -2469,6 +2463,11 @@ esac
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -2507,12 +2506,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
--- gnattools/configure.ac.0	2005-11-19 10:47:14.000000000 -0800
+++ gnattools/configure.ac	2007-12-04 15:14:14.000000000 -0800
@@ -83,41 +83,42 @@ case "${target}" in
   | xscale*-wrs-vx* \
   | xscale*-wrs-coff \
   | mips*-wrs-vx*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-vxworks.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-vxworks.adb"
     ;;
   sparc-sun-solaris*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-solaris.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-solaris.adb"
     ;;
   *86-*-solaris2*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-solaris.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-solaris.adb"
     ;;
   *86-*-linux* \
   | powerpc*-*-linux*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-linux.adb \
+    mlib-tgt-specific.adb<mlib-tgt-linux.adb \
     indepsw.adb<indepsw-linux.adb"
     ;;
   *ia64-*-linux* \
   | alpha*-*-linux )
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-linux.adb \
+    mlib-tgt-specific.adb<mlib-tgt-linux.adb \
     indepsw.adb<indepsw-linux.adb"
     ;;
   *x86_64-*-linux* \
   | s390*-*-linux*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-linux.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
     ;;
   *86-*-freebsd*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-linux.adb"
+    mlib-tgt-specific.adb<mlib-tgt-linux.adb"
     ;;
   mips-sgi-irix*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-irix.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-irix.adb"
     ;;
   hppa*-hp-hpux10*) # Unlike hpux11
     ;;
   hppa*-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-hpux.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-hpux.adb"
     ;;
   *-ibm-aix*)
     TOOLS_TARGET_PAIRS="\
@@ -125,12 +126,12 @@ case "${target}" in
     indepsw.adb<indepsw-aix.adb"
     ;;
   alpha*-dec-osf*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-tru64.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-tru64.adb"
     ;;
   alpha*-dec-vms* | alpha*-dec-openvms* | alpha*-dec-vms* \
   | alpha*-hp-vms* | alpha*-hp-openvms* | alpha*-hp-vms*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-vms-alpha.adb \
+    mlib-tgt-specific.adb<mlib-tgt-vms-alpha.adb \
     symbols.adb<symbols-vms-alpha.adb"
 
     EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
@@ -138,22 +139,22 @@ case "${target}" in
   ia64*-dec-vms* | ia64*-dec-openvms* | ia64*-dec-vms* \
   | ia64*-hp-vms* | ia64*-hp-openvms* | ia64*-hp-vms*)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-vms-ia64.adb \
+    mlib-tgt-specific.adb<mlib-tgt-vms-ia64.adb \
     symbols.adb<symbols-vms-ia64.adb"
 
     EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
     ;;
   *-*-cygwin32* | *-*-mingw32* | *-*-pe)
     TOOLS_TARGET_PAIRS="\
-    mlib-tgt.adb<mlib-tgt-mingw.adb \
+    mlib-tgt-specific.adb<mlib-tgt-mingw.adb \
     indepsw.adb<indepsw-mingw.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
   powerpc-*-darwin*)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-darwin.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-darwin.adb"
     ;;
   *-*-lynxos)
-    TOOLS_TARGET_PAIRS="mlib-tgt.adb<mlib-tgt-lynxos.adb"
+    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-lynxos.adb"
     ;;
 esac
 
--- gnattools/Makefile.in.0	2005-11-19 10:47:14.000000000 -0800
+++ gnattools/Makefile.in	2007-12-04 15:14:14.000000000 -0800
@@ -123,6 +123,7 @@ TOOLS_FLAGS_TO_PASS_NATIVE= \
 	"GNATBIND=../../gnatbind" \
 	"TOOLSCASE=native"
 
+ifeq (@host_alias@,@build_alias@)
 # Variables for gnattools, cross
 TOOLS_FLAGS_TO_PASS_CROSS= \
 	"CC=$(CC)" \
@@ -139,6 +140,24 @@ TOOLS_FLAGS_TO_PASS_CROSS= \
 	"GNATBIND=gnatbind" \
 	"TOOLSCASE=cross" \
 	"LIBGNAT="
+else
+# Variables for gnattools, cross native
+TOOLS_FLAGS_TO_PASS_CROSS= \
+	"CC=$(CC)" \
+	"CFLAGS=$(CFLAGS) $(WARN_CFLAGS)" \
+	"LDFLAGS=$(LDFLAGS)" \
+	"ADAFLAGS=$(ADAFLAGS)"	\
+	"INCLUDES=$(INCLUDES_FOR_SUBDIR)" \
+	"ADA_INCLUDES=-I$(RTS_DIR)../adainclude -I$(RTS_DIR) $(ADA_INCLUDES_FOR_SUBDIR)" \
+	"exeext=$(exeext)" \
+	"fsrcdir=$(fsrcdir)" \
+	"srcdir=$(fsrcdir)" \
+	"GNATMAKE=@host_alias@-gnatmake" \
+	"GNATLINK=@host_alias@-gnatlink" \
+	"GNATBIND=@host_alias@-gnatbind" \
+	"TOOLSCASE=cross" \
+	"LIBGNAT="
+endif
 
 # File lists
 # ----------
@@ -224,7 +243,13 @@ regnattools: $(GCC_DIR)/stamp-gnatlib
 # put the host RTS dir first in the PATH to hide the default runtime
 # files that are among the sources
 # FIXME: This should be done in configure.
+
+ifeq (@host_alias@,@build_alias@)
 RTS_DIR:=$(strip $(subst \,/,$(shell gnatls -v | grep adalib )))
+else
+RTS_DIR:=$(strip $(subst \,/,$(shell @host_alias@-gnatls -v | grep adalib )))
+endif
+
 gnattools-cross: $(GCC_DIR)/stamp-tools
 	# gnattools1-re
 	$(MAKE) -C $(GCC_DIR)/ada/tools -f ../Makefile \
@@ -239,6 +264,7 @@ gnattools-cross: $(GCC_DIR)/stamp-tools
 	  $(TOOLS_FLAGS_TO_PASS_CROSS) \
 	  top_buildir=../../.. \
            ../../vxaddr2line$(exeext)
+ifeq (@host_alias@,@build_alias@)
 	# Rename cross tools to where the GCC makefile wants them when
 	# installing.  FIXME: installation should be done elsewhere.
 	if [ -f $(GCC_DIR)/gnatbind$(exeext) ] ; then \
@@ -286,6 +312,7 @@ gnattools-cross: $(GCC_DIR)/stamp-tools
 	if [ -f $(GCC_DIR)/gnatsym$(exeext) ] ; then \
 	  mv $(GCC_DIR)/gnatsym$(exeext) $(GCC_DIR)/gnatsym-cross$(exeext); \
 	fi
+endif
 
 # Other
 # -----
--- intl/configure.0	2005-11-19 10:42:33.000000000 -0800
+++ intl/configure	2007-12-04 15:14:14.000000000 -0800
@@ -251,7 +251,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -309,7 +309,7 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS SET_MAKE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA MKINSTALLDIRS USE_NLS MSGFMT GMSGFMT XGETTEXT MSGMERGE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT build build_cpu build_vendor build_os host host_cpu host_vendor host_os RANLIB ac_ct_RANLIB CPP EGREP ALLOCA GLIBC21 LIBICONV LTLIBICONV INTLBISON BUILD_INCLUDED_LIBINTL USE_INCLUDED_LIBINTL CATOBJEXT DATADIRNAME INSTOBJEXT GENCAT INTLOBJS INTL_LIBTOOL_SUFFIX_PREFIX INTLLIBS LIBINTL LTLIBINTL POSUB ACLOCAL AUTOCONF AUTOHEADER MAINT LIBINTL_DEP INCINTL LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS SET_MAKE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA MKINSTALLDIRS USE_NLS MSGFMT GMSGFMT XGETTEXT MSGMERGE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT build build_cpu build_vendor build_os host host_cpu host_vendor host_os RANLIB ac_ct_RANLIB CPP EGREP ALLOCA GLIBC21 LIBICONV LTLIBICONV INTLBISON BUILD_INCLUDED_LIBINTL USE_INCLUDED_LIBINTL CATOBJEXT DATADIRNAME INSTOBJEXT GENCAT INTLOBJS INTL_LIBTOOL_SUFFIX_PREFIX INTLLIBS LIBINTL LTLIBINTL POSUB ACLOCAL AUTOCONF AUTOHEADER MAINT LIBINTL_DEP INCINTL NO_MINUS_C_MINUS_O OUTPUT_OPTION LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -7239,6 +7239,105 @@ fi
 
 
 
+if test "x$CC" != xcc; then
+  echo "$as_me:$LINENO: checking whether $CC and cc understand -c and -o together" >&5
+echo $ECHO_N "checking whether $CC and cc understand -c and -o together... $ECHO_C" >&6
+else
+  echo "$as_me:$LINENO: checking whether cc understands -c and -o together" >&5
+echo $ECHO_N "checking whether cc understands -c and -o together... $ECHO_C" >&6
+fi
+set dummy $CC; ac_cc=`echo $2 |
+		      sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
+if eval "test \"\${ac_cv_prog_cc_${ac_cc}_c_o+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+# Make sure it works both with $CC and with simple cc.
+# We do the test twice because some compilers refuse to overwrite an
+# existing .o file with -o, though they will create one.
+ac_try='$CC -c conftest.$ac_ext -o conftest.$ac_objext >&5'
+if { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+   test -f conftest.$ac_objext && { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); };
+then
+  eval ac_cv_prog_cc_${ac_cc}_c_o=yes
+  if test "x$CC" != xcc; then
+    # Test first that cc exists at all.
+    if { ac_try='cc -c conftest.$ac_ext >&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+      ac_try='cc -c conftest.$ac_ext -o conftest.$ac_objext >&5'
+      if { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 test -f conftest.$ac_objext && { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); };
+      then
+	# cc works too.
+	:
+      else
+	# cc exists but doesn't like -o.
+	eval ac_cv_prog_cc_${ac_cc}_c_o=no
+      fi
+    fi
+  fi
+else
+  eval ac_cv_prog_cc_${ac_cc}_c_o=no
+fi
+rm -f conftest*
+
+fi
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define NO_MINUS_C_MINUS_O 1
+_ACEOF
+
+fi
+
+# autoconf is lame and doesn't give us any substitution variable for this.
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
+  NO_MINUS_C_MINUS_O=yes
+else
+  OUTPUT_OPTION='-o $@'
+fi
+
+
+
 LIBINTL_DEP=
 INCINTL=
 case $USE_INCLUDED_LIBINTL in
@@ -7335,7 +7434,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
@@ -7934,6 +8033,8 @@ s,@AUTOHEADER@,$AUTOHEADER,;t t
 s,@MAINT@,$MAINT,;t t
 s,@LIBINTL_DEP@,$LIBINTL_DEP,;t t
 s,@INCINTL@,$INCINTL,;t t
+s,@NO_MINUS_C_MINUS_O@,$NO_MINUS_C_MINUS_O,;t t
+s,@OUTPUT_OPTION@,$OUTPUT_OPTION,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
 s,@LTLIBOBJS@,$LTLIBOBJS,;t t
 CEOF
--- intl/configure.ac.0	2005-11-19 10:42:33.000000000 -0800
+++ intl/configure.ac	2007-12-04 15:14:14.000000000 -0800
@@ -36,6 +36,16 @@ AC_SUBST(MAINT)
 AC_SUBST(LIBINTL_DEP)
 AC_SUBST(INCINTL)
 
+AC_PROG_CC_C_O
+# autoconf is lame and doesn't give us any substitution variable for this.
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
+  NO_MINUS_C_MINUS_O=yes
+else
+  OUTPUT_OPTION='-o $@'
+fi
+AC_SUBST(NO_MINUS_C_MINUS_O)
+AC_SUBST(OUTPUT_OPTION)
+
 LIBINTL_DEP=
 INCINTL=
 case $USE_INCLUDED_LIBINTL in
--- intl/dcigettext.c.0	2005-11-19 10:42:33.000000000 -0800
+++ intl/dcigettext.c	2007-12-04 15:14:14.000000000 -0800
@@ -27,6 +27,11 @@
 # include <config.h>
 #endif
 
+#ifdef VMS
+/* Non-posix getcwd prototype is incompatible with char *getcwd() below */
+#define __POSIX_C_SOURCE
+#endif
+
 #include <sys/types.h>
 
 #ifdef __GNUC__
--- intl/Makefile.in.0	2005-11-19 10:42:33.000000000 -0800
+++ intl/Makefile.in	2007-12-04 15:14:14.000000000 -0800
@@ -35,6 +35,8 @@ datadir = @datadir@
 localedir = $(datadir)/locale
 aliaspath = $(localedir)
 
+OUTPUT_OPTION = @OUTPUT_OPTION@
+
 AR = ar
 ACLOCAL = @ACLOCAL@
 AUTOCONF = @AUTOCONF@
@@ -129,7 +131,7 @@ libintl.h: $(srcdir)/libgnuintl.h
 .SUFFIXES: .c .y .o
 
 .c.o:
-	$(COMPILE) $<
+	$(COMPILE) $< $(OUTPUT_OPTION)
 
 .y.c:
 	$(YACC) $(YFLAGS) --output $@ $<
--- libcpp/configure.0	2007-12-04 15:25:15.000000000 -0800
+++ libcpp/configure	2007-12-04 15:14:14.000000000 -0800
@@ -253,7 +253,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -2869,11 +2869,11 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -2937,7 +2937,7 @@ else
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_CC_dependencies_compiler_type=none
 fi
@@ -3972,11 +3972,11 @@ _ACEOF
 
 else
   case $LIBOBJS in
-    "obstack.$ac_objext"   | \
-  *" obstack.$ac_objext"   | \
-    "obstack.$ac_objext "* | \
-  *" obstack.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS obstack.$ac_objext" ;;
+    "obstack.o"   | \
+  *" obstack.o"   | \
+    "obstack.o "* | \
+  *" obstack.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS obstack.o" ;;
 esac
 
 fi
@@ -8340,7 +8340,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
--- libcpp/include/cpplib.h.0	2005-11-19 10:47:07.000000000 -0800
+++ libcpp/include/cpplib.h	2007-12-04 15:14:14.000000000 -0800
@@ -477,6 +477,12 @@ struct cpp_callbacks
        ATTRIBUTE_FPTR_PRINTF(3,0);
 };
 
+#ifdef VMS
+#define INO_CPP ino[3]
+#else
+#define INO_CPP ino
+#endif
+
 /* Chain of directories to look for include files in.  */
 struct cpp_dir
 {
@@ -503,7 +509,7 @@ struct cpp_dir
 
   /* The C front end uses these to recognize duplicated
      directories in the search path.  */
-  ino_t ino;
+  ino_t INO_CPP;
   dev_t dev;
 
   /* Is this a user-supplied directory? */
--- libffi/aclocal.m4.0	2005-11-19 10:43:15.000000000 -0800
+++ libffi/aclocal.m4	2007-12-04 15:14:14.000000000 -0800
@@ -240,11 +240,11 @@ AC_CACHE_CHECK([dependency style of $dep
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -313,7 +313,7 @@ AC_CACHE_CHECK([dependency style of $dep
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_$1_dependencies_compiler_type=none
 fi
@@ -1181,17 +1181,17 @@ do
   test -n "${am_cv_prog_tar_$1}" && break
 
   # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
-  rm -rf conftest.dir
+  rm -rf conftest_dir
+  mkdir conftest_dir
+  echo GrepMe > conftest_dir/file
+  AM_RUN_LOG([tardir=conftest_dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest_dir
   if test -s conftest.tar; then
     AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+    grep GrepMe conftest_dir/file >/dev/null 2>&1 && break
   fi
 done
-rm -rf conftest.dir
+rm -rf conftest_dir
 
 AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
 AC_MSG_RESULT([$am_cv_prog_tar_$1])])
--- libffi/configure.0	2007-04-20 18:35:53.000000000 -0700
+++ libffi/configure	2007-12-04 15:14:14.000000000 -0800
@@ -253,7 +253,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -2904,11 +2904,11 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -2977,7 +2977,7 @@ else
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_CC_dependencies_compiler_type=none
 fi
@@ -7731,7 +7731,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
--- libiberty/configure.0	2005-11-19 10:43:06.000000000 -0800
+++ libiberty/configure	2007-12-04 15:14:14.000000000 -0800
@@ -251,7 +251,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -957,7 +957,7 @@ esac
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -1212,6 +1212,7 @@ echo "$as_me: loading site script $ac_si
   fi
 done
 
+
 if test -r "$cache_file"; then
   # Some versions of bash will fail to source /dev/null (special
   # files actually), so we avoid doing that.
@@ -1401,7 +1402,8 @@ else
   MAINT='#'
   NOTMAINT=''
 fi
-
+ 
+echo 1-----------------------ac_executable_extensions=$ac_executable_extensions
 # Do we have a single-tree copy of texinfo?  Even if we do, we can't
 # rely on it - libiberty is built before texinfo.
 # Extract the first word of "makeinfo", so it can be a program name with args.
@@ -1567,6 +1569,7 @@ host_os=`echo $ac_cv_host | sed 's/^\([^
 
 
 
+echo 2-----------------------ac_executable_extensions=$ac_executable_extensions
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ar; ac_word=$2
@@ -2330,7 +2333,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2388,7 +2392,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2504,7 +2509,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2558,7 +2564,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2603,7 +2610,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2647,7 +2655,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3103,7 +3112,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3163,7 +3173,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3239,7 +3250,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3281,7 +3293,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3338,7 +3351,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3710,7 +3724,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3774,7 +3789,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3835,7 +3851,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3916,7 +3933,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4145,7 +4163,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4207,7 +4226,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4247,7 +4267,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4303,7 +4324,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4343,7 +4365,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4407,7 +4430,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4438,8 +4462,10 @@ See \`config.log' for more details." >&2
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -4552,7 +4578,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4618,7 +4645,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4664,7 +4692,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4710,7 +4739,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4787,7 +4817,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5029,7 +5060,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5093,7 +5125,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5162,7 +5195,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5231,7 +5265,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5300,7 +5335,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5369,7 +5405,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5438,7 +5475,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5513,51 +5551,51 @@ if test -n "${with_target_subdir}"; then
 
   if test "x${with_newlib}" = "xyes"; then
     case $LIBOBJS in
-    "asprintf.$ac_objext"   | \
-  *" asprintf.$ac_objext"   | \
-    "asprintf.$ac_objext "* | \
-  *" asprintf.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS asprintf.$ac_objext" ;;
+    "asprintf.o"   | \
+  *" asprintf.o"   | \
+    "asprintf.o "* | \
+  *" asprintf.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS asprintf.o" ;;
 esac
 
     case $LIBOBJS in
-    "basename.$ac_objext"   | \
-  *" basename.$ac_objext"   | \
-    "basename.$ac_objext "* | \
-  *" basename.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS basename.$ac_objext" ;;
+    "basename.o"   | \
+  *" basename.o"   | \
+    "basename.o "* | \
+  *" basename.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS basename.o" ;;
 esac
 
     case $LIBOBJS in
-    "insque.$ac_objext"   | \
-  *" insque.$ac_objext"   | \
-    "insque.$ac_objext "* | \
-  *" insque.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS insque.$ac_objext" ;;
+    "insque.o"   | \
+  *" insque.o"   | \
+    "insque.o "* | \
+  *" insque.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS insque.o" ;;
 esac
 
     case $LIBOBJS in
-    "random.$ac_objext"   | \
-  *" random.$ac_objext"   | \
-    "random.$ac_objext "* | \
-  *" random.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS random.$ac_objext" ;;
+    "random.o"   | \
+  *" random.o"   | \
+    "random.o "* | \
+  *" random.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS random.o" ;;
 esac
 
     case $LIBOBJS in
-    "strdup.$ac_objext"   | \
-  *" strdup.$ac_objext"   | \
-    "strdup.$ac_objext "* | \
-  *" strdup.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strdup.$ac_objext" ;;
+    "strdup.o"   | \
+  *" strdup.o"   | \
+    "strdup.o "* | \
+  *" strdup.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS strdup.o" ;;
 esac
 
     case $LIBOBJS in
-    "vasprintf.$ac_objext"   | \
-  *" vasprintf.$ac_objext"   | \
-    "vasprintf.$ac_objext "* | \
-  *" vasprintf.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS vasprintf.$ac_objext" ;;
+    "vasprintf.o"   | \
+  *" vasprintf.o"   | \
+    "vasprintf.o "* | \
+  *" vasprintf.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS vasprintf.o" ;;
 esac
 
 
@@ -5642,83 +5680,83 @@ if test -z "${setobjs}"; then
     # libraries are actually on the target board, not in the file
     # system.
     case $LIBOBJS in
-    "basename.$ac_objext"   | \
-  *" basename.$ac_objext"   | \
-    "basename.$ac_objext "* | \
-  *" basename.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS basename.$ac_objext" ;;
+    "basename.o"   | \
+  *" basename.o"   | \
+    "basename.o "* | \
+  *" basename.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS basename.o" ;;
 esac
 
     case $LIBOBJS in
-    "getpagesize.$ac_objext"   | \
-  *" getpagesize.$ac_objext"   | \
-    "getpagesize.$ac_objext "* | \
-  *" getpagesize.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS getpagesize.$ac_objext" ;;
+    "getpagesize.o"   | \
+  *" getpagesize.o"   | \
+    "getpagesize.o "* | \
+  *" getpagesize.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS getpagesize.o" ;;
 esac
 
     case $LIBOBJS in
-    "insque.$ac_objext"   | \
-  *" insque.$ac_objext"   | \
-    "insque.$ac_objext "* | \
-  *" insque.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS insque.$ac_objext" ;;
+    "insque.o"   | \
+  *" insque.o"   | \
+    "insque.o "* | \
+  *" insque.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS insque.o" ;;
 esac
 
     case $LIBOBJS in
-    "random.$ac_objext"   | \
-  *" random.$ac_objext"   | \
-    "random.$ac_objext "* | \
-  *" random.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS random.$ac_objext" ;;
+    "random.o"   | \
+  *" random.o"   | \
+    "random.o "* | \
+  *" random.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS random.o" ;;
 esac
 
     case $LIBOBJS in
-    "strcasecmp.$ac_objext"   | \
-  *" strcasecmp.$ac_objext"   | \
-    "strcasecmp.$ac_objext "* | \
-  *" strcasecmp.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strcasecmp.$ac_objext" ;;
+    "strcasecmp.o"   | \
+  *" strcasecmp.o"   | \
+    "strcasecmp.o "* | \
+  *" strcasecmp.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS strcasecmp.o" ;;
 esac
 
     case $LIBOBJS in
-    "strncasecmp.$ac_objext"   | \
-  *" strncasecmp.$ac_objext"   | \
-    "strncasecmp.$ac_objext "* | \
-  *" strncasecmp.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strncasecmp.$ac_objext" ;;
+    "strncasecmp.o"   | \
+  *" strncasecmp.o"   | \
+    "strncasecmp.o "* | \
+  *" strncasecmp.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS strncasecmp.o" ;;
 esac
 
     case $LIBOBJS in
-    "strdup.$ac_objext"   | \
-  *" strdup.$ac_objext"   | \
-    "strdup.$ac_objext "* | \
-  *" strdup.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strdup.$ac_objext" ;;
+    "strdup.o"   | \
+  *" strdup.o"   | \
+    "strdup.o "* | \
+  *" strdup.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS strdup.o" ;;
 esac
 
     case $LIBOBJS in
-    "vfork.$ac_objext"   | \
-  *" vfork.$ac_objext"   | \
-    "vfork.$ac_objext "* | \
-  *" vfork.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS vfork.$ac_objext" ;;
+    "vfork.o"   | \
+  *" vfork.o"   | \
+    "vfork.o "* | \
+  *" vfork.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS vfork.o" ;;
 esac
 
     case $LIBOBJS in
-    "waitpid.$ac_objext"   | \
-  *" waitpid.$ac_objext"   | \
-    "waitpid.$ac_objext "* | \
-  *" waitpid.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS waitpid.$ac_objext" ;;
+    "waitpid.o"   | \
+  *" waitpid.o"   | \
+    "waitpid.o "* | \
+  *" waitpid.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS waitpid.o" ;;
 esac
 
     case $LIBOBJS in
-    "vasprintf.$ac_objext"   | \
-  *" vasprintf.$ac_objext"   | \
-    "vasprintf.$ac_objext "* | \
-  *" vasprintf.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS vasprintf.$ac_objext" ;;
+    "vasprintf.o"   | \
+  *" vasprintf.o"   | \
+    "vasprintf.o "* | \
+  *" vasprintf.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS vasprintf.o" ;;
 esac
 
     for f in $funcs; do
@@ -5774,11 +5812,11 @@ if test -z "${setobjs}"; then
     then
       funcs="`echo $funcs | sed -e 's/random//'`"
       case $LIBOBJS in
-    "random.$ac_objext"   | \
-  *" random.$ac_objext"   | \
-    "random.$ac_objext "* | \
-  *" random.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS random.$ac_objext" ;;
+    "random.o"   | \
+  *" random.o"   | \
+    "random.o "* | \
+  *" random.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS random.o" ;;
 esac
 
       vars="`echo $vars | sed -e 's/sys_siglist//'`"
@@ -5864,7 +5902,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5923,7 +5962,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6023,7 +6063,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6054,11 +6095,11 @@ _ACEOF
 
 else
   case $LIBOBJS in
-    "$ac_func.$ac_objext"   | \
-  *" $ac_func.$ac_objext"   | \
-    "$ac_func.$ac_objext "* | \
-  *" $ac_func.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS $ac_func.$ac_objext" ;;
+    "$ac_func.o"   | \
+  *" $ac_func.o"   | \
+    "$ac_func.o "* | \
+  *" $ac_func.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS $ac_func.o" ;;
 esac
 
 fi
@@ -6161,7 +6202,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6382,7 +6424,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6647,11 +6690,11 @@ fi
 
   if test $ac_cv_func_vfork_works = no; then
     case $LIBOBJS in
-    "vfork.$ac_objext"   | \
-  *" vfork.$ac_objext"   | \
-    "vfork.$ac_objext "* | \
-  *" vfork.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS vfork.$ac_objext" ;;
+    "vfork.o"   | \
+  *" vfork.o"   | \
+    "vfork.o "* | \
+  *" vfork.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS vfork.o" ;;
 esac
 
   fi
@@ -6727,7 +6770,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6758,11 +6802,11 @@ _ACEOF
 
 else
   case $LIBOBJS in
-    "$ac_func.$ac_objext"   | \
-  *" $ac_func.$ac_objext"   | \
-    "$ac_func.$ac_objext "* | \
-  *" $ac_func.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS $ac_func.$ac_objext" ;;
+    "$ac_func.o"   | \
+  *" $ac_func.o"   | \
+    "$ac_func.o "* | \
+  *" $ac_func.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS $ac_func.o" ;;
 esac
 
 fi
@@ -6838,7 +6882,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6907,7 +6952,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6972,7 +7018,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7068,7 +7115,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7132,7 +7180,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7201,7 +7250,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7270,7 +7320,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7339,7 +7390,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7408,7 +7460,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7477,7 +7530,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7548,7 +7602,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7617,7 +7672,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7686,7 +7742,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7755,7 +7812,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7824,7 +7882,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7893,7 +7952,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7964,7 +8024,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8047,7 +8108,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_c
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8219,7 +8281,8 @@ if { (eval echo "$as_me:$LINENO: \"$ac_l
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8532,11 +8595,11 @@ echo "$as_me:$LINENO: result: $ac_cv_fun
 echo "${ECHO_T}$ac_cv_func_strncmp_works" >&6
 if test $ac_cv_func_strncmp_works = no ; then
   case $LIBOBJS in
-    "strncmp.$ac_objext"   | \
-  *" strncmp.$ac_objext"   | \
-    "strncmp.$ac_objext "* | \
-  *" strncmp.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strncmp.$ac_objext" ;;
+    "strncmp.o"   | \
+  *" strncmp.o"   | \
+    "strncmp.o "* | \
+  *" strncmp.o "* ) ;;
+  *) LIBOBJS="$LIBOBJS strncmp.o" ;;
 esac
 
 fi
@@ -8649,7 +8712,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
@@ -9407,6 +9470,11 @@ esac
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -9445,12 +9513,6 @@ echo "$as_me: error: cannot find input f
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
--- libiberty/getopt.c.0	2005-11-19 10:43:06.000000000 -0800
+++ libiberty/getopt.c	2007-12-04 15:14:14.000000000 -0800
@@ -78,6 +78,7 @@
 # if HAVE_STRING_H - 0
 #  include <string.h>
 # endif
+# define getopt getopt_libiberty /* Temporary hack to link gcov */
 #endif
 
 #ifndef _
--- libiberty/make-temp-file.c.0	2005-11-19 10:43:06.000000000 -0800
+++ libiberty/make-temp-file.c	2007-12-04 15:14:14.000000000 -0800
@@ -103,9 +103,16 @@ choose_tmpdir (void)
   if (memoized_tmpdir)
     return memoized_tmpdir;
 
+#ifdef VMS
+  /* Use non-polluting names */
+  base = try_dir (getenv ("GNUTMPDIR"), base);
+  base = try_dir (getenv ("GNUTMP"), base);
+  base = try_dir (getenv ("GNUTEMP"), base);
+#else
   base = try_dir (getenv ("TMPDIR"), base);
   base = try_dir (getenv ("TMP"), base);
   base = try_dir (getenv ("TEMP"), base);
+#endif
 
 #ifdef P_tmpdir
   base = try_dir (P_tmpdir, base);
--- libiberty/mkstemps.c.0	2005-11-19 10:43:06.000000000 -0800
+++ libiberty/mkstemps.c	2007-12-04 15:14:14.000000000 -0800
@@ -73,8 +73,8 @@ reading and writing.
 int
 mkstemps (char *pattern, int suffix_len)
 {
-  static const char letters[]
-    = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+  char *letters;
+  int nletters = 0;
   static gcc_uint64_t value;
 #ifdef HAVE_GETTIMEOFDAY
   struct timeval tv;
@@ -83,6 +83,21 @@ mkstemps (char *pattern, int suffix_len)
   size_t len;
   int count;
 
+  if (nletters == 0)
+    {
+      char *gletters = getenv ("GNU_MKSTEMPS_LETTERS");
+      if (gletters)
+        letters = strdup (gletters);
+      else
+        letters = strdup
+#ifdef VMS
+          ("abcdefghijklmnopqrstuvwxyz0123456789");
+#else
+          ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
+#endif
+      nletters = (sizeof letters) - 1;
+    }
+
   len = strlen (pattern);
 
   if ((int) len < 6 + suffix_len
@@ -107,17 +122,17 @@ mkstemps (char *pattern, int suffix_len)
       int fd;
 
       /* Fill in the random bits.  */
-      XXXXXX[0] = letters[v % 62];
-      v /= 62;
-      XXXXXX[1] = letters[v % 62];
-      v /= 62;
-      XXXXXX[2] = letters[v % 62];
-      v /= 62;
-      XXXXXX[3] = letters[v % 62];
-      v /= 62;
-      XXXXXX[4] = letters[v % 62];
-      v /= 62;
-      XXXXXX[5] = letters[v % 62];
+      XXXXXX[0] = letters[v % nletters];
+      v /= nletters;
+      XXXXXX[1] = letters[v % nletters];
+      v /= nletters;
+      XXXXXX[2] = letters[v % nletters];
+      v /= nletters;
+      XXXXXX[3] = letters[v % nletters];
+      v /= nletters;
+      XXXXXX[4] = letters[v % nletters];
+      v /= nletters;
+      XXXXXX[5] = letters[v % nletters];
 
       fd = open (pattern, O_RDWR|O_CREAT|O_EXCL, 0600);
       if (fd >= 0)
--- libiberty/pex-unix.c.0	2006-08-27 18:09:16.000000000 -0700
+++ libiberty/pex-unix.c	2007-12-04 15:14:14.000000000 -0800
@@ -65,11 +65,40 @@ extern int errno;
 #ifdef HAVE_VFORK_H
 #include <vfork.h>
 #endif
-#ifdef VMS
-#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
-               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
-#endif /* VMS */
+#if defined(VMS) && defined (__LONG_POINTERS)
+#ifndef __CHAR_PTR32
+typedef char * __char_ptr32
+__attribute__ ((mode (SI)));
+#endif
+
+typedef __char_ptr32 *__char_ptr_char_ptr32
+__attribute__ ((mode (SI)));
+
+/* Return a 32 bit pointer to an array of 32 bit pointers 
+   given a 64 bit pointer to an array of 64 bit pointers */
+
+static __char_ptr_char_ptr32
+to_ptr32 (char **ptr64)
+{
+  int argc;
+  __char_ptr_char_ptr32 short_argv;
+
+  for (argc=0; ptr64[argc]; argc++);
 
+  /* Reallocate argv with 32 bit pointers. */
+  short_argv = (__char_ptr_char_ptr32) decc$malloc
+    (sizeof (__char_ptr32) * (argc + 1));
+
+  for (argc=0; ptr64[argc]; argc++)
+    short_argv[argc] = (__char_ptr32) decc$strdup (ptr64[argc]);
+
+  short_argv[argc] = (__char_ptr32) 0;
+  return short_argv;
+
+}
+#else
+#define to_ptr32(argv) argv
+#endif
 
 /* File mode to use for private and world-readable files.  */
 
@@ -414,12 +443,12 @@ pex_unix_exec_child (struct pex_obj *obj
 	}
       if ((flags & PEX_SEARCH) != 0)
 	{
-	  execvp (executable, argv);
+	  execvp (executable, to_ptr32 (argv));
 	  pex_child_error (obj, executable, "execvp", errno);
 	}
       else
 	{
-	  execv (executable, argv);
+	  execv (executable, to_ptr32 (argv));
 	  pex_child_error (obj, executable, "execv", errno);
 	}
 
--- libmudflap/aclocal.m4.0	2005-11-19 10:42:51.000000000 -0800
+++ libmudflap/aclocal.m4	2007-12-04 15:14:14.000000000 -0800
@@ -163,11 +163,11 @@ AC_CACHE_CHECK([dependency style of $dep
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -236,7 +236,7 @@ AC_CACHE_CHECK([dependency style of $dep
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_$1_dependencies_compiler_type=none
 fi
@@ -896,17 +896,17 @@ do
   test -n "${am_cv_prog_tar_$1}" && break
 
   # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
-  rm -rf conftest.dir
+  rm -rf conftest_dir
+  mkdir conftest_dir
+  echo GrepMe > conftest_dir/file
+  AM_RUN_LOG([tardir=conftest_dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest_dir
   if test -s conftest.tar; then
     AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+    grep GrepMe conftest_dir/file >/dev/null 2>&1 && break
   fi
 done
-rm -rf conftest.dir
+rm -rf conftest_dir
 
 AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
 AC_MSG_RESULT([$am_cv_prog_tar_$1])])
--- libmudflap/configure.0	2005-11-19 10:42:51.000000000 -0800
+++ libmudflap/configure	2007-12-04 15:14:14.000000000 -0800
@@ -251,7 +251,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -2942,11 +2942,11 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -3015,7 +3015,7 @@ else
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_CC_dependencies_compiler_type=none
 fi
@@ -7202,7 +7202,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
--- libssp/aclocal.m4.0	2006-09-29 18:08:01.000000000 -0700
+++ libssp/aclocal.m4	2007-12-04 15:14:14.000000000 -0800
@@ -163,11 +163,11 @@ AC_CACHE_CHECK([dependency style of $dep
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -236,7 +236,7 @@ AC_CACHE_CHECK([dependency style of $dep
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_$1_dependencies_compiler_type=none
 fi
@@ -896,17 +896,17 @@ do
   test -n "${am_cv_prog_tar_$1}" && break
 
   # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
-  rm -rf conftest.dir
+  rm -rf conftest_dir
+  mkdir conftest_dir
+  echo GrepMe > conftest_dir/file
+  AM_RUN_LOG([tardir=conftest_dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest_dir
   if test -s conftest.tar; then
     AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+    grep GrepMe conftest_dir/file >/dev/null 2>&1 && break
   fi
 done
-rm -rf conftest.dir
+rm -rf conftest_dir
 
 AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
 AC_MSG_RESULT([$am_cv_prog_tar_$1])])
--- libssp/configure.0	2006-09-29 18:08:01.000000000 -0700
+++ libssp/configure	2007-12-04 15:14:14.000000000 -0800
@@ -251,7 +251,7 @@ exec 6>&1
 #
 # Initializations.
 #
-ac_default_prefix=/usr/local
+ac_default_prefix=/gnu
 ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
@@ -2992,11 +2992,11 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  mkdir conftest.dir
+  mkdir conftest_dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
+  cp "$am_depcomp" conftest_dir
+  cd conftest_dir
   # We will build objects and dependencies in a subdirectory because
   # it helps to detect inapplicable dependency modes.  For instance
   # both Tru64's cc and ICC support -MD to output dependencies as a
@@ -3065,7 +3065,7 @@ else
   done
 
   cd ..
-  rm -rf conftest.dir
+  rm -rf conftest_dir
 else
   am_cv_CC_dependencies_compiler_type=none
 fi
@@ -5344,7 +5344,7 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`echo "$ac_i" |
 	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_libobjs="$ac_libobjs $ac_i\$U.o"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
--- ltconfig.0	2007-02-16 18:28:21.000000000 -0800
+++ ltconfig	2007-12-04 15:14:14.000000000 -0800
@@ -662,6 +662,10 @@ else
   # MS-DOS does not allow filenames that begin with a dot.
   objdir=_libs
 fi
+
+# DBR VMS HACK
+objdir=_libs
+
 rmdir .libs 2>/dev/null
 echo "$ac_t$objdir" 1>&6
 
--- Makefile.in.0	2007-12-04 15:25:15.000000000 -0800
+++ Makefile.in	2007-12-04 15:14:14.000000000 -0800
@@ -2216,7 +2216,7 @@ configure-build-libiberty: 
 	srcdiroption="--srcdir=$${topdir}/libiberty"; \
 	libsrcdir="$$s/libiberty"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-libiberty
@@ -2264,7 +2264,7 @@ configure-build-bison: 
 	srcdiroption="--srcdir=$${topdir}/bison"; \
 	libsrcdir="$$s/bison"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-bison
@@ -2312,7 +2312,7 @@ configure-build-byacc: 
 	srcdiroption="--srcdir=$${topdir}/byacc"; \
 	libsrcdir="$$s/byacc"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-byacc
@@ -2360,7 +2360,7 @@ configure-build-flex: 
 	srcdiroption="--srcdir=$${topdir}/flex"; \
 	libsrcdir="$$s/flex"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-flex
@@ -2408,7 +2408,7 @@ configure-build-m4: 
 	srcdiroption="--srcdir=$${topdir}/m4"; \
 	libsrcdir="$$s/m4"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-m4
@@ -2456,7 +2456,7 @@ configure-build-texinfo: 
 	srcdiroption="--srcdir=$${topdir}/texinfo"; \
 	libsrcdir="$$s/texinfo"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-texinfo
@@ -2504,7 +2504,7 @@ configure-build-fixincludes: 
 	srcdiroption="--srcdir=$${topdir}/fixincludes"; \
 	libsrcdir="$$s/fixincludes"; \
 	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+	$(SHELL) $${libsrcdir}/configure \
 	  $(BUILD_CONFIGARGS) $${srcdiroption}  \
 	  || exit 1
 @endif build-fixincludes
*** gcc/config/alpha/vms.h.ori	Wed Dec 12 16:43:37 2007
--- gcc/config/alpha/vms.h	Wed Dec 12 16:44:22 2007
*************** extern void sdata_section (void);
*** 326,331 ****
--- 326,334 ----
  #define DWARF2_DEBUGGING_INFO 1
  #define VMS_DEBUGGING_INFO 1
  
+ #undef  DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET
+ #define DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET 1
+ 
  #define DWARF2_UNWIND_INFO 1
  
  #undef EH_RETURN_HANDLER_RTX






*** gcc/varasm.c.old	Tue Nov  6 17:12:40 2007
--- gcc/varasm.c	Fri Dec 14 10:43:29 2007
***************
*** 5022,5028 ****
        target_decl = find_decl_and_mark_needed (p->decl, p->target);
        if (target_decl == NULL)
  	{
! 	  if (! lookup_attribute ("weakref", DECL_ATTRIBUTES (p->decl)))
  	    error ("%q+D aliased to undefined symbol %qs",
  		   p->decl, IDENTIFIER_POINTER (p->target));
  	}
--- 5022,5035 ----
        target_decl = find_decl_and_mark_needed (p->decl, p->target);
        if (target_decl == NULL)
  	{
! 	  const char *id = IDENTIFIER_POINTER (p->target);
! 	  if (*id >= '0' && *id <= '9')
! 	    {
! 	      /* Extension: an alias whose target is an address creates an
! 		 absolute symbol.  */
! 	      ;
! 	    }
! 	  else if (! lookup_attribute ("weakref", DECL_ATTRIBUTES (p->decl)))
  	    error ("%q+D aliased to undefined symbol %qs",
  		   p->decl, IDENTIFIER_POINTER (p->target));
  	}
*** gcc/config/alpha/vms-ehfb.h.old	Fri Dec 14 03:58:50 2007
--- gcc/config/alpha/vms-ehfb.h	Fri Dec 14 17:40:55 2007
***************
*** 26,31 ****
--- 26,33 ----
  #include <vms/chfctxdef.h>
  #include <vms/chfdef.h>
  
+ #define MD_FALLBACK_FRAME_STATE_FOR alpha_vms_fallback_frame_state
+ 
  typedef void * ADDR;
  typedef unsigned long long REG;
  typedef PDSCDEF * PV;
***************
*** 55,62 ****
  #define RA_COLUMN (DWARF_ALT_FRAME_RETURN_COLUMN)
  
  static int
! md_fallback_frame_state_for
! (struct _Unwind_Context *CONTEXT, _Unwind_FrameState *FS)
  {
    static int eh_debug = -1;
  
--- 57,64 ----
  #define RA_COLUMN (DWARF_ALT_FRAME_RETURN_COLUMN)
  
  static int
! alpha_vms_fallback_frame_state (struct _Unwind_Context *CONTEXT,
! 				_Unwind_FrameState *FS)
  {
    static int eh_debug = -1;
  
*** gcc/config/alpha/vms.h.old	Fri Dec 14 03:58:53 2007
--- gcc/config/alpha/vms.h	Fri Dec 14 17:39:48 2007
***************
*** 344,350 ****
     file. This avoids having to recompile the world instead of libgcc only
     when changes to this macro are exercised.  */
  
! #define MD_FALLBACK_FRAME_STATE_FOR_SOURCE "config/alpha/vms-ehfb.h"
  
  #endif
  
--- 341,347 ----
     file. This avoids having to recompile the world instead of libgcc only
     when changes to this macro are exercised.  */
  
! #define MD_UNWIND_SUPPORT "config/alpha/vms-ehfb.h"
  
  #endif
  
*** gcc/config/ia64/vms.h.old	2007-12-17 14:52:51.852178266 +0100
--- gcc/config/ia64/vms.h	2007-12-17 15:16:30.361324816 +0100
***************
*** 251,257 ****
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
  
! #define MD_FALLBACK_FRAME_STATE_FOR_SOURCE "config/ia64/vms-ehfb.h"
  
  #define UNW_IVMS_MODE(HEADER) (((HEADER) >> 44) & 0x3L)
  #define MD_UNW_COMPATIBLE_PERSONALITY_P(HEADER) (!UNW_IVMS_MODE (HEADER))
--- 251,257 ----
  /* Define this to be nonzero if static stack checking is supported.  */
  #define STACK_CHECK_STATIC_BUILTIN 1
  
! #define MD_UNWIND_SUPPORT "config/ia64/vms-ehfb.h"
  
  #define UNW_IVMS_MODE(HEADER) (((HEADER) >> 44) & 0x3L)
  #define MD_UNW_COMPATIBLE_PERSONALITY_P(HEADER) (!UNW_IVMS_MODE (HEADER))
*** gcc/config/alpha/vms-ehfb.h.old	2007-12-17 14:52:52.000000000 +0100
--- gcc/config/alpha/vms-ehfb.h	2007-12-18 17:03:19.040329085 +0100
***************
*** 51,57 ****
  (FS)->regs.reg[GRN].loc.offset = (_Unwind_Sword) ((REG) (LOC) - (REG) (CFA)); \
  } while (0);
  
! #define GIVEUP_ON_FAILURE(STATUS) { if ((((STATUS) & 1) != 1)) return 0; }
  #define DENOTES_EXC_DISPATCHER(PV) ((PV) == (ADDR) (REG) SYS$GL_CALL_HANDL)
  
  #define RA_COLUMN (DWARF_ALT_FRAME_RETURN_COLUMN)
--- 51,58 ----
  (FS)->regs.reg[GRN].loc.offset = (_Unwind_Sword) ((REG) (LOC) - (REG) (CFA)); \
  } while (0);
  
! #define GIVEUP_ON_FAILURE(STATUS) \
!   { if ((((STATUS) & 1) != 1)) return _URC_END_OF_STACK; }
  #define DENOTES_EXC_DISPATCHER(PV) ((PV) == (ADDR) (REG) SYS$GL_CALL_HANDL)
  
  #define RA_COLUMN (DWARF_ALT_FRAME_RETURN_COLUMN)
***************
*** 101,107 ****
    /* We only know how to deal with stack or reg frame procedures, so give
       up if we're handed anything else.  */
    if (pkind != PDSC$K_KIND_FP_STACK && pkind != PDSC$K_KIND_FP_REGISTER)
!     return 0;
    
    if (eh_debug)
      printf ("FALLBACK: CTX FP = 0x%p, PV = 0x%p, EN = 0x%x, RA = 0x%p\n",
--- 102,108 ----
    /* We only know how to deal with stack or reg frame procedures, so give
       up if we're handed anything else.  */
    if (pkind != PDSC$K_KIND_FP_STACK && pkind != PDSC$K_KIND_FP_REGISTER)
!     return _URC_END_OF_STACK;
    
    if (eh_debug)
      printf ("FALLBACK: CTX FP = 0x%p, PV = 0x%p, EN = 0x%x, RA = 0x%p\n",
***************
*** 219,225 ****
  
      default:
        /* Should never reach here.  */
!       return 0;
      }
  
    /* If PV designates an exception dispatcher, we have to adjust the return
--- 220,226 ----
  
      default:
        /* Should never reach here.  */
!       return _URC_END_OF_STACK;
      }
  
    /* If PV designates an exception dispatcher, we have to adjust the return
***************
*** 279,285 ****
        /* ??? floating point registers ?  */
      }
  
!   return 1;
  }
  
  
--- 280,286 ----
        /* ??? floating point registers ?  */
      }
  
!   return _URC_NO_REASON;
  }
  
  
*** gcc/config/ia64/vms-ehfb.h.old	2007-12-17 14:52:51.000000000 +0100
--- gcc/config/ia64/vms-ehfb.h	2007-12-18 17:12:22.073435465 +0100
***************
*** 29,40 ****
  #include <stdio.h>
  #include <string.h>
  
- #define UNW_SUCCESS 1
- #define UNW_FAILURE 0
- 
  #define DYN$C_SSENTRY 66
  /* ??? would rather get the proper header file.  */
  
  extern INVO_CONTEXT_BLK * LIB$I64_CREATE_INVO_CONTEXT (void);
  
  extern int LIB$I64_IS_EXC_DISPATCH_FRAME (void *);
--- 29,39 ----
  #include <stdio.h>
  #include <string.h>
  
  #define DYN$C_SSENTRY 66
  /* ??? would rather get the proper header file.  */
  
+ #define MD_FALLBACK_FRAME_STATE_FOR ia64_vms_fallback_frame_state
+ 
  extern INVO_CONTEXT_BLK * LIB$I64_CREATE_INVO_CONTEXT (void);
  
  extern int LIB$I64_IS_EXC_DISPATCH_FRAME (void *);
***************
*** 57,69 ****
  #define DENOTES_BOTTOM_OF_STACK(icb) ((icb)->libicb$v_bottom_of_stack)
  
  #define FAIL_IF(COND) \
! do { if (COND) { context->rp = 0; return UNW_FAILURE; } } while (0);
  /* Clearing context->rp is required to prevent the ia64 gcc unwinder from
     attempting to keep on walking the call chain.  */
  
  static int
! md_fallback_frame_state_for
! (struct _Unwind_Context *context, _Unwind_FrameState *fs)
  {
    int i, status;
  
--- 56,68 ----
  #define DENOTES_BOTTOM_OF_STACK(icb) ((icb)->libicb$v_bottom_of_stack)
  
  #define FAIL_IF(COND) \
!    do { if (COND) { context->rp = 0; return _URC_END_OF_STACK; } } while (0)
  /* Clearing context->rp is required to prevent the ia64 gcc unwinder from
     attempting to keep on walking the call chain.  */
  
  static int
! ia64_vms_fallback_frame_state (struct _Unwind_Context *context,
! 			       _Unwind_FrameState *fs)
  {
    int i, status;
  
***************
*** 143,149 ****
    /* If this is not a dispatcher frame, this is certainly a frame for a leaf
       subprogram.  Use default unwind information.  */
    if (! DENOTES_VMS_DISPATCHER_FRAME (icb))
!     return UNW_FAILURE;
  
    /* At this point, we know we are really trying to unwind past an exception
       dispatcher frame, and have it described in ICB.  Proceed.  */
--- 142,148 ----
    /* If this is not a dispatcher frame, this is certainly a frame for a leaf
       subprogram.  Use default unwind information.  */
    if (! DENOTES_VMS_DISPATCHER_FRAME (icb))
!     return _URC_END_OF_STACK;
  
    /* At this point, we know we are really trying to unwind past an exception
       dispatcher frame, and have it described in ICB.  Proceed.  */
***************
*** 300,305 ****
      fs->curr.reg[UNW_REG_RP].when = -1;
    }
  
!   return UNW_SUCCESS;
  }
       
--- 299,304 ----
      fs->curr.reg[UNW_REG_RP].when = -1;
    }
  
!   return _URC_NO_REASON;
  }
       
*** gcc/config/alpha/alpha.c.ori	Wed Jan  9 12:46:28 2008
--- gcc/config/alpha/alpha.c	Wed Jan  9 14:26:19 2008
*************** alpha_initial_elimination_offset (unsign
*** 7447,7467 ****
    return ret;
  }
  
! int
! alpha_pv_save_size (void)
! {
!   alpha_sa_size ();
!   return alpha_procedure_type == PT_STACK ? 8 : 0;
! }
  
  int
! alpha_using_fp (void)
  {
    alpha_sa_size ();
-   return vms_unwind_regno == HARD_FRAME_POINTER_REGNUM;
- }
  
! #if TARGET_ABI_OPEN_VMS
  
  #define COMMON_OBJECT "common_object"
  
--- 7447,7541 ----
    return ret;
  }
  
! #if TARGET_ABI_OPEN_VMS
  
  int
! alpha_vms_can_eliminate (unsigned int from ATTRIBUTE_UNUSED, unsigned int to)
  {
+   /* We need the alpha_procedure_type to decide. Evaluate it now.  */
    alpha_sa_size ();
  
!   switch (alpha_procedure_type)
!     {
!     case PT_NULL:
!       /* NULL procedures have no frame of their own and we only
! 	 know how to resolve from the current stack pointer.  */
!       return to == STACK_POINTER_REGNUM;
! 
!     case PT_REGISTER:
!     case PT_STACK:
!       /* We always eliminate except to the stack pointer if there is no
! 	 usable frame pointer at hand.  */
!       return (to != STACK_POINTER_REGNUM
! 	      || vms_unwind_regno != HARD_FRAME_POINTER_REGNUM);
!     }
! 
!   gcc_unreachable ();
! }
! 
! /* FROM is to be eliminated for TO. Return the offset so that TO+offset
!    designates the same location as FROM.  */
! 
! HOST_WIDE_INT
! alpha_vms_initial_elimination_offset (unsigned int from, unsigned int to)
! { 
!   /* The only possible attempts we ever expect are ARG or FRAME_PTR to
!      HARD_FRAME or STACK_PTR.  We need the alpha_procedure_type to decide
!      on the proper computations and will need the register save area size
!      in most cases.  */
! 
!   HOST_WIDE_INT sa_size = alpha_sa_size ();
! 
!   /* PT_NULL procedures have no frame of their own and we only allow
!      elimination to the stack pointer. This is the argument pointer and we
!      resolve the soft frame pointer to that as well.  */
!      
!   if (alpha_procedure_type == PT_NULL)
!     return 0;
! 
!   /* For a PT_STACK procedure the frame layout looks as follows
! 
!                       -----> decreasing addresses
! 
! 		   <             size rounded up to 16       |   likewise   >
!      --------------#------------------------------+++--------------+++-------#
!      incoming args # pretended args | "frame" | regs sa | PV | outgoing args #
!      --------------#---------------------------------------------------------#
!                                    ^         ^              ^               ^
! 			      ARG_PTR FRAME_PTR HARD_FRAME_PTR       STACK_PTR
! 
! 			      
!      PT_REGISTER procedures are similar in that they may have a frame of their
!      own. They have no regs-sa/pv/outgoing-args area.
! 
!      We first compute offset to HARD_FRAME_PTR, then add what we need to get
!      to STACK_PTR if need be.  */
!   
!   {
!     HOST_WIDE_INT offset;
!     HOST_WIDE_INT pv_save_size = alpha_procedure_type == PT_STACK ? 8 : 0;
! 
!     switch (from)
!       {
!       case FRAME_POINTER_REGNUM:
! 	offset = ALPHA_ROUND (sa_size + pv_save_size);
! 	break;
!       case ARG_POINTER_REGNUM:
! 	offset = (ALPHA_ROUND (sa_size + pv_save_size
! 			       + get_frame_size ()
! 			       + current_function_pretend_args_size)
! 		  - current_function_pretend_args_size);
! 	break;
!       default:
! 	gcc_unreachable ();
!       }
!     
!     if (to == STACK_POINTER_REGNUM)
!       offset += ALPHA_ROUND (current_function_outgoing_args_size);
!     
!     return offset;
!   }
! }
  
  #define COMMON_OBJECT "common_object"
  
*** gcc/config/alpha/alpha-protos.h.ori	Fri Jan  4 17:34:24 2008
--- gcc/config/alpha/alpha-protos.h	Fri Jan  4 17:57:07 2008
*************** extern int direct_return (void);
*** 29,36 ****
  extern int alpha_sa_size (void);
  extern HOST_WIDE_INT alpha_initial_elimination_offset (unsigned int,
  						       unsigned int);
- extern int alpha_pv_save_size (void);
- extern int alpha_using_fp (void);
  extern void alpha_expand_prologue (void);
  extern void alpha_expand_epilogue (void);
  extern void alpha_output_filename (FILE *, const char *);
--- 29,34 ----
*************** extern void avms_asm_output_external (FI
*** 126,131 ****
--- 124,133 ----
  extern void vms_output_aligned_decl_common (FILE *, tree, const char *,
  					    unsigned HOST_WIDE_INT,
  					    unsigned int);
+ 
+ extern int alpha_vms_can_eliminate (unsigned int, unsigned int);
+ extern HOST_WIDE_INT alpha_vms_initial_elimination_offset (unsigned int,
+ 							   unsigned int);
  #endif
  
  extern rtx unicosmk_add_call_info_word (rtx);
*** gcc/config/alpha/vms.h.ori	Thu Jan  3 17:58:23 2008
--- gcc/config/alpha/vms.h	Fri Jan  4 17:32:20 2008
*************** Boston, MA 02111-1307, USA.  */
*** 139,166 ****
  #define EPILOGUE_USES(REGNO)    ((REGNO) == 26 || (REGNO) == 29)
  
  #undef CAN_ELIMINATE
! #define CAN_ELIMINATE(FROM, TO)  \
! ((TO) != STACK_POINTER_REGNUM || ! alpha_using_fp ())
  
  #undef INITIAL_ELIMINATION_OFFSET
  #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
! { switch (FROM)								\
!     {									\
!     case FRAME_POINTER_REGNUM:						\
!       (OFFSET) = ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ());\
!       break;								\
!     case ARG_POINTER_REGNUM:						\
!       (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()	\
! 			       + get_frame_size ()			\
! 			       + current_function_pretend_args_size)	\
! 		  - current_function_pretend_args_size);		\
!       break;								\
!     default:								\
!       gcc_unreachable ();						\
!     }									\
!   if ((TO) == STACK_POINTER_REGNUM)					\
!     (OFFSET) += ALPHA_ROUND (current_function_outgoing_args_size);	\
! }
  
  /* Define a data type for recording info about an argument list
     during the scan of that argument list.  This data type should
--- 139,150 ----
  #define EPILOGUE_USES(REGNO)    ((REGNO) == 26 || (REGNO) == 29)
  
  #undef CAN_ELIMINATE
! #define CAN_ELIMINATE(FROM, TO) \
!   (alpha_vms_can_eliminate ((FROM), (TO)))
  
  #undef INITIAL_ELIMINATION_OFFSET
  #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
!   ((OFFSET) = alpha_vms_initial_elimination_offset(FROM, TO))
  
  /* Define a data type for recording info about an argument list
     during the scan of that argument list.  This data type should
*** gcc/config/alpha/alpha.c.ori	Wed Jan  9 16:03:28 2008
--- gcc/config/alpha/alpha.c	Wed Jan  9 16:20:04 2008
*************** alpha_sa_size (void)
*** 7354,7363 ****
      }
    else if (TARGET_ABI_OPEN_VMS)
      {
!       /* Start by assuming we can use a register procedure if we don't
! 	 make any calls (REG_RA not used) or need to save any
! 	 registers and a stack procedure if we do.  */
!       if ((mask[0] >> REG_RA) & 1)
  	alpha_procedure_type = PT_STACK;
        else if (get_frame_size() != 0)
  	alpha_procedure_type = PT_REGISTER;
--- 7354,7363 ----
      }
    else if (TARGET_ABI_OPEN_VMS)
      {
!       /* Start with a stack procedure if we make any calls (REG_RA used), or
! 	 need a frame pointer, with a register procedure if we otherwise need
! 	 at least a slot, and with a null procedure in other cases.  */
!       if ((mask[0] >> REG_RA) & 1 || frame_pointer_needed)
  	alpha_procedure_type = PT_STACK;
        else if (get_frame_size() != 0)
  	alpha_procedure_type = PT_REGISTER;
*** gcc/config/alpha/vms.h.ori	Fri Jan 11 10:27:38 2008
--- gcc/config/alpha/vms.h	Fri Jan 11 10:29:11 2008
*************** Boston, MA 02111-1307, USA.  */
*** 73,78 ****
--- 73,82 ----
  
  #define MAX_OFILE_ALIGNMENT 524288  /* 8 x 2^16 by DEC Ada Test CD40VRA */
  
+ /* The maximum alignment 'malloc' honors.  */
+ #undef  MALLOC_ALIGNMENT
+ #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
+ 
  #undef FIXED_REGISTERS
  #define FIXED_REGISTERS  \
   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
*** libcpp/config.in.old	2005-11-19 19:47:13.000000000 +0100
--- libcpp/config.in	2008-01-16 13:49:36.076958286 +0100
***************
*** 260,265 ****
--- 260,268 ----
  /* Define if you can safely include both <string.h> and <strings.h>. */
  #undef STRING_WITH_STRINGS
  
+ /* Define to the object file suffix. */
+ #undef TARGET_OBJECT_SUFFIX
+ 
  /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
  #undef TIME_WITH_SYS_TIME
  
*** libcpp/configure.ac.old	2007-12-19 14:14:23.000000000 +0100
--- libcpp/configure.ac	2008-01-16 12:20:40.806330045 +0100
*************** case $need_64bit_hwint:$ac_cv_sizeof_lon
*** 138,149 ****
--- 138,159 ----
  	*:8 | no:*) host_wide_int=long ;;
  	*) host_wide_int='long long' ;;
  esac
+ 
+ case $target in
+ 	*-*-openvms* | *-*-vms* )
+ 		target_object_suffix=".obj" ;;
+ 	*)
+ 		target_object_suffix=".o" ;;
+ esac
  m4_changequote([,])
  
  AC_DEFINE_UNQUOTED(HOST_WIDE_INT, $host_wide_int,
  [Define to the widest efficient host integer type at least
     as wide as the target's size_t type.])
  
+ AC_DEFINE_UNQUOTED(TARGET_OBJECT_SUFFIX, "$target_object_suffix",
+ [Define to the object file suffix.])
+ 
  # Output.
  
  AC_CONFIG_HEADERS(config.h:config.in, [echo timestamp > stamp-h1])
*** gcc/cgraph.c.old	2008-01-16 16:35:12.000000000 +0100
--- gcc/cgraph.c	2008-01-17 12:32:52.092528923 +0100
*************** decl_assembler_name_equal (tree decl, tr
*** 224,229 ****
--- 224,231 ----
  
    if (decl_asmname == asmname)
      return true;
+   if (decl_asmname == NULL_TREE)
+     return false;
  
    /* If the target assembler name was set by the user, things are trickier.
       We have a leading '*' to begin with.  After that, it's arguable what
*** gcc/config/alpha/alpha.md.old	2008-01-16 16:35:15.000000000 +0100
--- gcc/config/alpha/alpha.md	2008-01-17 15:53:38.017655796 +0100
***************
*** 6767,6774 ****
        if (GET_CODE (operands[1]) != CONST_INT)
  	{
  	  out_label = gen_label_rtx ();
! 	  emit_insn (gen_cmpdi (want, tmp));
! 	  emit_jump_insn (gen_bgeu (out_label));
  	}
  
        emit_label (loop_label);
--- 6767,6774 ----
        if (GET_CODE (operands[1]) != CONST_INT)
  	{
  	  out_label = gen_label_rtx ();
! 	  emit_insn (gen_cmpdi (operands[1], GEN_INT(4096)));
! 	  emit_jump_insn (gen_bleu (out_label));
  	}
  
        emit_label (loop_label);
*** gcc/config/ia64/ia64.h.ori	Mon Jan 21 18:09:26 2008
--- gcc/config/ia64/ia64.h	Mon Jan 21 18:03:39 2008
*************** while (0)
*** 282,293 ****
  
  #define DOUBLE_TYPE_SIZE 64
  
! /* long double is XFmode normally, TFmode for HPUX and VMS.  */
  #define LONG_DOUBLE_TYPE_SIZE \
!   ((TARGET_HPUX || TARGET_ABI_OPEN_VMS) ? 128 : 80)
  
- /* We always want the XFmode operations from libgcc2.c.  */
- #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 80
  
  #define DEFAULT_SIGNED_CHAR 1
  
--- 282,298 ----
  
  #define DOUBLE_TYPE_SIZE 64
  
! /* long double is XFmode normally, and TFmode for HPUX.  It should be
!    TFmode for VMS as well but we only support up to DFmode now.  */
  #define LONG_DOUBLE_TYPE_SIZE \
!   (TARGET_HPUX ? 128 \
!    : TARGET_ABI_OPEN_VMS ? 64 \
!    : 80)
! 
! /* We always want the XFmode operations from libgcc2.c, except on VMS
!    where this yields references to unimplemented "insns".  */
! #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE  (TARGET_ABI_OPEN_VMS ? 64 : 80)
  
  
  #define DEFAULT_SIGNED_CHAR 1
  
*** gcc/config/ia64/vms_symvec_libgcc_s.opt.old	2008-01-22 13:41:01.936240746 +0100
--- gcc/config/ia64/vms_symvec_libgcc_s.opt	2008-01-22 13:42:03.568645208 +0100
*************** SYMBOL_VECTOR=(__fixunsdfti=PROCEDURE)
*** 41,52 ****
  SYMBOL_VECTOR=(__fixunsdfdi=PROCEDURE)
  SYMBOL_VECTOR=(__fixunssfti=PROCEDURE)
  SYMBOL_VECTOR=(__fixunssfdi=PROCEDURE)
- SYMBOL_VECTOR=(__fixunsxfti=PROCEDURE)
- SYMBOL_VECTOR=(__fixunsxfdi=PROCEDURE)
- SYMBOL_VECTOR=(__fixxfti=PROCEDURE)
  SYMBOL_VECTOR=(__floattidf=PROCEDURE)
  SYMBOL_VECTOR=(__floattisf=PROCEDURE)
- SYMBOL_VECTOR=(__floattixf=PROCEDURE)
  SYMBOL_VECTOR=(__lshrti3=PROCEDURE)
  SYMBOL_VECTOR=(__modti3=PROCEDURE)
  SYMBOL_VECTOR=(__multi3=PROCEDURE)
--- 41,48 ----
*** gcc/config/ia64/vms.h.old	2008-01-29 16:01:38.280752047 +0100
--- gcc/config/ia64/vms.h	2008-01-29 17:43:55.649304276 +0100
*************** Boston, MA 02111-1307, USA.  */
*** 60,65 ****
--- 60,68 ----
  #define POINTER_SIZE 32
  #define POINTERS_EXTEND_UNSIGNED 0
  
+ #undef MAX_OFILE_ALIGNMENT
+ #define MAX_OFILE_ALIGNMENT 524288  /* 8 x 2^16 by DEC Ada Test CD40VRA */
+ 
  /* Widest floating-point type efficiently supported by hardware and OS.  */
  #undef WIDEST_HARDWARE_FP_SIZE
  #define WIDEST_HARDWARE_FP_SIZE 64
*** gcc/config/ia64/ia64.c.ori	Tue Jan 29 10:39:58 2008
--- gcc/config/ia64/ia64.c	Wed Jan 30 17:32:31 2008
*************** ia64_function_arg (CUMULATIVE_ARGS *cum,
*** 4253,4260 ****
    int offset = ia64_function_arg_offset (cum, type, words);
    enum machine_mode hfa_mode = VOIDmode;
  
    if (TARGET_ABI_OPEN_VMS && mode == VOIDmode && type == void_type_node
!       && named == 1 && incoming == 0)
      {
        unsigned HOST_WIDE_INT regval = cum->words;
        int i;
--- 4253,4265 ----
    int offset = ia64_function_arg_offset (cum, type, words);
    enum machine_mode hfa_mode = VOIDmode;
  
+   /* For OPEN VMS, emit the instruction setting up the argument register here,
+      when we know this will be together with the other arguments setup related
+      insns.  This is not the conceptually best place to do this, but this is
+      the easiest as we have convenient access to cumulative args info.  */
+ 
    if (TARGET_ABI_OPEN_VMS && mode == VOIDmode && type == void_type_node
!       && named == 1)
      {
        unsigned HOST_WIDE_INT regval = cum->words;
        int i;
*** gcc/config/ia64/ia64.c.old	2008-02-07 16:31:05.494969460 +0100
--- gcc/config/ia64/ia64.c	2008-02-07 16:38:25.567906574 +0100
*************** ia64_function_arg_words (tree type, enum
*** 4228,4234 ****
  static int
  ia64_function_arg_offset (CUMULATIVE_ARGS *cum, tree type, int words)
  {
!   if ((cum->words & 1) == 0)
      return 0;
  
    if (type
--- 4228,4235 ----
  static int
  ia64_function_arg_offset (CUMULATIVE_ARGS *cum, tree type, int words)
  {
!   /* No registers are skipped on VMS.  */
!   if (TARGET_ABI_OPEN_VMS || (cum->words & 1) == 0)
      return 0;
  
    if (type
*************** ia64_function_arg (CUMULATIVE_ARGS *cum,
*** 4360,4365 ****
--- 4361,4375 ----
  	}
        return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));
      }
+   
+   /* On OpenVMS variable argument is either in Rn or Fn.  */
+   else if (TARGET_ABI_OPEN_VMS && named == 0)
+     {
+       if (FLOAT_MODE_P (mode))
+ 	return gen_rtx_REG (mode, FR_ARG_FIRST + cum->words);
+       else
+ 	return gen_rtx_REG (mode, basereg + cum->words);
+     }
  
    /* Integral and aggregates go in general registers.  If we have run out of
       FR registers, then FP values must also go in general registers.  This can
*************** ia64_arg_partial_bytes (CUMULATIVE_ARGS 
*** 4452,4458 ****
    return (MAX_ARGUMENT_SLOTS - cum->words - offset) * UNITS_PER_WORD;
  }
  
! enum ivms_arg_type
  ia64_arg_type (enum machine_mode mode)
  {
    switch (mode)
--- 4462,4468 ----
    return (MAX_ARGUMENT_SLOTS - cum->words - offset) * UNITS_PER_WORD;
  }
  
! static enum ivms_arg_type
  ia64_arg_type (enum machine_mode mode)
  {
    switch (mode)
*************** ia64_function_arg_advance (CUMULATIVE_AR
*** 4527,4532 ****
--- 4537,4549 ----
        cum->fp_regs = fp_regs;
      }
  
+   /* On OpenVMS variable argument is either in Rn or Fn.  */
+   else if (TARGET_ABI_OPEN_VMS && named == 0)
+     {
+       cum->int_regs = cum->words;
+       cum->fp_regs = cum->words;
+     }
+ 
    /* Integral and aggregates go in general registers.  So do TFmode FP values.
       If we have run out of FR registers, then other FP values must also go in
       general registers.  This can happen when we have a SFmode HFA.  */
*** gcc/config/ia64/vms.h.old	2008-02-07 17:31:25.804030893 +0100
--- gcc/config/ia64/vms.h	2008-02-07 17:47:04.856733725 +0100
*************** do {                                \
*** 127,132 ****
--- 127,135 ----
    fprintf (FILE, ")/16*3");         \
  } while (0)
  
+ #undef  DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET
+ #define DWARF2_LOCATION_LISTS_SUPPORT_MISSING_ON_TARGET 1
+ 
  #undef STARTFILE_SPEC
  #define STARTFILE_SPEC \
  "%{!shared:%{mvms-return-codes:vcrt0.o%s} %{!mvms-return-codes:pcrt0.o%s} \
*** gcc/config/ia64/ia64.c.old	2008-02-11 16:35:00.369255300 +0100
--- gcc/config/ia64/ia64.c	2008-02-11 17:22:02.329151012 +0100
*************** static bool ia64_vms_valid_pointer_mode 
*** 260,265 ****
--- 260,268 ----
       ATTRIBUTE_UNUSED;
  
  static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);
+ #if TARGET_ABI_OPEN_VMS
+ static tree ia64_vms_common_object_attribute (tree *, tree, tree, int, bool *);
+ #endif
  static void ia64_encode_section_info (tree, rtx, int);
  static rtx ia64_struct_value_rtx (tree, int);
  static tree ia64_gimplify_va_arg (tree, tree, tree *, tree *);
*************** static const struct attribute_spec ia64_
*** 277,282 ****
--- 280,288 ----
    /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
    { "syscall_linkage", 0, 0, false, true,  true,  NULL },
    { "model",	       1, 1, true, false, false, ia64_handle_model_attribute },
+ #if TARGET_ABI_OPEN_VMS
+   { "common_object",   1, 1, true, false, false, ia64_vms_common_object_attribute},
+ #endif
    { NULL,	       0, 0, false, false, false, NULL }
  };
  
*************** ia64_handle_model_attribute (tree *node,
*** 552,557 ****
--- 558,649 ----
    return NULL_TREE;
  }
  
+ #if TARGET_ABI_OPEN_VMS
+ 
+ /* The section must have global and overlaid attributes.  */
+ #define SECTION_VMS_OVERLAY SECTION_MACH_DEP
+ 
+ static tree
+ ia64_vms_common_object_attribute (tree *node, tree name ATTRIBUTE_UNUSED,
+ 				  tree args, int flags ATTRIBUTE_UNUSED,
+ 				  bool *no_add_attrs)
+ {
+     tree decl = *node;
+     tree id, val;
+     if (! DECL_P (decl))
+       abort ();
+   
+     DECL_COMMON (decl) = 1;
+     id = TREE_VALUE (args);
+     if (TREE_CODE (id) == IDENTIFIER_NODE)
+       val = build_string (IDENTIFIER_LENGTH (id), IDENTIFIER_POINTER (id));
+     else if (TREE_CODE (id) == STRING_CST)
+       val = id;
+     else
+       {
+ 	warning (OPT_Wattributes,
+ 		 "`%s' attribute requires a string constant argument",
+ 		 IDENTIFIER_POINTER (name));
+ 	*no_add_attrs = true;
+ 	return NULL_TREE;
+       }
+     DECL_SECTION_NAME (decl) = val;
+     return NULL_TREE;
+ }
+ 
+ void
+ ia64_vms_elf_asm_named_section (const char *name, unsigned int flags,
+ 				tree decl)
+ {
+   if (!(flags & SECTION_VMS_OVERLAY))
+     {
+       default_elf_asm_named_section (name, flags, decl);
+       return;
+     }
+   if (flags != (SECTION_VMS_OVERLAY | SECTION_WRITE))
+     abort ();
+ 
+   if (! named_section_first_declaration (name))
+     {
+       fprintf (asm_out_file, "\t.section\t%s\n", name);
+       return;
+     }
+ 
+   fprintf (asm_out_file, "\t.section\t%s,\"awgO\"\n", name);
+ }
+ 
+ void
+ ia64_vms_output_aligned_decl_common(FILE *file, tree decl, const char *name,
+ 				    unsigned HOST_WIDE_INT size,
+ 				    unsigned int align)
+ {
+   tree attr = DECL_ATTRIBUTES (decl);
+ 
+   /* As common_object attribute set DECL_SECTION_NAME check it before
+      looking up the attribute.  */
+   if (DECL_SECTION_NAME (decl) && attr)
+     attr = lookup_attribute ("common_object", attr);
+   else
+     attr = NULL_TREE;
+ 
+   if (!attr)
+     {
+       /*  Code from elfos.h  */
+       fprintf (file, "%s", COMMON_ASM_OP);
+       assemble_name (file, name);
+       fprintf (file, ","HOST_WIDE_INT_PRINT_UNSIGNED",%u\n",
+ 	       size, align / BITS_PER_UNIT);
+     }
+   else
+     {
+       ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
+       ASM_OUTPUT_LABEL (file, name);
+       ASM_OUTPUT_SKIP (file, size ? size : 1);
+     }
+ }
+ #endif /* TARGET_ABI_OPEN_VMS */
+ 
+ 
  static void
  ia64_encode_addr_area (tree decl, rtx symbol)
  {
*************** ia64_initialize_trampoline (rtx addr, rt
*** 4041,4046 ****
--- 4133,4139 ----
    emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), static_chain);
  }
  
+ #if 0
  void
  ia64_vms_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)
  {
*************** ia64_vms_initialize_trampoline (rtx addr
*** 4085,4090 ****
--- 4178,4184 ----
    /* The sixth word is the static chain.  */
    emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), static_chain);
  }
+ #endif /* 0 */
  
  /* Do any needed setup for a variadic function.  CUM has not been updated
     for the last named argument which has type TYPE and mode MODE.
*************** ia64_section_type_flags (tree decl, cons
*** 9105,9110 ****
--- 9199,9210 ----
        || strncmp (name, ".gnu.linkonce.sb.", 17) == 0)
      flags = SECTION_SMALL;
  
+ #if TARGET_ABI_OPEN_VMS
+   if (decl && DECL_ATTRIBUTES (decl)
+       && lookup_attribute ("common_object", DECL_ATTRIBUTES (decl)))
+     flags |= SECTION_VMS_OVERLAY;
+ #endif
+ 
    flags |= default_section_type_flags_1 (decl, name, reloc, TARGET_RWRELOC);
    return flags;
  }
*** gcc/config/ia64/ia64-protos.h.old	2008-02-11 16:35:00.160272377 +0100
--- gcc/config/ia64/ia64-protos.h	2008-02-11 17:11:01.063236204 +0100
*************** extern bool ia64_expand_load_address (rt
*** 66,71 ****
--- 66,72 ----
  extern int ia64_hard_regno_rename_ok (int, int);
  
  extern void ia64_initialize_trampoline (rtx, rtx, rtx);
+ extern void ia64_vms_initialize_trampoline (rtx, rtx, rtx);
  extern void ia64_print_operand_address (FILE *, rtx);
  extern void ia64_print_operand (FILE *, rtx, int);
  extern enum reg_class ia64_preferred_reload_class (rtx, enum reg_class);
*************** extern void ia64_function_arg_advance (C
*** 90,95 ****
--- 91,100 ----
  extern int ia64_function_arg_boundary (enum machine_mode, tree);
  extern void ia64_asm_output_external (FILE *, tree, const char *);
  extern void ia64_start_function (FILE *, const char *, tree);
+ extern void ia64_vms_output_aligned_decl_common (FILE *, tree, const char *,
+ 						 unsigned HOST_WIDE_INT,
+ 						 unsigned int);
+ extern void ia64_vms_elf_asm_named_section (const char *, unsigned int, tree);
  #endif /* TREE_CODE */
  
  extern int ia64_register_move_cost (enum machine_mode, enum reg_class,
*** gcc/config/ia64/vms.h.old	2008-02-11 16:35:00.370231855 +0100
--- gcc/config/ia64/vms.h	2008-02-11 17:11:15.974265437 +0100
*************** typedef struct crtl_name_spec
*** 266,268 ****
--- 266,275 ----
     overflow detection.  The default value conveys an estimate of the amount
     of stack required to propagate an exception.  */
  #define STACK_CHECK_PROTECT (24 * 1024)
+ 
+ #undef ASM_OUTPUT_ALIGNED_DECL_COMMON
+ #define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \
+   ia64_vms_output_aligned_decl_common (FILE, DECL, NAME, SIZE, ALIGN)
+ 
+ #undef TARGET_ASM_NAMED_SECTION
+ #define TARGET_ASM_NAMED_SECTION ia64_vms_elf_asm_named_section
--- gcc/config/ia64/vms.h.old	2008-02-22 16:09:38.152670044 -0800
+++ gcc/config/ia64/vms.h	2008-02-22 16:11:39.607129286 -0800
@@ -46,7 +46,7 @@
 
 /* Need .debug_line info generated from gcc and gas */
 #undef TARGET_DEFAULT
-#define TARGET_DEFAULT MASK_GNU_AS
+#define TARGET_DEFAULT (MASK_DWARF2_ASM | MASK_GNU_AS)
 
 #define VMS_DEBUG_MAIN_POINTER "TRANSFER$BREAK$GO"
 
--- gcc/config/alpha/vms64.h.1	2008-02-22 16:09:37.000000000 -0800
+++ gcc/config/alpha/vms64.h	2008-03-02 13:05:02.241573521 -0800
@@ -1,5 +1,5 @@
 /* Output variables, constants and external declarations, for GNU compiler.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001-2008 Free Software Foundation, Inc.
    Contributed by Douglas Rupp (rupp@gnat.com).
 
 This file is part of GCC.
@@ -27,13 +27,16 @@ Boston, MA 02111-1307, USA.  */
         builtin_define ("__ALPHA");             \
         builtin_assert ("system=vms");          \
         builtin_define ("__IEEE_FLOAT");        \
-        builtin_define ("__LONG_POINTERS=0");   \
+        builtin_define ("__LONG_POINTERS=1");   \
     } while (0)
 
 #undef SUBTARGET_SWITCHES
 #define SUBTARGET_SWITCHES \
   { "malloc64",    MASK_MALLOC64,     "Malloc data into P2 space" },
 
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_FPREGS | MASK_GAS | MASK_MALLOC64)
+
 #undef LONG_TYPE_SIZE
 #define LONG_TYPE_SIZE 64
 
--- gcc/config/ia64/vms64.h.1	2008-02-22 16:09:37.000000000 -0800
+++ gcc/config/ia64/vms64.h	2008-03-02 13:05:31.495907597 -0800
@@ -1,5 +1,5 @@
 /* Output variables, constants and external declarations, for GNU compiler.
-   Copyright (C) 2004 Free Software Foundation, Inc.
+   Copyright (C) 2004-2008 Free Software Foundation, Inc.
    Contributed by Douglas Rupp (rupp@gnat.com).
 
 This file is part of GCC.
@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */
 	builtin_define ("__IA64");		\
 	builtin_assert ("system=vms");		\
 	builtin_define ("__IEEE_FLOAT");	\
-	builtin_define ("__LONG_POINTERS=0");	\
+	builtin_define ("__LONG_POINTERS=1");	\
     } while (0)
 
 #undef LONG_TYPE_SIZE
@@ -36,4 +36,7 @@ Boston, MA 02111-1307, USA.  */
 #undef POINTER_SIZE
 #define POINTER_SIZE 64
 
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_DWARF2_ASM | MASK_GNU_AS | MASK_MALLOC64)
+
 #include "config/vms/vms-crtl-64.h"
--- gcc/config/ia64/ia64.c.1	2008-02-22 16:09:38.000000000 -0800
+++ gcc/config/ia64/ia64.c	2008-03-13 13:16:54.709316966 -0800
@@ -3543,7 +3543,8 @@ ia64_start_function (FILE *file, const c
     {
       targetm.asm_out.globalize_label (asm_out_file, VMS_DEBUG_MAIN_POINTER);
       ASM_OUTPUT_DEF (asm_out_file, VMS_DEBUG_MAIN_POINTER, fnname);
-      vms_debug_main = NULL;
+      dwarf2out_vms_debug_main_pointer ();
+      vms_debug_main = 0;
     }
 #endif
 
--- gcc/dwarf2out.c.1	2008-02-22 16:09:37.000000000 -0800
+++ gcc/dwarf2out.c	2008-03-13 15:10:54.954994687 -0800
@@ -3664,7 +3664,11 @@ const struct gcc_debug_hooks dwarf2_debu
   dwarf2out_ignore_block,
   dwarf2out_source_line,
   dwarf2out_begin_prologue,
-  debug_nothing_int_charstar,	/* end_prologue */
+#if TARGET_ABI_OPEN_VMS
+  dwarf2out_end_prologue,
+#else
+  debug_nothing_int_charstar,
+#endif
   dwarf2out_begin_epilogue,
   dwarf2out_end_epilogue,
   dwarf2out_begin_function,
@@ -3684,6 +3688,11 @@ const struct gcc_debug_hooks dwarf2_debu
   dwarf2out_switch_text_section,
   1                             /* start_end_main_source_file */
 };
+
+#if TARGET_ABI_OPEN_VMS
+static dw_die_ref vms_debug_main_subr_die = 0;
+void dwarf2out_vms_debug_main_pointer (void);
+#endif
 #endif
 
 /* NOTE: In the comments in this file, many references are made to
@@ -7384,6 +7393,12 @@ output_comp_unit (dw_die_ref die, int ou
   if (!output_if_empty && die->die_child == NULL)
     return;
 
+#if TARGET_ABI_OPEN_VMS
+  /* Debug main die must be the first child of the main comp unit */
+  if (vms_debug_main_subr_die)
+    splice_child_die (die, vms_debug_main_subr_die);
+#endif
+
   /* Even if there are no children of this DIE, we must output the information
      about the compilation unit.  Otherwise, on an empty translation unit, we
      will generate a present, but empty, .debug_info section.  IRIX 6.5 `nm'
@@ -11173,6 +11188,23 @@ add_name_and_src_coords_attributes (dw_d
 #endif
 }
 
+#if TARGET_ABI_OPEN_VMS
+
+/* Output the debug main pointer die for VMS */
+
+void
+dwarf2out_vms_debug_main_pointer (void)
+{
+  char label[MAX_ARTIFICIAL_LABEL_BYTES];
+
+  vms_debug_main_subr_die = new_die (DW_TAG_subprogram, comp_unit_die, NULL);
+  add_name_attribute (vms_debug_main_subr_die, VMS_DEBUG_MAIN_POINTER);
+  ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,
+			       current_function_funcdef_no);
+  add_AT_lbl_id (vms_debug_main_subr_die, DW_AT_entry_pc, label);
+}
+#endif
+
 /* Push a new declaration scope.  */
 
 static void
*** gcc/config/alpha/vms.h.ori	Thu Mar 20 17:36:52 2008
--- gcc/config/alpha/vms.h	Thu Mar 20 17:38:13 2008
*************** Boston, MA 02111-1307, USA.  */
*** 75,81 ****
  
  /* The maximum alignment 'malloc' honors.  */
  #undef  MALLOC_ALIGNMENT
! #define MALLOC_ALIGNMENT (8 * BITS_PER_UNIT)
  
  #undef FIXED_REGISTERS
  #define FIXED_REGISTERS  \
--- 75,81 ----
  
  /* The maximum alignment 'malloc' honors.  */
  #undef  MALLOC_ALIGNMENT
! #define MALLOC_ALIGNMENT ((TARGET_MALLOC64 ? 16 : 8) * BITS_PER_UNIT)
  
  #undef FIXED_REGISTERS
  #define FIXED_REGISTERS  \
--- gcc/config/alpha/vms.h.1	2008-05-26 15:19:37.591214179 -0700
+++ gcc/config/alpha/vms.h	2008-05-26 15:29:55.377625881 -0700
@@ -414,6 +414,7 @@ typedef struct crtl_name_spec
 #undef TARGET_ASM_OUTPUT_MI_THUNK
 
 #undef ASM_SPEC
+#define ASM_SPEC "%{source-listing:-ahdl=%b.lis}"
 #undef ASM_FINAL_SPEC
 
 /* The VMS convention is to always provide minimal debug info
--- gcc/config/ia64/vms.h.1	2008-05-26 15:16:15.490792716 -0700
+++ gcc/config/ia64/vms.h	2008-05-26 15:30:06.447841326 -0700
@@ -153,9 +153,9 @@ do {                                \
 #ifdef ASM_SPEC
 #undef ASM_SPEC
 #endif
-#define ASM_SPEC                                          \
-  "%{mno-gnu-as:-N so -N vms_upcase -W DVLoc_off}         \
-   %{mconstant-gp:-M const_gp} %{mauto-pic:-M no_plabel}"
+#define ASM_SPEC \
+"%{mno-gnu-as:-N so -N vms_upcase -W DVLoc_off} %{mconstant-gp:-M const_gp} \
+ %{mauto-pic:-M no_plabel} %{source-listing:-ahdl=%b.lis}"
 
 #undef ASM_OUTPUT_EXTERNAL_LIBCALL
 #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)			\
--- gcc/config/vms/vms.opt.1	2008-06-20 09:27:01.000000000 -0700
+++ gcc/config/vms/vms.opt	2008-06-19 20:57:25.000000000 -0700
@@ -1,6 +1,6 @@
 
 mmalloc64
-Target Report RejectNegative Mask(MALLOC64)
+Target Report Mask(MALLOC64)
 Malloc data into P2 space
 
 mdebug-main=
--- gcc/doc/invoke.texi.1	2008-06-20 09:27:01.000000000 -0700
+++ gcc/doc/invoke.texi	2008-06-23 11:11:00.186913491 -0700
@@ -488,7 +488,7 @@ Objective-C and Objective-C++ Dialects}.
 -mmemory-latency=@var{time}}
 
 @emph{DEC Alpha/VMS Options}
-@gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mmalloc64}
+@gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mno-malloc64}
 
 @emph{FRV Options}
 @gccoptlist{-mgpr-32  -mgpr-64  -mfpr-32  -mfpr-64 @gol
@@ -554,7 +554,7 @@ Objective-C and Objective-C++ Dialects}.
 -mtune=@var{cpu-type} -mt -pthread -milp32 -mlp64}
 
 @emph{IA-64/VMS Options}
-@gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mmalloc64}
+@gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mno-malloc64}
 
 @emph{M32R/D Options}
 @gccoptlist{-m32r2 -m32rx -m32r @gol
@@ -8629,9 +8629,9 @@ style condition (e.g.@ error) codes.
 Flag the first routine whose name starts with @var{prefix} as the main
 routine for the debugger.
 
-@item -mmalloc64
-@opindex mmalloc64
-Default to 64bit memory allocation routines.
+@item -mno-malloc64
+@opindex mno-malloc64
+Force 32bit memory allocation routines.
 @end table
 
 @node FRV Options
@@ -9843,9 +9843,9 @@ style condition (e.g.@ error) codes.
 Flag the first routine whose name starts with @var{prefix} as the main
 routine for the debugger.
 
-@item -mmalloc64
-@opindex mmalloc64
-Default to 64bit memory allocation routines.
+@item -mno-malloc64
+@opindex mno-malloc64
+Force 32bit memory allocation routines.
 @end table
 
 @node M32C Options
--- gcc/config/ia64/vms_symvec_libgcc_s.opt.1	2008-06-09 12:41:37.000000000 -0700
+++ gcc/config/ia64/vms_symvec_libgcc_s.opt	2008-07-19 02:38:24.175254656 -0700
@@ -72,6 +72,7 @@ SYMBOL_VECTOR=(__gcc_personality_v0=PROC
 SYMBOL_VECTOR=(_Unwind_GetGR=PROCEDURE)
 SYMBOL_VECTOR=(_Unwind_SetGR=PROCEDURE)
 SYMBOL_VECTOR=(_Unwind_GetIP=PROCEDURE)
+SYMBOL_VECTOR=(_Unwind_GetIPInfo=PROCEDURE)
 SYMBOL_VECTOR=(_Unwind_SetIP=PROCEDURE)
 SYMBOL_VECTOR=(_Unwind_GetLanguageSpecificData=PROCEDURE)
 SYMBOL_VECTOR=(_Unwind_GetRegionStart=PROCEDURE)
*** gcc/Makefile.in.old	2008-08-14 10:36:16.000000000 +0200
--- gcc/Makefile.in	2008-08-14 10:46:16.000000000 +0200
***************
*** 1340,1348 ****
  	LIBGCOV='$(LIBGCOV)' \
  	LIB2ADD='$(LIB2ADD)' \
  	LIB2ADD_ST='$(LIB2ADD_ST)' \
! 	LIB2ADDEH='$(LIB2ADDEH) $(srcdir)/emutls.c' \
! 	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC) $(srcdir)/emutls.c' \
! 	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED) $(srcdir)/emutls.c' \
  	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
  	LIB2_SIDITI_CONV_FUNCS='$(LIB2_SIDITI_CONV_FUNCS)' \
  	LIBUNWIND='$(LIBUNWIND)' \
--- 1340,1348 ----
  	LIBGCOV='$(LIBGCOV)' \
  	LIB2ADD='$(LIB2ADD)' \
  	LIB2ADD_ST='$(LIB2ADD_ST)' \
! 	LIB2ADDEH='$(LIB2ADDEH)' \
! 	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC)' \
! 	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED)' \
  	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
  	LIB2_SIDITI_CONV_FUNCS='$(LIB2_SIDITI_CONV_FUNCS)' \
  	LIBUNWIND='$(LIBUNWIND)' \
--- gcc/config/alpha/vms.h.1	2009-03-26 15:41:02.316574190 -0800
+++ gcc/config/alpha/vms.h	2009-03-26 15:45:53.932355668 -0800
@@ -435,8 +435,12 @@ typedef struct crtl_name_spec
 /* Link with vms-dwarf2.o if -g (except -g0). This causes the
    VMS link to pull all the dwarf2 debug sections together.  */
 #undef LINK_SPEC
-#define LINK_SPEC "%{g:-g vms-dwarf2.o%s} %{g0} %{g1:-g1 vms-dwarf2.o%s} \
-%{g2:-g2 vms-dwarf2.o%s} %{g3:-g3 vms-dwarf2.o%s} %{shared} %{v} %{map}"
+#define LINK_SPEC "%{g0} \
+%{g:-g vms-dwarf2.o%s}   %{gdwarf-2:-gdwarf-2 vms-dwarf2.o%s} \
+%{g1:-g1 vms-dwarf2.o%s} %{gdwarf-21:-gdwarf-21 vms-dwarf2.o%s} \
+%{g2:-g2 vms-dwarf2.o%s} %{gdwarf-22:-gdwarf-22 vms-dwarf2.o%s} \
+%{g3:-g3 vms-dwarf2.o%s} %{gdwarf-23:-gdwarf-23 vms-dwarf2.o%s} \
+%{shared} %{v} %{map}"
 
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC \
